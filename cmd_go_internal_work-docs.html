<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>work - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>work</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"bufio"
"bytes"
"fmt"
"internal/buildcfg"
"internal/platform"
"io"
"log"
"os"
"path/filepath"
"runtime"
"strings"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fips140"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/load"
"cmd/go/internal/str"
"cmd/internal/quoted"
"crypto/sha1"
"bytes"
"fmt"
"os"
"os/exec"
"path/filepath"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/load"
"cmd/go/internal/str"
"cmd/internal/pathcache"
"cmd/internal/pkgpath"
"fmt"
"internal/lazyregexp"
"regexp"
"strings"
"cmd/go/internal/cfg"
"cmd/go/internal/load"
"bytes"
"cmd/go/internal/base"
"cmd/go/internal/cache"
"cmd/go/internal/cfg"
"cmd/go/internal/load"
"cmd/go/internal/str"
"cmd/internal/par"
"cmd/internal/pathcache"
"errors"
"fmt"
"internal/lazyregexp"
"io"
"io/fs"
"os"
"os/exec"
"path/filepath"
"runtime"
"strconv"
"strings"
"sync"
"time"
"bufio"
"bytes"
"cmd/internal/cov/covcmd"
"container/heap"
"context"
"debug/elf"
"encoding/json"
"fmt"
"internal/platform"
"os"
"path/filepath"
"strings"
"sync"
"time"
"cmd/go/internal/base"
"cmd/go/internal/cache"
"cmd/go/internal/cfg"
"cmd/go/internal/load"
"cmd/go/internal/str"
"cmd/go/internal/trace"
"cmd/internal/buildid"
"cmd/internal/robustio"
"bytes"
"fmt"
"os"
"os/exec"
"strings"
"sync"
"cmd/go/internal/base"
"cmd/go/internal/cache"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/str"
"cmd/internal/buildid"
"cmd/internal/pathcache"
"cmd/internal/quoted"
"cmd/internal/telemetry/counter"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/str"
"cmd/internal/cov/covcmd"
"context"
"encoding/json"
"fmt"
"internal/coverage"
"io"
"os"
"path/filepath"
"bytes"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/modload"
"cmd/internal/quoted"
"fmt"
"internal/platform"
"os"
"os/exec"
"path/filepath"
"regexp"
"runtime"
"strconv"
"sync"
"context"
"errors"
"flag"
"fmt"
"go/build"
"os"
"path/filepath"
"runtime"
"strconv"
"strings"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/load"
"cmd/go/internal/modload"
"cmd/go/internal/search"
"cmd/go/internal/trace"
"cmd/internal/pathcache"
"bytes"
"cmd/internal/cov/covcmd"
"cmd/internal/pathcache"
"context"
"crypto/sha256"
"encoding/json"
"errors"
"fmt"
"go/token"
"internal/lazyregexp"
"io"
"io/fs"
"log"
"math/rand"
"os"
"os/exec"
"path/filepath"
"regexp"
"runtime"
"slices"
"sort"
"strconv"
"strings"
"sync"
"time"
"cmd/go/internal/base"
"cmd/go/internal/cache"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/load"
"cmd/go/internal/modload"
"cmd/go/internal/str"
"cmd/go/internal/trace"
"cmd/internal/buildid"
"cmd/internal/quoted"
"cmd/internal/sys"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="AllowInstall" data-name="AllowInstall">
               <h3>
                  AllowInstall 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#AllowInstall" class="anchor" title="Link to AllowInstall">#</a>
               </h3>
               
                  <p class="doc-comment">AllowInstall returns a non-nil error if this invocation of the go command is
allowed to install a.Target.
The build of cmd/go running under its own test is forbidden from installing
to its original GOROOT. The var is exported so it can be set by TestMain.</p>
               
               <pre><code class="language-go">var AllowInstall = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BuildToolchain" data-name="BuildToolchain">
               <h3>
                  BuildToolchain 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#BuildToolchain" class="anchor" title="Link to BuildToolchain">#</a>
               </h3>
               
               <pre><code class="language-go">var BuildToolchain toolchain = noToolchain{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="CmdBuild" data-name="CmdBuild">
               <h3>
                  CmdBuild 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#CmdBuild" class="anchor" title="Link to CmdBuild">#</a>
               </h3>
               
               <pre><code class="language-go">var CmdBuild = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="CmdInstall" data-name="CmdInstall">
               <h3>
                  CmdInstall 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#CmdInstall" class="anchor" title="Link to CmdInstall">#</a>
               </h3>
               
               <pre><code class="language-go">var CmdInstall = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DefaultBuildFlags" data-name="DefaultBuildFlags">
               <h3>
                  DefaultBuildFlags 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DefaultBuildFlags" class="anchor" title="Link to DefaultBuildFlags">#</a>
               </h3>
               
               <pre><code class="language-go">const DefaultBuildFlags BuildFlagMask = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DefaultCFlags" data-name="DefaultCFlags">
               <h3>
                  DefaultCFlags 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DefaultCFlags" class="anchor" title="Link to DefaultCFlags">#</a>
               </h3>
               
               <pre><code class="language-go">const DefaultCFlags = "-O2 -g"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ExecCmd" data-name="ExecCmd">
               <h3>
                  ExecCmd 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ExecCmd" class="anchor" title="Link to ExecCmd">#</a>
               </h3>
               
                  <p class="doc-comment">ExecCmd is the command to use to run user binaries.
Normally it is empty, meaning run the binaries directly.
If cross-compiling and running on a remote system or
simulator, it is typically go_GOOS_GOARCH_exec, with
the target GOOS and GOARCH substituted.
The -exec flag overrides these defaults.</p>
               
               <pre><code class="language-go">var ExecCmd []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="GccgoBin" data-name="GccgoBin">
               <h3>
                  GccgoBin 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#GccgoBin" class="anchor" title="Link to GccgoBin">#</a>
               </h3>
               
               <pre><code class="language-go">var GccgoBin string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="GccgoName" data-name="GccgoName">
               <h3>
                  GccgoName 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#GccgoName" class="anchor" title="Link to GccgoName">#</a>
               </h3>
               
               <pre><code class="language-go">var GccgoName string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeBuggyInstall" data-name="ModeBuggyInstall">
               <h3>
                  ModeBuggyInstall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeBuggyInstall" class="anchor" title="Link to ModeBuggyInstall">#</a>
               </h3>
               
               <pre><code class="language-go">const ModeBuggyInstall</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeBuild" data-name="ModeBuild">
               <h3>
                  ModeBuild 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeBuild" class="anchor" title="Link to ModeBuild">#</a>
               </h3>
               
               <pre><code class="language-go">const ModeBuild BuildMode = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeInstall" data-name="ModeInstall">
               <h3>
                  ModeInstall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeInstall" class="anchor" title="Link to ModeInstall">#</a>
               </h3>
               
               <pre><code class="language-go">const ModeInstall</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeVetOnly" data-name="ModeVetOnly">
               <h3>
                  ModeVetOnly 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeVetOnly" class="anchor" title="Link to ModeVetOnly">#</a>
               </h3>
               
               <pre><code class="language-go">const ModeVetOnly = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OmitBuildOnlyFlags" data-name="OmitBuildOnlyFlags">
               <h3>
                  OmitBuildOnlyFlags 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OmitBuildOnlyFlags" class="anchor" title="Link to OmitBuildOnlyFlags">#</a>
               </h3>
               
               <pre><code class="language-go">const OmitBuildOnlyFlags</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OmitJSONFlag" data-name="OmitJSONFlag">
               <h3>
                  OmitJSONFlag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OmitJSONFlag" class="anchor" title="Link to OmitJSONFlag">#</a>
               </h3>
               
               <pre><code class="language-go">const OmitJSONFlag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OmitModCommonFlags" data-name="OmitModCommonFlags">
               <h3>
                  OmitModCommonFlags 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OmitModCommonFlags" class="anchor" title="Link to OmitModCommonFlags">#</a>
               </h3>
               
               <pre><code class="language-go">const OmitModCommonFlags</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OmitModFlag" data-name="OmitModFlag">
               <h3>
                  OmitModFlag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OmitModFlag" class="anchor" title="Link to OmitModFlag">#</a>
               </h3>
               
               <pre><code class="language-go">const OmitModFlag BuildFlagMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OmitVFlag" data-name="OmitVFlag">
               <h3>
                  OmitVFlag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OmitVFlag" class="anchor" title="Link to OmitVFlag">#</a>
               </h3>
               
               <pre><code class="language-go">const OmitVFlag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ToolchainVersion" data-name="ToolchainVersion">
               <h3>
                  ToolchainVersion 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ToolchainVersion" class="anchor" title="Link to ToolchainVersion">#</a>
               </h3>
               
                  <p class="doc-comment">Tests can override this by setting $TESTGO_TOOLCHAIN_VERSION.</p>
               
               <pre><code class="language-go">var ToolchainVersion = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="VetExplicit" data-name="VetExplicit">
               <h3>
                  VetExplicit 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#VetExplicit" class="anchor" title="Link to VetExplicit">#</a>
               </h3>
               
                  <p class="doc-comment">VetExplicit records whether the vet flags were set explicitly on the command line.</p>
               
               <pre><code class="language-go">var VetExplicit bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="VetFlags" data-name="VetFlags">
               <h3>
                  VetFlags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#VetFlags" class="anchor" title="Link to VetFlags">#</a>
               </h3>
               
                  <p class="doc-comment">VetFlags are the default flags to pass to vet.
The caller is expected to set them before executing any vet actions.</p>
               
               <pre><code class="language-go">var VetFlags []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="VetTool" data-name="VetTool">
               <h3>
                  VetTool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#VetTool" class="anchor" title="Link to VetTool">#</a>
               </h3>
               
                  <p class="doc-comment">VetTool is the path to an alternate vet tool binary.
The caller is expected to set it (if needed) before executing any vet actions.</p>
               
               <pre><code class="language-go">var VetTool string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="buildIDSeparator" data-name="buildIDSeparator">
               <h3>
                  buildIDSeparator 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#buildIDSeparator" class="anchor" title="Link to buildIDSeparator">#</a>
               </h3>
               
               <pre><code class="language-go">const buildIDSeparator = "/"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="buildInitStarted" data-name="buildInitStarted">
               <h3>
                  buildInitStarted 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#buildInitStarted" class="anchor" title="Link to buildInitStarted">#</a>
               </h3>
               
               <pre><code class="language-go">var buildInitStarted = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="builderWorkDirs" data-name="builderWorkDirs">
               <h3>
                  builderWorkDirs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#builderWorkDirs" class="anchor" title="Link to builderWorkDirs">#</a>
               </h3>
               
               <pre><code class="language-go">var builderWorkDirs sync.Map</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cgoLine" data-name="cgoLine">
               <h3>
                  cgoLine 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cgoLine" class="anchor" title="Link to cgoLine">#</a>
               </h3>
               
               <pre><code class="language-go">var cgoLine = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cgoRe" data-name="cgoRe">
               <h3>
                  cgoRe 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cgoRe" class="anchor" title="Link to cgoRe">#</a>
               </h3>
               
               <pre><code class="language-go">var cgoRe = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cgoTypeSigRe" data-name="cgoTypeSigRe">
               <h3>
                  cgoTypeSigRe 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cgoTypeSigRe" class="anchor" title="Link to cgoTypeSigRe">#</a>
               </h3>
               
               <pre><code class="language-go">var cgoTypeSigRe = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="compiler" data-name="compiler">
               <h3>
                  compiler 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#compiler" class="anchor" title="Link to compiler">#</a>
               </h3>
               
               <pre><code class="language-go">var compiler struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="concurrentGCBackendCompilationEnabledByDefault" data-name="concurrentGCBackendCompilationEnabledByDefault">
               <h3>
                  concurrentGCBackendCompilationEnabledByDefault 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#concurrentGCBackendCompilationEnabledByDefault" class="anchor" title="Link to concurrentGCBackendCompilationEnabledByDefault">#</a>
               </h3>
               
               <pre><code class="language-go">const concurrentGCBackendCompilationEnabledByDefault = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="counterCacheHit" data-name="counterCacheHit">
               <h3>
                  counterCacheHit 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#counterCacheHit" class="anchor" title="Link to counterCacheHit">#</a>
               </h3>
               
               <pre><code class="language-go">var counterCacheHit = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="counterCacheMiss" data-name="counterCacheMiss">
               <h3>
                  counterCacheMiss 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#counterCacheMiss" class="anchor" title="Link to counterCacheMiss">#</a>
               </h3>
               
               <pre><code class="language-go">var counterCacheMiss = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="forcedAsmflags" data-name="forcedAsmflags">
               <h3>
                  forcedAsmflags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#forcedAsmflags" class="anchor" title="Link to forcedAsmflags">#</a>
               </h3>
               
               <pre><code class="language-go">var forcedAsmflags []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="forcedGccgoflags" data-name="forcedGccgoflags">
               <h3>
                  forcedGccgoflags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#forcedGccgoflags" class="anchor" title="Link to forcedGccgoflags">#</a>
               </h3>
               
               <pre><code class="language-go">var forcedGccgoflags []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="forcedGcflags" data-name="forcedGcflags">
               <h3>
                  forcedGcflags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#forcedGcflags" class="anchor" title="Link to forcedGcflags">#</a>
               </h3>
               
               <pre><code class="language-go">var forcedGcflags []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="forcedLdflags" data-name="forcedLdflags">
               <h3>
                  forcedLdflags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#forcedLdflags" class="anchor" title="Link to forcedLdflags">#</a>
               </h3>
               
               <pre><code class="language-go">var forcedLdflags []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoErr" data-name="gccgoErr">
               <h3>
                  gccgoErr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gccgoErr" class="anchor" title="Link to gccgoErr">#</a>
               </h3>
               
               <pre><code class="language-go">var gccgoErr error</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoSupportsCgoIncomplete" data-name="gccgoSupportsCgoIncomplete">
               <h3>
                  gccgoSupportsCgoIncomplete 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gccgoSupportsCgoIncomplete" class="anchor" title="Link to gccgoSupportsCgoIncomplete">#</a>
               </h3>
               
               <pre><code class="language-go">var gccgoSupportsCgoIncomplete bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoSupportsCgoIncompleteCode" data-name="gccgoSupportsCgoIncompleteCode">
               <h3>
                  gccgoSupportsCgoIncompleteCode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoSupportsCgoIncompleteCode" class="anchor" title="Link to gccgoSupportsCgoIncompleteCode">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoSupportsCgoIncompleteCode = `
package p

import "runtime/cgo"

type I cgo.Incomplete
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoSupportsCgoIncompleteOnce" data-name="gccgoSupportsCgoIncompleteOnce">
               <h3>
                  gccgoSupportsCgoIncompleteOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gccgoSupportsCgoIncompleteOnce" class="anchor" title="Link to gccgoSupportsCgoIncompleteOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var gccgoSupportsCgoIncompleteOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoToSymbolFunc" data-name="gccgoToSymbolFunc">
               <h3>
                  gccgoToSymbolFunc 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gccgoToSymbolFunc" class="anchor" title="Link to gccgoToSymbolFunc">#</a>
               </h3>
               
               <pre><code class="language-go">var gccgoToSymbolFunc func(string) string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoToSymbolFuncOnce" data-name="gccgoToSymbolFuncOnce">
               <h3>
                  gccgoToSymbolFuncOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#gccgoToSymbolFuncOnce" class="anchor" title="Link to gccgoToSymbolFuncOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var gccgoToSymbolFuncOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="invalidLinkerFlags" data-name="invalidLinkerFlags">
               <h3>
                  invalidLinkerFlags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#invalidLinkerFlags" class="anchor" title="Link to invalidLinkerFlags">#</a>
               </h3>
               
               <pre><code class="language-go">var invalidLinkerFlags = []*lazyregexp.Regexp{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ldBuildmode" data-name="ldBuildmode">
               <h3>
                  ldBuildmode 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ldBuildmode" class="anchor" title="Link to ldBuildmode">#</a>
               </h3>
               
               <pre><code class="language-go">var ldBuildmode string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="needBuild" data-name="needBuild">
               <h3>
                  needBuild 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#needBuild" class="anchor" title="Link to needBuild">#</a>
               </h3>
               
               <pre><code class="language-go">const needBuild uint32 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="needCgoHdr" data-name="needCgoHdr">
               <h3>
                  needCgoHdr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#needCgoHdr" class="anchor" title="Link to needCgoHdr">#</a>
               </h3>
               
               <pre><code class="language-go">const needCgoHdr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="needCompiledGoFiles" data-name="needCompiledGoFiles">
               <h3>
                  needCompiledGoFiles 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#needCompiledGoFiles" class="anchor" title="Link to needCompiledGoFiles">#</a>
               </h3>
               
               <pre><code class="language-go">const needCompiledGoFiles</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="needCovMetaFile" data-name="needCovMetaFile">
               <h3>
                  needCovMetaFile 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#needCovMetaFile" class="anchor" title="Link to needCovMetaFile">#</a>
               </h3>
               
               <pre><code class="language-go">const needCovMetaFile</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="needStale" data-name="needStale">
               <h3>
                  needStale 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#needStale" class="anchor" title="Link to needStale">#</a>
               </h3>
               
               <pre><code class="language-go">const needStale</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="needVet" data-name="needVet">
               <h3>
                  needVet 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#needVet" class="anchor" title="Link to needVet">#</a>
               </h3>
               
               <pre><code class="language-go">const needVet</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="objectMagic" data-name="objectMagic">
               <h3>
                  objectMagic 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#objectMagic" class="anchor" title="Link to objectMagic">#</a>
               </h3>
               
               <pre><code class="language-go">var objectMagic = [][]byte{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pkgsFilter" data-name="pkgsFilter">
               <h3>
                  pkgsFilter 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#pkgsFilter" class="anchor" title="Link to pkgsFilter">#</a>
               </h3>
               
               <pre><code class="language-go">var pkgsFilter = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="re" data-name="re">
               <h3>
                  re 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#re" class="anchor" title="Link to re">#</a>
               </h3>
               
               <pre><code class="language-go">var re = lazyregexp.New</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdlibRecompiled" data-name="stdlibRecompiled">
               <h3>
                  stdlibRecompiled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#stdlibRecompiled" class="anchor" title="Link to stdlibRecompiled">#</a>
               </h3>
               
               <pre><code class="language-go">var stdlibRecompiled = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdlibRecompiledIncOnce" data-name="stdlibRecompiledIncOnce">
               <h3>
                  stdlibRecompiledIncOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#stdlibRecompiledIncOnce" class="anchor" title="Link to stdlibRecompiledIncOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var stdlibRecompiledIncOnce = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="swigCheck" data-name="swigCheck">
               <h3>
                  swigCheck 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#swigCheck" class="anchor" title="Link to swigCheck">#</a>
               </h3>
               
                  <p class="doc-comment">Make sure SWIG is new enough.</p>
               
               <pre><code class="language-go">var swigCheck error</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="swigCheckOnce" data-name="swigCheckOnce">
               <h3>
                  swigCheckOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#swigCheckOnce" class="anchor" title="Link to swigCheckOnce">#</a>
               </h3>
               
                  <p class="doc-comment">Make sure SWIG is new enough.</p>
               
               <pre><code class="language-go">var swigCheckOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="swigIntSize" data-name="swigIntSize">
               <h3>
                  swigIntSize 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#swigIntSize" class="anchor" title="Link to swigIntSize">#</a>
               </h3>
               
                  <p class="doc-comment">Find the value to pass for the -intgosize option to swig.</p>
               
               <pre><code class="language-go">var swigIntSize string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="swigIntSizeCode" data-name="swigIntSizeCode">
               <h3>
                  swigIntSizeCode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#swigIntSizeCode" class="anchor" title="Link to swigIntSizeCode">#</a>
               </h3>
               
                  <p class="doc-comment">This code fails to build if sizeof(int) <= 32</p>
               
               <pre><code class="language-go">const swigIntSizeCode = `
package main
const i int = 1 << 32
`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="swigIntSizeError" data-name="swigIntSizeError">
               <h3>
                  swigIntSizeError 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#swigIntSizeError" class="anchor" title="Link to swigIntSizeError">#</a>
               </h3>
               
                  <p class="doc-comment">Find the value to pass for the -intgosize option to swig.</p>
               
               <pre><code class="language-go">var swigIntSizeError error</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="swigIntSizeOnce" data-name="swigIntSizeOnce">
               <h3>
                  swigIntSizeOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#swigIntSizeOnce" class="anchor" title="Link to swigIntSizeOnce">#</a>
               </h3>
               
                  <p class="doc-comment">Find the value to pass for the -intgosize option to swig.</p>
               
               <pre><code class="language-go">var swigIntSizeOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="validCompilerFlags" data-name="validCompilerFlags">
               <h3>
                  validCompilerFlags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#validCompilerFlags" class="anchor" title="Link to validCompilerFlags">#</a>
               </h3>
               
               <pre><code class="language-go">var validCompilerFlags = []*lazyregexp.Regexp{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="validCompilerFlagsWithNextArg" data-name="validCompilerFlagsWithNextArg">
               <h3>
                  validCompilerFlagsWithNextArg 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#validCompilerFlagsWithNextArg" class="anchor" title="Link to validCompilerFlagsWithNextArg">#</a>
               </h3>
               
               <pre><code class="language-go">var validCompilerFlagsWithNextArg = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="validLinkerFlags" data-name="validLinkerFlags">
               <h3>
                  validLinkerFlags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#validLinkerFlags" class="anchor" title="Link to validLinkerFlags">#</a>
               </h3>
               
               <pre><code class="language-go">var validLinkerFlags = []*lazyregexp.Regexp{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="validLinkerFlagsWithNextArg" data-name="validLinkerFlagsWithNextArg">
               <h3>
                  validLinkerFlagsWithNextArg 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#validLinkerFlagsWithNextArg" class="anchor" title="Link to validLinkerFlagsWithNextArg">#</a>
               </h3>
               
               <pre><code class="language-go">var validLinkerFlagsWithNextArg = []string{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ActorFunc" data-name="ActorFunc">
               <h3>
                  ActorFunc
                  <span class="badge type-badge">type</span>
                  <a href="#ActorFunc" class="anchor" title="Link to ActorFunc">#</a>
               </h3>
               
               <p>An ActorFunc is an Actor that calls the function.</p>
               
               <pre><code class="language-go">type ActorFunc func(*Builder, context.Context, *Action) error</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="BuildFlagMask" data-name="BuildFlagMask">
               <h3>
                  BuildFlagMask
                  <span class="badge type-badge">type</span>
                  <a href="#BuildFlagMask" class="anchor" title="Link to BuildFlagMask">#</a>
               </h3>
               
               <pre><code class="language-go">type BuildFlagMask int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="BuildMode" data-name="BuildMode">
               <h3>
                  BuildMode
                  <span class="badge type-badge">type</span>
                  <a href="#BuildMode" class="anchor" title="Link to BuildMode">#</a>
               </h3>
               
               <p>BuildMode specifies the build mode:
are we just building things or also installing the results?</p>
               
               <pre><code class="language-go">type BuildMode int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="actionQueue" data-name="actionQueue">
               <h3>
                  actionQueue
                  <span class="badge type-badge">type</span>
                  <a href="#actionQueue" class="anchor" title="Link to actionQueue">#</a>
               </h3>
               
               <p>An actionQueue is a priority queue of actions.</p>
               
               <pre><code class="language-go">type actionQueue []*Action</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="buildvcsFlag" data-name="buildvcsFlag">
               <h3>
                  buildvcsFlag
                  <span class="badge type-badge">type</span>
                  <a href="#buildvcsFlag" class="anchor" title="Link to buildvcsFlag">#</a>
               </h3>
               
               <p>buildvcsFlag is the implementation of the -buildvcs flag.</p>
               
               <pre><code class="language-go">type buildvcsFlag string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="coverModeFlag" data-name="coverModeFlag">
               <h3>
                  coverModeFlag
                  <span class="badge type-badge">type</span>
                  <a href="#coverModeFlag" class="anchor" title="Link to coverModeFlag">#</a>
               </h3>
               
               <pre><code class="language-go">type coverModeFlag string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="tagsFlag" data-name="tagsFlag">
               <h3>
                  tagsFlag
                  <span class="badge type-badge">type</span>
                  <a href="#tagsFlag" class="anchor" title="Link to tagsFlag">#</a>
               </h3>
               
               <p>tagsFlag is the implementation of the -tags flag.</p>
               
               <pre><code class="language-go">type tagsFlag []string</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Actor" data-name="Actor">
               <h3>
                  Actor
                  <span class="badge interface-badge">interface</span>
                  <a href="#Actor" class="anchor" title="Link to Actor">#</a>
               </h3>
               
               <p>An Actor runs an action.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Actor interface {
Act(*Builder, context.Context, *Action) error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="toolchain" data-name="toolchain">
               <h3>
                  toolchain
                  <span class="badge interface-badge">interface</span>
                  <a href="#toolchain" class="anchor" title="Link to toolchain">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type toolchain interface {
gc(b *Builder, a *Action, archive string, importcfg []byte, embedcfg []byte, symabis string, asmhdr bool, pgoProfile string, gofiles []string) (ofile string, out []byte, err error)
cc(b *Builder, a *Action, ofile string, cfile string) error
asm(b *Builder, a *Action, sfiles []string) ([]string, error)
symabis(b *Builder, a *Action, sfiles []string) (string, error)
pack(b *Builder, a *Action, afile string, ofiles []string) error
ld(b *Builder, root *Action, targetPath string, importcfg string, mainpkg string) error
ldShared(b *Builder, root *Action, toplevelactions []*Action, targetPath string, importcfg string, allactions []*Action) error
compiler() string
linker() string
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Action" data-name="Action">
               <h3>
                  Action
                  <span class="badge">struct</span>
                  <a href="#Action" class="anchor" title="Link to Action">#</a>
               </h3>
               
               <p>An Action represents a single action in the action graph.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Action struct {
Mode string
Package *load.Package
Deps []*Action
Actor Actor
IgnoreFail bool
TestOutput *bytes.Buffer
Args []string
triggers []*Action
buggyInstall bool
TryCache func(*Builder, *Action) bool
CacheExecutable bool
Objdir string
Target string
built string
actionID cache.ActionID
buildID string
VetxOnly bool
needVet bool
needBuild bool
vetCfg *vetConfig
output []byte
sh *Shell
pending int
priority int
Failed *Action
json *actionJSON
nonGoOverlay map[string]string
traceSpan *trace.Span
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Builder" data-name="Builder">
               <h3>
                  Builder
                  <span class="badge">struct</span>
                  <a href="#Builder" class="anchor" title="Link to Builder">#</a>
               </h3>
               
               <p>A Builder holds global state about a build.
It does not hold per-package state, because we
build packages in parallel, and the builder is shared.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Builder struct {
WorkDir string
actionCache map[cacheKey]*Action
flagCache map[[2]string]bool
gccCompilerIDCache map[string]cache.ActionID
IsCmdList bool
NeedError bool
NeedExport bool
NeedCompiledGoFiles bool
AllowErrors bool
objdirSeq int
pkgSeq int
backgroundSh *Shell
exec sync.Mutex
readySema chan bool
ready actionQueue
id sync.Mutex
toolIDCache map[string]string
buildIDCache map[string]string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Shell" data-name="Shell">
               <h3>
                  Shell
                  <span class="badge">struct</span>
                  <a href="#Shell" class="anchor" title="Link to Shell">#</a>
               </h3>
               
               <p>A Shell runs shell commands and performs shell-like file system operations.
Shell tracks context related to running commands, and form a tree much like
context.Context.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Shell struct {
action *Action
*shellShared
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="actionJSON" data-name="actionJSON">
               <h3>
                  actionJSON
                  <span class="badge">struct</span>
                  <a href="#actionJSON" class="anchor" title="Link to actionJSON">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type actionJSON struct {
ID int
Mode string
Package string
Deps []int `json:",omitempty"`
IgnoreFail bool `json:",omitempty"`
Args []string `json:",omitempty"`
Link bool `json:",omitempty"`
Objdir string `json:",omitempty"`
Target string `json:",omitempty"`
Priority int `json:",omitempty"`
Failed bool `json:",omitempty"`
Built string `json:",omitempty"`
VetxOnly bool `json:",omitempty"`
NeedVet bool `json:",omitempty"`
NeedBuild bool `json:",omitempty"`
ActionID string `json:",omitempty"`
BuildID string `json:",omitempty"`
TimeReady time.Time `json:",omitempty"`
TimeStart time.Time `json:",omitempty"`
TimeDone time.Time `json:",omitempty"`
Cmd []string
CmdReal time.Duration `json:",omitempty"`
CmdUser time.Duration `json:",omitempty"`
CmdSys time.Duration `json:",omitempty"`
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="buildActor" data-name="buildActor">
               <h3>
                  buildActor
                  <span class="badge">struct</span>
                  <a href="#buildActor" class="anchor" title="Link to buildActor">#</a>
               </h3>
               
               <p>buildActor implements the Actor interface for package build
actions. For most package builds this simply means invoking th
*Builder.build method; in the case of "go test -cover" for
a package with no test files, we stores some additional state
information in the build actor to help with reporting.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type buildActor struct {
covMetaFileName string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="buildCompiler" data-name="buildCompiler">
               <h3>
                  buildCompiler
                  <span class="badge">struct</span>
                  <a href="#buildCompiler" class="anchor" title="Link to buildCompiler">#</a>
               </h3>
               
               <p>buildCompiler implements flag.Var.
It implements Set by updating both
BuildToolchain and buildContext.Compiler.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type buildCompiler struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cacheKey" data-name="cacheKey">
               <h3>
                  cacheKey
                  <span class="badge">struct</span>
                  <a href="#cacheKey" class="anchor" title="Link to cacheKey">#</a>
               </h3>
               
               <p>cacheKey is the key for the action cache.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cacheKey struct {
mode string
p *load.Package
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cmdError" data-name="cmdError">
               <h3>
                  cmdError
                  <span class="badge">struct</span>
                  <a href="#cmdError" class="anchor" title="Link to cmdError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cmdError struct {
desc string
text string
importPath string
needsPath bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="commaListFlag" data-name="commaListFlag">
               <h3>
                  commaListFlag
                  <span class="badge">struct</span>
                  <a href="#commaListFlag" class="anchor" title="Link to commaListFlag">#</a>
               </h3>
               
               <p>A commaListFlag is a flag.Value representing a comma-separated list.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type commaListFlag struct {
Vals *[]string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="coverFlag" data-name="coverFlag">
               <h3>
                  coverFlag
                  <span class="badge">struct</span>
                  <a href="#coverFlag" class="anchor" title="Link to coverFlag">#</a>
               </h3>
               
               <p>A coverFlag is a flag.Value that also implies -cover.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type coverFlag struct {
V flag.Value
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="gcToolchain" data-name="gcToolchain">
               <h3>
                  gcToolchain
                  <span class="badge">struct</span>
                  <a href="#gcToolchain" class="anchor" title="Link to gcToolchain">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type gcToolchain struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="gccgoToolchain" data-name="gccgoToolchain">
               <h3>
                  gccgoToolchain
                  <span class="badge">struct</span>
                  <a href="#gccgoToolchain" class="anchor" title="Link to gccgoToolchain">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type gccgoToolchain struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="noToolchain" data-name="noToolchain">
               <h3>
                  noToolchain
                  <span class="badge">struct</span>
                  <a href="#noToolchain" class="anchor" title="Link to noToolchain">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type noToolchain struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pgoActor" data-name="pgoActor">
               <h3>
                  pgoActor
                  <span class="badge">struct</span>
                  <a href="#pgoActor" class="anchor" title="Link to pgoActor">#</a>
               </h3>
               
               <p>pgoActor implements the Actor interface for preprocessing PGO profiles.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type pgoActor struct {
input string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="shellShared" data-name="shellShared">
               <h3>
                  shellShared
                  <span class="badge">struct</span>
                  <a href="#shellShared" class="anchor" title="Link to shellShared">#</a>
               </h3>
               
               <p>shellShared is Shell state shared across all Shells derived from a single
root shell (generally a single Builder).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type shellShared struct {
workDir string
printLock sync.Mutex
printer load.Printer
scriptDir string
mkdirCache *ast.IndexListExpr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="stringFlag" data-name="stringFlag">
               <h3>
                  stringFlag
                  <span class="badge">struct</span>
                  <a href="#stringFlag" class="anchor" title="Link to stringFlag">#</a>
               </h3>
               
               <p>A stringFlag is a flag.Value representing a single string.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type stringFlag struct {
val *string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="version" data-name="version">
               <h3>
                  version
                  <span class="badge">struct</span>
                  <a href="#version" class="anchor" title="Link to version">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type version struct {
name string
major int
minor int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="vetConfig" data-name="vetConfig">
               <h3>
                  vetConfig
                  <span class="badge">struct</span>
                  <a href="#vetConfig" class="anchor" title="Link to vetConfig">#</a>
               </h3>
               
               <p>vetConfig is the configuration passed to vet describing a single package.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type vetConfig struct {
ID string
Compiler string
Dir string
ImportPath string
GoFiles []string
NonGoFiles []string
IgnoredFiles []string
ModulePath string
ModuleVersion string
ImportMap map[string]string
PackageFile map[string]string
Standard map[string]bool
PackageVetx map[string]string
VetxOnly bool
VetxOutput string
GoVersion string
SucceedOnTypecheckFailure bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Act" data-name="Act">
               <h3>
                  Act 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Act" class="anchor" title="Link to Act">#</a>
               </h3>
               
               <pre><code class="language-go">func (f ActorFunc) Act(b *Builder, ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Act" data-name="Act">
               <h3>
                  Act 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Act" class="anchor" title="Link to Act">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *pgoActor) Act(b *Builder, ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Act" data-name="Act">
               <h3>
                  Act 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Act" class="anchor" title="Link to Act">#</a>
               </h3>
               
               <pre><code class="language-go">func (ba *buildActor) Act(b *Builder, ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddBuildFlags" data-name="AddBuildFlags">
               <h3>
                  AddBuildFlags 
                  <span class="badge">function</span>
                  
                  <a href="#AddBuildFlags" class="anchor" title="Link to AddBuildFlags">#</a>
               </h3>
               
               <p>AddBuildFlags adds the flags common to the build, clean, get,
install, list, run, and test commands.</p>
               
               <pre><code class="language-go">func AddBuildFlags(cmd *base.Command, mask BuildFlagMask)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddCoverFlags" data-name="AddCoverFlags">
               <h3>
                  AddCoverFlags 
                  <span class="badge">function</span>
                  
                  <a href="#AddCoverFlags" class="anchor" title="Link to AddCoverFlags">#</a>
               </h3>
               
               <p>AddCoverFlags adds coverage-related flags to "cmd". If the
CoverageRedesign experiment is enabled, we add -cover{mode,pkg} to
the build command and only -coverprofile to the test command. If
the CoverageRedesign experiment is disabled, -cover* flags are
added only to the test command.</p>
               
               <pre><code class="language-go">func AddCoverFlags(cmd *base.Command, coverProfileFlag *string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AutoAction" data-name="AutoAction">
               <h3>
                  AutoAction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AutoAction" class="anchor" title="Link to AutoAction">#</a>
               </h3>
               
               <p>AutoAction returns the "right" action for go build or go install of p.</p>
               
               <pre><code class="language-go">func (b *Builder) AutoAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BackgroundShell" data-name="BackgroundShell">
               <h3>
                  BackgroundShell 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BackgroundShell" class="anchor" title="Link to BackgroundShell">#</a>
               </h3>
               
               <p>BackgroundShell returns a Builder-wide Shell that's not bound to any Action.
Try not to use this unless there's really no sensible Action available.</p>
               
               <pre><code class="language-go">func (b *Builder) BackgroundShell() *Shell</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BuildActionCoverMetaFile" data-name="BuildActionCoverMetaFile">
               <h3>
                  BuildActionCoverMetaFile 
                  <span class="badge">function</span>
                  
                  <a href="#BuildActionCoverMetaFile" class="anchor" title="Link to BuildActionCoverMetaFile">#</a>
               </h3>
               
               <p>BuildActionCoverMetaFile locates and returns the path of the
meta-data file written by the "go tool cover" step as part of the
build action for the "go test -cover" run action 'runAct'. Note
that if the package has no functions the meta-data file will exist
but will be empty; in this case the return is an empty string.</p>
               
               <pre><code class="language-go">func BuildActionCoverMetaFile(runAct *Action) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BuildActionID" data-name="BuildActionID">
               <h3>
                  BuildActionID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BuildActionID" class="anchor" title="Link to BuildActionID">#</a>
               </h3>
               
               <p>BuildActionID returns the action ID section of a's build ID.</p>
               
               <pre><code class="language-go">func (a *Action) BuildActionID() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BuildContentID" data-name="BuildContentID">
               <h3>
                  BuildContentID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BuildContentID" class="anchor" title="Link to BuildContentID">#</a>
               </h3>
               
               <p>BuildContentID returns the content ID section of a's build ID.</p>
               
               <pre><code class="language-go">func (a *Action) BuildContentID() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BuildID" data-name="BuildID">
               <h3>
                  BuildID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BuildID" class="anchor" title="Link to BuildID">#</a>
               </h3>
               
               <p>BuildID returns a's build ID.</p>
               
               <pre><code class="language-go">func (a *Action) BuildID() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BuildInit" data-name="BuildInit">
               <h3>
                  BuildInit 
                  <span class="badge">function</span>
                  
                  <a href="#BuildInit" class="anchor" title="Link to BuildInit">#</a>
               </h3>
               
               <pre><code class="language-go">func BuildInit()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BuildInstallFunc" data-name="BuildInstallFunc">
               <h3>
                  BuildInstallFunc 
                  <span class="badge">function</span>
                  
                  <a href="#BuildInstallFunc" class="anchor" title="Link to BuildInstallFunc">#</a>
               </h3>
               
               <p>BuildInstallFunc is the action for installing a single package or executable.</p>
               
               <pre><code class="language-go">func BuildInstallFunc(b *Builder, ctx context.Context, a *Action) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BuiltTarget" data-name="BuiltTarget">
               <h3>
                  BuiltTarget 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BuiltTarget" class="anchor" title="Link to BuiltTarget">#</a>
               </h3>
               
               <p>BuiltTarget returns the actual file that was built. This differs
from Target when the result was cached.</p>
               
               <pre><code class="language-go">func (a *Action) BuiltTarget() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CFlags" data-name="CFlags">
               <h3>
                  CFlags 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CFlags" class="anchor" title="Link to CFlags">#</a>
               </h3>
               
               <p>CFlags returns the flags to use when invoking the C, C++ or Fortran compilers, or cgo.</p>
               
               <pre><code class="language-go">func (b *Builder) CFlags(p *load.Package) (cppflags []string, cflags []string, cxxflags []string, fflags []string, ldflags []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckGOOSARCHPair" data-name="CheckGOOSARCHPair">
               <h3>
                  CheckGOOSARCHPair 
                  <span class="badge">function</span>
                  
                  <a href="#CheckGOOSARCHPair" class="anchor" title="Link to CheckGOOSARCHPair">#</a>
               </h3>
               
               <pre><code class="language-go">func CheckGOOSARCHPair(goos string, goarch string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CompileAction" data-name="CompileAction">
               <h3>
                  CompileAction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CompileAction" class="anchor" title="Link to CompileAction">#</a>
               </h3>
               
               <p>CompileAction returns the action for compiling and possibly installing
(according to mode) the given package. The resulting action is only
for building packages (archives), never for linking executables.
depMode is the action (build or install) to use when building dependencies.
To turn package main into an executable, call b.Link instead.</p>
               
               <pre><code class="language-go">func (b *Builder) CompileAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CopyFile" data-name="CopyFile">
               <h3>
                  CopyFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CopyFile" class="anchor" title="Link to CopyFile">#</a>
               </h3>
               
               <p>copyFile is like 'cp src dst'.</p>
               
               <pre><code class="language-go">func (sh *Shell) CopyFile(dst string, src string, perm fs.FileMode, force bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CovData" data-name="CovData">
               <h3>
                  CovData 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CovData" class="anchor" title="Link to CovData">#</a>
               </h3>
               
               <p>CovData invokes "go tool covdata" with the specified arguments
as part of the execution of action 'a'.</p>
               
               <pre><code class="language-go">func (b *Builder) CovData(a *Action, cmdargs ...any) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Do" data-name="Do">
               <h3>
                  Do 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Do" class="anchor" title="Link to Do">#</a>
               </h3>
               
               <p>Do runs the action graph rooted at root.</p>
               
               <pre><code class="language-go">func (b *Builder) Do(ctx context.Context, root *Action)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *cmdError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Errorf" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Errorf" class="anchor" title="Link to Errorf">#</a>
               </h3>
               
               <p>Errorf reports an error on sh's package and sets the process exit status to 1.</p>
               
               <pre><code class="language-go">func (sh *Shell) Errorf(format string, a ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FindExecCmd" data-name="FindExecCmd">
               <h3>
                  FindExecCmd 
                  <span class="badge">function</span>
                  
                  <a href="#FindExecCmd" class="anchor" title="Link to FindExecCmd">#</a>
               </h3>
               
               <p>FindExecCmd derives the value of ExecCmd to use.
It returns that value and leaves ExecCmd set for direct use.</p>
               
               <pre><code class="language-go">func FindExecCmd() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GccCmd" data-name="GccCmd">
               <h3>
                  GccCmd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GccCmd" class="anchor" title="Link to GccCmd">#</a>
               </h3>
               
               <p>GccCmd returns a gcc command line prefix
defaultCC is defined in zdefaultcc.go, written by cmd/dist.</p>
               
               <pre><code class="language-go">func (b *Builder) GccCmd(incdir string, workdir string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GxxCmd" data-name="GxxCmd">
               <h3>
                  GxxCmd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GxxCmd" class="anchor" title="Link to GxxCmd">#</a>
               </h3>
               
               <p>GxxCmd returns a g++ command line prefix
defaultCXX is defined in zdefaultcc.go, written by cmd/dist.</p>
               
               <pre><code class="language-go">func (b *Builder) GxxCmd(incdir string, workdir string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPath" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPath" class="anchor" title="Link to ImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *cmdError) ImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InstallPackages" data-name="InstallPackages">
               <h3>
                  InstallPackages 
                  <span class="badge">function</span>
                  
                  <a href="#InstallPackages" class="anchor" title="Link to InstallPackages">#</a>
               </h3>
               
               <pre><code class="language-go">func InstallPackages(ctx context.Context, patterns []string, pkgs []*load.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsBoolFlag" data-name="IsBoolFlag">
               <h3>
                  IsBoolFlag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsBoolFlag" class="anchor" title="Link to IsBoolFlag">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *buildvcsFlag) IsBoolFlag() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Implement heap.Interface</p>
               
               <pre><code class="language-go">func (q *actionQueue) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code class="language-go">func (q *actionQueue) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LinkAction" data-name="LinkAction">
               <h3>
                  LinkAction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LinkAction" class="anchor" title="Link to LinkAction">#</a>
               </h3>
               
               <p>LinkAction returns the action for linking p into an executable
and possibly installing the result (according to mode).
depMode is the action (build or install) to use when compiling dependencies.</p>
               
               <pre><code class="language-go">func (b *Builder) LinkAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mkdir" data-name="Mkdir">
               <h3>
                  Mkdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mkdir" class="anchor" title="Link to Mkdir">#</a>
               </h3>
               
               <p>Mkdir makes the named directory.</p>
               
               <pre><code class="language-go">func (sh *Shell) Mkdir(dir string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewBuilder" data-name="NewBuilder">
               <h3>
                  NewBuilder 
                  <span class="badge">function</span>
                  
                  <a href="#NewBuilder" class="anchor" title="Link to NewBuilder">#</a>
               </h3>
               
               <p>NewBuilder returns a new Builder ready for use.
If workDir is the empty string, NewBuilder creates a WorkDir if needed
and arranges for it to be removed in case of an unclean exit.
The caller must Close the builder explicitly to clean up the WorkDir
before a clean exit.</p>
               
               <pre><code class="language-go">func NewBuilder(workDir string) *Builder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewObjdir" data-name="NewObjdir">
               <h3>
                  NewObjdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NewObjdir" class="anchor" title="Link to NewObjdir">#</a>
               </h3>
               
               <p>NewObjdir returns the name of a fresh object directory under b.WorkDir.
It is up to the caller to call b.Mkdir on the result at an appropriate time.
The result ends in a slash, so that file names in that directory
can be constructed with direct string addition.
NewObjdir must be called only from a single goroutine at a time,
so it is safe to call during action graph construction, but it must not
be called during action graph execution.</p>
               
               <pre><code class="language-go">func (b *Builder) NewObjdir() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewShell" data-name="NewShell">
               <h3>
                  NewShell 
                  <span class="badge">function</span>
                  
                  <a href="#NewShell" class="anchor" title="Link to NewShell">#</a>
               </h3>
               
               <p>NewShell returns a new Shell.
Shell will internally serialize calls to the printer.
If printer is nil, it uses load.DefaultPrinter.</p>
               
               <pre><code class="language-go">func NewShell(workDir string, printer load.Printer) *Shell</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PkgconfigCmd" data-name="PkgconfigCmd">
               <h3>
                  PkgconfigCmd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PkgconfigCmd" class="anchor" title="Link to PkgconfigCmd">#</a>
               </h3>
               
               <p>PkgconfigCmd returns a pkg-config binary name
defaultPkgConfig is defined in zdefaultcc.go, written by cmd/dist.</p>
               
               <pre><code class="language-go">func (b *Builder) PkgconfigCmd() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pop" data-name="Pop">
               <h3>
                  Pop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pop" class="anchor" title="Link to Pop">#</a>
               </h3>
               
               <pre><code class="language-go">func (q *actionQueue) Pop() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Printf" data-name="Printf">
               <h3>
                  Printf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Printf" class="anchor" title="Link to Printf">#</a>
               </h3>
               
               <p>Printf emits a to this Shell's output stream, formatting it like fmt.Printf.
It is safe to call concurrently.</p>
               
               <pre><code class="language-go">func (sh *Shell) Printf(format string, a ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Push" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Push" class="anchor" title="Link to Push">#</a>
               </h3>
               
               <pre><code class="language-go">func (q *actionQueue) Push(x any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RemoveAll" data-name="RemoveAll">
               <h3>
                  RemoveAll 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RemoveAll" class="anchor" title="Link to RemoveAll">#</a>
               </h3>
               
               <p>RemoveAll is like 'rm -rf'. It attempts to remove all paths even if there's
an error, and returns the first error.</p>
               
               <pre><code class="language-go">func (sh *Shell) RemoveAll(paths ...string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (f commaListFlag) Set(value string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (f coverFlag) Set(value string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *coverModeFlag) Set(value string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (f stringFlag) Set(value string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (c buildCompiler) Set(value string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *buildvcsFlag) Set(s string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (v *tagsFlag) Set(s string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Shell" data-name="Shell">
               <h3>
                  Shell 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Shell" class="anchor" title="Link to Shell">#</a>
               </h3>
               
               <p>Shell returns a shell for running commands on behalf of Action a.</p>
               
               <pre><code class="language-go">func (b *Builder) Shell(a *Action) *Shell</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ShowCmd" data-name="ShowCmd">
               <h3>
                  ShowCmd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ShowCmd" class="anchor" title="Link to ShowCmd">#</a>
               </h3>
               
               <p>ShowCmd prints the given command to standard output
for the implementation of -n or -x.
ShowCmd also replaces the name of the current script directory with dot (.)
but only when it is at the beginning of a space-separated token.
If dir is not "" or "/" and not the current script directory, ShowCmd first
prints a "cd" command to switch to dir and updates the script directory.</p>
               
               <pre><code class="language-go">func (sh *Shell) ShowCmd(dir string, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *buildvcsFlag) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (f commaListFlag) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (v *tagsFlag) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (c buildCompiler) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *coverModeFlag) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (f coverFlag) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (f stringFlag) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code class="language-go">func (q *actionQueue) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Symlink" data-name="Symlink">
               <h3>
                  Symlink 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Symlink" class="anchor" title="Link to Symlink">#</a>
               </h3>
               
               <p>Symlink creates a symlink newname -> oldname.</p>
               
               <pre><code class="language-go">func (sh *Shell) Symlink(oldname string, newname string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="VetAction" data-name="VetAction">
               <h3>
                  VetAction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#VetAction" class="anchor" title="Link to VetAction">#</a>
               </h3>
               
               <p>VetAction returns the action for running go vet on package p.
It depends on the action for compiling p.
If the caller may be causing p to be installed, it is up to the caller
to make sure that the install depends on (runs after) vet.</p>
               
               <pre><code class="language-go">func (b *Builder) VetAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithAction" data-name="WithAction">
               <h3>
                  WithAction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WithAction" class="anchor" title="Link to WithAction">#</a>
               </h3>
               
               <p>WithAction returns a Shell identical to sh, but bound to Action a.</p>
               
               <pre><code class="language-go">func (sh *Shell) WithAction(a *Action) *Shell</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteCoverMetaFilesFile" data-name="WriteCoverMetaFilesFile">
               <h3>
                  WriteCoverMetaFilesFile 
                  <span class="badge">function</span>
                  
                  <a href="#WriteCoverMetaFilesFile" class="anchor" title="Link to WriteCoverMetaFilesFile">#</a>
               </h3>
               
               <p>WriteCoverMetaFilesFile writes out a summary file ("meta-files
file") as part of the action function for the "writeCoverMeta"
pseudo action employed during "go test -coverpkg" runs where there
are multiple tests and multiple packages covered. It builds up a
table mapping package import path to meta-data file fragment and
writes it out to a file where it can be read by the various test
run actions. Note that this function has to be called A) after the
build actions are complete for all packages being tested, and B)
before any of the "run test" actions for those packages happen.
This requirement is enforced by adding making this action ("a")
dependent on all test package build actions, and making all test
run actions dependent on this action.</p>
               
               <pre><code class="language-go">func WriteCoverMetaFilesFile(b *Builder, ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteCoveragePercent" data-name="WriteCoveragePercent">
               <h3>
                  WriteCoveragePercent 
                  <span class="badge">function</span>
                  
                  <a href="#WriteCoveragePercent" class="anchor" title="Link to WriteCoveragePercent">#</a>
               </h3>
               
               <p>WriteCoveragePercent writes out to the writer 'w' a "percent
statements covered" for the package whose test-run action is
'runAct', based on the meta-data file 'mf'. This helper is used in
cases where a user runs "go test -cover" on a package that has
functions but no tests; in the normal case (package has tests)
the percentage is written by the test binary when it runs.</p>
               
               <pre><code class="language-go">func WriteCoveragePercent(b *Builder, runAct *Action, mf string, w io.Writer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteCoverageProfile" data-name="WriteCoverageProfile">
               <h3>
                  WriteCoverageProfile 
                  <span class="badge">function</span>
                  
                  <a href="#WriteCoverageProfile" class="anchor" title="Link to WriteCoverageProfile">#</a>
               </h3>
               
               <p>WriteCoverageProfile writes out a coverage profile fragment for the
package whose test-run action is 'runAct'; content is written to
the file 'outf' based on the coverage meta-data info found in
'mf'. This helper is used in cases where a user runs "go test
-cover" on a package that has functions but no tests.</p>
               
               <pre><code class="language-go">func WriteCoverageProfile(b *Builder, runAct *Action, mf string, outf string, w io.Writer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="actionGraphJSON" data-name="actionGraphJSON">
               <h3>
                  actionGraphJSON 
                  <span class="badge">function</span>
                  
                  <a href="#actionGraphJSON" class="anchor" title="Link to actionGraphJSON">#</a>
               </h3>
               
               <pre><code class="language-go">func actionGraphJSON(a *Action) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="actionID" data-name="actionID">
               <h3>
                  actionID 
                  <span class="badge">function</span>
                  
                  <a href="#actionID" class="anchor" title="Link to actionID">#</a>
               </h3>
               
               <p>actionID returns the action ID half of a build ID.</p>
               
               <pre><code class="language-go">func actionID(buildID string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="actionList" data-name="actionList">
               <h3>
                  actionList 
                  <span class="badge">function</span>
                  
                  <a href="#actionList" class="anchor" title="Link to actionList">#</a>
               </h3>
               
               <p>actionList returns the list of actions in the dag rooted at root
as visited in a depth-first post-order traversal.</p>
               
               <pre><code class="language-go">func actionList(root *Action) []*Action</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="actualFiles" data-name="actualFiles">
               <h3>
                  actualFiles 
                  <span class="badge">function</span>
                  
                  <a href="#actualFiles" class="anchor" title="Link to actualFiles">#</a>
               </h3>
               
               <p>actualFiles applies fsys.Actual to the list of files.</p>
               
               <pre><code class="language-go">func actualFiles(files []string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addInstallHeaderAction" data-name="addInstallHeaderAction">
               <h3>
                  addInstallHeaderAction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addInstallHeaderAction" class="anchor" title="Link to addInstallHeaderAction">#</a>
               </h3>
               
               <p>addInstallHeaderAction adds an install header action to a, if needed.
The action a should be an install action as generated by either
b.CompileAction or b.LinkAction with mode=ModeInstall,
and so a.Deps[0] is the corresponding build action.</p>
               
               <pre><code class="language-go">func (b *Builder) addInstallHeaderAction(a *Action)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addTransitiveLinkDeps" data-name="addTransitiveLinkDeps">
               <h3>
                  addTransitiveLinkDeps 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addTransitiveLinkDeps" class="anchor" title="Link to addTransitiveLinkDeps">#</a>
               </h3>
               
               <p>addTransitiveLinkDeps adds to the link action a all packages
that are transitive dependencies of a1.Deps.
That is, if a is a link of package main, a1 is the compile of package main
and a1.Deps is the actions for building packages directly imported by
package main (what the compiler needs). The linker needs all packages
transitively imported by the whole program; addTransitiveLinkDeps
makes sure those are present in a.Deps.
If shlib is non-empty, then a corresponds to the build and installation of shlib,
so any rebuild of shlib should not be added as a dependency.</p>
               
               <pre><code class="language-go">func (b *Builder) addTransitiveLinkDeps(a *Action, a1 *Action, shlib string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allowedVersion" data-name="allowedVersion">
               <h3>
                  allowedVersion 
                  <span class="badge">function</span>
                  
                  <a href="#allowedVersion" class="anchor" title="Link to allowedVersion">#</a>
               </h3>
               
               <p>allowedVersion reports whether the version v is an allowed version of go
(one that we can compile).
v is known to be of the form "1.23".</p>
               
               <pre><code class="language-go">func allowedVersion(v string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ar" data-name="ar">
               <h3>
                  ar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ar" class="anchor" title="Link to ar">#</a>
               </h3>
               
               <pre><code class="language-go">func (gccgoToolchain) ar() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asm" data-name="asm">
               <h3>
                  asm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#asm" class="anchor" title="Link to asm">#</a>
               </h3>
               
               <pre><code class="language-go">func (noToolchain) asm(b *Builder, a *Action, sfiles []string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asm" data-name="asm">
               <h3>
                  asm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#asm" class="anchor" title="Link to asm">#</a>
               </h3>
               
               <pre><code class="language-go">func (gcToolchain) asm(b *Builder, a *Action, sfiles []string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asm" data-name="asm">
               <h3>
                  asm 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#asm" class="anchor" title="Link to asm">#</a>
               </h3>
               
               <pre><code class="language-go">func (tools gccgoToolchain) asm(b *Builder, a *Action, sfiles []string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asmArgs" data-name="asmArgs">
               <h3>
                  asmArgs 
                  <span class="badge">function</span>
                  
                  <a href="#asmArgs" class="anchor" title="Link to asmArgs">#</a>
               </h3>
               
               <pre><code class="language-go">func asmArgs(a *Action, p *load.Package) []any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assemblerIsGas" data-name="assemblerIsGas">
               <h3>
                  assemblerIsGas 
                  <span class="badge">function</span>
                  
                  <a href="#assemblerIsGas" class="anchor" title="Link to assemblerIsGas">#</a>
               </h3>
               
               <p>Check if assembler used by gccgo is GNU as.</p>
               
               <pre><code class="language-go">func assemblerIsGas() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="build" data-name="build">
               <h3>
                  build 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#build" class="anchor" title="Link to build">#</a>
               </h3>
               
               <p>build is the action for building a single package.
Note that any new influence on this logic must be reported in b.buildActionID above as well.</p>
               
               <pre><code class="language-go">func (b *Builder) build(ctx context.Context, a *Action) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildActionID" data-name="buildActionID">
               <h3>
                  buildActionID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#buildActionID" class="anchor" title="Link to buildActionID">#</a>
               </h3>
               
               <p>buildActionID computes the action ID for a build action.</p>
               
               <pre><code class="language-go">func (b *Builder) buildActionID(a *Action) cache.ActionID</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildFlags" data-name="buildFlags">
               <h3>
                  buildFlags 
                  <span class="badge">function</span>
                  
                  <a href="#buildFlags" class="anchor" title="Link to buildFlags">#</a>
               </h3>
               
               <pre><code class="language-go">func buildFlags(name string, defaults string, fromPackage []string, check func(string, string, []string) error) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildID" data-name="buildID">
               <h3>
                  buildID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#buildID" class="anchor" title="Link to buildID">#</a>
               </h3>
               
               <p>buildID returns the build ID found in the given file.
If no build ID is found, buildID returns the content hash of the file.</p>
               
               <pre><code class="language-go">func (b *Builder) buildID(file string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildImportcfgSymlinks" data-name="buildImportcfgSymlinks">
               <h3>
                  buildImportcfgSymlinks 
                  <span class="badge">function</span>
                  
                  <a href="#buildImportcfgSymlinks" class="anchor" title="Link to buildImportcfgSymlinks">#</a>
               </h3>
               
               <p>buildImportcfgSymlinks builds in root a tree of symlinks
implementing the directives from importcfg.
This serves as a temporary transition mechanism until
we can depend on gccgo reading an importcfg directly.
(The Go 1.9 and later gc compilers already do.)</p>
               
               <pre><code class="language-go">func buildImportcfgSymlinks(sh *Shell, root string, importcfg []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildModeInit" data-name="buildModeInit">
               <h3>
                  buildModeInit 
                  <span class="badge">function</span>
                  
                  <a href="#buildModeInit" class="anchor" title="Link to buildModeInit">#</a>
               </h3>
               
               <pre><code class="language-go">func buildModeInit()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildVetConfig" data-name="buildVetConfig">
               <h3>
                  buildVetConfig 
                  <span class="badge">function</span>
                  
                  <a href="#buildVetConfig" class="anchor" title="Link to buildVetConfig">#</a>
               </h3>
               
               <pre><code class="language-go">func buildVetConfig(a *Action, srcfiles []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildmodeShared" data-name="buildmodeShared">
               <h3>
                  buildmodeShared 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#buildmodeShared" class="anchor" title="Link to buildmodeShared">#</a>
               </h3>
               
               <p>buildmodeShared takes the "go build" action a1 into the building of a shared library of a1.Deps.
That is, the input a1 represents "go build pkgs" and the result represents "go build -buildmode=shared pkgs".</p>
               
               <pre><code class="language-go">func (b *Builder) buildmodeShared(mode BuildMode, depMode BuildMode, args []string, pkgs []*load.Package, a1 *Action) *Action</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cCompilerEnv" data-name="cCompilerEnv">
               <h3>
                  cCompilerEnv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cCompilerEnv" class="anchor" title="Link to cCompilerEnv">#</a>
               </h3>
               
               <p>cCompilerEnv returns environment variables to set when running the
C compiler. This is needed to disable escape codes in clang error
messages that confuse tools like cgo.</p>
               
               <pre><code class="language-go">func (b *Builder) cCompilerEnv() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cacheAction" data-name="cacheAction">
               <h3>
                  cacheAction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cacheAction" class="anchor" title="Link to cacheAction">#</a>
               </h3>
               
               <p>cacheAction looks up {mode, p} in the cache and returns the resulting action.
If the cache has no such action, f() is recorded and returned.
TODO(rsc): Change the second key from *load.Package to interface{},
to make the caching in linkShared less awkward?</p>
               
               <pre><code class="language-go">func (b *Builder) cacheAction(mode string, p *load.Package, f func() *Action) *Action</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cacheCgoHdr" data-name="cacheCgoHdr">
               <h3>
                  cacheCgoHdr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cacheCgoHdr" class="anchor" title="Link to cacheCgoHdr">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) cacheCgoHdr(a *Action)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cacheObjdirFile" data-name="cacheObjdirFile">
               <h3>
                  cacheObjdirFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cacheObjdirFile" class="anchor" title="Link to cacheObjdirFile">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) cacheObjdirFile(a *Action, c cache.Cache, name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cacheSrcFiles" data-name="cacheSrcFiles">
               <h3>
                  cacheSrcFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cacheSrcFiles" class="anchor" title="Link to cacheSrcFiles">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) cacheSrcFiles(a *Action, srcfiles []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cc" data-name="cc">
               <h3>
                  cc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cc" class="anchor" title="Link to cc">#</a>
               </h3>
               
               <pre><code class="language-go">func (gcToolchain) cc(b *Builder, a *Action, ofile string, cfile string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cc" data-name="cc">
               <h3>
                  cc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cc" class="anchor" title="Link to cc">#</a>
               </h3>
               
               <pre><code class="language-go">func (noToolchain) cc(b *Builder, a *Action, ofile string, cfile string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cc" data-name="cc">
               <h3>
                  cc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cc" class="anchor" title="Link to cc">#</a>
               </h3>
               
               <pre><code class="language-go">func (tools gccgoToolchain) cc(b *Builder, a *Action, ofile string, cfile string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ccExe" data-name="ccExe">
               <h3>
                  ccExe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ccExe" class="anchor" title="Link to ccExe">#</a>
               </h3>
               
               <p>ccExe returns the CC compiler setting without all the extra flags we add implicitly.</p>
               
               <pre><code class="language-go">func (b *Builder) ccExe() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ccompile" data-name="ccompile">
               <h3>
                  ccompile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ccompile" class="anchor" title="Link to ccompile">#</a>
               </h3>
               
               <p>ccompile runs the given C or C++ compiler and creates an object from a single source file.</p>
               
               <pre><code class="language-go">func (b *Builder) ccompile(a *Action, outfile string, flags []string, file string, compiler []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cgo" data-name="cgo">
               <h3>
                  cgo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cgo" class="anchor" title="Link to cgo">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) cgo(a *Action, cgoExe string, objdir string, pcCFLAGS []string, pcLDFLAGS []string, cgofiles []string, gccfiles []string, gxxfiles []string, mfiles []string, ffiles []string) (outGo []string, outObj []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkCompilerFlags" data-name="checkCompilerFlags">
               <h3>
                  checkCompilerFlags 
                  <span class="badge">function</span>
                  
                  <a href="#checkCompilerFlags" class="anchor" title="Link to checkCompilerFlags">#</a>
               </h3>
               
               <pre><code class="language-go">func checkCompilerFlags(name string, source string, list []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkCompilerFlagsForInternalLink" data-name="checkCompilerFlagsForInternalLink">
               <h3>
                  checkCompilerFlagsForInternalLink 
                  <span class="badge">function</span>
                  
                  <a href="#checkCompilerFlagsForInternalLink" class="anchor" title="Link to checkCompilerFlagsForInternalLink">#</a>
               </h3>
               
               <p>checkCompilerFlagsForInternalLink returns an error if 'list'
contains a flag or flags that may not be fully supported by
internal linking (meaning that we should punt the link to the
external linker).</p>
               
               <pre><code class="language-go">func checkCompilerFlagsForInternalLink(name string, source string, list []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkDirectives" data-name="checkDirectives">
               <h3>
                  checkDirectives 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkDirectives" class="anchor" title="Link to checkDirectives">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) checkDirectives(a *Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFlags" data-name="checkFlags">
               <h3>
                  checkFlags 
                  <span class="badge">function</span>
                  
                  <a href="#checkFlags" class="anchor" title="Link to checkFlags">#</a>
               </h3>
               
               <pre><code class="language-go">func checkFlags(name string, source string, list []string, invalid []*lazyregexp.Regexp, valid []*lazyregexp.Regexp, validNext []string, checkOverrides bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkGccgoBin" data-name="checkGccgoBin">
               <h3>
                  checkGccgoBin 
                  <span class="badge">function</span>
                  
                  <a href="#checkGccgoBin" class="anchor" title="Link to checkGccgoBin">#</a>
               </h3>
               
               <pre><code class="language-go">func checkGccgoBin()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkLinkerFlags" data-name="checkLinkerFlags">
               <h3>
                  checkLinkerFlags 
                  <span class="badge">function</span>
                  
                  <a href="#checkLinkerFlags" class="anchor" title="Link to checkLinkerFlags">#</a>
               </h3>
               
               <pre><code class="language-go">func checkLinkerFlags(name string, source string, list []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanup" data-name="cleanup">
               <h3>
                  cleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cleanup" class="anchor" title="Link to cleanup">#</a>
               </h3>
               
               <p>cleanup removes a's object dir to keep the amount of
on-disk garbage down in a large build. On an operating system
with aggressive buffering, cleaning incrementally like
this keeps the intermediate objects from hitting the disk.</p>
               
               <pre><code class="language-go">func (b *Builder) cleanup(a *Action)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeBuilders" data-name="closeBuilders">
               <h3>
                  closeBuilders 
                  <span class="badge">function</span>
                  
                  <a href="#closeBuilders" class="anchor" title="Link to closeBuilders">#</a>
               </h3>
               
               <pre><code class="language-go">func closeBuilders()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compiler" data-name="compiler">
               <h3>
                  compiler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compiler" class="anchor" title="Link to compiler">#</a>
               </h3>
               
               <pre><code class="language-go">func (gcToolchain) compiler() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compiler" data-name="compiler">
               <h3>
                  compiler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compiler" class="anchor" title="Link to compiler">#</a>
               </h3>
               
               <pre><code class="language-go">func (gccgoToolchain) compiler() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compiler" data-name="compiler">
               <h3>
                  compiler 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compiler" class="anchor" title="Link to compiler">#</a>
               </h3>
               
               <pre><code class="language-go">func (noToolchain) compiler() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compilerCmd" data-name="compilerCmd">
               <h3>
                  compilerCmd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compilerCmd" class="anchor" title="Link to compilerCmd">#</a>
               </h3>
               
               <p>compilerCmd returns a command line prefix for the given environment
variable and using the default command when the variable is empty.</p>
               
               <pre><code class="language-go">func (b *Builder) compilerCmd(compiler []string, incdir string, workdir string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compilerRequiredAsanVersion" data-name="compilerRequiredAsanVersion">
               <h3>
                  compilerRequiredAsanVersion 
                  <span class="badge">function</span>
                  
                  <a href="#compilerRequiredAsanVersion" class="anchor" title="Link to compilerRequiredAsanVersion">#</a>
               </h3>
               
               <p>compilerRequiredAsanVersion is a copy of the function defined in
cmd/cgo/internal/testsanitizers/cc_test.go
compilerRequiredAsanVersion reports whether the compiler is the version
required by Asan.</p>
               
               <pre><code class="language-go">func compilerRequiredAsanVersion() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compilerVersion" data-name="compilerVersion">
               <h3>
                  compilerVersion 
                  <span class="badge">function</span>
                  
                  <a href="#compilerVersion" class="anchor" title="Link to compilerVersion">#</a>
               </h3>
               
               <p>compilerVersion detects the version of $(go env CC).
It returns a non-nil error if the compiler matches a known version schema but
the version could not be parsed, or if $(go env CC) could not be determined.</p>
               
               <pre><code class="language-go">func compilerVersion() (version, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="contentID" data-name="contentID">
               <h3>
                  contentID 
                  <span class="badge">function</span>
                  
                  <a href="#contentID" class="anchor" title="Link to contentID">#</a>
               </h3>
               
               <p>contentID returns the content ID half of a build ID.</p>
               
               <pre><code class="language-go">func contentID(buildID string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cover" data-name="cover">
               <h3>
                  cover 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cover" class="anchor" title="Link to cover">#</a>
               </h3>
               
               <p>cover runs, in effect,
go tool cover -mode=b.coverMode -var="varName" -o dst.go src.go</p>
               
               <pre><code class="language-go">func (b *Builder) cover(a *Action, dst string, src string, varName string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cover2" data-name="cover2">
               <h3>
                  cover2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cover2" class="anchor" title="Link to cover2">#</a>
               </h3>
               
               <p>cover2 runs, in effect,
go tool cover -pkgcfg=<config file> -mode=b.coverMode -var="varName" -o <outfiles> <infiles>
Return value is an updated output files list; in addition to the
regular outputs (instrumented source files) the cover tool also
writes a separate file (appearing first in the list of outputs)
that will contain coverage counters and meta-data.</p>
               
               <pre><code class="language-go">func (b *Builder) cover2(a *Action, infiles []string, outfiles []string, varName string, mode string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cxxExe" data-name="cxxExe">
               <h3>
                  cxxExe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cxxExe" class="anchor" title="Link to cxxExe">#</a>
               </h3>
               
               <p>cxxExe returns the CXX compiler setting without all the extra flags we add implicitly.</p>
               
               <pre><code class="language-go">func (b *Builder) cxxExe() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="disableBuildID" data-name="disableBuildID">
               <h3>
                  disableBuildID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#disableBuildID" class="anchor" title="Link to disableBuildID">#</a>
               </h3>
               
               <p>disableBuildID adjusts a linker command line to avoid creating a
build ID when creating an object file rather than an executable or
shared library. Some systems, such as Ubuntu, always add
--build-id to every link, but we don't want a build ID when we are
producing an object file. On some of those system a plain -r (not
-Wl,-r) will turn off --build-id, but clang 3.0 doesn't support a
plain -r. I don't know how to turn off --build-id when using clang
other than passing a trailing --build-id=none. So that is what we
do, but only on systems likely to support it, which is to say,
systems that normally use gold or the GNU linker.</p>
               
               <pre><code class="language-go">func (b *Builder) disableBuildID(ldflags []string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dynimport" data-name="dynimport">
               <h3>
                  dynimport 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dynimport" class="anchor" title="Link to dynimport">#</a>
               </h3>
               
               <p>dynimport creates a Go source file named importGo containing
//go:cgo_import_dynamic directives for each symbol or library
dynamically imported by the object files outObj.
dynOutGo, if not empty, is a new Go file to build as part of the package.
dynOutObj, if not empty, is a new file to add to the generated archive.</p>
               
               <pre><code class="language-go">func (b *Builder) dynimport(a *Action, objdir string, importGo string, cgoExe string, cflags []string, cgoLDFLAGS []string, outObj []string) (dynOutGo string, dynOutObj string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="encodeArg" data-name="encodeArg">
               <h3>
                  encodeArg 
                  <span class="badge">function</span>
                  
                  <a href="#encodeArg" class="anchor" title="Link to encodeArg">#</a>
               </h3>
               
               <p>encodeArg encodes an argument for response file writing.</p>
               
               <pre><code class="language-go">func encodeArg(arg string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="envList" data-name="envList">
               <h3>
                  envList 
                  <span class="badge">function</span>
                  
                  <a href="#envList" class="anchor" title="Link to envList">#</a>
               </h3>
               
               <p>envList returns the value of the given environment variable broken
into fields, using the default value when the variable is empty.
The environment variable must be quoted correctly for
quoted.Split. This should be done before building
anything, for example, in BuildInit.</p>
               
               <pre><code class="language-go">func envList(key string, def string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fcExe" data-name="fcExe">
               <h3>
                  fcExe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fcExe" class="anchor" title="Link to fcExe">#</a>
               </h3>
               
               <p>fcExe returns the FC compiler setting without all the extra flags we add implicitly.</p>
               
               <pre><code class="language-go">func (b *Builder) fcExe() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fileExtSplit" data-name="fileExtSplit">
               <h3>
                  fileExtSplit 
                  <span class="badge">function</span>
                  
                  <a href="#fileExtSplit" class="anchor" title="Link to fileExtSplit">#</a>
               </h3>
               
               <p>fileExtSplit expects a filename and returns the name
and ext (without the dot). If the file has no
extension, ext will be empty.</p>
               
               <pre><code class="language-go">func fileExtSplit(file string) (name string, ext string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fileHash" data-name="fileHash">
               <h3>
                  fileHash 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fileHash" class="anchor" title="Link to fileHash">#</a>
               </h3>
               
               <p>fileHash returns the content hash of the named file.</p>
               
               <pre><code class="language-go">func (b *Builder) fileHash(file string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findCachedObjdirFile" data-name="findCachedObjdirFile">
               <h3>
                  findCachedObjdirFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findCachedObjdirFile" class="anchor" title="Link to findCachedObjdirFile">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) findCachedObjdirFile(a *Action, c cache.Cache, name string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flagsNotCompatibleWithInternalLinking" data-name="flagsNotCompatibleWithInternalLinking">
               <h3>
                  flagsNotCompatibleWithInternalLinking 
                  <span class="badge">function</span>
                  
                  <a href="#flagsNotCompatibleWithInternalLinking" class="anchor" title="Link to flagsNotCompatibleWithInternalLinking">#</a>
               </h3>
               
               <p>flagsNotCompatibleWithInternalLinking scans the list of cgo
compiler flags (C/C++/Fortran) looking for flags that might cause
problems if the build in question uses internal linking. The
primary culprits are use of plugins or use of LTO, but we err on
the side of caution, supporting only those flags that are on the
allow-list for safe flags from security perspective. Return is TRUE
if a sensitive flag is found, FALSE otherwise.</p>
               
               <pre><code class="language-go">func flagsNotCompatibleWithInternalLinking(sourceList []string, flagListList [][]string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flushOutput" data-name="flushOutput">
               <h3>
                  flushOutput 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flushOutput" class="anchor" title="Link to flushOutput">#</a>
               </h3>
               
               <p>flushOutput flushes the output being queued in a.</p>
               
               <pre><code class="language-go">func (b *Builder) flushOutput(a *Action)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtCmd" data-name="fmtCmd">
               <h3>
                  fmtCmd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fmtCmd" class="anchor" title="Link to fmtCmd">#</a>
               </h3>
               
               <p>fmtCmd formats a command in the manner of fmt.Sprintf but also:
fmtCmd replaces the value of b.WorkDir with $WORK.</p>
               
               <pre><code class="language-go">func (sh *Shell) fmtCmd(dir string, format string, args ...any) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fuzzInstrumentFlags" data-name="fuzzInstrumentFlags">
               <h3>
                  fuzzInstrumentFlags 
                  <span class="badge">function</span>
                  
                  <a href="#fuzzInstrumentFlags" class="anchor" title="Link to fuzzInstrumentFlags">#</a>
               </h3>
               
               <p>fuzzInstrumentFlags returns compiler flags that enable fuzzing instrumentation
on supported platforms.
On unsupported platforms, fuzzInstrumentFlags returns nil, meaning no
instrumentation is added. 'go test -fuzz' still works without coverage,
but it generates random inputs without guidance, so it's much less effective.</p>
               
               <pre><code class="language-go">func fuzzInstrumentFlags() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gc" data-name="gc">
               <h3>
                  gc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gc" class="anchor" title="Link to gc">#</a>
               </h3>
               
               <pre><code class="language-go">func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, embedcfg []byte, symabis string, asmhdr bool, pgoProfile string, gofiles []string) (ofile string, output []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gc" data-name="gc">
               <h3>
                  gc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gc" class="anchor" title="Link to gc">#</a>
               </h3>
               
               <pre><code class="language-go">func (noToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, embedcfg []byte, symabis string, asmhdr bool, pgoProfile string, gofiles []string) (ofile string, out []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gc" data-name="gc">
               <h3>
                  gc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gc" class="anchor" title="Link to gc">#</a>
               </h3>
               
               <pre><code class="language-go">func (tools gccgoToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, embedcfg []byte, symabis string, asmhdr bool, pgoProfile string, gofiles []string) (ofile string, output []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gcBackendConcurrency" data-name="gcBackendConcurrency">
               <h3>
                  gcBackendConcurrency 
                  <span class="badge">function</span>
                  
                  <a href="#gcBackendConcurrency" class="anchor" title="Link to gcBackendConcurrency">#</a>
               </h3>
               
               <p>gcBackendConcurrency returns the backend compiler concurrency level for a package compilation.</p>
               
               <pre><code class="language-go">func gcBackendConcurrency(gcflags []string) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gcc" data-name="gcc">
               <h3>
                  gcc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gcc" class="anchor" title="Link to gcc">#</a>
               </h3>
               
               <p>gcc runs the gcc C compiler to create an object from a single C file.</p>
               
               <pre><code class="language-go">func (b *Builder) gcc(a *Action, workdir string, out string, flags []string, cfile string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccArchArgs" data-name="gccArchArgs">
               <h3>
                  gccArchArgs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccArchArgs" class="anchor" title="Link to gccArchArgs">#</a>
               </h3>
               
               <p>gccArchArgs returns arguments to pass to gcc based on the architecture.</p>
               
               <pre><code class="language-go">func (b *Builder) gccArchArgs() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccCompilerID" data-name="gccCompilerID">
               <h3>
                  gccCompilerID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccCompilerID" class="anchor" title="Link to gccCompilerID">#</a>
               </h3>
               
               <p>gccCompilerID returns a build cache key for the current gcc,
as identified by running 'compiler'.
The caller can use subkeys of the key.
Other parts of cmd/go can use the id as a hash
of the installed compiler version.</p>
               
               <pre><code class="language-go">func (b *Builder) gccCompilerID(compiler string) (id cache.ActionID, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccNoPie" data-name="gccNoPie">
               <h3>
                  gccNoPie 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccNoPie" class="anchor" title="Link to gccNoPie">#</a>
               </h3>
               
               <p>gccNoPie returns the flag to use to request non-PIE. On systems
with PIE (position independent executables) enabled by default,
-no-pie must be passed when doing a partial link with -Wl,-r.
But -no-pie is not supported by all compilers, and clang spells it -nopie.</p>
               
               <pre><code class="language-go">func (b *Builder) gccNoPie(linker []string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccSupportsFlag" data-name="gccSupportsFlag">
               <h3>
                  gccSupportsFlag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccSupportsFlag" class="anchor" title="Link to gccSupportsFlag">#</a>
               </h3>
               
               <p>gccSupportsFlag checks to see if the compiler supports a flag.</p>
               
               <pre><code class="language-go">func (b *Builder) gccSupportsFlag(compiler []string, flag string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccToolID" data-name="gccToolID">
               <h3>
                  gccToolID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccToolID" class="anchor" title="Link to gccToolID">#</a>
               </h3>
               
               <p>gccToolID returns the unique ID to use for a tool that is invoked
by the GCC driver. This is used particularly for gccgo, but this can also
be used for gcc, g++, gfortran, etc.; those tools all use the GCC
driver under different names. The approach used here should also
work for sufficiently new versions of clang. Unlike toolID, the
name argument is the program to run. The language argument is the
type of input file as passed to the GCC driver's -x option.
For these tools we have no -V=full option to dump the build ID,
but we can run the tool with -v -### to reliably get the compiler proper
and hash that. That will work in the presence of -toolexec.
In order to get reproducible builds for released compilers, we
detect a released compiler by the absence of "experimental" in the
--version output, and in that case we just use the version string.
gccToolID also returns the underlying executable for the compiler.
The caller assumes that stat of the exe can be used, combined with the id,
to detect changes in the underlying compiler. The returned exe can be empty,
which means to rely only on the id.</p>
               
               <pre><code class="language-go">func (b *Builder) gccToolID(name string, language string) (id string, exe string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccgoArchive" data-name="gccgoArchive">
               <h3>
                  gccgoArchive 
                  <span class="badge">function</span>
                  
                  <a href="#gccgoArchive" class="anchor" title="Link to gccgoArchive">#</a>
               </h3>
               
               <pre><code class="language-go">func gccgoArchive(basedir string, imp string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccgoBuildIDFile" data-name="gccgoBuildIDFile">
               <h3>
                  gccgoBuildIDFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccgoBuildIDFile" class="anchor" title="Link to gccgoBuildIDFile">#</a>
               </h3>
               
               <p>gccgoBuildIDFile creates an assembler file that records the
action's build ID in an SHF_EXCLUDE section for ELF files or
in a CSECT in XCOFF files.</p>
               
               <pre><code class="language-go">func (b *Builder) gccgoBuildIDFile(a *Action) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccgoCleanPkgpath" data-name="gccgoCleanPkgpath">
               <h3>
                  gccgoCleanPkgpath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccgoCleanPkgpath" class="anchor" title="Link to gccgoCleanPkgpath">#</a>
               </h3>
               
               <pre><code class="language-go">func (tools gccgoToolchain) gccgoCleanPkgpath(b *Builder, p *load.Package) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccgoPkgpath" data-name="gccgoPkgpath">
               <h3>
                  gccgoPkgpath 
                  <span class="badge">function</span>
                  
                  <a href="#gccgoPkgpath" class="anchor" title="Link to gccgoPkgpath">#</a>
               </h3>
               
               <pre><code class="language-go">func gccgoPkgpath(p *load.Package) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gccld" data-name="gccld">
               <h3>
                  gccld 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gccld" class="anchor" title="Link to gccld">#</a>
               </h3>
               
               <p>gccld runs the gcc linker to create an executable from a set of object files.</p>
               
               <pre><code class="language-go">func (b *Builder) gccld(a *Action, objdir string, outfile string, flags []string, objs []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getPkgConfigFlags" data-name="getPkgConfigFlags">
               <h3>
                  getPkgConfigFlags 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getPkgConfigFlags" class="anchor" title="Link to getPkgConfigFlags">#</a>
               </h3>
               
               <p>Calls pkg-config if needed and returns the cflags/ldflags needed to build a's package.</p>
               
               <pre><code class="language-go">func (b *Builder) getPkgConfigFlags(a *Action) (cflags []string, ldflags []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gfortran" data-name="gfortran">
               <h3>
                  gfortran 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gfortran" class="anchor" title="Link to gfortran">#</a>
               </h3>
               
               <p>gfortran runs the gfortran Fortran compiler to create an object from a single Fortran file.</p>
               
               <pre><code class="language-go">func (b *Builder) gfortran(a *Action, workdir string, out string, flags []string, ffile string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gfortranCmd" data-name="gfortranCmd">
               <h3>
                  gfortranCmd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gfortranCmd" class="anchor" title="Link to gfortranCmd">#</a>
               </h3>
               
               <p>gfortranCmd returns a gfortran command line prefix.</p>
               
               <pre><code class="language-go">func (b *Builder) gfortranCmd(incdir string, workdir string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gxx" data-name="gxx">
               <h3>
                  gxx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gxx" class="anchor" title="Link to gxx">#</a>
               </h3>
               
               <p>gxx runs the g++ C++ compiler to create an object from a single C++ file.</p>
               
               <pre><code class="language-go">func (b *Builder) gxx(a *Action, workdir string, out string, flags []string, cxxfile string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="installAction" data-name="installAction">
               <h3>
                  installAction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#installAction" class="anchor" title="Link to installAction">#</a>
               </h3>
               
               <p>installAction returns the action for installing the result of a1.</p>
               
               <pre><code class="language-go">func (b *Builder) installAction(a1 *Action, mode BuildMode) *Action</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="installHeader" data-name="installHeader">
               <h3>
                  installHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#installHeader" class="anchor" title="Link to installHeader">#</a>
               </h3>
               
               <p>Install the cgo export header file, if there is one.</p>
               
               <pre><code class="language-go">func (b *Builder) installHeader(ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="installOutsideModule" data-name="installOutsideModule">
               <h3>
                  installOutsideModule 
                  <span class="badge">function</span>
                  
                  <a href="#installOutsideModule" class="anchor" title="Link to installOutsideModule">#</a>
               </h3>
               
               <p>installOutsideModule implements 'go install pkg@version'. It builds and
installs one or more main packages in module mode while ignoring any go.mod
in the current directory or parent directories.
See golang.org/issue/40276 for details and rationale.</p>
               
               <pre><code class="language-go">func installOutsideModule(ctx context.Context, args []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="installShlibname" data-name="installShlibname">
               <h3>
                  installShlibname 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#installShlibname" class="anchor" title="Link to installShlibname">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) installShlibname(ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="instrumentInit" data-name="instrumentInit">
               <h3>
                  instrumentInit 
                  <span class="badge">function</span>
                  
                  <a href="#instrumentInit" class="anchor" title="Link to instrumentInit">#</a>
               </h3>
               
               <pre><code class="language-go">func instrumentInit()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isObject" data-name="isObject">
               <h3>
                  isObject 
                  <span class="badge">function</span>
                  
                  <a href="#isObject" class="anchor" title="Link to isObject">#</a>
               </h3>
               
               <pre><code class="language-go">func isObject(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="joinUnambiguously" data-name="joinUnambiguously">
               <h3>
                  joinUnambiguously 
                  <span class="badge">function</span>
                  
                  <a href="#joinUnambiguously" class="anchor" title="Link to joinUnambiguously">#</a>
               </h3>
               
               <p>joinUnambiguously prints the slice, quoting where necessary to make the
output unambiguous.
TODO: See issue 5279. The printing of commands needs a complete redo.</p>
               
               <pre><code class="language-go">func joinUnambiguously(a []string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ld" data-name="ld">
               <h3>
                  ld 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ld" class="anchor" title="Link to ld">#</a>
               </h3>
               
               <pre><code class="language-go">func (noToolchain) ld(b *Builder, root *Action, targetPath string, importcfg string, mainpkg string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ld" data-name="ld">
               <h3>
                  ld 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ld" class="anchor" title="Link to ld">#</a>
               </h3>
               
               <pre><code class="language-go">func (tools gccgoToolchain) ld(b *Builder, root *Action, targetPath string, importcfg string, mainpkg string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ld" data-name="ld">
               <h3>
                  ld 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ld" class="anchor" title="Link to ld">#</a>
               </h3>
               
               <pre><code class="language-go">func (gcToolchain) ld(b *Builder, root *Action, targetPath string, importcfg string, mainpkg string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ldShared" data-name="ldShared">
               <h3>
                  ldShared 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ldShared" class="anchor" title="Link to ldShared">#</a>
               </h3>
               
               <pre><code class="language-go">func (noToolchain) ldShared(b *Builder, root *Action, toplevelactions []*Action, targetPath string, importcfg string, allactions []*Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ldShared" data-name="ldShared">
               <h3>
                  ldShared 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ldShared" class="anchor" title="Link to ldShared">#</a>
               </h3>
               
               <pre><code class="language-go">func (tools gccgoToolchain) ldShared(b *Builder, root *Action, toplevelactions []*Action, targetPath string, importcfg string, allactions []*Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ldShared" data-name="ldShared">
               <h3>
                  ldShared 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ldShared" class="anchor" title="Link to ldShared">#</a>
               </h3>
               
               <pre><code class="language-go">func (gcToolchain) ldShared(b *Builder, root *Action, toplevelactions []*Action, targetPath string, importcfg string, allactions []*Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="libname" data-name="libname">
               <h3>
                  libname 
                  <span class="badge">function</span>
                  
                  <a href="#libname" class="anchor" title="Link to libname">#</a>
               </h3>
               
               <p>libname returns the filename to use for the shared library when using
-buildmode=shared. The rules we use are:
Use arguments for special 'meta' packages:
std --> libstd.so
std cmd --> libstd,cmd.so
A single non-meta argument with trailing "/..." is special cased:
foo/... --> libfoo.so
(A relative path like "./..."  expands the "." first)
Use import paths for other cases, changing '/' to '-':
somelib --> libsubdir-somelib.so
./ or ../ --> libsubdir-somelib.so
gopkg.in/tomb.v2 -> libgopkg.in-tomb.v2.so
a/... b/... ---> liba/c,b/d.so - all matching import paths
Name parts are joined with ','.</p>
               
               <pre><code class="language-go">func libname(args []string, pkgs []*load.Package) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="link" data-name="link">
               <h3>
                  link 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#link" class="anchor" title="Link to link">#</a>
               </h3>
               
               <pre><code class="language-go">func (tools gccgoToolchain) link(b *Builder, root *Action, out string, importcfg string, allactions []*Action, buildmode string, desc string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="link" data-name="link">
               <h3>
                  link 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#link" class="anchor" title="Link to link">#</a>
               </h3>
               
               <p>link is the action for linking a single command.
Note that any new influence on this logic must be reported in b.linkActionID above as well.</p>
               
               <pre><code class="language-go">func (b *Builder) link(ctx context.Context, a *Action) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linkActionID" data-name="linkActionID">
               <h3>
                  linkActionID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linkActionID" class="anchor" title="Link to linkActionID">#</a>
               </h3>
               
               <p>linkActionID computes the action ID for a link action.</p>
               
               <pre><code class="language-go">func (b *Builder) linkActionID(a *Action) cache.ActionID</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linkShared" data-name="linkShared">
               <h3>
                  linkShared 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linkShared" class="anchor" title="Link to linkShared">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) linkShared(ctx context.Context, a *Action) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linkSharedAction" data-name="linkSharedAction">
               <h3>
                  linkSharedAction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linkSharedAction" class="anchor" title="Link to linkSharedAction">#</a>
               </h3>
               
               <p>linkSharedAction takes a grouping action a1 corresponding to a list of built packages
and returns an action that links them together into a shared library with the name shlib.
If a1 is nil, shlib should be an absolute path to an existing shared library,
and then linkSharedAction reads that library to find out the package list.</p>
               
               <pre><code class="language-go">func (b *Builder) linkSharedAction(mode BuildMode, depMode BuildMode, shlib string, a1 *Action) *Action</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linkSharedActionID" data-name="linkSharedActionID">
               <h3>
                  linkSharedActionID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linkSharedActionID" class="anchor" title="Link to linkSharedActionID">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) linkSharedActionID(a *Action) cache.ActionID</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linker" data-name="linker">
               <h3>
                  linker 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linker" class="anchor" title="Link to linker">#</a>
               </h3>
               
               <pre><code class="language-go">func (noToolchain) linker() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linker" data-name="linker">
               <h3>
                  linker 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linker" class="anchor" title="Link to linker">#</a>
               </h3>
               
               <pre><code class="language-go">func (gccgoToolchain) linker() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linker" data-name="linker">
               <h3>
                  linker 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linker" class="anchor" title="Link to linker">#</a>
               </h3>
               
               <pre><code class="language-go">func (gcToolchain) linker() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadCachedCgoHdr" data-name="loadCachedCgoHdr">
               <h3>
                  loadCachedCgoHdr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loadCachedCgoHdr" class="anchor" title="Link to loadCachedCgoHdr">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) loadCachedCgoHdr(a *Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadCachedCompiledGoFiles" data-name="loadCachedCompiledGoFiles">
               <h3>
                  loadCachedCompiledGoFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loadCachedCompiledGoFiles" class="anchor" title="Link to loadCachedCompiledGoFiles">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) loadCachedCompiledGoFiles(a *Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadCachedObjdirFile" data-name="loadCachedObjdirFile">
               <h3>
                  loadCachedObjdirFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loadCachedObjdirFile" class="anchor" title="Link to loadCachedObjdirFile">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) loadCachedObjdirFile(a *Action, c cache.Cache, name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadCachedVet" data-name="loadCachedVet">
               <h3>
                  loadCachedVet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loadCachedVet" class="anchor" title="Link to loadCachedVet">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) loadCachedVet(a *Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maybePIC" data-name="maybePIC">
               <h3>
                  maybePIC 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maybePIC" class="anchor" title="Link to maybePIC">#</a>
               </h3>
               
               <p>maybePIC adds -fPIC to the list of arguments if needed.</p>
               
               <pre><code class="language-go">func (tools gccgoToolchain) maybePIC(args []string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mayberemovefile" data-name="mayberemovefile">
               <h3>
                  mayberemovefile 
                  <span class="badge">function</span>
                  
                  <a href="#mayberemovefile" class="anchor" title="Link to mayberemovefile">#</a>
               </h3>
               
               <p>mayberemovefile removes a file only if it is a regular file
When running as a user with sufficient privileges, we may delete
even device files, for example, which is not intended.</p>
               
               <pre><code class="language-go">func mayberemovefile(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mkAbs" data-name="mkAbs">
               <h3>
                  mkAbs 
                  <span class="badge">function</span>
                  
                  <a href="#mkAbs" class="anchor" title="Link to mkAbs">#</a>
               </h3>
               
               <p>mkAbs returns an absolute path corresponding to
evaluating f in the directory dir.
We always pass absolute paths of source files so that
the error messages will include the full path to a file
in need of attention.</p>
               
               <pre><code class="language-go">func mkAbs(dir string, f string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mkAbsFiles" data-name="mkAbsFiles">
               <h3>
                  mkAbsFiles 
                  <span class="badge">function</span>
                  
                  <a href="#mkAbsFiles" class="anchor" title="Link to mkAbsFiles">#</a>
               </h3>
               
               <p>mkAbsFiles converts files into a list of absolute files,
assuming they were originally relative to dir,
and returns that new list.</p>
               
               <pre><code class="language-go">func mkAbsFiles(dir string, files []string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="moveOrCopyFile" data-name="moveOrCopyFile">
               <h3>
                  moveOrCopyFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#moveOrCopyFile" class="anchor" title="Link to moveOrCopyFile">#</a>
               </h3>
               
               <p>moveOrCopyFile is like 'mv src dst' or 'cp src dst'.</p>
               
               <pre><code class="language-go">func (sh *Shell) moveOrCopyFile(dst string, src string, perm fs.FileMode, force bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="needCgoHdr" data-name="needCgoHdr">
               <h3>
                  needCgoHdr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#needCgoHdr" class="anchor" title="Link to needCgoHdr">#</a>
               </h3>
               
               <p>needCgoHdr reports whether the actions triggered by this one
expect to be able to access the cgo-generated header file.</p>
               
               <pre><code class="language-go">func (b *Builder) needCgoHdr(a *Action) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newBuildActor" data-name="newBuildActor">
               <h3>
                  newBuildActor 
                  <span class="badge">function</span>
                  
                  <a href="#newBuildActor" class="anchor" title="Link to newBuildActor">#</a>
               </h3>
               
               <p>newBuildActor returns a new buildActor object, setting up the
covMetaFileName field if 'genCoverMeta' flag is set.</p>
               
               <pre><code class="language-go">func newBuildActor(p *load.Package, genCoverMeta bool) *buildActor</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="noCompiler" data-name="noCompiler">
               <h3>
                  noCompiler 
                  <span class="badge">function</span>
                  
                  <a href="#noCompiler" class="anchor" title="Link to noCompiler">#</a>
               </h3>
               
               <pre><code class="language-go">func noCompiler() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="omitTestOnly" data-name="omitTestOnly">
               <h3>
                  omitTestOnly 
                  <span class="badge">function</span>
                  
                  <a href="#omitTestOnly" class="anchor" title="Link to omitTestOnly">#</a>
               </h3>
               
               <p>omitTestOnly returns pkgs with test-only packages removed.</p>
               
               <pre><code class="language-go">func omitTestOnly(pkgs []*load.Package) []*load.Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="oneMainPkg" data-name="oneMainPkg">
               <h3>
                  oneMainPkg 
                  <span class="badge">function</span>
                  
                  <a href="#oneMainPkg" class="anchor" title="Link to oneMainPkg">#</a>
               </h3>
               
               <pre><code class="language-go">func oneMainPkg(pkgs []*load.Package) []*load.Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pack" data-name="pack">
               <h3>
                  pack 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pack" class="anchor" title="Link to pack">#</a>
               </h3>
               
               <pre><code class="language-go">func (noToolchain) pack(b *Builder, a *Action, afile string, ofiles []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pack" data-name="pack">
               <h3>
                  pack 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pack" class="anchor" title="Link to pack">#</a>
               </h3>
               
               <pre><code class="language-go">func (tools gccgoToolchain) pack(b *Builder, a *Action, afile string, ofiles []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pack" data-name="pack">
               <h3>
                  pack 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pack" class="anchor" title="Link to pack">#</a>
               </h3>
               
               <pre><code class="language-go">func (gcToolchain) pack(b *Builder, a *Action, afile string, ofiles []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="packInternal" data-name="packInternal">
               <h3>
                  packInternal 
                  <span class="badge">function</span>
                  
                  <a href="#packInternal" class="anchor" title="Link to packInternal">#</a>
               </h3>
               
               <pre><code class="language-go">func packInternal(afile string, ofiles []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="passLongArgsInResponseFiles" data-name="passLongArgsInResponseFiles">
               <h3>
                  passLongArgsInResponseFiles 
                  <span class="badge">function</span>
                  
                  <a href="#passLongArgsInResponseFiles" class="anchor" title="Link to passLongArgsInResponseFiles">#</a>
               </h3>
               
               <p>passLongArgsInResponseFiles modifies cmd such that, for
certain programs, long arguments are passed in "response files", a
file on disk with the arguments, with one arg per line. An actual
argument starting with '@' means that the rest of the argument is
a filename of arguments to expand.
See issues 18468 (Windows) and 37768 (Darwin).</p>
               
               <pre><code class="language-go">func passLongArgsInResponseFiles(cmd *exec.Cmd) (cleanup func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pgoActionID" data-name="pgoActionID">
               <h3>
                  pgoActionID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pgoActionID" class="anchor" title="Link to pgoActionID">#</a>
               </h3>
               
               <p>pgoActionID computes the action ID for a preprocess PGO action.</p>
               
               <pre><code class="language-go">func (b *Builder) pgoActionID(input string) cache.ActionID</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkg" data-name="pkg">
               <h3>
                  pkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkg" class="anchor" title="Link to pkg">#</a>
               </h3>
               
               <pre><code class="language-go">func (sh *Shell) pkg() *load.Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgPath" data-name="pkgPath">
               <h3>
                  pkgPath 
                  <span class="badge">function</span>
                  
                  <a href="#pkgPath" class="anchor" title="Link to pkgPath">#</a>
               </h3>
               
               <pre><code class="language-go">func pkgPath(a *Action) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgsMain" data-name="pkgsMain">
               <h3>
                  pkgsMain 
                  <span class="badge">function</span>
                  
                  <a href="#pkgsMain" class="anchor" title="Link to pkgsMain">#</a>
               </h3>
               
               <pre><code class="language-go">func pkgsMain(pkgs []*load.Package) (res []*load.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgsNotMain" data-name="pkgsNotMain">
               <h3>
                  pkgsNotMain 
                  <span class="badge">function</span>
                  
                  <a href="#pkgsNotMain" class="anchor" title="Link to pkgsNotMain">#</a>
               </h3>
               
               <pre><code class="language-go">func pkgsNotMain(pkgs []*load.Package) (res []*load.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pluginPath" data-name="pluginPath">
               <h3>
                  pluginPath 
                  <span class="badge">function</span>
                  
                  <a href="#pluginPath" class="anchor" title="Link to pluginPath">#</a>
               </h3>
               
               <p>pluginPath computes the package path for a plugin main package.
This is typically the import path of the main package p, unless the
plugin is being built directly from source files. In that case we
combine the package build ID with the contents of the main package
source files. This allows us to identify two different plugins
built from two source files with the same name.</p>
               
               <pre><code class="language-go">func pluginPath(a *Action) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pop" data-name="pop">
               <h3>
                  pop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pop" class="anchor" title="Link to pop">#</a>
               </h3>
               
               <pre><code class="language-go">func (q *actionQueue) pop() *Action</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printLinkerConfig" data-name="printLinkerConfig">
               <h3>
                  printLinkerConfig 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printLinkerConfig" class="anchor" title="Link to printLinkerConfig">#</a>
               </h3>
               
               <p>printLinkerConfig prints the linker config into the hash h,
as part of the computation of a linker-related action ID.</p>
               
               <pre><code class="language-go">func (b *Builder) printLinkerConfig(h io.Writer, p *load.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printfLocked" data-name="printfLocked">
               <h3>
                  printfLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printfLocked" class="anchor" title="Link to printfLocked">#</a>
               </h3>
               
               <pre><code class="language-go">func (sh *Shell) printfLocked(format string, a ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="push" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#push" class="anchor" title="Link to push">#</a>
               </h3>
               
               <pre><code class="language-go">func (q *actionQueue) push(a *Action)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readpkglist" data-name="readpkglist">
               <h3>
                  readpkglist 
                  <span class="badge">function</span>
                  
                  <a href="#readpkglist" class="anchor" title="Link to readpkglist">#</a>
               </h3>
               
               <p>readpkglist returns the list of packages that were built into the shared library
at shlibpath. For the native toolchain this list is stored, newline separated, in
an ELF note with name "Go\x00\x00" and type 1. For GCCGO it is extracted from the
.go_export section.</p>
               
               <pre><code class="language-go">func readpkglist(shlibpath string) (pkgs []*load.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="replacePrefix" data-name="replacePrefix">
               <h3>
                  replacePrefix 
                  <span class="badge">function</span>
                  
                  <a href="#replacePrefix" class="anchor" title="Link to replacePrefix">#</a>
               </h3>
               
               <p>replacePrefix is like strings.ReplaceAll, but only replaces instances of old
that are preceded by ' ', '\t', or appear at the beginning of a line.</p>
               
               <pre><code class="language-go">func replacePrefix(s string, old string, new string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reportCmd" data-name="reportCmd">
               <h3>
                  reportCmd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reportCmd" class="anchor" title="Link to reportCmd">#</a>
               </h3>
               
               <p>reportCmd reports the output and exit status of a command. The cmdOut and
cmdErr arguments are the output and exit error of the command, respectively.
The exact reporting behavior is as follows:
cmdOut  cmdErr  Result
""      nil     print nothing, return nil
!=""    nil     print output, return nil
""      !=nil   print nothing, return cmdErr (later printed)
!=""    !=nil   print nothing, ignore err, return output as error (later printed)
reportCmd returns a non-nil error if and only if cmdErr != nil. It assumes
that the command output, if non-empty, is more detailed than the command
error (which is usually just an exit status), so prefers using the output as
the ultimate error. Typically, the caller should return this error from an
Action, which it will be printed by the Builder.
reportCmd formats the output as "# desc" followed by the given output. The
output is expected to contain references to 'dir', usually the source
directory for the package that has failed to build. reportCmd rewrites
mentions of dir with a relative path to dir when the relative path is
shorter. This is usually more pleasant. For example, if fmt doesn't compile
and we are in src/html, the output is
$ go build
# fmt
../fmt/print.go:1090: undefined: asdf
$
instead of
$ go build
# fmt
/usr/gopher/go/src/fmt/print.go:1090: undefined: asdf
$
reportCmd also replaces references to the work directory with $WORK, replaces
cgo file paths with the original file path, and replaces cgo-mangled names
with "C.name".
desc is optional. If "", a.Package.Desc() is used.
dir is optional. If "", a.Package.Dir is used.</p>
               
               <pre><code class="language-go">func (sh *Shell) reportCmd(desc string, dir string, cmdOut []byte, cmdErr error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="run" data-name="run">
               <h3>
                  run 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#run" class="anchor" title="Link to run">#</a>
               </h3>
               
               <p>run runs the command given by cmdline in the directory dir.
If the command fails, run prints information about the failure
and returns a non-nil error.</p>
               
               <pre><code class="language-go">func (sh *Shell) run(dir string, desc string, env []string, cmdargs ...any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runBuild" data-name="runBuild">
               <h3>
                  runBuild 
                  <span class="badge">function</span>
                  
                  <a href="#runBuild" class="anchor" title="Link to runBuild">#</a>
               </h3>
               
               <pre><code class="language-go">func runBuild(ctx context.Context, cmd *base.Command, args []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runInstall" data-name="runInstall">
               <h3>
                  runInstall 
                  <span class="badge">function</span>
                  
                  <a href="#runInstall" class="anchor" title="Link to runInstall">#</a>
               </h3>
               
               <pre><code class="language-go">func runInstall(ctx context.Context, cmd *base.Command, args []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runOut" data-name="runOut">
               <h3>
                  runOut 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#runOut" class="anchor" title="Link to runOut">#</a>
               </h3>
               
               <p>runOut runs the command given by cmdline in the directory dir.
It returns the command output and any errors that occurred.
It accumulates execution time in a.</p>
               
               <pre><code class="language-go">func (sh *Shell) runOut(dir string, env []string, cmdargs ...any) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setextld" data-name="setextld">
               <h3>
                  setextld 
                  <span class="badge">function</span>
                  
                  <a href="#setextld" class="anchor" title="Link to setextld">#</a>
               </h3>
               
               <p>setextld sets the appropriate linker flags for the specified compiler.</p>
               
               <pre><code class="language-go">func setextld(ldflags []string, compiler []string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="showStdout" data-name="showStdout">
               <h3>
                  showStdout 
                  <span class="badge">function</span>
                  
                  <a href="#showStdout" class="anchor" title="Link to showStdout">#</a>
               </h3>
               
               <pre><code class="language-go">func showStdout(b *Builder, c cache.Cache, a *Action, key string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitPkgConfigOutput" data-name="splitPkgConfigOutput">
               <h3>
                  splitPkgConfigOutput 
                  <span class="badge">function</span>
                  
                  <a href="#splitPkgConfigOutput" class="anchor" title="Link to splitPkgConfigOutput">#</a>
               </h3>
               
               <p>splitPkgConfigOutput parses the pkg-config output into a slice of flags.
This implements the shell quoting semantics described in
https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02,
except that it does not support parameter or arithmetic expansion or command
substitution and hard-codes the <blank> delimiters instead of reading them
from LC_LOCALE.</p>
               
               <pre><code class="language-go">func splitPkgConfigOutput(out []byte) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="statString" data-name="statString">
               <h3>
                  statString 
                  <span class="badge">function</span>
                  
                  <a href="#statString" class="anchor" title="Link to statString">#</a>
               </h3>
               
               <p>statString returns a string form of an os.FileInfo, for serializing and comparison.</p>
               
               <pre><code class="language-go">func statString(info os.FileInfo) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="supportsCgoIncomplete" data-name="supportsCgoIncomplete">
               <h3>
                  supportsCgoIncomplete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#supportsCgoIncomplete" class="anchor" title="Link to supportsCgoIncomplete">#</a>
               </h3>
               
               <p>supportsCgoIncomplete reports whether the gccgo/GoLLVM compiler
being used supports cgo.Incomplete, which was added in GCC 13.
This takes an Action only for output reporting purposes.
The result value is unrelated to the Action.</p>
               
               <pre><code class="language-go">func (tools gccgoToolchain) supportsCgoIncomplete(b *Builder, a *Action) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="swig" data-name="swig">
               <h3>
                  swig 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#swig" class="anchor" title="Link to swig">#</a>
               </h3>
               
               <p>Run SWIG on all SWIG input files.
TODO: Don't build a shared library, once SWIG emits the necessary
pragmas for external linking.</p>
               
               <pre><code class="language-go">func (b *Builder) swig(a *Action, objdir string, pcCFLAGS []string) (outGo []string, outC []string, outCXX []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="swigDoIntSize" data-name="swigDoIntSize">
               <h3>
                  swigDoIntSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#swigDoIntSize" class="anchor" title="Link to swigDoIntSize">#</a>
               </h3>
               
               <p>Determine the size of int on the target system for the -intgosize option
of swig >= 2.0.9. Run only once.</p>
               
               <pre><code class="language-go">func (b *Builder) swigDoIntSize(objdir string) (intsize string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="swigDoVersionCheck" data-name="swigDoVersionCheck">
               <h3>
                  swigDoVersionCheck 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#swigDoVersionCheck" class="anchor" title="Link to swigDoVersionCheck">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) swigDoVersionCheck() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="swigIntSize" data-name="swigIntSize">
               <h3>
                  swigIntSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#swigIntSize" class="anchor" title="Link to swigIntSize">#</a>
               </h3>
               
               <p>Determine the size of int on the target system for the -intgosize option
of swig >= 2.0.9.</p>
               
               <pre><code class="language-go">func (b *Builder) swigIntSize(objdir string) (intsize string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="swigOne" data-name="swigOne">
               <h3>
                  swigOne 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#swigOne" class="anchor" title="Link to swigOne">#</a>
               </h3>
               
               <p>Run SWIG on one SWIG input file.</p>
               
               <pre><code class="language-go">func (b *Builder) swigOne(a *Action, file string, objdir string, pcCFLAGS []string, cxx bool, intgosize string) (outGo string, outC string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="swigVersionCheck" data-name="swigVersionCheck">
               <h3>
                  swigVersionCheck 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#swigVersionCheck" class="anchor" title="Link to swigVersionCheck">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) swigVersionCheck() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="symabis" data-name="symabis">
               <h3>
                  symabis 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#symabis" class="anchor" title="Link to symabis">#</a>
               </h3>
               
               <pre><code class="language-go">func (gcToolchain) symabis(b *Builder, a *Action, sfiles []string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="symabis" data-name="symabis">
               <h3>
                  symabis 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#symabis" class="anchor" title="Link to symabis">#</a>
               </h3>
               
               <pre><code class="language-go">func (noToolchain) symabis(b *Builder, a *Action, sfiles []string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="symabis" data-name="symabis">
               <h3>
                  symabis 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#symabis" class="anchor" title="Link to symabis">#</a>
               </h3>
               
               <pre><code class="language-go">func (gccgoToolchain) symabis(b *Builder, a *Action, sfiles []string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toolID" data-name="toolID">
               <h3>
                  toolID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#toolID" class="anchor" title="Link to toolID">#</a>
               </h3>
               
               <p>toolID returns the unique ID to use for the current copy of the
named tool (asm, compile, cover, link).
It is important that if the tool changes (for example a compiler bug is fixed
and the compiler reinstalled), toolID returns a different string, so that old
package archives look stale and are rebuilt (with the fixed compiler).
This suggests using a content hash of the tool binary, as stored in the build ID.
Unfortunately, we can't just open the tool binary, because the tool might be
invoked via a wrapper program specified by -toolexec and we don't know
what the wrapper program does. In particular, we want "-toolexec toolstash"
to continue working: it does no good if "-toolexec toolstash" is executing a
stashed copy of the compiler but the go command is acting as if it will run
the standard copy of the compiler. The solution is to ask the tool binary to tell
us its own build ID using the "-V=full" flag now supported by all tools.
Then we know we're getting the build ID of the compiler that will actually run
during the build. (How does the compiler binary know its own content hash?
We store it there using updateBuildID after the standard link step.)
A final twist is that we'd prefer to have reproducible builds for release toolchains.
It should be possible to cross-compile for Windows from either Linux or Mac
or Windows itself and produce the same binaries, bit for bit. If the tool ID,
which influences the action ID half of the build ID, is based on the content ID,
then the Linux compiler binary and Mac compiler binary will have different tool IDs
and therefore produce executables with different action IDs.
To avoid this problem, for releases we use the release version string instead
of the compiler binary's content hash. This assumes that all compilers built
on all different systems are semantically equivalent, which is of course only true
modulo bugs. (Producing the exact same executables also requires that the different
build setups agree on details like $GOROOT and file name paths, but at least the
tool IDs do not make it impossible.)</p>
               
               <pre><code class="language-go">func (b *Builder) toolID(name string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toolVerify" data-name="toolVerify">
               <h3>
                  toolVerify 
                  <span class="badge">function</span>
                  
                  <a href="#toolVerify" class="anchor" title="Link to toolVerify">#</a>
               </h3>
               
               <p>toolVerify checks that the command line args writes the same output file
if run using newTool instead.
Unused now but kept around for future use.</p>
               
               <pre><code class="language-go">func toolVerify(a *Action, b *Builder, p *load.Package, newTool string, ofile string, args []any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimpath" data-name="trimpath">
               <h3>
                  trimpath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trimpath" class="anchor" title="Link to trimpath">#</a>
               </h3>
               
               <p>trimpath returns the -trimpath argument to use
when compiling the action.</p>
               
               <pre><code class="language-go">func (a *Action) trimpath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateBuildID" data-name="updateBuildID">
               <h3>
                  updateBuildID 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateBuildID" class="anchor" title="Link to updateBuildID">#</a>
               </h3>
               
               <p>updateBuildID updates the build ID in the target written by action a.
It requires that useCache was called for action a and returned false,
and that the build was then carried out and given the temporary
a.buildID to record as the build ID in the resulting package or binary.
updateBuildID computes the final content ID and updates the build IDs
in the binary.
Keep in sync with src/cmd/buildid/buildid.go</p>
               
               <pre><code class="language-go">func (b *Builder) updateBuildID(a *Action, target string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="useCache" data-name="useCache">
               <h3>
                  useCache 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#useCache" class="anchor" title="Link to useCache">#</a>
               </h3>
               
               <p>useCache tries to satisfy the action a, which has action ID actionHash,
by using a cached result from an earlier build.
If useCache decides that the cache can be used, it sets a.buildID
and a.built for use by parent actions and then returns true.
Otherwise it sets a.buildID to a temporary build ID for use in the build
and returns false. When useCache returns false the expectation is that
the caller will build the target and then call updateBuildID to finish the
build ID computation.
When useCache returns false, it may have initiated buffering of output
during a's work. The caller should defer b.flushOutput(a), to make sure
that flushOutput is eventually called regardless of whether the action
succeeds. The flushOutput call must happen after updateBuildID.</p>
               
               <pre><code class="language-go">func (b *Builder) useCache(a *Action, actionHash cache.ActionID, target string, printOutput bool) (ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="useResponseFile" data-name="useResponseFile">
               <h3>
                  useResponseFile 
                  <span class="badge">function</span>
                  
                  <a href="#useResponseFile" class="anchor" title="Link to useResponseFile">#</a>
               </h3>
               
               <pre><code class="language-go">func useResponseFile(path string, argLen int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="vet" data-name="vet">
               <h3>
                  vet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#vet" class="anchor" title="Link to vet">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) vet(ctx context.Context, a *Action) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="vetAction" data-name="vetAction">
               <h3>
                  vetAction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#vetAction" class="anchor" title="Link to vetAction">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) vetAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeCoverPkgInputs" data-name="writeCoverPkgInputs">
               <h3>
                  writeCoverPkgInputs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeCoverPkgInputs" class="anchor" title="Link to writeCoverPkgInputs">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) writeCoverPkgInputs(a *Action, pconfigfile string, covoutputsfile string, outfiles []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFile" data-name="writeFile">
               <h3>
                  writeFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFile" class="anchor" title="Link to writeFile">#</a>
               </h3>
               
               <p>writeFile writes the text to file.</p>
               
               <pre><code class="language-go">func (sh *Shell) writeFile(file string, text []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeLinkImportcfg" data-name="writeLinkImportcfg">
               <h3>
                  writeLinkImportcfg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeLinkImportcfg" class="anchor" title="Link to writeLinkImportcfg">#</a>
               </h3>
               
               <pre><code class="language-go">func (b *Builder) writeLinkImportcfg(a *Action, file string) error</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>