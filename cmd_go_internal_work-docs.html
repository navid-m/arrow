<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - work</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>work</code>
         </h1>
         <hr />
         
         <article class="global" data-name="ToolchainVersion">
            <h2>ToolchainVersion</h2>
            <hr />
            
            <p>Tests can override this by setting $TESTGO_TOOLCHAIN_VERSION.</p>
            
            <pre><code>ToolchainVersion</code></pre>
         </article>
         
         <article class="global" data-name="GccgoName">
            <h2>GccgoName</h2>
            <hr />
            
            <pre><code>GccgoName string</code></pre>
         </article>
         
         <article class="global" data-name="GccgoBin">
            <h2>GccgoBin</h2>
            <hr />
            
            <pre><code>GccgoBin string</code></pre>
         </article>
         
         <article class="global" data-name="gccgoErr">
            <h2>gccgoErr</h2>
            <hr />
            
            <pre><code>gccgoErr error</code></pre>
         </article>
         
         <article class="global" data-name="gccgoToSymbolFuncOnce">
            <h2>gccgoToSymbolFuncOnce</h2>
            <hr />
            
            <pre><code>gccgoToSymbolFuncOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="gccgoToSymbolFunc">
            <h2>gccgoToSymbolFunc</h2>
            <hr />
            
            <pre><code>gccgoToSymbolFunc func</code></pre>
         </article>
         
         <article class="global" data-name="gccgoSupportsCgoIncompleteOnce">
            <h2>gccgoSupportsCgoIncompleteOnce</h2>
            <hr />
            
            <pre><code>gccgoSupportsCgoIncompleteOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="gccgoSupportsCgoIncomplete">
            <h2>gccgoSupportsCgoIncomplete</h2>
            <hr />
            
            <pre><code>gccgoSupportsCgoIncomplete bool</code></pre>
         </article>
         
         <article class="global" data-name="gccgoSupportsCgoIncompleteCode">
            <h2>gccgoSupportsCgoIncompleteCode</h2>
            <hr />
            
            <pre><code>gccgoSupportsCgoIncompleteCode</code></pre>
         </article>
         
         <article class="global" data-name="buildInitStarted">
            <h2>buildInitStarted</h2>
            <hr />
            
            <pre><code>buildInitStarted</code></pre>
         </article>
         
         <article class="global" data-name="compiler">
            <h2>compiler</h2>
            <hr />
            
            <pre><code>compiler *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="ModeBuild">
            <h2>ModeBuild</h2>
            <hr />
            
            <pre><code>ModeBuild BuildMode</code></pre>
         </article>
         
         <article class="global" data-name="ModeInstall">
            <h2>ModeInstall</h2>
            <hr />
            
            <pre><code>ModeInstall</code></pre>
         </article>
         
         <article class="global" data-name="ModeBuggyInstall">
            <h2>ModeBuggyInstall</h2>
            <hr />
            
            <pre><code>ModeBuggyInstall</code></pre>
         </article>
         
         <article class="global" data-name="ModeVetOnly">
            <h2>ModeVetOnly</h2>
            <hr />
            
            <pre><code>ModeVetOnly</code></pre>
         </article>
         
         <article class="global" data-name="builderWorkDirs">
            <h2>builderWorkDirs</h2>
            <hr />
            
            <pre><code>builderWorkDirs sync.Map</code></pre>
         </article>
         
         <article class="global" data-name="DefaultCFlags">
            <h2>DefaultCFlags</h2>
            <hr />
            
            <pre><code>DefaultCFlags</code></pre>
         </article>
         
         <article class="global" data-name="needBuild">
            <h2>needBuild</h2>
            <hr />
            
            <pre><code>needBuild uint32</code></pre>
         </article>
         
         <article class="global" data-name="needCgoHdr">
            <h2>needCgoHdr</h2>
            <hr />
            
            <pre><code>needCgoHdr</code></pre>
         </article>
         
         <article class="global" data-name="needVet">
            <h2>needVet</h2>
            <hr />
            
            <pre><code>needVet</code></pre>
         </article>
         
         <article class="global" data-name="needCompiledGoFiles">
            <h2>needCompiledGoFiles</h2>
            <hr />
            
            <pre><code>needCompiledGoFiles</code></pre>
         </article>
         
         <article class="global" data-name="needCovMetaFile">
            <h2>needCovMetaFile</h2>
            <hr />
            
            <pre><code>needCovMetaFile</code></pre>
         </article>
         
         <article class="global" data-name="needStale">
            <h2>needStale</h2>
            <hr />
            
            <pre><code>needStale</code></pre>
         </article>
         
         <article class="global" data-name="VetTool">
            <h2>VetTool</h2>
            <hr />
            
            <p>VetTool is the path to an alternate vet tool binary.
The caller is expected to set it (if needed) before executing any vet actions.</p>
            
            <pre><code>VetTool string</code></pre>
         </article>
         
         <article class="global" data-name="VetFlags">
            <h2>VetFlags</h2>
            <hr />
            
            <p>VetFlags are the default flags to pass to vet.
The caller is expected to set them before executing any vet actions.</p>
            
            <pre><code>VetFlags []string</code></pre>
         </article>
         
         <article class="global" data-name="VetExplicit">
            <h2>VetExplicit</h2>
            <hr />
            
            <p>VetExplicit records whether the vet flags were set explicitly on the command line.</p>
            
            <pre><code>VetExplicit bool</code></pre>
         </article>
         
         <article class="global" data-name="AllowInstall">
            <h2>AllowInstall</h2>
            <hr />
            
            <p>AllowInstall returns a non-nil error if this invocation of the go command is
allowed to install a.Target.

The build of cmd/go running under its own test is forbidden from installing
to its original GOROOT. The var is exported so it can be set by TestMain.</p>
            
            <pre><code>AllowInstall</code></pre>
         </article>
         
         <article class="global" data-name="objectMagic">
            <h2>objectMagic</h2>
            <hr />
            
            <pre><code>objectMagic</code></pre>
         </article>
         
         <article class="global" data-name="cgoRe">
            <h2>cgoRe</h2>
            <hr />
            
            <pre><code>cgoRe</code></pre>
         </article>
         
         <article class="global" data-name="swigCheckOnce">
            <h2>swigCheckOnce</h2>
            <hr />
            
            <p>Make sure SWIG is new enough.</p>
            
            <pre><code>swigCheckOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="swigCheck">
            <h2>swigCheck</h2>
            <hr />
            
            <p>Make sure SWIG is new enough.</p>
            
            <pre><code>swigCheck error</code></pre>
         </article>
         
         <article class="global" data-name="swigIntSizeOnce">
            <h2>swigIntSizeOnce</h2>
            <hr />
            
            <p>Find the value to pass for the -intgosize option to swig.</p>
            
            <pre><code>swigIntSizeOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="swigIntSize">
            <h2>swigIntSize</h2>
            <hr />
            
            <p>Find the value to pass for the -intgosize option to swig.</p>
            
            <pre><code>swigIntSize string</code></pre>
         </article>
         
         <article class="global" data-name="swigIntSizeError">
            <h2>swigIntSizeError</h2>
            <hr />
            
            <p>Find the value to pass for the -intgosize option to swig.</p>
            
            <pre><code>swigIntSizeError error</code></pre>
         </article>
         
         <article class="global" data-name="swigIntSizeCode">
            <h2>swigIntSizeCode</h2>
            <hr />
            
            <p>This code fails to build if sizeof(int) <= 32</p>
            
            <pre><code>swigIntSizeCode</code></pre>
         </article>
         
         <article class="global" data-name="re">
            <h2>re</h2>
            <hr />
            
            <pre><code>re</code></pre>
         </article>
         
         <article class="global" data-name="validCompilerFlags">
            <h2>validCompilerFlags</h2>
            <hr />
            
            <pre><code>validCompilerFlags</code></pre>
         </article>
         
         <article class="global" data-name="validCompilerFlagsWithNextArg">
            <h2>validCompilerFlagsWithNextArg</h2>
            <hr />
            
            <pre><code>validCompilerFlagsWithNextArg</code></pre>
         </article>
         
         <article class="global" data-name="invalidLinkerFlags">
            <h2>invalidLinkerFlags</h2>
            <hr />
            
            <pre><code>invalidLinkerFlags</code></pre>
         </article>
         
         <article class="global" data-name="validLinkerFlags">
            <h2>validLinkerFlags</h2>
            <hr />
            
            <pre><code>validLinkerFlags</code></pre>
         </article>
         
         <article class="global" data-name="validLinkerFlagsWithNextArg">
            <h2>validLinkerFlagsWithNextArg</h2>
            <hr />
            
            <pre><code>validLinkerFlagsWithNextArg</code></pre>
         </article>
         
         <article class="global" data-name="goodCompilerFlags">
            <h2>goodCompilerFlags</h2>
            <hr />
            
            <pre><code>goodCompilerFlags</code></pre>
         </article>
         
         <article class="global" data-name="badCompilerFlags">
            <h2>badCompilerFlags</h2>
            <hr />
            
            <pre><code>badCompilerFlags</code></pre>
         </article>
         
         <article class="global" data-name="goodLinkerFlags">
            <h2>goodLinkerFlags</h2>
            <hr />
            
            <pre><code>goodLinkerFlags</code></pre>
         </article>
         
         <article class="global" data-name="badLinkerFlags">
            <h2>badLinkerFlags</h2>
            <hr />
            
            <pre><code>badLinkerFlags</code></pre>
         </article>
         
         <article class="global" data-name="cgoLine">
            <h2>cgoLine</h2>
            <hr />
            
            <pre><code>cgoLine</code></pre>
         </article>
         
         <article class="global" data-name="cgoTypeSigRe">
            <h2>cgoTypeSigRe</h2>
            <hr />
            
            <pre><code>cgoTypeSigRe</code></pre>
         </article>
         
         <article class="global" data-name="CmdBuild">
            <h2>CmdBuild</h2>
            <hr />
            
            <pre><code>CmdBuild</code></pre>
         </article>
         
         <article class="global" data-name="concurrentGCBackendCompilationEnabledByDefault">
            <h2>concurrentGCBackendCompilationEnabledByDefault</h2>
            <hr />
            
            <pre><code>concurrentGCBackendCompilationEnabledByDefault</code></pre>
         </article>
         
         <article class="global" data-name="forcedAsmflags">
            <h2>forcedAsmflags</h2>
            <hr />
            
            <pre><code>forcedAsmflags []string</code></pre>
         </article>
         
         <article class="global" data-name="forcedGcflags">
            <h2>forcedGcflags</h2>
            <hr />
            
            <pre><code>forcedGcflags []string</code></pre>
         </article>
         
         <article class="global" data-name="forcedLdflags">
            <h2>forcedLdflags</h2>
            <hr />
            
            <pre><code>forcedLdflags []string</code></pre>
         </article>
         
         <article class="global" data-name="forcedGccgoflags">
            <h2>forcedGccgoflags</h2>
            <hr />
            
            <pre><code>forcedGccgoflags []string</code></pre>
         </article>
         
         <article class="global" data-name="BuildToolchain">
            <h2>BuildToolchain</h2>
            <hr />
            
            <pre><code>BuildToolchain toolchain</code></pre>
         </article>
         
         <article class="global" data-name="ldBuildmode">
            <h2>ldBuildmode</h2>
            <hr />
            
            <pre><code>ldBuildmode string</code></pre>
         </article>
         
         <article class="global" data-name="DefaultBuildFlags">
            <h2>DefaultBuildFlags</h2>
            <hr />
            
            <pre><code>DefaultBuildFlags BuildFlagMask</code></pre>
         </article>
         
         <article class="global" data-name="OmitModFlag">
            <h2>OmitModFlag</h2>
            <hr />
            
            <pre><code>OmitModFlag BuildFlagMask</code></pre>
         </article>
         
         <article class="global" data-name="OmitModCommonFlags">
            <h2>OmitModCommonFlags</h2>
            <hr />
            
            <pre><code>OmitModCommonFlags</code></pre>
         </article>
         
         <article class="global" data-name="OmitVFlag">
            <h2>OmitVFlag</h2>
            <hr />
            
            <pre><code>OmitVFlag</code></pre>
         </article>
         
         <article class="global" data-name="OmitBuildOnlyFlags">
            <h2>OmitBuildOnlyFlags</h2>
            <hr />
            
            <pre><code>OmitBuildOnlyFlags</code></pre>
         </article>
         
         <article class="global" data-name="OmitJSONFlag">
            <h2>OmitJSONFlag</h2>
            <hr />
            
            <pre><code>OmitJSONFlag</code></pre>
         </article>
         
         <article class="global" data-name="pkgsFilter">
            <h2>pkgsFilter</h2>
            <hr />
            
            <pre><code>pkgsFilter</code></pre>
         </article>
         
         <article class="global" data-name="CmdInstall">
            <h2>CmdInstall</h2>
            <hr />
            
            <pre><code>CmdInstall</code></pre>
         </article>
         
         <article class="global" data-name="ExecCmd">
            <h2>ExecCmd</h2>
            <hr />
            
            <p>ExecCmd is the command to use to run user binaries.
Normally it is empty, meaning run the binaries directly.
If cross-compiling and running on a remote system or
simulator, it is typically go_GOOS_GOARCH_exec, with
the target GOOS and GOARCH substituted.
The -exec flag overrides these defaults.</p>
            
            <pre><code>ExecCmd []string</code></pre>
         </article>
         
         <article class="global" data-name="buildIDSeparator">
            <h2>buildIDSeparator</h2>
            <hr />
            
            <pre><code>buildIDSeparator</code></pre>
         </article>
         
         <article class="global" data-name="counterCacheHit">
            <h2>counterCacheHit</h2>
            <hr />
            
            <pre><code>counterCacheHit</code></pre>
         </article>
         
         <article class="global" data-name="counterCacheMiss">
            <h2>counterCacheMiss</h2>
            <hr />
            
            <pre><code>counterCacheMiss</code></pre>
         </article>
         
         <article class="global" data-name="stdlibRecompiled">
            <h2>stdlibRecompiled</h2>
            <hr />
            
            <pre><code>stdlibRecompiled</code></pre>
         </article>
         
         <article class="global" data-name="stdlibRecompiledIncOnce">
            <h2>stdlibRecompiledIncOnce</h2>
            <hr />
            
            <pre><code>stdlibRecompiledIncOnce</code></pre>
         </article>
          
         <article class="struct" data-name="gcToolchain">
            <h2>type gcToolchain struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="gccgoToolchain">
            <h2>type gccgoToolchain struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="version">
            <h2>type version struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
major int
minor int</code></pre>
         </article>
         
         <article class="struct" data-name="Builder">
            <h2>type Builder struct</h2>
            <hr />
            
            <p>A Builder holds global state about a build.
It does not hold per-package state, because we
build packages in parallel, and the builder is shared.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">WorkDir string
actionCache *ast.MapType
flagCache *ast.MapType
gccCompilerIDCache *ast.MapType
IsCmdList bool
NeedError bool
NeedExport bool
NeedCompiledGoFiles bool
AllowErrors bool
objdirSeq int
pkgSeq int
backgroundSh *Shell
exec sync.Mutex
readySema *ast.ChanType
ready actionQueue
id sync.Mutex
toolIDCache *ast.MapType
buildIDCache *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="Action">
            <h2>type Action struct</h2>
            <hr />
            
            <p>An Action represents a single action in the action graph.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Mode string
Package *load.Package
Deps []*Action
Actor Actor
IgnoreFail bool
TestOutput *bytes.Buffer
Args []string
triggers []*Action
buggyInstall bool
TryCache func
CacheExecutable bool
Objdir string
Target string
built string
actionID cache.ActionID
buildID string
VetxOnly bool
needVet bool
needBuild bool
vetCfg *vetConfig
output []byte
sh *Shell
pending int
priority int
Failed *Action
json *actionJSON
nonGoOverlay *ast.MapType
traceSpan *trace.Span</code></pre>
         </article>
         
         <article class="struct" data-name="actionJSON">
            <h2>type actionJSON struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ID int
Mode string
Package string
Deps []int
IgnoreFail bool
Args []string
Link bool
Objdir string
Target string
Priority int
Failed bool
Built string
VetxOnly bool
NeedVet bool
NeedBuild bool
ActionID string
BuildID string
TimeReady time.Time
TimeStart time.Time
TimeDone time.Time
Cmd []string
CmdReal time.Duration
CmdUser time.Duration
CmdSys time.Duration</code></pre>
         </article>
         
         <article class="struct" data-name="cacheKey">
            <h2>type cacheKey struct</h2>
            <hr />
            
            <p>cacheKey is the key for the action cache.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mode string
p *load.Package</code></pre>
         </article>
         
         <article class="struct" data-name="buildActor">
            <h2>type buildActor struct</h2>
            <hr />
            
            <p>buildActor implements the Actor interface for package build
actions. For most package builds this simply means invoking th
*Builder.build method; in the case of "go test -cover" for
a package with no test files, we stores some additional state
information in the build actor to help with reporting.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">covMetaFileName string</code></pre>
         </article>
         
         <article class="struct" data-name="pgoActor">
            <h2>type pgoActor struct</h2>
            <hr />
            
            <p>pgoActor implements the Actor interface for preprocessing PGO profiles.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">input string</code></pre>
         </article>
         
         <article class="struct" data-name="vetConfig">
            <h2>type vetConfig struct</h2>
            <hr />
            
            <p>vetConfig is the configuration passed to vet describing a single package.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ID string
Compiler string
Dir string
ImportPath string
GoFiles []string
NonGoFiles []string
IgnoredFiles []string
ModulePath string
ModuleVersion string
ImportMap *ast.MapType
PackageFile *ast.MapType
Standard *ast.MapType
PackageVetx *ast.MapType
VetxOnly bool
VetxOutput string
GoVersion string
SucceedOnTypecheckFailure bool</code></pre>
         </article>
         
         <article class="struct" data-name="noToolchain">
            <h2>type noToolchain struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="Shell">
            <h2>type Shell struct</h2>
            <hr />
            
            <p>A Shell runs shell commands and performs shell-like file system operations.

Shell tracks context related to running commands, and form a tree much like
context.Context.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">action *Action
*shellShared</code></pre>
         </article>
         
         <article class="struct" data-name="shellShared">
            <h2>type shellShared struct</h2>
            <hr />
            
            <p>shellShared is Shell state shared across all Shells derived from a single
root shell (generally a single Builder).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">workDir string
printLock sync.Mutex
printer load.Printer
scriptDir string
mkdirCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="struct" data-name="cmdError">
            <h2>type cmdError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">desc string
text string
importPath string
needsPath bool</code></pre>
         </article>
         
         <article class="struct" data-name="buildCompiler">
            <h2>type buildCompiler struct</h2>
            <hr />
            
            <p>buildCompiler implements flag.Var.
It implements Set by updating both
BuildToolchain and buildContext.Compiler.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="coverFlag">
            <h2>type coverFlag struct</h2>
            <hr />
            
            <p>A coverFlag is a flag.Value that also implies -cover.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">V flag.Value</code></pre>
         </article>
         
         <article class="struct" data-name="commaListFlag">
            <h2>type commaListFlag struct</h2>
            <hr />
            
            <p>A commaListFlag is a flag.Value representing a comma-separated list.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Vals *[]string</code></pre>
         </article>
         
         <article class="struct" data-name="stringFlag">
            <h2>type stringFlag struct</h2>
            <hr />
            
            <p>A stringFlag is a flag.Value representing a single string.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">val *string</code></pre>
         </article>
          
         <article class="function" data-name="CovData">
            <h2>CovData</h2>
            <hr />
            
            <p>CovData invokes "go tool covdata" with the specified arguments
as part of the execution of action 'a'.</p>
            
            <pre><code>func CovData(a *Action, cmdargs ...any) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="BuildActionCoverMetaFile">
            <h2>BuildActionCoverMetaFile</h2>
            <hr />
            
            <p>BuildActionCoverMetaFile locates and returns the path of the
meta-data file written by the "go tool cover" step as part of the
build action for the "go test -cover" run action 'runAct'. Note
that if the package has no functions the meta-data file will exist
but will be empty; in this case the return is an empty string.</p>
            
            <pre><code>func BuildActionCoverMetaFile(runAct *Action) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteCoveragePercent">
            <h2>WriteCoveragePercent</h2>
            <hr />
            
            <p>WriteCoveragePercent writes out to the writer 'w' a "percent
statements covered" for the package whose test-run action is
'runAct', based on the meta-data file 'mf'. This helper is used in
cases where a user runs "go test -cover" on a package that has
functions but no tests; in the normal case (package has tests)
the percentage is written by the test binary when it runs.</p>
            
            <pre><code>func WriteCoveragePercent(b *Builder, runAct *Action, mf string, w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="WriteCoverageProfile">
            <h2>WriteCoverageProfile</h2>
            <hr />
            
            <p>WriteCoverageProfile writes out a coverage profile fragment for the
package whose test-run action is 'runAct'; content is written to
the file 'outf' based on the coverage meta-data info found in
'mf'. This helper is used in cases where a user runs "go test
-cover" on a package that has functions but no tests.</p>
            
            <pre><code>func WriteCoverageProfile(b *Builder, runAct *Action, mf string, outf string, w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="WriteCoverMetaFilesFile">
            <h2>WriteCoverMetaFilesFile</h2>
            <hr />
            
            <p>WriteCoverMetaFilesFile writes out a summary file ("meta-files
file") as part of the action function for the "writeCoverMeta"
pseudo action employed during "go test -coverpkg" runs where there
are multiple tests and multiple packages covered. It builds up a
table mapping package import path to meta-data file fragment and
writes it out to a file where it can be read by the various test
run actions. Note that this function has to be called A) after the
build actions are complete for all packages being tested, and B)
before any of the "run test" actions for those packages happen.
This requirement is enforced by adding making this action ("a")
dependent on all test package build actions, and making all test
run actions dependent on this action.</p>
            
            <pre><code>func WriteCoverMetaFilesFile(b *Builder, ctx context.Context, a *Action) error</code></pre>
         </article>
         
         <article class="function" data-name="compiler">
            <h2>compiler</h2>
            <hr />
            
            <pre><code>func compiler() string</code></pre>
         </article>
         
         <article class="function" data-name="linker">
            <h2>linker</h2>
            <hr />
            
            <pre><code>func linker() string</code></pre>
         </article>
         
         <article class="function" data-name="pkgPath">
            <h2>pkgPath</h2>
            <hr />
            
            <pre><code>func pkgPath(a *Action) string</code></pre>
         </article>
         
         <article class="function" data-name="gc">
            <h2>gc</h2>
            <hr />
            
            <pre><code>func gc(b *Builder, a *Action, archive string, importcfg []byte, embedcfg []byte, symabis string, asmhdr bool, pgoProfile string, gofiles []string) (ofile string, output []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="gcBackendConcurrency">
            <h2>gcBackendConcurrency</h2>
            <hr />
            
            <p>gcBackendConcurrency returns the backend compiler concurrency level for a package compilation.</p>
            
            <pre><code>func gcBackendConcurrency(gcflags []string) int</code></pre>
         </article>
         
         <article class="function" data-name="trimpath">
            <h2>trimpath</h2>
            <hr />
            
            <p>trimpath returns the -trimpath argument to use
when compiling the action.</p>
            
            <pre><code>func trimpath() string</code></pre>
         </article>
         
         <article class="function" data-name="asmArgs">
            <h2>asmArgs</h2>
            <hr />
            
            <pre><code>func asmArgs(a *Action, p *load.Package) []any</code></pre>
         </article>
         
         <article class="function" data-name="asm">
            <h2>asm</h2>
            <hr />
            
            <pre><code>func asm(b *Builder, a *Action, sfiles []string) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="symabis">
            <h2>symabis</h2>
            <hr />
            
            <pre><code>func symabis(b *Builder, a *Action, sfiles []string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="toolVerify">
            <h2>toolVerify</h2>
            <hr />
            
            <p>toolVerify checks that the command line args writes the same output file
if run using newTool instead.
Unused now but kept around for future use.</p>
            
            <pre><code>func toolVerify(a *Action, b *Builder, p *load.Package, newTool string, ofile string, args []any) error</code></pre>
         </article>
         
         <article class="function" data-name="pack">
            <h2>pack</h2>
            <hr />
            
            <pre><code>func pack(b *Builder, a *Action, afile string, ofiles []string) error</code></pre>
         </article>
         
         <article class="function" data-name="packInternal">
            <h2>packInternal</h2>
            <hr />
            
            <pre><code>func packInternal(afile string, ofiles []string) error</code></pre>
         </article>
         
         <article class="function" data-name="setextld">
            <h2>setextld</h2>
            <hr />
            
            <p>setextld sets the appropriate linker flags for the specified compiler.</p>
            
            <pre><code>func setextld(ldflags []string, compiler []string) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="pluginPath">
            <h2>pluginPath</h2>
            <hr />
            
            <p>pluginPath computes the package path for a plugin main package.

This is typically the import path of the main package p, unless the
plugin is being built directly from source files. In that case we
combine the package build ID with the contents of the main package
source files. This allows us to identify two different plugins
built from two source files with the same name.</p>
            
            <pre><code>func pluginPath(a *Action) string</code></pre>
         </article>
         
         <article class="function" data-name="ld">
            <h2>ld</h2>
            <hr />
            
            <pre><code>func ld(b *Builder, root *Action, targetPath string, importcfg string, mainpkg string) error</code></pre>
         </article>
         
         <article class="function" data-name="ldShared">
            <h2>ldShared</h2>
            <hr />
            
            <pre><code>func ldShared(b *Builder, root *Action, toplevelactions []*Action, targetPath string, importcfg string, allactions []*Action) error</code></pre>
         </article>
         
         <article class="function" data-name="cc">
            <h2>cc</h2>
            <hr />
            
            <pre><code>func cc(b *Builder, a *Action, ofile string, cfile string) error</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="compiler">
            <h2>compiler</h2>
            <hr />
            
            <pre><code>func compiler() string</code></pre>
         </article>
         
         <article class="function" data-name="linker">
            <h2>linker</h2>
            <hr />
            
            <pre><code>func linker() string</code></pre>
         </article>
         
         <article class="function" data-name="ar">
            <h2>ar</h2>
            <hr />
            
            <pre><code>func ar() []string</code></pre>
         </article>
         
         <article class="function" data-name="checkGccgoBin">
            <h2>checkGccgoBin</h2>
            <hr />
            
            <pre><code>func checkGccgoBin()</code></pre>
         </article>
         
         <article class="function" data-name="gc">
            <h2>gc</h2>
            <hr />
            
            <pre><code>func gc(b *Builder, a *Action, archive string, importcfg []byte, embedcfg []byte, symabis string, asmhdr bool, pgoProfile string, gofiles []string) (ofile string, output []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="buildImportcfgSymlinks">
            <h2>buildImportcfgSymlinks</h2>
            <hr />
            
            <p>buildImportcfgSymlinks builds in root a tree of symlinks
implementing the directives from importcfg.
This serves as a temporary transition mechanism until
we can depend on gccgo reading an importcfg directly.
(The Go 1.9 and later gc compilers already do.)</p>
            
            <pre><code>func buildImportcfgSymlinks(sh *Shell, root string, importcfg []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="asm">
            <h2>asm</h2>
            <hr />
            
            <pre><code>func asm(b *Builder, a *Action, sfiles []string) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="symabis">
            <h2>symabis</h2>
            <hr />
            
            <pre><code>func symabis(b *Builder, a *Action, sfiles []string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="gccgoArchive">
            <h2>gccgoArchive</h2>
            <hr />
            
            <pre><code>func gccgoArchive(basedir string, imp string) string</code></pre>
         </article>
         
         <article class="function" data-name="pack">
            <h2>pack</h2>
            <hr />
            
            <pre><code>func pack(b *Builder, a *Action, afile string, ofiles []string) error</code></pre>
         </article>
         
         <article class="function" data-name="link">
            <h2>link</h2>
            <hr />
            
            <pre><code>func link(b *Builder, root *Action, out string, importcfg string, allactions []*Action, buildmode string, desc string) error</code></pre>
         </article>
         
         <article class="function" data-name="ld">
            <h2>ld</h2>
            <hr />
            
            <pre><code>func ld(b *Builder, root *Action, targetPath string, importcfg string, mainpkg string) error</code></pre>
         </article>
         
         <article class="function" data-name="ldShared">
            <h2>ldShared</h2>
            <hr />
            
            <pre><code>func ldShared(b *Builder, root *Action, toplevelactions []*Action, targetPath string, importcfg string, allactions []*Action) error</code></pre>
         </article>
         
         <article class="function" data-name="cc">
            <h2>cc</h2>
            <hr />
            
            <pre><code>func cc(b *Builder, a *Action, ofile string, cfile string) error</code></pre>
         </article>
         
         <article class="function" data-name="maybePIC">
            <h2>maybePIC</h2>
            <hr />
            
            <p>maybePIC adds -fPIC to the list of arguments if needed.</p>
            
            <pre><code>func maybePIC(args []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="gccgoPkgpath">
            <h2>gccgoPkgpath</h2>
            <hr />
            
            <pre><code>func gccgoPkgpath(p *load.Package) string</code></pre>
         </article>
         
         <article class="function" data-name="gccgoCleanPkgpath">
            <h2>gccgoCleanPkgpath</h2>
            <hr />
            
            <pre><code>func gccgoCleanPkgpath(b *Builder, p *load.Package) string</code></pre>
         </article>
         
         <article class="function" data-name="supportsCgoIncomplete">
            <h2>supportsCgoIncomplete</h2>
            <hr />
            
            <p>supportsCgoIncomplete reports whether the gccgo/GoLLVM compiler
being used supports cgo.Incomplete, which was added in GCC 13.

This takes an Action only for output reporting purposes.
The result value is unrelated to the Action.</p>
            
            <pre><code>func supportsCgoIncomplete(b *Builder, a *Action) bool</code></pre>
         </article>
         
         <article class="function" data-name="BuildInit">
            <h2>BuildInit</h2>
            <hr />
            
            <pre><code>func BuildInit()</code></pre>
         </article>
         
         <article class="function" data-name="fuzzInstrumentFlags">
            <h2>fuzzInstrumentFlags</h2>
            <hr />
            
            <p>fuzzInstrumentFlags returns compiler flags that enable fuzzing instrumentation
on supported platforms.

On unsupported platforms, fuzzInstrumentFlags returns nil, meaning no
instrumentation is added. 'go test -fuzz' still works without coverage,
but it generates random inputs without guidance, so it's much less effective.</p>
            
            <pre><code>func fuzzInstrumentFlags() []string</code></pre>
         </article>
         
         <article class="function" data-name="instrumentInit">
            <h2>instrumentInit</h2>
            <hr />
            
            <pre><code>func instrumentInit()</code></pre>
         </article>
         
         <article class="function" data-name="buildModeInit">
            <h2>buildModeInit</h2>
            <hr />
            
            <pre><code>func buildModeInit()</code></pre>
         </article>
         
         <article class="function" data-name="compilerVersion">
            <h2>compilerVersion</h2>
            <hr />
            
            <p>compilerVersion detects the version of $(go env CC).
It returns a non-nil error if the compiler matches a known version schema but
the version could not be parsed, or if $(go env CC) could not be determined.</p>
            
            <pre><code>func compilerVersion() (version, error)</code></pre>
         </article>
         
         <article class="function" data-name="compilerRequiredAsanVersion">
            <h2>compilerRequiredAsanVersion</h2>
            <hr />
            
            <p>compilerRequiredAsanVersion is a copy of the function defined in
cmd/cgo/internal/testsanitizers/cc_test.go
compilerRequiredAsanVersion reports whether the compiler is the version
required by Asan.</p>
            
            <pre><code>func compilerRequiredAsanVersion() error</code></pre>
         </article>
         
         <article class="function" data-name="Act">
            <h2>Act</h2>
            <hr />
            
            <pre><code>func Act(b *Builder, ctx context.Context, a *Action) error</code></pre>
         </article>
         
         <article class="function" data-name="BuildActionID">
            <h2>BuildActionID</h2>
            <hr />
            
            <p>BuildActionID returns the action ID section of a's build ID.</p>
            
            <pre><code>func BuildActionID() string</code></pre>
         </article>
         
         <article class="function" data-name="BuildContentID">
            <h2>BuildContentID</h2>
            <hr />
            
            <p>BuildContentID returns the content ID section of a's build ID.</p>
            
            <pre><code>func BuildContentID() string</code></pre>
         </article>
         
         <article class="function" data-name="BuildID">
            <h2>BuildID</h2>
            <hr />
            
            <p>BuildID returns a's build ID.</p>
            
            <pre><code>func BuildID() string</code></pre>
         </article>
         
         <article class="function" data-name="BuiltTarget">
            <h2>BuiltTarget</h2>
            <hr />
            
            <p>BuiltTarget returns the actual file that was built. This differs
from Target when the result was cached.</p>
            
            <pre><code>func BuiltTarget() string</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <p>Implement heap.Interface</p>
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Push">
            <h2>Push</h2>
            <hr />
            
            <pre><code>func Push(x any)</code></pre>
         </article>
         
         <article class="function" data-name="Pop">
            <h2>Pop</h2>
            <hr />
            
            <pre><code>func Pop() any</code></pre>
         </article>
         
         <article class="function" data-name="push">
            <h2>push</h2>
            <hr />
            
            <pre><code>func push(a *Action)</code></pre>
         </article>
         
         <article class="function" data-name="pop">
            <h2>pop</h2>
            <hr />
            
            <pre><code>func pop() *Action</code></pre>
         </article>
         
         <article class="function" data-name="actionGraphJSON">
            <h2>actionGraphJSON</h2>
            <hr />
            
            <pre><code>func actionGraphJSON(a *Action) string</code></pre>
         </article>
         
         <article class="function" data-name="NewBuilder">
            <h2>NewBuilder</h2>
            <hr />
            
            <p>NewBuilder returns a new Builder ready for use.

If workDir is the empty string, NewBuilder creates a WorkDir if needed
and arranges for it to be removed in case of an unclean exit.
The caller must Close the builder explicitly to clean up the WorkDir
before a clean exit.</p>
            
            <pre><code>func NewBuilder(workDir string) *Builder</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="closeBuilders">
            <h2>closeBuilders</h2>
            <hr />
            
            <pre><code>func closeBuilders()</code></pre>
         </article>
         
         <article class="function" data-name="CheckGOOSARCHPair">
            <h2>CheckGOOSARCHPair</h2>
            <hr />
            
            <pre><code>func CheckGOOSARCHPair(goos string, goarch string) error</code></pre>
         </article>
         
         <article class="function" data-name="NewObjdir">
            <h2>NewObjdir</h2>
            <hr />
            
            <p>NewObjdir returns the name of a fresh object directory under b.WorkDir.
It is up to the caller to call b.Mkdir on the result at an appropriate time.
The result ends in a slash, so that file names in that directory
can be constructed with direct string addition.

NewObjdir must be called only from a single goroutine at a time,
so it is safe to call during action graph construction, but it must not
be called during action graph execution.</p>
            
            <pre><code>func NewObjdir() string</code></pre>
         </article>
         
         <article class="function" data-name="readpkglist">
            <h2>readpkglist</h2>
            <hr />
            
            <p>readpkglist returns the list of packages that were built into the shared library
at shlibpath. For the native toolchain this list is stored, newline separated, in
an ELF note with name "Go\x00\x00" and type 1. For GCCGO it is extracted from the
.go_export section.</p>
            
            <pre><code>func readpkglist(shlibpath string) pkgs []*load.Package</code></pre>
         </article>
         
         <article class="function" data-name="cacheAction">
            <h2>cacheAction</h2>
            <hr />
            
            <p>cacheAction looks up {mode, p} in the cache and returns the resulting action.
If the cache has no such action, f() is recorded and returned.
TODO(rsc): Change the second key from *load.Package to interface{},
to make the caching in linkShared less awkward?</p>
            
            <pre><code>func cacheAction(mode string, p *load.Package, f func) *Action</code></pre>
         </article>
         
         <article class="function" data-name="AutoAction">
            <h2>AutoAction</h2>
            <hr />
            
            <p>AutoAction returns the "right" action for go build or go install of p.</p>
            
            <pre><code>func AutoAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
         </article>
         
         <article class="function" data-name="newBuildActor">
            <h2>newBuildActor</h2>
            <hr />
            
            <p>newBuildActor returns a new buildActor object, setting up the
covMetaFileName field if 'genCoverMeta' flag is set.</p>
            
            <pre><code>func newBuildActor(p *load.Package, genCoverMeta bool) *buildActor</code></pre>
         </article>
         
         <article class="function" data-name="Act">
            <h2>Act</h2>
            <hr />
            
            <pre><code>func Act(b *Builder, ctx context.Context, a *Action) error</code></pre>
         </article>
         
         <article class="function" data-name="pgoActionID">
            <h2>pgoActionID</h2>
            <hr />
            
            <p>pgoActionID computes the action ID for a preprocess PGO action.</p>
            
            <pre><code>func pgoActionID(input string) cache.ActionID</code></pre>
         </article>
         
         <article class="function" data-name="Act">
            <h2>Act</h2>
            <hr />
            
            <pre><code>func Act(b *Builder, ctx context.Context, a *Action) error</code></pre>
         </article>
         
         <article class="function" data-name="CompileAction">
            <h2>CompileAction</h2>
            <hr />
            
            <p>CompileAction returns the action for compiling and possibly installing
(according to mode) the given package. The resulting action is only
for building packages (archives), never for linking executables.
depMode is the action (build or install) to use when building dependencies.
To turn package main into an executable, call b.Link instead.</p>
            
            <pre><code>func CompileAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
         </article>
         
         <article class="function" data-name="VetAction">
            <h2>VetAction</h2>
            <hr />
            
            <p>VetAction returns the action for running go vet on package p.
It depends on the action for compiling p.
If the caller may be causing p to be installed, it is up to the caller
to make sure that the install depends on (runs after) vet.</p>
            
            <pre><code>func VetAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
         </article>
         
         <article class="function" data-name="vetAction">
            <h2>vetAction</h2>
            <hr />
            
            <pre><code>func vetAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
         </article>
         
         <article class="function" data-name="LinkAction">
            <h2>LinkAction</h2>
            <hr />
            
            <p>LinkAction returns the action for linking p into an executable
and possibly installing the result (according to mode).
depMode is the action (build or install) to use when compiling dependencies.</p>
            
            <pre><code>func LinkAction(mode BuildMode, depMode BuildMode, p *load.Package) *Action</code></pre>
         </article>
         
         <article class="function" data-name="installAction">
            <h2>installAction</h2>
            <hr />
            
            <p>installAction returns the action for installing the result of a1.</p>
            
            <pre><code>func installAction(a1 *Action, mode BuildMode) *Action</code></pre>
         </article>
         
         <article class="function" data-name="addTransitiveLinkDeps">
            <h2>addTransitiveLinkDeps</h2>
            <hr />
            
            <p>addTransitiveLinkDeps adds to the link action a all packages
that are transitive dependencies of a1.Deps.
That is, if a is a link of package main, a1 is the compile of package main
and a1.Deps is the actions for building packages directly imported by
package main (what the compiler needs). The linker needs all packages
transitively imported by the whole program; addTransitiveLinkDeps
makes sure those are present in a.Deps.
If shlib is non-empty, then a corresponds to the build and installation of shlib,
so any rebuild of shlib should not be added as a dependency.</p>
            
            <pre><code>func addTransitiveLinkDeps(a *Action, a1 *Action, shlib string)</code></pre>
         </article>
         
         <article class="function" data-name="addInstallHeaderAction">
            <h2>addInstallHeaderAction</h2>
            <hr />
            
            <p>addInstallHeaderAction adds an install header action to a, if needed.
The action a should be an install action as generated by either
b.CompileAction or b.LinkAction with mode=ModeInstall,
and so a.Deps[0] is the corresponding build action.</p>
            
            <pre><code>func addInstallHeaderAction(a *Action)</code></pre>
         </article>
         
         <article class="function" data-name="buildmodeShared">
            <h2>buildmodeShared</h2>
            <hr />
            
            <p>buildmodeShared takes the "go build" action a1 into the building of a shared library of a1.Deps.
That is, the input a1 represents "go build pkgs" and the result represents "go build -buildmode=shared pkgs".</p>
            
            <pre><code>func buildmodeShared(mode BuildMode, depMode BuildMode, args []string, pkgs []*load.Package, a1 *Action) *Action</code></pre>
         </article>
         
         <article class="function" data-name="linkSharedAction">
            <h2>linkSharedAction</h2>
            <hr />
            
            <p>linkSharedAction takes a grouping action a1 corresponding to a list of built packages
and returns an action that links them together into a shared library with the name shlib.
If a1 is nil, shlib should be an absolute path to an existing shared library,
and then linkSharedAction reads that library to find out the package list.</p>
            
            <pre><code>func linkSharedAction(mode BuildMode, depMode BuildMode, shlib string, a1 *Action) *Action</code></pre>
         </article>
         
         <article class="function" data-name="actionList">
            <h2>actionList</h2>
            <hr />
            
            <p>actionList returns the list of actions in the dag rooted at root
as visited in a depth-first post-order traversal.</p>
            
            <pre><code>func actionList(root *Action) []*Action</code></pre>
         </article>
         
         <article class="function" data-name="Do">
            <h2>Do</h2>
            <hr />
            
            <p>Do runs the action graph rooted at root.</p>
            
            <pre><code>func Do(ctx context.Context, root *Action)</code></pre>
         </article>
         
         <article class="function" data-name="buildActionID">
            <h2>buildActionID</h2>
            <hr />
            
            <p>buildActionID computes the action ID for a build action.</p>
            
            <pre><code>func buildActionID(a *Action) cache.ActionID</code></pre>
         </article>
         
         <article class="function" data-name="needCgoHdr">
            <h2>needCgoHdr</h2>
            <hr />
            
            <p>needCgoHdr reports whether the actions triggered by this one
expect to be able to access the cgo-generated header file.</p>
            
            <pre><code>func needCgoHdr(a *Action) bool</code></pre>
         </article>
         
         <article class="function" data-name="allowedVersion">
            <h2>allowedVersion</h2>
            <hr />
            
            <p>allowedVersion reports whether the version v is an allowed version of go
(one that we can compile).
v is known to be of the form "1.23".</p>
            
            <pre><code>func allowedVersion(v string) bool</code></pre>
         </article>
         
         <article class="function" data-name="build">
            <h2>build</h2>
            <hr />
            
            <p>build is the action for building a single package.
Note that any new influence on this logic must be reported in b.buildActionID above as well.</p>
            
            <pre><code>func build(ctx context.Context, a *Action) err error</code></pre>
         </article>
         
         <article class="function" data-name="checkDirectives">
            <h2>checkDirectives</h2>
            <hr />
            
            <pre><code>func checkDirectives(a *Action) error</code></pre>
         </article>
         
         <article class="function" data-name="cacheObjdirFile">
            <h2>cacheObjdirFile</h2>
            <hr />
            
            <pre><code>func cacheObjdirFile(a *Action, c cache.Cache, name string) error</code></pre>
         </article>
         
         <article class="function" data-name="findCachedObjdirFile">
            <h2>findCachedObjdirFile</h2>
            <hr />
            
            <pre><code>func findCachedObjdirFile(a *Action, c cache.Cache, name string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="loadCachedObjdirFile">
            <h2>loadCachedObjdirFile</h2>
            <hr />
            
            <pre><code>func loadCachedObjdirFile(a *Action, c cache.Cache, name string) error</code></pre>
         </article>
         
         <article class="function" data-name="cacheCgoHdr">
            <h2>cacheCgoHdr</h2>
            <hr />
            
            <pre><code>func cacheCgoHdr(a *Action)</code></pre>
         </article>
         
         <article class="function" data-name="loadCachedCgoHdr">
            <h2>loadCachedCgoHdr</h2>
            <hr />
            
            <pre><code>func loadCachedCgoHdr(a *Action) error</code></pre>
         </article>
         
         <article class="function" data-name="cacheSrcFiles">
            <h2>cacheSrcFiles</h2>
            <hr />
            
            <pre><code>func cacheSrcFiles(a *Action, srcfiles []string)</code></pre>
         </article>
         
         <article class="function" data-name="loadCachedVet">
            <h2>loadCachedVet</h2>
            <hr />
            
            <pre><code>func loadCachedVet(a *Action) error</code></pre>
         </article>
         
         <article class="function" data-name="loadCachedCompiledGoFiles">
            <h2>loadCachedCompiledGoFiles</h2>
            <hr />
            
            <pre><code>func loadCachedCompiledGoFiles(a *Action) error</code></pre>
         </article>
         
         <article class="function" data-name="buildVetConfig">
            <h2>buildVetConfig</h2>
            <hr />
            
            <pre><code>func buildVetConfig(a *Action, srcfiles []string)</code></pre>
         </article>
         
         <article class="function" data-name="vet">
            <h2>vet</h2>
            <hr />
            
            <pre><code>func vet(ctx context.Context, a *Action) error</code></pre>
         </article>
         
         <article class="function" data-name="linkActionID">
            <h2>linkActionID</h2>
            <hr />
            
            <p>linkActionID computes the action ID for a link action.</p>
            
            <pre><code>func linkActionID(a *Action) cache.ActionID</code></pre>
         </article>
         
         <article class="function" data-name="printLinkerConfig">
            <h2>printLinkerConfig</h2>
            <hr />
            
            <p>printLinkerConfig prints the linker config into the hash h,
as part of the computation of a linker-related action ID.</p>
            
            <pre><code>func printLinkerConfig(h io.Writer, p *load.Package)</code></pre>
         </article>
         
         <article class="function" data-name="link">
            <h2>link</h2>
            <hr />
            
            <p>link is the action for linking a single command.
Note that any new influence on this logic must be reported in b.linkActionID above as well.</p>
            
            <pre><code>func link(ctx context.Context, a *Action) err error</code></pre>
         </article>
         
         <article class="function" data-name="writeLinkImportcfg">
            <h2>writeLinkImportcfg</h2>
            <hr />
            
            <pre><code>func writeLinkImportcfg(a *Action, file string) error</code></pre>
         </article>
         
         <article class="function" data-name="PkgconfigCmd">
            <h2>PkgconfigCmd</h2>
            <hr />
            
            <p>PkgconfigCmd returns a pkg-config binary name
defaultPkgConfig is defined in zdefaultcc.go, written by cmd/dist.</p>
            
            <pre><code>func PkgconfigCmd() string</code></pre>
         </article>
         
         <article class="function" data-name="splitPkgConfigOutput">
            <h2>splitPkgConfigOutput</h2>
            <hr />
            
            <p>splitPkgConfigOutput parses the pkg-config output into a slice of flags.
This implements the shell quoting semantics described in
https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02,
except that it does not support parameter or arithmetic expansion or command
substitution and hard-codes the <blank> delimiters instead of reading them
from LC_LOCALE.</p>
            
            <pre><code>func splitPkgConfigOutput(out []byte) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="getPkgConfigFlags">
            <h2>getPkgConfigFlags</h2>
            <hr />
            
            <p>Calls pkg-config if needed and returns the cflags/ldflags needed to build a's package.</p>
            
            <pre><code>func getPkgConfigFlags(a *Action) (cflags []string, ldflags []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="installShlibname">
            <h2>installShlibname</h2>
            <hr />
            
            <pre><code>func installShlibname(ctx context.Context, a *Action) error</code></pre>
         </article>
         
         <article class="function" data-name="linkSharedActionID">
            <h2>linkSharedActionID</h2>
            <hr />
            
            <pre><code>func linkSharedActionID(a *Action) cache.ActionID</code></pre>
         </article>
         
         <article class="function" data-name="linkShared">
            <h2>linkShared</h2>
            <hr />
            
            <pre><code>func linkShared(ctx context.Context, a *Action) err error</code></pre>
         </article>
         
         <article class="function" data-name="BuildInstallFunc">
            <h2>BuildInstallFunc</h2>
            <hr />
            
            <p>BuildInstallFunc is the action for installing a single package or executable.</p>
            
            <pre><code>func BuildInstallFunc(b *Builder, ctx context.Context, a *Action) err error</code></pre>
         </article>
         
         <article class="function" data-name="cleanup">
            <h2>cleanup</h2>
            <hr />
            
            <p>cleanup removes a's object dir to keep the amount of
on-disk garbage down in a large build. On an operating system
with aggressive buffering, cleaning incrementally like
this keeps the intermediate objects from hitting the disk.</p>
            
            <pre><code>func cleanup(a *Action)</code></pre>
         </article>
         
         <article class="function" data-name="installHeader">
            <h2>installHeader</h2>
            <hr />
            
            <p>Install the cgo export header file, if there is one.</p>
            
            <pre><code>func installHeader(ctx context.Context, a *Action) error</code></pre>
         </article>
         
         <article class="function" data-name="cover">
            <h2>cover</h2>
            <hr />
            
            <p>cover runs, in effect,

	go tool cover -mode=b.coverMode -var="varName" -o dst.go src.go</p>
            
            <pre><code>func cover(a *Action, dst string, src string, varName string) error</code></pre>
         </article>
         
         <article class="function" data-name="cover2">
            <h2>cover2</h2>
            <hr />
            
            <p>cover2 runs, in effect,

	go tool cover -pkgcfg=<config file> -mode=b.coverMode -var="varName" -o <outfiles> <infiles>

Return value is an updated output files list; in addition to the
regular outputs (instrumented source files) the cover tool also
writes a separate file (appearing first in the list of outputs)
that will contain coverage counters and meta-data.</p>
            
            <pre><code>func cover2(a *Action, infiles []string, outfiles []string, varName string, mode string) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="writeCoverPkgInputs">
            <h2>writeCoverPkgInputs</h2>
            <hr />
            
            <pre><code>func writeCoverPkgInputs(a *Action, pconfigfile string, covoutputsfile string, outfiles []string) error</code></pre>
         </article>
         
         <article class="function" data-name="isObject">
            <h2>isObject</h2>
            <hr />
            
            <pre><code>func isObject(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="cCompilerEnv">
            <h2>cCompilerEnv</h2>
            <hr />
            
            <p>cCompilerEnv returns environment variables to set when running the
C compiler. This is needed to disable escape codes in clang error
messages that confuse tools like cgo.</p>
            
            <pre><code>func cCompilerEnv() []string</code></pre>
         </article>
         
         <article class="function" data-name="mkAbs">
            <h2>mkAbs</h2>
            <hr />
            
            <p>mkAbs returns an absolute path corresponding to
evaluating f in the directory dir.
We always pass absolute paths of source files so that
the error messages will include the full path to a file
in need of attention.</p>
            
            <pre><code>func mkAbs(dir string, f string) string</code></pre>
         </article>
         
         <article class="function" data-name="noCompiler">
            <h2>noCompiler</h2>
            <hr />
            
            <pre><code>func noCompiler() error</code></pre>
         </article>
         
         <article class="function" data-name="compiler">
            <h2>compiler</h2>
            <hr />
            
            <pre><code>func compiler() string</code></pre>
         </article>
         
         <article class="function" data-name="linker">
            <h2>linker</h2>
            <hr />
            
            <pre><code>func linker() string</code></pre>
         </article>
         
         <article class="function" data-name="gc">
            <h2>gc</h2>
            <hr />
            
            <pre><code>func gc(b *Builder, a *Action, archive string, importcfg []byte, embedcfg []byte, symabis string, asmhdr bool, pgoProfile string, gofiles []string) (ofile string, out []byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="asm">
            <h2>asm</h2>
            <hr />
            
            <pre><code>func asm(b *Builder, a *Action, sfiles []string) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="symabis">
            <h2>symabis</h2>
            <hr />
            
            <pre><code>func symabis(b *Builder, a *Action, sfiles []string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="pack">
            <h2>pack</h2>
            <hr />
            
            <pre><code>func pack(b *Builder, a *Action, afile string, ofiles []string) error</code></pre>
         </article>
         
         <article class="function" data-name="ld">
            <h2>ld</h2>
            <hr />
            
            <pre><code>func ld(b *Builder, root *Action, targetPath string, importcfg string, mainpkg string) error</code></pre>
         </article>
         
         <article class="function" data-name="ldShared">
            <h2>ldShared</h2>
            <hr />
            
            <pre><code>func ldShared(b *Builder, root *Action, toplevelactions []*Action, targetPath string, importcfg string, allactions []*Action) error</code></pre>
         </article>
         
         <article class="function" data-name="cc">
            <h2>cc</h2>
            <hr />
            
            <pre><code>func cc(b *Builder, a *Action, ofile string, cfile string) error</code></pre>
         </article>
         
         <article class="function" data-name="gcc">
            <h2>gcc</h2>
            <hr />
            
            <p>gcc runs the gcc C compiler to create an object from a single C file.</p>
            
            <pre><code>func gcc(a *Action, workdir string, out string, flags []string, cfile string) error</code></pre>
         </article>
         
         <article class="function" data-name="gxx">
            <h2>gxx</h2>
            <hr />
            
            <p>gxx runs the g++ C++ compiler to create an object from a single C++ file.</p>
            
            <pre><code>func gxx(a *Action, workdir string, out string, flags []string, cxxfile string) error</code></pre>
         </article>
         
         <article class="function" data-name="gfortran">
            <h2>gfortran</h2>
            <hr />
            
            <p>gfortran runs the gfortran Fortran compiler to create an object from a single Fortran file.</p>
            
            <pre><code>func gfortran(a *Action, workdir string, out string, flags []string, ffile string) error</code></pre>
         </article>
         
         <article class="function" data-name="ccompile">
            <h2>ccompile</h2>
            <hr />
            
            <p>ccompile runs the given C or C++ compiler and creates an object from a single source file.</p>
            
            <pre><code>func ccompile(a *Action, outfile string, flags []string, file string, compiler []string) error</code></pre>
         </article>
         
         <article class="function" data-name="gccld">
            <h2>gccld</h2>
            <hr />
            
            <p>gccld runs the gcc linker to create an executable from a set of object files.</p>
            
            <pre><code>func gccld(a *Action, objdir string, outfile string, flags []string, objs []string) error</code></pre>
         </article>
         
         <article class="function" data-name="GccCmd">
            <h2>GccCmd</h2>
            <hr />
            
            <p>GccCmd returns a gcc command line prefix
defaultCC is defined in zdefaultcc.go, written by cmd/dist.</p>
            
            <pre><code>func GccCmd(incdir string, workdir string) []string</code></pre>
         </article>
         
         <article class="function" data-name="GxxCmd">
            <h2>GxxCmd</h2>
            <hr />
            
            <p>GxxCmd returns a g++ command line prefix
defaultCXX is defined in zdefaultcc.go, written by cmd/dist.</p>
            
            <pre><code>func GxxCmd(incdir string, workdir string) []string</code></pre>
         </article>
         
         <article class="function" data-name="gfortranCmd">
            <h2>gfortranCmd</h2>
            <hr />
            
            <p>gfortranCmd returns a gfortran command line prefix.</p>
            
            <pre><code>func gfortranCmd(incdir string, workdir string) []string</code></pre>
         </article>
         
         <article class="function" data-name="ccExe">
            <h2>ccExe</h2>
            <hr />
            
            <p>ccExe returns the CC compiler setting without all the extra flags we add implicitly.</p>
            
            <pre><code>func ccExe() []string</code></pre>
         </article>
         
         <article class="function" data-name="cxxExe">
            <h2>cxxExe</h2>
            <hr />
            
            <p>cxxExe returns the CXX compiler setting without all the extra flags we add implicitly.</p>
            
            <pre><code>func cxxExe() []string</code></pre>
         </article>
         
         <article class="function" data-name="fcExe">
            <h2>fcExe</h2>
            <hr />
            
            <p>fcExe returns the FC compiler setting without all the extra flags we add implicitly.</p>
            
            <pre><code>func fcExe() []string</code></pre>
         </article>
         
         <article class="function" data-name="compilerCmd">
            <h2>compilerCmd</h2>
            <hr />
            
            <p>compilerCmd returns a command line prefix for the given environment
variable and using the default command when the variable is empty.</p>
            
            <pre><code>func compilerCmd(compiler []string, incdir string, workdir string) []string</code></pre>
         </article>
         
         <article class="function" data-name="gccNoPie">
            <h2>gccNoPie</h2>
            <hr />
            
            <p>gccNoPie returns the flag to use to request non-PIE. On systems
with PIE (position independent executables) enabled by default,
-no-pie must be passed when doing a partial link with -Wl,-r.
But -no-pie is not supported by all compilers, and clang spells it -nopie.</p>
            
            <pre><code>func gccNoPie(linker []string) string</code></pre>
         </article>
         
         <article class="function" data-name="gccSupportsFlag">
            <h2>gccSupportsFlag</h2>
            <hr />
            
            <p>gccSupportsFlag checks to see if the compiler supports a flag.</p>
            
            <pre><code>func gccSupportsFlag(compiler []string, flag string) bool</code></pre>
         </article>
         
         <article class="function" data-name="statString">
            <h2>statString</h2>
            <hr />
            
            <p>statString returns a string form of an os.FileInfo, for serializing and comparison.</p>
            
            <pre><code>func statString(info os.FileInfo) string</code></pre>
         </article>
         
         <article class="function" data-name="gccCompilerID">
            <h2>gccCompilerID</h2>
            <hr />
            
            <p>gccCompilerID returns a build cache key for the current gcc,
as identified by running 'compiler'.
The caller can use subkeys of the key.
Other parts of cmd/go can use the id as a hash
of the installed compiler version.</p>
            
            <pre><code>func gccCompilerID(compiler string) (id cache.ActionID, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="gccArchArgs">
            <h2>gccArchArgs</h2>
            <hr />
            
            <p>gccArchArgs returns arguments to pass to gcc based on the architecture.</p>
            
            <pre><code>func gccArchArgs() []string</code></pre>
         </article>
         
         <article class="function" data-name="envList">
            <h2>envList</h2>
            <hr />
            
            <p>envList returns the value of the given environment variable broken
into fields, using the default value when the variable is empty.

The environment variable must be quoted correctly for
quoted.Split. This should be done before building
anything, for example, in BuildInit.</p>
            
            <pre><code>func envList(key string, def string) []string</code></pre>
         </article>
         
         <article class="function" data-name="CFlags">
            <h2>CFlags</h2>
            <hr />
            
            <p>CFlags returns the flags to use when invoking the C, C++ or Fortran compilers, or cgo.</p>
            
            <pre><code>func CFlags(p *load.Package) (cppflags []string, cflags []string, cxxflags []string, fflags []string, ldflags []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="buildFlags">
            <h2>buildFlags</h2>
            <hr />
            
            <pre><code>func buildFlags(name string, defaults string, fromPackage []string, check func) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="cgo">
            <h2>cgo</h2>
            <hr />
            
            <pre><code>func cgo(a *Action, cgoExe string, objdir string, pcCFLAGS []string, pcLDFLAGS []string, cgofiles []string, gccfiles []string, gxxfiles []string, mfiles []string, ffiles []string) (outGo []string, outObj []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="flagsNotCompatibleWithInternalLinking">
            <h2>flagsNotCompatibleWithInternalLinking</h2>
            <hr />
            
            <p>flagsNotCompatibleWithInternalLinking scans the list of cgo
compiler flags (C/C++/Fortran) looking for flags that might cause
problems if the build in question uses internal linking. The
primary culprits are use of plugins or use of LTO, but we err on
the side of caution, supporting only those flags that are on the
allow-list for safe flags from security perspective. Return is TRUE
if a sensitive flag is found, FALSE otherwise.</p>
            
            <pre><code>func flagsNotCompatibleWithInternalLinking(sourceList []string, flagListList [][]string) bool</code></pre>
         </article>
         
         <article class="function" data-name="dynimport">
            <h2>dynimport</h2>
            <hr />
            
            <p>dynimport creates a Go source file named importGo containing
//go:cgo_import_dynamic directives for each symbol or library
dynamically imported by the object files outObj.
dynOutGo, if not empty, is a new Go file to build as part of the package.
dynOutObj, if not empty, is a new file to add to the generated archive.</p>
            
            <pre><code>func dynimport(a *Action, objdir string, importGo string, cgoExe string, cflags []string, cgoLDFLAGS []string, outObj []string) (dynOutGo string, dynOutObj string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="swig">
            <h2>swig</h2>
            <hr />
            
            <p>Run SWIG on all SWIG input files.
TODO: Don't build a shared library, once SWIG emits the necessary
pragmas for external linking.</p>
            
            <pre><code>func swig(a *Action, objdir string, pcCFLAGS []string) (outGo []string, outC []string, outCXX []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="swigDoVersionCheck">
            <h2>swigDoVersionCheck</h2>
            <hr />
            
            <pre><code>func swigDoVersionCheck() error</code></pre>
         </article>
         
         <article class="function" data-name="swigVersionCheck">
            <h2>swigVersionCheck</h2>
            <hr />
            
            <pre><code>func swigVersionCheck() error</code></pre>
         </article>
         
         <article class="function" data-name="swigDoIntSize">
            <h2>swigDoIntSize</h2>
            <hr />
            
            <p>Determine the size of int on the target system for the -intgosize option
of swig >= 2.0.9. Run only once.</p>
            
            <pre><code>func swigDoIntSize(objdir string) (intsize string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="swigIntSize">
            <h2>swigIntSize</h2>
            <hr />
            
            <p>Determine the size of int on the target system for the -intgosize option
of swig >= 2.0.9.</p>
            
            <pre><code>func swigIntSize(objdir string) (intsize string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="swigOne">
            <h2>swigOne</h2>
            <hr />
            
            <p>Run SWIG on one SWIG input file.</p>
            
            <pre><code>func swigOne(a *Action, file string, objdir string, pcCFLAGS []string, cxx bool, intgosize string) (outGo string, outC string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="disableBuildID">
            <h2>disableBuildID</h2>
            <hr />
            
            <p>disableBuildID adjusts a linker command line to avoid creating a
build ID when creating an object file rather than an executable or
shared library. Some systems, such as Ubuntu, always add
--build-id to every link, but we don't want a build ID when we are
producing an object file. On some of those system a plain -r (not
-Wl,-r) will turn off --build-id, but clang 3.0 doesn't support a
plain -r. I don't know how to turn off --build-id when using clang
other than passing a trailing --build-id=none. So that is what we
do, but only on systems likely to support it, which is to say,
systems that normally use gold or the GNU linker.</p>
            
            <pre><code>func disableBuildID(ldflags []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="mkAbsFiles">
            <h2>mkAbsFiles</h2>
            <hr />
            
            <p>mkAbsFiles converts files into a list of absolute files,
assuming they were originally relative to dir,
and returns that new list.</p>
            
            <pre><code>func mkAbsFiles(dir string, files []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="actualFiles">
            <h2>actualFiles</h2>
            <hr />
            
            <p>actualFiles applies fsys.Actual to the list of files.</p>
            
            <pre><code>func actualFiles(files []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="passLongArgsInResponseFiles">
            <h2>passLongArgsInResponseFiles</h2>
            <hr />
            
            <p>passLongArgsInResponseFiles modifies cmd such that, for
certain programs, long arguments are passed in "response files", a
file on disk with the arguments, with one arg per line. An actual
argument starting with '@' means that the rest of the argument is
a filename of arguments to expand.

See issues 18468 (Windows) and 37768 (Darwin).</p>
            
            <pre><code>func passLongArgsInResponseFiles(cmd *exec.Cmd) cleanup func</code></pre>
         </article>
         
         <article class="function" data-name="useResponseFile">
            <h2>useResponseFile</h2>
            <hr />
            
            <pre><code>func useResponseFile(path string, argLen int) bool</code></pre>
         </article>
         
         <article class="function" data-name="encodeArg">
            <h2>encodeArg</h2>
            <hr />
            
            <p>encodeArg encodes an argument for response file writing.</p>
            
            <pre><code>func encodeArg(arg string) string</code></pre>
         </article>
         
         <article class="function" data-name="TestEncodeArgs">
            <h2>TestEncodeArgs</h2>
            <hr />
            
            <pre><code>func TestEncodeArgs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEncodeDecode">
            <h2>TestEncodeDecode</h2>
            <hr />
            
            <pre><code>func TestEncodeDecode(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEncodeDecodeFuzz">
            <h2>TestEncodeDecodeFuzz</h2>
            <hr />
            
            <pre><code>func TestEncodeDecodeFuzz(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="checkCompilerFlags">
            <h2>checkCompilerFlags</h2>
            <hr />
            
            <pre><code>func checkCompilerFlags(name string, source string, list []string) error</code></pre>
         </article>
         
         <article class="function" data-name="checkLinkerFlags">
            <h2>checkLinkerFlags</h2>
            <hr />
            
            <pre><code>func checkLinkerFlags(name string, source string, list []string) error</code></pre>
         </article>
         
         <article class="function" data-name="checkCompilerFlagsForInternalLink">
            <h2>checkCompilerFlagsForInternalLink</h2>
            <hr />
            
            <p>checkCompilerFlagsForInternalLink returns an error if 'list'
contains a flag or flags that may not be fully supported by
internal linking (meaning that we should punt the link to the
external linker).</p>
            
            <pre><code>func checkCompilerFlagsForInternalLink(name string, source string, list []string) error</code></pre>
         </article>
         
         <article class="function" data-name="checkFlags">
            <h2>checkFlags</h2>
            <hr />
            
            <pre><code>func checkFlags(name string, source string, list []string, invalid []*lazyregexp.Regexp, valid []*lazyregexp.Regexp, validNext []string, checkOverrides bool) error</code></pre>
         </article>
         
         <article class="function" data-name="TestCheckCompilerFlags">
            <h2>TestCheckCompilerFlags</h2>
            <hr />
            
            <pre><code>func TestCheckCompilerFlags(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCheckLinkerFlags">
            <h2>TestCheckLinkerFlags</h2>
            <hr />
            
            <pre><code>func TestCheckLinkerFlags(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCheckFlagAllowDisallow">
            <h2>TestCheckFlagAllowDisallow</h2>
            <hr />
            
            <pre><code>func TestCheckFlagAllowDisallow(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCheckCompilerFlagsForInternalLink">
            <h2>TestCheckCompilerFlagsForInternalLink</h2>
            <hr />
            
            <pre><code>func TestCheckCompilerFlagsForInternalLink(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="NewShell">
            <h2>NewShell</h2>
            <hr />
            
            <p>NewShell returns a new Shell.

Shell will internally serialize calls to the printer.
If printer is nil, it uses load.DefaultPrinter.</p>
            
            <pre><code>func NewShell(workDir string, printer load.Printer) *Shell</code></pre>
         </article>
         
         <article class="function" data-name="pkg">
            <h2>pkg</h2>
            <hr />
            
            <pre><code>func pkg() *load.Package</code></pre>
         </article>
         
         <article class="function" data-name="Printf">
            <h2>Printf</h2>
            <hr />
            
            <p>Printf emits a to this Shell's output stream, formatting it like fmt.Printf.
It is safe to call concurrently.</p>
            
            <pre><code>func Printf(format string, a ...any)</code></pre>
         </article>
         
         <article class="function" data-name="printfLocked">
            <h2>printfLocked</h2>
            <hr />
            
            <pre><code>func printfLocked(format string, a ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Errorf">
            <h2>Errorf</h2>
            <hr />
            
            <p>Errorf reports an error on sh's package and sets the process exit status to 1.</p>
            
            <pre><code>func Errorf(format string, a ...any)</code></pre>
         </article>
         
         <article class="function" data-name="WithAction">
            <h2>WithAction</h2>
            <hr />
            
            <p>WithAction returns a Shell identical to sh, but bound to Action a.</p>
            
            <pre><code>func WithAction(a *Action) *Shell</code></pre>
         </article>
         
         <article class="function" data-name="Shell">
            <h2>Shell</h2>
            <hr />
            
            <p>Shell returns a shell for running commands on behalf of Action a.</p>
            
            <pre><code>func Shell(a *Action) *Shell</code></pre>
         </article>
         
         <article class="function" data-name="BackgroundShell">
            <h2>BackgroundShell</h2>
            <hr />
            
            <p>BackgroundShell returns a Builder-wide Shell that's not bound to any Action.
Try not to use this unless there's really no sensible Action available.</p>
            
            <pre><code>func BackgroundShell() *Shell</code></pre>
         </article>
         
         <article class="function" data-name="moveOrCopyFile">
            <h2>moveOrCopyFile</h2>
            <hr />
            
            <p>moveOrCopyFile is like 'mv src dst' or 'cp src dst'.</p>
            
            <pre><code>func moveOrCopyFile(dst string, src string, perm fs.FileMode, force bool) error</code></pre>
         </article>
         
         <article class="function" data-name="CopyFile">
            <h2>CopyFile</h2>
            <hr />
            
            <p>copyFile is like 'cp src dst'.</p>
            
            <pre><code>func CopyFile(dst string, src string, perm fs.FileMode, force bool) error</code></pre>
         </article>
         
         <article class="function" data-name="mayberemovefile">
            <h2>mayberemovefile</h2>
            <hr />
            
            <p>mayberemovefile removes a file only if it is a regular file
When running as a user with sufficient privileges, we may delete
even device files, for example, which is not intended.</p>
            
            <pre><code>func mayberemovefile(s string)</code></pre>
         </article>
         
         <article class="function" data-name="writeFile">
            <h2>writeFile</h2>
            <hr />
            
            <p>writeFile writes the text to file.</p>
            
            <pre><code>func writeFile(file string, text []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="Mkdir">
            <h2>Mkdir</h2>
            <hr />
            
            <p>Mkdir makes the named directory.</p>
            
            <pre><code>func Mkdir(dir string) error</code></pre>
         </article>
         
         <article class="function" data-name="RemoveAll">
            <h2>RemoveAll</h2>
            <hr />
            
            <p>RemoveAll is like 'rm -rf'. It attempts to remove all paths even if there's
an error, and returns the first error.</p>
            
            <pre><code>func RemoveAll(paths ...string) error</code></pre>
         </article>
         
         <article class="function" data-name="Symlink">
            <h2>Symlink</h2>
            <hr />
            
            <p>Symlink creates a symlink newname -> oldname.</p>
            
            <pre><code>func Symlink(oldname string, newname string) error</code></pre>
         </article>
         
         <article class="function" data-name="fmtCmd">
            <h2>fmtCmd</h2>
            <hr />
            
            <p>fmtCmd formats a command in the manner of fmt.Sprintf but also:

	fmtCmd replaces the value of b.WorkDir with $WORK.</p>
            
            <pre><code>func fmtCmd(dir string, format string, args ...any) string</code></pre>
         </article>
         
         <article class="function" data-name="ShowCmd">
            <h2>ShowCmd</h2>
            <hr />
            
            <p>ShowCmd prints the given command to standard output
for the implementation of -n or -x.

ShowCmd also replaces the name of the current script directory with dot (.)
but only when it is at the beginning of a space-separated token.

If dir is not "" or "/" and not the current script directory, ShowCmd first
prints a "cd" command to switch to dir and updates the script directory.</p>
            
            <pre><code>func ShowCmd(dir string, format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="reportCmd">
            <h2>reportCmd</h2>
            <hr />
            
            <p>reportCmd reports the output and exit status of a command. The cmdOut and
cmdErr arguments are the output and exit error of the command, respectively.

The exact reporting behavior is as follows:

	cmdOut  cmdErr  Result
	""      nil     print nothing, return nil
	!=""    nil     print output, return nil
	""      !=nil   print nothing, return cmdErr (later printed)
	!=""    !=nil   print nothing, ignore err, return output as error (later printed)

reportCmd returns a non-nil error if and only if cmdErr != nil. It assumes
that the command output, if non-empty, is more detailed than the command
error (which is usually just an exit status), so prefers using the output as
the ultimate error. Typically, the caller should return this error from an
Action, which it will be printed by the Builder.

reportCmd formats the output as "# desc" followed by the given output. The
output is expected to contain references to 'dir', usually the source
directory for the package that has failed to build. reportCmd rewrites
mentions of dir with a relative path to dir when the relative path is
shorter. This is usually more pleasant. For example, if fmt doesn't compile
and we are in src/html, the output is

	$ go build
	# fmt
	../fmt/print.go:1090: undefined: asdf
	$

instead of

	$ go build
	# fmt
	/usr/gopher/go/src/fmt/print.go:1090: undefined: asdf
	$

reportCmd also replaces references to the work directory with $WORK, replaces
cgo file paths with the original file path, and replaces cgo-mangled names
with "C.name".

desc is optional. If "", a.Package.Desc() is used.

dir is optional. If "", a.Package.Dir is used.</p>
            
            <pre><code>func reportCmd(desc string, dir string, cmdOut []byte, cmdErr error) error</code></pre>
         </article>
         
         <article class="function" data-name="replacePrefix">
            <h2>replacePrefix</h2>
            <hr />
            
            <p>replacePrefix is like strings.ReplaceAll, but only replaces instances of old
that are preceded by ' ', '\t', or appear at the beginning of a line.</p>
            
            <pre><code>func replacePrefix(s string, old string, new string) string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="ImportPath">
            <h2>ImportPath</h2>
            <hr />
            
            <pre><code>func ImportPath() string</code></pre>
         </article>
         
         <article class="function" data-name="run">
            <h2>run</h2>
            <hr />
            
            <p>run runs the command given by cmdline in the directory dir.
If the command fails, run prints information about the failure
and returns a non-nil error.</p>
            
            <pre><code>func run(dir string, desc string, env []string, cmdargs ...any) error</code></pre>
         </article>
         
         <article class="function" data-name="runOut">
            <h2>runOut</h2>
            <hr />
            
            <p>runOut runs the command given by cmdline in the directory dir.
It returns the command output and any errors that occurred.
It accumulates execution time in a.</p>
            
            <pre><code>func runOut(dir string, env []string, cmdargs ...any) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="joinUnambiguously">
            <h2>joinUnambiguously</h2>
            <hr />
            
            <p>joinUnambiguously prints the slice, quoting where necessary to make the
output unambiguous.
TODO: See issue 5279. The printing of commands needs a complete redo.</p>
            
            <pre><code>func joinUnambiguously(a []string) string</code></pre>
         </article>
         
         <article class="function" data-name="FuzzSplitPkgConfigOutput">
            <h2>FuzzSplitPkgConfigOutput</h2>
            <hr />
            
            <pre><code>func FuzzSplitPkgConfigOutput(f *testing.F)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(value string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="AddBuildFlags">
            <h2>AddBuildFlags</h2>
            <hr />
            
            <p>AddBuildFlags adds the flags common to the build, clean, get,
install, list, run, and test commands.</p>
            
            <pre><code>func AddBuildFlags(cmd *base.Command, mask BuildFlagMask)</code></pre>
         </article>
         
         <article class="function" data-name="AddCoverFlags">
            <h2>AddCoverFlags</h2>
            <hr />
            
            <p>AddCoverFlags adds coverage-related flags to "cmd". If the
CoverageRedesign experiment is enabled, we add -cover{mode,pkg} to
the build command and only -coverprofile to the test command. If
the CoverageRedesign experiment is disabled, -cover* flags are
added only to the test command.</p>
            
            <pre><code>func AddCoverFlags(cmd *base.Command, coverProfileFlag *string)</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(s string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="IsBoolFlag">
            <h2>IsBoolFlag</h2>
            <hr />
            
            <pre><code>func IsBoolFlag() bool</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(s string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="fileExtSplit">
            <h2>fileExtSplit</h2>
            <hr />
            
            <p>fileExtSplit expects a filename and returns the name
and ext (without the dot). If the file has no
extension, ext will be empty.</p>
            
            <pre><code>func fileExtSplit(file string) (name string, ext string)</code></pre>
         </article>
         
         <article class="function" data-name="pkgsMain">
            <h2>pkgsMain</h2>
            <hr />
            
            <pre><code>func pkgsMain(pkgs []*load.Package) res []*load.Package</code></pre>
         </article>
         
         <article class="function" data-name="pkgsNotMain">
            <h2>pkgsNotMain</h2>
            <hr />
            
            <pre><code>func pkgsNotMain(pkgs []*load.Package) res []*load.Package</code></pre>
         </article>
         
         <article class="function" data-name="oneMainPkg">
            <h2>oneMainPkg</h2>
            <hr />
            
            <pre><code>func oneMainPkg(pkgs []*load.Package) []*load.Package</code></pre>
         </article>
         
         <article class="function" data-name="runBuild">
            <h2>runBuild</h2>
            <hr />
            
            <pre><code>func runBuild(ctx context.Context, cmd *base.Command, args []string)</code></pre>
         </article>
         
         <article class="function" data-name="libname">
            <h2>libname</h2>
            <hr />
            
            <p>libname returns the filename to use for the shared library when using
-buildmode=shared. The rules we use are:
Use arguments for special 'meta' packages:

	std --> libstd.so
	std cmd --> libstd,cmd.so

A single non-meta argument with trailing "/..." is special cased:

	foo/... --> libfoo.so
	(A relative path like "./..."  expands the "." first)

Use import paths for other cases, changing '/' to '-':

	somelib --> libsubdir-somelib.so
	./ or ../ --> libsubdir-somelib.so
	gopkg.in/tomb.v2 -> libgopkg.in-tomb.v2.so
	a/... b/... ---> liba/c,b/d.so - all matching import paths

Name parts are joined with ','.</p>
            
            <pre><code>func libname(args []string, pkgs []*load.Package) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="runInstall">
            <h2>runInstall</h2>
            <hr />
            
            <pre><code>func runInstall(ctx context.Context, cmd *base.Command, args []string)</code></pre>
         </article>
         
         <article class="function" data-name="omitTestOnly">
            <h2>omitTestOnly</h2>
            <hr />
            
            <p>omitTestOnly returns pkgs with test-only packages removed.</p>
            
            <pre><code>func omitTestOnly(pkgs []*load.Package) []*load.Package</code></pre>
         </article>
         
         <article class="function" data-name="InstallPackages">
            <h2>InstallPackages</h2>
            <hr />
            
            <pre><code>func InstallPackages(ctx context.Context, patterns []string, pkgs []*load.Package)</code></pre>
         </article>
         
         <article class="function" data-name="installOutsideModule">
            <h2>installOutsideModule</h2>
            <hr />
            
            <p>installOutsideModule implements 'go install pkg@version'. It builds and
installs one or more main packages in module mode while ignoring any go.mod
in the current directory or parent directories.

See golang.org/issue/40276 for details and rationale.</p>
            
            <pre><code>func installOutsideModule(ctx context.Context, args []string)</code></pre>
         </article>
         
         <article class="function" data-name="FindExecCmd">
            <h2>FindExecCmd</h2>
            <hr />
            
            <p>FindExecCmd derives the value of ExecCmd to use.
It returns that value and leaves ExecCmd set for direct use.</p>
            
            <pre><code>func FindExecCmd() []string</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(value string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(value string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(value string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(value string) error</code></pre>
         </article>
         
         <article class="function" data-name="TestRemoveDevNull">
            <h2>TestRemoveDevNull</h2>
            <hr />
            
            <pre><code>func TestRemoveDevNull(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSplitPkgConfigOutput">
            <h2>TestSplitPkgConfigOutput</h2>
            <hr />
            
            <pre><code>func TestSplitPkgConfigOutput(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSharedLibName">
            <h2>TestSharedLibName</h2>
            <hr />
            
            <pre><code>func TestSharedLibName(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="pkgImportPath">
            <h2>pkgImportPath</h2>
            <hr />
            
            <pre><code>func pkgImportPath(pkgpath string) *load.Package</code></pre>
         </article>
         
         <article class="function" data-name="TestRespectSetgidDir">
            <h2>TestRespectSetgidDir</h2>
            <hr />
            
            <p>When installing packages, the installed package directory should
respect the SetGID bit and group name of the destination
directory.
See https://golang.org/issue/18878.</p>
            
            <pre><code>func TestRespectSetgidDir(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="actionID">
            <h2>actionID</h2>
            <hr />
            
            <p>actionID returns the action ID half of a build ID.</p>
            
            <pre><code>func actionID(buildID string) string</code></pre>
         </article>
         
         <article class="function" data-name="contentID">
            <h2>contentID</h2>
            <hr />
            
            <p>contentID returns the content ID half of a build ID.</p>
            
            <pre><code>func contentID(buildID string) string</code></pre>
         </article>
         
         <article class="function" data-name="toolID">
            <h2>toolID</h2>
            <hr />
            
            <p>toolID returns the unique ID to use for the current copy of the
named tool (asm, compile, cover, link).

It is important that if the tool changes (for example a compiler bug is fixed
and the compiler reinstalled), toolID returns a different string, so that old
package archives look stale and are rebuilt (with the fixed compiler).
This suggests using a content hash of the tool binary, as stored in the build ID.

Unfortunately, we can't just open the tool binary, because the tool might be
invoked via a wrapper program specified by -toolexec and we don't know
what the wrapper program does. In particular, we want "-toolexec toolstash"
to continue working: it does no good if "-toolexec toolstash" is executing a
stashed copy of the compiler but the go command is acting as if it will run
the standard copy of the compiler. The solution is to ask the tool binary to tell
us its own build ID using the "-V=full" flag now supported by all tools.
Then we know we're getting the build ID of the compiler that will actually run
during the build. (How does the compiler binary know its own content hash?
We store it there using updateBuildID after the standard link step.)

A final twist is that we'd prefer to have reproducible builds for release toolchains.
It should be possible to cross-compile for Windows from either Linux or Mac
or Windows itself and produce the same binaries, bit for bit. If the tool ID,
which influences the action ID half of the build ID, is based on the content ID,
then the Linux compiler binary and Mac compiler binary will have different tool IDs
and therefore produce executables with different action IDs.
To avoid this problem, for releases we use the release version string instead
of the compiler binary's content hash. This assumes that all compilers built
on all different systems are semantically equivalent, which is of course only true
modulo bugs. (Producing the exact same executables also requires that the different
build setups agree on details like $GOROOT and file name paths, but at least the
tool IDs do not make it impossible.)</p>
            
            <pre><code>func toolID(name string) string</code></pre>
         </article>
         
         <article class="function" data-name="gccToolID">
            <h2>gccToolID</h2>
            <hr />
            
            <p>gccToolID returns the unique ID to use for a tool that is invoked
by the GCC driver. This is used particularly for gccgo, but this can also
be used for gcc, g++, gfortran, etc.; those tools all use the GCC
driver under different names. The approach used here should also
work for sufficiently new versions of clang. Unlike toolID, the
name argument is the program to run. The language argument is the
type of input file as passed to the GCC driver's -x option.

For these tools we have no -V=full option to dump the build ID,
but we can run the tool with -v -### to reliably get the compiler proper
and hash that. That will work in the presence of -toolexec.

In order to get reproducible builds for released compilers, we
detect a released compiler by the absence of "experimental" in the
--version output, and in that case we just use the version string.

gccToolID also returns the underlying executable for the compiler.
The caller assumes that stat of the exe can be used, combined with the id,
to detect changes in the underlying compiler. The returned exe can be empty,
which means to rely only on the id.</p>
            
            <pre><code>func gccToolID(name string, language string) (id string, exe string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="assemblerIsGas">
            <h2>assemblerIsGas</h2>
            <hr />
            
            <p>Check if assembler used by gccgo is GNU as.</p>
            
            <pre><code>func assemblerIsGas() bool</code></pre>
         </article>
         
         <article class="function" data-name="gccgoBuildIDFile">
            <h2>gccgoBuildIDFile</h2>
            <hr />
            
            <p>gccgoBuildIDFile creates an assembler file that records the
action's build ID in an SHF_EXCLUDE section for ELF files or
in a CSECT in XCOFF files.</p>
            
            <pre><code>func gccgoBuildIDFile(a *Action) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="buildID">
            <h2>buildID</h2>
            <hr />
            
            <p>buildID returns the build ID found in the given file.
If no build ID is found, buildID returns the content hash of the file.</p>
            
            <pre><code>func buildID(file string) string</code></pre>
         </article>
         
         <article class="function" data-name="fileHash">
            <h2>fileHash</h2>
            <hr />
            
            <p>fileHash returns the content hash of the named file.</p>
            
            <pre><code>func fileHash(file string) string</code></pre>
         </article>
         
         <article class="function" data-name="useCache">
            <h2>useCache</h2>
            <hr />
            
            <p>useCache tries to satisfy the action a, which has action ID actionHash,
by using a cached result from an earlier build.
If useCache decides that the cache can be used, it sets a.buildID
and a.built for use by parent actions and then returns true.
Otherwise it sets a.buildID to a temporary build ID for use in the build
and returns false. When useCache returns false the expectation is that
the caller will build the target and then call updateBuildID to finish the
build ID computation.
When useCache returns false, it may have initiated buffering of output
during a's work. The caller should defer b.flushOutput(a), to make sure
that flushOutput is eventually called regardless of whether the action
succeeds. The flushOutput call must happen after updateBuildID.</p>
            
            <pre><code>func useCache(a *Action, actionHash cache.ActionID, target string, printOutput bool) ok bool</code></pre>
         </article>
         
         <article class="function" data-name="showStdout">
            <h2>showStdout</h2>
            <hr />
            
            <pre><code>func showStdout(b *Builder, c cache.Cache, a *Action, key string) error</code></pre>
         </article>
         
         <article class="function" data-name="flushOutput">
            <h2>flushOutput</h2>
            <hr />
            
            <p>flushOutput flushes the output being queued in a.</p>
            
            <pre><code>func flushOutput(a *Action)</code></pre>
         </article>
         
         <article class="function" data-name="updateBuildID">
            <h2>updateBuildID</h2>
            <hr />
            
            <p>updateBuildID updates the build ID in the target written by action a.
It requires that useCache was called for action a and returned false,
and that the build was then carried out and given the temporary
a.buildID to record as the build ID in the resulting package or binary.
updateBuildID computes the final content ID and updates the build IDs
in the binary.

Keep in sync with src/cmd/buildid/buildid.go</p>
            
            <pre><code>func updateBuildID(a *Action, target string) error</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
