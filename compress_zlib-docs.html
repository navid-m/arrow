<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - zlib</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                 
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>zlib</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bufio"
"compress/flate"
"encoding/binary"
"errors"
"hash"
"hash/adler32"
"io"
"compress/flate"
"encoding/binary"
"fmt"
"hash"
"hash/adler32"
"io"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="BestCompression">
               <h3>
                  BestCompression 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants are copied from the flate package, so that code that imports
"compress/zlib" does not also have to import "compress/flate".</p>
               
               <pre><code>const BestCompression = flate.BestCompression</code></pre>
            </article>
            
            <article class="global" data-name="BestSpeed">
               <h3>
                  BestSpeed 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants are copied from the flate package, so that code that imports
"compress/zlib" does not also have to import "compress/flate".</p>
               
               <pre><code>const BestSpeed = flate.BestSpeed</code></pre>
            </article>
            
            <article class="global" data-name="DefaultCompression">
               <h3>
                  DefaultCompression 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants are copied from the flate package, so that code that imports
"compress/zlib" does not also have to import "compress/flate".</p>
               
               <pre><code>const DefaultCompression = flate.DefaultCompression</code></pre>
            </article>
            
            <article class="global" data-name="ErrChecksum">
               <h3>
                  ErrChecksum 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrChecksum is returned when reading ZLIB data that has an invalid checksum.</p>
               
               <pre><code>var ErrChecksum = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrDictionary">
               <h3>
                  ErrDictionary 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrDictionary is returned when reading ZLIB data that has an invalid dictionary.</p>
               
               <pre><code>var ErrDictionary = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrHeader">
               <h3>
                  ErrHeader 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrHeader is returned when reading ZLIB data that has an invalid header.</p>
               
               <pre><code>var ErrHeader = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="HuffmanOnly">
               <h3>
                  HuffmanOnly 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants are copied from the flate package, so that code that imports
"compress/zlib" does not also have to import "compress/flate".</p>
               
               <pre><code>const HuffmanOnly = flate.HuffmanOnly</code></pre>
            </article>
            
            <article class="global" data-name="NoCompression">
               <h3>
                  NoCompression 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants are copied from the flate package, so that code that imports
"compress/zlib" does not also have to import "compress/flate".</p>
               
               <pre><code>const NoCompression = flate.NoCompression</code></pre>
            </article>
            
            <article class="global" data-name="zlibDeflate">
               <h3>
                  zlibDeflate 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const zlibDeflate = 8</code></pre>
            </article>
            
            <article class="global" data-name="zlibMaxWindow">
               <h3>
                  zlibMaxWindow 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const zlibMaxWindow = 7</code></pre>
            </article>
            
         </section>
           
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Resetter">
               <h3>
                  Resetter
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Resetter resets a ReadCloser returned by [NewReader] or [NewReaderDict]
to switch to a new underlying Reader. This permits reusing a ReadCloser
instead of allocating a new one.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Resetter interface {
Reset(r io.Reader, dict []byte) error
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Writer">
               <h3>
                  Writer
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Writer takes data written to it and writes the compressed
form of that data to an underlying writer (see NewWriter).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Writer struct {
w io.Writer
level int
dict []byte
compressor *flate.Writer
digest hash.Hash32
err error
scratch [4]byte
wroteHeader bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="reader">
               <h3>
                  reader
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type reader struct {
r flate.Reader
decompressor io.ReadCloser
digest hash.Hash32
err error
scratch [4]byte
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the Writer, flushing any unwritten data to the underlying
io.Writer, but does not close the underlying io.Writer.</p>
               
               <pre><code>func (z *Writer) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Calling Close does not close the wrapped [io.Reader] originally passed to [NewReader].
In order for the ZLIB checksum to be verified, the reader must be
fully consumed until the [io.EOF].</p>
               
               <pre><code>func (z *reader) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Flush flushes the Writer to its underlying io.Writer.</p>
               
               <pre><code>func (z *Writer) Flush() error</code></pre>
            </article>
            
            <article class="function" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewReader creates a new ReadCloser.
Reads from the returned ReadCloser read and decompress data from r.
If r does not implement [io.ByteReader], the decompressor may read more
data than necessary from r.
It is the caller's responsibility to call Close on the ReadCloser when done.
The [io.ReadCloser] returned by NewReader also implements [Resetter].</p>
               
               <pre><code>func NewReader(r io.Reader) (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewReaderDict">
               <h3>
                  NewReaderDict 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewReaderDict is like [NewReader] but uses a preset dictionary.
NewReaderDict ignores the dictionary if the compressed data does not refer to it.
If the compressed data refers to a different dictionary, NewReaderDict returns [ErrDictionary].
The ReadCloser returned by NewReaderDict also implements [Resetter].</p>
               
               <pre><code>func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewWriter">
               <h3>
                  NewWriter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewWriter creates a new Writer.
Writes to the returned Writer are compressed and written to w.
It is the caller's responsibility to call Close on the Writer when done.
Writes may be buffered and not flushed until Close.</p>
               
               <pre><code>func NewWriter(w io.Writer) *Writer</code></pre>
            </article>
            
            <article class="function" data-name="NewWriterLevel">
               <h3>
                  NewWriterLevel 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewWriterLevel is like NewWriter but specifies the compression level instead
of assuming DefaultCompression.
The compression level can be DefaultCompression, NoCompression, HuffmanOnly
or any integer value between BestSpeed and BestCompression inclusive.
The error returned will be nil if the level is valid.</p>
               
               <pre><code>func NewWriterLevel(w io.Writer, level int) (*Writer, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewWriterLevelDict">
               <h3>
                  NewWriterLevelDict 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to
compress with.
The dictionary may be nil. If not, its contents should not be modified until
the Writer is closed.</p>
               
               <pre><code>func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (z *reader) Read(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset clears the state of the Writer z such that it is equivalent to its
initial state from NewWriterLevel or NewWriterLevelDict, but instead writing
to w.</p>
               
               <pre><code>func (z *Writer) Reset(w io.Writer)</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (z *reader) Reset(r io.Reader, dict []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write writes a compressed form of p to the underlying io.Writer. The
compressed bytes are not necessarily flushed until the Writer is closed or
explicitly flushed.</p>
               
               <pre><code>func (z *Writer) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="writeHeader">
               <h3>
                  writeHeader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeHeader writes the ZLIB header.</p>
               
               <pre><code>func (z *Writer) writeHeader() (err error)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
