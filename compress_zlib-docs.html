<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - zlib</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>zlib</code>
         </h1>
         <hr />
         
         <article class="global" data-name="zlibDeflate">
            <h2>zlibDeflate</h2>
            <hr />
            
            <pre><code>zlibDeflate</code></pre>
         </article>
         
         <article class="global" data-name="zlibMaxWindow">
            <h2>zlibMaxWindow</h2>
            <hr />
            
            <pre><code>zlibMaxWindow</code></pre>
         </article>
         
         <article class="global" data-name="ErrChecksum">
            <h2>ErrChecksum</h2>
            <hr />
            
            <p>ErrChecksum is returned when reading ZLIB data that has an invalid checksum.</p>
            
            <pre><code>ErrChecksum</code></pre>
         </article>
         
         <article class="global" data-name="ErrDictionary">
            <h2>ErrDictionary</h2>
            <hr />
            
            <p>ErrDictionary is returned when reading ZLIB data that has an invalid dictionary.</p>
            
            <pre><code>ErrDictionary</code></pre>
         </article>
         
         <article class="global" data-name="ErrHeader">
            <h2>ErrHeader</h2>
            <hr />
            
            <p>ErrHeader is returned when reading ZLIB data that has an invalid header.</p>
            
            <pre><code>ErrHeader</code></pre>
         </article>
         
         <article class="global" data-name="zlibTests">
            <h2>zlibTests</h2>
            <hr />
            
            <pre><code>zlibTests</code></pre>
         </article>
         
         <article class="global" data-name="NoCompression">
            <h2>NoCompression</h2>
            <hr />
            
            <p>These constants are copied from the flate package, so that code that imports
"compress/zlib" does not also have to import "compress/flate".</p>
            
            <pre><code>NoCompression</code></pre>
         </article>
         
         <article class="global" data-name="BestSpeed">
            <h2>BestSpeed</h2>
            <hr />
            
            <p>These constants are copied from the flate package, so that code that imports
"compress/zlib" does not also have to import "compress/flate".</p>
            
            <pre><code>BestSpeed</code></pre>
         </article>
         
         <article class="global" data-name="BestCompression">
            <h2>BestCompression</h2>
            <hr />
            
            <p>These constants are copied from the flate package, so that code that imports
"compress/zlib" does not also have to import "compress/flate".</p>
            
            <pre><code>BestCompression</code></pre>
         </article>
         
         <article class="global" data-name="DefaultCompression">
            <h2>DefaultCompression</h2>
            <hr />
            
            <p>These constants are copied from the flate package, so that code that imports
"compress/zlib" does not also have to import "compress/flate".</p>
            
            <pre><code>DefaultCompression</code></pre>
         </article>
         
         <article class="global" data-name="HuffmanOnly">
            <h2>HuffmanOnly</h2>
            <hr />
            
            <p>These constants are copied from the flate package, so that code that imports
"compress/zlib" does not also have to import "compress/flate".</p>
            
            <pre><code>HuffmanOnly</code></pre>
         </article>
         
         <article class="global" data-name="filenames">
            <h2>filenames</h2>
            <hr />
            
            <pre><code>filenames</code></pre>
         </article>
         
         <article class="global" data-name="data">
            <h2>data</h2>
            <hr />
            
            <pre><code>data</code></pre>
         </article>
          
         <article class="struct" data-name="reader">
            <h2>type reader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">r flate.Reader
decompressor io.ReadCloser
digest hash.Hash32
err error
scratch []byte</code></pre>
         </article>
         
         <article class="struct" data-name="zlibTest">
            <h2>type zlibTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">desc string
raw string
compressed []byte
dict []byte
err error</code></pre>
         </article>
         
         <article class="struct" data-name="Writer">
            <h2>type Writer struct</h2>
            <hr />
            
            <p>A Writer takes data written to it and writes the compressed
form of that data to an underlying writer (see NewWriter).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">w io.Writer
level int
dict []byte
compressor *flate.Writer
digest hash.Hash32
err error
scratch []byte
wroteHeader bool</code></pre>
         </article>
          
         <article class="function" data-name="NewReader">
            <h2>NewReader</h2>
            <hr />
            
            <p>NewReader creates a new ReadCloser.
Reads from the returned ReadCloser read and decompress data from r.
If r does not implement [io.ByteReader], the decompressor may read more
data than necessary from r.
It is the caller's responsibility to call Close on the ReadCloser when done.

The [io.ReadCloser] returned by NewReader also implements [Resetter].</p>
            
            <pre><code>func NewReader(r io.Reader) (io.ReadCloser, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewReaderDict">
            <h2>NewReaderDict</h2>
            <hr />
            
            <p>NewReaderDict is like [NewReader] but uses a preset dictionary.
NewReaderDict ignores the dictionary if the compressed data does not refer to it.
If the compressed data refers to a different dictionary, NewReaderDict returns [ErrDictionary].

The ReadCloser returned by NewReaderDict also implements [Resetter].</p>
            
            <pre><code>func NewReaderDict(r io.Reader, dict []byte) (io.ReadCloser, error)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Calling Close does not close the wrapped [io.Reader] originally passed to [NewReader].
In order for the ZLIB checksum to be verified, the reader must be
fully consumed until the [io.EOF].</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="Reset">
            <h2>Reset</h2>
            <hr />
            
            <pre><code>func Reset(r io.Reader, dict []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="TestDecompressor">
            <h2>TestDecompressor</h2>
            <hr />
            
            <pre><code>func TestDecompressor(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="NewWriter">
            <h2>NewWriter</h2>
            <hr />
            
            <p>NewWriter creates a new Writer.
Writes to the returned Writer are compressed and written to w.

It is the caller's responsibility to call Close on the Writer when done.
Writes may be buffered and not flushed until Close.</p>
            
            <pre><code>func NewWriter(w io.Writer) *Writer</code></pre>
         </article>
         
         <article class="function" data-name="NewWriterLevel">
            <h2>NewWriterLevel</h2>
            <hr />
            
            <p>NewWriterLevel is like NewWriter but specifies the compression level instead
of assuming DefaultCompression.

The compression level can be DefaultCompression, NoCompression, HuffmanOnly
or any integer value between BestSpeed and BestCompression inclusive.
The error returned will be nil if the level is valid.</p>
            
            <pre><code>func NewWriterLevel(w io.Writer, level int) (*Writer, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewWriterLevelDict">
            <h2>NewWriterLevelDict</h2>
            <hr />
            
            <p>NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to
compress with.

The dictionary may be nil. If not, its contents should not be modified until
the Writer is closed.</p>
            
            <pre><code>func NewWriterLevelDict(w io.Writer, level int, dict []byte) (*Writer, error)</code></pre>
         </article>
         
         <article class="function" data-name="Reset">
            <h2>Reset</h2>
            <hr />
            
            <p>Reset clears the state of the Writer z such that it is equivalent to its
initial state from NewWriterLevel or NewWriterLevelDict, but instead writing
to w.</p>
            
            <pre><code>func Reset(w io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="writeHeader">
            <h2>writeHeader</h2>
            <hr />
            
            <p>writeHeader writes the ZLIB header.</p>
            
            <pre><code>func writeHeader() err error</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write writes a compressed form of p to the underlying io.Writer. The
compressed bytes are not necessarily flushed until the Writer is closed or
explicitly flushed.</p>
            
            <pre><code>func Write(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Flush">
            <h2>Flush</h2>
            <hr />
            
            <p>Flush flushes the Writer to its underlying io.Writer.</p>
            
            <pre><code>func Flush() error</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close closes the Writer, flushing any unwritten data to the underlying
io.Writer, but does not close the underlying io.Writer.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="testFileLevelDict">
            <h2>testFileLevelDict</h2>
            <hr />
            
            <p>Tests that compressing and then decompressing the given file at the given compression level and dictionary
yields equivalent bytes to the original file.</p>
            
            <pre><code>func testFileLevelDict(t *testing.T, fn string, level int, d string)</code></pre>
         </article>
         
         <article class="function" data-name="testLevelDict">
            <h2>testLevelDict</h2>
            <hr />
            
            <pre><code>func testLevelDict(t *testing.T, fn string, b0 []byte, level int, d string)</code></pre>
         </article>
         
         <article class="function" data-name="testFileLevelDictReset">
            <h2>testFileLevelDictReset</h2>
            <hr />
            
            <pre><code>func testFileLevelDictReset(t *testing.T, fn string, level int, dict []byte)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriter">
            <h2>TestWriter</h2>
            <hr />
            
            <pre><code>func TestWriter(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterBig">
            <h2>TestWriterBig</h2>
            <hr />
            
            <pre><code>func TestWriterBig(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterDict">
            <h2>TestWriterDict</h2>
            <hr />
            
            <pre><code>func TestWriterDict(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterReset">
            <h2>TestWriterReset</h2>
            <hr />
            
            <pre><code>func TestWriterReset(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterDictIsUsed">
            <h2>TestWriterDictIsUsed</h2>
            <hr />
            
            <pre><code>func TestWriterDictIsUsed(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
