<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>obj - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="cmd_internal_obj_arm-docs.html">arm</a></li>
               
               <li><a href="cmd_internal_obj_arm64-docs.html">arm64</a></li>
               
               <li><a href="cmd_internal_obj_loong64-docs.html">loong64</a></li>
               
               <li><a href="cmd_internal_obj_mips-docs.html">mips</a></li>
               
               <li><a href="cmd_internal_obj_ppc64-docs.html">ppc64</a></li>
               
               <li><a href="cmd_internal_obj_riscv-docs.html">riscv</a></li>
               
               <li><a href="cmd_internal_obj_s390x-docs.html">s390x</a></li>
               
               <li><a href="cmd_internal_obj_wasm-docs.html">wasm</a></li>
               
               <li><a href="cmd_internal_obj_x86-docs.html">x86</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>obj</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"strconv"
"cmd/internal/goobj"
"cmd/internal/src"
"bufio"
"bytes"
"cmd/internal/dwarf"
"cmd/internal/goobj"
"cmd/internal/objabi"
"cmd/internal/src"
"cmd/internal/sys"
"encoding/binary"
"fmt"
"internal/abi"
"sync"
"sync/atomic"
"bytes"
"cmd/internal/bio"
"cmd/internal/goobj"
"cmd/internal/hash"
"cmd/internal/objabi"
"cmd/internal/sys"
"cmp"
"encoding/binary"
"fmt"
"internal/abi"
"io"
"log"
"os"
"path/filepath"
"slices"
"sort"
"strings"
"cmd/internal/dwarf"
"cmd/internal/objabi"
"cmd/internal/src"
"fmt"
"slices"
"strings"
"sync"
"cmd/internal/src"
"cmd/internal/goobj"
"cmd/internal/objabi"
"encoding/binary"
"fmt"
"log"
"cmd/internal/objabi"
"cmd/internal/src"
"fmt"
"internal/abi"
"strings"
"strconv"
"cmd/internal/objabi"
"log"
"math"
"cmd/internal/objabi"
"fmt"
"internal/bisect"
"internal/buildcfg"
"log"
"os"
"strings"
"cmd/internal/goobj"
"cmd/internal/hash"
"cmd/internal/objabi"
"encoding/base64"
"encoding/binary"
"fmt"
"internal/buildcfg"
"log"
"math"
"sort"
"bytes"
"cmd/internal/objabi"
"fmt"
"internal/abi"
"internal/buildcfg"
"io"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ABI0" data-name="ABI0">
               <h3>
                  ABI0 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABI0" class="anchor" title="Link to ABI0">#</a>
               </h3>
               
                  <p class="doc-comment">ABI0 is the stable stack-based ABI. It's important that the
value of this is "0": we can't distinguish between
references to data and ABI0 text symbols in assembly code,
and hence this doesn't distinguish between symbols without
an ABI and text symbols with ABI0.</p>
               
               <pre><code class="language-go">const ABI0 ABI = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABICount" data-name="ABICount">
               <h3>
                  ABICount 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABICount" class="anchor" title="Link to ABICount">#</a>
               </h3>
               
               <pre><code class="language-go">const ABICount</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABIInternal" data-name="ABIInternal">
               <h3>
                  ABIInternal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABIInternal" class="anchor" title="Link to ABIInternal">#</a>
               </h3>
               
                  <p class="doc-comment">ABIInternal is the internal ABI that may change between Go
versions. All Go functions use the internal ABI and the
compiler generates wrappers for calls to and from other
ABIs.</p>
               
               <pre><code class="language-go">const ABIInternal</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABISetCallable" data-name="ABISetCallable">
               <h3>
                  ABISetCallable 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABISetCallable" class="anchor" title="Link to ABISetCallable">#</a>
               </h3>
               
                  <p class="doc-comment">ABISetCallable is the set of all ABIs any function could
potentially be called using.</p>
               
               <pre><code class="language-go">const ABISetCallable ABISet = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABIWRAPPER" data-name="ABIWRAPPER">
               <h3>
                  ABIWRAPPER 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABIWRAPPER" class="anchor" title="Link to ABIWRAPPER">#</a>
               </h3>
               
                  <p class="doc-comment">Function is an ABI wrapper.</p>
               
               <pre><code class="language-go">const ABIWRAPPER = 4096</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABase386" data-name="ABase386">
               <h3>
                  ABase386 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABase386" class="anchor" title="Link to ABase386">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace of opcode values
for declaring its arch-specific opcodes.
Within this subspace, the first arch-specific opcode should be
at offset A_ARCHSPECIFIC.
Subspaces are aligned to a power of two so opcodes can be masked
with AMask and used as compact array indices.</p>
               
               <pre><code class="language-go">const ABase386 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABaseAMD64" data-name="ABaseAMD64">
               <h3>
                  ABaseAMD64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABaseAMD64" class="anchor" title="Link to ABaseAMD64">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace of opcode values
for declaring its arch-specific opcodes.
Within this subspace, the first arch-specific opcode should be
at offset A_ARCHSPECIFIC.
Subspaces are aligned to a power of two so opcodes can be masked
with AMask and used as compact array indices.</p>
               
               <pre><code class="language-go">const ABaseAMD64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABaseARM" data-name="ABaseARM">
               <h3>
                  ABaseARM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABaseARM" class="anchor" title="Link to ABaseARM">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace of opcode values
for declaring its arch-specific opcodes.
Within this subspace, the first arch-specific opcode should be
at offset A_ARCHSPECIFIC.
Subspaces are aligned to a power of two so opcodes can be masked
with AMask and used as compact array indices.</p>
               
               <pre><code class="language-go">const ABaseARM</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABaseARM64" data-name="ABaseARM64">
               <h3>
                  ABaseARM64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABaseARM64" class="anchor" title="Link to ABaseARM64">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace of opcode values
for declaring its arch-specific opcodes.
Within this subspace, the first arch-specific opcode should be
at offset A_ARCHSPECIFIC.
Subspaces are aligned to a power of two so opcodes can be masked
with AMask and used as compact array indices.</p>
               
               <pre><code class="language-go">const ABaseARM64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABaseLoong64" data-name="ABaseLoong64">
               <h3>
                  ABaseLoong64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABaseLoong64" class="anchor" title="Link to ABaseLoong64">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace of opcode values
for declaring its arch-specific opcodes.
Within this subspace, the first arch-specific opcode should be
at offset A_ARCHSPECIFIC.
Subspaces are aligned to a power of two so opcodes can be masked
with AMask and used as compact array indices.</p>
               
               <pre><code class="language-go">const ABaseLoong64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABaseMIPS" data-name="ABaseMIPS">
               <h3>
                  ABaseMIPS 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABaseMIPS" class="anchor" title="Link to ABaseMIPS">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace of opcode values
for declaring its arch-specific opcodes.
Within this subspace, the first arch-specific opcode should be
at offset A_ARCHSPECIFIC.
Subspaces are aligned to a power of two so opcodes can be masked
with AMask and used as compact array indices.</p>
               
               <pre><code class="language-go">const ABaseMIPS</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABasePPC64" data-name="ABasePPC64">
               <h3>
                  ABasePPC64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABasePPC64" class="anchor" title="Link to ABasePPC64">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace of opcode values
for declaring its arch-specific opcodes.
Within this subspace, the first arch-specific opcode should be
at offset A_ARCHSPECIFIC.
Subspaces are aligned to a power of two so opcodes can be masked
with AMask and used as compact array indices.</p>
               
               <pre><code class="language-go">const ABasePPC64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABaseRISCV" data-name="ABaseRISCV">
               <h3>
                  ABaseRISCV 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABaseRISCV" class="anchor" title="Link to ABaseRISCV">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace of opcode values
for declaring its arch-specific opcodes.
Within this subspace, the first arch-specific opcode should be
at offset A_ARCHSPECIFIC.
Subspaces are aligned to a power of two so opcodes can be masked
with AMask and used as compact array indices.</p>
               
               <pre><code class="language-go">const ABaseRISCV</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABaseS390X" data-name="ABaseS390X">
               <h3>
                  ABaseS390X 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABaseS390X" class="anchor" title="Link to ABaseS390X">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace of opcode values
for declaring its arch-specific opcodes.
Within this subspace, the first arch-specific opcode should be
at offset A_ARCHSPECIFIC.
Subspaces are aligned to a power of two so opcodes can be masked
with AMask and used as compact array indices.</p>
               
               <pre><code class="language-go">const ABaseS390X</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ABaseWasm" data-name="ABaseWasm">
               <h3>
                  ABaseWasm 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ABaseWasm" class="anchor" title="Link to ABaseWasm">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace of opcode values
for declaring its arch-specific opcodes.
Within this subspace, the first arch-specific opcode should be
at offset A_ARCHSPECIFIC.
Subspaces are aligned to a power of two so opcodes can be masked
with AMask and used as compact array indices.</p>
               
               <pre><code class="language-go">const ABaseWasm</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ACALL" data-name="ACALL">
               <h3>
                  ACALL 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ACALL" class="anchor" title="Link to ACALL">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const ACALL</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ADUFFCOPY" data-name="ADUFFCOPY">
               <h3>
                  ADUFFCOPY 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ADUFFCOPY" class="anchor" title="Link to ADUFFCOPY">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const ADUFFCOPY</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ADUFFZERO" data-name="ADUFFZERO">
               <h3>
                  ADUFFZERO 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ADUFFZERO" class="anchor" title="Link to ADUFFZERO">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const ADUFFZERO</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AEND" data-name="AEND">
               <h3>
                  AEND 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AEND" class="anchor" title="Link to AEND">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const AEND</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AFUNCDATA" data-name="AFUNCDATA">
               <h3>
                  AFUNCDATA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AFUNCDATA" class="anchor" title="Link to AFUNCDATA">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const AFUNCDATA</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AGETCALLERPC" data-name="AGETCALLERPC">
               <h3>
                  AGETCALLERPC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AGETCALLERPC" class="anchor" title="Link to AGETCALLERPC">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const AGETCALLERPC</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AJMP" data-name="AJMP">
               <h3>
                  AJMP 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AJMP" class="anchor" title="Link to AJMP">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const AJMP</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AMask" data-name="AMask">
               <h3>
                  AMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AMask" class="anchor" title="Link to AMask">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace of opcode values
for declaring its arch-specific opcodes.
Within this subspace, the first arch-specific opcode should be
at offset A_ARCHSPECIFIC.
Subspaces are aligned to a power of two so opcodes can be masked
with AMask and used as compact array indices.</p>
               
               <pre><code class="language-go">const AMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ANOP" data-name="ANOP">
               <h3>
                  ANOP 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ANOP" class="anchor" title="Link to ANOP">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const ANOP</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="APCALIGN" data-name="APCALIGN">
               <h3>
                  APCALIGN 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#APCALIGN" class="anchor" title="Link to APCALIGN">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const APCALIGN</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="APCALIGNMAX" data-name="APCALIGNMAX">
               <h3>
                  APCALIGNMAX 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#APCALIGNMAX" class="anchor" title="Link to APCALIGNMAX">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const APCALIGNMAX</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="APCDATA" data-name="APCDATA">
               <h3>
                  APCDATA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#APCDATA" class="anchor" title="Link to APCDATA">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const APCDATA</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ARET" data-name="ARET">
               <h3>
                  ARET 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ARET" class="anchor" title="Link to ARET">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const ARET</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ATEXT" data-name="ATEXT">
               <h3>
                  ATEXT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ATEXT" class="anchor" title="Link to ATEXT">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const ATEXT</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AUNDEF" data-name="AUNDEF">
               <h3>
                  AUNDEF 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AUNDEF" class="anchor" title="Link to AUNDEF">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const AUNDEF</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AXXX" data-name="AXXX">
               <h3>
                  AXXX 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AXXX" class="anchor" title="Link to AXXX">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const AXXX As = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="A_ARCHSPECIFIC" data-name="A_ARCHSPECIFIC">
               <h3>
                  A_ARCHSPECIFIC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#A_ARCHSPECIFIC" class="anchor" title="Link to A_ARCHSPECIFIC">#</a>
               </h3>
               
                  <p class="doc-comment">These are the portable opcodes.</p>
               
               <pre><code class="language-go">const A_ARCHSPECIFIC</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AllowedOpCodes" data-name="AllowedOpCodes">
               <h3>
                  AllowedOpCodes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AllowedOpCodes" class="anchor" title="Link to AllowedOpCodes">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace of opcode values
for declaring its arch-specific opcodes.
Within this subspace, the first arch-specific opcode should be
at offset A_ARCHSPECIFIC.
Subspaces are aligned to a power of two so opcodes can be masked
with AMask and used as compact array indices.</p>
               
               <pre><code class="language-go">const AllowedOpCodes = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Anames" data-name="Anames">
               <h3>
                  Anames 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Anames" class="anchor" title="Link to Anames">#</a>
               </h3>
               
               <pre><code class="language-go">var Anames = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrABIWrapper" data-name="AttrABIWrapper">
               <h3>
                  AttrABIWrapper 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrABIWrapper" class="anchor" title="Link to AttrABIWrapper">#</a>
               </h3>
               
                  <p class="doc-comment">ABI wrapper is set for compiler-generated text symbols that
convert between ABI0 and ABIInternal calling conventions.</p>
               
               <pre><code class="language-go">const AttrABIWrapper</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrCFunc" data-name="AttrCFunc">
               <h3>
                  AttrCFunc 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrCFunc" class="anchor" title="Link to AttrCFunc">#</a>
               </h3>
               
               <pre><code class="language-go">const AttrCFunc</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrContentAddressable" data-name="AttrContentAddressable">
               <h3>
                  AttrContentAddressable 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrContentAddressable" class="anchor" title="Link to AttrContentAddressable">#</a>
               </h3>
               
                  <p class="doc-comment">ContentAddressable indicates this is a content-addressable symbol.</p>
               
               <pre><code class="language-go">const AttrContentAddressable</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrDuplicateOK" data-name="AttrDuplicateOK">
               <h3>
                  AttrDuplicateOK 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrDuplicateOK" class="anchor" title="Link to AttrDuplicateOK">#</a>
               </h3>
               
               <pre><code class="language-go">const AttrDuplicateOK Attribute = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrIndexed" data-name="AttrIndexed">
               <h3>
                  AttrIndexed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrIndexed" class="anchor" title="Link to AttrIndexed">#</a>
               </h3>
               
                  <p class="doc-comment">Indexed indicates this symbol has been assigned with an index (when using the
new object file format).</p>
               
               <pre><code class="language-go">const AttrIndexed</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrLeaf" data-name="AttrLeaf">
               <h3>
                  AttrLeaf 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrLeaf" class="anchor" title="Link to AttrLeaf">#</a>
               </h3>
               
               <pre><code class="language-go">const AttrLeaf</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrLinkname" data-name="AttrLinkname">
               <h3>
                  AttrLinkname 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrLinkname" class="anchor" title="Link to AttrLinkname">#</a>
               </h3>
               
                  <p class="doc-comment">Linkname indicates this is a go:linkname'd symbol.</p>
               
               <pre><code class="language-go">const AttrLinkname</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrLocal" data-name="AttrLocal">
               <h3>
                  AttrLocal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrLocal" class="anchor" title="Link to AttrLocal">#</a>
               </h3>
               
                  <p class="doc-comment">Local means make the symbol local even when compiling Go code to reference Go
symbols in other shared libraries, as in this mode symbols are global by
default. "local" here means in the sense of the dynamic linker, i.e. not
visible outside of the module (shared library or executable) that contains its
definition. (When not compiling to support Go shared libraries, all symbols are
local in this sense unless there is a cgo_export_* directive).</p>
               
               <pre><code class="language-go">const AttrLocal</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrMakeTypelink" data-name="AttrMakeTypelink">
               <h3>
                  AttrMakeTypelink 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrMakeTypelink" class="anchor" title="Link to AttrMakeTypelink">#</a>
               </h3>
               
                  <p class="doc-comment">MakeTypelink means that the type should have an entry in the typelink table.</p>
               
               <pre><code class="language-go">const AttrMakeTypelink</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrNeedCtxt" data-name="AttrNeedCtxt">
               <h3>
                  AttrNeedCtxt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrNeedCtxt" class="anchor" title="Link to AttrNeedCtxt">#</a>
               </h3>
               
               <pre><code class="language-go">const AttrNeedCtxt</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrNoFrame" data-name="AttrNoFrame">
               <h3>
                  AttrNoFrame 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrNoFrame" class="anchor" title="Link to AttrNoFrame">#</a>
               </h3>
               
               <pre><code class="language-go">const AttrNoFrame</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrNoSplit" data-name="AttrNoSplit">
               <h3>
                  AttrNoSplit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrNoSplit" class="anchor" title="Link to AttrNoSplit">#</a>
               </h3>
               
               <pre><code class="language-go">const AttrNoSplit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrOnList" data-name="AttrOnList">
               <h3>
                  AttrOnList 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrOnList" class="anchor" title="Link to AttrOnList">#</a>
               </h3>
               
               <pre><code class="language-go">const AttrOnList</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrPcdata" data-name="AttrPcdata">
               <h3>
                  AttrPcdata 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrPcdata" class="anchor" title="Link to AttrPcdata">#</a>
               </h3>
               
                  <p class="doc-comment">IsPcdata indicates this is a pcdata symbol.</p>
               
               <pre><code class="language-go">const AttrPcdata</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrPkgInit" data-name="AttrPkgInit">
               <h3>
                  AttrPkgInit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrPkgInit" class="anchor" title="Link to AttrPkgInit">#</a>
               </h3>
               
                  <p class="doc-comment">PkgInit indicates this is a compiler-generated package init func.</p>
               
               <pre><code class="language-go">const AttrPkgInit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrReflectMethod" data-name="AttrReflectMethod">
               <h3>
                  AttrReflectMethod 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrReflectMethod" class="anchor" title="Link to AttrReflectMethod">#</a>
               </h3>
               
                  <p class="doc-comment">ReflectMethod means the function may call reflect.Type.Method or
reflect.Type.MethodByName. Matching is imprecise (as reflect.Type
can be used through a custom interface), so ReflectMethod may be
set in some cases when the reflect package is not called.
Used by the linker to determine what methods can be pruned.</p>
               
               <pre><code class="language-go">const AttrReflectMethod</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrStatic" data-name="AttrStatic">
               <h3>
                  AttrStatic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrStatic" class="anchor" title="Link to AttrStatic">#</a>
               </h3>
               
               <pre><code class="language-go">const AttrStatic</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrUsedInIface" data-name="AttrUsedInIface">
               <h3>
                  AttrUsedInIface 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrUsedInIface" class="anchor" title="Link to AttrUsedInIface">#</a>
               </h3>
               
                  <p class="doc-comment">Only applied on type descriptor symbols, UsedInIface indicates this type is
converted to an interface.
Used by the linker to determine what methods can be pruned.</p>
               
               <pre><code class="language-go">const AttrUsedInIface</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrWasInlined" data-name="AttrWasInlined">
               <h3>
                  AttrWasInlined 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrWasInlined" class="anchor" title="Link to AttrWasInlined">#</a>
               </h3>
               
                  <p class="doc-comment">For function symbols; indicates that the specified function was the
target of an inline during compilation</p>
               
               <pre><code class="language-go">const AttrWasInlined</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AttrWrapper" data-name="AttrWrapper">
               <h3>
                  AttrWrapper 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AttrWrapper" class="anchor" title="Link to AttrWrapper">#</a>
               </h3>
               
               <pre><code class="language-go">const AttrWrapper</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="C_FBIT" data-name="C_FBIT">
               <h3>
                  C_FBIT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#C_FBIT" class="anchor" title="Link to C_FBIT">#</a>
               </h3>
               
                  <p class="doc-comment">ARM scond byte</p>
               
               <pre><code class="language-go">const C_FBIT = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="C_PBIT" data-name="C_PBIT">
               <h3>
                  C_PBIT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#C_PBIT" class="anchor" title="Link to C_PBIT">#</a>
               </h3>
               
                  <p class="doc-comment">ARM scond byte</p>
               
               <pre><code class="language-go">const C_PBIT = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="C_SBIT" data-name="C_SBIT">
               <h3>
                  C_SBIT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#C_SBIT" class="anchor" title="Link to C_SBIT">#</a>
               </h3>
               
                  <p class="doc-comment">ARM scond byte</p>
               
               <pre><code class="language-go">const C_SBIT = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="C_SCOND" data-name="C_SCOND">
               <h3>
                  C_SCOND 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#C_SCOND" class="anchor" title="Link to C_SCOND">#</a>
               </h3>
               
                  <p class="doc-comment">ARM scond byte</p>
               
               <pre><code class="language-go">const C_SCOND = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="C_SCOND_XOR" data-name="C_SCOND_XOR">
               <h3>
                  C_SCOND_XOR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#C_SCOND_XOR" class="anchor" title="Link to C_SCOND_XOR">#</a>
               </h3>
               
                  <p class="doc-comment">ARM scond byte</p>
               
               <pre><code class="language-go">const C_SCOND_XOR = 14</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="C_UBIT" data-name="C_UBIT">
               <h3>
                  C_UBIT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#C_UBIT" class="anchor" title="Link to C_UBIT">#</a>
               </h3>
               
                  <p class="doc-comment">ARM scond byte</p>
               
               <pre><code class="language-go">const C_UBIT = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="C_WBIT" data-name="C_WBIT">
               <h3>
                  C_WBIT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#C_WBIT" class="anchor" title="Link to C_WBIT">#</a>
               </h3>
               
                  <p class="doc-comment">ARM scond byte</p>
               
               <pre><code class="language-go">const C_WBIT = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DUPOK" data-name="DUPOK">
               <h3>
                  DUPOK 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DUPOK" class="anchor" title="Link to DUPOK">#</a>
               </h3>
               
                  <p class="doc-comment">It is ok for the linker to get multiple of these symbols. It will
pick one of the duplicates to use.</p>
               
               <pre><code class="language-go">const DUPOK = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Destination" data-name="Destination">
               <h3>
                  Destination 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Destination" class="anchor" title="Link to Destination">#</a>
               </h3>
               
               <pre><code class="language-go">const Destination</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="LINE_BASE" data-name="LINE_BASE">
               <h3>
                  LINE_BASE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#LINE_BASE" class="anchor" title="Link to LINE_BASE">#</a>
               </h3>
               
                  <p class="doc-comment">Generate a sequence of opcodes that is as short as possible.
See section 6.2.5</p>
               
               <pre><code class="language-go">const LINE_BASE = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="LINE_RANGE" data-name="LINE_RANGE">
               <h3>
                  LINE_RANGE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#LINE_RANGE" class="anchor" title="Link to LINE_RANGE">#</a>
               </h3>
               
                  <p class="doc-comment">Generate a sequence of opcodes that is as short as possible.
See section 6.2.5</p>
               
               <pre><code class="language-go">const LINE_RANGE = 10</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="LOCAL" data-name="LOCAL">
               <h3>
                  LOCAL 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#LOCAL" class="anchor" title="Link to LOCAL">#</a>
               </h3>
               
                  <p class="doc-comment">When passed to objw.Global, causes Local to be set to true on the LSym it creates.</p>
               
               <pre><code class="language-go">const LOCAL = 128</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="LOG" data-name="LOG">
               <h3>
                  LOG 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#LOG" class="anchor" title="Link to LOG">#</a>
               </h3>
               
               <pre><code class="language-go">const LOG = 5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NAME_AUTO" data-name="NAME_AUTO">
               <h3>
                  NAME_AUTO 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NAME_AUTO" class="anchor" title="Link to NAME_AUTO">#</a>
               </h3>
               
               <pre><code class="language-go">const NAME_AUTO</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NAME_EXTERN" data-name="NAME_EXTERN">
               <h3>
                  NAME_EXTERN 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NAME_EXTERN" class="anchor" title="Link to NAME_EXTERN">#</a>
               </h3>
               
               <pre><code class="language-go">const NAME_EXTERN</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NAME_GOTREF" data-name="NAME_GOTREF">
               <h3>
                  NAME_GOTREF 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NAME_GOTREF" class="anchor" title="Link to NAME_GOTREF">#</a>
               </h3>
               
                  <p class="doc-comment">A reference to name@GOT(SB) is a reference to the entry in the global offset
table for 'name'.</p>
               
               <pre><code class="language-go">const NAME_GOTREF</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NAME_NONE" data-name="NAME_NONE">
               <h3>
                  NAME_NONE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NAME_NONE" class="anchor" title="Link to NAME_NONE">#</a>
               </h3>
               
               <pre><code class="language-go">const NAME_NONE AddrName = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NAME_PARAM" data-name="NAME_PARAM">
               <h3>
                  NAME_PARAM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NAME_PARAM" class="anchor" title="Link to NAME_PARAM">#</a>
               </h3>
               
               <pre><code class="language-go">const NAME_PARAM</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NAME_STATIC" data-name="NAME_STATIC">
               <h3>
                  NAME_STATIC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NAME_STATIC" class="anchor" title="Link to NAME_STATIC">#</a>
               </h3>
               
               <pre><code class="language-go">const NAME_STATIC</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NAME_TOCREF" data-name="NAME_TOCREF">
               <h3>
                  NAME_TOCREF 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NAME_TOCREF" class="anchor" title="Link to NAME_TOCREF">#</a>
               </h3>
               
                  <p class="doc-comment">Indicates that this is a reference to a TOC anchor.</p>
               
               <pre><code class="language-go">const NAME_TOCREF</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NEEDCTXT" data-name="NEEDCTXT">
               <h3>
                  NEEDCTXT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NEEDCTXT" class="anchor" title="Link to NEEDCTXT">#</a>
               </h3>
               
                  <p class="doc-comment">This function uses its incoming context register.</p>
               
               <pre><code class="language-go">const NEEDCTXT = 64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NOFRAME" data-name="NOFRAME">
               <h3>
                  NOFRAME 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NOFRAME" class="anchor" title="Link to NOFRAME">#</a>
               </h3>
               
                  <p class="doc-comment">Do not insert instructions to allocate a stack frame for this function.
Only valid on functions that declare a frame size of 0.</p>
               
               <pre><code class="language-go">const NOFRAME = 512</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NOPROF" data-name="NOPROF">
               <h3>
                  NOPROF 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NOPROF" class="anchor" title="Link to NOPROF">#</a>
               </h3>
               
                  <p class="doc-comment">Don't profile the marked routine.
Deprecated: Not implemented, do not use.</p>
               
               <pre><code class="language-go">const NOPROF = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NOPTR" data-name="NOPTR">
               <h3>
                  NOPTR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NOPTR" class="anchor" title="Link to NOPTR">#</a>
               </h3>
               
                  <p class="doc-comment">This data contains no pointers.</p>
               
               <pre><code class="language-go">const NOPTR = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NOSPLIT" data-name="NOSPLIT">
               <h3>
                  NOSPLIT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NOSPLIT" class="anchor" title="Link to NOSPLIT">#</a>
               </h3>
               
                  <p class="doc-comment">Don't insert stack check preamble.</p>
               
               <pre><code class="language-go">const NOSPLIT = 4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OPCODE_BASE" data-name="OPCODE_BASE">
               <h3>
                  OPCODE_BASE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OPCODE_BASE" class="anchor" title="Link to OPCODE_BASE">#</a>
               </h3>
               
                  <p class="doc-comment">Generate a sequence of opcodes that is as short as possible.
See section 6.2.5</p>
               
               <pre><code class="language-go">const OPCODE_BASE = 11</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PC_RANGE" data-name="PC_RANGE">
               <h3>
                  PC_RANGE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PC_RANGE" class="anchor" title="Link to PC_RANGE">#</a>
               </h3>
               
                  <p class="doc-comment">Generate a sequence of opcodes that is as short as possible.
See section 6.2.5</p>
               
               <pre><code class="language-go">const PC_RANGE = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PKGINIT" data-name="PKGINIT">
               <h3>
                  PKGINIT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PKGINIT" class="anchor" title="Link to PKGINIT">#</a>
               </h3>
               
                  <p class="doc-comment">Function is a compiler-generated package init function.</p>
               
               <pre><code class="language-go">const PKGINIT = 8192</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RBase386" data-name="RBase386">
               <h3>
                  RBase386 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RBase386" class="anchor" title="Link to RBase386">#</a>
               </h3>
               
                  <p class="doc-comment">Because of masking operations in the encodings, each register
space should start at 0 modulo some power of 2.</p>
               
               <pre><code class="language-go">const RBase386 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RBaseAMD64" data-name="RBaseAMD64">
               <h3>
                  RBaseAMD64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RBaseAMD64" class="anchor" title="Link to RBaseAMD64">#</a>
               </h3>
               
               <pre><code class="language-go">const RBaseAMD64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RBaseARM" data-name="RBaseARM">
               <h3>
                  RBaseARM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RBaseARM" class="anchor" title="Link to RBaseARM">#</a>
               </h3>
               
               <pre><code class="language-go">const RBaseARM = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RBaseARM64" data-name="RBaseARM64">
               <h3>
                  RBaseARM64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RBaseARM64" class="anchor" title="Link to RBaseARM64">#</a>
               </h3>
               
               <pre><code class="language-go">const RBaseARM64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RBaseLOONG64" data-name="RBaseLOONG64">
               <h3>
                  RBaseLOONG64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RBaseLOONG64" class="anchor" title="Link to RBaseLOONG64">#</a>
               </h3>
               
               <pre><code class="language-go">const RBaseLOONG64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RBaseMIPS" data-name="RBaseMIPS">
               <h3>
                  RBaseMIPS 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RBaseMIPS" class="anchor" title="Link to RBaseMIPS">#</a>
               </h3>
               
               <pre><code class="language-go">const RBaseMIPS = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RBasePPC64" data-name="RBasePPC64">
               <h3>
                  RBasePPC64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RBasePPC64" class="anchor" title="Link to RBasePPC64">#</a>
               </h3>
               
               <pre><code class="language-go">const RBasePPC64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RBaseRISCV" data-name="RBaseRISCV">
               <h3>
                  RBaseRISCV 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RBaseRISCV" class="anchor" title="Link to RBaseRISCV">#</a>
               </h3>
               
               <pre><code class="language-go">const RBaseRISCV = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RBaseS390X" data-name="RBaseS390X">
               <h3>
                  RBaseS390X 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RBaseS390X" class="anchor" title="Link to RBaseS390X">#</a>
               </h3>
               
               <pre><code class="language-go">const RBaseS390X = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RBaseWasm" data-name="RBaseWasm">
               <h3>
                  RBaseWasm 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RBaseWasm" class="anchor" title="Link to RBaseWasm">#</a>
               </h3>
               
               <pre><code class="language-go">const RBaseWasm = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="REFLECTMETHOD" data-name="REFLECTMETHOD">
               <h3>
                  REFLECTMETHOD 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#REFLECTMETHOD" class="anchor" title="Link to REFLECTMETHOD">#</a>
               </h3>
               
                  <p class="doc-comment">Function can call reflect.Type.Method or reflect.Type.MethodByName.</p>
               
               <pre><code class="language-go">const REFLECTMETHOD = 1024</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="REG_NONE" data-name="REG_NONE">
               <h3>
                  REG_NONE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#REG_NONE" class="anchor" title="Link to REG_NONE">#</a>
               </h3>
               
               <pre><code class="language-go">const REG_NONE = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RODATA" data-name="RODATA">
               <h3>
                  RODATA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RODATA" class="anchor" title="Link to RODATA">#</a>
               </h3>
               
                  <p class="doc-comment">Put this data in a read-only section.</p>
               
               <pre><code class="language-go">const RODATA = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RegListARM64Hi" data-name="RegListARM64Hi">
               <h3>
                  RegListARM64Hi 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RegListARM64Hi" class="anchor" title="Link to RegListARM64Hi">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace: [Lo, Hi) for declaring its
arch-specific register list numbers.</p>
               
               <pre><code class="language-go">const RegListARM64Hi = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RegListARM64Lo" data-name="RegListARM64Lo">
               <h3>
                  RegListARM64Lo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RegListARM64Lo" class="anchor" title="Link to RegListARM64Lo">#</a>
               </h3>
               
                  <p class="doc-comment">arm64 uses the 60th bit to differentiate from other archs</p>
               
               <pre><code class="language-go">const RegListARM64Lo = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RegListARMHi" data-name="RegListARMHi">
               <h3>
                  RegListARMHi 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RegListARMHi" class="anchor" title="Link to RegListARMHi">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace: [Lo, Hi) for declaring its
arch-specific register list numbers.</p>
               
               <pre><code class="language-go">const RegListARMHi = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RegListARMLo" data-name="RegListARMLo">
               <h3>
                  RegListARMLo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RegListARMLo" class="anchor" title="Link to RegListARMLo">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace: [Lo, Hi) for declaring its
arch-specific register list numbers.</p>
               
               <pre><code class="language-go">const RegListARMLo = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RegListX86Hi" data-name="RegListX86Hi">
               <h3>
                  RegListX86Hi 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RegListX86Hi" class="anchor" title="Link to RegListX86Hi">#</a>
               </h3>
               
                  <p class="doc-comment">Each architecture is allotted a distinct subspace: [Lo, Hi) for declaring its
arch-specific register list numbers.</p>
               
               <pre><code class="language-go">const RegListX86Hi = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RegListX86Lo" data-name="RegListX86Lo">
               <h3>
                  RegListX86Lo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RegListX86Lo" class="anchor" title="Link to RegListX86Lo">#</a>
               </h3>
               
                  <p class="doc-comment">x86 uses the 61th bit to differentiate from other archs</p>
               
               <pre><code class="language-go">const RegListX86Lo = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Source" data-name="Source">
               <h3>
                  Source 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Source" class="anchor" title="Link to Source">#</a>
               </h3>
               
               <pre><code class="language-go">const Source OperandPos = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StaticNamePrefix" data-name="StaticNamePrefix">
               <h3>
                  StaticNamePrefix 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StaticNamePrefix" class="anchor" title="Link to StaticNamePrefix">#</a>
               </h3>
               
                  <p class="doc-comment">StaticNamePrefix is the prefix the front end applies to static temporary
variables. When turned into LSyms, these can be tagged as static so
as to avoid inserting them into the linker's name lookup tables.</p>
               
               <pre><code class="language-go">const StaticNamePrefix = ".stmp_"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TLSBSS" data-name="TLSBSS">
               <h3>
                  TLSBSS 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TLSBSS" class="anchor" title="Link to TLSBSS">#</a>
               </h3>
               
                  <p class="doc-comment">Allocate a word of thread local storage and store the offset from the
thread local base to the thread local storage in this variable.</p>
               
               <pre><code class="language-go">const TLSBSS = 256</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TOPFRAME" data-name="TOPFRAME">
               <h3>
                  TOPFRAME 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TOPFRAME" class="anchor" title="Link to TOPFRAME">#</a>
               </h3>
               
                  <p class="doc-comment">Function is the outermost frame of the call stack. Call stack unwinders
should stop at this function.</p>
               
               <pre><code class="language-go">const TOPFRAME = 2048</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_ADDR" data-name="TYPE_ADDR">
               <h3>
                  TYPE_ADDR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_ADDR" class="anchor" title="Link to TYPE_ADDR">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_ADDR</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_BRANCH" data-name="TYPE_BRANCH">
               <h3>
                  TYPE_BRANCH 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_BRANCH" class="anchor" title="Link to TYPE_BRANCH">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_BRANCH</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_CONST" data-name="TYPE_CONST">
               <h3>
                  TYPE_CONST 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_CONST" class="anchor" title="Link to TYPE_CONST">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_CONST</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_FCONST" data-name="TYPE_FCONST">
               <h3>
                  TYPE_FCONST 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_FCONST" class="anchor" title="Link to TYPE_FCONST">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_FCONST</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_INDIR" data-name="TYPE_INDIR">
               <h3>
                  TYPE_INDIR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_INDIR" class="anchor" title="Link to TYPE_INDIR">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_INDIR</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_MEM" data-name="TYPE_MEM">
               <h3>
                  TYPE_MEM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_MEM" class="anchor" title="Link to TYPE_MEM">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_MEM</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_NONE" data-name="TYPE_NONE">
               <h3>
                  TYPE_NONE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_NONE" class="anchor" title="Link to TYPE_NONE">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_NONE AddrType = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_REG" data-name="TYPE_REG">
               <h3>
                  TYPE_REG 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_REG" class="anchor" title="Link to TYPE_REG">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_REG</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_REGLIST" data-name="TYPE_REGLIST">
               <h3>
                  TYPE_REGLIST 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_REGLIST" class="anchor" title="Link to TYPE_REGLIST">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_REGLIST</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_REGREG" data-name="TYPE_REGREG">
               <h3>
                  TYPE_REGREG 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_REGREG" class="anchor" title="Link to TYPE_REGREG">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_REGREG</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_REGREG2" data-name="TYPE_REGREG2">
               <h3>
                  TYPE_REGREG2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_REGREG2" class="anchor" title="Link to TYPE_REGREG2">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_REGREG2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_SCONST" data-name="TYPE_SCONST">
               <h3>
                  TYPE_SCONST 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_SCONST" class="anchor" title="Link to TYPE_SCONST">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_SCONST</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_SHIFT" data-name="TYPE_SHIFT">
               <h3>
                  TYPE_SHIFT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_SHIFT" class="anchor" title="Link to TYPE_SHIFT">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_SHIFT</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_SPECIAL" data-name="TYPE_SPECIAL">
               <h3>
                  TYPE_SPECIAL 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_SPECIAL" class="anchor" title="Link to TYPE_SPECIAL">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_SPECIAL</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TYPE_TEXTSIZE" data-name="TYPE_TEXTSIZE">
               <h3>
                  TYPE_TEXTSIZE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TYPE_TEXTSIZE" class="anchor" title="Link to TYPE_TEXTSIZE">#</a>
               </h3>
               
               <pre><code class="language-go">const TYPE_TEXTSIZE</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnlinkablePkg" data-name="UnlinkablePkg">
               <h3>
                  UnlinkablePkg 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnlinkablePkg" class="anchor" title="Link to UnlinkablePkg">#</a>
               </h3>
               
               <pre><code class="language-go">const UnlinkablePkg = "<unlinkable>"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WRAPPER" data-name="WRAPPER">
               <h3>
                  WRAPPER 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#WRAPPER" class="anchor" title="Link to WRAPPER">#</a>
               </h3>
               
                  <p class="doc-comment">This is a wrapper function and should not count as
disabling 'recover' or appear in tracebacks by default.</p>
               
               <pre><code class="language-go">const WRAPPER = 32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WasmBool" data-name="WasmBool">
               <h3>
                  WasmBool 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#WasmBool" class="anchor" title="Link to WasmBool">#</a>
               </h3>
               
                  <p class="doc-comment">bool is not really a wasm type, but we allow it on wasmimport/wasmexport
function parameters/results. 32-bit on Wasm side, 8-bit on Go side.</p>
               
               <pre><code class="language-go">const WasmBool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WasmF32" data-name="WasmF32">
               <h3>
                  WasmF32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#WasmF32" class="anchor" title="Link to WasmF32">#</a>
               </h3>
               
               <pre><code class="language-go">const WasmF32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WasmF64" data-name="WasmF64">
               <h3>
                  WasmF64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#WasmF64" class="anchor" title="Link to WasmF64">#</a>
               </h3>
               
               <pre><code class="language-go">const WasmF64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WasmI32" data-name="WasmI32">
               <h3>
                  WasmI32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#WasmI32" class="anchor" title="Link to WasmI32">#</a>
               </h3>
               
               <pre><code class="language-go">const WasmI32 WasmFieldType = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WasmI64" data-name="WasmI64">
               <h3>
                  WasmI64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#WasmI64" class="anchor" title="Link to WasmI64">#</a>
               </h3>
               
               <pre><code class="language-go">const WasmI64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WasmPtr" data-name="WasmPtr">
               <h3>
                  WasmPtr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#WasmPtr" class="anchor" title="Link to WasmPtr">#</a>
               </h3>
               
               <pre><code class="language-go">const WasmPtr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
                  <p class="doc-comment">Ensure ABISet is big enough to hold all ABIs.</p>
               
               <pre><code class="language-go">var _ ABISet = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ABI_index" data-name="_ABI_index">
               <h3>
                  _ABI_index 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_ABI_index" class="anchor" title="Link to _ABI_index">#</a>
               </h3>
               
               <pre><code class="language-go">var _ABI_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ABI_name" data-name="_ABI_name">
               <h3>
                  _ABI_name 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_ABI_name" class="anchor" title="Link to _ABI_name">#</a>
               </h3>
               
               <pre><code class="language-go">const _ABI_name = "ABI0ABIInternalABICount"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_AddrType_index" data-name="_AddrType_index">
               <h3>
                  _AddrType_index 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_AddrType_index" class="anchor" title="Link to _AddrType_index">#</a>
               </h3>
               
               <pre><code class="language-go">var _AddrType_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_AddrType_name" data-name="_AddrType_name">
               <h3>
                  _AddrType_name 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_AddrType_name" class="anchor" title="Link to _AddrType_name">#</a>
               </h3>
               
               <pre><code class="language-go">const _AddrType_name = "TYPE_NONETYPE_BRANCHTYPE_TEXTSIZETYPE_MEMTYPE_CONSTTYPE_FCONSTTYPE_SCONSTTYPE_REGTYPE_ADDRTYPE_SHIFTTYPE_REGREGTYPE_REGREG2TYPE_INDIRTYPE_REGLISTTYPE_SPECIAL"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="aSpace" data-name="aSpace">
               <h3>
                  aSpace 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#aSpace" class="anchor" title="Link to aSpace">#</a>
               </h3>
               
                  <p class="doc-comment">Not even worth sorting</p>
               
               <pre><code class="language-go">var aSpace []opSet</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="armCondCode" data-name="armCondCode">
               <h3>
                  armCondCode 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#armCondCode" class="anchor" title="Link to armCondCode">#</a>
               </h3>
               
               <pre><code class="language-go">var armCondCode = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="attrABIBase" data-name="attrABIBase">
               <h3>
                  attrABIBase 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#attrABIBase" class="anchor" title="Link to attrABIBase">#</a>
               </h3>
               
                  <p class="doc-comment">attrABIBase is the value at which the ABI is encoded in
Attribute. This must be last; all bits after this are
assumed to be an ABI value.
MUST BE LAST since all bits above this comprise the ABI.</p>
               
               <pre><code class="language-go">const attrABIBase</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bisectFIPS" data-name="bisectFIPS">
               <h3>
                  bisectFIPS 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bisectFIPS" class="anchor" title="Link to bisectFIPS">#</a>
               </h3>
               
                  <p class="doc-comment">bisectFIPS controls bisect-based debugging of FIPS symbol assignment.</p>
               
               <pre><code class="language-go">var bisectFIPS *bisect.Matcher</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cutoff" data-name="cutoff">
               <h3>
                  cutoff 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#cutoff" class="anchor" title="Link to cutoff">#</a>
               </h3>
               
                  <p class="doc-comment">cutoff is the maximum data section size permitted by the linker
(see issue #9862).</p>
               
               <pre><code class="language-go">const cutoff = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="enableFIPS" data-name="enableFIPS">
               <h3>
                  enableFIPS 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#enableFIPS" class="anchor" title="Link to enableFIPS">#</a>
               </h3>
               
               <pre><code class="language-go">const enableFIPS = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="opSuffixSpace" data-name="opSuffixSpace">
               <h3>
                  opSuffixSpace 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#opSuffixSpace" class="anchor" title="Link to opSuffixSpace">#</a>
               </h3>
               
               <pre><code class="language-go">var opSuffixSpace []opSuffixSet</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="regListSpace" data-name="regListSpace">
               <h3>
                  regListSpace 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#regListSpace" class="anchor" title="Link to regListSpace">#</a>
               </h3>
               
               <pre><code class="language-go">var regListSpace []regListSet</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="regSpace" data-name="regSpace">
               <h3>
                  regSpace 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#regSpace" class="anchor" title="Link to regSpace">#</a>
               </h3>
               
                  <p class="doc-comment">Few enough architectures that a linear scan is fastest.
Not even worth sorting.</p>
               
               <pre><code class="language-go">var regSpace []regSet</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="spcSpace" data-name="spcSpace">
               <h3>
                  spcSpace 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#spcSpace" class="anchor" title="Link to spcSpace">#</a>
               </h3>
               
               <pre><code class="language-go">var spcSpace []spcSet</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="textAttrStrings" data-name="textAttrStrings">
               <h3>
                  textAttrStrings 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#textAttrStrings" class="anchor" title="Link to textAttrStrings">#</a>
               </h3>
               
               <pre><code class="language-go">var textAttrStrings = [...]struct{...}{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="traverseAll" data-name="traverseAll">
               <h3>
                  traverseAll 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#traverseAll" class="anchor" title="Link to traverseAll">#</a>
               </h3>
               
               <pre><code class="language-go">const traverseAll = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="traverseAux" data-name="traverseAux">
               <h3>
                  traverseAux 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#traverseAux" class="anchor" title="Link to traverseAux">#</a>
               </h3>
               
               <pre><code class="language-go">const traverseAux</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="traverseDefs" data-name="traverseDefs">
               <h3>
                  traverseDefs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#traverseDefs" class="anchor" title="Link to traverseDefs">#</a>
               </h3>
               
               <pre><code class="language-go">const traverseDefs traverseFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="traversePcdata" data-name="traversePcdata">
               <h3>
                  traversePcdata 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#traversePcdata" class="anchor" title="Link to traversePcdata">#</a>
               </h3>
               
               <pre><code class="language-go">const traversePcdata</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="traverseRefs" data-name="traverseRefs">
               <h3>
                  traverseRefs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#traverseRefs" class="anchor" title="Link to traverseRefs">#</a>
               </h3>
               
               <pre><code class="language-go">const traverseRefs</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ABI" data-name="ABI">
               <h3>
                  ABI
                  <span class="badge type-badge">type</span>
                  <a href="#ABI" class="anchor" title="Link to ABI">#</a>
               </h3>
               
               <p>ABI is the calling convention of a text symbol.</p>
               
               <pre><code class="language-go">type ABI uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ABISet" data-name="ABISet">
               <h3>
                  ABISet
                  <span class="badge type-badge">type</span>
                  <a href="#ABISet" class="anchor" title="Link to ABISet">#</a>
               </h3>
               
               <p>ABISet is a bit set of ABI values.</p>
               
               <pre><code class="language-go">type ABISet uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="AddrName" data-name="AddrName">
               <h3>
                  AddrName
                  <span class="badge type-badge">type</span>
                  <a href="#AddrName" class="anchor" title="Link to AddrName">#</a>
               </h3>
               
               <pre><code class="language-go">type AddrName int8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="AddrType" data-name="AddrType">
               <h3>
                  AddrType
                  <span class="badge type-badge">type</span>
                  <a href="#AddrType" class="anchor" title="Link to AddrType">#</a>
               </h3>
               
               <pre><code class="language-go">type AddrType uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="As" data-name="As">
               <h3>
                  As
                  <span class="badge type-badge">type</span>
                  <a href="#As" class="anchor" title="Link to As">#</a>
               </h3>
               
               <p>An As denotes an assembler opcode.
There are some portable opcodes, declared here in package obj,
that are common to all architectures.
However, the majority of opcodes are arch-specific
and are declared in their respective architecture's subpackage.</p>
               
               <pre><code class="language-go">type As int16</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Attribute" data-name="Attribute">
               <h3>
                  Attribute
                  <span class="badge type-badge">type</span>
                  <a href="#Attribute" class="anchor" title="Link to Attribute">#</a>
               </h3>
               
               <p>Attribute is a set of symbol attributes.</p>
               
               <pre><code class="language-go">type Attribute uint32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="OperandPos" data-name="OperandPos">
               <h3>
                  OperandPos
                  <span class="badge type-badge">type</span>
                  <a href="#OperandPos" class="anchor" title="Link to OperandPos">#</a>
               </h3>
               
               <pre><code class="language-go">type OperandPos int8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ProgAlloc" data-name="ProgAlloc">
               <h3>
                  ProgAlloc
                  <span class="badge type-badge">type</span>
                  <a href="#ProgAlloc" class="anchor" title="Link to ProgAlloc">#</a>
               </h3>
               
               <p>ProgAlloc is a function that allocates Progs.
It is used to provide access to cached/bulk-allocated Progs to the assemblers.</p>
               
               <pre><code class="language-go">type ProgAlloc func() *Prog</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="WasmFieldType" data-name="WasmFieldType">
               <h3>
                  WasmFieldType
                  <span class="badge type-badge">type</span>
                  <a href="#WasmFieldType" class="anchor" title="Link to WasmFieldType">#</a>
               </h3>
               
               <pre><code class="language-go">type WasmFieldType byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="traverseFlag" data-name="traverseFlag">
               <h3>
                  traverseFlag
                  <span class="badge type-badge">type</span>
                  <a href="#traverseFlag" class="anchor" title="Link to traverseFlag">#</a>
               </h3>
               
               <pre><code class="language-go">type traverseFlag uint32</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Func" data-name="Func">
               <h3>
                  Func
                  <span class="badge interface-badge">interface</span>
                  <a href="#Func" class="anchor" title="Link to Func">#</a>
               </h3>
               
               <p>A Func represents a Go function. If non-nil, it must be a *ir.Func.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Func interface {
Pos() src.XPos
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Addr" data-name="Addr">
               <h3>
                  Addr
                  <span class="badge">struct</span>
                  <a href="#Addr" class="anchor" title="Link to Addr">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Addr struct {
Reg int16
Index int16
Scale int16
Type AddrType
Name AddrName
Class int8
Offset int64
Sym *LSym
Val interface{}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="AddrPos" data-name="AddrPos">
               <h3>
                  AddrPos
                  <span class="badge">struct</span>
                  <a href="#AddrPos" class="anchor" title="Link to AddrPos">#</a>
               </h3>
               
               <p>AddrPos indicates whether the operand is the source or the destination.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type AddrPos struct {
Addr
Pos OperandPos
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Auto" data-name="Auto">
               <h3>
                  Auto
                  <span class="badge">struct</span>
                  <a href="#Auto" class="anchor" title="Link to Auto">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Auto struct {
Asym *LSym
Aoffset int32
Name AddrName
Gotype *LSym
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="DwarfFixupTable" data-name="DwarfFixupTable">
               <h3>
                  DwarfFixupTable
                  <span class="badge">struct</span>
                  <a href="#DwarfFixupTable" class="anchor" title="Link to DwarfFixupTable">#</a>
               </h3>
               
               <p>This table is designed to aid in the creation of references between
DWARF subprogram DIEs.
In most cases when one DWARF DIE has to refer to another DWARF DIE,
the target of the reference has an LSym, which makes it easy to use
the existing relocation mechanism. For DWARF inlined routine DIEs,
however, the subprogram DIE has to refer to a child
parameter/variable DIE of the abstract subprogram. This child DIE
doesn't have an LSym, and also of interest is the fact that when
DWARF generation is happening for inlined function F within caller
G, it's possible that DWARF generation hasn't happened yet for F,
so there is no way to know the offset of a child DIE within F's
abstract function. Making matters more complex, each inlined
instance of F may refer to a subset of the original F's variables
(depending on what happens with optimization, some vars may be
eliminated).
The fixup table below helps overcome this hurdle. At the point
where a parameter/variable reference is made (via a call to
"ReferenceChildDIE"), a fixup record is generate that records
the relocation that is targeting that child variable. At a later
point when the abstract function DIE is emitted, there will be
a call to "RegisterChildDIEOffsets", at which point the offsets
needed to apply fixups are captured. Finally, once the parallel
portion of the compilation is done, fixups can actually be applied
during the "Finalize" method (this can't be done during the
parallel portion of the compile due to the possibility of data
races).
This table is also used to record the "precursor" function node for
each function that is the target of an inline -- child DIE references
have to be made with respect to the original pre-optimization
version of the function (to allow for the fact that each inlined
body may be optimized differently).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type DwarfFixupTable struct {
ctxt *Link
mu sync.Mutex
symtab map[*LSym]int
svec []symFixups
precursor map[*LSym]fnState
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="FileInfo" data-name="FileInfo">
               <h3>
                  FileInfo
                  <span class="badge">struct</span>
                  <a href="#FileInfo" class="anchor" title="Link to FileInfo">#</a>
               </h3>
               
               <p>A FileInfo contains extra fields for SDATA symbols backed by files.
(If LSym.Extra is a *FileInfo, LSym.P == nil.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type FileInfo struct {
Name string
Size int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="FuncInfo" data-name="FuncInfo">
               <h3>
                  FuncInfo
                  <span class="badge">struct</span>
                  <a href="#FuncInfo" class="anchor" title="Link to FuncInfo">#</a>
               </h3>
               
               <p>A FuncInfo contains extra fields for STEXT symbols.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type FuncInfo struct {
Args int32
Locals int32
Align int32
FuncID abi.FuncID
FuncFlag abi.FuncFlag
StartLine int32
Text *Prog
Autot map[*LSym]struct{...}
Pcln Pcln
InlMarks []InlMark
spills []RegSpill
dwarfInfoSym *LSym
dwarfLocSym *LSym
dwarfRangesSym *LSym
dwarfAbsFnSym *LSym
dwarfDebugLinesSym *LSym
GCArgs *LSym
GCLocals *LSym
StackObjects *LSym
OpenCodedDeferInfo *LSym
ArgInfo *LSym
ArgLiveInfo *LSym
WrapInfo *LSym
JumpTables []JumpTable
FuncInfoSym *LSym
WasmImport *WasmImport
WasmExport *WasmExport
sehUnwindInfoSym *LSym
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="InlMark" data-name="InlMark">
               <h3>
                  InlMark
                  <span class="badge">struct</span>
                  <a href="#InlMark" class="anchor" title="Link to InlMark">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type InlMark struct {
p *Prog
id int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="InlTree" data-name="InlTree">
               <h3>
                  InlTree
                  <span class="badge">struct</span>
                  <a href="#InlTree" class="anchor" title="Link to InlTree">#</a>
               </h3>
               
               <p>InlTree is a collection of inlined calls. The Parent field of an
InlinedCall is the index of another InlinedCall in InlTree.
The compiler maintains a global inlining tree and adds a node to it
every time a function is inlined. For example, suppose f() calls g()
and g has two calls to h(), and that f, g, and h are inlineable:
1 func main() {
2     f()
3 }
4 func f() {
5     g()
6 }
7 func g() {
8     h()
9     h()
10 }
11 func h() {
12     println("H")
13 }
Assuming the global tree starts empty, inlining will produce the
following tree:
[]InlinedCall{
{Parent: -1, Func: "f", Pos: <line 2>},
{Parent:  0, Func: "g", Pos: <line 5>},
{Parent:  1, Func: "h", Pos: <line 8>},
{Parent:  1, Func: "h", Pos: <line 9>},
}
The nodes of h inlined into main will have inlining indexes 2 and 3.
Eventually, the compiler extracts a per-function inlining tree from
the global inlining tree (see pcln.go).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type InlTree struct {
nodes []InlinedCall
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="InlinedCall" data-name="InlinedCall">
               <h3>
                  InlinedCall
                  <span class="badge">struct</span>
                  <a href="#InlinedCall" class="anchor" title="Link to InlinedCall">#</a>
               </h3>
               
               <p>InlinedCall is a node in an InlTree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type InlinedCall struct {
Parent int
Pos src.XPos
Func *LSym
Name string
ParentPC int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="JumpTable" data-name="JumpTable">
               <h3>
                  JumpTable
                  <span class="badge">struct</span>
                  <a href="#JumpTable" class="anchor" title="Link to JumpTable">#</a>
               </h3>
               
               <p>JumpTable represents a table used for implementing multi-way
computed branching, used typically for implementing switches.
Sym is the table itself, and Targets is a list of target
instructions to go to for the computed branch index.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type JumpTable struct {
Sym *LSym
Targets []*Prog
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="LSym" data-name="LSym">
               <h3>
                  LSym
                  <span class="badge">struct</span>
                  <a href="#LSym" class="anchor" title="Link to LSym">#</a>
               </h3>
               
               <p>An LSym is the sort of symbol that is written to an object file.
It represents Go symbols in a flat pkg+"."+name namespace.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type LSym struct {
Name string
Type objabi.SymKind
Attribute
Size int64
Gotype *LSym
P []byte
R []Reloc
Extra *interface{}
Pkg string
PkgIdx int32
SymIdx int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Link" data-name="Link">
               <h3>
                  Link
                  <span class="badge">struct</span>
                  <a href="#Link" class="anchor" title="Link to Link">#</a>
               </h3>
               
               <p>Link holds the context for writing object code from a compiler
to be linker input or for reading that input into the linker.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Link struct {
Headtype objabi.HeadType
Arch *LinkArch
Debugasm int
Debugvlog bool
Debugpcln string
Flag_shared bool
Flag_dynlink bool
Flag_linkshared bool
Flag_optimize bool
Flag_locationlists bool
Flag_noRefName bool
Retpoline bool
Flag_maymorestack string
Bso *bufio.Writer
Pathname string
Pkgpath string
hashmu sync.Mutex
hash map[string]*LSym
funchash map[string]*LSym
statichash map[string]*LSym
PosTable src.PosTable
InlTree InlTree
DwFixups *DwarfFixupTable
Imports []goobj.ImportedPkg
DiagFunc func(string, ...interface{})
DiagFlush func()
DebugInfo func(ctxt *Link, fn *LSym, info *LSym, curfn Func) ([]dwarf.Scope, dwarf.InlCalls)
GenAbstractFunc func(fn *LSym)
Errors int
InParallel bool
UseBASEntries bool
IsAsm bool
Std bool
Text []*LSym
Data []*LSym
constSyms []*LSym
SEHSyms []*LSym
pkgIdx map[string]int32
defs []*LSym
hashed64defs []*LSym
hasheddefs []*LSym
nonpkgdefs []*LSym
nonpkgrefs []*LSym
Fingerprint goobj.FingerprintType
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="LinkArch" data-name="LinkArch">
               <h3>
                  LinkArch
                  <span class="badge">struct</span>
                  <a href="#LinkArch" class="anchor" title="Link to LinkArch">#</a>
               </h3>
               
               <p>LinkArch is the definition of a single architecture.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type LinkArch struct {
*sys.Arch
Init func(*Link)
ErrorCheck func(*Link, *LSym)
Preprocess func(*Link, *LSym, ProgAlloc)
Assemble func(*Link, *LSym, ProgAlloc)
Progedit func(*Link, *Prog, ProgAlloc)
SEH func(*Link, *LSym) *LSym
UnaryDst map[As]bool
DWARFRegisters map[int16]int16
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PCIter" data-name="PCIter">
               <h3>
                  PCIter
                  <span class="badge">struct</span>
                  <a href="#PCIter" class="anchor" title="Link to PCIter">#</a>
               </h3>
               
               <p>PCIter iterates over encoded pcdata tables.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PCIter struct {
p []byte
PC uint32
NextPC uint32
PCScale uint32
Value int32
start bool
Done bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Pcln" data-name="Pcln">
               <h3>
                  Pcln
                  <span class="badge">struct</span>
                  <a href="#Pcln" class="anchor" title="Link to Pcln">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Pcln struct {
Pcsp *LSym
Pcfile *LSym
Pcline *LSym
Pcinline *LSym
Pcdata []*LSym
Funcdata []*LSym
UsedFiles map[goobj.CUFileIndex]struct{...}
InlTree InlTree
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Plist" data-name="Plist">
               <h3>
                  Plist
                  <span class="badge">struct</span>
                  <a href="#Plist" class="anchor" title="Link to Plist">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Plist struct {
Firstpc *Prog
Curfn Func
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Prog" data-name="Prog">
               <h3>
                  Prog
                  <span class="badge">struct</span>
                  <a href="#Prog" class="anchor" title="Link to Prog">#</a>
               </h3>
               
               <p>Prog describes a single machine instruction.
The general instruction form is:
(1) As.Scond From [, ...RestArgs], To
(2) As.Scond From, Reg [, ...RestArgs], To, RegTo2
where As is an opcode and the others are arguments:
From, Reg are sources, and To, RegTo2 are destinations.
RestArgs can hold additional sources and destinations.
Usually, not all arguments are present.
For example, MOVL R1, R2 encodes using only As=MOVL, From=R1, To=R2.
The Scond field holds additional condition bits for systems (like arm)
that have generalized conditional execution.
(2) form is present for compatibility with older code,
to avoid too much changes in a single swing.
(1) scheme is enough to express any kind of operand combination.
Jump instructions use the To.Val field to point to the target *Prog,
which must be in the same linked list as the jump instruction.
The Progs for a given function are arranged in a list linked through the Link field.
Each Prog is charged to a specific source line in the debug information,
specified by Pos.Line().
Every Prog has a Ctxt field that defines its context.
For performance reasons, Progs are usually bulk allocated, cached, and reused;
those bulk allocators should always be used, rather than new(Prog).
The other fields not yet mentioned are for use by the back ends and should
be left zeroed by creators of Prog lists.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Prog struct {
Ctxt *Link
Link *Prog
From Addr
RestArgs []AddrPos
To Addr
Pool *Prog
Forwd *Prog
Rel *Prog
Pc int64
Pos src.XPos
Spadj int32
As As
Reg int16
RegTo2 int16
Mark uint16
Optab uint16
Scond uint8
Back uint8
Ft uint8
Tt uint8
Isize uint8
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="RegSpill" data-name="RegSpill">
               <h3>
                  RegSpill
                  <span class="badge">struct</span>
                  <a href="#RegSpill" class="anchor" title="Link to RegSpill">#</a>
               </h3>
               
               <p>RegSpill provides spill/fill information for a register-resident argument
to a function.  These need spilling/filling in the safepoint/stackgrowth case.
At the time of fill/spill, the offset must be adjusted by the architecture-dependent
adjustment to hardware SP that occurs in a call instruction.  E.g., for AMD64,
at Offset+8 because the return address was pushed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type RegSpill struct {
Addr Addr
Reg int16
Reg2 int16
Spill As
Unspill As
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Reloc" data-name="Reloc">
               <h3>
                  Reloc
                  <span class="badge">struct</span>
                  <a href="#Reloc" class="anchor" title="Link to Reloc">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Reloc struct {
Off int32
Siz uint8
Type objabi.RelocType
Add int64
Sym *LSym
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TypeInfo" data-name="TypeInfo">
               <h3>
                  TypeInfo
                  <span class="badge">struct</span>
                  <a href="#TypeInfo" class="anchor" title="Link to TypeInfo">#</a>
               </h3>
               
               <p>A TypeInfo contains information for a symbol
that contains a runtime._type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type TypeInfo struct {
Type interface{}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="VarInfo" data-name="VarInfo">
               <h3>
                  VarInfo
                  <span class="badge">struct</span>
                  <a href="#VarInfo" class="anchor" title="Link to VarInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type VarInfo struct {
dwarfInfoSym *LSym
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="WasmExport" data-name="WasmExport">
               <h3>
                  WasmExport
                  <span class="badge">struct</span>
                  <a href="#WasmExport" class="anchor" title="Link to WasmExport">#</a>
               </h3>
               
               <p>WasmExport represents a WebAssembly (WASM) exported function with
parameters and results translated into WASM types based on the Go function
declaration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type WasmExport struct {
WasmFuncType
WrappedSym *LSym
AuxSym *LSym
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="WasmField" data-name="WasmField">
               <h3>
                  WasmField
                  <span class="badge">struct</span>
                  <a href="#WasmField" class="anchor" title="Link to WasmField">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type WasmField struct {
Type WasmFieldType
Offset int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="WasmFuncType" data-name="WasmFuncType">
               <h3>
                  WasmFuncType
                  <span class="badge">struct</span>
                  <a href="#WasmFuncType" class="anchor" title="Link to WasmFuncType">#</a>
               </h3>
               
               <p>WasmFuncType represents a WebAssembly (WASM) function type with
parameters and results translated into WASM types based on the Go function
declaration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type WasmFuncType struct {
Params []WasmField
Results []WasmField
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="WasmImport" data-name="WasmImport">
               <h3>
                  WasmImport
                  <span class="badge">struct</span>
                  <a href="#WasmImport" class="anchor" title="Link to WasmImport">#</a>
               </h3>
               
               <p>WasmImport represents a WebAssembly (WASM) imported function with
parameters and results translated into WASM types based on the Go function
declaration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type WasmImport struct {
Module string
Name string
WasmFuncType
AuxSym *LSym
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="declOffset" data-name="declOffset">
               <h3>
                  declOffset
                  <span class="badge">struct</span>
                  <a href="#declOffset" class="anchor" title="Link to declOffset">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type declOffset struct {
dclIdx int32
offset int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dwCtxt" data-name="dwCtxt">
               <h3>
                  dwCtxt
                  <span class="badge">struct</span>
                  <a href="#dwCtxt" class="anchor" title="Link to dwCtxt">#</a>
               </h3>
               
               <p>implement dwarf.Context</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type dwCtxt struct {
*Link
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fnState" data-name="fnState">
               <h3>
                  fnState
                  <span class="badge">struct</span>
                  <a href="#fnState" class="anchor" title="Link to fnState">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fnState struct {
precursor Func
absfn *LSym
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="opSet" data-name="opSet">
               <h3>
                  opSet
                  <span class="badge">struct</span>
                  <a href="#opSet" class="anchor" title="Link to opSet">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type opSet struct {
lo As
names []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="opSuffixSet" data-name="opSuffixSet">
               <h3>
                  opSuffixSet
                  <span class="badge">struct</span>
                  <a href="#opSuffixSet" class="anchor" title="Link to opSuffixSet">#</a>
               </h3>
               
               <p>opSuffixSet is like regListSet, but for opcode suffixes.
Unlike some other similar structures, uint8 space is not
divided by its own values set (because there are only 256 of them).
Instead, every arch may interpret/format all 8 bits as they like,
as long as they register proper cconv function for it.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type opSuffixSet struct {
arch string
cconv func(suffix uint8) string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pcinlineState" data-name="pcinlineState">
               <h3>
                  pcinlineState
                  <span class="badge">struct</span>
                  <a href="#pcinlineState" class="anchor" title="Link to pcinlineState">#</a>
               </h3>
               
               <p>pcinlineState holds the state used to create a function's inlining
tree and the PC-value table that maps PCs to nodes in that tree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type pcinlineState struct {
globalToLocal map[int]int
localTree InlTree
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="regListSet" data-name="regListSet">
               <h3>
                  regListSet
                  <span class="badge">struct</span>
                  <a href="#regListSet" class="anchor" title="Link to regListSet">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type regListSet struct {
lo int64
hi int64
RLconv func(int64) string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="regSet" data-name="regSet">
               <h3>
                  regSet
                  <span class="badge">struct</span>
                  <a href="#regSet" class="anchor" title="Link to regSet">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type regSet struct {
lo int
hi int
Rconv func(int) string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="relFixup" data-name="relFixup">
               <h3>
                  relFixup
                  <span class="badge">struct</span>
                  <a href="#relFixup" class="anchor" title="Link to relFixup">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type relFixup struct {
refsym *LSym
relidx int32
dclidx int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="spcSet" data-name="spcSet">
               <h3>
                  spcSet
                  <span class="badge">struct</span>
                  <a href="#spcSet" class="anchor" title="Link to spcSet">#</a>
               </h3>
               
               <p>Special operands</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type spcSet struct {
lo int64
hi int64
SPCconv func(int64) string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="symFixups" data-name="symFixups">
               <h3>
                  symFixups
                  <span class="badge">struct</span>
                  <a href="#symFixups" class="anchor" title="Link to symFixups">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type symFixups struct {
fixups []relFixup
doffsets []declOffset
inlIndex int32
defseen bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="writer" data-name="writer">
               <h3>
                  writer
                  <span class="badge">struct</span>
                  <a href="#writer" class="anchor" title="Link to writer">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type writer struct {
*goobj.Writer
filebuf []byte
ctxt *Link
pkgpath string
pkglist []string
tmpSym goobj.Sym
tmpReloc goobj.Reloc
tmpAux goobj.Aux
tmpHash64 goobj.Hash64Type
tmpHash goobj.HashType
tmpRefFlags goobj.RefFlags
tmpRefName goobj.RefName
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="ABI" data-name="ABI">
               <h3>
                  ABI 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ABI" class="anchor" title="Link to ABI">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) ABI() ABI</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ABISetOf" data-name="ABISetOf">
               <h3>
                  ABISetOf 
                  <span class="badge">function</span>
                  
                  <a href="#ABISetOf" class="anchor" title="Link to ABISetOf">#</a>
               </h3>
               
               <pre><code class="language-go">func ABISetOf(abi ABI) ABISet</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ABIWrapper" data-name="ABIWrapper">
               <h3>
                  ABIWrapper 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ABIWrapper" class="anchor" title="Link to ABIWrapper">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) ABIWrapper() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AbsFuncDwarfSym" data-name="AbsFuncDwarfSym">
               <h3>
                  AbsFuncDwarfSym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AbsFuncDwarfSym" class="anchor" title="Link to AbsFuncDwarfSym">#</a>
               </h3>
               
               <p>return the LSym corresponding to the 'abstract subprogram' DWARF
info entry for a function.</p>
               
               <pre><code class="language-go">func (ft *DwarfFixupTable) AbsFuncDwarfSym(fnsym *LSym) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add adds a new call to the tree, returning its index.</p>
               
               <pre><code class="language-go">func (tree *InlTree) Add(parent int, pos src.XPos, func_ *LSym, name string) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddAddress" data-name="AddAddress">
               <h3>
                  AddAddress 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddAddress" class="anchor" title="Link to AddAddress">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) AddAddress(s dwarf.Sym, data interface{}, value int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddBytes" data-name="AddBytes">
               <h3>
                  AddBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddBytes" class="anchor" title="Link to AddBytes">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) AddBytes(s dwarf.Sym, b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddCURelativeAddress" data-name="AddCURelativeAddress">
               <h3>
                  AddCURelativeAddress 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddCURelativeAddress" class="anchor" title="Link to AddCURelativeAddress">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) AddCURelativeAddress(s dwarf.Sym, data interface{}, value int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddDWARFAddrSectionOffset" data-name="AddDWARFAddrSectionOffset">
               <h3>
                  AddDWARFAddrSectionOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddDWARFAddrSectionOffset" class="anchor" title="Link to AddDWARFAddrSectionOffset">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) AddDWARFAddrSectionOffset(s dwarf.Sym, t interface{}, ofs int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddImport" data-name="AddImport">
               <h3>
                  AddImport 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddImport" class="anchor" title="Link to AddImport">#</a>
               </h3>
               
               <p>AddImport adds a package to the list of imported packages.</p>
               
               <pre><code class="language-go">func (ctxt *Link) AddImport(pkg string, fingerprint goobj.FingerprintType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddInlMark" data-name="AddInlMark">
               <h3>
                  AddInlMark 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddInlMark" class="anchor" title="Link to AddInlMark">#</a>
               </h3>
               
               <p>Mark p as the instruction to set as the pc when
"unwinding" the inlining global frame id. Usually it should be
instruction with a file:line at the callsite, and occur
just before the body of the inlined function.</p>
               
               <pre><code class="language-go">func (fi *FuncInfo) AddInlMark(p *Prog, id int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddInt" data-name="AddInt">
               <h3>
                  AddInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddInt" class="anchor" title="Link to AddInt">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) AddInt(s dwarf.Sym, size int, i int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddRel" data-name="AddRel">
               <h3>
                  AddRel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddRel" class="anchor" title="Link to AddRel">#</a>
               </h3>
               
               <p>AddRel adds the relocation rel to s.</p>
               
               <pre><code class="language-go">func (s *LSym) AddRel(ctxt *Link, rel Reloc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddRestDest" data-name="AddRestDest">
               <h3>
                  AddRestDest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddRestDest" class="anchor" title="Link to AddRestDest">#</a>
               </h3>
               
               <p>AddRestDest assigns []Args{{a, Destination}} to p.RestArgs when the second destination
operand does not fit into prog.RegTo2.</p>
               
               <pre><code class="language-go">func (p *Prog) AddRestDest(a Addr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddRestSource" data-name="AddRestSource">
               <h3>
                  AddRestSource 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddRestSource" class="anchor" title="Link to AddRestSource">#</a>
               </h3>
               
               <p>AddRestSource assigns []Args{{a, Source}} to p.RestArgs.</p>
               
               <pre><code class="language-go">func (p *Prog) AddRestSource(a Addr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddRestSourceArgs" data-name="AddRestSourceArgs">
               <h3>
                  AddRestSourceArgs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddRestSourceArgs" class="anchor" title="Link to AddRestSourceArgs">#</a>
               </h3>
               
               <p>AddRestSourceArgs assigns more than one source operands to p.RestArgs.</p>
               
               <pre><code class="language-go">func (p *Prog) AddRestSourceArgs(args []Addr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddRestSourceConst" data-name="AddRestSourceConst">
               <h3>
                  AddRestSourceConst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddRestSourceConst" class="anchor" title="Link to AddRestSourceConst">#</a>
               </h3>
               
               <p>AddRestSourceConst calls p.AddRestSource with a const Addr containing off.</p>
               
               <pre><code class="language-go">func (p *Prog) AddRestSourceConst(off int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddRestSourceReg" data-name="AddRestSourceReg">
               <h3>
                  AddRestSourceReg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddRestSourceReg" class="anchor" title="Link to AddRestSourceReg">#</a>
               </h3>
               
               <p>AddRestSourceReg calls p.AddRestSource with a register Addr containing reg.</p>
               
               <pre><code class="language-go">func (p *Prog) AddRestSourceReg(reg int16)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddSectionOffset" data-name="AddSectionOffset">
               <h3>
                  AddSectionOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddSectionOffset" class="anchor" title="Link to AddSectionOffset">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) AddSectionOffset(s dwarf.Sym, size int, t interface{}, ofs int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddSpill" data-name="AddSpill">
               <h3>
                  AddSpill 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddSpill" class="anchor" title="Link to AddSpill">#</a>
               </h3>
               
               <p>AddSpill appends a spill record to the list for FuncInfo fi</p>
               
               <pre><code class="language-go">func (fi *FuncInfo) AddSpill(s RegSpill)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddString" data-name="AddString">
               <h3>
                  AddString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddString" class="anchor" title="Link to AddString">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) AddString(s dwarf.Sym, v string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddUint16" data-name="AddUint16">
               <h3>
                  AddUint16 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddUint16" class="anchor" title="Link to AddUint16">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) AddUint16(s dwarf.Sym, i uint16)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddUint8" data-name="AddUint8">
               <h3>
                  AddUint8 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddUint8" class="anchor" title="Link to AddUint8">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) AddUint8(s dwarf.Sym, i uint8)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AlignmentPadding" data-name="AlignmentPadding">
               <h3>
                  AlignmentPadding 
                  <span class="badge">function</span>
                  
                  <a href="#AlignmentPadding" class="anchor" title="Link to AlignmentPadding">#</a>
               </h3>
               
               <p>AlignmentPadding bytes to add to align code as requested.
Alignment is restricted to powers of 2 between 8 and 2048 inclusive.
pc_: current offset in function, in bytes
p:  a PCALIGN or PCALIGNMAX prog
ctxt: the context, for current function
cursym: current function being assembled
returns number of bytes of padding needed,
updates minimum alignment for the function.</p>
               
               <pre><code class="language-go">func AlignmentPadding(pc int32, p *Prog, ctxt *Link, cursym *LSym) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AlignmentPaddingLength" data-name="AlignmentPaddingLength">
               <h3>
                  AlignmentPaddingLength 
                  <span class="badge">function</span>
                  
                  <a href="#AlignmentPaddingLength" class="anchor" title="Link to AlignmentPaddingLength">#</a>
               </h3>
               
               <p>AlignmentPaddingLength is the number of bytes to add to align code as requested.
Alignment is restricted to powers of 2 between 8 and 2048 inclusive.
This only computes the length and does not update the (missing parameter)
current function's own required alignment.
pc: current offset in function, in bytes
p:  a PCALIGN or PCALIGNMAX prog
ctxt: the context, for current function
returns number of bytes of padding needed,</p>
               
               <pre><code class="language-go">func AlignmentPaddingLength(pc int32, p *Prog, ctxt *Link) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AllParents" data-name="AllParents">
               <h3>
                  AllParents 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AllParents" class="anchor" title="Link to AllParents">#</a>
               </h3>
               
               <p>AllParents invokes do on each InlinedCall in the inlining call
stack, from outermost to innermost.
That is, if inlIndex corresponds to f inlining g inlining h,
AllParents invokes do with the call for inlining g into f, and then
inlining h into g.</p>
               
               <pre><code class="language-go">func (tree *InlTree) AllParents(inlIndex int, do func(InlinedCall))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AllPos" data-name="AllPos">
               <h3>
                  AllPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AllPos" class="anchor" title="Link to AllPos">#</a>
               </h3>
               
               <p>AllPos invokes do with every position in the inlining call stack for xpos,
from outermost to innermost. That is, xpos corresponds to f inlining g inlining h,
AllPos invokes do with the position in f, then the position in g, then the position in h.</p>
               
               <pre><code class="language-go">func (ctxt *Link) AllPos(xpos src.XPos, do func(src.Pos))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Appendp" data-name="Appendp">
               <h3>
                  Appendp 
                  <span class="badge">function</span>
                  
                  <a href="#Appendp" class="anchor" title="Link to Appendp">#</a>
               </h3>
               
               <pre><code class="language-go">func Appendp(q *Prog, newprog ProgAlloc) *Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Aux" data-name="Aux">
               <h3>
                  Aux 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Aux" class="anchor" title="Link to Aux">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *writer) Aux(s *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bool2int" data-name="Bool2int">
               <h3>
                  Bool2int 
                  <span class="badge">function</span>
                  
                  <a href="#Bool2int" class="anchor" title="Link to Bool2int">#</a>
               </h3>
               
               <pre><code class="language-go">func Bool2int(b bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CConv" data-name="CConv">
               <h3>
                  CConv 
                  <span class="badge">function</span>
                  
                  <a href="#CConv" class="anchor" title="Link to CConv">#</a>
               </h3>
               
               <p>CConv formats opcode suffix bits (Prog.Scond).</p>
               
               <pre><code class="language-go">func CConv(s uint8) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CConvARM" data-name="CConvARM">
               <h3>
                  CConvARM 
                  <span class="badge">function</span>
                  
                  <a href="#CConvARM" class="anchor" title="Link to CConvARM">#</a>
               </h3>
               
               <p>CConvARM formats ARM opcode suffix bits (mostly condition codes).</p>
               
               <pre><code class="language-go">func CConvARM(s uint8) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CFunc" data-name="CFunc">
               <h3>
                  CFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CFunc" class="anchor" title="Link to CFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) CFunc() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CallPos" data-name="CallPos">
               <h3>
                  CallPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CallPos" class="anchor" title="Link to CallPos">#</a>
               </h3>
               
               <pre><code class="language-go">func (tree *InlTree) CallPos(inlIndex int) src.XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanBeAnSSAAux" data-name="CanBeAnSSAAux">
               <h3>
                  CanBeAnSSAAux 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanBeAnSSAAux" class="anchor" title="Link to CanBeAnSSAAux">#</a>
               </h3>
               
               <pre><code class="language-go">func (*LSym) CanBeAnSSAAux()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanBeAnSSASym" data-name="CanBeAnSSASym">
               <h3>
                  CanBeAnSSASym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanBeAnSSASym" class="anchor" title="Link to CanBeAnSSASym">#</a>
               </h3>
               
               <p>The compiler needs *LSym to be assignable to cmd/compile/internal/ssa.Sym.</p>
               
               <pre><code class="language-go">func (*LSym) CanBeAnSSASym()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanReuseProgs" data-name="CanReuseProgs">
               <h3>
                  CanReuseProgs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanReuseProgs" class="anchor" title="Link to CanReuseProgs">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) CanReuseProgs() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ContentAddressable" data-name="ContentAddressable">
               <h3>
                  ContentAddressable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ContentAddressable" class="anchor" title="Link to ContentAddressable">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) ContentAddressable() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CreateAuxSym" data-name="CreateAuxSym">
               <h3>
                  CreateAuxSym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CreateAuxSym" class="anchor" title="Link to CreateAuxSym">#</a>
               </h3>
               
               <pre><code class="language-go">func (we *WasmExport) CreateAuxSym()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CreateAuxSym" data-name="CreateAuxSym">
               <h3>
                  CreateAuxSym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CreateAuxSym" class="anchor" title="Link to CreateAuxSym">#</a>
               </h3>
               
               <pre><code class="language-go">func (wi *WasmImport) CreateAuxSym()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CurrentOffset" data-name="CurrentOffset">
               <h3>
                  CurrentOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CurrentOffset" class="anchor" title="Link to CurrentOffset">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) CurrentOffset(s dwarf.Sym) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Dconv" data-name="Dconv">
               <h3>
                  Dconv 
                  <span class="badge">function</span>
                  
                  <a href="#Dconv" class="anchor" title="Link to Dconv">#</a>
               </h3>
               
               <p>Dconv accepts an argument 'a' within a prog 'p' and returns a string
with a formatted version of the argument.</p>
               
               <pre><code class="language-go">func Dconv(p *Prog, a *Addr) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DconvWithABIDetail" data-name="DconvWithABIDetail">
               <h3>
                  DconvWithABIDetail 
                  <span class="badge">function</span>
                  
                  <a href="#DconvWithABIDetail" class="anchor" title="Link to DconvWithABIDetail">#</a>
               </h3>
               
               <p>DconvWithABIDetail accepts an argument 'a' within a prog 'p'
and returns a string with a formatted version of the argument, in
which text symbols are rendered with explicit ABI selectors.</p>
               
               <pre><code class="language-go">func DconvWithABIDetail(p *Prog, a *Addr) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Diag" data-name="Diag">
               <h3>
                  Diag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Diag" class="anchor" title="Link to Diag">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) Diag(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DuplicateOK" data-name="DuplicateOK">
               <h3>
                  DuplicateOK 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DuplicateOK" class="anchor" title="Link to DuplicateOK">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) DuplicateOK() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DwarfAbstractFunc" data-name="DwarfAbstractFunc">
               <h3>
                  DwarfAbstractFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DwarfAbstractFunc" class="anchor" title="Link to DwarfAbstractFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) DwarfAbstractFunc(curfn Func, s *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DwarfGlobal" data-name="DwarfGlobal">
               <h3>
                  DwarfGlobal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DwarfGlobal" class="anchor" title="Link to DwarfGlobal">#</a>
               </h3>
               
               <p>DwarfGlobal creates a link symbol containing a DWARF entry for
a global variable.</p>
               
               <pre><code class="language-go">func (ctxt *Link) DwarfGlobal(typename string, varSym *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DwarfIntConst" data-name="DwarfIntConst">
               <h3>
                  DwarfIntConst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DwarfIntConst" class="anchor" title="Link to DwarfIntConst">#</a>
               </h3>
               
               <p>DwarfIntConst creates a link symbol for an integer constant with the
given name, type and value.</p>
               
               <pre><code class="language-go">func (ctxt *Link) DwarfIntConst(name string, typename string, val int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EmitEntryLiveness" data-name="EmitEntryLiveness">
               <h3>
                  EmitEntryLiveness 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EmitEntryLiveness" class="anchor" title="Link to EmitEntryLiveness">#</a>
               </h3>
               
               <p>EmitEntryLiveness generates PCDATA Progs after p to switch to the
liveness map active at the entry of function s. It returns the last
Prog generated.</p>
               
               <pre><code class="language-go">func (ctxt *Link) EmitEntryLiveness(s *LSym, p *Prog, newprog ProgAlloc) *Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EmitEntryStackMap" data-name="EmitEntryStackMap">
               <h3>
                  EmitEntryStackMap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EmitEntryStackMap" class="anchor" title="Link to EmitEntryStackMap">#</a>
               </h3>
               
               <p>Similar to EmitEntryLiveness, but just emit stack map.</p>
               
               <pre><code class="language-go">func (ctxt *Link) EmitEntryStackMap(s *LSym, p *Prog, newprog ProgAlloc) *Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EmitEntryUnsafePoint" data-name="EmitEntryUnsafePoint">
               <h3>
                  EmitEntryUnsafePoint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EmitEntryUnsafePoint" class="anchor" title="Link to EmitEntryUnsafePoint">#</a>
               </h3>
               
               <p>Similar to EmitEntryLiveness, but just emit unsafe point map.</p>
               
               <pre><code class="language-go">func (ctxt *Link) EmitEntryUnsafePoint(s *LSym, p *Prog, newprog ProgAlloc) *Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EnableFIPS" data-name="EnableFIPS">
               <h3>
                  EnableFIPS 
                  <span class="badge">function</span>
                  
                  <a href="#EnableFIPS" class="anchor" title="Link to EnableFIPS">#</a>
               </h3>
               
               <p>EnableFIPS reports whether FIPS should be enabled at all
on the current buildcfg GOOS and GOARCH.</p>
               
               <pre><code class="language-go">func EnableFIPS() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EndUnsafePoint" data-name="EndUnsafePoint">
               <h3>
                  EndUnsafePoint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EndUnsafePoint" class="anchor" title="Link to EndUnsafePoint">#</a>
               </h3>
               
               <p>EndUnsafePoint generates PCDATA Progs after p to mark the end of an
unsafe point, restoring the register map index to oldval.
The unsafe point ends right after p.
It returns the last Prog generated.</p>
               
               <pre><code class="language-go">func (ctxt *Link) EndUnsafePoint(p *Prog, newprog ProgAlloc, oldval int64) *Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="File" data-name="File">
               <h3>
                  File 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#File" class="anchor" title="Link to File">#</a>
               </h3>
               
               <p>File returns the *FileInfo associated with s, or else nil.</p>
               
               <pre><code class="language-go">func (s *LSym) File() *FileInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Finalize" data-name="Finalize">
               <h3>
                  Finalize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Finalize" class="anchor" title="Link to Finalize">#</a>
               </h3>
               
               <p>Called after all functions have been compiled; the main job of this
function is to identify cases where there are outstanding fixups.
This scenario crops up when we have references to variables of an
inlined routine, but that routine is defined in some other package.
This helper walks through and locate these fixups, then invokes a
helper to create an abstract subprogram DIE for each one.</p>
               
               <pre><code class="language-go">func (ft *DwarfFixupTable) Finalize(myimportpath string, trace bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Float32Sym" data-name="Float32Sym">
               <h3>
                  Float32Sym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Float32Sym" class="anchor" title="Link to Float32Sym">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) Float32Sym(f float32) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Float64Sym" data-name="Float64Sym">
               <h3>
                  Float64Sym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Float64Sym" class="anchor" title="Link to Float64Sym">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) Float64Sym(f float64) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flushplist" data-name="Flushplist">
               <h3>
                  Flushplist 
                  <span class="badge">function</span>
                  
                  <a href="#Flushplist" class="anchor" title="Link to Flushplist">#</a>
               </h3>
               
               <pre><code class="language-go">func Flushplist(ctxt *Link, plist *Plist, newprog ProgAlloc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="From3Type" data-name="From3Type">
               <h3>
                  From3Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#From3Type" class="anchor" title="Link to From3Type">#</a>
               </h3>
               
               <p>From3Type returns p.GetFrom3().Type, or TYPE_NONE when
p.GetFrom3() returns nil.</p>
               
               <pre><code class="language-go">func (p *Prog) From3Type() AddrType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Func" data-name="Func">
               <h3>
                  Func 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Func" class="anchor" title="Link to Func">#</a>
               </h3>
               
               <p>Func returns the *FuncInfo associated with s, or else nil.</p>
               
               <pre><code class="language-go">func (s *LSym) Func() *FuncInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GCLocalsSym" data-name="GCLocalsSym">
               <h3>
                  GCLocalsSym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GCLocalsSym" class="anchor" title="Link to GCLocalsSym">#</a>
               </h3>
               
               <p>GCLocalsSym generates a content-addressable sym containing data.</p>
               
               <pre><code class="language-go">func (ctxt *Link) GCLocalsSym(data []byte) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *ABISet) Get(abi ABI) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetFrom3" data-name="GetFrom3">
               <h3>
                  GetFrom3 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GetFrom3" class="anchor" title="Link to GetFrom3">#</a>
               </h3>
               
               <p>GetFrom3 returns second source operand (the first is Prog.From).
The same kinds of operands are saved in order so GetFrom3 actually
return the first source operand in p.RestArgs.
In combination with Prog.From and Prog.To it makes common 3 operand
case easier to use.</p>
               
               <pre><code class="language-go">func (p *Prog) GetFrom3() *Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetPrecursorFunc" data-name="GetPrecursorFunc">
               <h3>
                  GetPrecursorFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GetPrecursorFunc" class="anchor" title="Link to GetPrecursorFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func (ft *DwarfFixupTable) GetPrecursorFunc(s *LSym) Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetTo2" data-name="GetTo2">
               <h3>
                  GetTo2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GetTo2" class="anchor" title="Link to GetTo2">#</a>
               </h3>
               
               <p>GetTo2 returns the second destination operand.
The same kinds of operands are saved in order so GetTo2 actually
return the first destination operand in Prog.RestArgs[]</p>
               
               <pre><code class="language-go">func (p *Prog) GetTo2() *Addr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Globl" data-name="Globl">
               <h3>
                  Globl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Globl" class="anchor" title="Link to Globl">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) Globl(s *LSym, size int64, flag int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GloblPos" data-name="GloblPos">
               <h3>
                  GloblPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GloblPos" class="anchor" title="Link to GloblPos">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) GloblPos(s *LSym, size int64, flag int, pos src.XPos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Grow" data-name="Grow">
               <h3>
                  Grow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Grow" class="anchor" title="Link to Grow">#</a>
               </h3>
               
               <p>Grow increases the length of s.P to lsiz.</p>
               
               <pre><code class="language-go">func (s *LSym) Grow(lsiz int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GrowCap" data-name="GrowCap">
               <h3>
                  GrowCap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GrowCap" class="anchor" title="Link to GrowCap">#</a>
               </h3>
               
               <p>GrowCap increases the capacity of s.P to c.</p>
               
               <pre><code class="language-go">func (s *LSym) GrowCap(c int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Hash" data-name="Hash">
               <h3>
                  Hash 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Hash" class="anchor" title="Link to Hash">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *writer) Hash(s *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Hash64" data-name="Hash64">
               <h3>
                  Hash64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Hash64" class="anchor" title="Link to Hash64">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *writer) Hash64(s *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Indexed" data-name="Indexed">
               <h3>
                  Indexed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Indexed" class="anchor" title="Link to Indexed">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) Indexed() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Init" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Init" class="anchor" title="Link to Init">#</a>
               </h3>
               
               <p>init prepares it to iterate over p,
and advances it to the first pc.</p>
               
               <pre><code class="language-go">func (it *PCIter) Init(p []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitTextSym" data-name="InitTextSym">
               <h3>
                  InitTextSym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InitTextSym" class="anchor" title="Link to InitTextSym">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) InitTextSym(s *LSym, flag int, start src.XPos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InlinedFunction" data-name="InlinedFunction">
               <h3>
                  InlinedFunction 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InlinedFunction" class="anchor" title="Link to InlinedFunction">#</a>
               </h3>
               
               <pre><code class="language-go">func (tree *InlTree) InlinedFunction(inlIndex int) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InnermostFilename" data-name="InnermostFilename">
               <h3>
                  InnermostFilename 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InnermostFilename" class="anchor" title="Link to InnermostFilename">#</a>
               </h3>
               
               <p>InnermostFilename returns a string containing the innermost
(in inlining) filename at p's position</p>
               
               <pre><code class="language-go">func (p *Prog) InnermostFilename() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InnermostLine" data-name="InnermostLine">
               <h3>
                  InnermostLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InnermostLine" class="anchor" title="Link to InnermostLine">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Prog) InnermostLine(w io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InnermostLineNumber" data-name="InnermostLineNumber">
               <h3>
                  InnermostLineNumber 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InnermostLineNumber" class="anchor" title="Link to InnermostLineNumber">#</a>
               </h3>
               
               <p>InnermostLineNumber returns a string containing the line number for the
innermost inlined function (if any inlining) at p's position</p>
               
               <pre><code class="language-go">func (p *Prog) InnermostLineNumber() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InnermostLineNumberHTML" data-name="InnermostLineNumberHTML">
               <h3>
                  InnermostLineNumberHTML 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InnermostLineNumberHTML" class="anchor" title="Link to InnermostLineNumberHTML">#</a>
               </h3>
               
               <p>InnermostLineNumberHTML returns a string containing the line number for the
innermost inlined function (if any inlining) at p's position</p>
               
               <pre><code class="language-go">func (p *Prog) InnermostLineNumberHTML() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InnermostPos" data-name="InnermostPos">
               <h3>
                  InnermostPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InnermostPos" class="anchor" title="Link to InnermostPos">#</a>
               </h3>
               
               <p>InnermostPos returns the innermost position corresponding to xpos,
that is, the code that is inlined and that inlines nothing else.
In the example for InlTree above, the code for println within h
would have an innermost position with line number 12, whether
h was not inlined, inlined into g, g-then-f, or g-then-f-then-main.
This corresponds to what someone debugging main, f, g, or h might
expect to see while single-stepping.</p>
               
               <pre><code class="language-go">func (ctxt *Link) InnermostPos(xpos src.XPos) src.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InnermostString" data-name="InnermostString">
               <h3>
                  InnermostString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InnermostString" class="anchor" title="Link to InnermostString">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Prog) InnermostString(w io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InstructionString" data-name="InstructionString">
               <h3>
                  InstructionString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InstructionString" class="anchor" title="Link to InstructionString">#</a>
               </h3>
               
               <p>InstructionString returns a string representation of the instruction without preceding
program counter or file and line number.</p>
               
               <pre><code class="language-go">func (p *Prog) InstructionString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Int128Sym" data-name="Int128Sym">
               <h3>
                  Int128Sym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Int128Sym" class="anchor" title="Link to Int128Sym">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) Int128Sym(hi int64, lo int64) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Int32Sym" data-name="Int32Sym">
               <h3>
                  Int32Sym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Int32Sym" class="anchor" title="Link to Int32Sym">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) Int32Sym(i int64) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Int64Sym" data-name="Int64Sym">
               <h3>
                  Int64Sym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Int64Sym" class="anchor" title="Link to Int64Sym">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) Int64Sym(i int64) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsFIPS" data-name="IsFIPS">
               <h3>
                  IsFIPS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsFIPS" class="anchor" title="Link to IsFIPS">#</a>
               </h3>
               
               <p>IsFIPS reports whether we are compiling one of the crypto/internal/fips140/... packages.</p>
               
               <pre><code class="language-go">func (ctxt *Link) IsFIPS() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsLinkname" data-name="IsLinkname">
               <h3>
                  IsLinkname 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsLinkname" class="anchor" title="Link to IsLinkname">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) IsLinkname() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsPcdata" data-name="IsPcdata">
               <h3>
                  IsPcdata 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsPcdata" class="anchor" title="Link to IsPcdata">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) IsPcdata() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsPkgInit" data-name="IsPkgInit">
               <h3>
                  IsPkgInit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsPkgInit" class="anchor" title="Link to IsPkgInit">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) IsPkgInit() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Leaf" data-name="Leaf">
               <h3>
                  Leaf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Leaf" class="anchor" title="Link to Leaf">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) Leaf() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Line" data-name="Line">
               <h3>
                  Line 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Line" class="anchor" title="Link to Line">#</a>
               </h3>
               
               <p>Line returns a string containing the filename and line number for p</p>
               
               <pre><code class="language-go">func (p *Prog) Line() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Linknew" data-name="Linknew">
               <h3>
                  Linknew 
                  <span class="badge">function</span>
                  
                  <a href="#Linknew" class="anchor" title="Link to Linknew">#</a>
               </h3>
               
               <pre><code class="language-go">func Linknew(arch *LinkArch) *Link</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Local" data-name="Local">
               <h3>
                  Local 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Local" class="anchor" title="Link to Local">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) Local() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Logf" data-name="Logf">
               <h3>
                  Logf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Logf" class="anchor" title="Link to Logf">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) Logf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Logf" data-name="Logf">
               <h3>
                  Logf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Logf" class="anchor" title="Link to Logf">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) Logf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lookup" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lookup" class="anchor" title="Link to Lookup">#</a>
               </h3>
               
               <p>Lookup looks up the symbol with name name.
If it does not exist, it creates it.</p>
               
               <pre><code class="language-go">func (ctxt *Link) Lookup(name string) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupABI" data-name="LookupABI">
               <h3>
                  LookupABI 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LookupABI" class="anchor" title="Link to LookupABI">#</a>
               </h3>
               
               <p>LookupABI looks up a symbol with the given ABI.
If it does not exist, it creates it.</p>
               
               <pre><code class="language-go">func (ctxt *Link) LookupABI(name string, abi ABI) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupABIInit" data-name="LookupABIInit">
               <h3>
                  LookupABIInit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LookupABIInit" class="anchor" title="Link to LookupABIInit">#</a>
               </h3>
               
               <p>LookupABIInit looks up a symbol with the given ABI.
If it does not exist, it creates it and
passes it to init for one-time initialization.</p>
               
               <pre><code class="language-go">func (ctxt *Link) LookupABIInit(name string, abi ABI, init func(s *LSym)) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupDerived" data-name="LookupDerived">
               <h3>
                  LookupDerived 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LookupDerived" class="anchor" title="Link to LookupDerived">#</a>
               </h3>
               
               <p>LookupDerived looks up or creates the symbol with name derived from symbol s.
The resulting symbol will be static iff s is.</p>
               
               <pre><code class="language-go">func (ctxt *Link) LookupDerived(s *LSym, name string) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupInit" data-name="LookupInit">
               <h3>
                  LookupInit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LookupInit" class="anchor" title="Link to LookupInit">#</a>
               </h3>
               
               <p>LookupInit looks up the symbol with name name.
If it does not exist, it creates it and
passes it to init for one-time initialization.</p>
               
               <pre><code class="language-go">func (ctxt *Link) LookupInit(name string, init func(s *LSym)) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupStatic" data-name="LookupStatic">
               <h3>
                  LookupStatic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LookupStatic" class="anchor" title="Link to LookupStatic">#</a>
               </h3>
               
               <p>LookupStatic looks up the static symbol with name name.
If it does not exist, it creates it.</p>
               
               <pre><code class="language-go">func (ctxt *Link) LookupStatic(name string) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeTypelink" data-name="MakeTypelink">
               <h3>
                  MakeTypelink 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MakeTypelink" class="anchor" title="Link to MakeTypelink">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) MakeTypelink() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarkUnsafePoints" data-name="MarkUnsafePoints">
               <h3>
                  MarkUnsafePoints 
                  <span class="badge">function</span>
                  
                  <a href="#MarkUnsafePoints" class="anchor" title="Link to MarkUnsafePoints">#</a>
               </h3>
               
               <p>MarkUnsafePoints inserts PCDATAs to mark nonpreemptible and restartable
instruction sequences, based on isUnsafePoint and isRestartable predicate.
p0 is the start of the instruction stream.
isUnsafePoint(p) returns true if p is not safe for async preemption.
isRestartable(p) returns true if we can restart at the start of p (this Prog)
upon async preemption. (Currently multi-Prog restartable sequence is not
supported.)
isRestartable can be nil. In this case it is treated as always returning false.
If isUnsafePoint(p) and isRestartable(p) are both true, it is treated as
an unsafe point.</p>
               
               <pre><code class="language-go">func MarkUnsafePoints(ctxt *Link, p0 *Prog, newprog ProgAlloc, isUnsafePoint func(*Prog) bool, isRestartable func(*Prog) bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NeedCtxt" data-name="NeedCtxt">
               <h3>
                  NeedCtxt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NeedCtxt" class="anchor" title="Link to NeedCtxt">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) NeedCtxt() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewDwarfFixupTable" data-name="NewDwarfFixupTable">
               <h3>
                  NewDwarfFixupTable 
                  <span class="badge">function</span>
                  
                  <a href="#NewDwarfFixupTable" class="anchor" title="Link to NewDwarfFixupTable">#</a>
               </h3>
               
               <pre><code class="language-go">func NewDwarfFixupTable(ctxt *Link) *DwarfFixupTable</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewFileInfo" data-name="NewFileInfo">
               <h3>
                  NewFileInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NewFileInfo" class="anchor" title="Link to NewFileInfo">#</a>
               </h3>
               
               <p>NewFileInfo allocates and returns a FileInfo for LSym.</p>
               
               <pre><code class="language-go">func (s *LSym) NewFileInfo() *FileInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewFuncInfo" data-name="NewFuncInfo">
               <h3>
                  NewFuncInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NewFuncInfo" class="anchor" title="Link to NewFuncInfo">#</a>
               </h3>
               
               <p>NewFuncInfo allocates and returns a FuncInfo for LSym.</p>
               
               <pre><code class="language-go">func (s *LSym) NewFuncInfo() *FuncInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewPCIter" data-name="NewPCIter">
               <h3>
                  NewPCIter 
                  <span class="badge">function</span>
                  
                  <a href="#NewPCIter" class="anchor" title="Link to NewPCIter">#</a>
               </h3>
               
               <p>NewPCIter creates a PCIter with a scale factor for the PC step size.</p>
               
               <pre><code class="language-go">func NewPCIter(pcScale uint32) *PCIter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewProg" data-name="NewProg">
               <h3>
                  NewProg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NewProg" class="anchor" title="Link to NewProg">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) NewProg() *Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewTypeInfo" data-name="NewTypeInfo">
               <h3>
                  NewTypeInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NewTypeInfo" class="anchor" title="Link to NewTypeInfo">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *LSym) NewTypeInfo() *TypeInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewVarInfo" data-name="NewVarInfo">
               <h3>
                  NewVarInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NewVarInfo" class="anchor" title="Link to NewVarInfo">#</a>
               </h3>
               
               <p>NewVarInfo allocates and returns a VarInfo for LSym.</p>
               
               <pre><code class="language-go">func (s *LSym) NewVarInfo() *VarInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <p>Next advances it to the Next pc.</p>
               
               <pre><code class="language-go">func (it *PCIter) Next()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NoFrame" data-name="NoFrame">
               <h3>
                  NoFrame 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NoFrame" class="anchor" title="Link to NoFrame">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) NoFrame() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NoSplit" data-name="NoSplit">
               <h3>
                  NoSplit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NoSplit" class="anchor" title="Link to NoSplit">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) NoSplit() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Nopout" data-name="Nopout">
               <h3>
                  Nopout 
                  <span class="badge">function</span>
                  
                  <a href="#Nopout" class="anchor" title="Link to Nopout">#</a>
               </h3>
               
               <pre><code class="language-go">func Nopout(p *Prog)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumberSyms" data-name="NumberSyms">
               <h3>
                  NumberSyms 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumberSyms" class="anchor" title="Link to NumberSyms">#</a>
               </h3>
               
               <p>Assign index to symbols.
asm is set to true if this is called by the assembler (i.e. not the compiler),
in which case all the symbols are non-package (for now).</p>
               
               <pre><code class="language-go">func (ctxt *Link) NumberSyms()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OnList" data-name="OnList">
               <h3>
                  OnList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OnList" class="anchor" title="Link to OnList">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) OnList() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OutermostPos" data-name="OutermostPos">
               <h3>
                  OutermostPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OutermostPos" class="anchor" title="Link to OutermostPos">#</a>
               </h3>
               
               <p>OutermostPos returns the outermost position corresponding to xpos,
which is where xpos was ultimately inlined to. In the example for
InlTree, main() contains inlined AST nodes from h(), but the
outermost position for those nodes is line 2.</p>
               
               <pre><code class="language-go">func (ctxt *Link) OutermostPos(xpos src.XPos) src.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parent" data-name="Parent">
               <h3>
                  Parent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Parent" class="anchor" title="Link to Parent">#</a>
               </h3>
               
               <pre><code class="language-go">func (tree *InlTree) Parent(inlIndex int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseABI" data-name="ParseABI">
               <h3>
                  ParseABI 
                  <span class="badge">function</span>
                  
                  <a href="#ParseABI" class="anchor" title="Link to ParseABI">#</a>
               </h3>
               
               <p>ParseABI converts from a string representation in 'abistr' to the
corresponding ABI value. Second return value is TRUE if the
abi string is recognized, FALSE otherwise.</p>
               
               <pre><code class="language-go">func ParseABI(abistr string) (ABI, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PtrSize" data-name="PtrSize">
               <h3>
                  PtrSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PtrSize" class="anchor" title="Link to PtrSize">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) PtrSize() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RLconv" data-name="RLconv">
               <h3>
                  RLconv 
                  <span class="badge">function</span>
                  
                  <a href="#RLconv" class="anchor" title="Link to RLconv">#</a>
               </h3>
               
               <pre><code class="language-go">func RLconv(list int64) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Rconv" data-name="Rconv">
               <h3>
                  Rconv 
                  <span class="badge">function</span>
                  
                  <a href="#Rconv" class="anchor" title="Link to Rconv">#</a>
               </h3>
               
               <pre><code class="language-go">func Rconv(reg int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code class="language-go">func (ft *WasmFuncType) Read(b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code class="language-go">func (wi *WasmImport) Read(b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RecordAutoType" data-name="RecordAutoType">
               <h3>
                  RecordAutoType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RecordAutoType" class="anchor" title="Link to RecordAutoType">#</a>
               </h3>
               
               <p>Record the type symbol for an auto variable so that the linker
an emit DWARF type information for the type.</p>
               
               <pre><code class="language-go">func (fi *FuncInfo) RecordAutoType(gotype *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RecordChildDieOffsets" data-name="RecordChildDieOffsets">
               <h3>
                  RecordChildDieOffsets 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RecordChildDieOffsets" class="anchor" title="Link to RecordChildDieOffsets">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) RecordChildDieOffsets(s dwarf.Sym, vars []*dwarf.Var, offsets []int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RecordDclReference" data-name="RecordDclReference">
               <h3>
                  RecordDclReference 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RecordDclReference" class="anchor" title="Link to RecordDclReference">#</a>
               </h3>
               
               <p>Here "from" is a symbol corresponding to an inlined or concrete
function, "to" is the symbol for the corresponding abstract
function, and "dclIdx" is the index of the symbol of interest with
respect to the Dcl slice of the original pre-optimization version
of the inlined function.</p>
               
               <pre><code class="language-go">func (c dwCtxt) RecordDclReference(from dwarf.Sym, to dwarf.Sym, dclIdx int, inlIndex int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReferenceChildDIE" data-name="ReferenceChildDIE">
               <h3>
                  ReferenceChildDIE 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReferenceChildDIE" class="anchor" title="Link to ReferenceChildDIE">#</a>
               </h3>
               
               <p>Make a note of a child DIE reference: relocation 'ridx' within symbol 's'
is targeting child 'c' of DIE with symbol 'tgt'.</p>
               
               <pre><code class="language-go">func (ft *DwarfFixupTable) ReferenceChildDIE(s *LSym, ridx int, tgt *LSym, dclidx int, inlIndex int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReflectMethod" data-name="ReflectMethod">
               <h3>
                  ReflectMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReflectMethod" class="anchor" title="Link to ReflectMethod">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) ReflectMethod() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterChildDIEOffsets" data-name="RegisterChildDIEOffsets">
               <h3>
                  RegisterChildDIEOffsets 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RegisterChildDIEOffsets" class="anchor" title="Link to RegisterChildDIEOffsets">#</a>
               </h3>
               
               <p>Called once DWARF generation is complete for a given abstract function,
whose children might have been referenced via a call above. Stores
the offsets for any child DIEs (vars, params) so that they can be
consumed later in on DwarfFixupTable.Finalize, which applies any
outstanding fixups.</p>
               
               <pre><code class="language-go">func (ft *DwarfFixupTable) RegisterChildDIEOffsets(s *LSym, vars []*dwarf.Var, coffsets []int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterOpSuffix" data-name="RegisterOpSuffix">
               <h3>
                  RegisterOpSuffix 
                  <span class="badge">function</span>
                  
                  <a href="#RegisterOpSuffix" class="anchor" title="Link to RegisterOpSuffix">#</a>
               </h3>
               
               <p>RegisterOpSuffix assigns cconv function for formatting opcode suffixes
when compiling for GOARCH=arch.
cconv is never called with 0 argument.</p>
               
               <pre><code class="language-go">func RegisterOpSuffix(arch string, cconv func(uint8) string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterOpcode" data-name="RegisterOpcode">
               <h3>
                  RegisterOpcode 
                  <span class="badge">function</span>
                  
                  <a href="#RegisterOpcode" class="anchor" title="Link to RegisterOpcode">#</a>
               </h3>
               
               <p>RegisterOpcode binds a list of instruction names
to a given instruction number range.</p>
               
               <pre><code class="language-go">func RegisterOpcode(lo As, Anames []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterRegister" data-name="RegisterRegister">
               <h3>
                  RegisterRegister 
                  <span class="badge">function</span>
                  
                  <a href="#RegisterRegister" class="anchor" title="Link to RegisterRegister">#</a>
               </h3>
               
               <p>RegisterRegister binds a pretty-printer (Rconv) for register
numbers to a given register number range. Lo is inclusive,
hi exclusive (valid registers are lo through hi-1).</p>
               
               <pre><code class="language-go">func RegisterRegister(lo int, hi int, Rconv func(int) string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterRegisterList" data-name="RegisterRegisterList">
               <h3>
                  RegisterRegisterList 
                  <span class="badge">function</span>
                  
                  <a href="#RegisterRegisterList" class="anchor" title="Link to RegisterRegisterList">#</a>
               </h3>
               
               <p>RegisterRegisterList binds a pretty-printer (RLconv) for register list
numbers to a given register list number range. Lo is inclusive,
hi exclusive (valid register list are lo through hi-1).</p>
               
               <pre><code class="language-go">func RegisterRegisterList(lo int64, hi int64, rlconv func(int64) string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterSpecialOperands" data-name="RegisterSpecialOperands">
               <h3>
                  RegisterSpecialOperands 
                  <span class="badge">function</span>
                  
                  <a href="#RegisterSpecialOperands" class="anchor" title="Link to RegisterSpecialOperands">#</a>
               </h3>
               
               <p>RegisterSpecialOperands binds a pretty-printer (SPCconv) for special
operand numbers to a given special operand number range. Lo is inclusive,
hi is exclusive (valid special operands are lo through hi-1).</p>
               
               <pre><code class="language-go">func RegisterSpecialOperands(lo int64, hi int64, rlconv func(int64) string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reloc" data-name="Reloc">
               <h3>
                  Reloc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reloc" class="anchor" title="Link to Reloc">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *writer) Reloc(r *Reloc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SPCconv" data-name="SPCconv">
               <h3>
                  SPCconv 
                  <span class="badge">function</span>
                  
                  <a href="#SPCconv" class="anchor" title="Link to SPCconv">#</a>
               </h3>
               
               <p>SPCconv returns the string representation of the special operand spc.</p>
               
               <pre><code class="language-go">func SPCconv(spc int64) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) Set(flag Attribute, value bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *ABISet) Set(abi ABI, value bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetABI" data-name="SetABI">
               <h3>
                  SetABI 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetABI" class="anchor" title="Link to SetABI">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) SetABI(abi ABI)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetConst" data-name="SetConst">
               <h3>
                  SetConst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetConst" class="anchor" title="Link to SetConst">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Addr) SetConst(v int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetFIPSDebugHash" data-name="SetFIPSDebugHash">
               <h3>
                  SetFIPSDebugHash 
                  <span class="badge">function</span>
                  
                  <a href="#SetFIPSDebugHash" class="anchor" title="Link to SetFIPSDebugHash">#</a>
               </h3>
               
               <p>SetFIPSDebugHash sets the bisect pattern for debugging FIPS changes.
The compiler calls this with the pattern set by -d=fipshash=pattern,
so that if FIPS symbol type conversions are causing problems,
you can use 'bisect -compile fips go test strings' to identify exactly
which symbol is not being handled correctly.</p>
               
               <pre><code class="language-go">func SetFIPSDebugHash(pattern string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetPrecursorFunc" data-name="SetPrecursorFunc">
               <h3>
                  SetPrecursorFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetPrecursorFunc" class="anchor" title="Link to SetPrecursorFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func (ft *DwarfFixupTable) SetPrecursorFunc(s *LSym, fn Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetTarget" data-name="SetTarget">
               <h3>
                  SetTarget 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetTarget" class="anchor" title="Link to SetTarget">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Addr) SetTarget(t *Prog)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <pre><code class="language-go">func (c dwCtxt) Size(s dwarf.Sym) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SpillRegisterArgs" data-name="SpillRegisterArgs">
               <h3>
                  SpillRegisterArgs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SpillRegisterArgs" class="anchor" title="Link to SpillRegisterArgs">#</a>
               </h3>
               
               <p>SpillRegisterArgs emits the code to spill register args into whatever
locations the spill records specify.</p>
               
               <pre><code class="language-go">func (fi *FuncInfo) SpillRegisterArgs(last *Prog, pa ProgAlloc) *Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StartUnsafePoint" data-name="StartUnsafePoint">
               <h3>
                  StartUnsafePoint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StartUnsafePoint" class="anchor" title="Link to StartUnsafePoint">#</a>
               </h3>
               
               <p>StartUnsafePoint generates PCDATA Progs after p to mark the
beginning of an unsafe point. The unsafe point starts immediately
after p.
It returns the last Prog generated.</p>
               
               <pre><code class="language-go">func (ctxt *Link) StartUnsafePoint(p *Prog, newprog ProgAlloc) *Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Static" data-name="Static">
               <h3>
                  Static 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Static" class="anchor" title="Link to Static">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) Static() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String formats a for printing in as part of a TEXT prog.</p>
               
               <pre><code class="language-go">func (a Attribute) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i ABI) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i AddrType) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (a As) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *LSym) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (a ABISet) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Prog) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StringTable" data-name="StringTable">
               <h3>
                  StringTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StringTable" class="anchor" title="Link to StringTable">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *writer) StringTable()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sym" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sym" class="anchor" title="Link to Sym">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *writer) Sym(s *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Target" data-name="Target">
               <h3>
                  Target 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Target" class="anchor" title="Link to Target">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Addr) Target() *Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TextAttrString" data-name="TextAttrString">
               <h3>
                  TextAttrString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TextAttrString" class="anchor" title="Link to TextAttrString">#</a>
               </h3>
               
               <p>TextAttrString formats the symbol attributes for printing in as part of a TEXT prog.</p>
               
               <pre><code class="language-go">func (s *LSym) TextAttrString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnspillRegisterArgs" data-name="UnspillRegisterArgs">
               <h3>
                  UnspillRegisterArgs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnspillRegisterArgs" class="anchor" title="Link to UnspillRegisterArgs">#</a>
               </h3>
               
               <p>UnspillRegisterArgs emits the code to restore register args from whatever
locations the spill records specify.</p>
               
               <pre><code class="language-go">func (fi *FuncInfo) UnspillRegisterArgs(last *Prog, pa ProgAlloc) *Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UsedInIface" data-name="UsedInIface">
               <h3>
                  UsedInIface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UsedInIface" class="anchor" title="Link to UsedInIface">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) UsedInIface() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="VarInfo" data-name="VarInfo">
               <h3>
                  VarInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#VarInfo" class="anchor" title="Link to VarInfo">#</a>
               </h3>
               
               <p>VarInfo returns the *VarInfo associated with s, or else nil.</p>
               
               <pre><code class="language-go">func (s *LSym) VarInfo() *VarInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WasInlined" data-name="WasInlined">
               <h3>
                  WasInlined 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WasInlined" class="anchor" title="Link to WasInlined">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) WasInlined() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Wrapper" data-name="Wrapper">
               <h3>
                  Wrapper 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Wrapper" class="anchor" title="Link to Wrapper">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) Wrapper() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code class="language-go">func (wi *WasmImport) Write(w *bytes.Buffer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code class="language-go">func (ft *WasmFuncType) Write(w *bytes.Buffer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteAddr" data-name="WriteAddr">
               <h3>
                  WriteAddr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteAddr" class="anchor" title="Link to WriteAddr">#</a>
               </h3>
               
               <p>WriteAddr writes an address of size siz into s at offset off.
rsym and roff specify the relocation for the address.</p>
               
               <pre><code class="language-go">func (s *LSym) WriteAddr(ctxt *Link, off int64, siz int, rsym *LSym, roff int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteBytes" data-name="WriteBytes">
               <h3>
                  WriteBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteBytes" class="anchor" title="Link to WriteBytes">#</a>
               </h3>
               
               <p>WriteBytes writes a slice of bytes into s at offset off.</p>
               
               <pre><code class="language-go">func (s *LSym) WriteBytes(ctxt *Link, off int64, b []byte) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteCURelativeAddr" data-name="WriteCURelativeAddr">
               <h3>
                  WriteCURelativeAddr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteCURelativeAddr" class="anchor" title="Link to WriteCURelativeAddr">#</a>
               </h3>
               
               <p>WriteCURelativeAddr writes a pointer-sized address into s at offset off.
rsym and roff specify the relocation for the address which will be
resolved by the linker to an offset from the DW_AT_low_pc attribute of
the DWARF Compile Unit of rsym.</p>
               
               <pre><code class="language-go">func (s *LSym) WriteCURelativeAddr(ctxt *Link, off int64, rsym *LSym, roff int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteDconv" data-name="WriteDconv">
               <h3>
                  WriteDconv 
                  <span class="badge">function</span>
                  
                  <a href="#WriteDconv" class="anchor" title="Link to WriteDconv">#</a>
               </h3>
               
               <p>WriteDconv accepts an argument 'a' within a prog 'p'
and writes a formatted version of the arg to the writer.</p>
               
               <pre><code class="language-go">func WriteDconv(w io.Writer, p *Prog, a *Addr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteFloat32" data-name="WriteFloat32">
               <h3>
                  WriteFloat32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteFloat32" class="anchor" title="Link to WriteFloat32">#</a>
               </h3>
               
               <p>WriteFloat32 writes f into s at offset off.</p>
               
               <pre><code class="language-go">func (s *LSym) WriteFloat32(ctxt *Link, off int64, f float32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteFloat64" data-name="WriteFloat64">
               <h3>
                  WriteFloat64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteFloat64" class="anchor" title="Link to WriteFloat64">#</a>
               </h3>
               
               <p>WriteFloat64 writes f into s at offset off.</p>
               
               <pre><code class="language-go">func (s *LSym) WriteFloat64(ctxt *Link, off int64, f float64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteInstructionString" data-name="WriteInstructionString">
               <h3>
                  WriteInstructionString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteInstructionString" class="anchor" title="Link to WriteInstructionString">#</a>
               </h3>
               
               <p>WriteInstructionString writes a string representation of the instruction without preceding
program counter or file and line number.</p>
               
               <pre><code class="language-go">func (p *Prog) WriteInstructionString(w io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteInt" data-name="WriteInt">
               <h3>
                  WriteInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteInt" class="anchor" title="Link to WriteInt">#</a>
               </h3>
               
               <p>WriteInt writes an integer i of size siz into s at offset off.</p>
               
               <pre><code class="language-go">func (s *LSym) WriteInt(ctxt *Link, off int64, siz int, i int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteNameTo" data-name="WriteNameTo">
               <h3>
                  WriteNameTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteNameTo" class="anchor" title="Link to WriteNameTo">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Addr) WriteNameTo(w io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteObjFile" data-name="WriteObjFile">
               <h3>
                  WriteObjFile 
                  <span class="badge">function</span>
                  
                  <a href="#WriteObjFile" class="anchor" title="Link to WriteObjFile">#</a>
               </h3>
               
               <p>Entry point of writing new object file.</p>
               
               <pre><code class="language-go">func WriteObjFile(ctxt *Link, b *bio.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteOff" data-name="WriteOff">
               <h3>
                  WriteOff 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteOff" class="anchor" title="Link to WriteOff">#</a>
               </h3>
               
               <p>WriteOff writes a 4 byte offset to rsym+roff into s at offset off.
After linking the 4 bytes stored at s+off will be
rsym+roff-(start of section that s is in).</p>
               
               <pre><code class="language-go">func (s *LSym) WriteOff(ctxt *Link, off int64, rsym *LSym, roff int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteString" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteString" class="anchor" title="Link to WriteString">#</a>
               </h3>
               
               <p>WriteString writes a string of size siz into s at offset off.</p>
               
               <pre><code class="language-go">func (s *LSym) WriteString(ctxt *Link, off int64, siz int, str string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteWeakAddr" data-name="WriteWeakAddr">
               <h3>
                  WriteWeakAddr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteWeakAddr" class="anchor" title="Link to WriteWeakAddr">#</a>
               </h3>
               
               <p>WriteWeakAddr writes an address of size siz into s at offset off.
rsym and roff specify the relocation for the address.
This is a weak reference.</p>
               
               <pre><code class="language-go">func (s *LSym) WriteWeakAddr(ctxt *Link, off int64, siz int, rsym *LSym, roff int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteWeakOff" data-name="WriteWeakOff">
               <h3>
                  WriteWeakOff 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteWeakOff" class="anchor" title="Link to WriteWeakOff">#</a>
               </h3>
               
               <p>WriteWeakOff writes a weak 4 byte offset to rsym+roff into s at offset off.
After linking the 4 bytes stored at s+off will be
rsym+roff-(start of section that s is in).</p>
               
               <pre><code class="language-go">func (s *LSym) WriteWeakOff(ctxt *Link, off int64, rsym *LSym, roff int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">func _()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">func _()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abiDecorate" data-name="abiDecorate">
               <h3>
                  abiDecorate 
                  <span class="badge">function</span>
                  
                  <a href="#abiDecorate" class="anchor" title="Link to abiDecorate">#</a>
               </h3>
               
               <pre><code class="language-go">func abiDecorate(a *Addr, abiDetail bool) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addBranch" data-name="addBranch">
               <h3>
                  addBranch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addBranch" class="anchor" title="Link to addBranch">#</a>
               </h3>
               
               <p>addBranch adds a branch from the global inlining tree in ctxt to
the function's local inlining tree, returning the index in the local tree.</p>
               
               <pre><code class="language-go">func (s *pcinlineState) addBranch(ctxt *Link, globalIndex int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="aux1" data-name="aux1">
               <h3>
                  aux1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#aux1" class="anchor" title="Link to aux1">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *writer) aux1(typ uint8, rs *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="brloop" data-name="brloop">
               <h3>
                  brloop 
                  <span class="badge">function</span>
                  
                  <a href="#brloop" class="anchor" title="Link to brloop">#</a>
               </h3>
               
               <p>brloop returns the ultimate destination of the series of unconditional jumps beginning at p.
In the case of an infinite loop, brloop returns nil.</p>
               
               <pre><code class="language-go">func brloop(p *Prog) *Prog</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFIPSReloc" data-name="checkFIPSReloc">
               <h3>
                  checkFIPSReloc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkFIPSReloc" class="anchor" title="Link to checkFIPSReloc">#</a>
               </h3>
               
               <p>checkFIPSReloc should be called for every relocation applied to s.
It rejects absolute (non-PC-relative) address relocations when building
with go build -buildmode=pie (which triggers the compiler's -shared flag),
because those relocations will be applied before crypto/internal/fips140/check
can hash-verify the FIPS code+data, which will make the verification fail.</p>
               
               <pre><code class="language-go">func (s *LSym) checkFIPSReloc(ctxt *Link, rel Reloc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkaddr" data-name="checkaddr">
               <h3>
                  checkaddr 
                  <span class="badge">function</span>
                  
                  <a href="#checkaddr" class="anchor" title="Link to checkaddr">#</a>
               </h3>
               
               <p>checkaddr checks that a has an expected encoding, especially TYPE_CONST vs TYPE_ADDR.</p>
               
               <pre><code class="language-go">func checkaddr(ctxt *Link, p *Prog, a *Addr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="contentHash" data-name="contentHash">
               <h3>
                  contentHash 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#contentHash" class="anchor" title="Link to contentHash">#</a>
               </h3>
               
               <p>Compute the content hash for a content-addressable symbol.
We build a content hash based on its content and relocations.
Depending on the category of the referenced symbol, we choose
different hash algorithms such that the hash is globally
consistent.
- For referenced content-addressable symbol, its content hash
is globally consistent.
- For package symbol and builtin symbol, its local index is
globally consistent.
- For non-package symbol, its fully-expanded name is globally
consistent. For now, we require we know the current package
path so we can always expand symbol names. (Otherwise,
symbols with relocations are not considered hashable.)
For now, we assume there is no circular dependencies among
hashed symbols.</p>
               
               <pre><code class="language-go">func (w *writer) contentHash(s *LSym) goobj.HashType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="contentHash64" data-name="contentHash64">
               <h3>
                  contentHash64 
                  <span class="badge">function</span>
                  
                  <a href="#contentHash64" class="anchor" title="Link to contentHash64">#</a>
               </h3>
               
               <pre><code class="language-go">func contentHash64(s *LSym) goobj.Hash64Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="contentHashSection" data-name="contentHashSection">
               <h3>
                  contentHashSection 
                  <span class="badge">function</span>
                  
                  <a href="#contentHashSection" class="anchor" title="Link to contentHashSection">#</a>
               </h3>
               
               <p>contentHashSection returns a mnemonic for s's section.
The goal is to prevent content-addressability from moving symbols between sections.
contentHashSection only distinguishes between sets of sections for which this matters.
Allowing flexibility increases the effectiveness of content-addressability.
But in some cases, such as doing addressing based on a base symbol,
we need to ensure that a symbol is always in a particular section.
Some of these conditions are duplicated in cmd/link/internal/ld.(*Link).symtab.
TODO: instead of duplicating them, have the compiler decide where symbols go.</p>
               
               <pre><code class="language-go">func contentHashSection(s *LSym) byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="debugAsmEmit" data-name="debugAsmEmit">
               <h3>
                  debugAsmEmit 
                  <span class="badge">function</span>
                  
                  <a href="#debugAsmEmit" class="anchor" title="Link to debugAsmEmit">#</a>
               </h3>
               
               <pre><code class="language-go">func debugAsmEmit(ctxt *Link)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dumpInlTree" data-name="dumpInlTree">
               <h3>
                  dumpInlTree 
                  <span class="badge">function</span>
                  
                  <a href="#dumpInlTree" class="anchor" title="Link to dumpInlTree">#</a>
               </h3>
               
               <pre><code class="language-go">func dumpInlTree(ctxt *Link, tree InlTree)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dwarfSym" data-name="dwarfSym">
               <h3>
                  dwarfSym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dwarfSym" class="anchor" title="Link to dwarfSym">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) dwarfSym(s *LSym) (dwarfInfoSym *LSym, dwarfLocSym *LSym, dwarfRangesSym *LSym, dwarfAbsFnSym *LSym, dwarfDebugLines *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcpctab" data-name="funcpctab">
               <h3>
                  funcpctab 
                  <span class="badge">function</span>
                  
                  <a href="#funcpctab" class="anchor" title="Link to funcpctab">#</a>
               </h3>
               
               <p>funcpctab writes to dst a pc-value table mapping the code in func to the values
returned by valfunc parameterized by arg. The invocation of valfunc to update the
current value is, for each p,
sym = valfunc(func, p, 0, arg);
record sym.P as value at p->pc;
sym = valfunc(func, p, 1, arg);
where func is the function, val is the current value, p is the instruction being
considered, and arg can be used to further parameterize valfunc.</p>
               
               <pre><code class="language-go">func funcpctab(ctxt *Link, func_ *LSym, desc string, valfunc func(*Link, *LSym, int32, *Prog, int32, interface{}) int32, arg interface{}) *LSym</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="genFuncInfoSyms" data-name="genFuncInfoSyms">
               <h3>
                  genFuncInfoSyms 
                  <span class="badge">function</span>
                  
                  <a href="#genFuncInfoSyms" class="anchor" title="Link to genFuncInfoSyms">#</a>
               </h3>
               
               <p>generate symbols for FuncInfo.</p>
               
               <pre><code class="language-go">func genFuncInfoSyms(ctxt *Link)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="generateDebugLinesSymbol" data-name="generateDebugLinesSymbol">
               <h3>
                  generateDebugLinesSymbol 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#generateDebugLinesSymbol" class="anchor" title="Link to generateDebugLinesSymbol">#</a>
               </h3>
               
               <p>generateDebugLinesSymbol fills the debug lines symbol of a given function.
It's worth noting that this function doesn't generate the full debug_lines
DWARF section, saving that for the linker. This function just generates the
state machine part of debug_lines. The full table is generated by the
linker.  Also, we use the file numbers from the full package (not just the
function in question) when generating the state machine. We do this so we
don't have to do a fixup on the indices when writing the full section.</p>
               
               <pre><code class="language-go">func (ctxt *Link) generateDebugLinesSymbol(s *LSym, lines *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getFileIndexAndLine" data-name="getFileIndexAndLine">
               <h3>
                  getFileIndexAndLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getFileIndexAndLine" class="anchor" title="Link to getFileIndexAndLine">#</a>
               </h3>
               
               <p>getFileIndexAndLine returns the relative file index (local to the CU), and
the relative line number for a position (i.e., as adjusted by a //line
directive). This is the file/line visible in the final binary (pcfile, pcln,
etc).</p>
               
               <pre><code class="language-go">func (ctxt *Link) getFileIndexAndLine(xpos src.XPos) (int, int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <p>prepare package index list</p>
               
               <pre><code class="language-go">func (w *writer) init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDwarf64" data-name="isDwarf64">
               <h3>
                  isDwarf64 
                  <span class="badge">function</span>
                  
                  <a href="#isDwarf64" class="anchor" title="Link to isDwarf64">#</a>
               </h3>
               
               <pre><code class="language-go">func isDwarf64(ctxt *Link) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNonPkgSym" data-name="isNonPkgSym">
               <h3>
                  isNonPkgSym 
                  <span class="badge">function</span>
                  
                  <a href="#isNonPkgSym" class="anchor" title="Link to isNonPkgSym">#</a>
               </h3>
               
               <p>Returns whether s is a non-package symbol, which needs to be referenced
by name instead of by index.</p>
               
               <pre><code class="language-go">func isNonPkgSym(ctxt *Link, s *LSym) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linkpatch" data-name="linkpatch">
               <h3>
                  linkpatch 
                  <span class="badge">function</span>
                  
                  <a href="#linkpatch" class="anchor" title="Link to linkpatch">#</a>
               </h3>
               
               <pre><code class="language-go">func linkpatch(ctxt *Link, sym *LSym, newprog ProgAlloc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linkpcln" data-name="linkpcln">
               <h3>
                  linkpcln 
                  <span class="badge">function</span>
                  
                  <a href="#linkpcln" class="anchor" title="Link to linkpcln">#</a>
               </h3>
               
               <pre><code class="language-go">func linkpcln(ctxt *Link, cursym *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="load" data-name="load">
               <h3>
                  load 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#load" class="anchor" title="Link to load">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Attribute) load() Attribute</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeSymRef" data-name="makeSymRef">
               <h3>
                  makeSymRef 
                  <span class="badge">function</span>
                  
                  <a href="#makeSymRef" class="anchor" title="Link to makeSymRef">#</a>
               </h3>
               
               <pre><code class="language-go">func makeSymRef(s *LSym) goobj.SymRef</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mkfwd" data-name="mkfwd">
               <h3>
                  mkfwd 
                  <span class="badge">function</span>
                  
                  <a href="#mkfwd" class="anchor" title="Link to mkfwd">#</a>
               </h3>
               
               <pre><code class="language-go">func mkfwd(sym *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nAuxSym" data-name="nAuxSym">
               <h3>
                  nAuxSym 
                  <span class="badge">function</span>
                  
                  <a href="#nAuxSym" class="anchor" title="Link to nAuxSym">#</a>
               </h3>
               
               <p>return the number of aux symbols s have.</p>
               
               <pre><code class="language-go">func nAuxSym(s *LSym) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="offConv" data-name="offConv">
               <h3>
                  offConv 
                  <span class="badge">function</span>
                  
                  <a href="#offConv" class="anchor" title="Link to offConv">#</a>
               </h3>
               
               <pre><code class="language-go">func offConv(off int64) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pctofileline" data-name="pctofileline">
               <h3>
                  pctofileline 
                  <span class="badge">function</span>
                  
                  <a href="#pctofileline" class="anchor" title="Link to pctofileline">#</a>
               </h3>
               
               <p>pctofileline computes either the file number (arg == 0)
or the line number (arg == 1) to use at p.
Because p.Pos applies to p, phase == 0 (before p)
takes care of the update.</p>
               
               <pre><code class="language-go">func pctofileline(ctxt *Link, sym *LSym, oldval int32, p *Prog, phase int32, arg interface{}) int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pctoinline" data-name="pctoinline">
               <h3>
                  pctoinline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pctoinline" class="anchor" title="Link to pctoinline">#</a>
               </h3>
               
               <p>pctoinline computes the index into the local inlining tree to use at p.
If p is not the result of inlining, pctoinline returns -1. Because p.Pos
applies to p, phase == 0 (before p) takes care of the update.</p>
               
               <pre><code class="language-go">func (s *pcinlineState) pctoinline(ctxt *Link, sym *LSym, oldval int32, p *Prog, phase int32, arg interface{}) int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pctopcdata" data-name="pctopcdata">
               <h3>
                  pctopcdata 
                  <span class="badge">function</span>
                  
                  <a href="#pctopcdata" class="anchor" title="Link to pctopcdata">#</a>
               </h3>
               
               <p>pctopcdata computes the pcdata value in effect at p.
A PCDATA instruction sets the value in effect at future
non-PCDATA instructions.
Since PCDATA instructions have no width in the final code,
it does not matter which phase we use for the update.</p>
               
               <pre><code class="language-go">func pctopcdata(ctxt *Link, sym *LSym, oldval int32, p *Prog, phase int32, arg interface{}) int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pctospadj" data-name="pctospadj">
               <h3>
                  pctospadj 
                  <span class="badge">function</span>
                  
                  <a href="#pctospadj" class="anchor" title="Link to pctospadj">#</a>
               </h3>
               
               <p>pctospadj computes the sp adjustment in effect.
It is oldval plus any adjustment made by p itself.
The adjustment by p takes effect only after p, so we
apply the change during phase == 1.</p>
               
               <pre><code class="language-go">func pctospadj(ctxt *Link, sym *LSym, oldval int32, p *Prog, phase int32, arg interface{}) int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="populateDWARF" data-name="populateDWARF">
               <h3>
                  populateDWARF 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#populateDWARF" class="anchor" title="Link to populateDWARF">#</a>
               </h3>
               
               <p>populateDWARF fills in the DWARF Debugging Information Entries for
TEXT symbol 's'. The various DWARF symbols must already have been
initialized in InitTextSym.</p>
               
               <pre><code class="language-go">func (ctxt *Link) populateDWARF(curfn Func, s *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prepwrite" data-name="prepwrite">
               <h3>
                  prepwrite 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#prepwrite" class="anchor" title="Link to prepwrite">#</a>
               </h3>
               
               <p>prepwrite prepares to write data of size siz into s at offset off.</p>
               
               <pre><code class="language-go">func (s *LSym) prepwrite(ctxt *Link, off int64, siz int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="processFixups" data-name="processFixups">
               <h3>
                  processFixups 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#processFixups" class="anchor" title="Link to processFixups">#</a>
               </h3>
               
               <pre><code class="language-go">func (ft *DwarfFixupTable) processFixups(slot int, s *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putpclcdelta" data-name="putpclcdelta">
               <h3>
                  putpclcdelta 
                  <span class="badge">function</span>
                  
                  <a href="#putpclcdelta" class="anchor" title="Link to putpclcdelta">#</a>
               </h3>
               
               <pre><code class="language-go">func putpclcdelta(linkctxt *Link, dctxt dwCtxt, s *LSym, deltaPC uint64, deltaLC int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="refFlags" data-name="refFlags">
               <h3>
                  refFlags 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#refFlags" class="anchor" title="Link to refFlags">#</a>
               </h3>
               
               <p>Emits flags of referenced indexed symbols.</p>
               
               <pre><code class="language-go">func (w *writer) refFlags()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="refNames" data-name="refNames">
               <h3>
                  refNames 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#refNames" class="anchor" title="Link to refNames">#</a>
               </h3>
               
               <p>Emits names of referenced indexed symbols, used by tools (objdump, nm)
only.</p>
               
               <pre><code class="language-go">func (w *writer) refNames()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="relocByOffCmp" data-name="relocByOffCmp">
               <h3>
                  relocByOffCmp 
                  <span class="badge">function</span>
                  
                  <a href="#relocByOffCmp" class="anchor" title="Link to relocByOffCmp">#</a>
               </h3>
               
               <p>relocByOffCmp compare relocations by their offsets.</p>
               
               <pre><code class="language-go">func relocByOffCmp(x Reloc, y Reloc) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="requireAlignment" data-name="requireAlignment">
               <h3>
                  requireAlignment 
                  <span class="badge">function</span>
                  
                  <a href="#requireAlignment" class="anchor" title="Link to requireAlignment">#</a>
               </h3>
               
               <p>requireAlignment ensures that the function is aligned enough to support
the required code alignment</p>
               
               <pre><code class="language-go">func requireAlignment(a int64, ctxt *Link, cursym *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rodataKind" data-name="rodataKind">
               <h3>
                  rodataKind 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rodataKind" class="anchor" title="Link to rodataKind">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) rodataKind() (suffix string, typ objabi.SymKind)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setFIPSType" data-name="setFIPSType">
               <h3>
                  setFIPSType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setFIPSType" class="anchor" title="Link to setFIPSType">#</a>
               </h3>
               
               <p>setFIPSType should be called every time s.Type is set or changed.
It changes the type to one of the FIPS type (for example, STEXT -> STEXTFIPS) if appropriate.</p>
               
               <pre><code class="language-go">func (s *LSym) setFIPSType(ctxt *Link)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setParentPC" data-name="setParentPC">
               <h3>
                  setParentPC 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setParentPC" class="anchor" title="Link to setParentPC">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *pcinlineState) setParentPC(ctxt *Link, globalIndex int, pc int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setParentPC" data-name="setParentPC">
               <h3>
                  setParentPC 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setParentPC" class="anchor" title="Link to setParentPC">#</a>
               </h3>
               
               <pre><code class="language-go">func (tree *InlTree) setParentPC(inlIndex int, pc int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="textPos" data-name="textPos">
               <h3>
                  textPos 
                  <span class="badge">function</span>
                  
                  <a href="#textPos" class="anchor" title="Link to textPos">#</a>
               </h3>
               
               <p>textPos returns the source position of the first instruction (prog)
of the specified function.</p>
               
               <pre><code class="language-go">func textPos(fn *LSym) src.XPos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toFuncFlag" data-name="toFuncFlag">
               <h3>
                  toFuncFlag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#toFuncFlag" class="anchor" title="Link to toFuncFlag">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) toFuncFlag(flag int) abi.FuncFlag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="traverseAuxSyms" data-name="traverseAuxSyms">
               <h3>
                  traverseAuxSyms 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#traverseAuxSyms" class="anchor" title="Link to traverseAuxSyms">#</a>
               </h3>
               
               <p>Traverse aux symbols, calling fn for each sym/aux pair.</p>
               
               <pre><code class="language-go">func (ctxt *Link) traverseAuxSyms(flag traverseFlag, fn func(parent *LSym, aux *LSym))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="traverseFuncAux" data-name="traverseFuncAux">
               <h3>
                  traverseFuncAux 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#traverseFuncAux" class="anchor" title="Link to traverseFuncAux">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) traverseFuncAux(flag traverseFlag, fsym *LSym, fn func(parent *LSym, aux *LSym), files []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="traverseSyms" data-name="traverseSyms">
               <h3>
                  traverseSyms 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#traverseSyms" class="anchor" title="Link to traverseSyms">#</a>
               </h3>
               
               <p>Traverse symbols based on flag, call fn for each symbol.</p>
               
               <pre><code class="language-go">func (ctxt *Link) traverseSyms(flag traverseFlag, fn func(*LSym))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeAddr" data-name="writeAddr">
               <h3>
                  writeAddr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeAddr" class="anchor" title="Link to writeAddr">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *LSym) writeAddr(ctxt *Link, off int64, siz int, rsym *LSym, roff int64, rtype objabi.RelocType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeAuxSymDebug" data-name="writeAuxSymDebug">
               <h3>
                  writeAuxSymDebug 
                  <span class="badge">function</span>
                  
                  <a href="#writeAuxSymDebug" class="anchor" title="Link to writeAuxSymDebug">#</a>
               </h3>
               
               <pre><code class="language-go">func writeAuxSymDebug(ctxt *Link, par *LSym, aux *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeDconv" data-name="writeDconv">
               <h3>
                  writeDconv 
                  <span class="badge">function</span>
                  
                  <a href="#writeDconv" class="anchor" title="Link to writeDconv">#</a>
               </h3>
               
               <pre><code class="language-go">func writeDconv(w io.Writer, p *Prog, a *Addr, abiDetail bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeFile" data-name="writeFile">
               <h3>
                  writeFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeFile" class="anchor" title="Link to writeFile">#</a>
               </h3>
               
               <pre><code class="language-go">func (w *writer) writeFile(ctxt *Link, file *FileInfo)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeNameTo" data-name="writeNameTo">
               <h3>
                  writeNameTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeNameTo" class="anchor" title="Link to writeNameTo">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *Addr) writeNameTo(w io.Writer, abiDetail bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeSymDebug" data-name="writeSymDebug">
               <h3>
                  writeSymDebug 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeSymDebug" class="anchor" title="Link to writeSymDebug">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) writeSymDebug(s *LSym)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeSymDebugNamed" data-name="writeSymDebugNamed">
               <h3>
                  writeSymDebugNamed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeSymDebugNamed" class="anchor" title="Link to writeSymDebugNamed">#</a>
               </h3>
               
               <pre><code class="language-go">func (ctxt *Link) writeSymDebugNamed(s *LSym, name string)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>