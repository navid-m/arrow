<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - auth</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>auth</code>
         </h1>
         <hr />
         
         <article class="global" data-name="isTokenTable">
            <h2>isTokenTable</h2>
            <hr />
            
            <pre><code>isTokenTable</code></pre>
         </article>
         
         <article class="global" data-name="testNetrc">
            <h2>testNetrc</h2>
            <hr />
            
            <pre><code>testNetrc</code></pre>
         </article>
         
         <article class="global" data-name="credentialCache">
            <h2>credentialCache</h2>
            <hr />
            
            <pre><code>credentialCache sync.Map</code></pre>
         </article>
         
         <article class="global" data-name="authOnce">
            <h2>authOnce</h2>
            <hr />
            
            <pre><code>authOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="maxTries">
            <h2>maxTries</h2>
            <hr />
            
            <pre><code>maxTries</code></pre>
         </article>
         
         <article class="global" data-name="readNetrc">
            <h2>readNetrc</h2>
            <hr />
            
            <pre><code>readNetrc</code></pre>
         </article>
          
         <article class="struct" data-name="netrcLine">
            <h2>type netrcLine struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">machine string
login string
password string</code></pre>
         </article>
          
         <article class="function" data-name="TestCredentialCache">
            <h2>TestCredentialCache</h2>
            <hr />
            
            <pre><code>func TestCredentialCache(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCredentialCacheDelete">
            <h2>TestCredentialCacheDelete</h2>
            <hr />
            
            <pre><code>func TestCredentialCacheDelete(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="isLWS">
            <h2>isLWS</h2>
            <hr />
            
            <p>isLWS reports whether b is linear white space, according
to http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2

	LWS            = [CRLF] 1*( SP | HT )</p>
            
            <pre><code>func isLWS(b byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="isCTL">
            <h2>isCTL</h2>
            <hr />
            
            <p>isCTL reports whether b is a control byte, according
to http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2

	CTL            = <any US-ASCII control character
	                 (octets 0 - 31) and DEL (127)></p>
            
            <pre><code>func isCTL(b byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="validHeaderFieldName">
            <h2>validHeaderFieldName</h2>
            <hr />
            
            <p>validHeaderFieldName reports whether v is a valid HTTP/1.x header name.
HTTP/2 imposes the additional restriction that uppercase ASCII
letters are not allowed.

RFC 7230 says:

	header-field   = field-name ":" OWS field-value OWS
	field-name     = token
	token          = 1*tchar
	tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
	        "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA</p>
            
            <pre><code>func validHeaderFieldName(v string) bool</code></pre>
         </article>
         
         <article class="function" data-name="validHeaderFieldValue">
            <h2>validHeaderFieldValue</h2>
            <hr />
            
            <p>validHeaderFieldValue reports whether v is a valid "field-value" according to
http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 :

	message-header = field-name ":" [ field-value ]
	field-value    = *( field-content | LWS )
	field-content  = <the OCTETs making up the field-value
	                 and consisting of either *TEXT or combinations
	                 of token, separators, and quoted-string>

http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2 :

	TEXT           = <any OCTET except CTLs,
	                  but including LWS>
	LWS            = [CRLF] 1*( SP | HT )
	CTL            = <any US-ASCII control character
	                 (octets 0 - 31) and DEL (127)>

RFC 7230 says:

	field-value    = *( field-content / obs-fold )
	obj-fold       =  N/A to http2, and deprecated
	field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	field-vchar    = VCHAR / obs-text
	obs-text       = %x80-FF
	VCHAR          = "any visible [USASCII] character"

http2 further says: "Similarly, HTTP/2 allows header field values
that are not valid. While most of the values that can be encoded
will not alter header field parsing, carriage return (CR, ASCII
0xd), line feed (LF, ASCII 0xa), and the zero character (NUL, ASCII
0x0) might be exploited by an attacker if they are translated
verbatim. Any request or response that contains a character not
permitted in a header field value MUST be treated as malformed
(Section 8.1.2.6). Valid characters are defined by the
field-content ABNF rule in Section 3.2 of [RFC7230]."

This function does not (yet?) properly handle the rejection of
strings that begin or end with SP or HTAB.</p>
            
            <pre><code>func validHeaderFieldValue(v string) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestParseNetrc">
            <h2>TestParseNetrc</h2>
            <hr />
            
            <pre><code>func TestParseNetrc(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="runAuthCommand">
            <h2>runAuthCommand</h2>
            <hr />
            
            <p>runAuthCommand executes a user provided GOAUTH command, parses its output, and
returns a mapping of prefix → http.Header.
It uses the client to verify the credential and passes the status to the
command's stdin.
res is used for the GOAUTH command's stdin.</p>
            
            <pre><code>func runAuthCommand(command string, url string, res *http.Response) (*ast.MapType, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseUserAuth">
            <h2>parseUserAuth</h2>
            <hr />
            
            <p>parseUserAuth parses the output from a GOAUTH command and
returns a mapping of prefix → http.Header without the leading "https://"
or an error if the data does not follow the expected format.
Returns an nil error and an empty map if the data is empty.
See the expected format in 'go help goauth'.</p>
            
            <pre><code>func parseUserAuth(data string) (*ast.MapType, error)</code></pre>
         </article>
         
         <article class="function" data-name="mapHeadersToPrefixes">
            <h2>mapHeadersToPrefixes</h2>
            <hr />
            
            <p>mapHeadersToPrefixes returns a mapping of prefix → http.Header without
the leading "https://".</p>
            
            <pre><code>func mapHeadersToPrefixes(prefixes []string, header http.Header) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="buildCommand">
            <h2>buildCommand</h2>
            <hr />
            
            <pre><code>func buildCommand(command string) (*exec.Cmd, error)</code></pre>
         </article>
         
         <article class="function" data-name="writeResponseToStdin">
            <h2>writeResponseToStdin</h2>
            <hr />
            
            <p>writeResponseToStdin writes the HTTP response to the command's stdin.</p>
            
            <pre><code>func writeResponseToStdin(cmd *exec.Cmd, res *http.Response) error</code></pre>
         </article>
         
         <article class="function" data-name="AddCredentials">
            <h2>AddCredentials</h2>
            <hr />
            
            <p>AddCredentials populates the request header with the user's credentials
as specified by the GOAUTH environment variable.
It returns whether any matching credentials were found.
req must use HTTPS or this function will panic.
res is used for the custom GOAUTH command's stdin.</p>
            
            <pre><code>func AddCredentials(client *http.Client, req *http.Request, res *http.Response, url string) bool</code></pre>
         </article>
         
         <article class="function" data-name="runGoAuth">
            <h2>runGoAuth</h2>
            <hr />
            
            <p>runGoAuth executes authentication commands specified by the GOAUTH
environment variable handling 'off', 'netrc', and 'git' methods specially,
and storing retrieved credentials for future access.</p>
            
            <pre><code>func runGoAuth(client *http.Client, res *http.Response, url string)</code></pre>
         </article>
         
         <article class="function" data-name="loadCredential">
            <h2>loadCredential</h2>
            <hr />
            
            <p>loadCredential retrieves cached credentials for the given url and adds
them to the request headers.</p>
            
            <pre><code>func loadCredential(req *http.Request, url string) bool</code></pre>
         </article>
         
         <article class="function" data-name="storeCredential">
            <h2>storeCredential</h2>
            <hr />
            
            <p>storeCredential caches or removes credentials (represented by HTTP headers)
associated with given URL prefixes.</p>
            
            <pre><code>func storeCredential(prefix string, header http.Header)</code></pre>
         </article>
         
         <article class="function" data-name="runGitAuth">
            <h2>runGitAuth</h2>
            <hr />
            
            <p>runGitAuth retrieves credentials for the given url using
'git credential fill', validates them with a HEAD request
(using the provided client) and updates the credential helper's cache.
It returns the matching credential prefix, the http.Header with the
Basic Authentication header set, or an error.
The caller must not mutate the header.</p>
            
            <pre><code>func runGitAuth(client *http.Client, dir string, url string) (string, http.Header, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseGitAuth">
            <h2>parseGitAuth</h2>
            <hr />
            
            <p>parseGitAuth parses the output of 'git credential fill', extracting
the URL prefix, user, and password.
Any of these values may be empty if parsing fails.</p>
            
            <pre><code>func parseGitAuth(data []byte) (parsedPrefix string, username string, password string)</code></pre>
         </article>
         
         <article class="function" data-name="updateGitCredentialHelper">
            <h2>updateGitCredentialHelper</h2>
            <hr />
            
            <p>updateGitCredentialHelper validates the given credentials by sending a HEAD request
and updates the git credential helper's cache accordingly. It retries the
request up to maxTries times.</p>
            
            <pre><code>func updateGitCredentialHelper(client *http.Client, req *http.Request, credentialOutput []byte)</code></pre>
         </article>
         
         <article class="function" data-name="approveOrRejectCredential">
            <h2>approveOrRejectCredential</h2>
            <hr />
            
            <p>approveOrRejectCredential approves or rejects the provided credential using
'git credential approve/reject'.</p>
            
            <pre><code>func approveOrRejectCredential(credentialOutput []byte, approve bool)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseGitAuth">
            <h2>TestParseGitAuth</h2>
            <hr />
            
            <pre><code>func TestParseGitAuth(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="parseNetrc">
            <h2>parseNetrc</h2>
            <hr />
            
            <pre><code>func parseNetrc(data string) []netrcLine</code></pre>
         </article>
         
         <article class="function" data-name="netrcPath">
            <h2>netrcPath</h2>
            <hr />
            
            <pre><code>func netrcPath() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseUserAuth">
            <h2>TestParseUserAuth</h2>
            <hr />
            
            <pre><code>func TestParseUserAuth(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseUserAuthInvalid">
            <h2>TestParseUserAuthInvalid</h2>
            <hr />
            
            <pre><code>func TestParseUserAuthInvalid(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseUserAuthDuplicated">
            <h2>TestParseUserAuthDuplicated</h2>
            <hr />
            
            <pre><code>func TestParseUserAuthDuplicated(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseUserAuthEmptyHeader">
            <h2>TestParseUserAuthEmptyHeader</h2>
            <hr />
            
            <pre><code>func TestParseUserAuthEmptyHeader(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseUserAuthEmpty">
            <h2>TestParseUserAuthEmpty</h2>
            <hr />
            
            <pre><code>func TestParseUserAuthEmpty(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
