<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - auth</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>auth</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"cmd/go/internal/base"
"cmd/go/internal/cfg"
"fmt"
"log"
"net/http"
"os"
"path/filepath"
"slices"
"strings"
"sync"
"bytes"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/web/intercept"
"fmt"
"log"
"net/http"
"net/url"
"os/exec"
"strings"
"os"
"path/filepath"
"runtime"
"strings"
"sync"
"cmd/internal/quoted"
"fmt"
"maps"
"net/http"
"net/url"
"os/exec"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="authOnce" data-name="authOnce">
               <h3>
                  authOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#authOnce" class="anchor" title="Link to authOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var authOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="credentialCache" data-name="credentialCache">
               <h3>
                  credentialCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#credentialCache" class="anchor" title="Link to credentialCache">#</a>
               </h3>
               
               <pre><code class="language-go">var credentialCache sync.Map</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="isTokenTable" data-name="isTokenTable">
               <h3>
                  isTokenTable 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#isTokenTable" class="anchor" title="Link to isTokenTable">#</a>
               </h3>
               
               <pre><code class="language-go">var isTokenTable = [256]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxTries" data-name="maxTries">
               <h3>
                  maxTries 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxTries" class="anchor" title="Link to maxTries">#</a>
               </h3>
               
               <pre><code class="language-go">const maxTries = 3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="readNetrc" data-name="readNetrc">
               <h3>
                  readNetrc 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#readNetrc" class="anchor" title="Link to readNetrc">#</a>
               </h3>
               
               <pre><code class="language-go">var readNetrc = *ast.CallExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="netrcLine" data-name="netrcLine">
               <h3>
                  netrcLine
                  <span class="badge">struct</span>
                  <a href="#netrcLine" class="anchor" title="Link to netrcLine">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type netrcLine struct {
machine string
login string
password string
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AddCredentials" data-name="AddCredentials">
               <h3>
                  AddCredentials 
                  <span class="badge">function</span>
                  
                  <a href="#AddCredentials" class="anchor" title="Link to AddCredentials">#</a>
               </h3>
               
               <p>AddCredentials populates the request header with the user's credentials
as specified by the GOAUTH environment variable.
It returns whether any matching credentials were found.
req must use HTTPS or this function will panic.
res is used for the custom GOAUTH command's stdin.</p>
               
               <pre><code class="language-go">func AddCredentials(client *http.Client, req *http.Request, res *http.Response, url string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="approveOrRejectCredential" data-name="approveOrRejectCredential">
               <h3>
                  approveOrRejectCredential 
                  <span class="badge">function</span>
                  
                  <a href="#approveOrRejectCredential" class="anchor" title="Link to approveOrRejectCredential">#</a>
               </h3>
               
               <p>approveOrRejectCredential approves or rejects the provided credential using
'git credential approve/reject'.</p>
               
               <pre><code class="language-go">func approveOrRejectCredential(credentialOutput []byte, approve bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="buildCommand" data-name="buildCommand">
               <h3>
                  buildCommand 
                  <span class="badge">function</span>
                  
                  <a href="#buildCommand" class="anchor" title="Link to buildCommand">#</a>
               </h3>
               
               <pre><code class="language-go">func buildCommand(command string) (*exec.Cmd, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isCTL" data-name="isCTL">
               <h3>
                  isCTL 
                  <span class="badge">function</span>
                  
                  <a href="#isCTL" class="anchor" title="Link to isCTL">#</a>
               </h3>
               
               <p>isCTL reports whether b is a control byte, according
to http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2
CTL            = <any US-ASCII control character
(octets 0 - 31) and DEL (127)></p>
               
               <pre><code class="language-go">func isCTL(b byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isLWS" data-name="isLWS">
               <h3>
                  isLWS 
                  <span class="badge">function</span>
                  
                  <a href="#isLWS" class="anchor" title="Link to isLWS">#</a>
               </h3>
               
               <p>isLWS reports whether b is linear white space, according
to http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2
LWS            = [CRLF] 1*( SP | HT )</p>
               
               <pre><code class="language-go">func isLWS(b byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadCredential" data-name="loadCredential">
               <h3>
                  loadCredential 
                  <span class="badge">function</span>
                  
                  <a href="#loadCredential" class="anchor" title="Link to loadCredential">#</a>
               </h3>
               
               <p>loadCredential retrieves cached credentials for the given url and adds
them to the request headers.</p>
               
               <pre><code class="language-go">func loadCredential(req *http.Request, url string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapHeadersToPrefixes" data-name="mapHeadersToPrefixes">
               <h3>
                  mapHeadersToPrefixes 
                  <span class="badge">function</span>
                  
                  <a href="#mapHeadersToPrefixes" class="anchor" title="Link to mapHeadersToPrefixes">#</a>
               </h3>
               
               <p>mapHeadersToPrefixes returns a mapping of prefix → http.Header without
the leading "https://".</p>
               
               <pre><code class="language-go">func mapHeadersToPrefixes(prefixes []string, header http.Header) map[string]http.Header</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="netrcPath" data-name="netrcPath">
               <h3>
                  netrcPath 
                  <span class="badge">function</span>
                  
                  <a href="#netrcPath" class="anchor" title="Link to netrcPath">#</a>
               </h3>
               
               <pre><code class="language-go">func netrcPath() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseGitAuth" data-name="parseGitAuth">
               <h3>
                  parseGitAuth 
                  <span class="badge">function</span>
                  
                  <a href="#parseGitAuth" class="anchor" title="Link to parseGitAuth">#</a>
               </h3>
               
               <p>parseGitAuth parses the output of 'git credential fill', extracting
the URL prefix, user, and password.
Any of these values may be empty if parsing fails.</p>
               
               <pre><code class="language-go">func parseGitAuth(data []byte) (parsedPrefix string, username string, password string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseNetrc" data-name="parseNetrc">
               <h3>
                  parseNetrc 
                  <span class="badge">function</span>
                  
                  <a href="#parseNetrc" class="anchor" title="Link to parseNetrc">#</a>
               </h3>
               
               <pre><code class="language-go">func parseNetrc(data string) []netrcLine</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseUserAuth" data-name="parseUserAuth">
               <h3>
                  parseUserAuth 
                  <span class="badge">function</span>
                  
                  <a href="#parseUserAuth" class="anchor" title="Link to parseUserAuth">#</a>
               </h3>
               
               <p>parseUserAuth parses the output from a GOAUTH command and
returns a mapping of prefix → http.Header without the leading "https://"
or an error if the data does not follow the expected format.
Returns an nil error and an empty map if the data is empty.
See the expected format in 'go help goauth'.</p>
               
               <pre><code class="language-go">func parseUserAuth(data string) (map[string]http.Header, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runAuthCommand" data-name="runAuthCommand">
               <h3>
                  runAuthCommand 
                  <span class="badge">function</span>
                  
                  <a href="#runAuthCommand" class="anchor" title="Link to runAuthCommand">#</a>
               </h3>
               
               <p>runAuthCommand executes a user provided GOAUTH command, parses its output, and
returns a mapping of prefix → http.Header.
It uses the client to verify the credential and passes the status to the
command's stdin.
res is used for the GOAUTH command's stdin.</p>
               
               <pre><code class="language-go">func runAuthCommand(command string, url string, res *http.Response) (map[string]http.Header, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runGitAuth" data-name="runGitAuth">
               <h3>
                  runGitAuth 
                  <span class="badge">function</span>
                  
                  <a href="#runGitAuth" class="anchor" title="Link to runGitAuth">#</a>
               </h3>
               
               <p>runGitAuth retrieves credentials for the given url using
'git credential fill', validates them with a HEAD request
(using the provided client) and updates the credential helper's cache.
It returns the matching credential prefix, the http.Header with the
Basic Authentication header set, or an error.
The caller must not mutate the header.</p>
               
               <pre><code class="language-go">func runGitAuth(client *http.Client, dir string, url string) (string, http.Header, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runGoAuth" data-name="runGoAuth">
               <h3>
                  runGoAuth 
                  <span class="badge">function</span>
                  
                  <a href="#runGoAuth" class="anchor" title="Link to runGoAuth">#</a>
               </h3>
               
               <p>runGoAuth executes authentication commands specified by the GOAUTH
environment variable handling 'off', 'netrc', and 'git' methods specially,
and storing retrieved credentials for future access.</p>
               
               <pre><code class="language-go">func runGoAuth(client *http.Client, res *http.Response, url string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="storeCredential" data-name="storeCredential">
               <h3>
                  storeCredential 
                  <span class="badge">function</span>
                  
                  <a href="#storeCredential" class="anchor" title="Link to storeCredential">#</a>
               </h3>
               
               <p>storeCredential caches or removes credentials (represented by HTTP headers)
associated with given URL prefixes.</p>
               
               <pre><code class="language-go">func storeCredential(prefix string, header http.Header)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateGitCredentialHelper" data-name="updateGitCredentialHelper">
               <h3>
                  updateGitCredentialHelper 
                  <span class="badge">function</span>
                  
                  <a href="#updateGitCredentialHelper" class="anchor" title="Link to updateGitCredentialHelper">#</a>
               </h3>
               
               <p>updateGitCredentialHelper validates the given credentials by sending a HEAD request
and updates the git credential helper's cache accordingly. It retries the
request up to maxTries times.</p>
               
               <pre><code class="language-go">func updateGitCredentialHelper(client *http.Client, req *http.Request, credentialOutput []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validHeaderFieldName" data-name="validHeaderFieldName">
               <h3>
                  validHeaderFieldName 
                  <span class="badge">function</span>
                  
                  <a href="#validHeaderFieldName" class="anchor" title="Link to validHeaderFieldName">#</a>
               </h3>
               
               <p>validHeaderFieldName reports whether v is a valid HTTP/1.x header name.
HTTP/2 imposes the additional restriction that uppercase ASCII
letters are not allowed.
RFC 7230 says:
header-field   = field-name ":" OWS field-value OWS
field-name     = token
token          = 1*tchar
tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." /
"^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA</p>
               
               <pre><code class="language-go">func validHeaderFieldName(v string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validHeaderFieldValue" data-name="validHeaderFieldValue">
               <h3>
                  validHeaderFieldValue 
                  <span class="badge">function</span>
                  
                  <a href="#validHeaderFieldValue" class="anchor" title="Link to validHeaderFieldValue">#</a>
               </h3>
               
               <p>validHeaderFieldValue reports whether v is a valid "field-value" according to
http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2 :
message-header = field-name ":" [ field-value ]
field-value    = *( field-content | LWS )
field-content  = <the OCTETs making up the field-value
and consisting of either *TEXT or combinations
of token, separators, and quoted-string>
http://www.w3.org/Protocols/rfc2616/rfc2616-sec2.html#sec2.2 :
TEXT           = <any OCTET except CTLs,
but including LWS>
LWS            = [CRLF] 1*( SP | HT )
CTL            = <any US-ASCII control character
(octets 0 - 31) and DEL (127)>
RFC 7230 says:
field-value    = *( field-content / obs-fold )
obj-fold       =  N/A to http2, and deprecated
field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
field-vchar    = VCHAR / obs-text
obs-text       = %x80-FF
VCHAR          = "any visible [USASCII] character"
http2 further says: "Similarly, HTTP/2 allows header field values
that are not valid. While most of the values that can be encoded
will not alter header field parsing, carriage return (CR, ASCII
0xd), line feed (LF, ASCII 0xa), and the zero character (NUL, ASCII
0x0) might be exploited by an attacker if they are translated
verbatim. Any request or response that contains a character not
permitted in a header field value MUST be treated as malformed
(Section 8.1.2.6). Valid characters are defined by the
field-content ABNF rule in Section 3.2 of [RFC7230]."
This function does not (yet?) properly handle the rejection of
strings that begin or end with SP or HTAB.</p>
               
               <pre><code class="language-go">func validHeaderFieldValue(v string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeResponseToStdin" data-name="writeResponseToStdin">
               <h3>
                  writeResponseToStdin 
                  <span class="badge">function</span>
                  
                  <a href="#writeResponseToStdin" class="anchor" title="Link to writeResponseToStdin">#</a>
               </h3>
               
               <p>writeResponseToStdin writes the HTTP response to the command's stdin.</p>
               
               <pre><code class="language-go">func writeResponseToStdin(cmd *exec.Cmd, res *http.Response) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>