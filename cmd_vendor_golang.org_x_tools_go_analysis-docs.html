<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - analysis</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="cmd_vendor_golang.org_x_tools_go_analysis_unitchecker-docs.html">unitchecker</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
                 
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>analysis</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"flag"
"fmt"
"go/ast"
"go/token"
"go/types"
"reflect"
"go/token"
"fmt"
"reflect"
"strings"
"unicode"
</code></pre>
            </article>
         </section>
            
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Fact" data-name="Fact">
               <h3>
                  Fact
                  <span class="badge interface-badge">interface</span>
                  <a href="#Fact" class="anchor" title="Link to Fact">#</a>
               </h3>
               
               <p>A Fact is an intermediate fact produced during analysis.
Each fact is associated with a named declaration (a types.Object) or
with a package as a whole. A single object or package may have
multiple associated facts, but only one of any particular fact type.
A Fact represents a predicate such as "never returns", but does not
represent the subject of the predicate such as "function F" or "package P".
Facts may be produced in one analysis pass and consumed by another
analysis pass even if these are in different address spaces.
If package P imports Q, all facts about Q produced during
analysis of that package will be available during later analysis of P.
Facts are analogous to type export data in a build system:
just as export data enables separate compilation of several passes,
facts enable "separate analysis".
Each pass (a, p) starts with the set of facts produced by the
same analyzer a applied to the packages directly imported by p.
The analysis may add facts to the set, and they may be exported in turn.
An analysis's Run function may retrieve facts by calling
Pass.Import{Object,Package}Fact and update them using
Pass.Export{Object,Package}Fact.
A fact is logically private to its Analysis. To pass values
between different analyzers, use the results mechanism;
see Analyzer.Requires, Analyzer.ResultType, and Pass.ResultOf.
A Fact type must be a pointer.
Facts are encoded and decoded using encoding/gob.
A Fact may implement the GobEncoder/GobDecoder interfaces
to customize its encoding. Fact encoding should not fail.
A Fact should not be modified once exported.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Fact interface {
AFact()
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Range" data-name="Range">
               <h3>
                  Range
                  <span class="badge interface-badge">interface</span>
                  <a href="#Range" class="anchor" title="Link to Range">#</a>
               </h3>
               
               <p>The Range interface provides a range. It's equivalent to and satisfied by
ast.Node.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Range interface {
Pos() token.Pos
End() token.Pos
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Analyzer" data-name="Analyzer">
               <h3>
                  Analyzer
                  <span class="badge">struct</span>
                  <a href="#Analyzer" class="anchor" title="Link to Analyzer">#</a>
               </h3>
               
               <p>An Analyzer describes an analysis function and its options.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Analyzer struct {
Name string
Doc string
URL string
Flags flag.FlagSet
Run func(*Pass) (interface{}, error)
RunDespiteErrors bool
Requires []*Analyzer
ResultType reflect.Type
FactTypes []Fact
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="CycleInRequiresGraphError" data-name="CycleInRequiresGraphError">
               <h3>
                  CycleInRequiresGraphError
                  <span class="badge">struct</span>
                  <a href="#CycleInRequiresGraphError" class="anchor" title="Link to CycleInRequiresGraphError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CycleInRequiresGraphError struct {
AnalyzerNames map[string]bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Diagnostic" data-name="Diagnostic">
               <h3>
                  Diagnostic
                  <span class="badge">struct</span>
                  <a href="#Diagnostic" class="anchor" title="Link to Diagnostic">#</a>
               </h3>
               
               <p>A Diagnostic is a message associated with a source location or range.
An Analyzer may return a variety of diagnostics; the optional Category,
which should be a constant, may be used to classify them.
It is primarily intended to make it easy to look up documentation.
All Pos values are interpreted relative to Pass.Fset. If End is
provided, the diagnostic is specified to apply to the range between
Pos and End.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Diagnostic struct {
Pos token.Pos
End token.Pos
Category string
Message string
URL string
SuggestedFixes []SuggestedFix
Related []RelatedInformation
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Module" data-name="Module">
               <h3>
                  Module
                  <span class="badge">struct</span>
                  <a href="#Module" class="anchor" title="Link to Module">#</a>
               </h3>
               
               <p>A Module describes the module to which a package belongs.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Module struct {
Path string
Version string
GoVersion string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ObjectFact" data-name="ObjectFact">
               <h3>
                  ObjectFact
                  <span class="badge">struct</span>
                  <a href="#ObjectFact" class="anchor" title="Link to ObjectFact">#</a>
               </h3>
               
               <p>ObjectFact is an object together with an associated fact.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ObjectFact struct {
Object types.Object
Fact Fact
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PackageFact" data-name="PackageFact">
               <h3>
                  PackageFact
                  <span class="badge">struct</span>
                  <a href="#PackageFact" class="anchor" title="Link to PackageFact">#</a>
               </h3>
               
               <p>PackageFact is a package together with an associated fact.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PackageFact struct {
Package *types.Package
Fact Fact
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Pass" data-name="Pass">
               <h3>
                  Pass
                  <span class="badge">struct</span>
                  <a href="#Pass" class="anchor" title="Link to Pass">#</a>
               </h3>
               
               <p>A Pass provides information to the Run function that
applies a specific analyzer to a single Go package.
It forms the interface between the analysis logic and the driver
program, and has both input and an output components.
As in a compiler, one pass may depend on the result computed by another.
The Run function should not call any of the Pass functions concurrently.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Pass struct {
Analyzer *Analyzer
Fset *token.FileSet
Files []*ast.File
OtherFiles []string
IgnoredFiles []string
Pkg *types.Package
TypesInfo *types.Info
TypesSizes types.Sizes
TypeErrors []types.Error
Module *Module
Report func(Diagnostic)
ResultOf map[*Analyzer]interface{}
ReadFile func(filename string) ([]byte, error)
ImportObjectFact func(obj types.Object, fact Fact) bool
ImportPackageFact func(pkg *types.Package, fact Fact) bool
ExportObjectFact func(obj types.Object, fact Fact)
ExportPackageFact func(fact Fact)
AllPackageFacts func() []PackageFact
AllObjectFacts func() []ObjectFact
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="RelatedInformation" data-name="RelatedInformation">
               <h3>
                  RelatedInformation
                  <span class="badge">struct</span>
                  <a href="#RelatedInformation" class="anchor" title="Link to RelatedInformation">#</a>
               </h3>
               
               <p>RelatedInformation contains information related to a diagnostic.
For example, a diagnostic that flags duplicated declarations of a
variable may include one RelatedInformation per existing
declaration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type RelatedInformation struct {
Pos token.Pos
End token.Pos
Message string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="SuggestedFix" data-name="SuggestedFix">
               <h3>
                  SuggestedFix
                  <span class="badge">struct</span>
                  <a href="#SuggestedFix" class="anchor" title="Link to SuggestedFix">#</a>
               </h3>
               
               <p>A SuggestedFix is a code change associated with a Diagnostic that a
user can choose to apply to their code. Usually the SuggestedFix is
meant to fix the issue flagged by the diagnostic.
The TextEdits must not overlap, nor contain edits for other packages.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SuggestedFix struct {
Message string
TextEdits []TextEdit
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TextEdit" data-name="TextEdit">
               <h3>
                  TextEdit
                  <span class="badge">struct</span>
                  <a href="#TextEdit" class="anchor" title="Link to TextEdit">#</a>
               </h3>
               
               <p>A TextEdit represents the replacement of the code between Pos and End with the new text.
Each TextEdit should apply to a single file. End should not be earlier in the file than Pos.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TextEdit struct {
Pos token.Pos
End token.Pos
NewText []byte
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *CycleInRequiresGraphError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReportRangef" data-name="ReportRangef">
               <h3>
                  ReportRangef 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReportRangef" class="anchor" title="Link to ReportRangef">#</a>
               </h3>
               
               <p>ReportRangef is a helper function that reports a Diagnostic using the
range provided. ast.Node values can be passed in as the range because
they satisfy the Range interface.</p>
               
               <pre><code>func (pass *Pass) ReportRangef(rng Range, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reportf" data-name="Reportf">
               <h3>
                  Reportf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reportf" class="anchor" title="Link to Reportf">#</a>
               </h3>
               
               <p>Reportf is a helper function that reports a Diagnostic using the
specified position and formatted error message.</p>
               
               <pre><code>func (pass *Pass) Reportf(pos token.Pos, format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (a *Analyzer) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (pass *Pass) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Validate" data-name="Validate">
               <h3>
                  Validate 
                  <span class="badge">function</span>
                  
                  <a href="#Validate" class="anchor" title="Link to Validate">#</a>
               </h3>
               
               <p>Validate reports an error if any of the analyzers are misconfigured.
Checks include:
that the name is a valid identifier;
that the Doc is not empty;
that the Run is non-nil;
that the Requires graph is acyclic;
that analyzer fact types are unique;
that each fact type is a pointer.
Analyzer names need not be unique, though this may be confusing.</p>
               
               <pre><code>func Validate(analyzers []*Analyzer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validIdent" data-name="validIdent">
               <h3>
                  validIdent 
                  <span class="badge">function</span>
                  
                  <a href="#validIdent" class="anchor" title="Link to validIdent">#</a>
               </h3>
               
               <pre><code>func validIdent(name string) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>