<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - counter</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>counter</code>
         </h1>
         <hr />
         
         <article class="global" data-name="debugCounter">
            <h2>debugCounter</h2>
            <hr />
            
            <p>Note: not using internal/godebug, so that internal/godebug can use
internal/counter.</p>
            
            <pre><code>debugCounter</code></pre>
         </article>
         
         <article class="global" data-name="CrashOnBugs">
            <h2>CrashOnBugs</h2>
            <hr />
            
            <pre><code>CrashOnBugs</code></pre>
         </article>
         
         <article class="global" data-name="stateReaders">
            <h2>stateReaders</h2>
            <hr />
            
            <pre><code>stateReaders counterStateBits</code></pre>
         </article>
         
         <article class="global" data-name="stateLocked">
            <h2>stateLocked</h2>
            <hr />
            
            <pre><code>stateLocked counterStateBits</code></pre>
         </article>
         
         <article class="global" data-name="stateHavePtr">
            <h2>stateHavePtr</h2>
            <hr />
            
            <pre><code>stateHavePtr counterStateBits</code></pre>
         </article>
         
         <article class="global" data-name="stateExtraShift">
            <h2>stateExtraShift</h2>
            <hr />
            
            <pre><code>stateExtraShift</code></pre>
         </article>
         
         <article class="global" data-name="stateExtra">
            <h2>stateExtra</h2>
            <hr />
            
            <pre><code>stateExtra counterStateBits</code></pre>
         </article>
         
         <article class="global" data-name="defaultFile">
            <h2>defaultFile</h2>
            <hr />
            
            <pre><code>defaultFile file</code></pre>
         </article>
         
         <article class="global" data-name="ErrDisabled">
            <h2>ErrDisabled</h2>
            <hr />
            
            <p>ErrDisabled is the error returned when telemetry is disabled.</p>
            
            <pre><code>ErrDisabled</code></pre>
         </article>
         
         <article class="global" data-name="errNoBuildInfo">
            <h2>errNoBuildInfo</h2>
            <hr />
            
            <pre><code>errNoBuildInfo</code></pre>
         </article>
         
         <article class="global" data-name="errCorrupt">
            <h2>errCorrupt</h2>
            <hr />
            
            <pre><code>errCorrupt</code></pre>
         </article>
         
         <article class="global" data-name="CounterTime">
            <h2>CounterTime</h2>
            <hr />
            
            <p>CounterTime returns the current UTC time.
Mutable for testing.</p>
            
            <pre><code>CounterTime</code></pre>
         </article>
         
         <article class="global" data-name="openOnce">
            <h2>openOnce</h2>
            <hr />
            
            <pre><code>openOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="rotating">
            <h2>rotating</h2>
            <hr />
            
            <p>rotating reports whether the call to Open had rotate = true.

In golang/go#68497, we observed that file rotation can break runtime
deadlock detection. To minimize the fix for 1.23, we are splitting the
Open API into one version that rotates the counter file, and another that
does not. The rotating variable guards against use of both APIs from the
same process.</p>
            
            <pre><code>rotating bool</code></pre>
         </article>
         
         <article class="global" data-name="FileVersion">
            <h2>FileVersion</h2>
            <hr />
            
            <pre><code>FileVersion</code></pre>
         </article>
         
         <article class="global" data-name="hdrPrefix">
            <h2>hdrPrefix</h2>
            <hr />
            
            <pre><code>hdrPrefix</code></pre>
         </article>
         
         <article class="global" data-name="recordUnit">
            <h2>recordUnit</h2>
            <hr />
            
            <pre><code>recordUnit</code></pre>
         </article>
         
         <article class="global" data-name="maxMetaLen">
            <h2>maxMetaLen</h2>
            <hr />
            
            <pre><code>maxMetaLen</code></pre>
         </article>
         
         <article class="global" data-name="numHash">
            <h2>numHash</h2>
            <hr />
            
            <pre><code>numHash</code></pre>
         </article>
         
         <article class="global" data-name="maxNameLen">
            <h2>maxNameLen</h2>
            <hr />
            
            <pre><code>maxNameLen</code></pre>
         </article>
         
         <article class="global" data-name="limitOff">
            <h2>limitOff</h2>
            <hr />
            
            <pre><code>limitOff</code></pre>
         </article>
         
         <article class="global" data-name="hashOff">
            <h2>hashOff</h2>
            <hr />
            
            <pre><code>hashOff</code></pre>
         </article>
         
         <article class="global" data-name="pageSize">
            <h2>pageSize</h2>
            <hr />
            
            <pre><code>pageSize</code></pre>
         </article>
         
         <article class="global" data-name="minFileLen">
            <h2>minFileLen</h2>
            <hr />
            
            <pre><code>minFileLen</code></pre>
         </article>
         
         <article class="global" data-name="memmap">
            <h2>memmap</h2>
            <hr />
            
            <pre><code>memmap</code></pre>
         </article>
         
         <article class="global" data-name="munmap">
            <h2>munmap</h2>
            <hr />
            
            <pre><code>munmap</code></pre>
         </article>
          
         <article class="struct" data-name="Counter">
            <h2>type Counter struct</h2>
            <hr />
            
            <p>A Counter is a single named event counter.
A Counter is safe for use by multiple goroutines simultaneously.

Counters should typically be created using New
and stored as global variables, like:

	package mypackage
	var errorCount = counter.New("mypackage/errors")

(The initialization of errorCount in this example is handled
entirely by the compiler and linker; this line executes no code
at program startup.)

Then code can call Add to increment the counter
each time the corresponding event is observed.

Although it is possible to use New to create
a Counter each time a particular event needs to be recorded,
that usage fails to amortize the construction cost over
multiple calls to Add, so it is more expensive and not recommended.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
file *file
next *ast.IndexExpr
state counterState
ptr counterPtr</code></pre>
         </article>
         
         <article class="struct" data-name="counterPtr">
            <h2>type counterPtr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">m *mappedFile
count *atomic.Uint64</code></pre>
         </article>
         
         <article class="struct" data-name="counterState">
            <h2>type counterState struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">bits atomic.Uint64</code></pre>
         </article>
         
         <article class="struct" data-name="file">
            <h2>type file struct</h2>
            <hr />
            
            <p>A file is a counter file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">counters *ast.IndexExpr
end Counter
mu sync.Mutex
buildInfo *debug.BuildInfo
timeBegin time.Time
timeEnd time.Time
err error
current *ast.IndexExpr</code></pre>
         </article>
         
         <article class="struct" data-name="mappedFile">
            <h2>type mappedFile struct</h2>
            <hr />
            
            <p>A mappedFile is a counter file mmapped into memory.

The file layout for a mappedFile m is as follows:

	offset, byte size:                 description
	------------------                 -----------
	0, hdrLen:                         header, containing metadata; see [mappedHeader]
	hdrLen+limitOff, 4:                uint32 allocation limit (byte offset of the end of counter records)
	hdrLen+hashOff, 4*numHash:         hash table, stores uint32 heads of a linked list of records, keyed by name hash
	hdrLen+hashOff+4*numHash to limit: counter records: see record syntax below

The record layout is as follows:

	offset, byte size: description
	------------------ -----------
	0, 8:              uint64 counter value
	8, 12:             uint32 name length
	12, 16:            uint32 offset of next record in linked list
	16, name length:   counter name</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">meta string
hdrLen uint32
zero []byte
closeOnce sync.Once
f *os.File
mapping *mmap.Data</code></pre>
         </article>
         
         <article class="struct" data-name="File">
            <h2>type File struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Meta *ast.MapType
Count *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="StackCounter">
            <h2>type StackCounter struct</h2>
            <hr />
            
            <p>a StackCounter is the in-memory knowledge about a stack counter.
StackCounters are more expensive to use than regular Counters,
requiring, at a minimum, a call to runtime.Callers.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
depth int
file *file
mu sync.Mutex
stacks []stack</code></pre>
         </article>
         
         <article class="struct" data-name="stack">
            <h2>type stack struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pcs []uintptr
counter *Counter</code></pre>
         </article>
          
         <article class="function" data-name="debugPrintf">
            <h2>debugPrintf</h2>
            <hr />
            
            <p>debugPrintf formats a debug message if GODEBUG=countertrace=1.</p>
            
            <pre><code>func debugPrintf(format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="debugFatalf">
            <h2>debugFatalf</h2>
            <hr />
            
            <p>debugFatalf logs a fatal error if GODEBUG=countertrace=1.</p>
            
            <pre><code>func debugFatalf(format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="load">
            <h2>load</h2>
            <hr />
            
            <pre><code>func load() counterStateBits</code></pre>
         </article>
         
         <article class="function" data-name="update">
            <h2>update</h2>
            <hr />
            
            <pre><code>func update(old *counterStateBits, new counterStateBits) bool</code></pre>
         </article>
         
         <article class="function" data-name="readers">
            <h2>readers</h2>
            <hr />
            
            <pre><code>func readers() int</code></pre>
         </article>
         
         <article class="function" data-name="locked">
            <h2>locked</h2>
            <hr />
            
            <pre><code>func locked() bool</code></pre>
         </article>
         
         <article class="function" data-name="havePtr">
            <h2>havePtr</h2>
            <hr />
            
            <pre><code>func havePtr() bool</code></pre>
         </article>
         
         <article class="function" data-name="extra">
            <h2>extra</h2>
            <hr />
            
            <pre><code>func extra() uint64</code></pre>
         </article>
         
         <article class="function" data-name="incReader">
            <h2>incReader</h2>
            <hr />
            
            <pre><code>func incReader() counterStateBits</code></pre>
         </article>
         
         <article class="function" data-name="decReader">
            <h2>decReader</h2>
            <hr />
            
            <pre><code>func decReader() counterStateBits</code></pre>
         </article>
         
         <article class="function" data-name="setLocked">
            <h2>setLocked</h2>
            <hr />
            
            <pre><code>func setLocked() counterStateBits</code></pre>
         </article>
         
         <article class="function" data-name="clearLocked">
            <h2>clearLocked</h2>
            <hr />
            
            <pre><code>func clearLocked() counterStateBits</code></pre>
         </article>
         
         <article class="function" data-name="setHavePtr">
            <h2>setHavePtr</h2>
            <hr />
            
            <pre><code>func setHavePtr() counterStateBits</code></pre>
         </article>
         
         <article class="function" data-name="clearHavePtr">
            <h2>clearHavePtr</h2>
            <hr />
            
            <pre><code>func clearHavePtr() counterStateBits</code></pre>
         </article>
         
         <article class="function" data-name="clearExtra">
            <h2>clearExtra</h2>
            <hr />
            
            <pre><code>func clearExtra() counterStateBits</code></pre>
         </article>
         
         <article class="function" data-name="addExtra">
            <h2>addExtra</h2>
            <hr />
            
            <pre><code>func addExtra(n uint64) counterStateBits</code></pre>
         </article>
         
         <article class="function" data-name="New">
            <h2>New</h2>
            <hr />
            
            <p>New returns a counter with the given name.
New can be called in global initializers and will be compiled down to
linker-initialized data. That is, calling New to initialize a global
has no cost at program startup.</p>
            
            <pre><code>func New(name string) *Counter</code></pre>
         </article>
         
         <article class="function" data-name="Inc">
            <h2>Inc</h2>
            <hr />
            
            <p>Inc adds 1 to the counter.</p>
            
            <pre><code>func Inc()</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add adds n to the counter. n cannot be negative, as counts cannot decrease.</p>
            
            <pre><code>func Add(n int64)</code></pre>
         </article>
         
         <article class="function" data-name="releaseReader">
            <h2>releaseReader</h2>
            <hr />
            
            <pre><code>func releaseReader(state counterStateBits)</code></pre>
         </article>
         
         <article class="function" data-name="releaseLock">
            <h2>releaseLock</h2>
            <hr />
            
            <pre><code>func releaseLock(state counterStateBits)</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <p>add wraps the atomic.Uint64.Add operation to handle integer overflow.</p>
            
            <pre><code>func add(n uint64) uint64</code></pre>
         </article>
         
         <article class="function" data-name="invalidate">
            <h2>invalidate</h2>
            <hr />
            
            <pre><code>func invalidate()</code></pre>
         </article>
         
         <article class="function" data-name="refresh">
            <h2>refresh</h2>
            <hr />
            
            <pre><code>func refresh()</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <p>Read reads the given counter.
This is the implementation of x/telemetry/counter/countertest.ReadCounter.</p>
            
            <pre><code>func Read(c *Counter) (uint64, error)</code></pre>
         </article>
         
         <article class="function" data-name="readFile">
            <h2>readFile</h2>
            <hr />
            
            <pre><code>func readFile(f *file) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadFile">
            <h2>ReadFile</h2>
            <hr />
            
            <p>ReadFile reads the counters and stack counters from the given file.
This is the implementation of x/telemetry/counter/countertest.ReadFile.</p>
            
            <pre><code>func ReadFile(name string) (counters *ast.MapType, stackCounters *ast.MapType, _ error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadMapped">
            <h2>ReadMapped</h2>
            <hr />
            
            <p>ReadMapped reads the contents of the given file by memory mapping.

This avoids file synchronization issues.</p>
            
            <pre><code>func ReadMapped(name string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="register">
            <h2>register</h2>
            <hr />
            
            <p>register ensures that the counter c is registered with the file.</p>
            
            <pre><code>func register(c *Counter)</code></pre>
         </article>
         
         <article class="function" data-name="invalidateCounters">
            <h2>invalidateCounters</h2>
            <hr />
            
            <p>invalidateCounters marks as invalid all the pointers
held by f's counters and then refreshes them.

invalidateCounters cannot be called while holding f.mu,
because a counter refresh may call f.lookup.</p>
            
            <pre><code>func invalidateCounters()</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup looks up the counter with the given name in the file,
allocating it if needed, and returns a pointer to the atomic.Uint64
containing the counter data.
If the file has not been opened yet, lookup returns nil.</p>
            
            <pre><code>func lookup(name string) counterPtr</code></pre>
         </article>
         
         <article class="function" data-name="weekEnd">
            <h2>weekEnd</h2>
            <hr />
            
            <p>weekEnd returns the day of the week on which uploads occur (and therefore
counters expire).

Reads the weekends file, creating one if none exists.</p>
            
            <pre><code>func weekEnd() (time.Weekday, error)</code></pre>
         </article>
         
         <article class="function" data-name="rotate">
            <h2>rotate</h2>
            <hr />
            
            <p>rotate checks to see whether the file f needs to be rotated,
meaning to start a new counter file with a different date in the name.
rotate is also used to open the file initially, meaning f.current can be nil.
In general rotate should be called just once for each file.
rotate will arrange a timer to call itself again when necessary.</p>
            
            <pre><code>func rotate()</code></pre>
         </article>
         
         <article class="function" data-name="nop">
            <h2>nop</h2>
            <hr />
            
            <pre><code>func nop()</code></pre>
         </article>
         
         <article class="function" data-name="counterSpan">
            <h2>counterSpan</h2>
            <hr />
            
            <p>counterSpan returns the current time span for a counter file, as determined
by [CounterTime] and the [weekEnd].</p>
            
            <pre><code>func counterSpan() (begin time.Time, end time.Time, _ error)</code></pre>
         </article>
         
         <article class="function" data-name="rotate1">
            <h2>rotate1</h2>
            <hr />
            
            <p>rotate1 rotates the current counter file, returning its expiry, or the zero
time if rotation failed.</p>
            
            <pre><code>func rotate1() time.Time</code></pre>
         </article>
         
         <article class="function" data-name="newCounter">
            <h2>newCounter</h2>
            <hr />
            
            <pre><code>func newCounter(name string) *atomic.Uint64</code></pre>
         </article>
         
         <article class="function" data-name="newCounter1">
            <h2>newCounter1</h2>
            <hr />
            
            <pre><code>func newCounter1(name string) (v *atomic.Uint64, cleanup func)</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <p>Open associates counting with the defaultFile.
The returned function is for testing only, and should
be called after all Inc()s are finished, but before
any reports are generated.
(Otherwise expired count files will not be deleted on Windows.)</p>
            
            <pre><code>func Open(rotate bool) func</code></pre>
         </article>
         
         <article class="function" data-name="openMapped">
            <h2>openMapped</h2>
            <hr />
            
            <p>openMapped opens and memory maps a file.

name is the path to the file.

meta is the file metadata, which must match the metadata of the file on disk
exactly.

existing should be nil the first time this is called for a file,
and when remapping, should be the previous mappedFile.</p>
            
            <pre><code>func openMapped(name string, meta string) (_ *mappedFile, err error)</code></pre>
         </article>
         
         <article class="function" data-name="mappedHeader">
            <h2>mappedHeader</h2>
            <hr />
            
            <pre><code>func mappedHeader(meta string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="place">
            <h2>place</h2>
            <hr />
            
            <pre><code>func place(limit uint32, name string) (start uint32, end uint32)</code></pre>
         </article>
         
         <article class="function" data-name="close">
            <h2>close</h2>
            <hr />
            
            <pre><code>func close()</code></pre>
         </article>
         
         <article class="function" data-name="hash">
            <h2>hash</h2>
            <hr />
            
            <p>hash returns the hash code for name.
The implementation is FNV-1a.
This hash function is a fixed detail of the file format.
It cannot be changed without also changing the file format version.</p>
            
            <pre><code>func hash(name string) uint32</code></pre>
         </article>
         
         <article class="function" data-name="load32">
            <h2>load32</h2>
            <hr />
            
            <pre><code>func load32(off uint32) uint32</code></pre>
         </article>
         
         <article class="function" data-name="cas32">
            <h2>cas32</h2>
            <hr />
            
            <pre><code>func cas32(off uint32, old uint32, new uint32) bool</code></pre>
         </article>
         
         <article class="function" data-name="entryAt">
            <h2>entryAt</h2>
            <hr />
            
            <p>entryAt reads a counter record at the given byte offset.

See the documentation for [mappedFile] for a description of the counter record layout.</p>
            
            <pre><code>func entryAt(off uint32) (name []byte, next uint32, v *atomic.Uint64, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="writeEntryAt">
            <h2>writeEntryAt</h2>
            <hr />
            
            <p>writeEntryAt writes a new counter record at the given offset.

See the documentation for [mappedFile] for a description of the counter record layout.

writeEntryAt only returns false in the presence of some form of corruption:
an offset outside the bounds of the record region in the mapped file.</p>
            
            <pre><code>func writeEntryAt(off uint32, name string) (next *atomic.Uint32, v *atomic.Uint64, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="lookup">
            <h2>lookup</h2>
            <hr />
            
            <p>lookup searches the mapped file for a counter record with the given name, returning:
  - v: the mapped counter value
  - headOff: the offset of the head pointer (see [mappedFile])
  - head: the value of the head pointer
  - ok: whether lookup succeeded</p>
            
            <pre><code>func lookup(name string) (v *atomic.Uint64, headOff uint32, head uint32, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="newCounter">
            <h2>newCounter</h2>
            <hr />
            
            <p>newCounter allocates and writes a new counter record with the given name.

If name is already recorded in the file, newCounter returns the existing counter.</p>
            
            <pre><code>func newCounter(name string) (v *atomic.Uint64, m1 *mappedFile, err error)</code></pre>
         </article>
         
         <article class="function" data-name="extend">
            <h2>extend</h2>
            <hr />
            
            <pre><code>func extend(end uint32) (*mappedFile, error)</code></pre>
         </article>
         
         <article class="function" data-name="round">
            <h2>round</h2>
            <hr />
            
            <p>round returns x rounded up to the next multiple of unit,
which must be a power of two.</p>
            
            <pre><code>func round(x T, unit T) T</code></pre>
         </article>
         
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <pre><code>func Parse(filename string, data []byte) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewStack">
            <h2>NewStack</h2>
            <hr />
            
            <pre><code>func NewStack(name string, depth int) *StackCounter</code></pre>
         </article>
         
         <article class="function" data-name="Inc">
            <h2>Inc</h2>
            <hr />
            
            <p>Inc increments a stack counter. It computes the caller's stack and
looks up the corresponding counter. It then increments that counter,
creating it if necessary.</p>
            
            <pre><code>func Inc()</code></pre>
         </article>
         
         <article class="function" data-name="EncodeStack">
            <h2>EncodeStack</h2>
            <hr />
            
            <p>EncodeStack returns the name of the counter to
use for the given stack of program counters.
The name encodes the stack.</p>
            
            <pre><code>func EncodeStack(pcs []uintptr, prefix string) string</code></pre>
         </article>
         
         <article class="function" data-name="DecodeStack">
            <h2>DecodeStack</h2>
            <hr />
            
            <p>DecodeStack expands the (compressed) stack encoded in the counter name.</p>
            
            <pre><code>func DecodeStack(ename string) string</code></pre>
         </article>
         
         <article class="function" data-name="cutLastDot">
            <h2>cutLastDot</h2>
            <hr />
            
            <p>input is <import path>.<function name>
output is (import path, function name)</p>
            
            <pre><code>func cutLastDot(x string) (before string, after string)</code></pre>
         </article>
         
         <article class="function" data-name="Names">
            <h2>Names</h2>
            <hr />
            
            <p>Names reports all the counter names associated with a StackCounter.</p>
            
            <pre><code>func Names() []string</code></pre>
         </article>
         
         <article class="function" data-name="Counters">
            <h2>Counters</h2>
            <hr />
            
            <p>Counters returns the known Counters for a StackCounter.
There may be more in the count file.</p>
            
            <pre><code>func Counters() []*Counter</code></pre>
         </article>
         
         <article class="function" data-name="eq">
            <h2>eq</h2>
            <hr />
            
            <pre><code>func eq(a []uintptr, b []uintptr) bool</code></pre>
         </article>
         
         <article class="function" data-name="ReadStack">
            <h2>ReadStack</h2>
            <hr />
            
            <p>ReadStack reads the given stack counter.
This is the implementation of
golang.org/x/telemetry/counter/countertest.ReadStackCounter.</p>
            
            <pre><code>func ReadStack(c *StackCounter) (*ast.MapType, error)</code></pre>
         </article>
         
         <article class="function" data-name="IsStackCounter">
            <h2>IsStackCounter</h2>
            <hr />
            
            <p>IsStackCounter reports whether the counter name is for a stack counter.</p>
            
            <pre><code>func IsStackCounter(name string) bool</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
