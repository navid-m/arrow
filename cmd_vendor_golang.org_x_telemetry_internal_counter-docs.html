<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>counter - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>counter</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"os"
"runtime"
"strings"
"sync/atomic"
"bytes"
"errors"
"fmt"
"math/rand"
"os"
"path"
"path/filepath"
"runtime"
"runtime/debug"
"sync"
"sync/atomic"
"time"
"unsafe"
"golang.org/x/telemetry/internal/mmap"
"golang.org/x/telemetry/internal/telemetry"
"bytes"
"fmt"
"strings"
"unsafe"
"golang.org/x/telemetry/internal/mmap"
"fmt"
"runtime"
"strings"
"sync"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="CounterTime" data-name="CounterTime">
               <h3>
                  CounterTime 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#CounterTime" class="anchor" title="Link to CounterTime">#</a>
               </h3>
               
                  <p class="doc-comment">CounterTime returns the current UTC time.
Mutable for testing.</p>
               
               <pre><code class="language-go">var CounterTime = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="CrashOnBugs" data-name="CrashOnBugs">
               <h3>
                  CrashOnBugs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#CrashOnBugs" class="anchor" title="Link to CrashOnBugs">#</a>
               </h3>
               
               <pre><code class="language-go">var CrashOnBugs = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrDisabled" data-name="ErrDisabled">
               <h3>
                  ErrDisabled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrDisabled" class="anchor" title="Link to ErrDisabled">#</a>
               </h3>
               
                  <p class="doc-comment">ErrDisabled is the error returned when telemetry is disabled.</p>
               
               <pre><code class="language-go">var ErrDisabled = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FileVersion" data-name="FileVersion">
               <h3>
                  FileVersion 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FileVersion" class="anchor" title="Link to FileVersion">#</a>
               </h3>
               
               <pre><code class="language-go">const FileVersion = "v1"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugCounter" data-name="debugCounter">
               <h3>
                  debugCounter 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#debugCounter" class="anchor" title="Link to debugCounter">#</a>
               </h3>
               
                  <p class="doc-comment">Note: not using internal/godebug, so that internal/godebug can use
internal/counter.</p>
               
               <pre><code class="language-go">var debugCounter = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultFile" data-name="defaultFile">
               <h3>
                  defaultFile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultFile" class="anchor" title="Link to defaultFile">#</a>
               </h3>
               
               <pre><code class="language-go">var defaultFile file</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errCorrupt" data-name="errCorrupt">
               <h3>
                  errCorrupt 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errCorrupt" class="anchor" title="Link to errCorrupt">#</a>
               </h3>
               
               <pre><code class="language-go">var errCorrupt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNoBuildInfo" data-name="errNoBuildInfo">
               <h3>
                  errNoBuildInfo 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNoBuildInfo" class="anchor" title="Link to errNoBuildInfo">#</a>
               </h3>
               
               <pre><code class="language-go">var errNoBuildInfo = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hashOff" data-name="hashOff">
               <h3>
                  hashOff 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#hashOff" class="anchor" title="Link to hashOff">#</a>
               </h3>
               
               <pre><code class="language-go">const hashOff = 4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hdrPrefix" data-name="hdrPrefix">
               <h3>
                  hdrPrefix 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#hdrPrefix" class="anchor" title="Link to hdrPrefix">#</a>
               </h3>
               
               <pre><code class="language-go">const hdrPrefix = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="limitOff" data-name="limitOff">
               <h3>
                  limitOff 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#limitOff" class="anchor" title="Link to limitOff">#</a>
               </h3>
               
               <pre><code class="language-go">const limitOff = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxMetaLen" data-name="maxMetaLen">
               <h3>
                  maxMetaLen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxMetaLen" class="anchor" title="Link to maxMetaLen">#</a>
               </h3>
               
               <pre><code class="language-go">const maxMetaLen = 512</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxNameLen" data-name="maxNameLen">
               <h3>
                  maxNameLen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxNameLen" class="anchor" title="Link to maxNameLen">#</a>
               </h3>
               
               <pre><code class="language-go">const maxNameLen = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="memmap" data-name="memmap">
               <h3>
                  memmap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#memmap" class="anchor" title="Link to memmap">#</a>
               </h3>
               
               <pre><code class="language-go">var memmap = mmap.Mmap</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="minFileLen" data-name="minFileLen">
               <h3>
                  minFileLen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#minFileLen" class="anchor" title="Link to minFileLen">#</a>
               </h3>
               
               <pre><code class="language-go">const minFileLen = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="munmap" data-name="munmap">
               <h3>
                  munmap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#munmap" class="anchor" title="Link to munmap">#</a>
               </h3>
               
               <pre><code class="language-go">var munmap = mmap.Munmap</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="numHash" data-name="numHash">
               <h3>
                  numHash 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#numHash" class="anchor" title="Link to numHash">#</a>
               </h3>
               
               <pre><code class="language-go">const numHash = 512</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="openOnce" data-name="openOnce">
               <h3>
                  openOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#openOnce" class="anchor" title="Link to openOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var openOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pageSize" data-name="pageSize">
               <h3>
                  pageSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#pageSize" class="anchor" title="Link to pageSize">#</a>
               </h3>
               
               <pre><code class="language-go">const pageSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="recordUnit" data-name="recordUnit">
               <h3>
                  recordUnit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#recordUnit" class="anchor" title="Link to recordUnit">#</a>
               </h3>
               
               <pre><code class="language-go">const recordUnit = 32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="rotating" data-name="rotating">
               <h3>
                  rotating 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#rotating" class="anchor" title="Link to rotating">#</a>
               </h3>
               
                  <p class="doc-comment">rotating reports whether the call to Open had rotate = true.
In golang/go#68497, we observed that file rotation can break runtime
deadlock detection. To minimize the fix for 1.23, we are splitting the
Open API into one version that rotates the counter file, and another that
does not. The rotating variable guards against use of both APIs from the
same process.</p>
               
               <pre><code class="language-go">var rotating bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stateExtra" data-name="stateExtra">
               <h3>
                  stateExtra 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stateExtra" class="anchor" title="Link to stateExtra">#</a>
               </h3>
               
               <pre><code class="language-go">const stateExtra counterStateBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stateExtraShift" data-name="stateExtraShift">
               <h3>
                  stateExtraShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stateExtraShift" class="anchor" title="Link to stateExtraShift">#</a>
               </h3>
               
               <pre><code class="language-go">const stateExtraShift = 31</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stateHavePtr" data-name="stateHavePtr">
               <h3>
                  stateHavePtr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stateHavePtr" class="anchor" title="Link to stateHavePtr">#</a>
               </h3>
               
               <pre><code class="language-go">const stateHavePtr counterStateBits = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stateLocked" data-name="stateLocked">
               <h3>
                  stateLocked 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stateLocked" class="anchor" title="Link to stateLocked">#</a>
               </h3>
               
               <pre><code class="language-go">const stateLocked counterStateBits = stateReaders</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stateReaders" data-name="stateReaders">
               <h3>
                  stateReaders 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stateReaders" class="anchor" title="Link to stateReaders">#</a>
               </h3>
               
               <pre><code class="language-go">const stateReaders counterStateBits = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="counterStateBits" data-name="counterStateBits">
               <h3>
                  counterStateBits
                  <span class="badge type-badge">type</span>
                  <a href="#counterStateBits" class="anchor" title="Link to counterStateBits">#</a>
               </h3>
               
               <pre><code class="language-go">type counterStateBits uint64</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Counter" data-name="Counter">
               <h3>
                  Counter
                  <span class="badge">struct</span>
                  <a href="#Counter" class="anchor" title="Link to Counter">#</a>
               </h3>
               
               <p>A Counter is a single named event counter.
A Counter is safe for use by multiple goroutines simultaneously.
Counters should typically be created using New
and stored as global variables, like:
package mypackage
var errorCount = counter.New("mypackage/errors")
(The initialization of errorCount in this example is handled
entirely by the compiler and linker; this line executes no code
at program startup.)
Then code can call Add to increment the counter
each time the corresponding event is observed.
Although it is possible to use New to create
a Counter each time a particular event needs to be recorded,
that usage fails to amortize the construction cost over
multiple calls to Add, so it is more expensive and not recommended.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Counter struct {
name string
file *file
next *ast.IndexExpr
state counterState
ptr counterPtr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="File" data-name="File">
               <h3>
                  File
                  <span class="badge">struct</span>
                  <a href="#File" class="anchor" title="Link to File">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type File struct {
Meta map[string]string
Count map[string]uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="StackCounter" data-name="StackCounter">
               <h3>
                  StackCounter
                  <span class="badge">struct</span>
                  <a href="#StackCounter" class="anchor" title="Link to StackCounter">#</a>
               </h3>
               
               <p>a StackCounter is the in-memory knowledge about a stack counter.
StackCounters are more expensive to use than regular Counters,
requiring, at a minimum, a call to runtime.Callers.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type StackCounter struct {
name string
depth int
file *file
mu sync.Mutex
stacks []stack
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="counterPtr" data-name="counterPtr">
               <h3>
                  counterPtr
                  <span class="badge">struct</span>
                  <a href="#counterPtr" class="anchor" title="Link to counterPtr">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type counterPtr struct {
m *mappedFile
count *atomic.Uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="counterState" data-name="counterState">
               <h3>
                  counterState
                  <span class="badge">struct</span>
                  <a href="#counterState" class="anchor" title="Link to counterState">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type counterState struct {
bits atomic.Uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="file" data-name="file">
               <h3>
                  file
                  <span class="badge">struct</span>
                  <a href="#file" class="anchor" title="Link to file">#</a>
               </h3>
               
               <p>A file is a counter file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type file struct {
counters *ast.IndexExpr
end Counter
mu sync.Mutex
buildInfo *debug.BuildInfo
timeBegin time.Time
timeEnd time.Time
err error
current *ast.IndexExpr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mappedFile" data-name="mappedFile">
               <h3>
                  mappedFile
                  <span class="badge">struct</span>
                  <a href="#mappedFile" class="anchor" title="Link to mappedFile">#</a>
               </h3>
               
               <p>A mappedFile is a counter file mmapped into memory.
The file layout for a mappedFile m is as follows:
offset, byte size:                 description
------------------                 -----------
0, hdrLen:                         header, containing metadata; see [mappedHeader]
hdrLen+limitOff, 4:                uint32 allocation limit (byte offset of the end of counter records)
hdrLen+hashOff, 4*numHash:         hash table, stores uint32 heads of a linked list of records, keyed by name hash
hdrLen+hashOff+4*numHash to limit: counter records: see record syntax below
The record layout is as follows:
offset, byte size: description
------------------ -----------
0, 8:              uint64 counter value
8, 12:             uint32 name length
12, 16:            uint32 offset of next record in linked list
16, name length:   counter name</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type mappedFile struct {
meta string
hdrLen uint32
zero [4]byte
closeOnce sync.Once
f *os.File
mapping *mmap.Data
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="stack" data-name="stack">
               <h3>
                  stack
                  <span class="badge">struct</span>
                  <a href="#stack" class="anchor" title="Link to stack">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type stack struct {
pcs []uintptr
counter *Counter
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add adds n to the counter. n cannot be negative, as counts cannot decrease.</p>
               
               <pre><code class="language-go">func (c *Counter) Add(n int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Counters" data-name="Counters">
               <h3>
                  Counters 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Counters" class="anchor" title="Link to Counters">#</a>
               </h3>
               
               <p>Counters returns the known Counters for a StackCounter.
There may be more in the count file.</p>
               
               <pre><code class="language-go">func (c *StackCounter) Counters() []*Counter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DecodeStack" data-name="DecodeStack">
               <h3>
                  DecodeStack 
                  <span class="badge">function</span>
                  
                  <a href="#DecodeStack" class="anchor" title="Link to DecodeStack">#</a>
               </h3>
               
               <p>DecodeStack expands the (compressed) stack encoded in the counter name.</p>
               
               <pre><code class="language-go">func DecodeStack(ename string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EncodeStack" data-name="EncodeStack">
               <h3>
                  EncodeStack 
                  <span class="badge">function</span>
                  
                  <a href="#EncodeStack" class="anchor" title="Link to EncodeStack">#</a>
               </h3>
               
               <p>EncodeStack returns the name of the counter to
use for the given stack of program counters.
The name encodes the stack.</p>
               
               <pre><code class="language-go">func EncodeStack(pcs []uintptr, prefix string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Inc" data-name="Inc">
               <h3>
                  Inc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Inc" class="anchor" title="Link to Inc">#</a>
               </h3>
               
               <p>Inc adds 1 to the counter.</p>
               
               <pre><code class="language-go">func (c *Counter) Inc()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Inc" data-name="Inc">
               <h3>
                  Inc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Inc" class="anchor" title="Link to Inc">#</a>
               </h3>
               
               <p>Inc increments a stack counter. It computes the caller's stack and
looks up the corresponding counter. It then increments that counter,
creating it if necessary.</p>
               
               <pre><code class="language-go">func (c *StackCounter) Inc()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsStackCounter" data-name="IsStackCounter">
               <h3>
                  IsStackCounter 
                  <span class="badge">function</span>
                  
                  <a href="#IsStackCounter" class="anchor" title="Link to IsStackCounter">#</a>
               </h3>
               
               <p>IsStackCounter reports whether the counter name is for a stack counter.</p>
               
               <pre><code class="language-go">func IsStackCounter(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Counter) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Names" data-name="Names">
               <h3>
                  Names 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Names" class="anchor" title="Link to Names">#</a>
               </h3>
               
               <p>Names reports all the counter names associated with a StackCounter.</p>
               
               <pre><code class="language-go">func (c *StackCounter) Names() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="New" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
                  <a href="#New" class="anchor" title="Link to New">#</a>
               </h3>
               
               <p>New returns a counter with the given name.
New can be called in global initializers and will be compiled down to
linker-initialized data. That is, calling New to initialize a global
has no cost at program startup.</p>
               
               <pre><code class="language-go">func New(name string) *Counter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewStack" data-name="NewStack">
               <h3>
                  NewStack 
                  <span class="badge">function</span>
                  
                  <a href="#NewStack" class="anchor" title="Link to NewStack">#</a>
               </h3>
               
               <pre><code class="language-go">func NewStack(name string, depth int) *StackCounter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge">function</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <p>Open associates counting with the defaultFile.
The returned function is for testing only, and should
be called after all Inc()s are finished, but before
any reports are generated.
(Otherwise expired count files will not be deleted on Windows.)</p>
               
               <pre><code class="language-go">func Open(rotate bool) func()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parse" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge">function</span>
                  
                  <a href="#Parse" class="anchor" title="Link to Parse">#</a>
               </h3>
               
               <pre><code class="language-go">func Parse(filename string, data []byte) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge">function</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read reads the given counter.
This is the implementation of x/telemetry/counter/countertest.ReadCounter.</p>
               
               <pre><code class="language-go">func Read(c *Counter) (uint64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFile" data-name="ReadFile">
               <h3>
                  ReadFile 
                  <span class="badge">function</span>
                  
                  <a href="#ReadFile" class="anchor" title="Link to ReadFile">#</a>
               </h3>
               
               <p>ReadFile reads the counters and stack counters from the given file.
This is the implementation of x/telemetry/counter/countertest.ReadFile.</p>
               
               <pre><code class="language-go">func ReadFile(name string) (counters map[string]uint64, stackCounters map[string]uint64, _ error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadMapped" data-name="ReadMapped">
               <h3>
                  ReadMapped 
                  <span class="badge">function</span>
                  
                  <a href="#ReadMapped" class="anchor" title="Link to ReadMapped">#</a>
               </h3>
               
               <p>ReadMapped reads the contents of the given file by memory mapping.
This avoids file synchronization issues.</p>
               
               <pre><code class="language-go">func ReadMapped(name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadStack" data-name="ReadStack">
               <h3>
                  ReadStack 
                  <span class="badge">function</span>
                  
                  <a href="#ReadStack" class="anchor" title="Link to ReadStack">#</a>
               </h3>
               
               <p>ReadStack reads the given stack counter.
This is the implementation of
golang.org/x/telemetry/counter/countertest.ReadStackCounter.</p>
               
               <pre><code class="language-go">func ReadStack(c *StackCounter) (map[string]uint64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add wraps the atomic.Uint64.Add operation to handle integer overflow.</p>
               
               <pre><code class="language-go">func (c *Counter) add(n uint64) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addExtra" data-name="addExtra">
               <h3>
                  addExtra 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addExtra" class="anchor" title="Link to addExtra">#</a>
               </h3>
               
               <pre><code class="language-go">func (b counterStateBits) addExtra(n uint64) counterStateBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cas32" data-name="cas32">
               <h3>
                  cas32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cas32" class="anchor" title="Link to cas32">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *mappedFile) cas32(off uint32, old uint32, new uint32) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clearExtra" data-name="clearExtra">
               <h3>
                  clearExtra 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#clearExtra" class="anchor" title="Link to clearExtra">#</a>
               </h3>
               
               <pre><code class="language-go">func (b counterStateBits) clearExtra() counterStateBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clearHavePtr" data-name="clearHavePtr">
               <h3>
                  clearHavePtr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#clearHavePtr" class="anchor" title="Link to clearHavePtr">#</a>
               </h3>
               
               <pre><code class="language-go">func (b counterStateBits) clearHavePtr() counterStateBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clearLocked" data-name="clearLocked">
               <h3>
                  clearLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#clearLocked" class="anchor" title="Link to clearLocked">#</a>
               </h3>
               
               <pre><code class="language-go">func (b counterStateBits) clearLocked() counterStateBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *mappedFile) close()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="counterSpan" data-name="counterSpan">
               <h3>
                  counterSpan 
                  <span class="badge">function</span>
                  
                  <a href="#counterSpan" class="anchor" title="Link to counterSpan">#</a>
               </h3>
               
               <p>counterSpan returns the current time span for a counter file, as determined
by [CounterTime] and the [weekEnd].</p>
               
               <pre><code class="language-go">func counterSpan() (begin time.Time, end time.Time, _ error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cutLastDot" data-name="cutLastDot">
               <h3>
                  cutLastDot 
                  <span class="badge">function</span>
                  
                  <a href="#cutLastDot" class="anchor" title="Link to cutLastDot">#</a>
               </h3>
               
               <p>input is <import path>.<function name>
output is (import path, function name)</p>
               
               <pre><code class="language-go">func cutLastDot(x string) (before string, after string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="debugFatalf" data-name="debugFatalf">
               <h3>
                  debugFatalf 
                  <span class="badge">function</span>
                  
                  <a href="#debugFatalf" class="anchor" title="Link to debugFatalf">#</a>
               </h3>
               
               <p>debugFatalf logs a fatal error if GODEBUG=countertrace=1.</p>
               
               <pre><code class="language-go">func debugFatalf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="debugPrintf" data-name="debugPrintf">
               <h3>
                  debugPrintf 
                  <span class="badge">function</span>
                  
                  <a href="#debugPrintf" class="anchor" title="Link to debugPrintf">#</a>
               </h3>
               
               <p>debugPrintf formats a debug message if GODEBUG=countertrace=1.</p>
               
               <pre><code class="language-go">func debugPrintf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decReader" data-name="decReader">
               <h3>
                  decReader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#decReader" class="anchor" title="Link to decReader">#</a>
               </h3>
               
               <pre><code class="language-go">func (b counterStateBits) decReader() counterStateBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="entryAt" data-name="entryAt">
               <h3>
                  entryAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#entryAt" class="anchor" title="Link to entryAt">#</a>
               </h3>
               
               <p>entryAt reads a counter record at the given byte offset.
See the documentation for [mappedFile] for a description of the counter record layout.</p>
               
               <pre><code class="language-go">func (m *mappedFile) entryAt(off uint32) (name []byte, next uint32, v *atomic.Uint64, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="eq" data-name="eq">
               <h3>
                  eq 
                  <span class="badge">function</span>
                  
                  <a href="#eq" class="anchor" title="Link to eq">#</a>
               </h3>
               
               <pre><code class="language-go">func eq(a []uintptr, b []uintptr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="extend" data-name="extend">
               <h3>
                  extend 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#extend" class="anchor" title="Link to extend">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *mappedFile) extend(end uint32) (*mappedFile, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="extra" data-name="extra">
               <h3>
                  extra 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#extra" class="anchor" title="Link to extra">#</a>
               </h3>
               
               <pre><code class="language-go">func (b counterStateBits) extra() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hash" data-name="hash">
               <h3>
                  hash 
                  <span class="badge">function</span>
                  
                  <a href="#hash" class="anchor" title="Link to hash">#</a>
               </h3>
               
               <p>hash returns the hash code for name.
The implementation is FNV-1a.
This hash function is a fixed detail of the file format.
It cannot be changed without also changing the file format version.</p>
               
               <pre><code class="language-go">func hash(name string) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="havePtr" data-name="havePtr">
               <h3>
                  havePtr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#havePtr" class="anchor" title="Link to havePtr">#</a>
               </h3>
               
               <pre><code class="language-go">func (b counterStateBits) havePtr() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="incReader" data-name="incReader">
               <h3>
                  incReader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#incReader" class="anchor" title="Link to incReader">#</a>
               </h3>
               
               <pre><code class="language-go">func (b counterStateBits) incReader() counterStateBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="invalidate" data-name="invalidate">
               <h3>
                  invalidate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#invalidate" class="anchor" title="Link to invalidate">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Counter) invalidate()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="invalidateCounters" data-name="invalidateCounters">
               <h3>
                  invalidateCounters 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#invalidateCounters" class="anchor" title="Link to invalidateCounters">#</a>
               </h3>
               
               <p>invalidateCounters marks as invalid all the pointers
held by f's counters and then refreshes them.
invalidateCounters cannot be called while holding f.mu,
because a counter refresh may call f.lookup.</p>
               
               <pre><code class="language-go">func (f *file) invalidateCounters()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="load" data-name="load">
               <h3>
                  load 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#load" class="anchor" title="Link to load">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *counterState) load() counterStateBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="load32" data-name="load32">
               <h3>
                  load32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#load32" class="anchor" title="Link to load32">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *mappedFile) load32(off uint32) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="locked" data-name="locked">
               <h3>
                  locked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#locked" class="anchor" title="Link to locked">#</a>
               </h3>
               
               <pre><code class="language-go">func (b counterStateBits) locked() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookup" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookup" class="anchor" title="Link to lookup">#</a>
               </h3>
               
               <p>lookup searches the mapped file for a counter record with the given name, returning:
- v: the mapped counter value
- headOff: the offset of the head pointer (see [mappedFile])
- head: the value of the head pointer
- ok: whether lookup succeeded</p>
               
               <pre><code class="language-go">func (m *mappedFile) lookup(name string) (v *atomic.Uint64, headOff uint32, head uint32, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookup" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookup" class="anchor" title="Link to lookup">#</a>
               </h3>
               
               <p>lookup looks up the counter with the given name in the file,
allocating it if needed, and returns a pointer to the atomic.Uint64
containing the counter data.
If the file has not been opened yet, lookup returns nil.</p>
               
               <pre><code class="language-go">func (f *file) lookup(name string) counterPtr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mappedHeader" data-name="mappedHeader">
               <h3>
                  mappedHeader 
                  <span class="badge">function</span>
                  
                  <a href="#mappedHeader" class="anchor" title="Link to mappedHeader">#</a>
               </h3>
               
               <pre><code class="language-go">func mappedHeader(meta string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newCounter" data-name="newCounter">
               <h3>
                  newCounter 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newCounter" class="anchor" title="Link to newCounter">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *file) newCounter(name string) *atomic.Uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newCounter" data-name="newCounter">
               <h3>
                  newCounter 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newCounter" class="anchor" title="Link to newCounter">#</a>
               </h3>
               
               <p>newCounter allocates and writes a new counter record with the given name.
If name is already recorded in the file, newCounter returns the existing counter.</p>
               
               <pre><code class="language-go">func (m *mappedFile) newCounter(name string) (v *atomic.Uint64, m1 *mappedFile, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newCounter1" data-name="newCounter1">
               <h3>
                  newCounter1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newCounter1" class="anchor" title="Link to newCounter1">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *file) newCounter1(name string) (v *atomic.Uint64, cleanup func())</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nop" data-name="nop">
               <h3>
                  nop 
                  <span class="badge">function</span>
                  
                  <a href="#nop" class="anchor" title="Link to nop">#</a>
               </h3>
               
               <pre><code class="language-go">func nop()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openMapped" data-name="openMapped">
               <h3>
                  openMapped 
                  <span class="badge">function</span>
                  
                  <a href="#openMapped" class="anchor" title="Link to openMapped">#</a>
               </h3>
               
               <p>openMapped opens and memory maps a file.
name is the path to the file.
meta is the file metadata, which must match the metadata of the file on disk
exactly.
existing should be nil the first time this is called for a file,
and when remapping, should be the previous mappedFile.</p>
               
               <pre><code class="language-go">func openMapped(name string, meta string) (_ *mappedFile, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="place" data-name="place">
               <h3>
                  place 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#place" class="anchor" title="Link to place">#</a>
               </h3>
               
               <pre><code class="language-go">func (m *mappedFile) place(limit uint32, name string) (start uint32, end uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFile" data-name="readFile">
               <h3>
                  readFile 
                  <span class="badge">function</span>
                  
                  <a href="#readFile" class="anchor" title="Link to readFile">#</a>
               </h3>
               
               <pre><code class="language-go">func readFile(f *file) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readers" data-name="readers">
               <h3>
                  readers 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readers" class="anchor" title="Link to readers">#</a>
               </h3>
               
               <pre><code class="language-go">func (b counterStateBits) readers() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="refresh" data-name="refresh">
               <h3>
                  refresh 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#refresh" class="anchor" title="Link to refresh">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Counter) refresh()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="register" data-name="register">
               <h3>
                  register 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#register" class="anchor" title="Link to register">#</a>
               </h3>
               
               <p>register ensures that the counter c is registered with the file.</p>
               
               <pre><code class="language-go">func (f *file) register(c *Counter)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="releaseLock" data-name="releaseLock">
               <h3>
                  releaseLock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#releaseLock" class="anchor" title="Link to releaseLock">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Counter) releaseLock(state counterStateBits)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="releaseReader" data-name="releaseReader">
               <h3>
                  releaseReader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#releaseReader" class="anchor" title="Link to releaseReader">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *Counter) releaseReader(state counterStateBits)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rotate" data-name="rotate">
               <h3>
                  rotate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rotate" class="anchor" title="Link to rotate">#</a>
               </h3>
               
               <p>rotate checks to see whether the file f needs to be rotated,
meaning to start a new counter file with a different date in the name.
rotate is also used to open the file initially, meaning f.current can be nil.
In general rotate should be called just once for each file.
rotate will arrange a timer to call itself again when necessary.</p>
               
               <pre><code class="language-go">func (f *file) rotate()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rotate1" data-name="rotate1">
               <h3>
                  rotate1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rotate1" class="anchor" title="Link to rotate1">#</a>
               </h3>
               
               <p>rotate1 rotates the current counter file, returning its expiry, or the zero
time if rotation failed.</p>
               
               <pre><code class="language-go">func (f *file) rotate1() time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="round" data-name="round">
               <h3>
                  round 
                  <span class="badge">function</span>
                  
                  <a href="#round" class="anchor" title="Link to round">#</a>
               </h3>
               
               <p>round returns x rounded up to the next multiple of unit,
which must be a power of two.</p>
               
               <pre><code class="language-go">func round(x T, unit T) T</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setHavePtr" data-name="setHavePtr">
               <h3>
                  setHavePtr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setHavePtr" class="anchor" title="Link to setHavePtr">#</a>
               </h3>
               
               <pre><code class="language-go">func (b counterStateBits) setHavePtr() counterStateBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setLocked" data-name="setLocked">
               <h3>
                  setLocked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setLocked" class="anchor" title="Link to setLocked">#</a>
               </h3>
               
               <pre><code class="language-go">func (b counterStateBits) setLocked() counterStateBits</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="update" data-name="update">
               <h3>
                  update 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#update" class="anchor" title="Link to update">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *counterState) update(old *counterStateBits, new counterStateBits) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="weekEnd" data-name="weekEnd">
               <h3>
                  weekEnd 
                  <span class="badge">function</span>
                  
                  <a href="#weekEnd" class="anchor" title="Link to weekEnd">#</a>
               </h3>
               
               <p>weekEnd returns the day of the week on which uploads occur (and therefore
counters expire).
Reads the weekends file, creating one if none exists.</p>
               
               <pre><code class="language-go">func weekEnd() (time.Weekday, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeEntryAt" data-name="writeEntryAt">
               <h3>
                  writeEntryAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeEntryAt" class="anchor" title="Link to writeEntryAt">#</a>
               </h3>
               
               <p>writeEntryAt writes a new counter record at the given offset.
See the documentation for [mappedFile] for a description of the counter record layout.
writeEntryAt only returns false in the presence of some form of corruption:
an offset outside the bounds of the record region in the mapped file.</p>
               
               <pre><code class="language-go">func (m *mappedFile) writeEntryAt(off uint32, name string) (next *atomic.Uint32, v *atomic.Uint64, ok bool)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>