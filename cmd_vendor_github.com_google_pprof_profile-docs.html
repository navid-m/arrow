<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - profile</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>profile</code>
         </h1>
         <hr />
         
         <article class="global" data-name="reservedNames">
            <h2>reservedNames</h2>
            <hr />
            
            <pre><code>reservedNames</code></pre>
         </article>
         
         <article class="global" data-name="bracketRx">
            <h2>bracketRx</h2>
            <hr />
            
            <pre><code>bracketRx</code></pre>
         </article>
         
         <article class="global" data-name="profileDecoder">
            <h2>profileDecoder</h2>
            <hr />
            
            <pre><code>profileDecoder</code></pre>
         </article>
         
         <article class="global" data-name="valueTypeDecoder">
            <h2>valueTypeDecoder</h2>
            <hr />
            
            <pre><code>valueTypeDecoder</code></pre>
         </article>
         
         <article class="global" data-name="sampleDecoder">
            <h2>sampleDecoder</h2>
            <hr />
            
            <pre><code>sampleDecoder</code></pre>
         </article>
         
         <article class="global" data-name="labelDecoder">
            <h2>labelDecoder</h2>
            <hr />
            
            <pre><code>labelDecoder</code></pre>
         </article>
         
         <article class="global" data-name="mappingDecoder">
            <h2>mappingDecoder</h2>
            <hr />
            
            <pre><code>mappingDecoder</code></pre>
         </article>
         
         <article class="global" data-name="locationDecoder">
            <h2>locationDecoder</h2>
            <hr />
            
            <pre><code>locationDecoder</code></pre>
         </article>
         
         <article class="global" data-name="lineDecoder">
            <h2>lineDecoder</h2>
            <hr />
            
            <pre><code>lineDecoder</code></pre>
         </article>
         
         <article class="global" data-name="functionDecoder">
            <h2>functionDecoder</h2>
            <hr />
            
            <pre><code>functionDecoder</code></pre>
         </article>
         
         <article class="global" data-name="attributeRx">
            <h2>attributeRx</h2>
            <hr />
            
            <pre><code>attributeRx</code></pre>
         </article>
         
         <article class="global" data-name="javaSampleRx">
            <h2>javaSampleRx</h2>
            <hr />
            
            <pre><code>javaSampleRx</code></pre>
         </article>
         
         <article class="global" data-name="javaLocationRx">
            <h2>javaLocationRx</h2>
            <hr />
            
            <pre><code>javaLocationRx</code></pre>
         </article>
         
         <article class="global" data-name="javaLocationFileLineRx">
            <h2>javaLocationFileLineRx</h2>
            <hr />
            
            <pre><code>javaLocationFileLineRx</code></pre>
         </article>
         
         <article class="global" data-name="javaLocationPathRx">
            <h2>javaLocationPathRx</h2>
            <hr />
            
            <pre><code>javaLocationPathRx</code></pre>
         </article>
         
         <article class="global" data-name="countStartRE">
            <h2>countStartRE</h2>
            <hr />
            
            <pre><code>countStartRE</code></pre>
         </article>
         
         <article class="global" data-name="countRE">
            <h2>countRE</h2>
            <hr />
            
            <pre><code>countRE</code></pre>
         </article>
         
         <article class="global" data-name="heapHeaderRE">
            <h2>heapHeaderRE</h2>
            <hr />
            
            <pre><code>heapHeaderRE</code></pre>
         </article>
         
         <article class="global" data-name="heapSampleRE">
            <h2>heapSampleRE</h2>
            <hr />
            
            <pre><code>heapSampleRE</code></pre>
         </article>
         
         <article class="global" data-name="contentionSampleRE">
            <h2>contentionSampleRE</h2>
            <hr />
            
            <pre><code>contentionSampleRE</code></pre>
         </article>
         
         <article class="global" data-name="hexNumberRE">
            <h2>hexNumberRE</h2>
            <hr />
            
            <pre><code>hexNumberRE</code></pre>
         </article>
         
         <article class="global" data-name="growthHeaderRE">
            <h2>growthHeaderRE</h2>
            <hr />
            
            <pre><code>growthHeaderRE</code></pre>
         </article>
         
         <article class="global" data-name="fragmentationHeaderRE">
            <h2>fragmentationHeaderRE</h2>
            <hr />
            
            <pre><code>fragmentationHeaderRE</code></pre>
         </article>
         
         <article class="global" data-name="threadzStartRE">
            <h2>threadzStartRE</h2>
            <hr />
            
            <pre><code>threadzStartRE</code></pre>
         </article>
         
         <article class="global" data-name="threadStartRE">
            <h2>threadStartRE</h2>
            <hr />
            
            <pre><code>threadStartRE</code></pre>
         </article>
         
         <article class="global" data-name="spaceDigits">
            <h2>spaceDigits</h2>
            <hr />
            
            <p>Regular expressions to parse process mappings. Support the format used by Linux /proc/.../maps and other tools.
Recommended format:
Start   End     object file name     offset(optional)   linker build id
0x40000-0x80000 /path/to/binary      (@FF00)            abc123456</p>
            
            <pre><code>spaceDigits</code></pre>
         </article>
         
         <article class="global" data-name="hexPair">
            <h2>hexPair</h2>
            <hr />
            
            <pre><code>hexPair</code></pre>
         </article>
         
         <article class="global" data-name="oSpace">
            <h2>oSpace</h2>
            <hr />
            
            <pre><code>oSpace</code></pre>
         </article>
         
         <article class="global" data-name="cHex">
            <h2>cHex</h2>
            <hr />
            
            <p>Capturing expressions.</p>
            
            <pre><code>cHex</code></pre>
         </article>
         
         <article class="global" data-name="cHexRange">
            <h2>cHexRange</h2>
            <hr />
            
            <pre><code>cHexRange</code></pre>
         </article>
         
         <article class="global" data-name="cSpaceString">
            <h2>cSpaceString</h2>
            <hr />
            
            <pre><code>cSpaceString</code></pre>
         </article>
         
         <article class="global" data-name="cSpaceHex">
            <h2>cSpaceHex</h2>
            <hr />
            
            <pre><code>cSpaceHex</code></pre>
         </article>
         
         <article class="global" data-name="cSpaceAtOffset">
            <h2>cSpaceAtOffset</h2>
            <hr />
            
            <pre><code>cSpaceAtOffset</code></pre>
         </article>
         
         <article class="global" data-name="cPerm">
            <h2>cPerm</h2>
            <hr />
            
            <pre><code>cPerm</code></pre>
         </article>
         
         <article class="global" data-name="procMapsRE">
            <h2>procMapsRE</h2>
            <hr />
            
            <pre><code>procMapsRE</code></pre>
         </article>
         
         <article class="global" data-name="briefMapsRE">
            <h2>briefMapsRE</h2>
            <hr />
            
            <pre><code>briefMapsRE</code></pre>
         </article>
         
         <article class="global" data-name="logInfoRE">
            <h2>logInfoRE</h2>
            <hr />
            
            <p>Regular expression to parse log data, of the form:
... file:line] msg...</p>
            
            <pre><code>logInfoRE</code></pre>
         </article>
         
         <article class="global" data-name="cpuInts">
            <h2>cpuInts</h2>
            <hr />
            
            <pre><code>cpuInts</code></pre>
         </article>
         
         <article class="global" data-name="memoryMapSentinels">
            <h2>memoryMapSentinels</h2>
            <hr />
            
            <pre><code>memoryMapSentinels</code></pre>
         </article>
         
         <article class="global" data-name="heapzSampleTypes">
            <h2>heapzSampleTypes</h2>
            <hr />
            
            <pre><code>heapzSampleTypes</code></pre>
         </article>
         
         <article class="global" data-name="contentionzSampleTypes">
            <h2>contentionzSampleTypes</h2>
            <hr />
            
            <pre><code>contentionzSampleTypes</code></pre>
         </article>
         
         <article class="global" data-name="allocRxStr">
            <h2>allocRxStr</h2>
            <hr />
            
            <pre><code>allocRxStr</code></pre>
         </article>
         
         <article class="global" data-name="allocSkipRxStr">
            <h2>allocSkipRxStr</h2>
            <hr />
            
            <pre><code>allocSkipRxStr</code></pre>
         </article>
         
         <article class="global" data-name="cpuProfilerRxStr">
            <h2>cpuProfilerRxStr</h2>
            <hr />
            
            <pre><code>cpuProfilerRxStr</code></pre>
         </article>
         
         <article class="global" data-name="lockRxStr">
            <h2>lockRxStr</h2>
            <hr />
            
            <pre><code>lockRxStr</code></pre>
         </article>
         
         <article class="global" data-name="errUnrecognized">
            <h2>errUnrecognized</h2>
            <hr />
            
            <pre><code>errUnrecognized</code></pre>
         </article>
         
         <article class="global" data-name="errMalformed">
            <h2>errMalformed</h2>
            <hr />
            
            <pre><code>errMalformed</code></pre>
         </article>
         
         <article class="global" data-name="errNoData">
            <h2>errNoData</h2>
            <hr />
            
            <pre><code>errNoData</code></pre>
         </article>
         
         <article class="global" data-name="errConcatProfile">
            <h2>errConcatProfile</h2>
            <hr />
            
            <pre><code>errConcatProfile</code></pre>
         </article>
         
         <article class="global" data-name="libRx">
            <h2>libRx</h2>
            <hr />
            
            <pre><code>libRx</code></pre>
         </article>
          
         <article class="struct" data-name="buffer">
            <h2>type buffer struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">field int
typ int
u64 uint64
data []byte
tmp []byte
tmpLines []Line</code></pre>
         </article>
         
         <article class="struct" data-name="profileMerger">
            <h2>type profileMerger struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">p *Profile
locationsByID locationIDMap
functionsByID *ast.MapType
mappingsByID *ast.MapType
samples *ast.MapType
locations *ast.MapType
functions *ast.MapType
mappings *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="mapInfo">
            <h2>type mapInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">m *Mapping
offset int64</code></pre>
         </article>
         
         <article class="struct" data-name="locationKey">
            <h2>type locationKey struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">addr uint64
mappingID uint64
lines string
isFolded bool</code></pre>
         </article>
         
         <article class="struct" data-name="mappingKey">
            <h2>type mappingKey struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">size uint64
offset uint64
buildIDOrFile string</code></pre>
         </article>
         
         <article class="struct" data-name="functionKey">
            <h2>type functionKey struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">startLine int64
name string
systemName string
fileName string</code></pre>
         </article>
         
         <article class="struct" data-name="locationIDMap">
            <h2>type locationIDMap struct</h2>
            <hr />
            
            <p>locationIDMap is like a map[uint64]*Location, but provides efficiency for
ids that are densely numbered, which is often the case.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">dense []*Location
sparse *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="Profile">
            <h2>type Profile struct</h2>
            <hr />
            
            <p>Profile is an in-memory representation of profile.proto.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">SampleType []*ValueType
DefaultSampleType string
Sample []*Sample
Mapping []*Mapping
Location []*Location
Function []*Function
Comments []string
DocURL string
DropFrames string
KeepFrames string
TimeNanos int64
DurationNanos int64
PeriodType *ValueType
Period int64
encodeMu sync.Mutex
commentX []int64
docURLX int64
dropFramesX int64
keepFramesX int64
stringTable []string
defaultSampleTypeX int64</code></pre>
         </article>
         
         <article class="struct" data-name="ValueType">
            <h2>type ValueType struct</h2>
            <hr />
            
            <p>ValueType corresponds to Profile.ValueType</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Type string
Unit string
typeX int64
unitX int64</code></pre>
         </article>
         
         <article class="struct" data-name="Sample">
            <h2>type Sample struct</h2>
            <hr />
            
            <p>Sample corresponds to Profile.Sample</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Location []*Location
Value []int64
Label *ast.MapType
NumLabel *ast.MapType
NumUnit *ast.MapType
locationIDX []uint64
labelX []label</code></pre>
         </article>
         
         <article class="struct" data-name="label">
            <h2>type label struct</h2>
            <hr />
            
            <p>label corresponds to Profile.Label</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">keyX int64
strX int64
numX int64
unitX int64</code></pre>
         </article>
         
         <article class="struct" data-name="Mapping">
            <h2>type Mapping struct</h2>
            <hr />
            
            <p>Mapping corresponds to Profile.Mapping</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ID uint64
Start uint64
Limit uint64
Offset uint64
File string
BuildID string
HasFunctions bool
HasFilenames bool
HasLineNumbers bool
HasInlineFrames bool
fileX int64
buildIDX int64
KernelRelocationSymbol string</code></pre>
         </article>
         
         <article class="struct" data-name="Location">
            <h2>type Location struct</h2>
            <hr />
            
            <p>Location corresponds to Profile.Location</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ID uint64
Mapping *Mapping
Address uint64
Line []Line
IsFolded bool
mappingIDX uint64</code></pre>
         </article>
         
         <article class="struct" data-name="Line">
            <h2>type Line struct</h2>
            <hr />
            
            <p>Line corresponds to Profile.Line</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Function *Function
Line int64
Column int64
functionIDX uint64</code></pre>
         </article>
         
         <article class="struct" data-name="Function">
            <h2>type Function struct</h2>
            <hr />
            
            <p>Function corresponds to Profile.Function</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ID uint64
Name string
SystemName string
Filename string
StartLine int64
nameX int64
systemNameX int64
filenameX int64</code></pre>
         </article>
          
         <article class="function" data-name="marshal">
            <h2>marshal</h2>
            <hr />
            
            <pre><code>func marshal(m message) []byte</code></pre>
         </article>
         
         <article class="function" data-name="encodeVarint">
            <h2>encodeVarint</h2>
            <hr />
            
            <pre><code>func encodeVarint(b *buffer, x uint64)</code></pre>
         </article>
         
         <article class="function" data-name="encodeLength">
            <h2>encodeLength</h2>
            <hr />
            
            <pre><code>func encodeLength(b *buffer, tag int, len int)</code></pre>
         </article>
         
         <article class="function" data-name="encodeUint64">
            <h2>encodeUint64</h2>
            <hr />
            
            <pre><code>func encodeUint64(b *buffer, tag int, x uint64)</code></pre>
         </article>
         
         <article class="function" data-name="encodeUint64s">
            <h2>encodeUint64s</h2>
            <hr />
            
            <pre><code>func encodeUint64s(b *buffer, tag int, x []uint64)</code></pre>
         </article>
         
         <article class="function" data-name="encodeUint64Opt">
            <h2>encodeUint64Opt</h2>
            <hr />
            
            <pre><code>func encodeUint64Opt(b *buffer, tag int, x uint64)</code></pre>
         </article>
         
         <article class="function" data-name="encodeInt64">
            <h2>encodeInt64</h2>
            <hr />
            
            <pre><code>func encodeInt64(b *buffer, tag int, x int64)</code></pre>
         </article>
         
         <article class="function" data-name="encodeInt64s">
            <h2>encodeInt64s</h2>
            <hr />
            
            <pre><code>func encodeInt64s(b *buffer, tag int, x []int64)</code></pre>
         </article>
         
         <article class="function" data-name="encodeInt64Opt">
            <h2>encodeInt64Opt</h2>
            <hr />
            
            <pre><code>func encodeInt64Opt(b *buffer, tag int, x int64)</code></pre>
         </article>
         
         <article class="function" data-name="encodeString">
            <h2>encodeString</h2>
            <hr />
            
            <pre><code>func encodeString(b *buffer, tag int, x string)</code></pre>
         </article>
         
         <article class="function" data-name="encodeStrings">
            <h2>encodeStrings</h2>
            <hr />
            
            <pre><code>func encodeStrings(b *buffer, tag int, x []string)</code></pre>
         </article>
         
         <article class="function" data-name="encodeBool">
            <h2>encodeBool</h2>
            <hr />
            
            <pre><code>func encodeBool(b *buffer, tag int, x bool)</code></pre>
         </article>
         
         <article class="function" data-name="encodeBoolOpt">
            <h2>encodeBoolOpt</h2>
            <hr />
            
            <pre><code>func encodeBoolOpt(b *buffer, tag int, x bool)</code></pre>
         </article>
         
         <article class="function" data-name="encodeMessage">
            <h2>encodeMessage</h2>
            <hr />
            
            <pre><code>func encodeMessage(b *buffer, tag int, m message)</code></pre>
         </article>
         
         <article class="function" data-name="unmarshal">
            <h2>unmarshal</h2>
            <hr />
            
            <pre><code>func unmarshal(data []byte, m message) err error</code></pre>
         </article>
         
         <article class="function" data-name="le64">
            <h2>le64</h2>
            <hr />
            
            <pre><code>func le64(p []byte) uint64</code></pre>
         </article>
         
         <article class="function" data-name="le32">
            <h2>le32</h2>
            <hr />
            
            <pre><code>func le32(p []byte) uint32</code></pre>
         </article>
         
         <article class="function" data-name="decodeVarint">
            <h2>decodeVarint</h2>
            <hr />
            
            <pre><code>func decodeVarint(data []byte) (uint64, []byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="decodeField">
            <h2>decodeField</h2>
            <hr />
            
            <pre><code>func decodeField(b *buffer, data []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="checkType">
            <h2>checkType</h2>
            <hr />
            
            <pre><code>func checkType(b *buffer, typ int) error</code></pre>
         </article>
         
         <article class="function" data-name="decodeMessage">
            <h2>decodeMessage</h2>
            <hr />
            
            <pre><code>func decodeMessage(b *buffer, m message) error</code></pre>
         </article>
         
         <article class="function" data-name="decodeInt64">
            <h2>decodeInt64</h2>
            <hr />
            
            <pre><code>func decodeInt64(b *buffer, x *int64) error</code></pre>
         </article>
         
         <article class="function" data-name="decodeInt64s">
            <h2>decodeInt64s</h2>
            <hr />
            
            <pre><code>func decodeInt64s(b *buffer, x *[]int64) error</code></pre>
         </article>
         
         <article class="function" data-name="decodeUint64">
            <h2>decodeUint64</h2>
            <hr />
            
            <pre><code>func decodeUint64(b *buffer, x *uint64) error</code></pre>
         </article>
         
         <article class="function" data-name="decodeUint64s">
            <h2>decodeUint64s</h2>
            <hr />
            
            <pre><code>func decodeUint64s(b *buffer, x *[]uint64) error</code></pre>
         </article>
         
         <article class="function" data-name="decodeString">
            <h2>decodeString</h2>
            <hr />
            
            <pre><code>func decodeString(b *buffer, x *string) error</code></pre>
         </article>
         
         <article class="function" data-name="decodeStrings">
            <h2>decodeStrings</h2>
            <hr />
            
            <pre><code>func decodeStrings(b *buffer, x *[]string) error</code></pre>
         </article>
         
         <article class="function" data-name="decodeBool">
            <h2>decodeBool</h2>
            <hr />
            
            <pre><code>func decodeBool(b *buffer, x *bool) error</code></pre>
         </article>
         
         <article class="function" data-name="FilterSamplesByName">
            <h2>FilterSamplesByName</h2>
            <hr />
            
            <p>FilterSamplesByName filters the samples in a profile and only keeps
samples where at least one frame matches focus but none match ignore.
Returns true is the corresponding regexp matched at least one sample.</p>
            
            <pre><code>func FilterSamplesByName(focus *regexp.Regexp, ignore *regexp.Regexp, hide *regexp.Regexp, show *regexp.Regexp) (fm bool, im bool, hm bool, hnm bool)</code></pre>
         </article>
         
         <article class="function" data-name="ShowFrom">
            <h2>ShowFrom</h2>
            <hr />
            
            <p>ShowFrom drops all stack frames above the highest matching frame and returns
whether a match was found. If showFrom is nil it returns false and does not
modify the profile.

Example: consider a sample with frames [A, B, C, B], where A is the root.
ShowFrom(nil) returns false and has frames [A, B, C, B].
ShowFrom(A) returns true and has frames [A, B, C, B].
ShowFrom(B) returns true and has frames [B, C, B].
ShowFrom(C) returns true and has frames [C, B].
ShowFrom(D) returns false and drops the sample because no frames remain.</p>
            
            <pre><code>func ShowFrom(showFrom *regexp.Regexp) matched bool</code></pre>
         </article>
         
         <article class="function" data-name="filterShowFromLocation">
            <h2>filterShowFromLocation</h2>
            <hr />
            
            <p>filterShowFromLocation tests a showFrom regex against a location, removes
lines after the last match and returns whether a match was found. If the
mapping is matched, then all lines are kept.</p>
            
            <pre><code>func filterShowFromLocation(loc *Location, showFrom *regexp.Regexp) bool</code></pre>
         </article>
         
         <article class="function" data-name="lastMatchedLineIndex">
            <h2>lastMatchedLineIndex</h2>
            <hr />
            
            <p>lastMatchedLineIndex returns the index of the last line that matches a regex,
or -1 if no match is found.</p>
            
            <pre><code>func lastMatchedLineIndex(re *regexp.Regexp) int</code></pre>
         </article>
         
         <article class="function" data-name="FilterTagsByName">
            <h2>FilterTagsByName</h2>
            <hr />
            
            <p>FilterTagsByName filters the tags in a profile and only keeps
tags that match show and not hide.</p>
            
            <pre><code>func FilterTagsByName(show *regexp.Regexp, hide *regexp.Regexp) (sm bool, hm bool)</code></pre>
         </article>
         
         <article class="function" data-name="matchesName">
            <h2>matchesName</h2>
            <hr />
            
            <p>matchesName returns whether the location matches the regular
expression. It checks any available function names, file names, and
mapping object filename.</p>
            
            <pre><code>func matchesName(re *regexp.Regexp) bool</code></pre>
         </article>
         
         <article class="function" data-name="unmatchedLines">
            <h2>unmatchedLines</h2>
            <hr />
            
            <p>unmatchedLines returns the lines in the location that do not match
the regular expression.</p>
            
            <pre><code>func unmatchedLines(re *regexp.Regexp) []Line</code></pre>
         </article>
         
         <article class="function" data-name="matchedLines">
            <h2>matchedLines</h2>
            <hr />
            
            <p>matchedLines returns the lines in the location that match
the regular expression.</p>
            
            <pre><code>func matchedLines(re *regexp.Regexp) []Line</code></pre>
         </article>
         
         <article class="function" data-name="focusedAndNotIgnored">
            <h2>focusedAndNotIgnored</h2>
            <hr />
            
            <p>focusedAndNotIgnored looks up a slice of ids against a map of
focused/ignored locations. The map only contains locations that are
explicitly focused or ignored. Returns whether there is at least
one focused location but no ignored locations.</p>
            
            <pre><code>func focusedAndNotIgnored(locs []*Location, m *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="FilterSamplesByTag">
            <h2>FilterSamplesByTag</h2>
            <hr />
            
            <p>FilterSamplesByTag removes all samples from the profile, except
those that match focus and do not match the ignore regular
expression.</p>
            
            <pre><code>func FilterSamplesByTag(focus TagMatch, ignore TagMatch) (fm bool, im bool)</code></pre>
         </article>
         
         <article class="function" data-name="SampleIndexByName">
            <h2>SampleIndexByName</h2>
            <hr />
            
            <p>SampleIndexByName returns the appropriate index for a value of sample index.
If numeric, it returns the number, otherwise it looks up the text in the
profile sample types.</p>
            
            <pre><code>func SampleIndexByName(sampleIndex string) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="sampleTypes">
            <h2>sampleTypes</h2>
            <hr />
            
            <pre><code>func sampleTypes(p *Profile) []string</code></pre>
         </article>
         
         <article class="function" data-name="Compact">
            <h2>Compact</h2>
            <hr />
            
            <p>Compact performs garbage collection on a profile to remove any
unreferenced fields. This is useful to reduce the size of a profile
after samples or locations have been removed.</p>
            
            <pre><code>func Compact() *Profile</code></pre>
         </article>
         
         <article class="function" data-name="Merge">
            <h2>Merge</h2>
            <hr />
            
            <p>Merge merges all the profiles in profs into a single Profile.
Returns a new profile independent of the input profiles. The merged
profile is compacted to eliminate unused samples, locations,
functions and mappings. Profiles must have identical profile sample
and period types or the merge will fail. profile.Period of the
resulting profile will be the maximum of all profiles, and
profile.TimeNanos will be the earliest nonzero one. Merges are
associative with the caveat of the first profile having some
specialization in how headers are combined. There may be other
subtleties now or in the future regarding associativity.</p>
            
            <pre><code>func Merge(srcs []*Profile) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="Normalize">
            <h2>Normalize</h2>
            <hr />
            
            <p>Normalize normalizes the source profile by multiplying each value in profile by the
ratio of the sum of the base profile's values of that sample type to the sum of the
source profile's value of that sample type.</p>
            
            <pre><code>func Normalize(pb *Profile) error</code></pre>
         </article>
         
         <article class="function" data-name="isZeroSample">
            <h2>isZeroSample</h2>
            <hr />
            
            <pre><code>func isZeroSample(s *Sample) bool</code></pre>
         </article>
         
         <article class="function" data-name="mapSample">
            <h2>mapSample</h2>
            <hr />
            
            <pre><code>func mapSample(src *Sample) *Sample</code></pre>
         </article>
         
         <article class="function" data-name="sampleKey">
            <h2>sampleKey</h2>
            <hr />
            
            <pre><code>func sampleKey(sample *Sample) sampleKey</code></pre>
         </article>
         
         <article class="function" data-name="sortedKeys1">
            <h2>sortedKeys1</h2>
            <hr />
            
            <p>sortedKeys1 returns the sorted keys found in a string->[]string map.

Note: this is currently non-generic since github pprof runs golint,
which does not support generics. When that issue is fixed, it can
be merged with sortedKeys2 and made into a generic function.</p>
            
            <pre><code>func sortedKeys1(m *ast.MapType) []string</code></pre>
         </article>
         
         <article class="function" data-name="sortedKeys2">
            <h2>sortedKeys2</h2>
            <hr />
            
            <p>sortedKeys2 returns the sorted keys found in a string->[]int64 map.

Note: this is currently non-generic since github pprof runs golint,
which does not support generics. When that issue is fixed, it can
be merged with sortedKeys1 and made into a generic function.</p>
            
            <pre><code>func sortedKeys2(m *ast.MapType) []string</code></pre>
         </article>
         
         <article class="function" data-name="mapLocation">
            <h2>mapLocation</h2>
            <hr />
            
            <pre><code>func mapLocation(src *Location) *Location</code></pre>
         </article>
         
         <article class="function" data-name="key">
            <h2>key</h2>
            <hr />
            
            <p>key generates locationKey to be used as a key for maps.</p>
            
            <pre><code>func key() locationKey</code></pre>
         </article>
         
         <article class="function" data-name="mapMapping">
            <h2>mapMapping</h2>
            <hr />
            
            <pre><code>func mapMapping(src *Mapping) mapInfo</code></pre>
         </article>
         
         <article class="function" data-name="key">
            <h2>key</h2>
            <hr />
            
            <p>key generates encoded strings of Mapping to be used as a key for
maps.</p>
            
            <pre><code>func key() mappingKey</code></pre>
         </article>
         
         <article class="function" data-name="mapLine">
            <h2>mapLine</h2>
            <hr />
            
            <pre><code>func mapLine(src Line) Line</code></pre>
         </article>
         
         <article class="function" data-name="mapFunction">
            <h2>mapFunction</h2>
            <hr />
            
            <pre><code>func mapFunction(src *Function) *Function</code></pre>
         </article>
         
         <article class="function" data-name="key">
            <h2>key</h2>
            <hr />
            
            <p>key generates a struct to be used as a key for maps.</p>
            
            <pre><code>func key() functionKey</code></pre>
         </article>
         
         <article class="function" data-name="combineHeaders">
            <h2>combineHeaders</h2>
            <hr />
            
            <p>combineHeaders checks that all profiles can be merged and returns
their combined profile.</p>
            
            <pre><code>func combineHeaders(srcs []*Profile) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="compatible">
            <h2>compatible</h2>
            <hr />
            
            <p>compatible determines if two profiles can be compared/merged.
returns nil if the profiles are compatible; otherwise an error with
details on the incompatibility.</p>
            
            <pre><code>func compatible(pb *Profile) error</code></pre>
         </article>
         
         <article class="function" data-name="equalValueType">
            <h2>equalValueType</h2>
            <hr />
            
            <p>equalValueType returns true if the two value types are semantically
equal. It ignores the internal fields used during encode/decode.</p>
            
            <pre><code>func equalValueType(st1 *ValueType, st2 *ValueType) bool</code></pre>
         </article>
         
         <article class="function" data-name="makeLocationIDMap">
            <h2>makeLocationIDMap</h2>
            <hr />
            
            <pre><code>func makeLocationIDMap(n int) locationIDMap</code></pre>
         </article>
         
         <article class="function" data-name="get">
            <h2>get</h2>
            <hr />
            
            <pre><code>func get(id uint64) *Location</code></pre>
         </article>
         
         <article class="function" data-name="set">
            <h2>set</h2>
            <hr />
            
            <pre><code>func set(id uint64, loc *Location)</code></pre>
         </article>
         
         <article class="function" data-name="CompatibilizeSampleTypes">
            <h2>CompatibilizeSampleTypes</h2>
            <hr />
            
            <p>CompatibilizeSampleTypes makes profiles compatible to be compared/merged. It
keeps sample types that appear in all profiles only and drops/reorders the
sample types as necessary.

In the case of sample types order is not the same for given profiles the
order is derived from the first profile.

Profiles are modified in-place.

It returns an error if the sample type's intersection is empty.</p>
            
            <pre><code>func CompatibilizeSampleTypes(ps []*Profile) error</code></pre>
         </article>
         
         <article class="function" data-name="commonSampleTypes">
            <h2>commonSampleTypes</h2>
            <hr />
            
            <p>commonSampleTypes returns sample types that appear in all profiles in the
order how they ordered in the first profile.</p>
            
            <pre><code>func commonSampleTypes(ps []*Profile) []string</code></pre>
         </article>
         
         <article class="function" data-name="compatibilizeSampleTypes">
            <h2>compatibilizeSampleTypes</h2>
            <hr />
            
            <p>compatibilizeSampleTypes drops sample types that are not present in sTypes
list and reorder them if needed.

It sets DefaultSampleType to sType[0] if it is not in sType list.

It assumes that all sample types from the sTypes list are present in the
given profile otherwise it returns an error.</p>
            
            <pre><code>func compatibilizeSampleTypes(p *Profile, sTypes []string) error</code></pre>
         </article>
         
         <article class="function" data-name="searchValueType">
            <h2>searchValueType</h2>
            <hr />
            
            <pre><code>func searchValueType(vts []*ValueType, s string) int</code></pre>
         </article>
         
         <article class="function" data-name="simplifyFunc">
            <h2>simplifyFunc</h2>
            <hr />
            
            <p>simplifyFunc does some primitive simplification of function names.</p>
            
            <pre><code>func simplifyFunc(f string) string</code></pre>
         </article>
         
         <article class="function" data-name="Prune">
            <h2>Prune</h2>
            <hr />
            
            <p>Prune removes all nodes beneath a node matching dropRx, and not
matching keepRx. If the root node of a Sample matches, the sample
will have an empty stack.</p>
            
            <pre><code>func Prune(dropRx *regexp.Regexp, keepRx *regexp.Regexp)</code></pre>
         </article>
         
         <article class="function" data-name="RemoveUninteresting">
            <h2>RemoveUninteresting</h2>
            <hr />
            
            <p>RemoveUninteresting prunes and elides profiles using built-in
tables of uninteresting function names.</p>
            
            <pre><code>func RemoveUninteresting() error</code></pre>
         </article>
         
         <article class="function" data-name="PruneFrom">
            <h2>PruneFrom</h2>
            <hr />
            
            <p>PruneFrom removes all nodes beneath the lowest node matching dropRx, not including itself.

Please see the example below to understand this method as well as
the difference from Prune method.

A sample contains Location of [A,B,C,B,D] where D is the top frame and there's no inline.

PruneFrom(A) returns [A,B,C,B,D] because there's no node beneath A.
Prune(A, nil) returns [B,C,B,D] by removing A itself.

PruneFrom(B) returns [B,C,B,D] by removing all nodes beneath the first B when scanning from the bottom.
Prune(B, nil) returns [D] because a matching node is found by scanning from the root.</p>
            
            <pre><code>func PruneFrom(dropRx *regexp.Regexp)</code></pre>
         </article>
         
         <article class="function" data-name="decoder">
            <h2>decoder</h2>
            <hr />
            
            <pre><code>func decoder() []decoder</code></pre>
         </article>
         
         <article class="function" data-name="preEncode">
            <h2>preEncode</h2>
            <hr />
            
            <p>preEncode populates the unexported fields to be used by encode
(with suffix X) from the corresponding exported fields. The
exported fields are cleared up to facilitate testing.</p>
            
            <pre><code>func preEncode()</code></pre>
         </article>
         
         <article class="function" data-name="encode">
            <h2>encode</h2>
            <hr />
            
            <pre><code>func encode(b *buffer)</code></pre>
         </article>
         
         <article class="function" data-name="postDecode">
            <h2>postDecode</h2>
            <hr />
            
            <p>postDecode takes the unexported fields populated by decode (with
suffix X) and populates the corresponding exported fields.
The unexported fields are cleared up to facilitate testing.</p>
            
            <pre><code>func postDecode() error</code></pre>
         </article>
         
         <article class="function" data-name="padStringArray">
            <h2>padStringArray</h2>
            <hr />
            
            <p>padStringArray pads arr with enough empty strings to make arr
length l when arr's length is less than l.</p>
            
            <pre><code>func padStringArray(arr []string, l int) []string</code></pre>
         </article>
         
         <article class="function" data-name="decoder">
            <h2>decoder</h2>
            <hr />
            
            <pre><code>func decoder() []decoder</code></pre>
         </article>
         
         <article class="function" data-name="encode">
            <h2>encode</h2>
            <hr />
            
            <pre><code>func encode(b *buffer)</code></pre>
         </article>
         
         <article class="function" data-name="decoder">
            <h2>decoder</h2>
            <hr />
            
            <pre><code>func decoder() []decoder</code></pre>
         </article>
         
         <article class="function" data-name="encode">
            <h2>encode</h2>
            <hr />
            
            <pre><code>func encode(b *buffer)</code></pre>
         </article>
         
         <article class="function" data-name="decoder">
            <h2>decoder</h2>
            <hr />
            
            <pre><code>func decoder() []decoder</code></pre>
         </article>
         
         <article class="function" data-name="encode">
            <h2>encode</h2>
            <hr />
            
            <pre><code>func encode(b *buffer)</code></pre>
         </article>
         
         <article class="function" data-name="decoder">
            <h2>decoder</h2>
            <hr />
            
            <pre><code>func decoder() []decoder</code></pre>
         </article>
         
         <article class="function" data-name="encode">
            <h2>encode</h2>
            <hr />
            
            <pre><code>func encode(b *buffer)</code></pre>
         </article>
         
         <article class="function" data-name="decoder">
            <h2>decoder</h2>
            <hr />
            
            <pre><code>func decoder() []decoder</code></pre>
         </article>
         
         <article class="function" data-name="encode">
            <h2>encode</h2>
            <hr />
            
            <pre><code>func encode(b *buffer)</code></pre>
         </article>
         
         <article class="function" data-name="decoder">
            <h2>decoder</h2>
            <hr />
            
            <pre><code>func decoder() []decoder</code></pre>
         </article>
         
         <article class="function" data-name="encode">
            <h2>encode</h2>
            <hr />
            
            <pre><code>func encode(b *buffer)</code></pre>
         </article>
         
         <article class="function" data-name="decoder">
            <h2>decoder</h2>
            <hr />
            
            <pre><code>func decoder() []decoder</code></pre>
         </article>
         
         <article class="function" data-name="encode">
            <h2>encode</h2>
            <hr />
            
            <pre><code>func encode(b *buffer)</code></pre>
         </article>
         
         <article class="function" data-name="addString">
            <h2>addString</h2>
            <hr />
            
            <pre><code>func addString(strings *ast.MapType, s string) int64</code></pre>
         </article>
         
         <article class="function" data-name="getString">
            <h2>getString</h2>
            <hr />
            
            <pre><code>func getString(strings []string, strng *int64, err error) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="javaCPUProfile">
            <h2>javaCPUProfile</h2>
            <hr />
            
            <p>javaCPUProfile returns a new Profile from profilez data.
b is the profile bytes after the header, period is the profiling
period, and parse is a function to parse 8-byte chunks from the
profile in its native endianness.</p>
            
            <pre><code>func javaCPUProfile(b []byte, period int64, parse func) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseJavaProfile">
            <h2>parseJavaProfile</h2>
            <hr />
            
            <p>parseJavaProfile returns a new profile from heapz or contentionz
data. b is the profile bytes after the header.</p>
            
            <pre><code>func parseJavaProfile(b []byte) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseJavaHeader">
            <h2>parseJavaHeader</h2>
            <hr />
            
            <p>parseJavaHeader parses the attribute section on a java profile and
populates a profile. Returns the remainder of the buffer after all
attributes.</p>
            
            <pre><code>func parseJavaHeader(pType string, b []byte, p *Profile) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseJavaSamples">
            <h2>parseJavaSamples</h2>
            <hr />
            
            <p>parseJavaSamples parses the samples from a java profile and
populates the Samples in a profile. Returns the remainder of the
buffer after the samples.</p>
            
            <pre><code>func parseJavaSamples(pType string, b []byte, p *Profile) ([]byte, *ast.MapType, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseJavaLocations">
            <h2>parseJavaLocations</h2>
            <hr />
            
            <p>parseJavaLocations parses the location information in a java
profile and populates the Locations in a profile. It uses the
location addresses from the profile as both the ID of each
location.</p>
            
            <pre><code>func parseJavaLocations(b []byte, locs *ast.MapType, p *Profile) error</code></pre>
         </article>
         
         <article class="function" data-name="isSpaceOrComment">
            <h2>isSpaceOrComment</h2>
            <hr />
            
            <pre><code>func isSpaceOrComment(line string) bool</code></pre>
         </article>
         
         <article class="function" data-name="parseGoCount">
            <h2>parseGoCount</h2>
            <hr />
            
            <p>parseGoCount parses a Go count profile (e.g., threadcreate or
goroutine) and returns a new Profile.</p>
            
            <pre><code>func parseGoCount(b []byte) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="remapLocationIDs">
            <h2>remapLocationIDs</h2>
            <hr />
            
            <p>remapLocationIDs ensures there is a location for each address
referenced by a sample, and remaps the samples to point to the new
location ids.</p>
            
            <pre><code>func remapLocationIDs()</code></pre>
         </article>
         
         <article class="function" data-name="remapFunctionIDs">
            <h2>remapFunctionIDs</h2>
            <hr />
            
            <pre><code>func remapFunctionIDs()</code></pre>
         </article>
         
         <article class="function" data-name="remapMappingIDs">
            <h2>remapMappingIDs</h2>
            <hr />
            
            <p>remapMappingIDs matches location addresses with existing mappings
and updates them appropriately. This is O(N*M), if this ever shows
up as a bottleneck, evaluate sorting the mappings and doing a
binary search, which would make it O(N*log(M)).</p>
            
            <pre><code>func remapMappingIDs()</code></pre>
         </article>
         
         <article class="function" data-name="get32l">
            <h2>get32l</h2>
            <hr />
            
            <pre><code>func get32l(b []byte) (uint64, []byte)</code></pre>
         </article>
         
         <article class="function" data-name="get32b">
            <h2>get32b</h2>
            <hr />
            
            <pre><code>func get32b(b []byte) (uint64, []byte)</code></pre>
         </article>
         
         <article class="function" data-name="get64l">
            <h2>get64l</h2>
            <hr />
            
            <pre><code>func get64l(b []byte) (uint64, []byte)</code></pre>
         </article>
         
         <article class="function" data-name="get64b">
            <h2>get64b</h2>
            <hr />
            
            <pre><code>func get64b(b []byte) (uint64, []byte)</code></pre>
         </article>
         
         <article class="function" data-name="parseCPU">
            <h2>parseCPU</h2>
            <hr />
            
            <p>parseCPU parses a profilez legacy profile and returns a newly
populated Profile.

The general format for profilez samples is a sequence of words in
binary format. The first words are a header with the following data:

	1st word -- 0
	2nd word -- 3
	3rd word -- 0 if a c++ application, 1 if a java application.
	4th word -- Sampling period (in microseconds).
	5th word -- Padding.</p>
            
            <pre><code>func parseCPU(b []byte) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="cpuProfile">
            <h2>cpuProfile</h2>
            <hr />
            
            <p>cpuProfile returns a new Profile from C++ profilez data.
b is the profile bytes after the header, period is the profiling
period, and parse is a function to parse 8-byte chunks from the
profile in its native endianness.</p>
            
            <pre><code>func cpuProfile(b []byte, period int64, parse func) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="cleanupDuplicateLocations">
            <h2>cleanupDuplicateLocations</h2>
            <hr />
            
            <pre><code>func cleanupDuplicateLocations(p *Profile)</code></pre>
         </article>
         
         <article class="function" data-name="parseCPUSamples">
            <h2>parseCPUSamples</h2>
            <hr />
            
            <p>parseCPUSamples parses a collection of profilez samples from a
profile.

profilez samples are a repeated sequence of stack frames of the
form:

	1st word -- The number of times this stack was encountered.
	2nd word -- The size of the stack (StackSize).
	3rd word -- The first address on the stack.
	...
	StackSize + 2 -- The last address on the stack

The last stack trace is of the form:

	1st word -- 0
	2nd word -- 1
	3rd word -- 0

Addresses from stack traces may point to the next instruction after
each call. Optionally adjust by -1 to land somewhere on the actual
call (except for the leaf, which is not a call).</p>
            
            <pre><code>func parseCPUSamples(b []byte, parse func, adjust bool, p *Profile) ([]byte, *ast.MapType, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseHeap">
            <h2>parseHeap</h2>
            <hr />
            
            <p>parseHeap parses a heapz legacy or a growthz profile and
returns a newly populated Profile.</p>
            
            <pre><code>func parseHeap(b []byte) (p *Profile, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseHeapHeader">
            <h2>parseHeapHeader</h2>
            <hr />
            
            <pre><code>func parseHeapHeader(line string) (sampling string, period int64, hasAlloc bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseHeapSample">
            <h2>parseHeapSample</h2>
            <hr />
            
            <p>parseHeapSample parses a single row from a heap profile into a new Sample.</p>
            
            <pre><code>func parseHeapSample(line string, rate int64, sampling string, includeAlloc bool) (value []int64, blocksize int64, addrs []uint64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseHexAddresses">
            <h2>parseHexAddresses</h2>
            <hr />
            
            <p>parseHexAddresses extracts hex numbers from a string, attempts to convert
each to an unsigned 64-bit number and returns the resulting numbers as a
slice, or an error if the string contains hex numbers which are too large to
handle (which means a malformed profile).</p>
            
            <pre><code>func parseHexAddresses(s string) ([]uint64, error)</code></pre>
         </article>
         
         <article class="function" data-name="scaleHeapSample">
            <h2>scaleHeapSample</h2>
            <hr />
            
            <p>scaleHeapSample adjusts the data from a heapz Sample to
account for its probability of appearing in the collected
data. heapz profiles are a sampling of the memory allocations
requests in a program. We estimate the unsampled value by dividing
each collected sample by its probability of appearing in the
profile. heapz v2 profiles rely on a poisson process to determine
which samples to collect, based on the desired average collection
rate R. The probability of a sample of size S to appear in that
profile is 1-exp(-S/R).</p>
            
            <pre><code>func scaleHeapSample(count int64, size int64, rate int64) (int64, int64)</code></pre>
         </article>
         
         <article class="function" data-name="parseContention">
            <h2>parseContention</h2>
            <hr />
            
            <p>parseContention parses a mutex or contention profile. There are 2 cases:
"--- contentionz " for legacy C++ profiles (and backwards compatibility)
"--- mutex:" or "--- contention:" for profiles generated by the Go runtime.</p>
            
            <pre><code>func parseContention(b []byte) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseContentionSample">
            <h2>parseContentionSample</h2>
            <hr />
            
            <p>parseContentionSample parses a single row from a contention profile
into a new Sample.</p>
            
            <pre><code>func parseContentionSample(line string, period int64, cpuHz int64) (value []int64, addrs []uint64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseThread">
            <h2>parseThread</h2>
            <hr />
            
            <p>parseThread parses a Threadz profile and returns a new Profile.</p>
            
            <pre><code>func parseThread(b []byte) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseThreadSample">
            <h2>parseThreadSample</h2>
            <hr />
            
            <p>parseThreadSample parses a symbolized or unsymbolized stack trace.
Returns the first line after the traceback, the sample (or nil if
it hits a 'same-as-previous' marker) and an error.</p>
            
            <pre><code>func parseThreadSample(s *bufio.Scanner) (nextl string, addrs []uint64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseAdditionalSections">
            <h2>parseAdditionalSections</h2>
            <hr />
            
            <p>parseAdditionalSections parses any additional sections in the
profile, ignoring any unrecognized sections.</p>
            
            <pre><code>func parseAdditionalSections(s *bufio.Scanner, p *Profile) error</code></pre>
         </article>
         
         <article class="function" data-name="ParseProcMaps">
            <h2>ParseProcMaps</h2>
            <hr />
            
            <p>ParseProcMaps parses a memory map in the format of /proc/self/maps.
ParseMemoryMap should be called after setting on a profile to
associate locations to the corresponding mapping based on their
address.</p>
            
            <pre><code>func ParseProcMaps(rd io.Reader) ([]*Mapping, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseProcMapsFromScanner">
            <h2>parseProcMapsFromScanner</h2>
            <hr />
            
            <pre><code>func parseProcMapsFromScanner(s *bufio.Scanner) ([]*Mapping, error)</code></pre>
         </article>
         
         <article class="function" data-name="removeLoggingInfo">
            <h2>removeLoggingInfo</h2>
            <hr />
            
            <p>removeLoggingInfo detects and removes log prefix entries generated
by the glog package. If no logging prefix is detected, the string
is returned unmodified.</p>
            
            <pre><code>func removeLoggingInfo(line string) string</code></pre>
         </article>
         
         <article class="function" data-name="ParseMemoryMap">
            <h2>ParseMemoryMap</h2>
            <hr />
            
            <p>ParseMemoryMap parses a memory map in the format of
/proc/self/maps, and overrides the mappings in the current profile.
It renumbers the samples and locations in the profile correspondingly.</p>
            
            <pre><code>func ParseMemoryMap(rd io.Reader) error</code></pre>
         </article>
         
         <article class="function" data-name="ParseMemoryMapFromScanner">
            <h2>ParseMemoryMapFromScanner</h2>
            <hr />
            
            <p>ParseMemoryMapFromScanner parses a memory map in the format of
/proc/self/maps or a variety of legacy format, and overrides the
mappings in the current profile.  It renumbers the samples and
locations in the profile correspondingly.</p>
            
            <pre><code>func ParseMemoryMapFromScanner(s *bufio.Scanner) error</code></pre>
         </article>
         
         <article class="function" data-name="parseMappingEntry">
            <h2>parseMappingEntry</h2>
            <hr />
            
            <pre><code>func parseMappingEntry(l string) (*Mapping, error)</code></pre>
         </article>
         
         <article class="function" data-name="isMemoryMapSentinel">
            <h2>isMemoryMapSentinel</h2>
            <hr />
            
            <p>isMemoryMapSentinel returns true if the string contains one of the
known sentinels for memory map information.</p>
            
            <pre><code>func isMemoryMapSentinel(line string) bool</code></pre>
         </article>
         
         <article class="function" data-name="addLegacyFrameInfo">
            <h2>addLegacyFrameInfo</h2>
            <hr />
            
            <pre><code>func addLegacyFrameInfo()</code></pre>
         </article>
         
         <article class="function" data-name="isProfileType">
            <h2>isProfileType</h2>
            <hr />
            
            <pre><code>func isProfileType(p *Profile, types [][]string) bool</code></pre>
         </article>
         
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <p>Parse parses a profile and checks for its validity. The input
may be a gzip-compressed encoded protobuf or one of many legacy
profile formats which may be unsupported in the future.</p>
            
            <pre><code>func Parse(r io.Reader) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="ParseData">
            <h2>ParseData</h2>
            <hr />
            
            <p>ParseData parses a profile from a buffer and checks for its
validity.</p>
            
            <pre><code>func ParseData(data []byte) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseLegacy">
            <h2>parseLegacy</h2>
            <hr />
            
            <pre><code>func parseLegacy(data []byte) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="ParseUncompressed">
            <h2>ParseUncompressed</h2>
            <hr />
            
            <p>ParseUncompressed parses an uncompressed protobuf into a profile.</p>
            
            <pre><code>func ParseUncompressed(data []byte) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="massageMappings">
            <h2>massageMappings</h2>
            <hr />
            
            <p>massageMappings applies heuristic-based changes to the profile
mappings to account for quirks of some environments.</p>
            
            <pre><code>func massageMappings()</code></pre>
         </article>
         
         <article class="function" data-name="adjacent">
            <h2>adjacent</h2>
            <hr />
            
            <p>adjacent returns whether two mapping entries represent the same
mapping that has been split into two. Check that their addresses are adjacent,
and if the offsets match, if they are available.</p>
            
            <pre><code>func adjacent(m1 *Mapping, m2 *Mapping) bool</code></pre>
         </article>
         
         <article class="function" data-name="updateLocationMapping">
            <h2>updateLocationMapping</h2>
            <hr />
            
            <pre><code>func updateLocationMapping(from *Mapping, to *Mapping)</code></pre>
         </article>
         
         <article class="function" data-name="serialize">
            <h2>serialize</h2>
            <hr />
            
            <pre><code>func serialize(p *Profile) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write writes the profile as a gzip-compressed marshaled protobuf.</p>
            
            <pre><code>func Write(w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="WriteUncompressed">
            <h2>WriteUncompressed</h2>
            <hr />
            
            <p>WriteUncompressed writes the profile as a marshaled protobuf.</p>
            
            <pre><code>func WriteUncompressed(w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="CheckValid">
            <h2>CheckValid</h2>
            <hr />
            
            <p>CheckValid tests whether the profile is valid. Checks include, but are
not limited to:
  - len(Profile.Sample[n].value) == len(Profile.value_unit)
  - Sample.id has a corresponding Profile.Location</p>
            
            <pre><code>func CheckValid() error</code></pre>
         </article>
         
         <article class="function" data-name="Aggregate">
            <h2>Aggregate</h2>
            <hr />
            
            <p>Aggregate merges the locations in the profile into equivalence
classes preserving the request attributes. It also updates the
samples to point to the merged locations.</p>
            
            <pre><code>func Aggregate(inlineFrame bool, function bool, filename bool, linenumber bool, columnnumber bool, address bool) error</code></pre>
         </article>
         
         <article class="function" data-name="NumLabelUnits">
            <h2>NumLabelUnits</h2>
            <hr />
            
            <p>NumLabelUnits returns a map of numeric label keys to the units
associated with those keys and a map of those keys to any units
that were encountered but not used.
Unit for a given key is the first encountered unit for that key. If multiple
units are encountered for values paired with a particular key, then the first
unit encountered is used and all other units are returned in sorted order
in map of ignored units.
If no units are encountered for a particular key, the unit is then inferred
based on the key.</p>
            
            <pre><code>func NumLabelUnits() (*ast.MapType, *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String dumps a text representation of a profile. Intended mainly
for debugging purposes.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="string">
            <h2>string</h2>
            <hr />
            
            <p>string dumps a text representation of a mapping. Intended mainly
for debugging purposes.</p>
            
            <pre><code>func string() string</code></pre>
         </article>
         
         <article class="function" data-name="string">
            <h2>string</h2>
            <hr />
            
            <p>string dumps a text representation of a location. Intended mainly
for debugging purposes.</p>
            
            <pre><code>func string() string</code></pre>
         </article>
         
         <article class="function" data-name="string">
            <h2>string</h2>
            <hr />
            
            <p>string dumps a text representation of a sample. Intended mainly
for debugging purposes.</p>
            
            <pre><code>func string() string</code></pre>
         </article>
         
         <article class="function" data-name="labelsToString">
            <h2>labelsToString</h2>
            <hr />
            
            <p>labelsToString returns a string representation of a
map representing labels.</p>
            
            <pre><code>func labelsToString(labels *ast.MapType) string</code></pre>
         </article>
         
         <article class="function" data-name="numLabelsToString">
            <h2>numLabelsToString</h2>
            <hr />
            
            <p>numLabelsToString returns a string representation of a map
representing numeric labels.</p>
            
            <pre><code>func numLabelsToString(numLabels *ast.MapType, numUnits *ast.MapType) string</code></pre>
         </article>
         
         <article class="function" data-name="SetLabel">
            <h2>SetLabel</h2>
            <hr />
            
            <p>SetLabel sets the specified key to the specified value for all samples in the
profile.</p>
            
            <pre><code>func SetLabel(key string, value []string)</code></pre>
         </article>
         
         <article class="function" data-name="RemoveLabel">
            <h2>RemoveLabel</h2>
            <hr />
            
            <p>RemoveLabel removes all labels associated with the specified key for all
samples in the profile.</p>
            
            <pre><code>func RemoveLabel(key string)</code></pre>
         </article>
         
         <article class="function" data-name="HasLabel">
            <h2>HasLabel</h2>
            <hr />
            
            <p>HasLabel returns true if a sample has a label with indicated key and value.</p>
            
            <pre><code>func HasLabel(key string, value string) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetNumLabel">
            <h2>SetNumLabel</h2>
            <hr />
            
            <p>SetNumLabel sets the specified key to the specified value for all samples in the
profile. "unit" is a slice that describes the units that each corresponding member
of "values" is measured in (e.g. bytes or seconds).  If there is no relevant
unit for a given value, that member of "unit" should be the empty string.
"unit" must either have the same length as "value", or be nil.</p>
            
            <pre><code>func SetNumLabel(key string, value []int64, unit []string)</code></pre>
         </article>
         
         <article class="function" data-name="RemoveNumLabel">
            <h2>RemoveNumLabel</h2>
            <hr />
            
            <p>RemoveNumLabel removes all numerical labels associated with the specified key for all
samples in the profile.</p>
            
            <pre><code>func RemoveNumLabel(key string)</code></pre>
         </article>
         
         <article class="function" data-name="DiffBaseSample">
            <h2>DiffBaseSample</h2>
            <hr />
            
            <p>DiffBaseSample returns true if a sample belongs to the diff base and false
otherwise.</p>
            
            <pre><code>func DiffBaseSample() bool</code></pre>
         </article>
         
         <article class="function" data-name="Scale">
            <h2>Scale</h2>
            <hr />
            
            <p>Scale multiplies all sample values in a profile by a constant and keeps
only samples that have at least one non-zero value.</p>
            
            <pre><code>func Scale(ratio float64)</code></pre>
         </article>
         
         <article class="function" data-name="ScaleN">
            <h2>ScaleN</h2>
            <hr />
            
            <p>ScaleN multiplies each sample values in a sample by a different amount
and keeps only samples that have at least one non-zero value.</p>
            
            <pre><code>func ScaleN(ratios []float64) error</code></pre>
         </article>
         
         <article class="function" data-name="HasFunctions">
            <h2>HasFunctions</h2>
            <hr />
            
            <p>HasFunctions determines if all locations in this profile have
symbolized function information.</p>
            
            <pre><code>func HasFunctions() bool</code></pre>
         </article>
         
         <article class="function" data-name="HasFileLines">
            <h2>HasFileLines</h2>
            <hr />
            
            <p>HasFileLines determines if all locations in this profile have
symbolized file and line number information.</p>
            
            <pre><code>func HasFileLines() bool</code></pre>
         </article>
         
         <article class="function" data-name="Unsymbolizable">
            <h2>Unsymbolizable</h2>
            <hr />
            
            <p>Unsymbolizable returns true if a mapping points to a binary for which
locations can't be symbolized in principle, at least now. Examples are
"[vdso]", "[vsyscall]" and some others, see the code.</p>
            
            <pre><code>func Unsymbolizable() bool</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <p>Copy makes a fully independent copy of a profile.</p>
            
            <pre><code>func Copy() *Profile</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
