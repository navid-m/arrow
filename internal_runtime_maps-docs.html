<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - maps</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>maps</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"internal/abi"
"unsafe"
"internal/abi"
"internal/goarch"
"internal/runtime/sys"
"unsafe"
"internal/abi"
"internal/goarch"
"internal/runtime/math"
"internal/runtime/sys"
"unsafe"
"internal/abi"
"unsafe"
"internal/abi"
"internal/race"
"internal/runtime/sys"
"unsafe"
"internal/abi"
"internal/race"
"internal/runtime/sys"
"unsafe"
"internal/abi"
"internal/goarch"
"internal/race"
"internal/runtime/sys"
"unsafe"
"internal/abi"
"unsafe"
"internal/abi"
"internal/asan"
"internal/msan"
"internal/race"
"internal/runtime/sys"
"unsafe"
"internal/abi"
"internal/goarch"
"unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <p>Ensure the max capacity fits in uint16, used for capacity and growthLeft
below.</p>
               
               <pre><code>var _ = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bitsetDeleted" data-name="bitsetDeleted">
               <h3>
                  bitsetDeleted 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bitsetDeleted" class="anchor" title="Link to bitsetDeleted">#</a>
               </h3>
               
               <pre><code>const bitsetDeleted = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bitsetEmpty" data-name="bitsetEmpty">
               <h3>
                  bitsetEmpty 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bitsetEmpty" class="anchor" title="Link to bitsetEmpty">#</a>
               </h3>
               
               <pre><code>const bitsetEmpty = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bitsetLSB" data-name="bitsetLSB">
               <h3>
                  bitsetLSB 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bitsetLSB" class="anchor" title="Link to bitsetLSB">#</a>
               </h3>
               
               <pre><code>const bitsetLSB = 0x0101010101010101</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bitsetMSB" data-name="bitsetMSB">
               <h3>
                  bitsetMSB 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bitsetMSB" class="anchor" title="Link to bitsetMSB">#</a>
               </h3>
               
               <pre><code>const bitsetMSB = 0x8080808080808080</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctrlDeleted" data-name="ctrlDeleted">
               <h3>
                  ctrlDeleted 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctrlDeleted" class="anchor" title="Link to ctrlDeleted">#</a>
               </h3>
               
               <pre><code>const ctrlDeleted ctrl = 0b11111110</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctrlEmpty" data-name="ctrlEmpty">
               <h3>
                  ctrlEmpty 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctrlEmpty" class="anchor" title="Link to ctrlEmpty">#</a>
               </h3>
               
               <pre><code>const ctrlEmpty ctrl = 0b10000000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctrlGroupsSize" data-name="ctrlGroupsSize">
               <h3>
                  ctrlGroupsSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctrlGroupsSize" class="anchor" title="Link to ctrlGroupsSize">#</a>
               </h3>
               
               <pre><code>const ctrlGroupsSize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugLog" data-name="debugLog">
               <h3>
                  debugLog 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugLog" class="anchor" title="Link to debugLog">#</a>
               </h3>
               
               <pre><code>const debugLog = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNilAssign" data-name="errNilAssign">
               <h3>
                  errNilAssign 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNilAssign" class="anchor" title="Link to errNilAssign">#</a>
               </h3>
               
               <p>Pushed from runtime in order to use runtime.plainError
go:linkname errNilAssign</p>
               
               <pre><code>var errNilAssign error</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="groupSlotsOffset" data-name="groupSlotsOffset">
               <h3>
                  groupSlotsOffset 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#groupSlotsOffset" class="anchor" title="Link to groupSlotsOffset">#</a>
               </h3>
               
               <pre><code>const groupSlotsOffset = ctrlGroupsSize</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxAvgGroupLoad" data-name="maxAvgGroupLoad">
               <h3>
                  maxAvgGroupLoad 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxAvgGroupLoad" class="anchor" title="Link to maxAvgGroupLoad">#</a>
               </h3>
               
               <p>Maximum load factor prior to growing.
7/8 is the same load factor used by Abseil, but Abseil defaults to
16 slots per group, so they get two empty slots vs our one empty
slot. We may want to reevaluate if this is best for us.</p>
               
               <pre><code>const maxAvgGroupLoad = 7</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxTableCapacity" data-name="maxTableCapacity">
               <h3>
                  maxTableCapacity 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxTableCapacity" class="anchor" title="Link to maxTableCapacity">#</a>
               </h3>
               
               <p>Maximum size of a table before it is split at the directory level.
TODO: Completely made up value. This should be tuned for performance vs grow
latency.
TODO: This should likely be based on byte size, as copying costs will
dominate grow latency for large objects.</p>
               
               <pre><code>const maxTableCapacity = 1024</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="zeroVal" data-name="zeroVal">
               <h3>
                  zeroVal 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#zeroVal" class="anchor" title="Link to zeroVal">#</a>
               </h3>
               
               <p>Pull from runtime. It is important that is this the exact same copy as the
runtime because runtime.mapaccess1_fat compares the returned pointer with
&runtime.zeroVal[0].
TODO: move zeroVal to internal/abi?
go:linkname zeroVal runtime.zeroVal</p>
               
               <pre><code>var zeroVal [abi.ZeroValSize]byte</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="bitset" data-name="bitset">
               <h3>
                  bitset
                  <span class="badge type-badge">type</span>
                  <a href="#bitset" class="anchor" title="Link to bitset">#</a>
               </h3>
               
               <p>bitset represents a set of slots within a group.
The underlying representation depends on GOARCH.
On AMD64, bitset uses one bit per slot, where the bit is set if the slot is
part of the set. All of the ctrlGroup.match* methods are replaced with
intrinsics that return this packed representation.
On other architectures, bitset uses one byte per slot, where each byte is
either 0x80 if the slot is part of the set or 0x00 otherwise. This makes it
convenient to calculate for an entire group at once using standard
arithemetic instructions.</p>
               
               <pre><code>type bitset uint64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ctrl" data-name="ctrl">
               <h3>
                  ctrl
                  <span class="badge type-badge">type</span>
                  <a href="#ctrl" class="anchor" title="Link to ctrl">#</a>
               </h3>
               
               <p>Each slot in the hash table has a control byte which can have one of three
states: empty, deleted, and full. They have the following bit patterns:
empty: 1 0 0 0 0 0 0 0
deleted: 1 1 1 1 1 1 1 0
full: 0 h h h h h h h  // h represents the H1 hash bits
TODO(prattmic): Consider inverting the top bit so that the zero value is empty.</p>
               
               <pre><code>type ctrl uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ctrlGroup" data-name="ctrlGroup">
               <h3>
                  ctrlGroup
                  <span class="badge type-badge">type</span>
                  <a href="#ctrlGroup" class="anchor" title="Link to ctrlGroup">#</a>
               </h3>
               
               <p>ctrlGroup is a fixed size array of abi.SwissMapGroupSlots control bytes
stored in a uint64.</p>
               
               <pre><code>type ctrlGroup uint64</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Iter" data-name="Iter">
               <h3>
                  Iter
                  <span class="badge">struct</span>
                  <a href="#Iter" class="anchor" title="Link to Iter">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Iter struct {
key unsafe.Pointer
elem unsafe.Pointer
typ *abi.SwissMapType
m *Map
entryOffset uint64
dirOffset uint64
clearSeq uint64
globalDepth uint8
dirIdx int
tab *table
group groupReference
entryIdx uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Map" data-name="Map">
               <h3>
                  Map
                  <span class="badge">struct</span>
                  <a href="#Map" class="anchor" title="Link to Map">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Map struct {
used uint64
seed uintptr
dirPtr unsafe.Pointer
dirLen int
globalDepth uint8
globalShift uint8
writing uint8
clearSeq uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="groupReference" data-name="groupReference">
               <h3>
                  groupReference
                  <span class="badge">struct</span>
                  <a href="#groupReference" class="anchor" title="Link to groupReference">#</a>
               </h3>
               
               <p>groupReference is a wrapper type representing a single slot group stored at
data.
A group holds abi.SwissMapGroupSlots slots (key/elem pairs) plus their
control word.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type groupReference struct {
data unsafe.Pointer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="groupsReference" data-name="groupsReference">
               <h3>
                  groupsReference
                  <span class="badge">struct</span>
                  <a href="#groupsReference" class="anchor" title="Link to groupsReference">#</a>
               </h3>
               
               <p>groupsReference is a wrapper type describing an array of groups stored at
data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type groupsReference struct {
data unsafe.Pointer
lengthMask uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="probeSeq" data-name="probeSeq">
               <h3>
                  probeSeq
                  <span class="badge">struct</span>
                  <a href="#probeSeq" class="anchor" title="Link to probeSeq">#</a>
               </h3>
               
               <p>probeSeq maintains the state for a probe sequence that iterates through the
groups in a table. The sequence is a triangular progression of the form
p(i) := (i^2 + i)/2 + hash (mod mask+1)
The sequence effectively outputs the indexes of *groups*. The group
machinery allows us to check an entire group with minimal branching.
It turns out that this probe sequence visits every group exactly once if
the number of groups is a power of two, since (i^2+i)/2 is a bijection in
Z/(2^m). See https://en.wikipedia.org/wiki/Quadratic_probing</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type probeSeq struct {
mask uint64
offset uint64
index uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="table" data-name="table">
               <h3>
                  table
                  <span class="badge">struct</span>
                  <a href="#table" class="anchor" title="Link to table">#</a>
               </h3>
               
               <p>table is a Swiss table hash table structure.
Each table is a complete hash table implementation.
Map uses one or more tables to store entries. Extendible hashing (hash
prefix) is used to select the table to use for a specific key. Using
multiple tables enables incremental growth by growing only one table at a
time.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type table struct {
used uint16
capacity uint16
growthLeft uint16
localDepth uint8
index int
groups groupsReference
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Clear" data-name="Clear">
               <h3>
                  Clear 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Clear" class="anchor" title="Link to Clear">#</a>
               </h3>
               
               <p>Clear deletes all entries from the map resulting in an empty map.</p>
               
               <pre><code>func (m *Map) Clear(typ *abi.SwissMapType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clear" data-name="Clear">
               <h3>
                  Clear 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Clear" class="anchor" title="Link to Clear">#</a>
               </h3>
               
               <p>Clear deletes all entries from the map resulting in an empty map.</p>
               
               <pre><code>func (t *table) Clear(typ *abi.SwissMapType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Delete" data-name="Delete">
               <h3>
                  Delete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Delete" class="anchor" title="Link to Delete">#</a>
               </h3>
               
               <pre><code>func (m *Map) Delete(typ *abi.SwissMapType, key unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Delete" data-name="Delete">
               <h3>
                  Delete 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Delete" class="anchor" title="Link to Delete">#</a>
               </h3>
               
               <pre><code>func (t *table) Delete(typ *abi.SwissMapType, m *Map, hash uintptr, key unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Elem" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Elem" class="anchor" title="Link to Elem">#</a>
               </h3>
               
               <p>Key returns a pointer to the current element. nil indicates end of
iteration.
Must not be called prior to Next.</p>
               
               <pre><code>func (it *Iter) Elem() unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <p>Get performs a lookup of the key that key points to. It returns a pointer to
the element, or false if the key doesn't exist.</p>
               
               <pre><code>func (m *Map) Get(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <p>Get performs a lookup of the key that key points to. It returns a pointer to
the element, or false if the key doesn't exist.</p>
               
               <pre><code>func (t *table) Get(typ *abi.SwissMapType, m *Map, key unsafe.Pointer) (unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Init" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Init" class="anchor" title="Link to Init">#</a>
               </h3>
               
               <p>Init initializes Iter for iteration.</p>
               
               <pre><code>func (it *Iter) Init(typ *abi.SwissMapType, m *Map)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Initialized" data-name="Initialized">
               <h3>
                  Initialized 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Initialized" class="anchor" title="Link to Initialized">#</a>
               </h3>
               
               <pre><code>func (it *Iter) Initialized() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Key" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Key" class="anchor" title="Link to Key">#</a>
               </h3>
               
               <p>Key returns a pointer to the current key. nil indicates end of iteration.
Must not be called prior to Next.</p>
               
               <pre><code>func (it *Iter) Key() unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Map" data-name="Map">
               <h3>
                  Map 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Map" class="anchor" title="Link to Map">#</a>
               </h3>
               
               <p>Map returns the map this iterator is iterating over.</p>
               
               <pre><code>func (it *Iter) Map() *Map</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewEmptyMap" data-name="NewEmptyMap">
               <h3>
                  NewEmptyMap 
                  <span class="badge">function</span>
                  
                  <a href="#NewEmptyMap" class="anchor" title="Link to NewEmptyMap">#</a>
               </h3>
               
               <pre><code>func NewEmptyMap() *Map</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewMap" data-name="NewMap">
               <h3>
                  NewMap 
                  <span class="badge">function</span>
                  
                  <a href="#NewMap" class="anchor" title="Link to NewMap">#</a>
               </h3>
               
               <p>If m is non-nil, it should be used rather than allocating.
maxAlloc should be runtime.maxAlloc.
TODO(prattmic): Put maxAlloc somewhere accessible.</p>
               
               <pre><code>func NewMap(mt *abi.SwissMapType, hint uintptr, m *Map, maxAlloc uintptr) *Map</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <p>Next proceeds to the next element in iteration, which can be accessed via
the Key and Elem methods.
The table can be mutated during iteration, though there is no guarantee that
the mutations will be visible to the iteration.
Init must be called prior to Next.</p>
               
               <pre><code>func (it *Iter) Next()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Print" data-name="Print">
               <h3>
                  Print 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Print" class="anchor" title="Link to Print">#</a>
               </h3>
               
               <pre><code>func (t *table) Print(typ *abi.SwissMapType, m *Map)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Put" data-name="Put">
               <h3>
                  Put 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Put" class="anchor" title="Link to Put">#</a>
               </h3>
               
               <pre><code>func (m *Map) Put(typ *abi.SwissMapType, key unsafe.Pointer, elem unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PutSlot" data-name="PutSlot">
               <h3>
                  PutSlot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PutSlot" class="anchor" title="Link to PutSlot">#</a>
               </h3>
               
               <p>PutSlot returns a pointer to the element slot where an inserted element
should be written.
PutSlot never returns nil.</p>
               
               <pre><code>func (m *Map) PutSlot(typ *abi.SwissMapType, key unsafe.Pointer) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PutSlot" data-name="PutSlot">
               <h3>
                  PutSlot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PutSlot" class="anchor" title="Link to PutSlot">#</a>
               </h3>
               
               <p>PutSlot returns a pointer to the element slot where an inserted element
should be written, and ok if it returned a valid slot.
PutSlot returns ok false if the table was split and the Map needs to find
the new table.
hash must be the hash of key.</p>
               
               <pre><code>func (t *table) PutSlot(typ *abi.SwissMapType, m *Map, hash uintptr, key unsafe.Pointer) (unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Used" data-name="Used">
               <h3>
                  Used 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Used" class="anchor" title="Link to Used">#</a>
               </h3>
               
               <pre><code>func (t *table) Used() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Used" data-name="Used">
               <h3>
                  Used 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Used" class="anchor" title="Link to Used">#</a>
               </h3>
               
               <pre><code>func (m *Map) Used() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="alignUp" data-name="alignUp">
               <h3>
                  alignUp 
                  <span class="badge">function</span>
                  
                  <a href="#alignUp" class="anchor" title="Link to alignUp">#</a>
               </h3>
               
               <p>alignUp rounds n up to a multiple of a. a must be a power of 2.</p>
               
               <pre><code>func alignUp(n uintptr, a uintptr) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="alignUpPow2" data-name="alignUpPow2">
               <h3>
                  alignUpPow2 
                  <span class="badge">function</span>
                  
                  <a href="#alignUpPow2" class="anchor" title="Link to alignUpPow2">#</a>
               </h3>
               
               <p>alignUpPow2 rounds n up to the next power of 2.
Returns true if round up causes overflow.</p>
               
               <pre><code>func alignUpPow2(n uint64) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bitsetFirst" data-name="bitsetFirst">
               <h3>
                  bitsetFirst 
                  <span class="badge">function</span>
                  
                  <a href="#bitsetFirst" class="anchor" title="Link to bitsetFirst">#</a>
               </h3>
               
               <p>Portable implementation of first.
On AMD64, this is replaced with an intrisic that simply does
TrailingZeros64. There is no need to shift as the bitset is packed.</p>
               
               <pre><code>func bitsetFirst(b bitset) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bitsetLowestSet" data-name="bitsetLowestSet">
               <h3>
                  bitsetLowestSet 
                  <span class="badge">function</span>
                  
                  <a href="#bitsetLowestSet" class="anchor" title="Link to bitsetLowestSet">#</a>
               </h3>
               
               <p>Portable implementation of lowestSet.
On AMD64, this is replaced with an intrisic that checks the lowest bit.</p>
               
               <pre><code>func bitsetLowestSet(b bitset) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bitsetRemoveBelow" data-name="bitsetRemoveBelow">
               <h3>
                  bitsetRemoveBelow 
                  <span class="badge">function</span>
                  
                  <a href="#bitsetRemoveBelow" class="anchor" title="Link to bitsetRemoveBelow">#</a>
               </h3>
               
               <p>Portable implementation of removeBelow.
On AMD64, this is replaced with an intrisic that clears the lower i bits.</p>
               
               <pre><code>func bitsetRemoveBelow(b bitset, i uintptr) bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bitsetShiftOutLowest" data-name="bitsetShiftOutLowest">
               <h3>
                  bitsetShiftOutLowest 
                  <span class="badge">function</span>
                  
                  <a href="#bitsetShiftOutLowest" class="anchor" title="Link to bitsetShiftOutLowest">#</a>
               </h3>
               
               <p>Portable implementation of shiftOutLowest.
On AMD64, this is replaced with an intrisic that shifts a single bit.</p>
               
               <pre><code>func bitsetShiftOutLowest(b bitset) bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkInvariants" data-name="checkInvariants">
               <h3>
                  checkInvariants 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkInvariants" class="anchor" title="Link to checkInvariants">#</a>
               </h3>
               
               <pre><code>func (t *table) checkInvariants(typ *abi.SwissMapType, m *Map)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clearSmall" data-name="clearSmall">
               <h3>
                  clearSmall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#clearSmall" class="anchor" title="Link to clearSmall">#</a>
               </h3>
               
               <pre><code>func (m *Map) clearSmall(typ *abi.SwissMapType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ctrlGroupMatchEmpty" data-name="ctrlGroupMatchEmpty">
               <h3>
                  ctrlGroupMatchEmpty 
                  <span class="badge">function</span>
                  
                  <a href="#ctrlGroupMatchEmpty" class="anchor" title="Link to ctrlGroupMatchEmpty">#</a>
               </h3>
               
               <p>Portable implementation of matchEmpty.
Note: On AMD64, this is an intrinsic implemented with SIMD instructions. See
note on bitset about the packed instrinsified return value.</p>
               
               <pre><code>func ctrlGroupMatchEmpty(g ctrlGroup) bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ctrlGroupMatchEmptyOrDeleted" data-name="ctrlGroupMatchEmptyOrDeleted">
               <h3>
                  ctrlGroupMatchEmptyOrDeleted 
                  <span class="badge">function</span>
                  
                  <a href="#ctrlGroupMatchEmptyOrDeleted" class="anchor" title="Link to ctrlGroupMatchEmptyOrDeleted">#</a>
               </h3>
               
               <p>Portable implementation of matchEmptyOrDeleted.
Note: On AMD64, this is an intrinsic implemented with SIMD instructions. See
note on bitset about the packed instrinsified return value.</p>
               
               <pre><code>func ctrlGroupMatchEmptyOrDeleted(g ctrlGroup) bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ctrlGroupMatchFull" data-name="ctrlGroupMatchFull">
               <h3>
                  ctrlGroupMatchFull 
                  <span class="badge">function</span>
                  
                  <a href="#ctrlGroupMatchFull" class="anchor" title="Link to ctrlGroupMatchFull">#</a>
               </h3>
               
               <p>Portable implementation of matchFull.
Note: On AMD64, this is an intrinsic implemented with SIMD instructions. See
note on bitset about the packed instrinsified return value.</p>
               
               <pre><code>func ctrlGroupMatchFull(g ctrlGroup) bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ctrlGroupMatchH2" data-name="ctrlGroupMatchH2">
               <h3>
                  ctrlGroupMatchH2 
                  <span class="badge">function</span>
                  
                  <a href="#ctrlGroupMatchH2" class="anchor" title="Link to ctrlGroupMatchH2">#</a>
               </h3>
               
               <p>Portable implementation of matchH2.
Note: On AMD64, this is an intrinsic implemented with SIMD instructions. See
note on bitset about the packed instrinsified return value.</p>
               
               <pre><code>func ctrlGroupMatchH2(g ctrlGroup, h uintptr) bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ctrls" data-name="ctrls">
               <h3>
                  ctrls 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ctrls" class="anchor" title="Link to ctrls">#</a>
               </h3>
               
               <p>ctrls returns the group control word.</p>
               
               <pre><code>func (g *groupReference) ctrls() *ctrlGroup</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deleteSmall" data-name="deleteSmall">
               <h3>
                  deleteSmall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#deleteSmall" class="anchor" title="Link to deleteSmall">#</a>
               </h3>
               
               <pre><code>func (m *Map) deleteSmall(typ *abi.SwissMapType, hash uintptr, key unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="depthToShift" data-name="depthToShift">
               <h3>
                  depthToShift 
                  <span class="badge">function</span>
                  
                  <a href="#depthToShift" class="anchor" title="Link to depthToShift">#</a>
               </h3>
               
               <pre><code>func depthToShift(depth uint8) uint8</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="directoryAt" data-name="directoryAt">
               <h3>
                  directoryAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#directoryAt" class="anchor" title="Link to directoryAt">#</a>
               </h3>
               
               <pre><code>func (m *Map) directoryAt(i uintptr) *table</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="directoryIndex" data-name="directoryIndex">
               <h3>
                  directoryIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#directoryIndex" class="anchor" title="Link to directoryIndex">#</a>
               </h3>
               
               <pre><code>func (m *Map) directoryIndex(hash uintptr) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="directorySet" data-name="directorySet">
               <h3>
                  directorySet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#directorySet" class="anchor" title="Link to directorySet">#</a>
               </h3>
               
               <pre><code>func (m *Map) directorySet(i uintptr, nt *table)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dump" data-name="dump">
               <h3>
                  dump 
                  <span class="badge">function</span>
                  
                  <a href="#dump" class="anchor" title="Link to dump">#</a>
               </h3>
               
               <p>TODO(prattmic): not in hex because print doesn't have a way to print in hex
outside the runtime.</p>
               
               <pre><code>func dump(ptr unsafe.Pointer, size uintptr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="elem" data-name="elem">
               <h3>
                  elem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#elem" class="anchor" title="Link to elem">#</a>
               </h3>
               
               <p>elem returns a pointer to the element at index i.</p>
               
               <pre><code>func (g *groupReference) elem(typ *abi.SwissMapType, i uintptr) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fatal" data-name="fatal">
               <h3>
                  fatal 
                  <span class="badge">function</span>
                  
                  <a href="#fatal" class="anchor" title="Link to fatal">#</a>
               </h3>
               
               <p>go:linkname fatal</p>
               
               <pre><code>func fatal(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="first" data-name="first">
               <h3>
                  first 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#first" class="anchor" title="Link to first">#</a>
               </h3>
               
               <p>first returns the relative index of the first control byte in the group that
is in the set.
Preconditions: b is not 0 (empty).</p>
               
               <pre><code>func (b bitset) first() uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="get" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#get" class="anchor" title="Link to get">#</a>
               </h3>
               
               <p>get returns the i-th control byte.</p>
               
               <pre><code>func (g *ctrlGroup) get(i uintptr) ctrl</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getWithKey" data-name="getWithKey">
               <h3>
                  getWithKey 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getWithKey" class="anchor" title="Link to getWithKey">#</a>
               </h3>
               
               <p>getWithKey performs a lookup of key, returning a pointer to the version of
the key in the map in addition to the element.
This is relevant when multiple different key values compare equal (e.g.,
+0.0 and -0.0). When a grow occurs during iteration, iteration perform a
lookup of keys from the old group in the new group in order to correctly
expose updated elements. For NeedsKeyUpdate keys, iteration also must return
the new key value, not the old key value.
hash must be the hash of the key.</p>
               
               <pre><code>func (t *table) getWithKey(typ *abi.SwissMapType, hash uintptr, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getWithKey" data-name="getWithKey">
               <h3>
                  getWithKey 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getWithKey" class="anchor" title="Link to getWithKey">#</a>
               </h3>
               
               <pre><code>func (m *Map) getWithKey(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getWithKeySmall" data-name="getWithKeySmall">
               <h3>
                  getWithKeySmall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getWithKeySmall" class="anchor" title="Link to getWithKeySmall">#</a>
               </h3>
               
               <pre><code>func (m *Map) getWithKeySmall(typ *abi.SwissMapType, hash uintptr, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getWithoutKey" data-name="getWithoutKey">
               <h3>
                  getWithoutKey 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getWithoutKey" class="anchor" title="Link to getWithoutKey">#</a>
               </h3>
               
               <pre><code>func (m *Map) getWithoutKey(typ *abi.SwissMapType, key unsafe.Pointer) (unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getWithoutKey" data-name="getWithoutKey">
               <h3>
                  getWithoutKey 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getWithoutKey" class="anchor" title="Link to getWithoutKey">#</a>
               </h3>
               
               <pre><code>func (t *table) getWithoutKey(typ *abi.SwissMapType, hash uintptr, key unsafe.Pointer) (unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getWithoutKeySmallFastStr" data-name="getWithoutKeySmallFastStr">
               <h3>
                  getWithoutKeySmallFastStr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getWithoutKeySmallFastStr" class="anchor" title="Link to getWithoutKeySmallFastStr">#</a>
               </h3>
               
               <pre><code>func (m *Map) getWithoutKeySmallFastStr(typ *abi.SwissMapType, key string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="group" data-name="group">
               <h3>
                  group 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#group" class="anchor" title="Link to group">#</a>
               </h3>
               
               <p>group returns the group at index i.</p>
               
               <pre><code>func (g *groupsReference) group(typ *abi.SwissMapType, i uint64) groupReference</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="grow" data-name="grow">
               <h3>
                  grow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#grow" class="anchor" title="Link to grow">#</a>
               </h3>
               
               <p>grow the capacity of the table by allocating a new table with a bigger array
and uncheckedPutting each element of the table into the new table (we know
that no insertion here will Put an already-present value), and discard the
old table.</p>
               
               <pre><code>func (t *table) grow(typ *abi.SwissMapType, m *Map, newCapacity uint16)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="growToSmall" data-name="growToSmall">
               <h3>
                  growToSmall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#growToSmall" class="anchor" title="Link to growToSmall">#</a>
               </h3>
               
               <pre><code>func (m *Map) growToSmall(typ *abi.SwissMapType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="growToTable" data-name="growToTable">
               <h3>
                  growToTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#growToTable" class="anchor" title="Link to growToTable">#</a>
               </h3>
               
               <pre><code>func (m *Map) growToTable(typ *abi.SwissMapType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="grownKeyElem" data-name="grownKeyElem">
               <h3>
                  grownKeyElem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#grownKeyElem" class="anchor" title="Link to grownKeyElem">#</a>
               </h3>
               
               <p>Return the appropriate key/elem for key at slotIdx index within it.group, if
any.</p>
               
               <pre><code>func (it *Iter) grownKeyElem(key unsafe.Pointer, slotIdx uintptr) (unsafe.Pointer, unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="h1" data-name="h1">
               <h3>
                  h1 
                  <span class="badge">function</span>
                  
                  <a href="#h1" class="anchor" title="Link to h1">#</a>
               </h3>
               
               <p>Extracts the H1 portion of a hash: the 57 upper bits.
TODO(prattmic): what about 32-bit systems?</p>
               
               <pre><code>func h1(h uintptr) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="h2" data-name="h2">
               <h3>
                  h2 
                  <span class="badge">function</span>
                  
                  <a href="#h2" class="anchor" title="Link to h2">#</a>
               </h3>
               
               <p>Extracts the H2 portion of a hash: the 7 bits not used for h1.
These are used as an occupied control byte.</p>
               
               <pre><code>func h2(h uintptr) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="installTableSplit" data-name="installTableSplit">
               <h3>
                  installTableSplit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#installTableSplit" class="anchor" title="Link to installTableSplit">#</a>
               </h3>
               
               <pre><code>func (m *Map) installTableSplit(old *table, left *table, right *table)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="key" data-name="key">
               <h3>
                  key 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#key" class="anchor" title="Link to key">#</a>
               </h3>
               
               <p>key returns a pointer to the key at index i.</p>
               
               <pre><code>func (g *groupReference) key(typ *abi.SwissMapType, i uintptr) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="localDepthMask" data-name="localDepthMask">
               <h3>
                  localDepthMask 
                  <span class="badge">function</span>
                  
                  <a href="#localDepthMask" class="anchor" title="Link to localDepthMask">#</a>
               </h3>
               
               <p>Bitmask for the last selection bit at this depth.</p>
               
               <pre><code>func localDepthMask(localDepth uint8) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="longStringQuickEqualityTest" data-name="longStringQuickEqualityTest">
               <h3>
                  longStringQuickEqualityTest 
                  <span class="badge">function</span>
                  
                  <a href="#longStringQuickEqualityTest" class="anchor" title="Link to longStringQuickEqualityTest">#</a>
               </h3>
               
               <p>Returns true if a and b might be equal.
Returns false if a and b are definitely not equal.
Requires len(a)>=8.</p>
               
               <pre><code>func longStringQuickEqualityTest(a string, b string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lowestSet" data-name="lowestSet">
               <h3>
                  lowestSet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lowestSet" class="anchor" title="Link to lowestSet">#</a>
               </h3>
               
               <p>lowestSet returns true if the bit is set for the lowest index in the bitset.
This is intended for use with shiftOutLowest to loop over all entries in the
bitset regardless of whether they are set.</p>
               
               <pre><code>func (b bitset) lowestSet() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeProbeSeq" data-name="makeProbeSeq">
               <h3>
                  makeProbeSeq 
                  <span class="badge">function</span>
                  
                  <a href="#makeProbeSeq" class="anchor" title="Link to makeProbeSeq">#</a>
               </h3>
               
               <pre><code>func makeProbeSeq(hash uintptr, mask uint64) probeSeq</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapKeyError" data-name="mapKeyError">
               <h3>
                  mapKeyError 
                  <span class="badge">function</span>
                  
                  <a href="#mapKeyError" class="anchor" title="Link to mapKeyError">#</a>
               </h3>
               
               <p>go:linkname mapKeyError</p>
               
               <pre><code>func mapKeyError(typ *abi.SwissMapType, p unsafe.Pointer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapKeyError" data-name="mapKeyError">
               <h3>
                  mapKeyError 
                  <span class="badge">function</span>
                  
                  <a href="#mapKeyError" class="anchor" title="Link to mapKeyError">#</a>
               </h3>
               
               <p>For testing, we don't ever need key errors.</p>
               
               <pre><code>func mapKeyError(typ *abi.SwissMapType, p unsafe.Pointer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchEmpty" data-name="matchEmpty">
               <h3>
                  matchEmpty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchEmpty" class="anchor" title="Link to matchEmpty">#</a>
               </h3>
               
               <p>matchEmpty returns the set of slots in the group that are empty.</p>
               
               <pre><code>func (g ctrlGroup) matchEmpty() bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchEmptyOrDeleted" data-name="matchEmptyOrDeleted">
               <h3>
                  matchEmptyOrDeleted 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchEmptyOrDeleted" class="anchor" title="Link to matchEmptyOrDeleted">#</a>
               </h3>
               
               <p>matchEmptyOrDeleted returns the set of slots in the group that are empty or
deleted.</p>
               
               <pre><code>func (g ctrlGroup) matchEmptyOrDeleted() bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchFull" data-name="matchFull">
               <h3>
                  matchFull 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchFull" class="anchor" title="Link to matchFull">#</a>
               </h3>
               
               <p>matchFull returns the set of slots in the group that are full.</p>
               
               <pre><code>func (g ctrlGroup) matchFull() bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchH2" data-name="matchH2">
               <h3>
                  matchH2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchH2" class="anchor" title="Link to matchH2">#</a>
               </h3>
               
               <p>matchH2 returns the set of slots which are full and for which the 7-bit hash
matches the given value. May return false positives.</p>
               
               <pre><code>func (g ctrlGroup) matchH2(h uintptr) bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newGroups" data-name="newGroups">
               <h3>
                  newGroups 
                  <span class="badge">function</span>
                  
                  <a href="#newGroups" class="anchor" title="Link to newGroups">#</a>
               </h3>
               
               <p>newGroups allocates a new array of length groups.
Length must be a power of two.</p>
               
               <pre><code>func newGroups(typ *abi.SwissMapType, length uint64) groupsReference</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTable" data-name="newTable">
               <h3>
                  newTable 
                  <span class="badge">function</span>
                  
                  <a href="#newTable" class="anchor" title="Link to newTable">#</a>
               </h3>
               
               <pre><code>func newTable(typ *abi.SwissMapType, capacity uint64, index int, localDepth uint8) *table</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newarray" data-name="newarray">
               <h3>
                  newarray 
                  <span class="badge">function</span>
                  
                  <a href="#newarray" class="anchor" title="Link to newarray">#</a>
               </h3>
               
               <p>go:linkname newarray</p>
               
               <pre><code>func newarray(typ *abi.Type, n int) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newobject" data-name="newobject">
               <h3>
                  newobject 
                  <span class="badge">function</span>
                  
                  <a href="#newobject" class="anchor" title="Link to newobject">#</a>
               </h3>
               
               <p>go:linkname newobject</p>
               
               <pre><code>func newobject(typ *abi.Type) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="next" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#next" class="anchor" title="Link to next">#</a>
               </h3>
               
               <pre><code>func (s probeSeq) next() probeSeq</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextDirIdx" data-name="nextDirIdx">
               <h3>
                  nextDirIdx 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nextDirIdx" class="anchor" title="Link to nextDirIdx">#</a>
               </h3>
               
               <pre><code>func (it *Iter) nextDirIdx()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putSlotSmall" data-name="putSlotSmall">
               <h3>
                  putSlotSmall 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#putSlotSmall" class="anchor" title="Link to putSlotSmall">#</a>
               </h3>
               
               <pre><code>func (m *Map) putSlotSmall(typ *abi.SwissMapType, hash uintptr, key unsafe.Pointer) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putSlotSmallFast32" data-name="putSlotSmallFast32">
               <h3>
                  putSlotSmallFast32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#putSlotSmallFast32" class="anchor" title="Link to putSlotSmallFast32">#</a>
               </h3>
               
               <pre><code>func (m *Map) putSlotSmallFast32(typ *abi.SwissMapType, hash uintptr, key uint32) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putSlotSmallFast64" data-name="putSlotSmallFast64">
               <h3>
                  putSlotSmallFast64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#putSlotSmallFast64" class="anchor" title="Link to putSlotSmallFast64">#</a>
               </h3>
               
               <pre><code>func (m *Map) putSlotSmallFast64(typ *abi.SwissMapType, hash uintptr, key uint64) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putSlotSmallFastPtr" data-name="putSlotSmallFastPtr">
               <h3>
                  putSlotSmallFastPtr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#putSlotSmallFastPtr" class="anchor" title="Link to putSlotSmallFastPtr">#</a>
               </h3>
               
               <pre><code>func (m *Map) putSlotSmallFastPtr(typ *abi.SwissMapType, hash uintptr, key unsafe.Pointer) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putSlotSmallFastStr" data-name="putSlotSmallFastStr">
               <h3>
                  putSlotSmallFastStr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#putSlotSmallFastStr" class="anchor" title="Link to putSlotSmallFastStr">#</a>
               </h3>
               
               <pre><code>func (m *Map) putSlotSmallFastStr(typ *abi.SwissMapType, hash uintptr, key string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rand" data-name="rand">
               <h3>
                  rand 
                  <span class="badge">function</span>
                  
                  <a href="#rand" class="anchor" title="Link to rand">#</a>
               </h3>
               
               <p>go:linkname rand</p>
               
               <pre><code>func rand() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rehash" data-name="rehash">
               <h3>
                  rehash 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rehash" class="anchor" title="Link to rehash">#</a>
               </h3>
               
               <p>Replaces the table with one larger table or two split tables to fit more
entries. Since the table is replaced, t is now stale and should not be
modified.</p>
               
               <pre><code>func (t *table) rehash(typ *abi.SwissMapType, m *Map)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeBelow" data-name="removeBelow">
               <h3>
                  removeBelow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#removeBelow" class="anchor" title="Link to removeBelow">#</a>
               </h3>
               
               <p>removeBelow clears all set bits below slot i (non-inclusive).</p>
               
               <pre><code>func (b bitset) removeBelow(i uintptr) bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeFirst" data-name="removeFirst">
               <h3>
                  removeFirst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#removeFirst" class="anchor" title="Link to removeFirst">#</a>
               </h3>
               
               <p>removeFirst clears the first set bit (that is, resets the least significant
set bit to 0).</p>
               
               <pre><code>func (b bitset) removeFirst() bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="replaceTable" data-name="replaceTable">
               <h3>
                  replaceTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#replaceTable" class="anchor" title="Link to replaceTable">#</a>
               </h3>
               
               <pre><code>func (m *Map) replaceTable(nt *table)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reset" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reset" class="anchor" title="Link to reset">#</a>
               </h3>
               
               <p>reset resets the table with new, empty groups with the specified new total
capacity.</p>
               
               <pre><code>func (t *table) reset(typ *abi.SwissMapType, capacity uint16)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resetGrowthLeft" data-name="resetGrowthLeft">
               <h3>
                  resetGrowthLeft 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resetGrowthLeft" class="anchor" title="Link to resetGrowthLeft">#</a>
               </h3>
               
               <p>Preconditions: table must be empty.</p>
               
               <pre><code>func (t *table) resetGrowthLeft()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapaccess1" data-name="runtime_mapaccess1">
               <h3>
                  runtime_mapaccess1 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapaccess1" class="anchor" title="Link to runtime_mapaccess1">#</a>
               </h3>
               
               <p>mapaccess1 returns a pointer to h[key].  Never returns nil, instead
it will return a reference to the zero object for the elem type if
the key is not in the map.
NOTE: The returned pointer may keep the whole map live, so don't
hold onto it for very long.
go:linkname runtime_mapaccess1 runtime.mapaccess1</p>
               
               <pre><code>func runtime_mapaccess1(typ *abi.SwissMapType, m *Map, key unsafe.Pointer) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapaccess1_fast32" data-name="runtime_mapaccess1_fast32">
               <h3>
                  runtime_mapaccess1_fast32 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapaccess1_fast32" class="anchor" title="Link to runtime_mapaccess1_fast32">#</a>
               </h3>
               
               <p>go:linkname runtime_mapaccess1_fast32 runtime.mapaccess1_fast32</p>
               
               <pre><code>func runtime_mapaccess1_fast32(typ *abi.SwissMapType, m *Map, key uint32) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapaccess1_fast64" data-name="runtime_mapaccess1_fast64">
               <h3>
                  runtime_mapaccess1_fast64 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapaccess1_fast64" class="anchor" title="Link to runtime_mapaccess1_fast64">#</a>
               </h3>
               
               <p>go:linkname runtime_mapaccess1_fast64 runtime.mapaccess1_fast64</p>
               
               <pre><code>func runtime_mapaccess1_fast64(typ *abi.SwissMapType, m *Map, key uint64) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapaccess1_faststr" data-name="runtime_mapaccess1_faststr">
               <h3>
                  runtime_mapaccess1_faststr 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapaccess1_faststr" class="anchor" title="Link to runtime_mapaccess1_faststr">#</a>
               </h3>
               
               <p>go:linkname runtime_mapaccess1_faststr runtime.mapaccess1_faststr</p>
               
               <pre><code>func runtime_mapaccess1_faststr(typ *abi.SwissMapType, m *Map, key string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapaccess2" data-name="runtime_mapaccess2">
               <h3>
                  runtime_mapaccess2 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapaccess2" class="anchor" title="Link to runtime_mapaccess2">#</a>
               </h3>
               
               <p>go:linkname runtime_mapaccess2 runtime.mapaccess2</p>
               
               <pre><code>func runtime_mapaccess2(typ *abi.SwissMapType, m *Map, key unsafe.Pointer) (unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapaccess2_fast32" data-name="runtime_mapaccess2_fast32">
               <h3>
                  runtime_mapaccess2_fast32 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapaccess2_fast32" class="anchor" title="Link to runtime_mapaccess2_fast32">#</a>
               </h3>
               
               <p>go:linkname runtime_mapaccess2_fast32 runtime.mapaccess2_fast32</p>
               
               <pre><code>func runtime_mapaccess2_fast32(typ *abi.SwissMapType, m *Map, key uint32) (unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapaccess2_fast64" data-name="runtime_mapaccess2_fast64">
               <h3>
                  runtime_mapaccess2_fast64 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapaccess2_fast64" class="anchor" title="Link to runtime_mapaccess2_fast64">#</a>
               </h3>
               
               <p>go:linkname runtime_mapaccess2_fast64 runtime.mapaccess2_fast64</p>
               
               <pre><code>func runtime_mapaccess2_fast64(typ *abi.SwissMapType, m *Map, key uint64) (unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapaccess2_faststr" data-name="runtime_mapaccess2_faststr">
               <h3>
                  runtime_mapaccess2_faststr 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapaccess2_faststr" class="anchor" title="Link to runtime_mapaccess2_faststr">#</a>
               </h3>
               
               <p>go:linkname runtime_mapaccess2_faststr runtime.mapaccess2_faststr</p>
               
               <pre><code>func runtime_mapaccess2_faststr(typ *abi.SwissMapType, m *Map, key string) (unsafe.Pointer, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapassign" data-name="runtime_mapassign">
               <h3>
                  runtime_mapassign 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapassign" class="anchor" title="Link to runtime_mapassign">#</a>
               </h3>
               
               <p>go:linkname runtime_mapassign runtime.mapassign</p>
               
               <pre><code>func runtime_mapassign(typ *abi.SwissMapType, m *Map, key unsafe.Pointer) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapassign_fast32" data-name="runtime_mapassign_fast32">
               <h3>
                  runtime_mapassign_fast32 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapassign_fast32" class="anchor" title="Link to runtime_mapassign_fast32">#</a>
               </h3>
               
               <p>go:linkname runtime_mapassign_fast32 runtime.mapassign_fast32</p>
               
               <pre><code>func runtime_mapassign_fast32(typ *abi.SwissMapType, m *Map, key uint32) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapassign_fast32ptr" data-name="runtime_mapassign_fast32ptr">
               <h3>
                  runtime_mapassign_fast32ptr 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapassign_fast32ptr" class="anchor" title="Link to runtime_mapassign_fast32ptr">#</a>
               </h3>
               
               <p>Key is a 32-bit pointer (only called on 32-bit GOARCH). This source is identical to fast64ptr.
TODO(prattmic): With some compiler refactoring we could avoid duplication of this function.
go:linkname runtime_mapassign_fast32ptr runtime.mapassign_fast32ptr</p>
               
               <pre><code>func runtime_mapassign_fast32ptr(typ *abi.SwissMapType, m *Map, key unsafe.Pointer) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapassign_fast64" data-name="runtime_mapassign_fast64">
               <h3>
                  runtime_mapassign_fast64 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapassign_fast64" class="anchor" title="Link to runtime_mapassign_fast64">#</a>
               </h3>
               
               <p>go:linkname runtime_mapassign_fast64 runtime.mapassign_fast64</p>
               
               <pre><code>func runtime_mapassign_fast64(typ *abi.SwissMapType, m *Map, key uint64) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapassign_fast64ptr" data-name="runtime_mapassign_fast64ptr">
               <h3>
                  runtime_mapassign_fast64ptr 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapassign_fast64ptr" class="anchor" title="Link to runtime_mapassign_fast64ptr">#</a>
               </h3>
               
               <p>Key is a 64-bit pointer (only called on 64-bit GOARCH).
go:linkname runtime_mapassign_fast64ptr runtime.mapassign_fast64ptr</p>
               
               <pre><code>func runtime_mapassign_fast64ptr(typ *abi.SwissMapType, m *Map, key unsafe.Pointer) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapassign_faststr" data-name="runtime_mapassign_faststr">
               <h3>
                  runtime_mapassign_faststr 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapassign_faststr" class="anchor" title="Link to runtime_mapassign_faststr">#</a>
               </h3>
               
               <p>go:linkname runtime_mapassign_faststr runtime.mapassign_faststr</p>
               
               <pre><code>func runtime_mapassign_faststr(typ *abi.SwissMapType, m *Map, key string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapdelete_fast32" data-name="runtime_mapdelete_fast32">
               <h3>
                  runtime_mapdelete_fast32 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapdelete_fast32" class="anchor" title="Link to runtime_mapdelete_fast32">#</a>
               </h3>
               
               <p>go:linkname runtime_mapdelete_fast32 runtime.mapdelete_fast32</p>
               
               <pre><code>func runtime_mapdelete_fast32(typ *abi.SwissMapType, m *Map, key uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapdelete_fast64" data-name="runtime_mapdelete_fast64">
               <h3>
                  runtime_mapdelete_fast64 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapdelete_fast64" class="anchor" title="Link to runtime_mapdelete_fast64">#</a>
               </h3>
               
               <p>go:linkname runtime_mapdelete_fast64 runtime.mapdelete_fast64</p>
               
               <pre><code>func runtime_mapdelete_fast64(typ *abi.SwissMapType, m *Map, key uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_mapdelete_faststr" data-name="runtime_mapdelete_faststr">
               <h3>
                  runtime_mapdelete_faststr 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_mapdelete_faststr" class="anchor" title="Link to runtime_mapdelete_faststr">#</a>
               </h3>
               
               <p>go:linkname runtime_mapdelete_faststr runtime.mapdelete_faststr</p>
               
               <pre><code>func runtime_mapdelete_faststr(typ *abi.SwissMapType, m *Map, key string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="set" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#set" class="anchor" title="Link to set">#</a>
               </h3>
               
               <p>set sets the i-th control byte.</p>
               
               <pre><code>func (g *ctrlGroup) set(i uintptr, c ctrl)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setEmpty" data-name="setEmpty">
               <h3>
                  setEmpty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setEmpty" class="anchor" title="Link to setEmpty">#</a>
               </h3>
               
               <p>setEmpty sets all the control bytes to empty.</p>
               
               <pre><code>func (g *ctrlGroup) setEmpty()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shiftOutLowest" data-name="shiftOutLowest">
               <h3>
                  shiftOutLowest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shiftOutLowest" class="anchor" title="Link to shiftOutLowest">#</a>
               </h3>
               
               <p>shiftOutLowest shifts the lowest entry out of the bitset. Afterwards, the
lowest entry in the bitset corresponds to the next slot.</p>
               
               <pre><code>func (b bitset) shiftOutLowest() bitset</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="split" data-name="split">
               <h3>
                  split 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#split" class="anchor" title="Link to split">#</a>
               </h3>
               
               <p>split the table into two, installing the new tables in the map directory.</p>
               
               <pre><code>func (t *table) split(typ *abi.SwissMapType, m *Map)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stringPtr" data-name="stringPtr">
               <h3>
                  stringPtr 
                  <span class="badge">function</span>
                  
                  <a href="#stringPtr" class="anchor" title="Link to stringPtr">#</a>
               </h3>
               
               <pre><code>func stringPtr(s string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tombstones" data-name="tombstones">
               <h3>
                  tombstones 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tombstones" class="anchor" title="Link to tombstones">#</a>
               </h3>
               
               <p>tombstones returns the number of deleted (tombstone) entries in the table. A
tombstone is a slot that has been deleted but is still considered occupied
so as not to violate the probing invariant.</p>
               
               <pre><code>func (t *table) tombstones() uint16</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typedmemclr" data-name="typedmemclr">
               <h3>
                  typedmemclr 
                  <span class="badge">function</span>
                  
                  <a href="#typedmemclr" class="anchor" title="Link to typedmemclr">#</a>
               </h3>
               
               <p>go:linkname typedmemclr</p>
               
               <pre><code>func typedmemclr(typ *abi.Type, ptr unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typedmemmove" data-name="typedmemmove">
               <h3>
                  typedmemmove 
                  <span class="badge">function</span>
                  
                  <a href="#typedmemmove" class="anchor" title="Link to typedmemmove">#</a>
               </h3>
               
               <p>go:linkname typedmemmove</p>
               
               <pre><code>func typedmemmove(typ *abi.Type, dst unsafe.Pointer, src unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uncheckedPutSlot" data-name="uncheckedPutSlot">
               <h3>
                  uncheckedPutSlot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uncheckedPutSlot" class="anchor" title="Link to uncheckedPutSlot">#</a>
               </h3>
               
               <p>uncheckedPutSlot inserts an entry known not to be in the table.
This is used for grow/split where we are making a new table from
entries in an existing table.
Decrements growthLeft and increments used.
Requires that the entry does not exist in the table, and that the table has
room for another element without rehashing.
Requires that there are no deleted entries in the table.
For indirect keys and/or elements, the key and elem pointers can be
put directly into the map, they do not need to be copied. This
requires the caller to ensure that the referenced memory never
changes (by sourcing those pointers from another indirect key/elem
map).</p>
               
               <pre><code>func (t *table) uncheckedPutSlot(typ *abi.SwissMapType, hash uintptr, key unsafe.Pointer, elem unsafe.Pointer)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>