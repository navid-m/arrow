<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - gcm</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>gcm</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"crypto/internal/fips140/aes"
"crypto/internal/fips140/subtle"
"crypto/internal/fips140deps/cpu"
"crypto/internal/impl"
"crypto/internal/fips140/aes"
"crypto/internal/fips140/subtle"
"crypto/internal/fips140deps/byteorder"
"crypto/internal/fips140deps/godebug"
"crypto/internal/impl"
"runtime"
"crypto/internal/fips140"
"crypto/internal/fips140/aes"
"crypto/internal/fips140/alias"
"errors"
"crypto/internal/fips140/aes"
"crypto/internal/fips140/subtle"
"crypto/internal/fips140deps/byteorder"
"crypto/internal/fips140"
"crypto/internal/fips140/aes"
"crypto/internal/fips140/alias"
"crypto/internal/fips140/drbg"
"crypto/internal/fips140deps/byteorder"
"math"
"crypto/internal/fips140/aes"
"crypto/internal/fips140/subtle"
"crypto/internal/fips140deps/byteorder"
"crypto/internal/fips140deps/cpu"
"crypto/internal/impl"
"crypto/internal/fips140"
"crypto/internal/fips140deps/byteorder"
"crypto/internal/fips140"
"crypto/internal/fips140/aes"
_ "crypto/internal/fips140/check"
"errors"
"crypto/internal/fips140"
"crypto/internal/fips140/aes"
"crypto/internal/fips140/subtle"
"crypto/internal/fips140"
"crypto/internal/fips140/aes"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="errOpen">
               <h3>
                  errOpen 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errOpen = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="gcmBlockSize">
               <h3>
                  gcmBlockSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gcmBlockSize = 16</code></pre>
            </article>
            
            <article class="global" data-name="gcmMinimumTagSize">
               <h3>
                  gcmMinimumTagSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gcmMinimumTagSize = 12</code></pre>
            </article>
            
            <article class="global" data-name="gcmStandardNonceSize">
               <h3>
                  gcmStandardNonceSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gcmStandardNonceSize = 12</code></pre>
            </article>
            
            <article class="global" data-name="gcmTagSize">
               <h3>
                  gcmTagSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gcmTagSize = 16</code></pre>
            </article>
            
            <article class="global" data-name="ghashReductionTable">
               <h3>
                  ghashReductionTable 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ghashReductionTable = []uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="kmaDecrypt">
               <h3>
                  kmaDecrypt 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>flags for the KMA instruction</p>
               
               <pre><code>const kmaDecrypt = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="kmaHS">
               <h3>
                  kmaHS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>flags for the KMA instruction</p>
               
               <pre><code>const kmaHS = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="kmaLAAD">
               <h3>
                  kmaLAAD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>flags for the KMA instruction</p>
               
               <pre><code>const kmaLAAD = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="kmaLPC">
               <h3>
                  kmaLPC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>flags for the KMA instruction</p>
               
               <pre><code>const kmaLPC = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="supportsAESGCM">
               <h3>
                  supportsAESGCM 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Keep in sync with crypto/tls.hasAESGCMHardwareSupport.</p>
               
               <pre><code>var supportsAESGCM = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="supportsAESGCM">
               <h3>
                  supportsAESGCM 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>The POWER architecture doesn't have a way to turn off AES-GCM support
at runtime with GODEBUG=cpu.something=off, so introduce a new GODEBUG
knob for that. It's intentionally only checked at init() time, to
avoid the performance overhead of checking it every time.</p>
               
               <pre><code>var supportsAESGCM = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="useGCM">
               <h3>
                  useGCM 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var useGCM = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="useGHASH">
               <h3>
                  useGHASH 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Keep in sync with crypto/tls.hasAESGCMHardwareSupport.</p>
               
               <pre><code>var useGHASH = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="gcmHashKey">
               <h3>
                  gcmHashKey
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>gcmHashKey represents the 16-byte hash key required by the GHASH algorithm.</p>
               
               <pre><code>type gcmHashKey [16]byte</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="CMAC">
               <h3>
                  CMAC
                  <span class="badge">struct</span>
               </h3>
               
               <p>CMAC implements the CMAC mode from NIST SP 800-38B.
It is optimized for use in Counter KDF (SP 800-108r1) and XAES-256-GCM
(https://c2sp.org/XAES-256-GCM), rather than for exposing it to applications
as a stand-alone MAC.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CMAC struct {
b aes.Block
k1 [aes.BlockSize]byte
k2 [aes.BlockSize]byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="CounterKDF">
               <h3>
                  CounterKDF
                  <span class="badge">struct</span>
               </h3>
               
               <p>CounterKDF implements a KDF in Counter Mode instantiated with CMAC-AES,
according to NIST SP 800-108 Revision 1 Update 1, Section 4.1.
It produces a 256-bit output, and accepts a 8-bit Label and a 96-bit Context.
It uses a counter of 16 bits placed before the fixed data. The fixed data is
the sequence Label || 0x00 || Context. The L field is omitted, since the
output key length is fixed.
It's optimized for use in XAES-256-GCM (https://c2sp.org/XAES-256-GCM),
rather than for exposing it to applications as a stand-alone KDF.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CounterKDF struct {
mac CMAC
}</code></pre>
            </article>
            
            <article class="struct" data-name="GCM">
               <h3>
                  GCM
                  <span class="badge">struct</span>
               </h3>
               
               <p>GCM represents a Galois Counter Mode with a specific key.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type GCM struct {
cipher aes.Block
nonceSize int
tagSize int
gcmPlatformData
}</code></pre>
            </article>
            
            <article class="struct" data-name="GCMForSSH">
               <h3>
                  GCMForSSH
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type GCMForSSH struct {
g GCM
ready bool
start uint64
next uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="GCMForTLS12">
               <h3>
                  GCMForTLS12
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type GCMForTLS12 struct {
g GCM
next uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="GCMForTLS13">
               <h3>
                  GCMForTLS13
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type GCMForTLS13 struct {
g GCM
ready bool
mask uint64
next uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="GCMWithCounterNonce">
               <h3>
                  GCMWithCounterNonce
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type GCMWithCounterNonce struct {
g GCM
ready bool
fixedName uint32
start uint64
next uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="gcmFieldElement">
               <h3>
                  gcmFieldElement
                  <span class="badge">struct</span>
               </h3>
               
               <p>gcmFieldElement represents a value in GF(2¹²⁸). In order to reflect the GCM
standard and make binary.BigEndian suitable for marshaling these values, the
bits are stored in big endian order. For example:
the coefficient of x⁰ can be obtained by v.low >> 63.
the coefficient of x⁶³ can be obtained by v.low & 1.
the coefficient of x⁶⁴ can be obtained by v.high >> 63.
the coefficient of x¹²⁷ can be obtained by v.high & 1.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gcmFieldElement struct {
low uint64
high uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="gcmPlatformData">
               <h3>
                  gcmPlatformData
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gcmPlatformData struct {
productTable [256]byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="gcmPlatformData">
               <h3>
                  gcmPlatformData
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gcmPlatformData struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="gcmPlatformData">
               <h3>
                  gcmPlatformData
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gcmPlatformData struct {
productTable [256]byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="gcmPlatformData">
               <h3>
                  gcmPlatformData
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gcmPlatformData struct {
hashKey gcmHashKey
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="DeriveKey">
               <h3>
                  DeriveKey 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DeriveKey derives a key from the given label and context.</p>
               
               <pre><code>func (kdf *CounterKDF) DeriveKey(label byte, context [12]byte) [32]byte</code></pre>
            </article>
            
            <article class="function" data-name="GHASH">
               <h3>
                  GHASH 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>GHASH is exposed to allow crypto/cipher to implement non-AES GCM modes.
It is not allowed as a stand-alone operation in FIPS mode because it
is not ACVP tested.</p>
               
               <pre><code>func GHASH(key *[16]byte, inputs ...[]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="MAC">
               <h3>
                  MAC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *CMAC) MAC(m []byte) [aes.BlockSize]byte</code></pre>
            </article>
            
            <article class="function" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func New(cipher *aes.Block, nonceSize int, tagSize int) (*GCM, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewCMAC">
               <h3>
                  NewCMAC 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewCMAC(b *aes.Block) *CMAC</code></pre>
            </article>
            
            <article class="function" data-name="NewCounterKDF">
               <h3>
                  NewCounterKDF 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewCounterKDF creates a new CounterKDF with the given key.</p>
               
               <pre><code>func NewCounterKDF(b *aes.Block) *CounterKDF</code></pre>
            </article>
            
            <article class="function" data-name="NewGCMForSSH">
               <h3>
                  NewGCMForSSH 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewGCMForSSH returns a new AEAD that works like GCM, but enforces the
construction of nonces as specified in RFC 5647.
This complies with FIPS 140-3 IG C.H Scenario 1.d.</p>
               
               <pre><code>func NewGCMForSSH(cipher *aes.Block) (*GCMForSSH, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewGCMForTLS12">
               <h3>
                  NewGCMForTLS12 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewGCMForTLS12 returns a new AEAD that works like GCM, but enforces the
construction of nonces as specified in RFC 5288, Section 3 and RFC 9325,
Section 7.2.1.
This complies with FIPS 140-3 IG C.H Scenario 1.a.</p>
               
               <pre><code>func NewGCMForTLS12(cipher *aes.Block) (*GCMForTLS12, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewGCMForTLS13">
               <h3>
                  NewGCMForTLS13 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewGCMForTLS13 returns a new AEAD that works like GCM, but enforces the
construction of nonces as specified in RFC 8446, Section 5.3.</p>
               
               <pre><code>func NewGCMForTLS13(cipher *aes.Block) (*GCMForTLS13, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewGCMWithCounterNonce">
               <h3>
                  NewGCMWithCounterNonce 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewGCMWithCounterNonce returns a new AEAD that works like GCM, but enforces
the construction of deterministic nonces. The nonce must be 96 bits, the
first 32 bits must be an encoding of the module name, and the last 64 bits
must be a counter.
This complies with FIPS 140-3 IG C.H Scenario 3.</p>
               
               <pre><code>func NewGCMWithCounterNonce(cipher *aes.Block) (*GCMWithCounterNonce, error)</code></pre>
            </article>
            
            <article class="function" data-name="NonceSize">
               <h3>
                  NonceSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMForTLS12) NonceSize() int</code></pre>
            </article>
            
            <article class="function" data-name="NonceSize">
               <h3>
                  NonceSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCM) NonceSize() int</code></pre>
            </article>
            
            <article class="function" data-name="NonceSize">
               <h3>
                  NonceSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMWithCounterNonce) NonceSize() int</code></pre>
            </article>
            
            <article class="function" data-name="NonceSize">
               <h3>
                  NonceSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMForSSH) NonceSize() int</code></pre>
            </article>
            
            <article class="function" data-name="NonceSize">
               <h3>
                  NonceSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMForTLS13) NonceSize() int</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMForSSH) Open(dst []byte, nonce []byte, ciphertext []byte, data []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMWithCounterNonce) Open(dst []byte, nonce []byte, ciphertext []byte, data []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMForTLS13) Open(dst []byte, nonce []byte, ciphertext []byte, data []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCM) Open(dst []byte, nonce []byte, ciphertext []byte, data []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMForTLS12) Open(dst []byte, nonce []byte, ciphertext []byte, data []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Overhead">
               <h3>
                  Overhead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMForTLS12) Overhead() int</code></pre>
            </article>
            
            <article class="function" data-name="Overhead">
               <h3>
                  Overhead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMWithCounterNonce) Overhead() int</code></pre>
            </article>
            
            <article class="function" data-name="Overhead">
               <h3>
                  Overhead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMForTLS13) Overhead() int</code></pre>
            </article>
            
            <article class="function" data-name="Overhead">
               <h3>
                  Overhead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMForSSH) Overhead() int</code></pre>
            </article>
            
            <article class="function" data-name="Overhead">
               <h3>
                  Overhead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCM) Overhead() int</code></pre>
            </article>
            
            <article class="function" data-name="Seal">
               <h3>
                  Seal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCM) Seal(dst []byte, nonce []byte, plaintext []byte, data []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Seal">
               <h3>
                  Seal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMWithCounterNonce) Seal(dst []byte, nonce []byte, plaintext []byte, data []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Seal">
               <h3>
                  Seal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMForSSH) Seal(dst []byte, nonce []byte, plaintext []byte, data []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Seal">
               <h3>
                  Seal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMForTLS13) Seal(dst []byte, nonce []byte, plaintext []byte, data []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Seal">
               <h3>
                  Seal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCMForTLS12) Seal(dst []byte, nonce []byte, plaintext []byte, data []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="SealWithRandomNonce">
               <h3>
                  SealWithRandomNonce 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SealWithRandomNonce encrypts plaintext to out, and writes a random nonce to
nonce. nonce must be 12 bytes, and out must be 16 bytes longer than plaintext.
out and plaintext may overlap exactly or not at all. additionalData and out
must not overlap.
This complies with FIPS 140-3 IG C.H Scenario 2.
Note that this is NOT a [cipher.AEAD].Seal method.</p>
               
               <pre><code>func SealWithRandomNonce(g *GCM, nonce []byte, out []byte, plaintext []byte, additionalData []byte)</code></pre>
            </article>
            
            <article class="function" data-name="auth">
               <h3>
                  auth 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>auth calculates GHASH(ciphertext, additionalData), masks the result with
tagMask and writes the result to out.</p>
               
               <pre><code>func auth(out []byte, ciphertext []byte, aad []byte, tagMask *[gcmTagSize]byte, productTable *[256]byte)</code></pre>
            </article>
            
            <article class="function" data-name="checkGenericIsExpected">
               <h3>
                  checkGenericIsExpected 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkGenericIsExpected()</code></pre>
            </article>
            
            <article class="function" data-name="checkGenericIsExpected">
               <h3>
                  checkGenericIsExpected 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkGenericIsExpected()</code></pre>
            </article>
            
            <article class="function" data-name="checkGenericIsExpected">
               <h3>
                  checkGenericIsExpected 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkGenericIsExpected()</code></pre>
            </article>
            
            <article class="function" data-name="checkGenericIsExpected">
               <h3>
                  checkGenericIsExpected 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkGenericIsExpected is called by the variable-time implementation to make
sure it is not used when hardware support is available. It shouldn't happen,
but this way it's more evidently correct.</p>
               
               <pre><code>func checkGenericIsExpected()</code></pre>
            </article>
            
            <article class="function" data-name="counterCrypt">
               <h3>
                  counterCrypt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>counterCrypt encrypts in using AES in counter mode and places the result
into out. counter is the initial count value and will be updated with the next
count value. The length of out must be greater than or equal to the length
of in.
counterCryptASM implements counterCrypt which then allows the loop to
be unrolled and optimized.</p>
               
               <pre><code>func counterCrypt(b *aes.Block, out []byte, in []byte, counter *[gcmBlockSize]byte)</code></pre>
            </article>
            
            <article class="function" data-name="counterCrypt">
               <h3>
                  counterCrypt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>counterCrypt encrypts src using AES in counter mode and places the result
into dst. cnt is the initial count value and will be updated with the next
count value. The length of dst must be greater than or equal to the length
of src.</p>
               
               <pre><code>func counterCrypt(g *GCM, dst []byte, src []byte, cnt *[gcmBlockSize]byte)</code></pre>
            </article>
            
            <article class="function" data-name="counterCryptASM">
               <h3>
                  counterCryptASM 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func counterCryptASM(nr int, out []byte, in []byte, counter *[gcmBlockSize]byte, key *uint32)</code></pre>
            </article>
            
            <article class="function" data-name="cryptBlocksGCM">
               <h3>
                  cryptBlocksGCM 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>cryptBlocksGCM encrypts src using AES in counter mode using the given
function code and key. The rightmost 32-bits of the counter are incremented
between each block as required by the GCM spec. The initial counter value
is given by cnt, which is updated with the value of the next counter value
to use.
The lengths of both dst and buf must be greater than or equal to the length
of src. buf may be partially or completely overwritten during the execution
of the function.
go:noescape</p>
               
               <pre><code>func cryptBlocksGCM(fn int, key []byte, dst []byte, src []byte, buf []byte, cnt *[gcmBlockSize]byte)</code></pre>
            </article>
            
            <article class="function" data-name="deriveCounter">
               <h3>
                  deriveCounter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>deriveCounter computes the initial GCM counter state from the given nonce.
See NIST SP 800-38D, section 7.1 and deriveCounterGeneric in gcm_generic.go.</p>
               
               <pre><code>func deriveCounter(H *gcmHashKey, counter *[gcmBlockSize]byte, nonce []byte)</code></pre>
            </article>
            
            <article class="function" data-name="deriveCounter">
               <h3>
                  deriveCounter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>deriveCounter computes the initial GCM counter state from the given nonce.</p>
               
               <pre><code>func deriveCounter(counter *[gcmBlockSize]byte, nonce []byte, productTable *[256]byte)</code></pre>
            </article>
            
            <article class="function" data-name="deriveCounterGeneric">
               <h3>
                  deriveCounterGeneric 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>deriveCounterGeneric computes the initial GCM counter state from the given nonce.
See NIST SP 800-38D, section 7.1. This assumes that counter is filled with
zeros on entry.</p>
               
               <pre><code>func deriveCounterGeneric(H *[gcmBlockSize]byte, counter *[gcmBlockSize]byte, nonce []byte)</code></pre>
            </article>
            
            <article class="function" data-name="deriveSubkeys">
               <h3>
                  deriveSubkeys 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *CMAC) deriveSubkeys()</code></pre>
            </article>
            
            <article class="function" data-name="gcmAesData">
               <h3>
                  gcmAesData 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func gcmAesData(productTable *[256]byte, data []byte, T *[16]byte)</code></pre>
            </article>
            
            <article class="function" data-name="gcmAesDec">
               <h3>
                  gcmAesDec 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func gcmAesDec(productTable *[256]byte, dst []byte, src []byte, ctr *[16]byte, T *[16]byte, ks []uint32)</code></pre>
            </article>
            
            <article class="function" data-name="gcmAesEnc">
               <h3>
                  gcmAesEnc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func gcmAesEnc(productTable *[256]byte, dst []byte, src []byte, ctr *[16]byte, T *[16]byte, ks []uint32)</code></pre>
            </article>
            
            <article class="function" data-name="gcmAesFinish">
               <h3>
                  gcmAesFinish 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func gcmAesFinish(productTable *[256]byte, tagMask *[16]byte, T *[16]byte, pLen uint64, dLen uint64)</code></pre>
            </article>
            
            <article class="function" data-name="gcmAesInit">
               <h3>
                  gcmAesInit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func gcmAesInit(productTable *[256]byte, ks []uint32)</code></pre>
            </article>
            
            <article class="function" data-name="gcmAuth">
               <h3>
                  gcmAuth 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>gcmAuth calculates GHASH(additionalData, ciphertext), masks the result
with tagMask and writes the result to out.</p>
               
               <pre><code>func gcmAuth(out []byte, H *gcmHashKey, tagMask *[gcmBlockSize]byte, ciphertext []byte, additionalData []byte)</code></pre>
            </article>
            
            <article class="function" data-name="gcmAuthGeneric">
               <h3>
                  gcmAuthGeneric 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>gcmAuthGeneric calculates GHASH(additionalData, ciphertext), masks the result
with tagMask and writes the result to out.</p>
               
               <pre><code>func gcmAuthGeneric(out []byte, H *[gcmBlockSize]byte, tagMask *[gcmBlockSize]byte, ciphertext []byte, additionalData []byte)</code></pre>
            </article>
            
            <article class="function" data-name="gcmCounterCryptGeneric">
               <h3>
                  gcmCounterCryptGeneric 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>gcmCounterCryptGeneric encrypts src using AES in counter mode with 32-bit
wrapping (which is different from AES-CTR) and places the result into out.
counter is the initial value and will be updated with the next value.</p>
               
               <pre><code>func gcmCounterCryptGeneric(b *aes.Block, out []byte, src []byte, counter *[gcmBlockSize]byte)</code></pre>
            </article>
            
            <article class="function" data-name="gcmHash">
               <h3>
                  gcmHash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func gcmHash(output []byte, productTable *[256]byte, inp []byte, len int)</code></pre>
            </article>
            
            <article class="function" data-name="gcmInc32">
               <h3>
                  gcmInc32 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>gcmInc32 treats the final four bytes of counterBlock as a big-endian value
and increments it.</p>
               
               <pre><code>func gcmInc32(counterBlock *[gcmBlockSize]byte)</code></pre>
            </article>
            
            <article class="function" data-name="gcmInit">
               <h3>
                  gcmInit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func gcmInit(productTable *[256]byte, h []byte)</code></pre>
            </article>
            
            <article class="function" data-name="gcmLengths">
               <h3>
                  gcmLengths 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func gcmLengths(len0 uint64, len1 uint64) [16]byte</code></pre>
            </article>
            
            <article class="function" data-name="gcmLengths">
               <h3>
                  gcmLengths 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>gcmLengths writes len0 || len1 as big-endian values to a 16-byte array.</p>
               
               <pre><code>func gcmLengths(len0 uint64, len1 uint64) [16]byte</code></pre>
            </article>
            
            <article class="function" data-name="ghash">
               <h3>
                  ghash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ghash is a variable-time generic implementation of GHASH, which shouldn't
be used on any architecture with hardware support for AES-GCM.
Each input is zero-padded to 128-bit before being absorbed.</p>
               
               <pre><code>func ghash(out *[gcmBlockSize]byte, H *[gcmBlockSize]byte, inputs ...[]byte)</code></pre>
            </article>
            
            <article class="function" data-name="ghashAdd">
               <h3>
                  ghashAdd 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ghashAdd adds two elements of GF(2¹²⁸) and returns the sum.</p>
               
               <pre><code>func ghashAdd(x *gcmFieldElement, y *gcmFieldElement) gcmFieldElement</code></pre>
            </article>
            
            <article class="function" data-name="ghashAsm">
               <h3>
                  ghashAsm 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ghashAsm uses the GHASH algorithm to hash data with the given key. The initial
hash value is given by hash which will be updated with the new hash value.
The length of data must be a multiple of 16-bytes.
go:noescape</p>
               
               <pre><code>func ghashAsm(key *gcmHashKey, hash *[16]byte, data []byte)</code></pre>
            </article>
            
            <article class="function" data-name="ghashDouble">
               <h3>
                  ghashDouble 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ghashDouble returns the result of doubling an element of GF(2¹²⁸).</p>
               
               <pre><code>func ghashDouble(x *gcmFieldElement) (double gcmFieldElement)</code></pre>
            </article>
            
            <article class="function" data-name="ghashMul">
               <h3>
                  ghashMul 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ghashMul sets y to y*H, where H is the GCM key, fixed during New.</p>
               
               <pre><code>func ghashMul(productTable *[16]gcmFieldElement, y *gcmFieldElement)</code></pre>
            </article>
            
            <article class="function" data-name="ghashUpdate">
               <h3>
                  ghashUpdate 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ghashUpdate extends y with more polynomial terms from data. If data is not a
multiple of gcmBlockSize bytes long then the remainder is zero padded.</p>
               
               <pre><code>func ghashUpdate(productTable *[16]gcmFieldElement, y *gcmFieldElement, data []byte)</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="initGCM">
               <h3>
                  initGCM 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initGCM(g *GCM)</code></pre>
            </article>
            
            <article class="function" data-name="initGCM">
               <h3>
                  initGCM 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initGCM(g *GCM)</code></pre>
            </article>
            
            <article class="function" data-name="initGCM">
               <h3>
                  initGCM 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initGCM(g *GCM)</code></pre>
            </article>
            
            <article class="function" data-name="initGCM">
               <h3>
                  initGCM 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initGCM(g *GCM)</code></pre>
            </article>
            
            <article class="function" data-name="kmaGCM">
               <h3>
                  kmaGCM 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>kmaGCM executes the encryption or decryption operation given by fn. The tag
will be calculated and written to tag. cnt should contain the current
counter state and will be overwritten with the updated counter state.
TODO(mundaym): could pass in hash subkey
go:noescape</p>
               
               <pre><code>func kmaGCM(fn int, key []byte, dst []byte, src []byte, aad []byte, tag *[16]byte, cnt *[gcmBlockSize]byte)</code></pre>
            </article>
            
            <article class="function" data-name="newGCM">
               <h3>
                  newGCM 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newGCM is marked go:noinline to avoid it inlining into New, and making New
too complex to inline itself.
go:noinline</p>
               
               <pre><code>func newGCM(g *GCM, cipher *aes.Block, nonceSize int, tagSize int) (*GCM, error)</code></pre>
            </article>
            
            <article class="function" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func open(out []byte, g *GCM, nonce []byte, ciphertext []byte, data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func open(out []byte, g *GCM, nonce []byte, ciphertext []byte, data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func open(out []byte, g *GCM, nonce []byte, ciphertext []byte, data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func open(out []byte, g *GCM, nonce []byte, ciphertext []byte, data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="openAsm">
               <h3>
                  openAsm 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func openAsm(out []byte, g *GCM, nonce []byte, ciphertext []byte, additionalData []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="openGeneric">
               <h3>
                  openGeneric 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func openGeneric(out []byte, g *GCM, nonce []byte, ciphertext []byte, additionalData []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="openKMA">
               <h3>
                  openKMA 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func openKMA(out []byte, g *GCM, nonce []byte, ciphertext []byte, data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="paddedGHASH">
               <h3>
                  paddedGHASH 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>paddedGHASH pads data with zeroes until its length is a multiple of
16-bytes. It then calculates a new value for hash using the ghash
algorithm.</p>
               
               <pre><code>func paddedGHASH(hash *[16]byte, data []byte, productTable *[256]byte)</code></pre>
            </article>
            
            <article class="function" data-name="paddedGHASH">
               <h3>
                  paddedGHASH 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>paddedGHASH pads data with zeroes until its length is a multiple of
16-bytes. It then calculates a new value for hash using the GHASH algorithm.</p>
               
               <pre><code>func paddedGHASH(hashKey *gcmHashKey, hash *[16]byte, data []byte)</code></pre>
            </article>
            
            <article class="function" data-name="reverseBits">
               <h3>
                  reverseBits 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>reverseBits reverses the order of the bits of 4-bit number in i.</p>
               
               <pre><code>func reverseBits(i int) int</code></pre>
            </article>
            
            <article class="function" data-name="seal">
               <h3>
                  seal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func seal(out []byte, g *GCM, nonce []byte, plaintext []byte, data []byte)</code></pre>
            </article>
            
            <article class="function" data-name="seal">
               <h3>
                  seal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func seal(out []byte, g *GCM, nonce []byte, plaintext []byte, data []byte)</code></pre>
            </article>
            
            <article class="function" data-name="seal">
               <h3>
                  seal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func seal(out []byte, g *GCM, nonce []byte, plaintext []byte, data []byte)</code></pre>
            </article>
            
            <article class="function" data-name="seal">
               <h3>
                  seal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func seal(out []byte, g *GCM, nonce []byte, plaintext []byte, data []byte)</code></pre>
            </article>
            
            <article class="function" data-name="sealAfterIndicator">
               <h3>
                  sealAfterIndicator 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *GCM) sealAfterIndicator(dst []byte, nonce []byte, plaintext []byte, data []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="sealAsm">
               <h3>
                  sealAsm 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sealAsm(out []byte, g *GCM, nonce []byte, plaintext []byte, additionalData []byte)</code></pre>
            </article>
            
            <article class="function" data-name="sealGeneric">
               <h3>
                  sealGeneric 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sealGeneric(out []byte, g *GCM, nonce []byte, plaintext []byte, additionalData []byte)</code></pre>
            </article>
            
            <article class="function" data-name="sealKMA">
               <h3>
                  sealKMA 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func sealKMA(out []byte, g *GCM, nonce []byte, plaintext []byte, data []byte)</code></pre>
            </article>
            
            <article class="function" data-name="shiftLeft">
               <h3>
                  shiftLeft 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>shiftLeft sets x to x << 1, and returns MSB₁(x).</p>
               
               <pre><code>func shiftLeft(x *[aes.BlockSize]byte) byte</code></pre>
            </article>
            
            <article class="function" data-name="sliceForAppend">
               <h3>
                  sliceForAppend 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>sliceForAppend takes a slice and a requested number of bytes. It returns a
slice with the contents of the given slice followed by that many bytes and a
second slice that aliases into it and contains only the extra bytes. If the
original slice has sufficient capacity then no allocation is performed.</p>
               
               <pre><code>func sliceForAppend(in []byte, n int) (head []byte, tail []byte)</code></pre>
            </article>
            
            <article class="function" data-name="updateBlocks">
               <h3>
                  updateBlocks 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>updateBlocks extends y with more polynomial terms from blocks, based on
Horner's rule. There must be a multiple of gcmBlockSize bytes in blocks.</p>
               
               <pre><code>func updateBlocks(productTable *[16]gcmFieldElement, y *gcmFieldElement, blocks []byte)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
