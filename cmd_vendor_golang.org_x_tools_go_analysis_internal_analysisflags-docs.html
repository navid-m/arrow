<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - analysisflags</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>analysisflags</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"crypto/sha256"
"encoding/gob"
"encoding/json"
"flag"
"fmt"
"go/token"
"io"
"log"
"os"
"strconv"
"strings"
"golang.org/x/tools/go/analysis"
"flag"
"fmt"
"log"
"os"
"sort"
"strings"
"golang.org/x/tools/go/analysis"
"fmt"
"net/url"
"golang.org/x/tools/go/analysis"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="Context">
               <h3>
                  Context 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>flags common to all {single,multi,unit}checkers.</p>
               
               <pre><code>var Context = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="JSON">
               <h3>
                  JSON 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>flags common to all {single,multi,unit}checkers.</p>
               
               <pre><code>var JSON = false</code></pre>
            </article>
            
            <article class="global" data-name="help">
               <h3>
                  help 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const help = `PROGNAME is a tool for static analysis of Go programs.

PROGNAME examines Go source code and reports suspicious constructs,
such as Printf calls whose arguments do not align with the format
string. It uses heuristics that do not guarantee all reports are
genuine problems, but it can find errors not caught by the compilers.
`</code></pre>
            </article>
            
            <article class="global" data-name="setFalse">
               <h3>
                  setFalse 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const setFalse</code></pre>
            </article>
            
            <article class="global" data-name="setTrue">
               <h3>
                  setTrue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const setTrue</code></pre>
            </article>
            
            <article class="global" data-name="unset">
               <h3>
                  unset 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const unset triState = iota</code></pre>
            </article>
            
            <article class="global" data-name="vetLegacyFlags">
               <h3>
                  vetLegacyFlags 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>vetLegacyFlags maps flags used by legacy vet to their corresponding
new names. The old names will continue to work.</p>
               
               <pre><code>var vetLegacyFlags = map[string]string{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="JSONTree">
               <h3>
                  JSONTree
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A JSONTree is a mapping from package ID to analysis name to result.
Each result is either a jsonError or a list of JSONDiagnostic.</p>
               
               <pre><code>type JSONTree map[string]map[string]interface{}</code></pre>
            </article>
            
            <article class="type" data-name="triState">
               <h3>
                  triState
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A triState is a boolean that knows whether
it has been set to either true or false.
It is used to identify whether a flag appears;
the standard boolean flag cannot
distinguish missing from unset.
It also satisfies flag.Value.</p>
               
               <pre><code>type triState int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="JSONDiagnostic">
               <h3>
                  JSONDiagnostic
                  <span class="badge">struct</span>
               </h3>
               
               <p>A JSONDiagnostic describes the JSON schema of an analysis.Diagnostic.
TODO(matloob): include End position if present.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type JSONDiagnostic struct {
Category string `json:"category,omitempty"`
Posn string `json:"posn"`
Message string `json:"message"`
SuggestedFixes []JSONSuggestedFix `json:"suggested_fixes,omitempty"`
Related []JSONRelatedInformation `json:"related,omitempty"`
}</code></pre>
            </article>
            
            <article class="struct" data-name="JSONRelatedInformation">
               <h3>
                  JSONRelatedInformation
                  <span class="badge">struct</span>
               </h3>
               
               <p>A JSONRelated describes a secondary position and message related to
a primary diagnostic.
TODO(adonovan): include End position if present.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type JSONRelatedInformation struct {
Posn string `json:"posn"`
Message string `json:"message"`
}</code></pre>
            </article>
            
            <article class="struct" data-name="JSONSuggestedFix">
               <h3>
                  JSONSuggestedFix
                  <span class="badge">struct</span>
               </h3>
               
               <p>A JSONSuggestedFix describes an edit that should be applied as a whole or not
at all. It might contain multiple TextEdits/text_edits if the SuggestedFix
consists of multiple non-contiguous edits.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type JSONSuggestedFix struct {
Message string `json:"message"`
Edits []JSONTextEdit `json:"edits"`
}</code></pre>
            </article>
            
            <article class="struct" data-name="JSONTextEdit">
               <h3>
                  JSONTextEdit
                  <span class="badge">struct</span>
               </h3>
               
               <p>A TextEdit describes the replacement of a portion of a file.
Start and End are zero-based half-open indices into the original byte
sequence of the file, and New is the new text.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type JSONTextEdit struct {
Filename string `json:"filename"`
Start int `json:"start"`
End int `json:"end"`
New string `json:"new"`
}</code></pre>
            </article>
            
            <article class="struct" data-name="versionFlag">
               <h3>
                  versionFlag
                  <span class="badge">struct</span>
               </h3>
               
               <p>versionFlag minimally complies with the -V protocol required by "go vet".</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type versionFlag struct {

}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add adds the result of analysis 'name' on package 'id'.
The result is either a list of diagnostics or an error.</p>
               
               <pre><code>func (tree JSONTree) Add(fset *token.FileSet, id string, name string, diags []analysis.Diagnostic, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (versionFlag) Get() interface{}</code></pre>
            </article>
            
            <article class="function" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>triState implements flag.Value, flag.Getter, and flag.boolFlag.
They work like boolean flags: we can say vet -printf as well as vet -printf=true</p>
               
               <pre><code>func (ts *triState) Get() interface{}</code></pre>
            </article>
            
            <article class="function" data-name="Help">
               <h3>
                  Help 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Help implements the help subcommand for a multichecker or unitchecker
style command. The optional args specify the analyzers to describe.
Help calls log.Fatal if no such analyzer exists.</p>
               
               <pre><code>func Help(progname string, analyzers []*analysis.Analyzer, args []string)</code></pre>
            </article>
            
            <article class="function" data-name="IsBoolFlag">
               <h3>
                  IsBoolFlag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (versionFlag) IsBoolFlag() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsBoolFlag">
               <h3>
                  IsBoolFlag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ts triState) IsBoolFlag() bool</code></pre>
            </article>
            
            <article class="function" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Parse creates a flag for each of the analyzer's flags,
including (in multi mode) a flag named after the analyzer,
parses the flags, then filters and returns the list of
analyzers enabled by flags.
The result is intended to be passed to unitchecker.Run or checker.Run.
Use in unitchecker.Run will gob.Register all fact types for the returned
graph of analyzers but of course not the ones only reachable from
dropped analyzers. To avoid inconsistency about which gob types are
registered from run to run, Parse itself gob.Registers all the facts
only reachable from dropped analyzers.
This is not a particularly elegant API, but this is an internal package.</p>
               
               <pre><code>func Parse(analyzers []*analysis.Analyzer, multi bool) []*analysis.Analyzer</code></pre>
            </article>
            
            <article class="function" data-name="Print">
               <h3>
                  Print 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (tree JSONTree) Print(out io.Writer) error</code></pre>
            </article>
            
            <article class="function" data-name="PrintPlain">
               <h3>
                  PrintPlain 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PrintPlain prints a diagnostic in plain text form.
If contextLines is nonnegative, it also prints the
offending line plus this many lines of context.</p>
               
               <pre><code>func PrintPlain(out io.Writer, fset *token.FileSet, contextLines int, diag analysis.Diagnostic)</code></pre>
            </article>
            
            <article class="function" data-name="ResolveURL">
               <h3>
                  ResolveURL 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ResolveURL resolves the URL field for a Diagnostic from an Analyzer
and returns the URL. See Diagnostic.URL for details.</p>
               
               <pre><code>func ResolveURL(a *analysis.Analyzer, d analysis.Diagnostic) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (versionFlag) Set(s string) error</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ts *triState) Set(value string) error</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ts *triState) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (versionFlag) String() string</code></pre>
            </article>
            
            <article class="function" data-name="addVersionFlag">
               <h3>
                  addVersionFlag 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addVersionFlag registers a -V flag that, if set,
prints the executable version and exits 0.
If the -V flag already exists — for example, because it was already
registered by a call to cmd/internal/objabi.AddVersionFlag — then
addVersionFlag does nothing.</p>
               
               <pre><code>func addVersionFlag()</code></pre>
            </article>
            
            <article class="function" data-name="expand">
               <h3>
                  expand 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func expand(analyzers []*analysis.Analyzer) map[*analysis.Analyzer]bool</code></pre>
            </article>
            
            <article class="function" data-name="isTrue">
               <h3>
                  isTrue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ts triState) isTrue() bool</code></pre>
            </article>
            
            <article class="function" data-name="printFlags">
               <h3>
                  printFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func printFlags()</code></pre>
            </article>
            
            <article class="function" data-name="triStateFlag">
               <h3>
                  triStateFlag 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func triStateFlag(name string, value triState, usage string) *triState</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
