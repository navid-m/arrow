<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - analysisflags</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>analysisflags</code>
         </h1>
         <hr />
         
         <article class="global" data-name="JSON">
            <h2>JSON</h2>
            <hr />
            
            <p>flags common to all {single,multi,unit}checkers.</p>
            
            <pre><code>JSON</code></pre>
         </article>
         
         <article class="global" data-name="Context">
            <h2>Context</h2>
            <hr />
            
            <p>flags common to all {single,multi,unit}checkers.</p>
            
            <pre><code>Context</code></pre>
         </article>
         
         <article class="global" data-name="unset">
            <h2>unset</h2>
            <hr />
            
            <pre><code>unset triState</code></pre>
         </article>
         
         <article class="global" data-name="setTrue">
            <h2>setTrue</h2>
            <hr />
            
            <pre><code>setTrue</code></pre>
         </article>
         
         <article class="global" data-name="setFalse">
            <h2>setFalse</h2>
            <hr />
            
            <pre><code>setFalse</code></pre>
         </article>
         
         <article class="global" data-name="vetLegacyFlags">
            <h2>vetLegacyFlags</h2>
            <hr />
            
            <p>vetLegacyFlags maps flags used by legacy vet to their corresponding
new names. The old names will continue to work.</p>
            
            <pre><code>vetLegacyFlags</code></pre>
         </article>
         
         <article class="global" data-name="help">
            <h2>help</h2>
            <hr />
            
            <pre><code>help</code></pre>
         </article>
          
         <article class="struct" data-name="versionFlag">
            <h2>type versionFlag struct</h2>
            <hr />
            
            <p>versionFlag minimally complies with the -V protocol required by "go vet".</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="JSONTextEdit">
            <h2>type JSONTextEdit struct</h2>
            <hr />
            
            <p>A TextEdit describes the replacement of a portion of a file.
Start and End are zero-based half-open indices into the original byte
sequence of the file, and New is the new text.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Filename string
Start int
End int
New string</code></pre>
         </article>
         
         <article class="struct" data-name="JSONSuggestedFix">
            <h2>type JSONSuggestedFix struct</h2>
            <hr />
            
            <p>A JSONSuggestedFix describes an edit that should be applied as a whole or not
at all. It might contain multiple TextEdits/text_edits if the SuggestedFix
consists of multiple non-contiguous edits.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Message string
Edits []JSONTextEdit</code></pre>
         </article>
         
         <article class="struct" data-name="JSONDiagnostic">
            <h2>type JSONDiagnostic struct</h2>
            <hr />
            
            <p>A JSONDiagnostic describes the JSON schema of an analysis.Diagnostic.

TODO(matloob): include End position if present.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Category string
Posn string
Message string
SuggestedFixes []JSONSuggestedFix
Related []JSONRelatedInformation</code></pre>
         </article>
         
         <article class="struct" data-name="JSONRelatedInformation">
            <h2>type JSONRelatedInformation struct</h2>
            <hr />
            
            <p>A JSONRelated describes a secondary position and message related to
a primary diagnostic.

TODO(adonovan): include End position if present.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Posn string
Message string</code></pre>
         </article>
          
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <p>Parse creates a flag for each of the analyzer's flags,
including (in multi mode) a flag named after the analyzer,
parses the flags, then filters and returns the list of
analyzers enabled by flags.

The result is intended to be passed to unitchecker.Run or checker.Run.
Use in unitchecker.Run will gob.Register all fact types for the returned
graph of analyzers but of course not the ones only reachable from
dropped analyzers. To avoid inconsistency about which gob types are
registered from run to run, Parse itself gob.Registers all the facts
only reachable from dropped analyzers.
This is not a particularly elegant API, but this is an internal package.</p>
            
            <pre><code>func Parse(analyzers []*analysis.Analyzer, multi bool) []*analysis.Analyzer</code></pre>
         </article>
         
         <article class="function" data-name="expand">
            <h2>expand</h2>
            <hr />
            
            <pre><code>func expand(analyzers []*analysis.Analyzer) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="printFlags">
            <h2>printFlags</h2>
            <hr />
            
            <pre><code>func printFlags()</code></pre>
         </article>
         
         <article class="function" data-name="addVersionFlag">
            <h2>addVersionFlag</h2>
            <hr />
            
            <p>addVersionFlag registers a -V flag that, if set,
prints the executable version and exits 0.

If the -V flag already exists — for example, because it was already
registered by a call to cmd/internal/objabi.AddVersionFlag — then
addVersionFlag does nothing.</p>
            
            <pre><code>func addVersionFlag()</code></pre>
         </article>
         
         <article class="function" data-name="IsBoolFlag">
            <h2>IsBoolFlag</h2>
            <hr />
            
            <pre><code>func IsBoolFlag() bool</code></pre>
         </article>
         
         <article class="function" data-name="Get">
            <h2>Get</h2>
            <hr />
            
            <pre><code>func Get() *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(s string) error</code></pre>
         </article>
         
         <article class="function" data-name="triStateFlag">
            <h2>triStateFlag</h2>
            <hr />
            
            <pre><code>func triStateFlag(name string, value triState, usage string) *triState</code></pre>
         </article>
         
         <article class="function" data-name="Get">
            <h2>Get</h2>
            <hr />
            
            <p>triState implements flag.Value, flag.Getter, and flag.boolFlag.
They work like boolean flags: we can say vet -printf as well as vet -printf=true</p>
            
            <pre><code>func Get() *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="isTrue">
            <h2>isTrue</h2>
            <hr />
            
            <pre><code>func isTrue() bool</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(value string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="IsBoolFlag">
            <h2>IsBoolFlag</h2>
            <hr />
            
            <pre><code>func IsBoolFlag() bool</code></pre>
         </article>
         
         <article class="function" data-name="PrintPlain">
            <h2>PrintPlain</h2>
            <hr />
            
            <p>PrintPlain prints a diagnostic in plain text form.
If contextLines is nonnegative, it also prints the
offending line plus this many lines of context.</p>
            
            <pre><code>func PrintPlain(out io.Writer, fset *token.FileSet, contextLines int, diag analysis.Diagnostic)</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add adds the result of analysis 'name' on package 'id'.
The result is either a list of diagnostics or an error.</p>
            
            <pre><code>func Add(fset *token.FileSet, id string, name string, diags []analysis.Diagnostic, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Print">
            <h2>Print</h2>
            <hr />
            
            <pre><code>func Print(out io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="Help">
            <h2>Help</h2>
            <hr />
            
            <p>Help implements the help subcommand for a multichecker or unitchecker
style command. The optional args specify the analyzers to describe.
Help calls log.Fatal if no such analyzer exists.</p>
            
            <pre><code>func Help(progname string, analyzers []*analysis.Analyzer, args []string)</code></pre>
         </article>
         
         <article class="function" data-name="ResolveURL">
            <h2>ResolveURL</h2>
            <hr />
            
            <p>ResolveURL resolves the URL field for a Diagnostic from an Analyzer
and returns the URL. See Diagnostic.URL for details.</p>
            
            <pre><code>func ResolveURL(a *analysis.Analyzer, d analysis.Diagnostic) (string, error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
