<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>time - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="time_tzdata-docs.html">tzdata</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>time</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">_ "time/tzdata"
"errors"
"syscall"
"internal/godebug"
"unsafe"
"errors"
"sync"
"syscall"
"internal/itoa"
"syscall/js"
"errors"
"internal/bytealg"
"runtime"
"syscall"
_ "unsafe"
"errors"
"internal/stringslite"
_ "unsafe"
"errors"
"unsafe"
"errors"
"syscall"
"syscall"
"errors"
"internal/syscall/windows/registry"
"syscall"
"errors"
"runtime"
"syscall"
"errors"
"syscall"
"errors"
"math/bits"
_ "unsafe"
"syscall"
"syscall"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ANSIC" data-name="ANSIC">
               <h3>
                  ANSIC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ANSIC" class="anchor" title="Link to ANSIC">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const ANSIC = "Mon Jan _2 15:04:05 2006"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="April" data-name="April">
               <h3>
                  April 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#April" class="anchor" title="Link to April">#</a>
               </h3>
               
               <pre><code class="language-go">const April</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="August" data-name="August">
               <h3>
                  August 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#August" class="anchor" title="Link to August">#</a>
               </h3>
               
               <pre><code class="language-go">const August</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DateOnly" data-name="DateOnly">
               <h3>
                  DateOnly 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DateOnly" class="anchor" title="Link to DateOnly">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const DateOnly = "2006-01-02"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DateTime" data-name="DateTime">
               <h3>
                  DateTime 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DateTime" class="anchor" title="Link to DateTime">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const DateTime = "2006-01-02 15:04:05"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="December" data-name="December">
               <h3>
                  December 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#December" class="anchor" title="Link to December">#</a>
               </h3>
               
               <pre><code class="language-go">const December</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="February" data-name="February">
               <h3>
                  February 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#February" class="anchor" title="Link to February">#</a>
               </h3>
               
               <pre><code class="language-go">const February</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Friday" data-name="Friday">
               <h3>
                  Friday 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Friday" class="anchor" title="Link to Friday">#</a>
               </h3>
               
               <pre><code class="language-go">const Friday</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Hour" data-name="Hour">
               <h3>
                  Hour 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Hour" class="anchor" title="Link to Hour">#</a>
               </h3>
               
                  <p class="doc-comment">Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
To count the number of units in a [Duration], divide:
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
To convert an integer number of units to a Duration, multiply:
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</p>
               
               <pre><code class="language-go">const Hour = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="January" data-name="January">
               <h3>
                  January 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#January" class="anchor" title="Link to January">#</a>
               </h3>
               
               <pre><code class="language-go">const January Month = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="July" data-name="July">
               <h3>
                  July 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#July" class="anchor" title="Link to July">#</a>
               </h3>
               
               <pre><code class="language-go">const July</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="June" data-name="June">
               <h3>
                  June 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#June" class="anchor" title="Link to June">#</a>
               </h3>
               
               <pre><code class="language-go">const June</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Kitchen" data-name="Kitchen">
               <h3>
                  Kitchen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Kitchen" class="anchor" title="Link to Kitchen">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const Kitchen = "3:04PM"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Layout" data-name="Layout">
               <h3>
                  Layout 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Layout" class="anchor" title="Link to Layout">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const Layout = "01/02 03:04:05PM '06 -0700"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Local" data-name="Local">
               <h3>
                  Local 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Local" class="anchor" title="Link to Local">#</a>
               </h3>
               
                  <p class="doc-comment">Local represents the system's local time zone.
On Unix systems, Local consults the TZ environment
variable to find the time zone to use. No TZ means
use the system default /etc/localtime.
TZ="" means use UTC.
TZ="foo" means use file foo in the system timezone directory.</p>
               
               <pre><code class="language-go">var Local *Location = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="March" data-name="March">
               <h3>
                  March 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#March" class="anchor" title="Link to March">#</a>
               </h3>
               
               <pre><code class="language-go">const March</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="May" data-name="May">
               <h3>
                  May 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#May" class="anchor" title="Link to May">#</a>
               </h3>
               
               <pre><code class="language-go">const May</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Microsecond" data-name="Microsecond">
               <h3>
                  Microsecond 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Microsecond" class="anchor" title="Link to Microsecond">#</a>
               </h3>
               
                  <p class="doc-comment">Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
To count the number of units in a [Duration], divide:
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
To convert an integer number of units to a Duration, multiply:
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</p>
               
               <pre><code class="language-go">const Microsecond = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Millisecond" data-name="Millisecond">
               <h3>
                  Millisecond 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Millisecond" class="anchor" title="Link to Millisecond">#</a>
               </h3>
               
                  <p class="doc-comment">Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
To count the number of units in a [Duration], divide:
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
To convert an integer number of units to a Duration, multiply:
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</p>
               
               <pre><code class="language-go">const Millisecond = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Minute" data-name="Minute">
               <h3>
                  Minute 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Minute" class="anchor" title="Link to Minute">#</a>
               </h3>
               
                  <p class="doc-comment">Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
To count the number of units in a [Duration], divide:
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
To convert an integer number of units to a Duration, multiply:
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</p>
               
               <pre><code class="language-go">const Minute = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Monday" data-name="Monday">
               <h3>
                  Monday 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Monday" class="anchor" title="Link to Monday">#</a>
               </h3>
               
               <pre><code class="language-go">const Monday</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Nanosecond" data-name="Nanosecond">
               <h3>
                  Nanosecond 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Nanosecond" class="anchor" title="Link to Nanosecond">#</a>
               </h3>
               
                  <p class="doc-comment">Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
To count the number of units in a [Duration], divide:
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
To convert an integer number of units to a Duration, multiply:
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</p>
               
               <pre><code class="language-go">const Nanosecond Duration = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="November" data-name="November">
               <h3>
                  November 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#November" class="anchor" title="Link to November">#</a>
               </h3>
               
               <pre><code class="language-go">const November</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="October" data-name="October">
               <h3>
                  October 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#October" class="anchor" title="Link to October">#</a>
               </h3>
               
               <pre><code class="language-go">const October</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RFC1123" data-name="RFC1123">
               <h3>
                  RFC1123 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RFC1123" class="anchor" title="Link to RFC1123">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const RFC1123 = "Mon, 02 Jan 2006 15:04:05 MST"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RFC1123Z" data-name="RFC1123Z">
               <h3>
                  RFC1123Z 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RFC1123Z" class="anchor" title="Link to RFC1123Z">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const RFC1123Z = "Mon, 02 Jan 2006 15:04:05 -0700"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RFC3339" data-name="RFC3339">
               <h3>
                  RFC3339 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RFC3339" class="anchor" title="Link to RFC3339">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const RFC3339 = "2006-01-02T15:04:05Z07:00"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RFC3339Nano" data-name="RFC3339Nano">
               <h3>
                  RFC3339Nano 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RFC3339Nano" class="anchor" title="Link to RFC3339Nano">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const RFC3339Nano = "2006-01-02T15:04:05.999999999Z07:00"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RFC822" data-name="RFC822">
               <h3>
                  RFC822 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RFC822" class="anchor" title="Link to RFC822">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const RFC822 = "02 Jan 06 15:04 MST"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RFC822Z" data-name="RFC822Z">
               <h3>
                  RFC822Z 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RFC822Z" class="anchor" title="Link to RFC822Z">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const RFC822Z = "02 Jan 06 15:04 -0700"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RFC850" data-name="RFC850">
               <h3>
                  RFC850 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RFC850" class="anchor" title="Link to RFC850">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const RFC850 = "Monday, 02-Jan-06 15:04:05 MST"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RubyDate" data-name="RubyDate">
               <h3>
                  RubyDate 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RubyDate" class="anchor" title="Link to RubyDate">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const RubyDate = "Mon Jan 02 15:04:05 -0700 2006"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Saturday" data-name="Saturday">
               <h3>
                  Saturday 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Saturday" class="anchor" title="Link to Saturday">#</a>
               </h3>
               
               <pre><code class="language-go">const Saturday</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Second" data-name="Second">
               <h3>
                  Second 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Second" class="anchor" title="Link to Second">#</a>
               </h3>
               
                  <p class="doc-comment">Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
To count the number of units in a [Duration], divide:
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
To convert an integer number of units to a Duration, multiply:
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</p>
               
               <pre><code class="language-go">const Second = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="September" data-name="September">
               <h3>
                  September 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#September" class="anchor" title="Link to September">#</a>
               </h3>
               
               <pre><code class="language-go">const September</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Stamp" data-name="Stamp">
               <h3>
                  Stamp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Stamp" class="anchor" title="Link to Stamp">#</a>
               </h3>
               
                  <p class="doc-comment">Handy time stamps.</p>
               
               <pre><code class="language-go">const Stamp = "Jan _2 15:04:05"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StampMicro" data-name="StampMicro">
               <h3>
                  StampMicro 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StampMicro" class="anchor" title="Link to StampMicro">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const StampMicro = "Jan _2 15:04:05.000000"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StampMilli" data-name="StampMilli">
               <h3>
                  StampMilli 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StampMilli" class="anchor" title="Link to StampMilli">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const StampMilli = "Jan _2 15:04:05.000"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StampNano" data-name="StampNano">
               <h3>
                  StampNano 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StampNano" class="anchor" title="Link to StampNano">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const StampNano = "Jan _2 15:04:05.000000000"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Sunday" data-name="Sunday">
               <h3>
                  Sunday 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Sunday" class="anchor" title="Link to Sunday">#</a>
               </h3>
               
               <pre><code class="language-go">const Sunday Weekday = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Thursday" data-name="Thursday">
               <h3>
                  Thursday 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Thursday" class="anchor" title="Link to Thursday">#</a>
               </h3>
               
               <pre><code class="language-go">const Thursday</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TimeOnly" data-name="TimeOnly">
               <h3>
                  TimeOnly 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TimeOnly" class="anchor" title="Link to TimeOnly">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const TimeOnly = "15:04:05"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Tuesday" data-name="Tuesday">
               <h3>
                  Tuesday 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Tuesday" class="anchor" title="Link to Tuesday">#</a>
               </h3>
               
               <pre><code class="language-go">const Tuesday</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UTC" data-name="UTC">
               <h3>
                  UTC 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#UTC" class="anchor" title="Link to UTC">#</a>
               </h3>
               
                  <p class="doc-comment">UTC represents Universal Coordinated Time (UTC).</p>
               
               <pre><code class="language-go">var UTC *Location = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnixDate" data-name="UnixDate">
               <h3>
                  UnixDate 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnixDate" class="anchor" title="Link to UnixDate">#</a>
               </h3>
               
                  <p class="doc-comment">These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code class="language-go">const UnixDate = "Mon Jan _2 15:04:05 MST 2006"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Wednesday" data-name="Wednesday">
               <h3>
                  Wednesday 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Wednesday" class="anchor" title="Link to Wednesday">#</a>
               </h3>
               
               <pre><code class="language-go">const Wednesday</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">const _ = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="abbrs" data-name="abbrs">
               <h3>
                  abbrs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#abbrs" class="anchor" title="Link to abbrs">#</a>
               </h3>
               
               <pre><code class="language-go">var abbrs = map[string]abbr{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="absoluteToInternal" data-name="absoluteToInternal">
               <h3>
                  absoluteToInternal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#absoluteToInternal" class="anchor" title="Link to absoluteToInternal">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets to convert between internal and absolute or Unix times.</p>
               
               <pre><code class="language-go">const absoluteToInternal int64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="absoluteToUnix" data-name="absoluteToUnix">
               <h3>
                  absoluteToUnix 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#absoluteToUnix" class="anchor" title="Link to absoluteToUnix">#</a>
               </h3>
               
                  <p class="doc-comment">To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code class="language-go">const absoluteToUnix = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="absoluteYears" data-name="absoluteYears">
               <h3>
                  absoluteYears 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#absoluteYears" class="anchor" title="Link to absoluteYears">#</a>
               </h3>
               
                  <p class="doc-comment">absoluteYears is the number of years we subtract from internal time to get absolute time.
This value must be 0 mod 400, and it defines the “absolute zero instant”
mentioned in the “Computations on Times” comment above: March 1, -absoluteYears.
Dates before the absolute epoch will not compute correctly,
but otherwise the value can be changed as needed.</p>
               
               <pre><code class="language-go">const absoluteYears = 292277022400</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="allowGorootSource" data-name="allowGorootSource">
               <h3>
                  allowGorootSource 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#allowGorootSource" class="anchor" title="Link to allowGorootSource">#</a>
               </h3>
               
               <pre><code class="language-go">var allowGorootSource = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="alpha" data-name="alpha">
               <h3>
                  alpha 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#alpha" class="anchor" title="Link to alpha">#</a>
               </h3>
               
                  <p class="doc-comment">alpha and omega are the beginning and end of time for zone
transitions.</p>
               
               <pre><code class="language-go">const alpha = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="asynctimerchan" data-name="asynctimerchan">
               <h3>
                  asynctimerchan 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#asynctimerchan" class="anchor" title="Link to asynctimerchan">#</a>
               </h3>
               
               <pre><code class="language-go">var asynctimerchan = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="aus" data-name="aus">
               <h3>
                  aus 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#aus" class="anchor" title="Link to aus">#</a>
               </h3>
               
               <pre><code class="language-go">var aus = syscall.Timezoneinformation{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="daysPer400Years" data-name="daysPer400Years">
               <h3>
                  daysPer400Years 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#daysPer400Years" class="anchor" title="Link to daysPer400Years">#</a>
               </h3>
               
                  <p class="doc-comment">To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code class="language-go">const daysPer400Years = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errAtoi" data-name="errAtoi">
               <h3>
                  errAtoi 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errAtoi" class="anchor" title="Link to errAtoi">#</a>
               </h3>
               
                  <p class="doc-comment">Never printed, just needs to be non-nil for return by atoi.</p>
               
               <pre><code class="language-go">var errAtoi = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errBad" data-name="errBad">
               <h3>
                  errBad 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errBad" class="anchor" title="Link to errBad">#</a>
               </h3>
               
               <pre><code class="language-go">var errBad = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errBadData" data-name="errBadData">
               <h3>
                  errBadData 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errBadData" class="anchor" title="Link to errBadData">#</a>
               </h3>
               
               <pre><code class="language-go">var errBadData = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errLeadingInt" data-name="errLeadingInt">
               <h3>
                  errLeadingInt 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errLeadingInt" class="anchor" title="Link to errLeadingInt">#</a>
               </h3>
               
               <pre><code class="language-go">var errLeadingInt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errLocation" data-name="errLocation">
               <h3>
                  errLocation 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errLocation" class="anchor" title="Link to errLocation">#</a>
               </h3>
               
               <pre><code class="language-go">var errLocation = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hasMonotonic" data-name="hasMonotonic">
               <h3>
                  hasMonotonic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#hasMonotonic" class="anchor" title="Link to hasMonotonic">#</a>
               </h3>
               
               <pre><code class="language-go">const hasMonotonic = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="internalToAbsolute" data-name="internalToAbsolute">
               <h3>
                  internalToAbsolute 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#internalToAbsolute" class="anchor" title="Link to internalToAbsolute">#</a>
               </h3>
               
                  <p class="doc-comment">To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code class="language-go">const internalToAbsolute = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="internalToUnix" data-name="internalToUnix">
               <h3>
                  internalToUnix 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#internalToUnix" class="anchor" title="Link to internalToUnix">#</a>
               </h3>
               
                  <p class="doc-comment">To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code class="language-go">const internalToUnix int64 = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="internalYear" data-name="internalYear">
               <h3>
                  internalYear 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#internalYear" class="anchor" title="Link to internalYear">#</a>
               </h3>
               
                  <p class="doc-comment">The year of the zero Time.
Assumed by the unixToInternal computation below.</p>
               
               <pre><code class="language-go">const internalYear = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="loadFromEmbeddedTZData" data-name="loadFromEmbeddedTZData">
               <h3>
                  loadFromEmbeddedTZData 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#loadFromEmbeddedTZData" class="anchor" title="Link to loadFromEmbeddedTZData">#</a>
               </h3>
               
                  <p class="doc-comment">loadFromEmbeddedTZData is used to load a specific tzdata file
from tzdata information embedded in the binary itself.
This is set when the time/tzdata package is imported,
via registerLoadFromEmbeddedTzdata.</p>
               
               <pre><code class="language-go">var loadFromEmbeddedTZData func(zipname string) (string, error)</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="loadTzinfoFromTzdata" data-name="loadTzinfoFromTzdata">
               <h3>
                  loadTzinfoFromTzdata 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#loadTzinfoFromTzdata" class="anchor" title="Link to loadTzinfoFromTzdata">#</a>
               </h3>
               
                  <p class="doc-comment">loadTzinfoFromTzdata returns the time zone information of the time zone
with the given name, from a tzdata database file as they are typically
found on android.</p>
               
               <pre><code class="language-go">var loadTzinfoFromTzdata func(file string, name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="localLoc" data-name="localLoc">
               <h3>
                  localLoc 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#localLoc" class="anchor" title="Link to localLoc">#</a>
               </h3>
               
                  <p class="doc-comment">localLoc is separate so that initLocal can initialize
it even if a client has changed Local.</p>
               
               <pre><code class="language-go">var localLoc Location</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="localOnce" data-name="localOnce">
               <h3>
                  localOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#localOnce" class="anchor" title="Link to localOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var localOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="longDayNames" data-name="longDayNames">
               <h3>
                  longDayNames 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#longDayNames" class="anchor" title="Link to longDayNames">#</a>
               </h3>
               
               <pre><code class="language-go">var longDayNames = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="longMonthNames" data-name="longMonthNames">
               <h3>
                  longMonthNames 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#longMonthNames" class="anchor" title="Link to longMonthNames">#</a>
               </h3>
               
               <pre><code class="language-go">var longMonthNames = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lowerhex" data-name="lowerhex">
               <h3>
                  lowerhex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#lowerhex" class="anchor" title="Link to lowerhex">#</a>
               </h3>
               
                  <p class="doc-comment">These are borrowed from unicode/utf8 and strconv and replicate behavior in
that package, since we can't take a dependency on either.</p>
               
               <pre><code class="language-go">const lowerhex = "0123456789abcdef"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="marchThruDecember" data-name="marchThruDecember">
               <h3>
                  marchThruDecember 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#marchThruDecember" class="anchor" title="Link to marchThruDecember">#</a>
               </h3>
               
                  <p class="doc-comment">Days from March 1 through end of year</p>
               
               <pre><code class="language-go">const marchThruDecember = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxDuration" data-name="maxDuration">
               <h3>
                  maxDuration 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxDuration" class="anchor" title="Link to maxDuration">#</a>
               </h3>
               
               <pre><code class="language-go">const maxDuration Duration = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxFileSize" data-name="maxFileSize">
               <h3>
                  maxFileSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxFileSize" class="anchor" title="Link to maxFileSize">#</a>
               </h3>
               
                  <p class="doc-comment">maxFileSize is the max permitted size of files read by readFile.
As reference, the zoneinfo.zip distributed by Go is ~350 KB,
so 10MB is overkill.</p>
               
               <pre><code class="language-go">const maxFileSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxWall" data-name="maxWall">
               <h3>
                  maxWall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxWall" class="anchor" title="Link to maxWall">#</a>
               </h3>
               
               <pre><code class="language-go">const maxWall = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="minDuration" data-name="minDuration">
               <h3>
                  minDuration 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#minDuration" class="anchor" title="Link to minDuration">#</a>
               </h3>
               
               <pre><code class="language-go">const minDuration Duration = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="minWall" data-name="minWall">
               <h3>
                  minWall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#minWall" class="anchor" title="Link to minWall">#</a>
               </h3>
               
               <pre><code class="language-go">const minWall = wallToInternal</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nsecMask" data-name="nsecMask">
               <h3>
                  nsecMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nsecMask" class="anchor" title="Link to nsecMask">#</a>
               </h3>
               
               <pre><code class="language-go">const nsecMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nsecShift" data-name="nsecShift">
               <h3>
                  nsecShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#nsecShift" class="anchor" title="Link to nsecShift">#</a>
               </h3>
               
               <pre><code class="language-go">const nsecShift = 30</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="omega" data-name="omega">
               <h3>
                  omega 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#omega" class="anchor" title="Link to omega">#</a>
               </h3>
               
                  <p class="doc-comment">alpha and omega are the beginning and end of time for zone
transitions.</p>
               
               <pre><code class="language-go">const omega = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="platformZoneSources" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#platformZoneSources" class="anchor" title="Link to platformZoneSources">#</a>
               </h3>
               
               <pre><code class="language-go">var platformZoneSources []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="platformZoneSources" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#platformZoneSources" class="anchor" title="Link to platformZoneSources">#</a>
               </h3>
               
                  <p class="doc-comment">Many systems use /usr/share/zoneinfo, Solaris 2 has
/usr/share/lib/zoneinfo, IRIX 6 has /usr/lib/locale/TZ,
NixOS has /etc/zoneinfo.</p>
               
               <pre><code class="language-go">var platformZoneSources = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="platformZoneSources" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#platformZoneSources" class="anchor" title="Link to platformZoneSources">#</a>
               </h3>
               
               <pre><code class="language-go">var platformZoneSources []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="platformZoneSources" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#platformZoneSources" class="anchor" title="Link to platformZoneSources">#</a>
               </h3>
               
               <pre><code class="language-go">var platformZoneSources = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="platformZoneSources" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#platformZoneSources" class="anchor" title="Link to platformZoneSources">#</a>
               </h3>
               
               <pre><code class="language-go">var platformZoneSources []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="platformZoneSources" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#platformZoneSources" class="anchor" title="Link to platformZoneSources">#</a>
               </h3>
               
               <pre><code class="language-go">var platformZoneSources = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="platformZoneSources" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#platformZoneSources" class="anchor" title="Link to platformZoneSources">#</a>
               </h3>
               
                  <p class="doc-comment">in wasip1 zoneinfo is managed by the runtime.</p>
               
               <pre><code class="language-go">var platformZoneSources = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ruleDOY" data-name="ruleDOY">
               <h3>
                  ruleDOY 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ruleDOY" class="anchor" title="Link to ruleDOY">#</a>
               </h3>
               
               <pre><code class="language-go">const ruleDOY</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ruleJulian" data-name="ruleJulian">
               <h3>
                  ruleJulian 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ruleJulian" class="anchor" title="Link to ruleJulian">#</a>
               </h3>
               
               <pre><code class="language-go">const ruleJulian ruleKind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ruleMonthWeekDay" data-name="ruleMonthWeekDay">
               <h3>
                  ruleMonthWeekDay 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ruleMonthWeekDay" class="anchor" title="Link to ruleMonthWeekDay">#</a>
               </h3>
               
               <pre><code class="language-go">const ruleMonthWeekDay</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="runeError" data-name="runeError">
               <h3>
                  runeError 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#runeError" class="anchor" title="Link to runeError">#</a>
               </h3>
               
                  <p class="doc-comment">These are borrowed from unicode/utf8 and strconv and replicate behavior in
that package, since we can't take a dependency on either.</p>
               
               <pre><code class="language-go">const runeError = '\uFFFD'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="runeSelf" data-name="runeSelf">
               <h3>
                  runeSelf 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#runeSelf" class="anchor" title="Link to runeSelf">#</a>
               </h3>
               
                  <p class="doc-comment">These are borrowed from unicode/utf8 and strconv and replicate behavior in
that package, since we can't take a dependency on either.</p>
               
               <pre><code class="language-go">const runeSelf = 0x80</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="secondsPerDay" data-name="secondsPerDay">
               <h3>
                  secondsPerDay 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#secondsPerDay" class="anchor" title="Link to secondsPerDay">#</a>
               </h3>
               
                  <p class="doc-comment">To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code class="language-go">const secondsPerDay = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="secondsPerHour" data-name="secondsPerHour">
               <h3>
                  secondsPerHour 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#secondsPerHour" class="anchor" title="Link to secondsPerHour">#</a>
               </h3>
               
                  <p class="doc-comment">To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code class="language-go">const secondsPerHour = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="secondsPerMinute" data-name="secondsPerMinute">
               <h3>
                  secondsPerMinute 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#secondsPerMinute" class="anchor" title="Link to secondsPerMinute">#</a>
               </h3>
               
                  <p class="doc-comment">To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code class="language-go">const secondsPerMinute = 60</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="secondsPerWeek" data-name="secondsPerWeek">
               <h3>
                  secondsPerWeek 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#secondsPerWeek" class="anchor" title="Link to secondsPerWeek">#</a>
               </h3>
               
                  <p class="doc-comment">To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code class="language-go">const secondsPerWeek = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="seekCurrent" data-name="seekCurrent">
               <h3>
                  seekCurrent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#seekCurrent" class="anchor" title="Link to seekCurrent">#</a>
               </h3>
               
                  <p class="doc-comment">Copies of io.Seek* constants to avoid importing "io":</p>
               
               <pre><code class="language-go">const seekCurrent = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="seekEnd" data-name="seekEnd">
               <h3>
                  seekEnd 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#seekEnd" class="anchor" title="Link to seekEnd">#</a>
               </h3>
               
                  <p class="doc-comment">Copies of io.Seek* constants to avoid importing "io":</p>
               
               <pre><code class="language-go">const seekEnd = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="seekStart" data-name="seekStart">
               <h3>
                  seekStart 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#seekStart" class="anchor" title="Link to seekStart">#</a>
               </h3>
               
                  <p class="doc-comment">Copies of io.Seek* constants to avoid importing "io":</p>
               
               <pre><code class="language-go">const seekStart = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="shortDayNames" data-name="shortDayNames">
               <h3>
                  shortDayNames 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#shortDayNames" class="anchor" title="Link to shortDayNames">#</a>
               </h3>
               
               <pre><code class="language-go">var shortDayNames = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="shortMonthNames" data-name="shortMonthNames">
               <h3>
                  shortMonthNames 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#shortMonthNames" class="anchor" title="Link to shortMonthNames">#</a>
               </h3>
               
               <pre><code class="language-go">var shortMonthNames = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="startNano" data-name="startNano">
               <h3>
                  startNano 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#startNano" class="anchor" title="Link to startNano">#</a>
               </h3>
               
                  <p class="doc-comment">Monotonic times are reported as offsets from startNano.
We initialize startNano to runtimeNano() - 1 so that on systems where
monotonic time resolution is fairly low (e.g. Windows 2008
which appears to have a default resolution of 15ms),
we avoid ever reporting a monotonic time of 0.
(Callers may want to use 0 as "time not set".)</p>
               
               <pre><code class="language-go">var startNano int64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="std0x" data-name="std0x">
               <h3>
                  std0x 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#std0x" class="anchor" title="Link to std0x">#</a>
               </h3>
               
                  <p class="doc-comment">std0x records the std values for "01", "02", ..., "06".</p>
               
               <pre><code class="language-go">var std0x = [...]int{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdArgShift" data-name="stdArgShift">
               <h3>
                  stdArgShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdArgShift" class="anchor" title="Link to stdArgShift">#</a>
               </h3>
               
               <pre><code class="language-go">const stdArgShift = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdDay" data-name="stdDay">
               <h3>
                  stdDay 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdDay" class="anchor" title="Link to stdDay">#</a>
               </h3>
               
               <pre><code class="language-go">const stdDay</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdFracSecond0" data-name="stdFracSecond0">
               <h3>
                  stdFracSecond0 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdFracSecond0" class="anchor" title="Link to stdFracSecond0">#</a>
               </h3>
               
               <pre><code class="language-go">const stdFracSecond0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdFracSecond9" data-name="stdFracSecond9">
               <h3>
                  stdFracSecond9 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdFracSecond9" class="anchor" title="Link to stdFracSecond9">#</a>
               </h3>
               
               <pre><code class="language-go">const stdFracSecond9</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdHour" data-name="stdHour">
               <h3>
                  stdHour 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdHour" class="anchor" title="Link to stdHour">#</a>
               </h3>
               
               <pre><code class="language-go">const stdHour = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdHour12" data-name="stdHour12">
               <h3>
                  stdHour12 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdHour12" class="anchor" title="Link to stdHour12">#</a>
               </h3>
               
               <pre><code class="language-go">const stdHour12</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdISO8601ColonSecondsTZ" data-name="stdISO8601ColonSecondsTZ">
               <h3>
                  stdISO8601ColonSecondsTZ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdISO8601ColonSecondsTZ" class="anchor" title="Link to stdISO8601ColonSecondsTZ">#</a>
               </h3>
               
               <pre><code class="language-go">const stdISO8601ColonSecondsTZ</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdISO8601ColonTZ" data-name="stdISO8601ColonTZ">
               <h3>
                  stdISO8601ColonTZ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdISO8601ColonTZ" class="anchor" title="Link to stdISO8601ColonTZ">#</a>
               </h3>
               
               <pre><code class="language-go">const stdISO8601ColonTZ</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdISO8601SecondsTZ" data-name="stdISO8601SecondsTZ">
               <h3>
                  stdISO8601SecondsTZ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdISO8601SecondsTZ" class="anchor" title="Link to stdISO8601SecondsTZ">#</a>
               </h3>
               
               <pre><code class="language-go">const stdISO8601SecondsTZ</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdISO8601ShortTZ" data-name="stdISO8601ShortTZ">
               <h3>
                  stdISO8601ShortTZ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdISO8601ShortTZ" class="anchor" title="Link to stdISO8601ShortTZ">#</a>
               </h3>
               
               <pre><code class="language-go">const stdISO8601ShortTZ</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdISO8601TZ" data-name="stdISO8601TZ">
               <h3>
                  stdISO8601TZ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdISO8601TZ" class="anchor" title="Link to stdISO8601TZ">#</a>
               </h3>
               
               <pre><code class="language-go">const stdISO8601TZ</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdLongMonth" data-name="stdLongMonth">
               <h3>
                  stdLongMonth 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdLongMonth" class="anchor" title="Link to stdLongMonth">#</a>
               </h3>
               
               <pre><code class="language-go">const stdLongMonth = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdLongWeekDay" data-name="stdLongWeekDay">
               <h3>
                  stdLongWeekDay 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdLongWeekDay" class="anchor" title="Link to stdLongWeekDay">#</a>
               </h3>
               
               <pre><code class="language-go">const stdLongWeekDay</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdLongYear" data-name="stdLongYear">
               <h3>
                  stdLongYear 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdLongYear" class="anchor" title="Link to stdLongYear">#</a>
               </h3>
               
               <pre><code class="language-go">const stdLongYear = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdMask" data-name="stdMask">
               <h3>
                  stdMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdMask" class="anchor" title="Link to stdMask">#</a>
               </h3>
               
               <pre><code class="language-go">const stdMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdMinute" data-name="stdMinute">
               <h3>
                  stdMinute 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdMinute" class="anchor" title="Link to stdMinute">#</a>
               </h3>
               
               <pre><code class="language-go">const stdMinute</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdMonth" data-name="stdMonth">
               <h3>
                  stdMonth 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdMonth" class="anchor" title="Link to stdMonth">#</a>
               </h3>
               
               <pre><code class="language-go">const stdMonth</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdNeedClock" data-name="stdNeedClock">
               <h3>
                  stdNeedClock 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdNeedClock" class="anchor" title="Link to stdNeedClock">#</a>
               </h3>
               
               <pre><code class="language-go">const stdNeedClock = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdNeedDate" data-name="stdNeedDate">
               <h3>
                  stdNeedDate 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdNeedDate" class="anchor" title="Link to stdNeedDate">#</a>
               </h3>
               
               <pre><code class="language-go">const stdNeedDate = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdNeedYday" data-name="stdNeedYday">
               <h3>
                  stdNeedYday 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdNeedYday" class="anchor" title="Link to stdNeedYday">#</a>
               </h3>
               
               <pre><code class="language-go">const stdNeedYday = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdNumColonSecondsTZ" data-name="stdNumColonSecondsTZ">
               <h3>
                  stdNumColonSecondsTZ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdNumColonSecondsTZ" class="anchor" title="Link to stdNumColonSecondsTZ">#</a>
               </h3>
               
               <pre><code class="language-go">const stdNumColonSecondsTZ</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdNumColonTZ" data-name="stdNumColonTZ">
               <h3>
                  stdNumColonTZ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdNumColonTZ" class="anchor" title="Link to stdNumColonTZ">#</a>
               </h3>
               
               <pre><code class="language-go">const stdNumColonTZ</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdNumMonth" data-name="stdNumMonth">
               <h3>
                  stdNumMonth 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdNumMonth" class="anchor" title="Link to stdNumMonth">#</a>
               </h3>
               
               <pre><code class="language-go">const stdNumMonth</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdNumSecondsTz" data-name="stdNumSecondsTz">
               <h3>
                  stdNumSecondsTz 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdNumSecondsTz" class="anchor" title="Link to stdNumSecondsTz">#</a>
               </h3>
               
               <pre><code class="language-go">const stdNumSecondsTz</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdNumShortTZ" data-name="stdNumShortTZ">
               <h3>
                  stdNumShortTZ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdNumShortTZ" class="anchor" title="Link to stdNumShortTZ">#</a>
               </h3>
               
               <pre><code class="language-go">const stdNumShortTZ</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdNumTZ" data-name="stdNumTZ">
               <h3>
                  stdNumTZ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdNumTZ" class="anchor" title="Link to stdNumTZ">#</a>
               </h3>
               
               <pre><code class="language-go">const stdNumTZ</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdPM" data-name="stdPM">
               <h3>
                  stdPM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdPM" class="anchor" title="Link to stdPM">#</a>
               </h3>
               
               <pre><code class="language-go">const stdPM = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdSecond" data-name="stdSecond">
               <h3>
                  stdSecond 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdSecond" class="anchor" title="Link to stdSecond">#</a>
               </h3>
               
               <pre><code class="language-go">const stdSecond</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdSeparatorShift" data-name="stdSeparatorShift">
               <h3>
                  stdSeparatorShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdSeparatorShift" class="anchor" title="Link to stdSeparatorShift">#</a>
               </h3>
               
               <pre><code class="language-go">const stdSeparatorShift = 28</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdTZ" data-name="stdTZ">
               <h3>
                  stdTZ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdTZ" class="anchor" title="Link to stdTZ">#</a>
               </h3>
               
               <pre><code class="language-go">const stdTZ = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdUnderDay" data-name="stdUnderDay">
               <h3>
                  stdUnderDay 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdUnderDay" class="anchor" title="Link to stdUnderDay">#</a>
               </h3>
               
               <pre><code class="language-go">const stdUnderDay</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdUnderYearDay" data-name="stdUnderYearDay">
               <h3>
                  stdUnderYearDay 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdUnderYearDay" class="anchor" title="Link to stdUnderYearDay">#</a>
               </h3>
               
               <pre><code class="language-go">const stdUnderYearDay = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdWeekDay" data-name="stdWeekDay">
               <h3>
                  stdWeekDay 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdWeekDay" class="anchor" title="Link to stdWeekDay">#</a>
               </h3>
               
               <pre><code class="language-go">const stdWeekDay</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdYear" data-name="stdYear">
               <h3>
                  stdYear 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdYear" class="anchor" title="Link to stdYear">#</a>
               </h3>
               
               <pre><code class="language-go">const stdYear</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdZeroDay" data-name="stdZeroDay">
               <h3>
                  stdZeroDay 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdZeroDay" class="anchor" title="Link to stdZeroDay">#</a>
               </h3>
               
               <pre><code class="language-go">const stdZeroDay</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdZeroHour12" data-name="stdZeroHour12">
               <h3>
                  stdZeroHour12 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdZeroHour12" class="anchor" title="Link to stdZeroHour12">#</a>
               </h3>
               
               <pre><code class="language-go">const stdZeroHour12</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdZeroMinute" data-name="stdZeroMinute">
               <h3>
                  stdZeroMinute 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdZeroMinute" class="anchor" title="Link to stdZeroMinute">#</a>
               </h3>
               
               <pre><code class="language-go">const stdZeroMinute</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdZeroMonth" data-name="stdZeroMonth">
               <h3>
                  stdZeroMonth 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdZeroMonth" class="anchor" title="Link to stdZeroMonth">#</a>
               </h3>
               
               <pre><code class="language-go">const stdZeroMonth</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdZeroSecond" data-name="stdZeroSecond">
               <h3>
                  stdZeroSecond 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdZeroSecond" class="anchor" title="Link to stdZeroSecond">#</a>
               </h3>
               
               <pre><code class="language-go">const stdZeroSecond</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdZeroYearDay" data-name="stdZeroYearDay">
               <h3>
                  stdZeroYearDay 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdZeroYearDay" class="anchor" title="Link to stdZeroYearDay">#</a>
               </h3>
               
               <pre><code class="language-go">const stdZeroYearDay</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stdpm" data-name="stdpm">
               <h3>
                  stdpm 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stdpm" class="anchor" title="Link to stdpm">#</a>
               </h3>
               
               <pre><code class="language-go">const stdpm</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="timeBinaryVersionV1" data-name="timeBinaryVersionV1">
               <h3>
                  timeBinaryVersionV1 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#timeBinaryVersionV1" class="anchor" title="Link to timeBinaryVersionV1">#</a>
               </h3>
               
               <pre><code class="language-go">const timeBinaryVersionV1 byte = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="timeBinaryVersionV2" data-name="timeBinaryVersionV2">
               <h3>
                  timeBinaryVersionV2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#timeBinaryVersionV2" class="anchor" title="Link to timeBinaryVersionV2">#</a>
               </h3>
               
               <pre><code class="language-go">const timeBinaryVersionV2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unitMap" data-name="unitMap">
               <h3>
                  unitMap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#unitMap" class="anchor" title="Link to unitMap">#</a>
               </h3>
               
               <pre><code class="language-go">var unitMap = map[string]uint64{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unixToAbsolute" data-name="unixToAbsolute">
               <h3>
                  unixToAbsolute 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#unixToAbsolute" class="anchor" title="Link to unixToAbsolute">#</a>
               </h3>
               
                  <p class="doc-comment">To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code class="language-go">const unixToAbsolute = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unixToInternal" data-name="unixToInternal">
               <h3>
                  unixToInternal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#unixToInternal" class="anchor" title="Link to unixToInternal">#</a>
               </h3>
               
                  <p class="doc-comment">To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code class="language-go">const unixToInternal int64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unnamedFixedZones" data-name="unnamedFixedZones">
               <h3>
                  unnamedFixedZones 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#unnamedFixedZones" class="anchor" title="Link to unnamedFixedZones">#</a>
               </h3>
               
               <pre><code class="language-go">var unnamedFixedZones []*Location</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unnamedFixedZonesOnce" data-name="unnamedFixedZonesOnce">
               <h3>
                  unnamedFixedZonesOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#unnamedFixedZonesOnce" class="anchor" title="Link to unnamedFixedZonesOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var unnamedFixedZonesOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="usPacific" data-name="usPacific">
               <h3>
                  usPacific 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#usPacific" class="anchor" title="Link to usPacific">#</a>
               </h3>
               
               <pre><code class="language-go">var usPacific = syscall.Timezoneinformation{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="utcLoc" data-name="utcLoc">
               <h3>
                  utcLoc 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#utcLoc" class="anchor" title="Link to utcLoc">#</a>
               </h3>
               
                  <p class="doc-comment">utcLoc is separate so that get can refer to &utcLoc
and ensure that it never returns a nil *Location,
even if a badly behaved client has changed UTC.</p>
               
               <pre><code class="language-go">var utcLoc = Location{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="wallToInternal" data-name="wallToInternal">
               <h3>
                  wallToInternal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#wallToInternal" class="anchor" title="Link to wallToInternal">#</a>
               </h3>
               
                  <p class="doc-comment">To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code class="language-go">const wallToInternal int64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="zoneinfo" data-name="zoneinfo">
               <h3>
                  zoneinfo 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#zoneinfo" class="anchor" title="Link to zoneinfo">#</a>
               </h3>
               
               <pre><code class="language-go">var zoneinfo *string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="zoneinfoOnce" data-name="zoneinfoOnce">
               <h3>
                  zoneinfoOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#zoneinfoOnce" class="anchor" title="Link to zoneinfoOnce">#</a>
               </h3>
               
               <pre><code class="language-go">var zoneinfoOnce sync.Once</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Duration" data-name="Duration">
               <h3>
                  Duration
                  <span class="badge type-badge">type</span>
                  <a href="#Duration" class="anchor" title="Link to Duration">#</a>
               </h3>
               
               <p>A Duration represents the elapsed time between two instants
as an int64 nanosecond count. The representation limits the
largest representable duration to approximately 290 years.</p>
               
               <pre><code class="language-go">type Duration int64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Month" data-name="Month">
               <h3>
                  Month
                  <span class="badge type-badge">type</span>
                  <a href="#Month" class="anchor" title="Link to Month">#</a>
               </h3>
               
               <p>A Month specifies a month of the year (January = 1, ...).</p>
               
               <pre><code class="language-go">type Month int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Weekday" data-name="Weekday">
               <h3>
                  Weekday
                  <span class="badge type-badge">type</span>
                  <a href="#Weekday" class="anchor" title="Link to Weekday">#</a>
               </h3>
               
               <p>A Weekday specifies a day of the week (Sunday = 0, ...).</p>
               
               <pre><code class="language-go">type Weekday int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="absCentury" data-name="absCentury">
               <h3>
                  absCentury
                  <span class="badge type-badge">type</span>
                  <a href="#absCentury" class="anchor" title="Link to absCentury">#</a>
               </h3>
               
               <p>An absCentury counts the number of centuries since the absolute zero instant.</p>
               
               <pre><code class="language-go">type absCentury uint64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="absCyear" data-name="absCyear">
               <h3>
                  absCyear
                  <span class="badge type-badge">type</span>
                  <a href="#absCyear" class="anchor" title="Link to absCyear">#</a>
               </h3>
               
               <p>An absCyear counts the number of years since the start of a century.</p>
               
               <pre><code class="language-go">type absCyear int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="absDays" data-name="absDays">
               <h3>
                  absDays
                  <span class="badge type-badge">type</span>
                  <a href="#absDays" class="anchor" title="Link to absDays">#</a>
               </h3>
               
               <p>An absDays counts the number of days since the absolute zero instant.</p>
               
               <pre><code class="language-go">type absDays uint64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="absJanFeb" data-name="absJanFeb">
               <h3>
                  absJanFeb
                  <span class="badge type-badge">type</span>
                  <a href="#absJanFeb" class="anchor" title="Link to absJanFeb">#</a>
               </h3>
               
               <p>An absJanFeb is a single bit (0 or 1) denoting whether a given day falls in January or February.
That is a special case because the absolute years start in March (unlike normal calendar years).</p>
               
               <pre><code class="language-go">type absJanFeb int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="absLeap" data-name="absLeap">
               <h3>
                  absLeap
                  <span class="badge type-badge">type</span>
                  <a href="#absLeap" class="anchor" title="Link to absLeap">#</a>
               </h3>
               
               <p>An absLeap is a single bit (0 or 1) denoting whether a given year is a leap year.</p>
               
               <pre><code class="language-go">type absLeap int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="absMonth" data-name="absMonth">
               <h3>
                  absMonth
                  <span class="badge type-badge">type</span>
                  <a href="#absMonth" class="anchor" title="Link to absMonth">#</a>
               </h3>
               
               <p>An absMonth counts the number of months since the start of a year.
absMonth=0 denotes March.</p>
               
               <pre><code class="language-go">type absMonth int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="absSeconds" data-name="absSeconds">
               <h3>
                  absSeconds
                  <span class="badge type-badge">type</span>
                  <a href="#absSeconds" class="anchor" title="Link to absSeconds">#</a>
               </h3>
               
               <p>An absSeconds counts the number of seconds since the absolute zero instant.</p>
               
               <pre><code class="language-go">type absSeconds uint64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="absYday" data-name="absYday">
               <h3>
                  absYday
                  <span class="badge type-badge">type</span>
                  <a href="#absYday" class="anchor" title="Link to absYday">#</a>
               </h3>
               
               <p>An absYday counts the number of days since the start of a year.
Note that absolute years start on March 1.</p>
               
               <pre><code class="language-go">type absYday int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="fileSizeError" data-name="fileSizeError">
               <h3>
                  fileSizeError
                  <span class="badge type-badge">type</span>
                  <a href="#fileSizeError" class="anchor" title="Link to fileSizeError">#</a>
               </h3>
               
               <pre><code class="language-go">type fileSizeError string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ruleKind" data-name="ruleKind">
               <h3>
                  ruleKind
                  <span class="badge type-badge">type</span>
                  <a href="#ruleKind" class="anchor" title="Link to ruleKind">#</a>
               </h3>
               
               <p>ruleKind is the kinds of rules that can be seen in a tzset string.</p>
               
               <pre><code class="language-go">type ruleKind int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Location" data-name="Location">
               <h3>
                  Location
                  <span class="badge">struct</span>
                  <a href="#Location" class="anchor" title="Link to Location">#</a>
               </h3>
               
               <p>A Location maps time instants to the zone in use at that time.
Typically, the Location represents the collection of time offsets
in use in a geographical area. For many Locations the time offset varies
depending on whether daylight savings time is in use at the time instant.
Location is used to provide a time zone in a printed Time value and for
calculations involving intervals that may cross daylight savings time
boundaries.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Location struct {
name string
zone []zone
tx []zoneTrans
extend string
cacheStart int64
cacheEnd int64
cacheZone *zone
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ParseError" data-name="ParseError">
               <h3>
                  ParseError
                  <span class="badge">struct</span>
                  <a href="#ParseError" class="anchor" title="Link to ParseError">#</a>
               </h3>
               
               <p>ParseError describes a problem parsing a time string.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ParseError struct {
Layout string
Value string
LayoutElem string
ValueElem string
Message string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Ticker" data-name="Ticker">
               <h3>
                  Ticker
                  <span class="badge">struct</span>
                  <a href="#Ticker" class="anchor" title="Link to Ticker">#</a>
               </h3>
               
               <p>A Ticker holds a channel that delivers “ticks” of a clock
at intervals.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Ticker struct {
C <-chan Time
initTicker bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Time" data-name="Time">
               <h3>
                  Time
                  <span class="badge">struct</span>
                  <a href="#Time" class="anchor" title="Link to Time">#</a>
               </h3>
               
               <p>A Time represents an instant in time with nanosecond precision.
Programs using times should typically store and pass them as values,
not pointers. That is, time variables and struct fields should be of
type [time.Time], not *time.Time.
A Time value can be used by multiple goroutines simultaneously except
that the methods [Time.GobDecode], [Time.UnmarshalBinary], [Time.UnmarshalJSON] and
[Time.UnmarshalText] are not concurrency-safe.
Time instants can be compared using the [Time.Before], [Time.After], and [Time.Equal] methods.
The [Time.Sub] method subtracts two instants, producing a [Duration].
The [Time.Add] method adds a Time and a Duration, producing a Time.
The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
As this time is unlikely to come up in practice, the [Time.IsZero] method gives
a simple way of detecting a time that has not been initialized explicitly.
Each time has an associated [Location]. The methods [Time.Local], [Time.UTC], and Time.In return a
Time with a specific Location. Changing the Location of a Time value with
these methods does not change the actual instant it represents, only the time
zone in which to interpret it.
Representations of a Time value saved by the [Time.GobEncode], [Time.MarshalBinary], [Time.AppendBinary],
[Time.MarshalJSON], [Time.MarshalText] and [Time.AppendText] methods store the [Time.Location]'s offset,
but not the location name. They therefore lose information about Daylight Saving Time.
In addition to the required “wall clock” reading, a Time may contain an optional
reading of the current process's monotonic clock, to provide additional precision
for comparison or subtraction.
See the “Monotonic Clocks” section in the package documentation for details.
Note that the Go == operator compares not just the time instant but also the
Location and the monotonic clock reading. Therefore, Time values should not
be used as map or database keys without first guaranteeing that the
identical Location has been set for all values, which can be achieved
through use of the UTC or Local method, and that the monotonic clock reading
has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)
to t == u, since t.Equal uses the most accurate comparison available and
correctly handles the case when only one of its arguments has a monotonic
clock reading.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Time struct {
wall uint64
ext int64
loc *Location
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Timer" data-name="Timer">
               <h3>
                  Timer
                  <span class="badge">struct</span>
                  <a href="#Timer" class="anchor" title="Link to Timer">#</a>
               </h3>
               
               <p>The Timer type represents a single event.
When the Timer expires, the current time will be sent on C,
unless the Timer was created by [AfterFunc].
A Timer must be created with [NewTimer] or AfterFunc.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Timer struct {
C <-chan Time
initTimer bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="abbr" data-name="abbr">
               <h3>
                  abbr
                  <span class="badge">struct</span>
                  <a href="#abbr" class="anchor" title="Link to abbr">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type abbr struct {
std string
dst string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dataIO" data-name="dataIO">
               <h3>
                  dataIO
                  <span class="badge">struct</span>
                  <a href="#dataIO" class="anchor" title="Link to dataIO">#</a>
               </h3>
               
               <p>Simple I/O interface to binary blob of data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type dataIO struct {
p []byte
error bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="rule" data-name="rule">
               <h3>
                  rule
                  <span class="badge">struct</span>
                  <a href="#rule" class="anchor" title="Link to rule">#</a>
               </h3>
               
               <p>rule is a rule read from a tzset string.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type rule struct {
kind ruleKind
day int
week int
mon int
time int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="zone" data-name="zone">
               <h3>
                  zone
                  <span class="badge">struct</span>
                  <a href="#zone" class="anchor" title="Link to zone">#</a>
               </h3>
               
               <p>A zone represents a single time zone such as CET.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type zone struct {
name string
offset int
isDST bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="zoneTrans" data-name="zoneTrans">
               <h3>
                  zoneTrans
                  <span class="badge">struct</span>
                  <a href="#zoneTrans" class="anchor" title="Link to zoneTrans">#</a>
               </h3>
               
               <p>A zoneTrans represents a single time zone transition.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type zoneTrans struct {
when int64
index uint8
isstd bool
isutc bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Abs" data-name="Abs">
               <h3>
                  Abs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Abs" class="anchor" title="Link to Abs">#</a>
               </h3>
               
               <p>Abs returns the absolute value of d.
As a special case, Duration([math.MinInt64]) is converted to Duration([math.MaxInt64]),
reducing its magnitude by 1 nanosecond.</p>
               
               <pre><code class="language-go">func (d Duration) Abs() Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add returns the time t+d.</p>
               
               <pre><code class="language-go">func (t Time) Add(d Duration) Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddDate" data-name="AddDate">
               <h3>
                  AddDate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddDate" class="anchor" title="Link to AddDate">#</a>
               </h3>
               
               <p>AddDate returns the time corresponding to adding the
given number of years, months, and days to t.
For example, AddDate(-1, 2, 3) applied to January 1, 2011
returns March 4, 2010.
Note that dates are fundamentally coupled to timezones, and calendrical
periods like days don't have fixed durations. AddDate uses the Location of
the Time value to determine these durations. That means that the same
AddDate arguments can produce a different shift in absolute time depending on
the base Time value and its Location. For example, AddDate(0, 0, 1) applied
to 12:00 on March 27 always returns 12:00 on March 28. At some locations and
in some years this is a 24 hour shift. In others it's a 23 hour shift due to
daylight savings time transitions.
AddDate normalizes its result in the same way that Date does,
so, for example, adding one month to October 31 yields
December 1, the normalized form for November 31.</p>
               
               <pre><code class="language-go">func (t Time) AddDate(years int, months int, days int) Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="After" data-name="After">
               <h3>
                  After 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#After" class="anchor" title="Link to After">#</a>
               </h3>
               
               <p>After reports whether the time instant t is after u.</p>
               
               <pre><code class="language-go">func (t Time) After(u Time) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="After" data-name="After">
               <h3>
                  After 
                  <span class="badge">function</span>
                  
                  <a href="#After" class="anchor" title="Link to After">#</a>
               </h3>
               
               <p>After waits for the duration to elapse and then sends the current time
on the returned channel.
It is equivalent to [NewTimer](d).C.
Before Go 1.23, this documentation warned that the underlying
[Timer] would not be recovered by the garbage collector until the
timer fired, and that if efficiency was a concern, code should use
NewTimer instead and call [Timer.Stop] if the timer is no longer needed.
As of Go 1.23, the garbage collector can recover unreferenced,
unstopped timers. There is no reason to prefer NewTimer when After will do.</p>
               
               <pre><code class="language-go">func After(d Duration) (<-chan Time)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AfterFunc" data-name="AfterFunc">
               <h3>
                  AfterFunc 
                  <span class="badge">function</span>
                  
                  <a href="#AfterFunc" class="anchor" title="Link to AfterFunc">#</a>
               </h3>
               
               <p>AfterFunc waits for the duration to elapse and then calls f
in its own goroutine. It returns a [Timer] that can
be used to cancel the call using its Stop method.
The returned Timer's C field is not used and will be nil.</p>
               
               <pre><code class="language-go">func AfterFunc(d Duration, f func()) *Timer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendBinary" data-name="AppendBinary">
               <h3>
                  AppendBinary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendBinary" class="anchor" title="Link to AppendBinary">#</a>
               </h3>
               
               <p>AppendBinary implements the [encoding.BinaryAppender] interface.</p>
               
               <pre><code class="language-go">func (t Time) AppendBinary(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendFormat" data-name="AppendFormat">
               <h3>
                  AppendFormat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendFormat" class="anchor" title="Link to AppendFormat">#</a>
               </h3>
               
               <p>AppendFormat is like [Time.Format] but appends the textual
representation to b and returns the extended buffer.</p>
               
               <pre><code class="language-go">func (t Time) AppendFormat(b []byte, layout string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendText" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendText" class="anchor" title="Link to AppendText">#</a>
               </h3>
               
               <p>AppendText implements the [encoding.TextAppender] interface.
The time is formatted in RFC 3339 format with sub-second precision.
If the timestamp cannot be represented as valid RFC 3339
(e.g., the year is out of range), then an error is returned.</p>
               
               <pre><code class="language-go">func (t Time) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Before" data-name="Before">
               <h3>
                  Before 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Before" class="anchor" title="Link to Before">#</a>
               </h3>
               
               <p>Before reports whether the time instant t is before u.</p>
               
               <pre><code class="language-go">func (t Time) Before(u Time) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clock" data-name="Clock">
               <h3>
                  Clock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Clock" class="anchor" title="Link to Clock">#</a>
               </h3>
               
               <p>Clock returns the hour, minute, and second within the day specified by t.</p>
               
               <pre><code class="language-go">func (t Time) Clock() (hour int, min int, sec int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Compare" data-name="Compare">
               <h3>
                  Compare 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Compare" class="anchor" title="Link to Compare">#</a>
               </h3>
               
               <p>Compare compares the time instant t with u. If t is before u, it returns -1;
if t is after u, it returns +1; if they're the same, it returns 0.</p>
               
               <pre><code class="language-go">func (t Time) Compare(u Time) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Date" data-name="Date">
               <h3>
                  Date 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Date" class="anchor" title="Link to Date">#</a>
               </h3>
               
               <p>Date returns the year, month, and day in which t occurs.</p>
               
               <pre><code class="language-go">func (t Time) Date() (year int, month Month, day int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Date" data-name="Date">
               <h3>
                  Date 
                  <span class="badge">function</span>
                  
                  <a href="#Date" class="anchor" title="Link to Date">#</a>
               </h3>
               
               <p>Date returns the Time corresponding to
yyyy-mm-dd hh:mm:ss + nsec nanoseconds
in the appropriate zone for that time in the given location.
The month, day, hour, min, sec, and nsec values may be outside
their usual ranges and will be normalized during the conversion.
For example, October 32 converts to November 1.
A daylight savings time transition skips or repeats times.
For example, in the United States, March 13, 2011 2:15am never occurred,
while November 6, 2011 1:15am occurred twice. In such cases, the
choice of time zone, and therefore the time, is not well-defined.
Date returns a time that is correct in one of the two zones involved
in the transition, but it does not guarantee which.
Date panics if loc is nil.</p>
               
               <pre><code class="language-go">func Date(year int, month Month, day int, hour int, min int, sec int, nsec int, loc *Location) Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Day" data-name="Day">
               <h3>
                  Day 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Day" class="anchor" title="Link to Day">#</a>
               </h3>
               
               <p>Day returns the day of the month specified by t.</p>
               
               <pre><code class="language-go">func (t Time) Day() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Equal" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Equal" class="anchor" title="Link to Equal">#</a>
               </h3>
               
               <p>Equal reports whether t and u represent the same time instant.
Two times can be equal even if they are in different locations.
For example, 6:00 +0200 and 4:00 UTC are Equal.
See the documentation on the Time type for the pitfalls of using == with
Time values; most code should use Equal instead.</p>
               
               <pre><code class="language-go">func (t Time) Equal(u Time) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (f fileSizeError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>Error returns the string representation of a ParseError.</p>
               
               <pre><code class="language-go">func (e *ParseError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FixedZone" data-name="FixedZone">
               <h3>
                  FixedZone 
                  <span class="badge">function</span>
                  
                  <a href="#FixedZone" class="anchor" title="Link to FixedZone">#</a>
               </h3>
               
               <p>FixedZone returns a [Location] that always uses
the given zone name and offset (seconds east of UTC).</p>
               
               <pre><code class="language-go">func FixedZone(name string, offset int) *Location</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Format" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Format" class="anchor" title="Link to Format">#</a>
               </h3>
               
               <p>Format returns a textual representation of the time value formatted according
to the layout defined by the argument. See the documentation for the
constant called [Layout] to see how to represent the layout format.
The executable example for [Time.Format] demonstrates the working
of the layout string in detail and is a good reference.</p>
               
               <pre><code class="language-go">func (t Time) Format(layout string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoString" data-name="GoString">
               <h3>
                  GoString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoString" class="anchor" title="Link to GoString">#</a>
               </h3>
               
               <p>GoString implements [fmt.GoStringer] and formats t to be printed in Go source
code.</p>
               
               <pre><code class="language-go">func (t Time) GoString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GobDecode" data-name="GobDecode">
               <h3>
                  GobDecode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GobDecode" class="anchor" title="Link to GobDecode">#</a>
               </h3>
               
               <p>GobDecode implements the gob.GobDecoder interface.</p>
               
               <pre><code class="language-go">func (t *Time) GobDecode(data []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GobEncode" data-name="GobEncode">
               <h3>
                  GobEncode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GobEncode" class="anchor" title="Link to GobEncode">#</a>
               </h3>
               
               <p>GobEncode implements the gob.GobEncoder interface.</p>
               
               <pre><code class="language-go">func (t Time) GobEncode() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Hour" data-name="Hour">
               <h3>
                  Hour 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Hour" class="anchor" title="Link to Hour">#</a>
               </h3>
               
               <p>Hour returns the hour within the day specified by t, in the range [0, 23].</p>
               
               <pre><code class="language-go">func (t Time) Hour() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Hours" data-name="Hours">
               <h3>
                  Hours 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Hours" class="anchor" title="Link to Hours">#</a>
               </h3>
               
               <p>Hours returns the duration as a floating point number of hours.</p>
               
               <pre><code class="language-go">func (d Duration) Hours() float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ISOWeek" data-name="ISOWeek">
               <h3>
                  ISOWeek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ISOWeek" class="anchor" title="Link to ISOWeek">#</a>
               </h3>
               
               <p>ISOWeek returns the ISO 8601 year and week number in which t occurs.
Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to
week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1
of year n+1.</p>
               
               <pre><code class="language-go">func (t Time) ISOWeek() (year int, week int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="In" data-name="In">
               <h3>
                  In 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#In" class="anchor" title="Link to In">#</a>
               </h3>
               
               <p>In returns a copy of t representing the same time instant, but
with the copy's location information set to loc for display
purposes.
In panics if loc is nil.</p>
               
               <pre><code class="language-go">func (t Time) In(loc *Location) Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDST" data-name="IsDST">
               <h3>
                  IsDST 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDST" class="anchor" title="Link to IsDST">#</a>
               </h3>
               
               <p>IsDST reports whether the time in the configured location is in Daylight Savings Time.</p>
               
               <pre><code class="language-go">func (t Time) IsDST() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsZero" data-name="IsZero">
               <h3>
                  IsZero 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsZero" class="anchor" title="Link to IsZero">#</a>
               </h3>
               
               <p>IsZero reports whether t represents the zero time instant,
January 1, year 1, 00:00:00 UTC.</p>
               
               <pre><code class="language-go">func (t Time) IsZero() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadLocation" data-name="LoadLocation">
               <h3>
                  LoadLocation 
                  <span class="badge">function</span>
                  
                  <a href="#LoadLocation" class="anchor" title="Link to LoadLocation">#</a>
               </h3>
               
               <p>LoadLocation returns the Location with the given name.
If the name is "" or "UTC", LoadLocation returns UTC.
If the name is "Local", LoadLocation returns Local.
Otherwise, the name is taken to be a location name corresponding to a file
in the IANA Time Zone database, such as "America/New_York".
LoadLocation looks for the IANA Time Zone database in the following
locations in order:
- the directory or uncompressed zip file named by the ZONEINFO environment variable
- on a Unix system, the system standard installation location
- $GOROOT/lib/time/zoneinfo.zip
- the time/tzdata package, if it was imported</p>
               
               <pre><code class="language-go">func LoadLocation(name string) (*Location, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadLocationFromTZData" data-name="LoadLocationFromTZData">
               <h3>
                  LoadLocationFromTZData 
                  <span class="badge">function</span>
                  
                  <a href="#LoadLocationFromTZData" class="anchor" title="Link to LoadLocationFromTZData">#</a>
               </h3>
               
               <p>LoadLocationFromTZData returns a Location with the given name
initialized from the IANA Time Zone database-formatted data.
The data should be in the format of a standard IANA time zone file
(for example, the content of /etc/localtime on Unix systems).</p>
               
               <pre><code class="language-go">func LoadLocationFromTZData(name string, data []byte) (*Location, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Local" data-name="Local">
               <h3>
                  Local 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Local" class="anchor" title="Link to Local">#</a>
               </h3>
               
               <p>Local returns t with the location set to local time.</p>
               
               <pre><code class="language-go">func (t Time) Local() Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Location" data-name="Location">
               <h3>
                  Location 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Location" class="anchor" title="Link to Location">#</a>
               </h3>
               
               <p>Location returns the time zone information associated with t.</p>
               
               <pre><code class="language-go">func (t Time) Location() *Location</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalBinary" data-name="MarshalBinary">
               <h3>
                  MarshalBinary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalBinary" class="anchor" title="Link to MarshalBinary">#</a>
               </h3>
               
               <p>MarshalBinary implements the [encoding.BinaryMarshaler] interface.</p>
               
               <pre><code class="language-go">func (t Time) MarshalBinary() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalJSON" data-name="MarshalJSON">
               <h3>
                  MarshalJSON 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalJSON" class="anchor" title="Link to MarshalJSON">#</a>
               </h3>
               
               <p>MarshalJSON implements the [encoding/json.Marshaler] interface.
The time is a quoted string in the RFC 3339 format with sub-second precision.
If the timestamp cannot be represented as valid RFC 3339
(e.g., the year is out of range), then an error is reported.</p>
               
               <pre><code class="language-go">func (t Time) MarshalJSON() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalText" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalText" class="anchor" title="Link to MarshalText">#</a>
               </h3>
               
               <p>MarshalText implements the [encoding.TextMarshaler] interface. The output
matches that of calling the [Time.AppendText] method.
See [Time.AppendText] for more information.</p>
               
               <pre><code class="language-go">func (t Time) MarshalText() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Microseconds" data-name="Microseconds">
               <h3>
                  Microseconds 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Microseconds" class="anchor" title="Link to Microseconds">#</a>
               </h3>
               
               <p>Microseconds returns the duration as an integer microsecond count.</p>
               
               <pre><code class="language-go">func (d Duration) Microseconds() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Milliseconds" data-name="Milliseconds">
               <h3>
                  Milliseconds 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Milliseconds" class="anchor" title="Link to Milliseconds">#</a>
               </h3>
               
               <p>Milliseconds returns the duration as an integer millisecond count.</p>
               
               <pre><code class="language-go">func (d Duration) Milliseconds() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Minute" data-name="Minute">
               <h3>
                  Minute 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Minute" class="anchor" title="Link to Minute">#</a>
               </h3>
               
               <p>Minute returns the minute offset within the hour specified by t, in the range [0, 59].</p>
               
               <pre><code class="language-go">func (t Time) Minute() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Minutes" data-name="Minutes">
               <h3>
                  Minutes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Minutes" class="anchor" title="Link to Minutes">#</a>
               </h3>
               
               <p>Minutes returns the duration as a floating point number of minutes.</p>
               
               <pre><code class="language-go">func (d Duration) Minutes() float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Month" data-name="Month">
               <h3>
                  Month 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Month" class="anchor" title="Link to Month">#</a>
               </h3>
               
               <p>Month returns the month of the year specified by t.</p>
               
               <pre><code class="language-go">func (t Time) Month() Month</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Nanosecond" data-name="Nanosecond">
               <h3>
                  Nanosecond 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Nanosecond" class="anchor" title="Link to Nanosecond">#</a>
               </h3>
               
               <p>Nanosecond returns the nanosecond offset within the second specified by t,
in the range [0, 999999999].</p>
               
               <pre><code class="language-go">func (t Time) Nanosecond() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Nanoseconds" data-name="Nanoseconds">
               <h3>
                  Nanoseconds 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Nanoseconds" class="anchor" title="Link to Nanoseconds">#</a>
               </h3>
               
               <p>Nanoseconds returns the duration as an integer nanosecond count.</p>
               
               <pre><code class="language-go">func (d Duration) Nanoseconds() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewTicker" data-name="NewTicker">
               <h3>
                  NewTicker 
                  <span class="badge">function</span>
                  
                  <a href="#NewTicker" class="anchor" title="Link to NewTicker">#</a>
               </h3>
               
               <p>NewTicker returns a new [Ticker] containing a channel that will send
the current time on the channel after each tick. The period of the
ticks is specified by the duration argument. The ticker will adjust
the time interval or drop ticks to make up for slow receivers.
The duration d must be greater than zero; if not, NewTicker will
panic.
Before Go 1.23, the garbage collector did not recover
tickers that had not yet expired or been stopped, so code often
immediately deferred t.Stop after calling NewTicker, to make
the ticker recoverable when it was no longer needed.
As of Go 1.23, the garbage collector can recover unreferenced
tickers, even if they haven't been stopped.
The Stop method is no longer necessary to help the garbage collector.
(Code may of course still want to call Stop to stop the ticker for other reasons.)</p>
               
               <pre><code class="language-go">func NewTicker(d Duration) *Ticker</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewTimer" data-name="NewTimer">
               <h3>
                  NewTimer 
                  <span class="badge">function</span>
                  
                  <a href="#NewTimer" class="anchor" title="Link to NewTimer">#</a>
               </h3>
               
               <p>NewTimer creates a new Timer that will send
the current time on its channel after at least duration d.
Before Go 1.23, the garbage collector did not recover
timers that had not yet expired or been stopped, so code often
immediately deferred t.Stop after calling NewTimer, to make
the timer recoverable when it was no longer needed.
As of Go 1.23, the garbage collector can recover unreferenced
timers, even if they haven't expired or been stopped.
The Stop method is no longer necessary to help the garbage collector.
(Code may of course still want to call Stop to stop the timer for other reasons.)
Before Go 1.23, the channel associated with a Timer was
asynchronous (buffered, capacity 1), which meant that
stale time values could be received even after [Timer.Stop]
or [Timer.Reset] returned.
As of Go 1.23, the channel is synchronous (unbuffered, capacity 0),
eliminating the possibility of those stale values.
The GODEBUG setting asynctimerchan=1 restores both pre-Go 1.23
behaviors: when set, unexpired timers won't be garbage collected, and
channels will have buffered capacity. This setting may be removed
in Go 1.27 or later.</p>
               
               <pre><code class="language-go">func NewTimer(d Duration) *Timer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Now" data-name="Now">
               <h3>
                  Now 
                  <span class="badge">function</span>
                  
                  <a href="#Now" class="anchor" title="Link to Now">#</a>
               </h3>
               
               <p>Now returns the current local time.</p>
               
               <pre><code class="language-go">func Now() Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parse" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge">function</span>
                  
                  <a href="#Parse" class="anchor" title="Link to Parse">#</a>
               </h3>
               
               <p>Parse parses a formatted string and returns the time value it represents.
See the documentation for the constant called [Layout] to see how to
represent the format. The second argument must be parseable using
the format string (layout) provided as the first argument.
The example for [Time.Format] demonstrates the working of the layout string
in detail and is a good reference.
When parsing (only), the input may contain a fractional second
field immediately after the seconds field, even if the layout does not
signify its presence. In that case either a comma or a decimal point
followed by a maximal series of digits is parsed as a fractional second.
Fractional seconds are truncated to nanosecond precision.
Elements omitted from the layout are assumed to be zero or, when
zero is impossible, one, so parsing "3:04pm" returns the time
corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is
0, this time is before the zero Time).
Years must be in the range 0000..9999. The day of the week is checked
for syntax but it is otherwise ignored.
For layouts specifying the two-digit year 06, a value NN >= 69 will be treated
as 19NN and a value NN < 69 will be treated as 20NN.
The remainder of this comment describes the handling of time zones.
In the absence of a time zone indicator, Parse returns a time in UTC.
When parsing a time with a zone offset like -0700, if the offset corresponds
to a time zone used by the current location ([Local]), then Parse uses that
location and zone in the returned time. Otherwise it records the time as
being in a fabricated location with time fixed at the given zone offset.
When parsing a time with a zone abbreviation like MST, if the zone abbreviation
has a defined offset in the current location, then that offset is used.
The zone abbreviation "UTC" is recognized as UTC regardless of location.
If the zone abbreviation is unknown, Parse records the time as being
in a fabricated location with the given zone abbreviation and a zero offset.
This choice means that such a time can be parsed and reformatted with the
same layout losslessly, but the exact instant used in the representation will
differ by the actual zone offset. To avoid such problems, prefer time layouts
that use a numeric zone offset, or use [ParseInLocation].</p>
               
               <pre><code class="language-go">func Parse(layout string, value string) (Time, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseDuration" data-name="ParseDuration">
               <h3>
                  ParseDuration 
                  <span class="badge">function</span>
                  
                  <a href="#ParseDuration" class="anchor" title="Link to ParseDuration">#</a>
               </h3>
               
               <p>ParseDuration parses a duration string.
A duration string is a possibly signed sequence of
decimal numbers, each with optional fraction and a unit suffix,
such as "300ms", "-1.5h" or "2h45m".
Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".</p>
               
               <pre><code class="language-go">func ParseDuration(s string) (Duration, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseInLocation" data-name="ParseInLocation">
               <h3>
                  ParseInLocation 
                  <span class="badge">function</span>
                  
                  <a href="#ParseInLocation" class="anchor" title="Link to ParseInLocation">#</a>
               </h3>
               
               <p>ParseInLocation is like Parse but differs in two important ways.
First, in the absence of time zone information, Parse interprets a time as UTC;
ParseInLocation interprets the time as in the given location.
Second, when given a zone offset or abbreviation, Parse tries to match it
against the Local location; ParseInLocation uses the given location.</p>
               
               <pre><code class="language-go">func ParseInLocation(layout string, value string, loc *Location) (Time, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset stops a ticker and resets its period to the specified duration.
The next tick will arrive after the new period elapses. The duration d
must be greater than zero; if not, Reset will panic.</p>
               
               <pre><code class="language-go">func (t *Ticker) Reset(d Duration)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset changes the timer to expire after duration d.
It returns true if the timer had been active, false if the timer had
expired or been stopped.
For a func-based timer created with [AfterFunc](d, f), Reset either reschedules
when f will run, in which case Reset returns true, or schedules f
to run again, in which case it returns false.
When Reset returns false, Reset neither waits for the prior f to
complete before returning nor does it guarantee that the subsequent
goroutine running f does not run concurrently with the prior
one. If the caller needs to know whether the prior execution of
f is completed, it must coordinate with f explicitly.
For a chan-based timer created with NewTimer, as of Go 1.23,
any receive from t.C after Reset has returned is guaranteed not
to receive a time value corresponding to the previous timer settings;
if the program has not received from t.C already and the timer is
running, Reset is guaranteed to return true.
Before Go 1.23, the only safe way to use Reset was to call [Timer.Stop]
and explicitly drain the timer first.
See the [NewTimer] documentation for more details.</p>
               
               <pre><code class="language-go">func (t *Timer) Reset(d Duration) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Round" data-name="Round">
               <h3>
                  Round 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Round" class="anchor" title="Link to Round">#</a>
               </h3>
               
               <p>Round returns the result of rounding t to the nearest multiple of d (since the zero time).
The rounding behavior for halfway values is to round up.
If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.
Round operates on the time as an absolute duration since the
zero time; it does not operate on the presentation form of the
time. Thus, Round(Hour) may return a time with a non-zero
minute, depending on the time's Location.</p>
               
               <pre><code class="language-go">func (t Time) Round(d Duration) Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Round" data-name="Round">
               <h3>
                  Round 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Round" class="anchor" title="Link to Round">#</a>
               </h3>
               
               <p>Round returns the result of rounding d to the nearest multiple of m.
The rounding behavior for halfway values is to round away from zero.
If the result exceeds the maximum (or minimum)
value that can be stored in a [Duration],
Round returns the maximum (or minimum) duration.
If m <= 0, Round returns d unchanged.</p>
               
               <pre><code class="language-go">func (d Duration) Round(m Duration) Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Second" data-name="Second">
               <h3>
                  Second 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Second" class="anchor" title="Link to Second">#</a>
               </h3>
               
               <p>Second returns the second offset within the minute specified by t, in the range [0, 59].</p>
               
               <pre><code class="language-go">func (t Time) Second() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Seconds" data-name="Seconds">
               <h3>
                  Seconds 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Seconds" class="anchor" title="Link to Seconds">#</a>
               </h3>
               
               <p>Seconds returns the duration as a floating point number of seconds.</p>
               
               <pre><code class="language-go">func (d Duration) Seconds() float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Since" data-name="Since">
               <h3>
                  Since 
                  <span class="badge">function</span>
                  
                  <a href="#Since" class="anchor" title="Link to Since">#</a>
               </h3>
               
               <p>Since returns the time elapsed since t.
It is shorthand for time.Now().Sub(t).</p>
               
               <pre><code class="language-go">func Since(t Time) Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sleep" data-name="Sleep">
               <h3>
                  Sleep 
                  <span class="badge">function</span>
                  
                  <a href="#Sleep" class="anchor" title="Link to Sleep">#</a>
               </h3>
               
               <p>Sleep pauses the current goroutine for at least the duration d.
A negative or zero duration causes Sleep to return immediately.</p>
               
               <pre><code class="language-go">func Sleep(d Duration)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stop" data-name="Stop">
               <h3>
                  Stop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stop" class="anchor" title="Link to Stop">#</a>
               </h3>
               
               <p>Stop turns off a ticker. After Stop, no more ticks will be sent.
Stop does not close the channel, to prevent a concurrent goroutine
reading from the channel from seeing an erroneous "tick".</p>
               
               <pre><code class="language-go">func (t *Ticker) Stop()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stop" data-name="Stop">
               <h3>
                  Stop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stop" class="anchor" title="Link to Stop">#</a>
               </h3>
               
               <p>Stop prevents the [Timer] from firing.
It returns true if the call stops the timer, false if the timer has already
expired or been stopped.
For a func-based timer created with [AfterFunc](d, f),
if t.Stop returns false, then the timer has already expired
and the function f has been started in its own goroutine;
Stop does not wait for f to complete before returning.
If the caller needs to know whether f is completed,
it must coordinate with f explicitly.
For a chan-based timer created with NewTimer(d), as of Go 1.23,
any receive from t.C after Stop has returned is guaranteed to block
rather than receive a stale time value from before the Stop;
if the program has not received from t.C already and the timer is
running, Stop is guaranteed to return true.
Before Go 1.23, the only safe way to use Stop was insert an extra
<-t.C if Stop returned false to drain a potential stale value.
See the [NewTimer] documentation for more details.</p>
               
               <pre><code class="language-go">func (t *Timer) Stop() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the English name of the day ("Sunday", "Monday", ...).</p>
               
               <pre><code class="language-go">func (d Weekday) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns a string representing the duration in the form "72h3m0.5s".
Leading zero units are omitted. As a special case, durations less than one
second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure
that the leading digit is non-zero. The zero duration formats as 0s.</p>
               
               <pre><code class="language-go">func (d Duration) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the English name of the month ("January", "February", ...).</p>
               
               <pre><code class="language-go">func (m Month) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the time formatted using the format string
"2006-01-02 15:04:05.999999999 -0700 MST"
If the time has a monotonic clock reading, the returned string
includes a final field "m=±<value>", where value is the monotonic
clock reading formatted as a decimal number of seconds.
The returned string is meant for debugging; for a stable serialized
representation, use t.MarshalText, t.MarshalBinary, or t.Format
with an explicit format string.</p>
               
               <pre><code class="language-go">func (t Time) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns a descriptive name for the time zone information,
corresponding to the name argument to [LoadLocation] or [FixedZone].</p>
               
               <pre><code class="language-go">func (l *Location) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sub" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sub" class="anchor" title="Link to Sub">#</a>
               </h3>
               
               <p>Sub returns the duration t-u. If the result exceeds the maximum (or minimum)
value that can be stored in a [Duration], the maximum (or minimum) duration
will be returned.
To compute t-d for a duration d, use t.Add(-d).</p>
               
               <pre><code class="language-go">func (t Time) Sub(u Time) Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Tick" data-name="Tick">
               <h3>
                  Tick 
                  <span class="badge">function</span>
                  
                  <a href="#Tick" class="anchor" title="Link to Tick">#</a>
               </h3>
               
               <p>Tick is a convenience wrapper for [NewTicker] providing access to the ticking
channel only. Unlike NewTicker, Tick will return nil if d <= 0.
Before Go 1.23, this documentation warned that the underlying
[Ticker] would never be recovered by the garbage collector, and that
if efficiency was a concern, code should use NewTicker instead and
call [Ticker.Stop] when the ticker is no longer needed.
As of Go 1.23, the garbage collector can recover unreferenced
tickers, even if they haven't been stopped.
The Stop method is no longer necessary to help the garbage collector.
There is no longer any reason to prefer NewTicker when Tick will do.</p>
               
               <pre><code class="language-go">func Tick(d Duration) (<-chan Time)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Truncate" data-name="Truncate">
               <h3>
                  Truncate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Truncate" class="anchor" title="Link to Truncate">#</a>
               </h3>
               
               <p>Truncate returns the result of rounding t down to a multiple of d (since the zero time).
If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.
Truncate operates on the time as an absolute duration since the
zero time; it does not operate on the presentation form of the
time. Thus, Truncate(Hour) may return a time with a non-zero
minute, depending on the time's Location.</p>
               
               <pre><code class="language-go">func (t Time) Truncate(d Duration) Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Truncate" data-name="Truncate">
               <h3>
                  Truncate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Truncate" class="anchor" title="Link to Truncate">#</a>
               </h3>
               
               <p>Truncate returns the result of rounding d toward zero to a multiple of m.
If m <= 0, Truncate returns d unchanged.</p>
               
               <pre><code class="language-go">func (d Duration) Truncate(m Duration) Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UTC" data-name="UTC">
               <h3>
                  UTC 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UTC" class="anchor" title="Link to UTC">#</a>
               </h3>
               
               <p>UTC returns t with the location set to UTC.</p>
               
               <pre><code class="language-go">func (t Time) UTC() Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unix" data-name="Unix">
               <h3>
                  Unix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unix" class="anchor" title="Link to Unix">#</a>
               </h3>
               
               <p>Unix returns t as a Unix time, the number of seconds elapsed
since January 1, 1970 UTC. The result does not depend on the
location associated with t.
Unix-like operating systems often record time as a 32-bit
count of seconds, but since the method here returns a 64-bit
value it is valid for billions of years into the past or future.</p>
               
               <pre><code class="language-go">func (t Time) Unix() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unix" data-name="Unix">
               <h3>
                  Unix 
                  <span class="badge">function</span>
                  
                  <a href="#Unix" class="anchor" title="Link to Unix">#</a>
               </h3>
               
               <p>Unix returns the local Time corresponding to the given Unix time,
sec seconds and nsec nanoseconds since January 1, 1970 UTC.
It is valid to pass nsec outside the range [0, 999999999].
Not all sec values have a corresponding time value. One such
value is 1<<63-1 (the largest int64 value).</p>
               
               <pre><code class="language-go">func Unix(sec int64, nsec int64) Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnixMicro" data-name="UnixMicro">
               <h3>
                  UnixMicro 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnixMicro" class="anchor" title="Link to UnixMicro">#</a>
               </h3>
               
               <p>UnixMicro returns t as a Unix time, the number of microseconds elapsed since
January 1, 1970 UTC. The result is undefined if the Unix time in
microseconds cannot be represented by an int64 (a date before year -290307 or
after year 294246). The result does not depend on the location associated
with t.</p>
               
               <pre><code class="language-go">func (t Time) UnixMicro() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnixMicro" data-name="UnixMicro">
               <h3>
                  UnixMicro 
                  <span class="badge">function</span>
                  
                  <a href="#UnixMicro" class="anchor" title="Link to UnixMicro">#</a>
               </h3>
               
               <p>UnixMicro returns the local Time corresponding to the given Unix time,
usec microseconds since January 1, 1970 UTC.</p>
               
               <pre><code class="language-go">func UnixMicro(usec int64) Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnixMilli" data-name="UnixMilli">
               <h3>
                  UnixMilli 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnixMilli" class="anchor" title="Link to UnixMilli">#</a>
               </h3>
               
               <p>UnixMilli returns t as a Unix time, the number of milliseconds elapsed since
January 1, 1970 UTC. The result is undefined if the Unix time in
milliseconds cannot be represented by an int64 (a date more than 292 million
years before or after 1970). The result does not depend on the
location associated with t.</p>
               
               <pre><code class="language-go">func (t Time) UnixMilli() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnixMilli" data-name="UnixMilli">
               <h3>
                  UnixMilli 
                  <span class="badge">function</span>
                  
                  <a href="#UnixMilli" class="anchor" title="Link to UnixMilli">#</a>
               </h3>
               
               <p>UnixMilli returns the local Time corresponding to the given Unix time,
msec milliseconds since January 1, 1970 UTC.</p>
               
               <pre><code class="language-go">func UnixMilli(msec int64) Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnixNano" data-name="UnixNano">
               <h3>
                  UnixNano 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnixNano" class="anchor" title="Link to UnixNano">#</a>
               </h3>
               
               <p>UnixNano returns t as a Unix time, the number of nanoseconds elapsed
since January 1, 1970 UTC. The result is undefined if the Unix time
in nanoseconds cannot be represented by an int64 (a date before the year
1678 or after 2262). Note that this means the result of calling UnixNano
on the zero Time is undefined. The result does not depend on the
location associated with t.</p>
               
               <pre><code class="language-go">func (t Time) UnixNano() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalBinary" data-name="UnmarshalBinary">
               <h3>
                  UnmarshalBinary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalBinary" class="anchor" title="Link to UnmarshalBinary">#</a>
               </h3>
               
               <p>UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface.</p>
               
               <pre><code class="language-go">func (t *Time) UnmarshalBinary(data []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalJSON" data-name="UnmarshalJSON">
               <h3>
                  UnmarshalJSON 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalJSON" class="anchor" title="Link to UnmarshalJSON">#</a>
               </h3>
               
               <p>UnmarshalJSON implements the [encoding/json.Unmarshaler] interface.
The time must be a quoted string in the RFC 3339 format.</p>
               
               <pre><code class="language-go">func (t *Time) UnmarshalJSON(data []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnmarshalText" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnmarshalText" class="anchor" title="Link to UnmarshalText">#</a>
               </h3>
               
               <p>UnmarshalText implements the [encoding.TextUnmarshaler] interface.
The time must be in the RFC 3339 format.</p>
               
               <pre><code class="language-go">func (t *Time) UnmarshalText(data []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Until" data-name="Until">
               <h3>
                  Until 
                  <span class="badge">function</span>
                  
                  <a href="#Until" class="anchor" title="Link to Until">#</a>
               </h3>
               
               <p>Until returns the duration until t.
It is shorthand for t.Sub(time.Now()).</p>
               
               <pre><code class="language-go">func Until(t Time) Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Weekday" data-name="Weekday">
               <h3>
                  Weekday 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Weekday" class="anchor" title="Link to Weekday">#</a>
               </h3>
               
               <p>Weekday returns the day of the week specified by t.</p>
               
               <pre><code class="language-go">func (t Time) Weekday() Weekday</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Year" data-name="Year">
               <h3>
                  Year 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Year" class="anchor" title="Link to Year">#</a>
               </h3>
               
               <p>Year returns the year in which t occurs.</p>
               
               <pre><code class="language-go">func (t Time) Year() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="YearDay" data-name="YearDay">
               <h3>
                  YearDay 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#YearDay" class="anchor" title="Link to YearDay">#</a>
               </h3>
               
               <p>YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years,
and [1,366] in leap years.</p>
               
               <pre><code class="language-go">func (t Time) YearDay() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Zone" data-name="Zone">
               <h3>
                  Zone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Zone" class="anchor" title="Link to Zone">#</a>
               </h3>
               
               <p>Zone computes the time zone in effect at time t, returning the abbreviated
name of the zone (such as "CET") and its offset in seconds east of UTC.</p>
               
               <pre><code class="language-go">func (t Time) Zone() (name string, offset int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ZoneBounds" data-name="ZoneBounds">
               <h3>
                  ZoneBounds 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ZoneBounds" class="anchor" title="Link to ZoneBounds">#</a>
               </h3>
               
               <p>ZoneBounds returns the bounds of the time zone in effect at time t.
The zone begins at start and the next zone begins at end.
If the zone begins at the beginning of time, start will be returned as a zero Time.
If the zone goes on forever, end will be returned as a zero Time.
The Location of the returned times will be the same as t.</p>
               
               <pre><code class="language-go">func (t Time) ZoneBounds() (start Time, end Time)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abbrev" data-name="abbrev">
               <h3>
                  abbrev 
                  <span class="badge">function</span>
                  
                  <a href="#abbrev" class="anchor" title="Link to abbrev">#</a>
               </h3>
               
               <p>abbrev returns the abbreviations to use for the given zone z.</p>
               
               <pre><code class="language-go">func abbrev(z *syscall.Timezoneinformation) (std string, dst string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="absSec" data-name="absSec">
               <h3>
                  absSec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#absSec" class="anchor" title="Link to absSec">#</a>
               </h3>
               
               <p>absSec returns the time t as an absolute seconds, adjusted by the zone offset.
It is called when computing a presentation property like Month or Hour.
We'd rather call it abs, but there are linknames to abs that make that problematic.
See timeAbs below.</p>
               
               <pre><code class="language-go">func (t Time) absSec() absSeconds</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addSec" data-name="addSec">
               <h3>
                  addSec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addSec" class="anchor" title="Link to addSec">#</a>
               </h3>
               
               <p>addSec adds d seconds to the time.</p>
               
               <pre><code class="language-go">func (t *Time) addSec(d int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="androidLoadTzinfoFromTzdata" data-name="androidLoadTzinfoFromTzdata">
               <h3>
                  androidLoadTzinfoFromTzdata 
                  <span class="badge">function</span>
                  
                  <a href="#androidLoadTzinfoFromTzdata" class="anchor" title="Link to androidLoadTzinfoFromTzdata">#</a>
               </h3>
               
               <pre><code class="language-go">func androidLoadTzinfoFromTzdata(file string, name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendFormat" data-name="appendFormat">
               <h3>
                  appendFormat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#appendFormat" class="anchor" title="Link to appendFormat">#</a>
               </h3>
               
               <pre><code class="language-go">func (t Time) appendFormat(b []byte, layout string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendFormatRFC3339" data-name="appendFormatRFC3339">
               <h3>
                  appendFormatRFC3339 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#appendFormatRFC3339" class="anchor" title="Link to appendFormatRFC3339">#</a>
               </h3>
               
               <pre><code class="language-go">func (t Time) appendFormatRFC3339(b []byte, nanos bool) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendInt" data-name="appendInt">
               <h3>
                  appendInt 
                  <span class="badge">function</span>
                  
                  <a href="#appendInt" class="anchor" title="Link to appendInt">#</a>
               </h3>
               
               <p>appendInt appends the decimal form of x to b and returns the result.
If the decimal form (excluding sign) is shorter than width, the result is padded with leading 0's.
Duplicates functionality in strconv, but avoids dependency.</p>
               
               <pre><code class="language-go">func appendInt(b []byte, x int, width int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendNano" data-name="appendNano">
               <h3>
                  appendNano 
                  <span class="badge">function</span>
                  
                  <a href="#appendNano" class="anchor" title="Link to appendNano">#</a>
               </h3>
               
               <p>appendNano appends a fractional second, as nanoseconds, to b
and returns the result. The nanosec must be within [0, 999999999].</p>
               
               <pre><code class="language-go">func appendNano(b []byte, nanosec int, std int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendStrictRFC3339" data-name="appendStrictRFC3339">
               <h3>
                  appendStrictRFC3339 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#appendStrictRFC3339" class="anchor" title="Link to appendStrictRFC3339">#</a>
               </h3>
               
               <pre><code class="language-go">func (t Time) appendStrictRFC3339(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendTo" data-name="appendTo">
               <h3>
                  appendTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#appendTo" class="anchor" title="Link to appendTo">#</a>
               </h3>
               
               <pre><code class="language-go">func (t Time) appendTo(b []byte, errPrefix string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atoi" data-name="atoi">
               <h3>
                  atoi 
                  <span class="badge">function</span>
                  
                  <a href="#atoi" class="anchor" title="Link to atoi">#</a>
               </h3>
               
               <p>Duplicates functionality in strconv, but avoids dependency.</p>
               
               <pre><code class="language-go">func atoi(s bytes) (x int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="big4" data-name="big4">
               <h3>
                  big4 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#big4" class="anchor" title="Link to big4">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *dataIO) big4() (n uint32, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="big8" data-name="big8">
               <h3>
                  big8 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#big8" class="anchor" title="Link to big8">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *dataIO) big8() (n uint64, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byte" data-name="byte">
               <h3>
                  byte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#byte" class="anchor" title="Link to byte">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *dataIO) byte() (n byte, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="byteString" data-name="byteString">
               <h3>
                  byteString 
                  <span class="badge">function</span>
                  
                  <a href="#byteString" class="anchor" title="Link to byteString">#</a>
               </h3>
               
               <p>Make a string by stopping at the first NUL</p>
               
               <pre><code class="language-go">func byteString(p []byte) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clock" data-name="clock">
               <h3>
                  clock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#clock" class="anchor" title="Link to clock">#</a>
               </h3>
               
               <p>clock returns the hour, minute, and second within the day specified by abs.</p>
               
               <pre><code class="language-go">func (abs absSeconds) clock() (hour int, min int, sec int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closefd" data-name="closefd">
               <h3>
                  closefd 
                  <span class="badge">function</span>
                  
                  <a href="#closefd" class="anchor" title="Link to closefd">#</a>
               </h3>
               
               <pre><code class="language-go">func closefd(fd uintptr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closefd" data-name="closefd">
               <h3>
                  closefd 
                  <span class="badge">function</span>
                  
                  <a href="#closefd" class="anchor" title="Link to closefd">#</a>
               </h3>
               
               <pre><code class="language-go">func closefd(fd uintptr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closefd" data-name="closefd">
               <h3>
                  closefd 
                  <span class="badge">function</span>
                  
                  <a href="#closefd" class="anchor" title="Link to closefd">#</a>
               </h3>
               
               <pre><code class="language-go">func closefd(fd uintptr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commaOrPeriod" data-name="commaOrPeriod">
               <h3>
                  commaOrPeriod 
                  <span class="badge">function</span>
                  
                  <a href="#commaOrPeriod" class="anchor" title="Link to commaOrPeriod">#</a>
               </h3>
               
               <pre><code class="language-go">func commaOrPeriod(b byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="containsDotDot" data-name="containsDotDot">
               <h3>
                  containsDotDot 
                  <span class="badge">function</span>
                  
                  <a href="#containsDotDot" class="anchor" title="Link to containsDotDot">#</a>
               </h3>
               
               <p>containsDotDot reports whether s contains "..".</p>
               
               <pre><code class="language-go">func containsDotDot(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cutspace" data-name="cutspace">
               <h3>
                  cutspace 
                  <span class="badge">function</span>
                  
                  <a href="#cutspace" class="anchor" title="Link to cutspace">#</a>
               </h3>
               
               <pre><code class="language-go">func cutspace(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="date" data-name="date">
               <h3>
                  date 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#date" class="anchor" title="Link to date">#</a>
               </h3>
               
               <p>date converts days into standard year, month, day.</p>
               
               <pre><code class="language-go">func (days absDays) date() (year int, month Month, day int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dateToAbsDays" data-name="dateToAbsDays">
               <h3>
                  dateToAbsDays 
                  <span class="badge">function</span>
                  
                  <a href="#dateToAbsDays" class="anchor" title="Link to dateToAbsDays">#</a>
               </h3>
               
               <p>dateToAbsDays takes a standard year/month/day and returns the
number of days from the absolute epoch to that day.
The days argument can be out of range and in particular can be negative.</p>
               
               <pre><code class="language-go">func dateToAbsDays(year int64, month Month, day int) absDays</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="days" data-name="days">
               <h3>
                  days 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#days" class="anchor" title="Link to days">#</a>
               </h3>
               
               <p>days converts absolute seconds to absolute days.</p>
               
               <pre><code class="language-go">func (abs absSeconds) days() absDays</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="daysBefore" data-name="daysBefore">
               <h3>
                  daysBefore 
                  <span class="badge">function</span>
                  
                  <a href="#daysBefore" class="anchor" title="Link to daysBefore">#</a>
               </h3>
               
               <p>daysBefore returns the number of days in a non-leap year before month m.
daysBefore(December+1) returns 365.</p>
               
               <pre><code class="language-go">func daysBefore(m Month) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="daysIn" data-name="daysIn">
               <h3>
                  daysIn 
                  <span class="badge">function</span>
                  
                  <a href="#daysIn" class="anchor" title="Link to daysIn">#</a>
               </h3>
               
               <pre><code class="language-go">func daysIn(m Month, year int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="digitsLen" data-name="digitsLen">
               <h3>
                  digitsLen 
                  <span class="badge">function</span>
                  
                  <a href="#digitsLen" class="anchor" title="Link to digitsLen">#</a>
               </h3>
               
               <pre><code class="language-go">func digitsLen(std int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="div" data-name="div">
               <h3>
                  div 
                  <span class="badge">function</span>
                  
                  <a href="#div" class="anchor" title="Link to div">#</a>
               </h3>
               
               <p>div divides t by d and returns the quotient parity and remainder.
We don't use the quotient parity anymore (round half up instead of round to even)
but it's still here in case we change our minds.</p>
               
               <pre><code class="language-go">func div(t Time, d Duration) (qmod2 int, r Duration)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="extractCAPS" data-name="extractCAPS">
               <h3>
                  extractCAPS 
                  <span class="badge">function</span>
                  
                  <a href="#extractCAPS" class="anchor" title="Link to extractCAPS">#</a>
               </h3>
               
               <p>extractCAPS extracts capital letters from description desc.</p>
               
               <pre><code class="language-go">func extractCAPS(desc string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fields" data-name="fields">
               <h3>
                  fields 
                  <span class="badge">function</span>
                  
                  <a href="#fields" class="anchor" title="Link to fields">#</a>
               </h3>
               
               <p>Copied from strings to avoid a dependency.</p>
               
               <pre><code class="language-go">func fields(s string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findZone" data-name="findZone">
               <h3>
                  findZone 
                  <span class="badge">function</span>
                  
                  <a href="#findZone" class="anchor" title="Link to findZone">#</a>
               </h3>
               
               <pre><code class="language-go">func findZone(zones []zone, name string, offset int, isDST bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="firstZoneUsed" data-name="firstZoneUsed">
               <h3>
                  firstZoneUsed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#firstZoneUsed" class="anchor" title="Link to firstZoneUsed">#</a>
               </h3>
               
               <p>firstZoneUsed reports whether the first zone is used by some
transition.</p>
               
               <pre><code class="language-go">func (l *Location) firstZoneUsed() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixedZone" data-name="fixedZone">
               <h3>
                  fixedZone 
                  <span class="badge">function</span>
                  
                  <a href="#fixedZone" class="anchor" title="Link to fixedZone">#</a>
               </h3>
               
               <pre><code class="language-go">func fixedZone(name string, offset int) *Location</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtFrac" data-name="fmtFrac">
               <h3>
                  fmtFrac 
                  <span class="badge">function</span>
                  
                  <a href="#fmtFrac" class="anchor" title="Link to fmtFrac">#</a>
               </h3>
               
               <p>fmtFrac formats the fraction of v/10**prec (e.g., ".12345") into the
tail of buf, omitting trailing zeros. It omits the decimal
point too when the fraction is 0. It returns the index where the
output bytes begin and the value v/10**prec.</p>
               
               <pre><code class="language-go">func fmtFrac(buf []byte, v uint64, prec int) (nw int, nv uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fmtInt" data-name="fmtInt">
               <h3>
                  fmtInt 
                  <span class="badge">function</span>
                  
                  <a href="#fmtInt" class="anchor" title="Link to fmtInt">#</a>
               </h3>
               
               <p>fmtInt formats v into the tail of buf.
It returns the index where the output begins.</p>
               
               <pre><code class="language-go">func fmtInt(buf []byte, v uint64) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="format" data-name="format">
               <h3>
                  format 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#format" class="anchor" title="Link to format">#</a>
               </h3>
               
               <p>format formats the representation of d into the end of buf and
returns the offset of the first character.</p>
               
               <pre><code class="language-go">func (d Duration) format(buf *[32]byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="get" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#get" class="anchor" title="Link to get">#</a>
               </h3>
               
               <pre><code class="language-go">func (l *Location) get() *Location</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="get2" data-name="get2">
               <h3>
                  get2 
                  <span class="badge">function</span>
                  
                  <a href="#get2" class="anchor" title="Link to get2">#</a>
               </h3>
               
               <p>get2 returns the little-endian 16-bit value in b.</p>
               
               <pre><code class="language-go">func get2(b []byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="get4" data-name="get4">
               <h3>
                  get4 
                  <span class="badge">function</span>
                  
                  <a href="#get4" class="anchor" title="Link to get4">#</a>
               </h3>
               
               <p>get4 returns the little-endian 32-bit value in b.</p>
               
               <pre><code class="language-go">func get4(b []byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getnum" data-name="getnum">
               <h3>
                  getnum 
                  <span class="badge">function</span>
                  
                  <a href="#getnum" class="anchor" title="Link to getnum">#</a>
               </h3>
               
               <p>getnum parses s[0:1] or s[0:2] (fixed forces s[0:2])
as a decimal integer and returns the integer and the
remainder of the string.</p>
               
               <pre><code class="language-go">func getnum(s string, fixed bool) (int, string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getnum3" data-name="getnum3">
               <h3>
                  getnum3 
                  <span class="badge">function</span>
                  
                  <a href="#getnum3" class="anchor" title="Link to getnum3">#</a>
               </h3>
               
               <p>getnum3 parses s[0:1], s[0:2], or s[0:3] (fixed forces s[0:3])
as a decimal integer and returns the integer and the remainder
of the string.</p>
               
               <pre><code class="language-go">func getnum3(s string, fixed bool) (int, string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goFunc" data-name="goFunc">
               <h3>
                  goFunc 
                  <span class="badge">function</span>
                  
                  <a href="#goFunc" class="anchor" title="Link to goFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func goFunc(arg any, seq uintptr, delta int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gorootZoneSource" data-name="gorootZoneSource">
               <h3>
                  gorootZoneSource 
                  <span class="badge">function</span>
                  
                  <a href="#gorootZoneSource" class="anchor" title="Link to gorootZoneSource">#</a>
               </h3>
               
               <pre><code class="language-go">func gorootZoneSource(goroot string) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gorootZoneSource" data-name="gorootZoneSource">
               <h3>
                  gorootZoneSource 
                  <span class="badge">function</span>
                  
                  <a href="#gorootZoneSource" class="anchor" title="Link to gorootZoneSource">#</a>
               </h3>
               
               <pre><code class="language-go">func gorootZoneSource(goroot string) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gorootZoneSource" data-name="gorootZoneSource">
               <h3>
                  gorootZoneSource 
                  <span class="badge">function</span>
                  
                  <a href="#gorootZoneSource" class="anchor" title="Link to gorootZoneSource">#</a>
               </h3>
               
               <pre><code class="language-go">func gorootZoneSource(goroot string) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initLocal" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
                  <a href="#initLocal" class="anchor" title="Link to initLocal">#</a>
               </h3>
               
               <pre><code class="language-go">func initLocal()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initLocal" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
                  <a href="#initLocal" class="anchor" title="Link to initLocal">#</a>
               </h3>
               
               <pre><code class="language-go">func initLocal()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initLocal" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
                  <a href="#initLocal" class="anchor" title="Link to initLocal">#</a>
               </h3>
               
               <pre><code class="language-go">func initLocal()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initLocal" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
                  <a href="#initLocal" class="anchor" title="Link to initLocal">#</a>
               </h3>
               
               <pre><code class="language-go">func initLocal()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initLocal" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
                  <a href="#initLocal" class="anchor" title="Link to initLocal">#</a>
               </h3>
               
               <pre><code class="language-go">func initLocal()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initLocal" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
                  <a href="#initLocal" class="anchor" title="Link to initLocal">#</a>
               </h3>
               
               <pre><code class="language-go">func initLocal()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initLocal" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
                  <a href="#initLocal" class="anchor" title="Link to initLocal">#</a>
               </h3>
               
               <pre><code class="language-go">func initLocal()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initLocalFromTZI" data-name="initLocalFromTZI">
               <h3>
                  initLocalFromTZI 
                  <span class="badge">function</span>
                  
                  <a href="#initLocalFromTZI" class="anchor" title="Link to initLocalFromTZI">#</a>
               </h3>
               
               <pre><code class="language-go">func initLocalFromTZI(i *syscall.Timezoneinformation)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="interrupt" data-name="interrupt">
               <h3>
                  interrupt 
                  <span class="badge">function</span>
                  
                  <a href="#interrupt" class="anchor" title="Link to interrupt">#</a>
               </h3>
               
               <p>for testing: whatever interrupts a sleep</p>
               
               <pre><code class="language-go">func interrupt()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="interrupt" data-name="interrupt">
               <h3>
                  interrupt 
                  <span class="badge">function</span>
                  
                  <a href="#interrupt" class="anchor" title="Link to interrupt">#</a>
               </h3>
               
               <p>for testing: whatever interrupts a sleep</p>
               
               <pre><code class="language-go">func interrupt()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="interrupt" data-name="interrupt">
               <h3>
                  interrupt 
                  <span class="badge">function</span>
                  
                  <a href="#interrupt" class="anchor" title="Link to interrupt">#</a>
               </h3>
               
               <p>for testing: whatever interrupts a sleep</p>
               
               <pre><code class="language-go">func interrupt()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDigit" data-name="isDigit">
               <h3>
                  isDigit 
                  <span class="badge">function</span>
                  
                  <a href="#isDigit" class="anchor" title="Link to isDigit">#</a>
               </h3>
               
               <p>isDigit reports whether s[i] is in range and is a decimal digit.</p>
               
               <pre><code class="language-go">func isDigit(s bytes, i int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isLeap" data-name="isLeap">
               <h3>
                  isLeap 
                  <span class="badge">function</span>
                  
                  <a href="#isLeap" class="anchor" title="Link to isLeap">#</a>
               </h3>
               
               <pre><code class="language-go">func isLeap(year int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSpace" data-name="isSpace">
               <h3>
                  isSpace 
                  <span class="badge">function</span>
                  
                  <a href="#isSpace" class="anchor" title="Link to isSpace">#</a>
               </h3>
               
               <pre><code class="language-go">func isSpace(r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="janFeb" data-name="janFeb">
               <h3>
                  janFeb 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#janFeb" class="anchor" title="Link to janFeb">#</a>
               </h3>
               
               <p>janFeb returns 1 if the March 1-based ayday is in January or February, 0 otherwise.</p>
               
               <pre><code class="language-go">func (ayday absYday) janFeb() absJanFeb</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="leadingFraction" data-name="leadingFraction">
               <h3>
                  leadingFraction 
                  <span class="badge">function</span>
                  
                  <a href="#leadingFraction" class="anchor" title="Link to leadingFraction">#</a>
               </h3>
               
               <p>leadingFraction consumes the leading [0-9]* from s.
It is used only for fractions, so does not return an error on overflow,
it just stops accumulating precision.</p>
               
               <pre><code class="language-go">func leadingFraction(s string) (x uint64, scale float64, rem string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="leadingInt" data-name="leadingInt">
               <h3>
                  leadingInt 
                  <span class="badge">function</span>
                  
                  <a href="#leadingInt" class="anchor" title="Link to leadingInt">#</a>
               </h3>
               
               <p>leadingInt consumes the leading [0-9]* from s.</p>
               
               <pre><code class="language-go">func leadingInt(s bytes) (x uint64, rem bytes, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="leap" data-name="leap">
               <h3>
                  leap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#leap" class="anchor" title="Link to leap">#</a>
               </h3>
               
               <p>leap returns 1 if (century, cyear) is a leap year, 0 otherwise.</p>
               
               <pre><code class="language-go">func (century absCentury) leap(cyear absCyear) absLeap</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="legacyAbsClock" data-name="legacyAbsClock">
               <h3>
                  legacyAbsClock 
                  <span class="badge">function</span>
                  
                  <a href="#legacyAbsClock" class="anchor" title="Link to legacyAbsClock">#</a>
               </h3>
               
               <p>go:linkname legacyAbsClock time.absClock</p>
               
               <pre><code class="language-go">func legacyAbsClock(abs uint64) (hour int, min int, sec int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="legacyAbsDate" data-name="legacyAbsDate">
               <h3>
                  legacyAbsDate 
                  <span class="badge">function</span>
                  
                  <a href="#legacyAbsDate" class="anchor" title="Link to legacyAbsDate">#</a>
               </h3>
               
               <p>go:linkname legacyAbsDate time.absDate</p>
               
               <pre><code class="language-go">func legacyAbsDate(abs uint64, full bool) (year int, month Month, day int, yday int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="legacyTimeTimeAbs" data-name="legacyTimeTimeAbs">
               <h3>
                  legacyTimeTimeAbs 
                  <span class="badge">function</span>
                  
                  <a href="#legacyTimeTimeAbs" class="anchor" title="Link to legacyTimeTimeAbs">#</a>
               </h3>
               
               <p>go:linkname legacyTimeTimeAbs time.Time.abs</p>
               
               <pre><code class="language-go">func legacyTimeTimeAbs(t Time) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lessThanHalf" data-name="lessThanHalf">
               <h3>
                  lessThanHalf 
                  <span class="badge">function</span>
                  
                  <a href="#lessThanHalf" class="anchor" title="Link to lessThanHalf">#</a>
               </h3>
               
               <p>lessThanHalf reports whether x+x < y but avoids overflow,
assuming x and y are both positive (Duration is signed).</p>
               
               <pre><code class="language-go">func lessThanHalf(x Duration, y Duration) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadLocation" data-name="loadLocation">
               <h3>
                  loadLocation 
                  <span class="badge">function</span>
                  
                  <a href="#loadLocation" class="anchor" title="Link to loadLocation">#</a>
               </h3>
               
               <p>loadLocation returns the Location with the given name from one of
the specified sources. See loadTzinfo for a list of supported sources.
The first timezone data matching the given name that is successfully loaded
and parsed is returned as a Location.</p>
               
               <pre><code class="language-go">func loadLocation(name string, sources []string) (z *Location, firstErr error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadTzinfo" data-name="loadTzinfo">
               <h3>
                  loadTzinfo 
                  <span class="badge">function</span>
                  
                  <a href="#loadTzinfo" class="anchor" title="Link to loadTzinfo">#</a>
               </h3>
               
               <p>loadTzinfo returns the time zone information of the time zone
with the given name, from a given source. A source may be a
timezone database directory, tzdata database file or an uncompressed
zip file, containing the contents of such a directory.</p>
               
               <pre><code class="language-go">func loadTzinfo(name string, source string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadTzinfoFromDirOrZip" data-name="loadTzinfoFromDirOrZip">
               <h3>
                  loadTzinfoFromDirOrZip 
                  <span class="badge">function</span>
                  
                  <a href="#loadTzinfoFromDirOrZip" class="anchor" title="Link to loadTzinfoFromDirOrZip">#</a>
               </h3>
               
               <p>loadTzinfoFromDirOrZip returns the contents of the file with the given name
in dir. dir can either be an uncompressed zip file, or a directory.</p>
               
               <pre><code class="language-go">func loadTzinfoFromDirOrZip(dir string, name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadTzinfoFromZip" data-name="loadTzinfoFromZip">
               <h3>
                  loadTzinfoFromZip 
                  <span class="badge">function</span>
                  
                  <a href="#loadTzinfoFromZip" class="anchor" title="Link to loadTzinfoFromZip">#</a>
               </h3>
               
               <p>loadTzinfoFromZip returns the contents of the file with the given name
in the given uncompressed zip file.</p>
               
               <pre><code class="language-go">func loadTzinfoFromZip(zipfile string, name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadZoneDataPlan9" data-name="loadZoneDataPlan9">
               <h3>
                  loadZoneDataPlan9 
                  <span class="badge">function</span>
                  
                  <a href="#loadZoneDataPlan9" class="anchor" title="Link to loadZoneDataPlan9">#</a>
               </h3>
               
               <pre><code class="language-go">func loadZoneDataPlan9(s string) (l *Location, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadZoneFilePlan9" data-name="loadZoneFilePlan9">
               <h3>
                  loadZoneFilePlan9 
                  <span class="badge">function</span>
                  
                  <a href="#loadZoneFilePlan9" class="anchor" title="Link to loadZoneFilePlan9">#</a>
               </h3>
               
               <pre><code class="language-go">func loadZoneFilePlan9(name string) (*Location, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="locabs" data-name="locabs">
               <h3>
                  locabs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#locabs" class="anchor" title="Link to locabs">#</a>
               </h3>
               
               <p>locabs is a combination of the Zone and abs methods,
extracting both return values from a single zone lookup.</p>
               
               <pre><code class="language-go">func (t Time) locabs() (name string, offset int, abs absSeconds)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookup" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge">function</span>
                  
                  <a href="#lookup" class="anchor" title="Link to lookup">#</a>
               </h3>
               
               <pre><code class="language-go">func lookup(tab []string, val string) (int, string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookup" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookup" class="anchor" title="Link to lookup">#</a>
               </h3>
               
               <p>lookup returns information about the time zone in use at an
instant in time expressed as seconds since January 1, 1970 00:00:00 UTC.
The returned information gives the name of the zone (such as "CET"),
the start and end times bracketing sec when that zone is in effect,
the offset in seconds east of UTC (such as -5*60*60), and whether
the daylight savings is being observed at that time.</p>
               
               <pre><code class="language-go">func (l *Location) lookup(sec int64) (name string, offset int, start int64, end int64, isDST bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupFirstZone" data-name="lookupFirstZone">
               <h3>
                  lookupFirstZone 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookupFirstZone" class="anchor" title="Link to lookupFirstZone">#</a>
               </h3>
               
               <p>lookupFirstZone returns the index of the time zone to use for times
before the first transition time, or when there are no transition
times.
The reference implementation in localtime.c from
https://www.iana.org/time-zones/repository/releases/tzcode2013g.tar.gz
implements the following algorithm for these cases:
1. If the first zone is unused by the transitions, use it.
2. Otherwise, if there are transition times, and the first
transition is to a zone in daylight time, find the first
non-daylight-time zone before and closest to the first transition
zone.
3. Otherwise, use the first zone that is not daylight time, if
there is one.
4. Otherwise, use the first zone.</p>
               
               <pre><code class="language-go">func (l *Location) lookupFirstZone() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupName" data-name="lookupName">
               <h3>
                  lookupName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookupName" class="anchor" title="Link to lookupName">#</a>
               </h3>
               
               <p>lookupName returns information about the time zone with
the given name (such as "EST") at the given pseudo-Unix time
(what the given time of day would be in UTC).</p>
               
               <pre><code class="language-go">func (l *Location) lookupName(name string, unix int64) (offset int, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge">function</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <p>match reports whether s1 and s2 match ignoring case.
It is assumed s1 and s2 are the same length.</p>
               
               <pre><code class="language-go">func match(s1 string, s2 string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchZoneKey" data-name="matchZoneKey">
               <h3>
                  matchZoneKey 
                  <span class="badge">function</span>
                  
                  <a href="#matchZoneKey" class="anchor" title="Link to matchZoneKey">#</a>
               </h3>
               
               <p>matchZoneKey checks if stdname and dstname match the corresponding key
values "MUI_Std" and "MUI_Dlt" or "Std" and "Dlt" in the kname key stored
under the open registry key zones.</p>
               
               <pre><code class="language-go">func matchZoneKey(zones registry.Key, kname string, stdname string, dstname string) (matched bool, err2 error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mono" data-name="mono">
               <h3>
                  mono 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mono" class="anchor" title="Link to mono">#</a>
               </h3>
               
               <p>mono returns t's monotonic clock reading.
It returns 0 for a missing reading.
This function is used only for testing,
so it's OK that technically 0 is a valid
monotonic clock reading as well.</p>
               
               <pre><code class="language-go">func (t *Time) mono() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="month" data-name="month">
               <h3>
                  month 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#month" class="anchor" title="Link to month">#</a>
               </h3>
               
               <p>month returns the standard Month for (m, janFeb)</p>
               
               <pre><code class="language-go">func (m absMonth) month(janFeb absJanFeb) Month</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newParseError" data-name="newParseError">
               <h3>
                  newParseError 
                  <span class="badge">function</span>
                  
                  <a href="#newParseError" class="anchor" title="Link to newParseError">#</a>
               </h3>
               
               <p>newParseError creates a new ParseError.
The provided value and valueElem are cloned to avoid escaping their values.</p>
               
               <pre><code class="language-go">func newParseError(layout string, value string, layoutElem string, valueElem string, message string) *ParseError</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTimer" data-name="newTimer">
               <h3>
                  newTimer 
                  <span class="badge">function</span>
                  
                  <a href="#newTimer" class="anchor" title="Link to newTimer">#</a>
               </h3>
               
               <p>The arg cp is a chan Time, but the declaration in runtime uses a pointer,
so we use a pointer here too. This keeps some tools that aggressively
compare linknamed symbol definitions happier.
go:linkname newTimer</p>
               
               <pre><code class="language-go">func newTimer(when int64, period int64, f func(any, uintptr, int64), arg any, cp unsafe.Pointer) *Timer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextStdChunk" data-name="nextStdChunk">
               <h3>
                  nextStdChunk 
                  <span class="badge">function</span>
                  
                  <a href="#nextStdChunk" class="anchor" title="Link to nextStdChunk">#</a>
               </h3>
               
               <p>nextStdChunk finds the first occurrence of a std string in
layout and returns the text before, the std string, and the text after.
nextStdChunk should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/searKing/golang/go
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname nextStdChunk</p>
               
               <pre><code class="language-go">func nextStdChunk(layout string) (prefix string, std int, suffix string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="norm" data-name="norm">
               <h3>
                  norm 
                  <span class="badge">function</span>
                  
                  <a href="#norm" class="anchor" title="Link to norm">#</a>
               </h3>
               
               <p>norm returns nhi, nlo such that
hi * base + lo == nhi * base + nlo
0 <= nlo < base</p>
               
               <pre><code class="language-go">func norm(hi int, lo int, base int) (nhi int, nlo int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="now" data-name="now">
               <h3>
                  now 
                  <span class="badge">function</span>
                  
                  <a href="#now" class="anchor" title="Link to now">#</a>
               </h3>
               
               <p>Provided by package runtime.
now returns the current real time, and is superseded by runtimeNow which returns
the fake synctest clock when appropriate.
now should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- gitee.com/quant1x/gox
- github.com/phuslu/log
- github.com/sethvargo/go-limiter
- github.com/ulule/limiter/v3
Do not remove or change the type signature.
See go.dev/issue/67401.</p>
               
               <pre><code class="language-go">func now() (sec int64, nsec int32, mono int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nsec" data-name="nsec">
               <h3>
                  nsec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nsec" class="anchor" title="Link to nsec">#</a>
               </h3>
               
               <p>nsec returns the time's nanoseconds.</p>
               
               <pre><code class="language-go">func (t *Time) nsec() int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="open" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
                  <a href="#open" class="anchor" title="Link to open">#</a>
               </h3>
               
               <pre><code class="language-go">func open(name string) (uintptr, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="open" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
                  <a href="#open" class="anchor" title="Link to open">#</a>
               </h3>
               
               <pre><code class="language-go">func open(name string) (uintptr, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="open" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
                  <a href="#open" class="anchor" title="Link to open">#</a>
               </h3>
               
               <pre><code class="language-go">func open(name string) (uintptr, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parse" data-name="parse">
               <h3>
                  parse 
                  <span class="badge">function</span>
                  
                  <a href="#parse" class="anchor" title="Link to parse">#</a>
               </h3>
               
               <pre><code class="language-go">func parse(layout string, value string, defaultLocation *Location, local *Location) (Time, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseGMT" data-name="parseGMT">
               <h3>
                  parseGMT 
                  <span class="badge">function</span>
                  
                  <a href="#parseGMT" class="anchor" title="Link to parseGMT">#</a>
               </h3>
               
               <p>parseGMT parses a GMT time zone. The input string is known to start "GMT".
The function checks whether that is followed by a sign and a number in the
range -23 through +23 excluding zero.</p>
               
               <pre><code class="language-go">func parseGMT(value string) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseNanoseconds" data-name="parseNanoseconds">
               <h3>
                  parseNanoseconds 
                  <span class="badge">function</span>
                  
                  <a href="#parseNanoseconds" class="anchor" title="Link to parseNanoseconds">#</a>
               </h3>
               
               <pre><code class="language-go">func parseNanoseconds(value bytes, nbytes int) (ns int, rangeErrString string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseRFC3339" data-name="parseRFC3339">
               <h3>
                  parseRFC3339 
                  <span class="badge">function</span>
                  
                  <a href="#parseRFC3339" class="anchor" title="Link to parseRFC3339">#</a>
               </h3>
               
               <pre><code class="language-go">func parseRFC3339(s bytes, local *Location) (Time, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseSignedOffset" data-name="parseSignedOffset">
               <h3>
                  parseSignedOffset 
                  <span class="badge">function</span>
                  
                  <a href="#parseSignedOffset" class="anchor" title="Link to parseSignedOffset">#</a>
               </h3>
               
               <p>parseSignedOffset parses a signed timezone offset (e.g. "+03" or "-04").
The function checks for a signed number in the range -23 through +23 excluding zero.
Returns length of the found offset string or 0 otherwise.</p>
               
               <pre><code class="language-go">func parseSignedOffset(value string) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseStrictRFC3339" data-name="parseStrictRFC3339">
               <h3>
                  parseStrictRFC3339 
                  <span class="badge">function</span>
                  
                  <a href="#parseStrictRFC3339" class="anchor" title="Link to parseStrictRFC3339">#</a>
               </h3>
               
               <pre><code class="language-go">func parseStrictRFC3339(b []byte) (Time, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseTimeZone" data-name="parseTimeZone">
               <h3>
                  parseTimeZone 
                  <span class="badge">function</span>
                  
                  <a href="#parseTimeZone" class="anchor" title="Link to parseTimeZone">#</a>
               </h3>
               
               <p>parseTimeZone parses a time zone string and returns its length. Time zones
are human-generated and unpredictable. We can't do precise error checking.
On the other hand, for a correct parse there must be a time zone at the
beginning of the string, so it's almost always true that there's one
there. We look at the beginning of the string for a run of upper-case letters.
If there are more than 5, it's an error.
If there are 4 or 5 and the last is a T, it's a time zone.
If there are 3, it's a time zone.
Otherwise, other than special cases, it's not a time zone.
GMT is special because it can have an hour offset.</p>
               
               <pre><code class="language-go">func parseTimeZone(value string) (length int, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="preadn" data-name="preadn">
               <h3>
                  preadn 
                  <span class="badge">function</span>
                  
                  <a href="#preadn" class="anchor" title="Link to preadn">#</a>
               </h3>
               
               <pre><code class="language-go">func preadn(fd uintptr, buf []byte, off int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="preadn" data-name="preadn">
               <h3>
                  preadn 
                  <span class="badge">function</span>
                  
                  <a href="#preadn" class="anchor" title="Link to preadn">#</a>
               </h3>
               
               <pre><code class="language-go">func preadn(fd uintptr, buf []byte, off int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="preadn" data-name="preadn">
               <h3>
                  preadn 
                  <span class="badge">function</span>
                  
                  <a href="#preadn" class="anchor" title="Link to preadn">#</a>
               </h3>
               
               <pre><code class="language-go">func preadn(fd uintptr, buf []byte, off int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pseudoUnix" data-name="pseudoUnix">
               <h3>
                  pseudoUnix 
                  <span class="badge">function</span>
                  
                  <a href="#pseudoUnix" class="anchor" title="Link to pseudoUnix">#</a>
               </h3>
               
               <p>pseudoUnix returns the pseudo-Unix time (seconds since Jan 1 1970 *LOCAL TIME*)
denoted by the system date+time d in the given year.
It is up to the caller to convert this local time into a UTC-based time.</p>
               
               <pre><code class="language-go">func pseudoUnix(year int, d *syscall.Systemtime) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="quote" data-name="quote">
               <h3>
                  quote 
                  <span class="badge">function</span>
                  
                  <a href="#quote" class="anchor" title="Link to quote">#</a>
               </h3>
               
               <pre><code class="language-go">func quote(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="read" data-name="read">
               <h3>
                  read 
                  <span class="badge">function</span>
                  
                  <a href="#read" class="anchor" title="Link to read">#</a>
               </h3>
               
               <pre><code class="language-go">func read(fd uintptr, buf []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="read" data-name="read">
               <h3>
                  read 
                  <span class="badge">function</span>
                  
                  <a href="#read" class="anchor" title="Link to read">#</a>
               </h3>
               
               <pre><code class="language-go">func read(fd uintptr, buf []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="read" data-name="read">
               <h3>
                  read 
                  <span class="badge">function</span>
                  
                  <a href="#read" class="anchor" title="Link to read">#</a>
               </h3>
               
               <pre><code class="language-go">func read(fd uintptr, buf []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="read" data-name="read">
               <h3>
                  read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#read" class="anchor" title="Link to read">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *dataIO) read(n int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFile" data-name="readFile">
               <h3>
                  readFile 
                  <span class="badge">function</span>
                  
                  <a href="#readFile" class="anchor" title="Link to readFile">#</a>
               </h3>
               
               <p>readFile reads and returns the content of the named file.
It is a trivial implementation of os.ReadFile, reimplemented
here to avoid depending on io/ioutil or os.
It returns an error if name exceeds maxFileSize bytes.</p>
               
               <pre><code class="language-go">func readFile(name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="registerLoadFromEmbeddedTZData" data-name="registerLoadFromEmbeddedTZData">
               <h3>
                  registerLoadFromEmbeddedTZData 
                  <span class="badge">function</span>
                  
                  <a href="#registerLoadFromEmbeddedTZData" class="anchor" title="Link to registerLoadFromEmbeddedTZData">#</a>
               </h3>
               
               <p>registerLoadFromEmbeddedTZData is called by the time/tzdata package,
if it is imported.
go:linkname registerLoadFromEmbeddedTZData</p>
               
               <pre><code class="language-go">func registerLoadFromEmbeddedTZData(f func(string) (string, error))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resetTimer" data-name="resetTimer">
               <h3>
                  resetTimer 
                  <span class="badge">function</span>
                  
                  <a href="#resetTimer" class="anchor" title="Link to resetTimer">#</a>
               </h3>
               
               <p>go:linkname resetTimer</p>
               
               <pre><code class="language-go">func resetTimer(t *Timer, when int64, period int64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rest" data-name="rest">
               <h3>
                  rest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rest" class="anchor" title="Link to rest">#</a>
               </h3>
               
               <p>rest returns the rest of the data in the buffer.</p>
               
               <pre><code class="language-go">func (d *dataIO) rest() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtimeNano" data-name="runtimeNano">
               <h3>
                  runtimeNano 
                  <span class="badge">function</span>
                  
                  <a href="#runtimeNano" class="anchor" title="Link to runtimeNano">#</a>
               </h3>
               
               <p>runtimeNano returns the current value of the runtime clock in nanoseconds.
When called within a synctest.Run bubble, it returns the group's fake clock.
go:linkname runtimeNano</p>
               
               <pre><code class="language-go">func runtimeNano() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtimeNow" data-name="runtimeNow">
               <h3>
                  runtimeNow 
                  <span class="badge">function</span>
                  
                  <a href="#runtimeNow" class="anchor" title="Link to runtimeNow">#</a>
               </h3>
               
               <p>runtimeNow returns the current time.
When called within a synctest.Run bubble, it returns the group's fake clock.
go:linkname runtimeNow</p>
               
               <pre><code class="language-go">func runtimeNow() (sec int64, nsec int32, mono int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sec" data-name="sec">
               <h3>
                  sec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sec" class="anchor" title="Link to sec">#</a>
               </h3>
               
               <p>sec returns the time's seconds since Jan 1 year 1.</p>
               
               <pre><code class="language-go">func (t *Time) sec() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sendTime" data-name="sendTime">
               <h3>
                  sendTime 
                  <span class="badge">function</span>
                  
                  <a href="#sendTime" class="anchor" title="Link to sendTime">#</a>
               </h3>
               
               <p>sendTime does a non-blocking send of the current time on c.</p>
               
               <pre><code class="language-go">func sendTime(c any, seq uintptr, delta int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="separator" data-name="separator">
               <h3>
                  separator 
                  <span class="badge">function</span>
                  
                  <a href="#separator" class="anchor" title="Link to separator">#</a>
               </h3>
               
               <pre><code class="language-go">func separator(std int) byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setLoc" data-name="setLoc">
               <h3>
                  setLoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setLoc" class="anchor" title="Link to setLoc">#</a>
               </h3>
               
               <p>setLoc sets the location associated with the time.</p>
               
               <pre><code class="language-go">func (t *Time) setLoc(loc *Location)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setMono" data-name="setMono">
               <h3>
                  setMono 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setMono" class="anchor" title="Link to setMono">#</a>
               </h3>
               
               <p>setMono sets the monotonic clock reading in t.
If t cannot hold a monotonic clock reading,
because its wall time is too large,
setMono is a no-op.</p>
               
               <pre><code class="language-go">func (t *Time) setMono(m int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skip" data-name="skip">
               <h3>
                  skip 
                  <span class="badge">function</span>
                  
                  <a href="#skip" class="anchor" title="Link to skip">#</a>
               </h3>
               
               <p>skip removes the given prefix from value,
treating runs of space characters as equivalent.</p>
               
               <pre><code class="language-go">func skip(value string, prefix string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="split" data-name="split">
               <h3>
                  split 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#split" class="anchor" title="Link to split">#</a>
               </h3>
               
               <p>split splits ayday into absolute month and standard (1-based) day-in-month.</p>
               
               <pre><code class="language-go">func (ayday absYday) split() (m absMonth, mday int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="split" data-name="split">
               <h3>
                  split 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#split" class="anchor" title="Link to split">#</a>
               </h3>
               
               <p>split splits days into century, cyear, ayday.</p>
               
               <pre><code class="language-go">func (days absDays) split() (century absCentury, cyear absCyear, ayday absYday)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startsWithLowerCase" data-name="startsWithLowerCase">
               <h3>
                  startsWithLowerCase 
                  <span class="badge">function</span>
                  
                  <a href="#startsWithLowerCase" class="anchor" title="Link to startsWithLowerCase">#</a>
               </h3>
               
               <p>startsWithLowerCase reports whether the string has a lower-case letter at the beginning.
Its purpose is to prevent matching strings like "Month" when looking for "Mon".</p>
               
               <pre><code class="language-go">func startsWithLowerCase(str string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stdFracSecond" data-name="stdFracSecond">
               <h3>
                  stdFracSecond 
                  <span class="badge">function</span>
                  
                  <a href="#stdFracSecond" class="anchor" title="Link to stdFracSecond">#</a>
               </h3>
               
               <p>The "std" value passed to appendNano contains two packed fields: the number of
digits after the decimal and the separator character (period or comma).
These functions pack and unpack that variable.</p>
               
               <pre><code class="language-go">func stdFracSecond(code int, n int, c int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stopTimer" data-name="stopTimer">
               <h3>
                  stopTimer 
                  <span class="badge">function</span>
                  
                  <a href="#stopTimer" class="anchor" title="Link to stopTimer">#</a>
               </h3>
               
               <p>go:linkname stopTimer</p>
               
               <pre><code class="language-go">func stopTimer(*Timer) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stripMono" data-name="stripMono">
               <h3>
                  stripMono 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stripMono" class="anchor" title="Link to stripMono">#</a>
               </h3>
               
               <p>stripMono strips the monotonic clock reading in t.</p>
               
               <pre><code class="language-go">func (t *Time) stripMono()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="subMono" data-name="subMono">
               <h3>
                  subMono 
                  <span class="badge">function</span>
                  
                  <a href="#subMono" class="anchor" title="Link to subMono">#</a>
               </h3>
               
               <pre><code class="language-go">func subMono(t int64, u int64) Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syncTimer" data-name="syncTimer">
               <h3>
                  syncTimer 
                  <span class="badge">function</span>
                  
                  <a href="#syncTimer" class="anchor" title="Link to syncTimer">#</a>
               </h3>
               
               <p>syncTimer returns c as an unsafe.Pointer, for passing to newTimer.
If the GODEBUG asynctimerchan has disabled the async timer chan
code, then syncTimer always returns nil, to disable the special
channel code paths in the runtime.</p>
               
               <pre><code class="language-go">func syncTimer(c chan Time) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toEnglishName" data-name="toEnglishName">
               <h3>
                  toEnglishName 
                  <span class="badge">function</span>
                  
                  <a href="#toEnglishName" class="anchor" title="Link to toEnglishName">#</a>
               </h3>
               
               <p>toEnglishName searches the registry for an English name of a time zone
whose zone names are stdname and dstname and returns the English name.</p>
               
               <pre><code class="language-go">func toEnglishName(stdname string, dstname string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tzruleTime" data-name="tzruleTime">
               <h3>
                  tzruleTime 
                  <span class="badge">function</span>
                  
                  <a href="#tzruleTime" class="anchor" title="Link to tzruleTime">#</a>
               </h3>
               
               <p>tzruleTime takes a year, a rule, and a timezone offset,
and returns the number of seconds since the start of the year
that the rule takes effect.</p>
               
               <pre><code class="language-go">func tzruleTime(year int, r rule, off int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tzset" data-name="tzset">
               <h3>
                  tzset 
                  <span class="badge">function</span>
                  
                  <a href="#tzset" class="anchor" title="Link to tzset">#</a>
               </h3>
               
               <p>tzset takes a timezone string like the one found in the TZ environment
variable, the time of the last time zone transition expressed as seconds
since January 1, 1970 00:00:00 UTC, and a time expressed the same way.
We call this a tzset string since in C the function tzset reads TZ.
The return values are as for lookup, plus ok which reports whether the
parse succeeded.</p>
               
               <pre><code class="language-go">func tzset(s string, lastTxSec int64, sec int64) (name string, offset int, start int64, end int64, isDST bool, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tzsetName" data-name="tzsetName">
               <h3>
                  tzsetName 
                  <span class="badge">function</span>
                  
                  <a href="#tzsetName" class="anchor" title="Link to tzsetName">#</a>
               </h3>
               
               <p>tzsetName returns the timezone name at the start of the tzset string s,
and the remainder of s, and reports whether the parsing is OK.</p>
               
               <pre><code class="language-go">func tzsetName(s string) (string, string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tzsetNum" data-name="tzsetNum">
               <h3>
                  tzsetNum 
                  <span class="badge">function</span>
                  
                  <a href="#tzsetNum" class="anchor" title="Link to tzsetNum">#</a>
               </h3>
               
               <p>tzsetNum parses a number from a tzset string.
It returns the number, and the remainder of the string, and reports success.
The number must be between min and max.</p>
               
               <pre><code class="language-go">func tzsetNum(s string, min int, max int) (num int, rest string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tzsetOffset" data-name="tzsetOffset">
               <h3>
                  tzsetOffset 
                  <span class="badge">function</span>
                  
                  <a href="#tzsetOffset" class="anchor" title="Link to tzsetOffset">#</a>
               </h3>
               
               <p>tzsetOffset returns the timezone offset at the start of the tzset string s,
and the remainder of s, and reports whether the parsing is OK.
The timezone offset is returned as a number of seconds.</p>
               
               <pre><code class="language-go">func tzsetOffset(s string) (offset int, rest string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tzsetRule" data-name="tzsetRule">
               <h3>
                  tzsetRule 
                  <span class="badge">function</span>
                  
                  <a href="#tzsetRule" class="anchor" title="Link to tzsetRule">#</a>
               </h3>
               
               <p>tzsetRule parses a rule from a tzset string.
It returns the rule, and the remainder of the string, and reports success.</p>
               
               <pre><code class="language-go">func tzsetRule(s string) (rule, string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unixSec" data-name="unixSec">
               <h3>
                  unixSec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unixSec" class="anchor" title="Link to unixSec">#</a>
               </h3>
               
               <p>unixSec returns the time's seconds since Jan 1 1970 (Unix time).</p>
               
               <pre><code class="language-go">func (t *Time) unixSec() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unixTime" data-name="unixTime">
               <h3>
                  unixTime 
                  <span class="badge">function</span>
                  
                  <a href="#unixTime" class="anchor" title="Link to unixTime">#</a>
               </h3>
               
               <pre><code class="language-go">func unixTime(sec int64, nsec int32) Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="weekday" data-name="weekday">
               <h3>
                  weekday 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#weekday" class="anchor" title="Link to weekday">#</a>
               </h3>
               
               <p>weekday returns the day of the week specified by days.</p>
               
               <pre><code class="language-go">func (days absDays) weekday() Weekday</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="when" data-name="when">
               <h3>
                  when 
                  <span class="badge">function</span>
                  
                  <a href="#when" class="anchor" title="Link to when">#</a>
               </h3>
               
               <p>when is a helper function for setting the 'when' field of a runtimeTimer.
It returns what the time will be, in nanoseconds, Duration d in the future.
If d is negative, it is ignored. If the returned value would be less than
zero because of an overflow, MaxInt64 is returned.</p>
               
               <pre><code class="language-go">func when(d Duration) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="yday" data-name="yday">
               <h3>
                  yday 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#yday" class="anchor" title="Link to yday">#</a>
               </h3>
               
               <p>yday returns the standard 1-based yday for (ayday, janFeb, leap).</p>
               
               <pre><code class="language-go">func (ayday absYday) yday(janFeb absJanFeb, leap absLeap) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="year" data-name="year">
               <h3>
                  year 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#year" class="anchor" title="Link to year">#</a>
               </h3>
               
               <p>year returns the standard year for (century, cyear, janFeb).</p>
               
               <pre><code class="language-go">func (century absCentury) year(cyear absCyear, janFeb absJanFeb) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="yearYday" data-name="yearYday">
               <h3>
                  yearYday 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#yearYday" class="anchor" title="Link to yearYday">#</a>
               </h3>
               
               <p>yearYday converts days into the standard year and 1-based yday.</p>
               
               <pre><code class="language-go">func (days absDays) yearYday() (year int, yday int)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>