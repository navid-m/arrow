<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>doc - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="go_doc_comment-docs.html">comment</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>doc</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"cmp"
"fmt"
"go/ast"
"go/token"
"internal/lazyregexp"
"path"
"slices"
"strconv"
"strings"
"unicode"
"unicode/utf8"
"go/doc/comment"
"strings"
"unicode"
"go/doc/comment"
"io"
"fmt"
"go/ast"
"go/doc/comment"
"go/token"
"strings"
"cmp"
"go/ast"
"go/token"
"internal/lazyregexp"
"path"
"slices"
"strconv"
"strings"
"unicode"
"unicode/utf8"
"go/ast"
"go/token"
"go/ast"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="AllDecls" data-name="AllDecls">
               <h3>
                  AllDecls 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AllDecls" class="anchor" title="Link to AllDecls">#</a>
               </h3>
               
                  <p class="doc-comment">AllDecls says to extract documentation for all package-level
declarations, not just exported ones.</p>
               
               <pre><code class="language-go">const AllDecls Mode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="AllMethods" data-name="AllMethods">
               <h3>
                  AllMethods 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AllMethods" class="anchor" title="Link to AllMethods">#</a>
               </h3>
               
                  <p class="doc-comment">AllMethods says to show all embedded methods, not just the ones of
invisible (unexported) anonymous fields.</p>
               
               <pre><code class="language-go">const AllMethods</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IllegalPrefixes" data-name="IllegalPrefixes">
               <h3>
                  IllegalPrefixes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#IllegalPrefixes" class="anchor" title="Link to IllegalPrefixes">#</a>
               </h3>
               
                  <p class="doc-comment">IllegalPrefixes is a list of lower-case prefixes that identify
a comment as not being a doc comment.
This helps to avoid misinterpreting the common mistake
of a copyright notice immediately before a package statement
as being a doc comment.</p>
               
               <pre><code class="language-go">var IllegalPrefixes = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PreserveAST" data-name="PreserveAST">
               <h3>
                  PreserveAST 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PreserveAST" class="anchor" title="Link to PreserveAST">#</a>
               </h3>
               
                  <p class="doc-comment">PreserveAST says to leave the AST unmodified. Originally, pieces of
the AST such as function bodies were nil-ed out to save memory in
godoc, but not all programs want that behavior.</p>
               
               <pre><code class="language-go">const PreserveAST</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noteCommentRx" data-name="noteCommentRx">
               <h3>
                  noteCommentRx 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#noteCommentRx" class="anchor" title="Link to noteCommentRx">#</a>
               </h3>
               
               <pre><code class="language-go">var noteCommentRx = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noteMarker" data-name="noteMarker">
               <h3>
                  noteMarker 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#noteMarker" class="anchor" title="Link to noteMarker">#</a>
               </h3>
               
               <pre><code class="language-go">var noteMarker = `([A-Z][A-Z]+)\(([^)]+)\):?`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noteMarkerRx" data-name="noteMarkerRx">
               <h3>
                  noteMarkerRx 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#noteMarkerRx" class="anchor" title="Link to noteMarkerRx">#</a>
               </h3>
               
               <pre><code class="language-go">var noteMarkerRx = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="outputPrefix" data-name="outputPrefix">
               <h3>
                  outputPrefix 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#outputPrefix" class="anchor" title="Link to outputPrefix">#</a>
               </h3>
               
               <pre><code class="language-go">var outputPrefix = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="predeclaredConstants" data-name="predeclaredConstants">
               <h3>
                  predeclaredConstants 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#predeclaredConstants" class="anchor" title="Link to predeclaredConstants">#</a>
               </h3>
               
               <pre><code class="language-go">var predeclaredConstants = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="predeclaredFuncs" data-name="predeclaredFuncs">
               <h3>
                  predeclaredFuncs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#predeclaredFuncs" class="anchor" title="Link to predeclaredFuncs">#</a>
               </h3>
               
               <pre><code class="language-go">var predeclaredFuncs = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="predeclaredTypes" data-name="predeclaredTypes">
               <h3>
                  predeclaredTypes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#predeclaredTypes" class="anchor" title="Link to predeclaredTypes">#</a>
               </h3>
               
               <pre><code class="language-go">var predeclaredTypes = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="underscore" data-name="underscore">
               <h3>
                  underscore 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#underscore" class="anchor" title="Link to underscore">#</a>
               </h3>
               
               <pre><code class="language-go">var underscore = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Filter" data-name="Filter">
               <h3>
                  Filter
                  <span class="badge type-badge">type</span>
                  <a href="#Filter" class="anchor" title="Link to Filter">#</a>
               </h3>
               
               <pre><code class="language-go">type Filter func(string) bool</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Mode" data-name="Mode">
               <h3>
                  Mode
                  <span class="badge type-badge">type</span>
                  <a href="#Mode" class="anchor" title="Link to Mode">#</a>
               </h3>
               
               <p>Mode values control the operation of [New] and [NewFromFiles].</p>
               
               <pre><code class="language-go">type Mode int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="embeddedSet" data-name="embeddedSet">
               <h3>
                  embeddedSet
                  <span class="badge type-badge">type</span>
                  <a href="#embeddedSet" class="anchor" title="Link to embeddedSet">#</a>
               </h3>
               
               <p>An embeddedSet describes a set of embedded types.</p>
               
               <pre><code class="language-go">type embeddedSet map[*namedType]bool</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="methodSet" data-name="methodSet">
               <h3>
                  methodSet
                  <span class="badge type-badge">type</span>
                  <a href="#methodSet" class="anchor" title="Link to methodSet">#</a>
               </h3>
               
               <p>A methodSet describes a set of methods. Entries where Decl == nil are conflict
entries (more than one method with the same name at the same embedding level).</p>
               
               <pre><code class="language-go">type methodSet map[string]*Func</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Example" data-name="Example">
               <h3>
                  Example
                  <span class="badge">struct</span>
                  <a href="#Example" class="anchor" title="Link to Example">#</a>
               </h3>
               
               <p>An Example represents an example function found in a test source file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Example struct {
Name string
Suffix string
Doc string
Code ast.Node
Play *ast.File
Comments []*ast.CommentGroup
Output string
Unordered bool
EmptyOutput bool
Order int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Func" data-name="Func">
               <h3>
                  Func
                  <span class="badge">struct</span>
                  <a href="#Func" class="anchor" title="Link to Func">#</a>
               </h3>
               
               <p>Func is the documentation for a func declaration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Func struct {
Doc string
Name string
Decl *ast.FuncDecl
Recv string
Orig string
Level int
Examples []*Example
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Note" data-name="Note">
               <h3>
                  Note
                  <span class="badge">struct</span>
                  <a href="#Note" class="anchor" title="Link to Note">#</a>
               </h3>
               
               <p>A Note represents a marked comment starting with "MARKER(uid): note body".
Any note with a marker of 2 or more upper case [A-Z] letters and a uid of
at least one character is recognized. The ":" following the uid is optional.
Notes are collected in the Package.Notes map indexed by the notes marker.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Note struct {
Pos token.Pos
End token.Pos
UID string
Body string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Package" data-name="Package">
               <h3>
                  Package
                  <span class="badge">struct</span>
                  <a href="#Package" class="anchor" title="Link to Package">#</a>
               </h3>
               
               <p>Package is the documentation for an entire package.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Package struct {
Doc string
Name string
ImportPath string
Imports []string
Filenames []string
Notes map[string][]*Note
Bugs []string
Consts []*Value
Types []*Type
Vars []*Value
Funcs []*Func
Examples []*Example
importByName map[string]string
syms map[string]bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type
                  <span class="badge">struct</span>
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>Type is the documentation for a type declaration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Type struct {
Doc string
Name string
Decl *ast.GenDecl
Consts []*Value
Vars []*Value
Funcs []*Func
Methods []*Func
Examples []*Example
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value
                  <span class="badge">struct</span>
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <p>Value is the documentation for a (possibly grouped) var or const declaration.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Value struct {
Doc string
Names []string
Decl *ast.GenDecl
order int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="namedType" data-name="namedType">
               <h3>
                  namedType
                  <span class="badge">struct</span>
                  <a href="#namedType" class="anchor" title="Link to namedType">#</a>
               </h3>
               
               <p>A namedType represents a named unqualified (package local, or possibly
predeclared) type. The namedType for a type name is always found via
reader.lookupType.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type namedType struct {
doc string
name string
decl *ast.GenDecl
isEmbedded bool
isStruct bool
embedded embeddedSet
values []*Value
funcs methodSet
methods methodSet
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="reader" data-name="reader">
               <h3>
                  reader
                  <span class="badge">struct</span>
                  <a href="#reader" class="anchor" title="Link to reader">#</a>
               </h3>
               
               <p>reader accumulates documentation for a single package.
It modifies the AST: Comments (declaration documentation)
that have been collected by the reader are set to nil
in the respective AST nodes so that they are not printed
twice (once when printing the documentation and once when
printing the corresponding AST node).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type reader struct {
mode Mode
doc string
filenames []string
notes map[string][]*Note
imports map[string]int
hasDotImp bool
importByName map[string]string
values []*Value
order int
types map[string]*namedType
funcs methodSet
shadowedPredecl map[string]bool
fixmap map[string][]*ast.InterfaceType
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Filter" data-name="Filter">
               <h3>
                  Filter 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Filter" class="anchor" title="Link to Filter">#</a>
               </h3>
               
               <p>Filter eliminates documentation for names that don't pass through the filter f.
TODO(gri): Recognize "Type.Method" as a name.</p>
               
               <pre><code class="language-go">func (p *Package) Filter(f Filter)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HTML" data-name="HTML">
               <h3>
                  HTML 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HTML" class="anchor" title="Link to HTML">#</a>
               </h3>
               
               <p>HTML returns formatted HTML for the doc comment text.
To customize details of the HTML, use [Package.Printer]
to obtain a [comment.Printer], and configure it
before calling its HTML method.</p>
               
               <pre><code class="language-go">func (p *Package) HTML(text string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsPredeclared" data-name="IsPredeclared">
               <h3>
                  IsPredeclared 
                  <span class="badge">function</span>
                  
                  <a href="#IsPredeclared" class="anchor" title="Link to IsPredeclared">#</a>
               </h3>
               
               <p>IsPredeclared reports whether s is a predeclared identifier.</p>
               
               <pre><code class="language-go">func IsPredeclared(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Markdown" data-name="Markdown">
               <h3>
                  Markdown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Markdown" class="anchor" title="Link to Markdown">#</a>
               </h3>
               
               <p>Markdown returns formatted Markdown for the doc comment text.
To customize details of the Markdown, use [Package.Printer]
to obtain a [comment.Printer], and configure it
before calling its Markdown method.</p>
               
               <pre><code class="language-go">func (p *Package) Markdown(text string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="New" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
                  <a href="#New" class="anchor" title="Link to New">#</a>
               </h3>
               
               <p>New computes the package documentation for the given package AST.
New takes ownership of the AST pkg and may edit or overwrite it.
To have the [Examples] fields populated, use [NewFromFiles] and include
the package's _test.go files.</p>
               
               <pre><code class="language-go">func New(pkg *ast.Package, importPath string, mode Mode) *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewFromFiles" data-name="NewFromFiles">
               <h3>
                  NewFromFiles 
                  <span class="badge">function</span>
                  
                  <a href="#NewFromFiles" class="anchor" title="Link to NewFromFiles">#</a>
               </h3>
               
               <p>NewFromFiles computes documentation for a package.
The package is specified by a list of *ast.Files and corresponding
file set, which must not be nil.
NewFromFiles uses all provided files when computing documentation,
so it is the caller's responsibility to provide only the files that
match the desired build context. "go/build".Context.MatchFile can
be used for determining whether a file matches a build context with
the desired GOOS and GOARCH values, and other build constraints.
The import path of the package is specified by importPath.
Examples found in _test.go files are associated with the corresponding
type, function, method, or the package, based on their name.
If the example has a suffix in its name, it is set in the
[Example.Suffix] field. [Examples] with malformed names are skipped.
Optionally, a single extra argument of type [Mode] can be provided to
control low-level aspects of the documentation extraction behavior.
NewFromFiles takes ownership of the AST files and may edit them,
unless the PreserveAST Mode bit is on.</p>
               
               <pre><code class="language-go">func NewFromFiles(fset *token.FileSet, files []*ast.File, importPath string, opts ...any) (*Package, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parser" data-name="Parser">
               <h3>
                  Parser 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Parser" class="anchor" title="Link to Parser">#</a>
               </h3>
               
               <p>Parser returns a doc comment parser configured
for parsing doc comments from package p.
Each call returns a new parser, so that the caller may
customize it before use.</p>
               
               <pre><code class="language-go">func (p *Package) Parser() *comment.Parser</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Printer" data-name="Printer">
               <h3>
                  Printer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Printer" class="anchor" title="Link to Printer">#</a>
               </h3>
               
               <p>Printer returns a doc comment printer configured
for printing doc comments from package p.
Each call returns a new printer, so that the caller may
customize it before use.</p>
               
               <pre><code class="language-go">func (p *Package) Printer() *comment.Printer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Synopsis" data-name="Synopsis">
               <h3>
                  Synopsis 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Synopsis" class="anchor" title="Link to Synopsis">#</a>
               </h3>
               
               <p>Synopsis returns a cleaned version of the first sentence in text.
That sentence ends after the first period followed by space and not
preceded by exactly one uppercase letter, or at the first paragraph break.
The result string has no \n, \r, or \t characters and uses only single
spaces between words. If text starts with any of the [IllegalPrefixes],
the result is the empty string.</p>
               
               <pre><code class="language-go">func (p *Package) Synopsis(text string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Synopsis" data-name="Synopsis">
               <h3>
                  Synopsis 
                  <span class="badge">function</span>
                  
                  <a href="#Synopsis" class="anchor" title="Link to Synopsis">#</a>
               </h3>
               
               <p>Synopsis returns a cleaned version of the first sentence in text.
Deprecated: New programs should use [Package.Synopsis] instead,
which handles links in text properly.</p>
               
               <pre><code class="language-go">func Synopsis(text string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Text" data-name="Text">
               <h3>
                  Text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Text" class="anchor" title="Link to Text">#</a>
               </h3>
               
               <p>Text returns formatted text for the doc comment text,
wrapped to 80 Unicode code points and using tabs for
code block indentation.
To customize details of the formatting, use [Package.Printer]
to obtain a [comment.Printer], and configure it
before calling its Text method.</p>
               
               <pre><code class="language-go">func (p *Package) Text(text string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToHTML" data-name="ToHTML">
               <h3>
                  ToHTML 
                  <span class="badge">function</span>
                  
                  <a href="#ToHTML" class="anchor" title="Link to ToHTML">#</a>
               </h3>
               
               <p>ToHTML converts comment text to formatted HTML.
Deprecated: ToHTML cannot identify documentation links
in the doc comment, because they depend on knowing what
package the text came from, which is not included in this API.
Given the *[doc.Package] p where text was found,
ToHTML(w, text, nil) can be replaced by:
w.Write(p.HTML(text))
which is in turn shorthand for:
w.Write(p.Printer().HTML(p.Parser().Parse(text)))
If words may be non-nil, the longer replacement is:
parser := p.Parser()
parser.Words = words
w.Write(p.Printer().HTML(parser.Parse(d)))</p>
               
               <pre><code class="language-go">func ToHTML(w io.Writer, text string, words map[string]string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToText" data-name="ToText">
               <h3>
                  ToText 
                  <span class="badge">function</span>
                  
                  <a href="#ToText" class="anchor" title="Link to ToText">#</a>
               </h3>
               
               <p>ToText converts comment text to formatted text.
Deprecated: ToText cannot identify documentation links
in the doc comment, because they depend on knowing what
package the text came from, which is not included in this API.
Given the *[doc.Package] p where text was found,
ToText(w, text, "", "\t", 80) can be replaced by:
w.Write(p.Text(text))
In the general case, ToText(w, text, prefix, codePrefix, width)
can be replaced by:
d := p.Parser().Parse(text)
pr := p.Printer()
pr.TextPrefix = prefix
pr.TextCodePrefix = codePrefix
pr.TextWidth = width
w.Write(pr.Text(d))
See the documentation for [Package.Text] and [comment.Printer.Text]
for more details.</p>
               
               <pre><code class="language-go">func ToText(w io.Writer, text string, prefix string, codePrefix string, width int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add adds method m to the method set; m is ignored if the method set
already contains a method with the same name at the same or a higher
level than m.</p>
               
               <pre><code class="language-go">func (mset methodSet) add(m *Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assumedPackageName" data-name="assumedPackageName">
               <h3>
                  assumedPackageName 
                  <span class="badge">function</span>
                  
                  <a href="#assumedPackageName" class="anchor" title="Link to assumedPackageName">#</a>
               </h3>
               
               <p>assumedPackageName returns the assumed package name
for a given import path. This is a copy of
golang.org/x/tools/internal/imports.ImportPathToAssumedName.</p>
               
               <pre><code class="language-go">func assumedPackageName(importPath string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="baseTypeName" data-name="baseTypeName">
               <h3>
                  baseTypeName 
                  <span class="badge">function</span>
                  
                  <a href="#baseTypeName" class="anchor" title="Link to baseTypeName">#</a>
               </h3>
               
               <p>baseTypeName returns the name of the base type of x (or "")
and whether the type is imported or not.</p>
               
               <pre><code class="language-go">func baseTypeName(x ast.Expr) (name string, imported bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="classifyExamples" data-name="classifyExamples">
               <h3>
                  classifyExamples 
                  <span class="badge">function</span>
                  
                  <a href="#classifyExamples" class="anchor" title="Link to classifyExamples">#</a>
               </h3>
               
               <p>classifyExamples classifies examples and assigns them to the Examples field
of the relevant Func, Type, or Package that the example is associated with.
The classification process is ambiguous in some cases:
- ExampleFoo_Bar matches a type named Foo_Bar
or a method named Foo.Bar.
- ExampleFoo_bar matches a type named Foo_bar
or Foo (with a "bar" suffix).
Examples with malformed names are not associated with anything.</p>
               
               <pre><code class="language-go">func classifyExamples(p *Package, examples []*Example)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="clean" data-name="clean">
               <h3>
                  clean 
                  <span class="badge">function</span>
                  
                  <a href="#clean" class="anchor" title="Link to clean">#</a>
               </h3>
               
               <p>clean replaces each sequence of space, \r, or \t characters
with a single space and removes any trailing and leading spaces.</p>
               
               <pre><code class="language-go">func clean(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanupTypes" data-name="cleanupTypes">
               <h3>
                  cleanupTypes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cleanupTypes" class="anchor" title="Link to cleanupTypes">#</a>
               </h3>
               
               <p>cleanupTypes removes the association of functions and methods with
types that have no declaration. Instead, these functions and methods
are shown at the package level. It also removes types with missing
declarations or which are not visible.</p>
               
               <pre><code class="language-go">func (r *reader) cleanupTypes()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectEmbeddedMethods" data-name="collectEmbeddedMethods">
               <h3>
                  collectEmbeddedMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collectEmbeddedMethods" class="anchor" title="Link to collectEmbeddedMethods">#</a>
               </h3>
               
               <p>collectEmbeddedMethods collects the embedded methods of typ in mset.</p>
               
               <pre><code class="language-go">func (r *reader) collectEmbeddedMethods(mset methodSet, typ *namedType, recvTypeName string, embeddedIsPtr bool, level int, visited embeddedSet)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectFuncs" data-name="collectFuncs">
               <h3>
                  collectFuncs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collectFuncs" class="anchor" title="Link to collectFuncs">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Package) collectFuncs(funcs []*Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectTypes" data-name="collectTypes">
               <h3>
                  collectTypes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collectTypes" class="anchor" title="Link to collectTypes">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Package) collectTypes(types []*Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collectValues" data-name="collectValues">
               <h3>
                  collectValues 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collectValues" class="anchor" title="Link to collectValues">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Package) collectValues(values []*Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computeMethodSets" data-name="computeMethodSets">
               <h3>
                  computeMethodSets 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#computeMethodSets" class="anchor" title="Link to computeMethodSets">#</a>
               </h3>
               
               <p>computeMethodSets determines the actual method sets for each type encountered.</p>
               
               <pre><code class="language-go">func (r *reader) computeMethodSets()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyConstType" data-name="copyConstType">
               <h3>
                  copyConstType 
                  <span class="badge">function</span>
                  
                  <a href="#copyConstType" class="anchor" title="Link to copyConstType">#</a>
               </h3>
               
               <p>copyConstType returns a copy of typ with position pos.
typ must be a valid constant type.
In practice, only (possibly qualified) identifiers are possible.</p>
               
               <pre><code class="language-go">func copyConstType(typ ast.Expr, pos token.Pos) ast.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="customizeRecv" data-name="customizeRecv">
               <h3>
                  customizeRecv 
                  <span class="badge">function</span>
                  
                  <a href="#customizeRecv" class="anchor" title="Link to customizeRecv">#</a>
               </h3>
               
               <pre><code class="language-go">func customizeRecv(f *Func, recvTypeName string, embeddedIsPtr bool, level int) *Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exampleOutput" data-name="exampleOutput">
               <h3>
                  exampleOutput 
                  <span class="badge">function</span>
                  
                  <a href="#exampleOutput" class="anchor" title="Link to exampleOutput">#</a>
               </h3>
               
               <p>Extracts the expected output and whether there was a valid output comment.</p>
               
               <pre><code class="language-go">func exampleOutput(b *ast.BlockStmt, comments []*ast.CommentGroup) (output string, unordered bool, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fields" data-name="fields">
               <h3>
                  fields 
                  <span class="badge">function</span>
                  
                  <a href="#fields" class="anchor" title="Link to fields">#</a>
               </h3>
               
               <p>fields returns a struct's fields or an interface's methods.</p>
               
               <pre><code class="language-go">func fields(typ ast.Expr) (list []*ast.Field, isStruct bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fileExports" data-name="fileExports">
               <h3>
                  fileExports 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fileExports" class="anchor" title="Link to fileExports">#</a>
               </h3>
               
               <p>fileExports removes unexported declarations from src in place.</p>
               
               <pre><code class="language-go">func (r *reader) fileExports(src *ast.File)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterCompositeLit" data-name="filterCompositeLit">
               <h3>
                  filterCompositeLit 
                  <span class="badge">function</span>
                  
                  <a href="#filterCompositeLit" class="anchor" title="Link to filterCompositeLit">#</a>
               </h3>
               
               <pre><code class="language-go">func filterCompositeLit(lit *ast.CompositeLit, filter Filter, export bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterDecl" data-name="filterDecl">
               <h3>
                  filterDecl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#filterDecl" class="anchor" title="Link to filterDecl">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *reader) filterDecl(decl ast.Decl) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterExprList" data-name="filterExprList">
               <h3>
                  filterExprList 
                  <span class="badge">function</span>
                  
                  <a href="#filterExprList" class="anchor" title="Link to filterExprList">#</a>
               </h3>
               
               <pre><code class="language-go">func filterExprList(list []ast.Expr, filter Filter, export bool) []ast.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterFieldList" data-name="filterFieldList">
               <h3>
                  filterFieldList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#filterFieldList" class="anchor" title="Link to filterFieldList">#</a>
               </h3>
               
               <p>filterFieldList removes unexported fields (field names) from the field list
in place and reports whether fields were removed. Anonymous fields are
recorded with the parent type. filterType is called with the types of
all remaining fields.</p>
               
               <pre><code class="language-go">func (r *reader) filterFieldList(parent *namedType, fields *ast.FieldList, ityp *ast.InterfaceType) (removedFields bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterFuncs" data-name="filterFuncs">
               <h3>
                  filterFuncs 
                  <span class="badge">function</span>
                  
                  <a href="#filterFuncs" class="anchor" title="Link to filterFuncs">#</a>
               </h3>
               
               <pre><code class="language-go">func filterFuncs(a []*Func, f Filter) []*Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterIdentList" data-name="filterIdentList">
               <h3>
                  filterIdentList 
                  <span class="badge">function</span>
                  
                  <a href="#filterIdentList" class="anchor" title="Link to filterIdentList">#</a>
               </h3>
               
               <p>filterIdentList removes unexported names from list in place
and returns the resulting list.</p>
               
               <pre><code class="language-go">func filterIdentList(list []*ast.Ident) []*ast.Ident</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterParamList" data-name="filterParamList">
               <h3>
                  filterParamList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#filterParamList" class="anchor" title="Link to filterParamList">#</a>
               </h3>
               
               <p>filterParamList applies filterType to each parameter type in fields.</p>
               
               <pre><code class="language-go">func (r *reader) filterParamList(fields *ast.FieldList)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterSpec" data-name="filterSpec">
               <h3>
                  filterSpec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#filterSpec" class="anchor" title="Link to filterSpec">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *reader) filterSpec(spec ast.Spec) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterSpecList" data-name="filterSpecList">
               <h3>
                  filterSpecList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#filterSpecList" class="anchor" title="Link to filterSpecList">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *reader) filterSpecList(list []ast.Spec, tok token.Token) []ast.Spec</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterType" data-name="filterType">
               <h3>
                  filterType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#filterType" class="anchor" title="Link to filterType">#</a>
               </h3>
               
               <p>filterType strips any unexported struct fields or method types from typ
in place. If fields (or methods) have been removed, the corresponding
struct or interface type has the Incomplete field set to true.</p>
               
               <pre><code class="language-go">func (r *reader) filterType(parent *namedType, typ ast.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterTypes" data-name="filterTypes">
               <h3>
                  filterTypes 
                  <span class="badge">function</span>
                  
                  <a href="#filterTypes" class="anchor" title="Link to filterTypes">#</a>
               </h3>
               
               <pre><code class="language-go">func filterTypes(a []*Type, f Filter) []*Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filterValues" data-name="filterValues">
               <h3>
                  filterValues 
                  <span class="badge">function</span>
                  
                  <a href="#filterValues" class="anchor" title="Link to filterValues">#</a>
               </h3>
               
               <pre><code class="language-go">func filterValues(a []*Value, f Filter) []*Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findDeclsAndUnresolved" data-name="findDeclsAndUnresolved">
               <h3>
                  findDeclsAndUnresolved 
                  <span class="badge">function</span>
                  
                  <a href="#findDeclsAndUnresolved" class="anchor" title="Link to findDeclsAndUnresolved">#</a>
               </h3>
               
               <p>findDeclsAndUnresolved returns all the top-level declarations mentioned in
the body, and a set of unresolved symbols (those that appear in the body but
have no declaration in the program).
topDecls maps objects to the top-level declaration declaring them (not
necessarily obj.Decl, as obj.Decl will be a Spec for GenDecls, but
topDecls[obj] will be the GenDecl itself).</p>
               
               <pre><code class="language-go">func findDeclsAndUnresolved(body ast.Node, topDecls map[*ast.Object]ast.Decl, typMethods map[string][]ast.Decl) ([]ast.Decl, map[string]bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findImportGroupStarts" data-name="findImportGroupStarts">
               <h3>
                  findImportGroupStarts 
                  <span class="badge">function</span>
                  
                  <a href="#findImportGroupStarts" class="anchor" title="Link to findImportGroupStarts">#</a>
               </h3>
               
               <p>findImportGroupStarts finds the start positions of each sequence of import
specs that are not separated by a blank line.</p>
               
               <pre><code class="language-go">func findImportGroupStarts(imps []*ast.ImportSpec) []token.Pos</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findImportGroupStarts1" data-name="findImportGroupStarts1">
               <h3>
                  findImportGroupStarts1 
                  <span class="badge">function</span>
                  
                  <a href="#findImportGroupStarts1" class="anchor" title="Link to findImportGroupStarts1">#</a>
               </h3>
               
               <p>Helper for findImportGroupStarts to ease testing.</p>
               
               <pre><code class="language-go">func findImportGroupStarts1(origImps []*ast.ImportSpec) []*ast.ImportSpec</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="firstSentence" data-name="firstSentence">
               <h3>
                  firstSentence 
                  <span class="badge">function</span>
                  
                  <a href="#firstSentence" class="anchor" title="Link to firstSentence">#</a>
               </h3>
               
               <p>firstSentence returns the first sentence in s.
The sentence ends after the first period followed by space and
not preceded by exactly one uppercase letter.</p>
               
               <pre><code class="language-go">func firstSentence(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasExportedName" data-name="hasExportedName">
               <h3>
                  hasExportedName 
                  <span class="badge">function</span>
                  
                  <a href="#hasExportedName" class="anchor" title="Link to hasExportedName">#</a>
               </h3>
               
               <p>hasExportedName reports whether list contains any exported names.</p>
               
               <pre><code class="language-go">func hasExportedName(list []*ast.Ident) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasIota" data-name="hasIota">
               <h3>
                  hasIota 
                  <span class="badge">function</span>
                  
                  <a href="#hasIota" class="anchor" title="Link to hasIota">#</a>
               </h3>
               
               <pre><code class="language-go">func hasIota(s ast.Spec) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isExampleSuffix" data-name="isExampleSuffix">
               <h3>
                  isExampleSuffix 
                  <span class="badge">function</span>
                  
                  <a href="#isExampleSuffix" class="anchor" title="Link to isExampleSuffix">#</a>
               </h3>
               
               <pre><code class="language-go">func isExampleSuffix(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isPredeclared" data-name="isPredeclared">
               <h3>
                  isPredeclared 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isPredeclared" class="anchor" title="Link to isPredeclared">#</a>
               </h3>
               
               <p>isPredeclared reports whether n denotes a predeclared type.</p>
               
               <pre><code class="language-go">func (r *reader) isPredeclared(n string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTest" data-name="isTest">
               <h3>
                  isTest 
                  <span class="badge">function</span>
                  
                  <a href="#isTest" class="anchor" title="Link to isTest">#</a>
               </h3>
               
               <p>isTest tells whether name looks like a test, example, fuzz test, or
benchmark. It is a Test (say) if there is a character after Test that is not
a lower-case letter. (We don't want Testiness.)</p>
               
               <pre><code class="language-go">func isTest(name string, prefix string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isVisible" data-name="isVisible">
               <h3>
                  isVisible 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isVisible" class="anchor" title="Link to isVisible">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *reader) isVisible(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lastComment" data-name="lastComment">
               <h3>
                  lastComment 
                  <span class="badge">function</span>
                  
                  <a href="#lastComment" class="anchor" title="Link to lastComment">#</a>
               </h3>
               
               <p>lastComment returns the last comment inside the provided block.</p>
               
               <pre><code class="language-go">func lastComment(b *ast.BlockStmt, c []*ast.CommentGroup) (i int, last *ast.CommentGroup)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupPackage" data-name="lookupPackage">
               <h3>
                  lookupPackage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookupPackage" class="anchor" title="Link to lookupPackage">#</a>
               </h3>
               
               <p>lookupPackage returns the import path identified by name
in the given package. If name uniquely identifies a single import,
then lookupPackage returns that import.
If multiple packages are imported as name, importPath returns "", false.
Otherwise, if name is the name of p itself, importPath returns "", true,
to signal a reference to p.
Otherwise, importPath returns "", false.</p>
               
               <pre><code class="language-go">func (p *Package) lookupPackage(name string) (importPath string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupSym" data-name="lookupSym">
               <h3>
                  lookupSym 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookupSym" class="anchor" title="Link to lookupSym">#</a>
               </h3>
               
               <p>lookupSym reports whether the package has a given symbol or method.
If recv == "", HasSym reports whether the package has a top-level
const, func, type, or var named name.
If recv != "", HasSym reports whether the package has a type
named recv with a method named name.</p>
               
               <pre><code class="language-go">func (p *Package) lookupSym(recv string, name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupType" data-name="lookupType">
               <h3>
                  lookupType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lookupType" class="anchor" title="Link to lookupType">#</a>
               </h3>
               
               <p>lookupType returns the base type with the given name.
If the base type has not been encountered yet, a new
type with the given name but no associated declaration
is added to the type map.</p>
               
               <pre><code class="language-go">func (r *reader) lookupType(name string) *namedType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupTypeParam" data-name="lookupTypeParam">
               <h3>
                  lookupTypeParam 
                  <span class="badge">function</span>
                  
                  <a href="#lookupTypeParam" class="anchor" title="Link to lookupTypeParam">#</a>
               </h3>
               
               <p>lookupTypeParam searches for type parameters named name within the tparams
field list, returning the relevant identifier if found, or nil if not.</p>
               
               <pre><code class="language-go">func lookupTypeParam(name string, tparams *ast.FieldList) *ast.Ident</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchDecl" data-name="matchDecl">
               <h3>
                  matchDecl 
                  <span class="badge">function</span>
                  
                  <a href="#matchDecl" class="anchor" title="Link to matchDecl">#</a>
               </h3>
               
               <pre><code class="language-go">func matchDecl(d *ast.GenDecl, f Filter) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchFields" data-name="matchFields">
               <h3>
                  matchFields 
                  <span class="badge">function</span>
                  
                  <a href="#matchFields" class="anchor" title="Link to matchFields">#</a>
               </h3>
               
               <pre><code class="language-go">func matchFields(fields *ast.FieldList, f Filter) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nameWithoutInst" data-name="nameWithoutInst">
               <h3>
                  nameWithoutInst 
                  <span class="badge">function</span>
                  
                  <a href="#nameWithoutInst" class="anchor" title="Link to nameWithoutInst">#</a>
               </h3>
               
               <p>nameWithoutInst returns name if name has no brackets. If name contains
brackets, then it returns name with all the contents between (and including)
the outermost left and right bracket removed.
Adapted from debug/gosym/symtab.go:Sym.nameWithoutInst.</p>
               
               <pre><code class="language-go">func nameWithoutInst(name string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="noteBodies" data-name="noteBodies">
               <h3>
                  noteBodies 
                  <span class="badge">function</span>
                  
                  <a href="#noteBodies" class="anchor" title="Link to noteBodies">#</a>
               </h3>
               
               <p>noteBodies returns a list of note body strings given a list of notes.
This is only used to populate the deprecated Package.Bugs field.</p>
               
               <pre><code class="language-go">func noteBodies(notes []*Note) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="playExample" data-name="playExample">
               <h3>
                  playExample 
                  <span class="badge">function</span>
                  
                  <a href="#playExample" class="anchor" title="Link to playExample">#</a>
               </h3>
               
               <p>playExample synthesizes a new *ast.File based on the provided
file with the provided function body as the body of main.</p>
               
               <pre><code class="language-go">func playExample(file *ast.File, f *ast.FuncDecl) *ast.File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="playExampleFile" data-name="playExampleFile">
               <h3>
                  playExampleFile 
                  <span class="badge">function</span>
                  
                  <a href="#playExampleFile" class="anchor" title="Link to playExampleFile">#</a>
               </h3>
               
               <p>playExampleFile takes a whole file example and synthesizes a new *ast.File
such that the example is function main in package main.</p>
               
               <pre><code class="language-go">func playExampleFile(file *ast.File) *ast.File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readDoc" data-name="readDoc">
               <h3>
                  readDoc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readDoc" class="anchor" title="Link to readDoc">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *reader) readDoc(comment *ast.CommentGroup)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFile" data-name="readFile">
               <h3>
                  readFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readFile" class="anchor" title="Link to readFile">#</a>
               </h3>
               
               <p>readFile adds the AST for a source file to the reader.</p>
               
               <pre><code class="language-go">func (r *reader) readFile(src *ast.File)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFunc" data-name="readFunc">
               <h3>
                  readFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readFunc" class="anchor" title="Link to readFunc">#</a>
               </h3>
               
               <p>readFunc processes a func or method declaration.</p>
               
               <pre><code class="language-go">func (r *reader) readFunc(fun *ast.FuncDecl)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readNote" data-name="readNote">
               <h3>
                  readNote 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readNote" class="anchor" title="Link to readNote">#</a>
               </h3>
               
               <p>readNote collects a single note from a sequence of comments.</p>
               
               <pre><code class="language-go">func (r *reader) readNote(list []*ast.Comment)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readNotes" data-name="readNotes">
               <h3>
                  readNotes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readNotes" class="anchor" title="Link to readNotes">#</a>
               </h3>
               
               <p>readNotes extracts notes from comments.
A note must start at the beginning of a comment with "MARKER(uid):"
and is followed by the note body (e.g., "// BUG(gri): fix this").
The note ends at the end of the comment group or at the start of
another note in the same comment group, whichever comes first.</p>
               
               <pre><code class="language-go">func (r *reader) readNotes(comments []*ast.CommentGroup)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readPackage" data-name="readPackage">
               <h3>
                  readPackage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readPackage" class="anchor" title="Link to readPackage">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *reader) readPackage(pkg *ast.Package, mode Mode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readType" data-name="readType">
               <h3>
                  readType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readType" class="anchor" title="Link to readType">#</a>
               </h3>
               
               <p>readType processes a type declaration.</p>
               
               <pre><code class="language-go">func (r *reader) readType(decl *ast.GenDecl, spec *ast.TypeSpec)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readValue" data-name="readValue">
               <h3>
                  readValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readValue" class="anchor" title="Link to readValue">#</a>
               </h3>
               
               <p>readValue processes a const or var declaration.</p>
               
               <pre><code class="language-go">func (r *reader) readValue(decl *ast.GenDecl)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordAnonymousField" data-name="recordAnonymousField">
               <h3>
                  recordAnonymousField 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordAnonymousField" class="anchor" title="Link to recordAnonymousField">#</a>
               </h3>
               
               <p>recordAnonymousField registers fieldType as the type of an
anonymous field in the parent type. If the field is imported
(qualified name) or the parent is nil, the field is ignored.
The function returns the field name.</p>
               
               <pre><code class="language-go">func (r *reader) recordAnonymousField(parent *namedType, fieldType ast.Expr) (fname string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recvParam" data-name="recvParam">
               <h3>
                  recvParam 
                  <span class="badge">function</span>
                  
                  <a href="#recvParam" class="anchor" title="Link to recvParam">#</a>
               </h3>
               
               <pre><code class="language-go">func recvParam(p ast.Expr) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recvString" data-name="recvString">
               <h3>
                  recvString 
                  <span class="badge">function</span>
                  
                  <a href="#recvString" class="anchor" title="Link to recvString">#</a>
               </h3>
               
               <p>recvString returns a string representation of recv of the form "T", "*T",
"T[A, ...]", "*T[A, ...]" or "BADRECV" (if not a proper receiver type).</p>
               
               <pre><code class="language-go">func recvString(recv ast.Expr) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="remember" data-name="remember">
               <h3>
                  remember 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#remember" class="anchor" title="Link to remember">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *reader) remember(predecl string, typ *ast.InterfaceType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeAnonymousField" data-name="removeAnonymousField">
               <h3>
                  removeAnonymousField 
                  <span class="badge">function</span>
                  
                  <a href="#removeAnonymousField" class="anchor" title="Link to removeAnonymousField">#</a>
               </h3>
               
               <p>removeAnonymousField removes anonymous fields named name from an interface.</p>
               
               <pre><code class="language-go">func removeAnonymousField(name string, ityp *ast.InterfaceType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeStar" data-name="removeStar">
               <h3>
                  removeStar 
                  <span class="badge">function</span>
                  
                  <a href="#removeStar" class="anchor" title="Link to removeStar">#</a>
               </h3>
               
               <pre><code class="language-go">func removeStar(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="set" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#set" class="anchor" title="Link to set">#</a>
               </h3>
               
               <p>set creates the corresponding Func for f and adds it to mset.
If there are multiple f's with the same name, set keeps the first
one with documentation; conflicts are ignored. The boolean
specifies whether to leave the AST untouched.</p>
               
               <pre><code class="language-go">func (mset methodSet) set(f *ast.FuncDecl, preserveAST bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="simpleImporter" data-name="simpleImporter">
               <h3>
                  simpleImporter 
                  <span class="badge">function</span>
                  
                  <a href="#simpleImporter" class="anchor" title="Link to simpleImporter">#</a>
               </h3>
               
               <p>simpleImporter returns a (dummy) package object named by the last path
component of the provided package path (as is the convention for packages).
This is sufficient to resolve package identifiers without doing an actual
import. It never returns an error.</p>
               
               <pre><code class="language-go">func simpleImporter(imports map[string]*ast.Object, path string) (*ast.Object, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sortedFuncs" data-name="sortedFuncs">
               <h3>
                  sortedFuncs 
                  <span class="badge">function</span>
                  
                  <a href="#sortedFuncs" class="anchor" title="Link to sortedFuncs">#</a>
               </h3>
               
               <pre><code class="language-go">func sortedFuncs(m methodSet, allMethods bool) []*Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sortedKeys" data-name="sortedKeys">
               <h3>
                  sortedKeys 
                  <span class="badge">function</span>
                  
                  <a href="#sortedKeys" class="anchor" title="Link to sortedKeys">#</a>
               </h3>
               
               <pre><code class="language-go">func sortedKeys(m map[string]int) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sortedTypes" data-name="sortedTypes">
               <h3>
                  sortedTypes 
                  <span class="badge">function</span>
                  
                  <a href="#sortedTypes" class="anchor" title="Link to sortedTypes">#</a>
               </h3>
               
               <pre><code class="language-go">func sortedTypes(m map[string]*namedType, allMethods bool) []*Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sortedValues" data-name="sortedValues">
               <h3>
                  sortedValues 
                  <span class="badge">function</span>
                  
                  <a href="#sortedValues" class="anchor" title="Link to sortedValues">#</a>
               </h3>
               
               <pre><code class="language-go">func sortedValues(m []*Value, tok token.Token) []*Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sortingName" data-name="sortingName">
               <h3>
                  sortingName 
                  <span class="badge">function</span>
                  
                  <a href="#sortingName" class="anchor" title="Link to sortingName">#</a>
               </h3>
               
               <p>sortingName returns the name to use when sorting d into place.</p>
               
               <pre><code class="language-go">func sortingName(d *ast.GenDecl) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="specNames" data-name="specNames">
               <h3>
                  specNames 
                  <span class="badge">function</span>
                  
                  <a href="#specNames" class="anchor" title="Link to specNames">#</a>
               </h3>
               
               <pre><code class="language-go">func specNames(specs []ast.Spec) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitExampleName" data-name="splitExampleName">
               <h3>
                  splitExampleName 
                  <span class="badge">function</span>
                  
                  <a href="#splitExampleName" class="anchor" title="Link to splitExampleName">#</a>
               </h3>
               
               <p>splitExampleName attempts to split example name s at index i,
and reports if that produces a valid split. The suffix may be
absent. Otherwise, it must start with a lower-case letter and
be preceded by '_'.
One of i == len(s) or s[i] == '_' must be true.</p>
               
               <pre><code class="language-go">func splitExampleName(s string, i int) (prefix string, suffix string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stripOutputComment" data-name="stripOutputComment">
               <h3>
                  stripOutputComment 
                  <span class="badge">function</span>
                  
                  <a href="#stripOutputComment" class="anchor" title="Link to stripOutputComment">#</a>
               </h3>
               
               <p>stripOutputComment finds and removes the "Output:" or "Unordered output:"
comment from body and comments, and adjusts the body block's end position.</p>
               
               <pre><code class="language-go">func stripOutputComment(body *ast.BlockStmt, comments []*ast.CommentGroup) (*ast.BlockStmt, []*ast.CommentGroup)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateIdentList" data-name="updateIdentList">
               <h3>
                  updateIdentList 
                  <span class="badge">function</span>
                  
                  <a href="#updateIdentList" class="anchor" title="Link to updateIdentList">#</a>
               </h3>
               
               <p>updateIdentList replaces all unexported identifiers with underscore
and reports whether at least one exported name exists.</p>
               
               <pre><code class="language-go">func updateIdentList(list []*ast.Ident) (hasExported bool)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>