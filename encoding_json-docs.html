<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - json</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>json</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"strconv"
"sync"
"bytes"
"errors"
"io"
"unicode/utf8"
"strings"
"encoding"
"encoding/base64"
"fmt"
"reflect"
"strconv"
"strings"
"unicode"
"unicode/utf16"
"unicode/utf8"
_ "unsafe"
"bytes"
"cmp"
"encoding"
"encoding/base64"
"fmt"
"math"
"reflect"
"slices"
"strconv"
"strings"
"sync"
"unicode"
"unicode/utf8"
_ "unsafe"
"unicode"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ Unmarshaler = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ Marshaler = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="encodeStatePool">
               <h3>
                  encodeStatePool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var encodeStatePool sync.Pool</code></pre>
            </article>
            
            <article class="global" data-name="encoderCache">
               <h3>
                  encoderCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var encoderCache sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="fieldCache">
               <h3>
                  fieldCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var fieldCache sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="float32Encoder">
               <h3>
                  float32Encoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var float32Encoder = *ast.ParenExpr.encode</code></pre>
            </article>
            
            <article class="global" data-name="float64Encoder">
               <h3>
                  float64Encoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var float64Encoder = *ast.ParenExpr.encode</code></pre>
            </article>
            
            <article class="global" data-name="hex">
               <h3>
                  hex 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hex = "0123456789abcdef"</code></pre>
            </article>
            
            <article class="global" data-name="htmlSafeSet">
               <h3>
                  htmlSafeSet 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>htmlSafeSet holds the value true if the ASCII character with the given
array position can be safely represented inside a JSON string, embedded
inside of HTML <script> tags, without any additional escaping.
All values are true except for the ASCII control characters (0-31), the
double quote ("), the backslash character ("\"), HTML opening and closing
tags ("<" and ">"), and the ampersand ("&").</p>
               
               <pre><code>var htmlSafeSet = [utf8.RuneSelf]bool{...}</code></pre>
            </article>
            
            <article class="global" data-name="indentGrowthFactor">
               <h3>
                  indentGrowthFactor 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>indentGrowthFactor specifies the growth factor of indenting JSON input.
Empirically, the growth factor was measured to be between 1.4x to 1.8x
for some set of compacted JSON with the indent being a single tab.
Specify a growth factor slightly larger than what is observed
to reduce probability of allocation in appendIndent.
A factor no higher than 2 ensures that wasted space never exceeds 50%.</p>
               
               <pre><code>const indentGrowthFactor = 2</code></pre>
            </article>
            
            <article class="global" data-name="isZeroerType">
               <h3>
                  isZeroerType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var isZeroerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="marshalerType">
               <h3>
                  marshalerType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var marshalerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxNestingDepth">
               <h3>
                  maxNestingDepth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>This limits the max nesting depth to prevent stack overflow.
This is permitted by https://tools.ietf.org/html/rfc7159#section-9</p>
               
               <pre><code>const maxNestingDepth = 10000</code></pre>
            </article>
            
            <article class="global" data-name="nullLiteral">
               <h3>
                  nullLiteral 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nullLiteral = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="numberType">
               <h3>
                  numberType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var numberType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="parseArrayValue">
               <h3>
                  parseArrayValue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are stored in the parseState stack.
They give the current state of a composite value
being scanned. If the parser is inside a nested value
the parseState describes the nested state, outermost at entry 0.</p>
               
               <pre><code>const parseArrayValue</code></pre>
            </article>
            
            <article class="global" data-name="parseObjectKey">
               <h3>
                  parseObjectKey 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are stored in the parseState stack.
They give the current state of a composite value
being scanned. If the parser is inside a nested value
the parseState describes the nested state, outermost at entry 0.</p>
               
               <pre><code>const parseObjectKey = iota</code></pre>
            </article>
            
            <article class="global" data-name="parseObjectValue">
               <h3>
                  parseObjectValue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are stored in the parseState stack.
They give the current state of a composite value
being scanned. If the parser is inside a nested value
the parseState describes the nested state, outermost at entry 0.</p>
               
               <pre><code>const parseObjectValue</code></pre>
            </article>
            
            <article class="global" data-name="phasePanicMsg">
               <h3>
                  phasePanicMsg 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>phasePanicMsg is used as a panic message when we end up with something that
shouldn't happen. It can indicate a bug in the JSON decoder, or that
something is editing the data slice while the decoder executes.</p>
               
               <pre><code>const phasePanicMsg = "JSON decoder out of sync - data changing underfoot?"</code></pre>
            </article>
            
            <article class="global" data-name="safeSet">
               <h3>
                  safeSet 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>safeSet holds the value true if the ASCII character with the given array
position can be represented inside a JSON string without any further
escaping.
All values are true except for the ASCII control characters (0-31), the
double quote ("), and the backslash character ("\").</p>
               
               <pre><code>var safeSet = [utf8.RuneSelf]bool{...}</code></pre>
            </article>
            
            <article class="global" data-name="scanArrayValue">
               <h3>
                  scanArrayValue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are returned by the state transition functions
assigned to scanner.state and the method scanner.eof.
They give details about the current state of the scan that
callers might be interested to know about.
It is okay to ignore the return value of any particular
call to scanner.state: if one call returns scanError,
every subsequent call will return scanError too.</p>
               
               <pre><code>const scanArrayValue</code></pre>
            </article>
            
            <article class="global" data-name="scanBeginArray">
               <h3>
                  scanBeginArray 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are returned by the state transition functions
assigned to scanner.state and the method scanner.eof.
They give details about the current state of the scan that
callers might be interested to know about.
It is okay to ignore the return value of any particular
call to scanner.state: if one call returns scanError,
every subsequent call will return scanError too.</p>
               
               <pre><code>const scanBeginArray</code></pre>
            </article>
            
            <article class="global" data-name="scanBeginLiteral">
               <h3>
                  scanBeginLiteral 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are returned by the state transition functions
assigned to scanner.state and the method scanner.eof.
They give details about the current state of the scan that
callers might be interested to know about.
It is okay to ignore the return value of any particular
call to scanner.state: if one call returns scanError,
every subsequent call will return scanError too.</p>
               
               <pre><code>const scanBeginLiteral</code></pre>
            </article>
            
            <article class="global" data-name="scanBeginObject">
               <h3>
                  scanBeginObject 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are returned by the state transition functions
assigned to scanner.state and the method scanner.eof.
They give details about the current state of the scan that
callers might be interested to know about.
It is okay to ignore the return value of any particular
call to scanner.state: if one call returns scanError,
every subsequent call will return scanError too.</p>
               
               <pre><code>const scanBeginObject</code></pre>
            </article>
            
            <article class="global" data-name="scanContinue">
               <h3>
                  scanContinue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Continue.</p>
               
               <pre><code>const scanContinue = iota</code></pre>
            </article>
            
            <article class="global" data-name="scanEnd">
               <h3>
                  scanEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Stop.</p>
               
               <pre><code>const scanEnd</code></pre>
            </article>
            
            <article class="global" data-name="scanEndArray">
               <h3>
                  scanEndArray 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are returned by the state transition functions
assigned to scanner.state and the method scanner.eof.
They give details about the current state of the scan that
callers might be interested to know about.
It is okay to ignore the return value of any particular
call to scanner.state: if one call returns scanError,
every subsequent call will return scanError too.</p>
               
               <pre><code>const scanEndArray</code></pre>
            </article>
            
            <article class="global" data-name="scanEndObject">
               <h3>
                  scanEndObject 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are returned by the state transition functions
assigned to scanner.state and the method scanner.eof.
They give details about the current state of the scan that
callers might be interested to know about.
It is okay to ignore the return value of any particular
call to scanner.state: if one call returns scanError,
every subsequent call will return scanError too.</p>
               
               <pre><code>const scanEndObject</code></pre>
            </article>
            
            <article class="global" data-name="scanError">
               <h3>
                  scanError 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are returned by the state transition functions
assigned to scanner.state and the method scanner.eof.
They give details about the current state of the scan that
callers might be interested to know about.
It is okay to ignore the return value of any particular
call to scanner.state: if one call returns scanError,
every subsequent call will return scanError too.</p>
               
               <pre><code>const scanError</code></pre>
            </article>
            
            <article class="global" data-name="scanObjectKey">
               <h3>
                  scanObjectKey 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are returned by the state transition functions
assigned to scanner.state and the method scanner.eof.
They give details about the current state of the scan that
callers might be interested to know about.
It is okay to ignore the return value of any particular
call to scanner.state: if one call returns scanError,
every subsequent call will return scanError too.</p>
               
               <pre><code>const scanObjectKey</code></pre>
            </article>
            
            <article class="global" data-name="scanObjectValue">
               <h3>
                  scanObjectValue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are returned by the state transition functions
assigned to scanner.state and the method scanner.eof.
They give details about the current state of the scan that
callers might be interested to know about.
It is okay to ignore the return value of any particular
call to scanner.state: if one call returns scanError,
every subsequent call will return scanError too.</p>
               
               <pre><code>const scanObjectValue</code></pre>
            </article>
            
            <article class="global" data-name="scanSkipSpace">
               <h3>
                  scanSkipSpace 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These values are returned by the state transition functions
assigned to scanner.state and the method scanner.eof.
They give details about the current state of the scan that
callers might be interested to know about.
It is okay to ignore the return value of any particular
call to scanner.state: if one call returns scanError,
every subsequent call will return scanError too.</p>
               
               <pre><code>const scanSkipSpace</code></pre>
            </article>
            
            <article class="global" data-name="scannerPool">
               <h3>
                  scannerPool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var scannerPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global" data-name="startDetectingCyclesAfter">
               <h3>
                  startDetectingCyclesAfter 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const startDetectingCyclesAfter = 1000</code></pre>
            </article>
            
            <article class="global" data-name="textMarshalerType">
               <h3>
                  textMarshalerType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var textMarshalerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="textUnmarshalerType">
               <h3>
                  textUnmarshalerType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var textUnmarshalerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="tokenArrayComma">
               <h3>
                  tokenArrayComma 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tokenArrayComma</code></pre>
            </article>
            
            <article class="global" data-name="tokenArrayStart">
               <h3>
                  tokenArrayStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tokenArrayStart</code></pre>
            </article>
            
            <article class="global" data-name="tokenArrayValue">
               <h3>
                  tokenArrayValue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tokenArrayValue</code></pre>
            </article>
            
            <article class="global" data-name="tokenObjectColon">
               <h3>
                  tokenObjectColon 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tokenObjectColon</code></pre>
            </article>
            
            <article class="global" data-name="tokenObjectComma">
               <h3>
                  tokenObjectComma 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tokenObjectComma</code></pre>
            </article>
            
            <article class="global" data-name="tokenObjectKey">
               <h3>
                  tokenObjectKey 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tokenObjectKey</code></pre>
            </article>
            
            <article class="global" data-name="tokenObjectStart">
               <h3>
                  tokenObjectStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tokenObjectStart</code></pre>
            </article>
            
            <article class="global" data-name="tokenObjectValue">
               <h3>
                  tokenObjectValue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tokenObjectValue</code></pre>
            </article>
            
            <article class="global" data-name="tokenTopValue">
               <h3>
                  tokenTopValue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const tokenTopValue = iota</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Delim">
               <h3>
                  Delim
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Delim is a JSON array or object delimiter, one of [ ] { or }.</p>
               
               <pre><code>type Delim rune</code></pre>
            </article>
            
            <article class="type" data-name="Number">
               <h3>
                  Number
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Number represents a JSON number literal.</p>
               
               <pre><code>type Number string</code></pre>
            </article>
            
            <article class="type" data-name="RawMessage">
               <h3>
                  RawMessage
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>RawMessage is a raw encoded JSON value.
It implements [Marshaler] and [Unmarshaler] and can
be used to delay JSON decoding or precompute a JSON encoding.</p>
               
               <pre><code>type RawMessage []byte</code></pre>
            </article>
            
            <article class="type" data-name="Token">
               <h3>
                  Token
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Token holds a value of one of these types:
- [Delim], for the four JSON delimiters [ ] { }
- bool, for JSON booleans
- float64, for JSON numbers
- [Number], for JSON numbers
- string, for JSON string literals
- nil, for JSON null</p>
               
               <pre><code>type Token any</code></pre>
            </article>
            
            <article class="type" data-name="encoderFunc">
               <h3>
                  encoderFunc
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type encoderFunc func(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="type" data-name="floatEncoder">
               <h3>
                  floatEncoder
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type floatEncoder int</code></pre>
            </article>
            
            <article class="type" data-name="tagOptions">
               <h3>
                  tagOptions
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>tagOptions is the string following a comma in a struct field's "json"
tag, or the empty string. It does not include the leading comma.</p>
               
               <pre><code>type tagOptions string</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Marshaler">
               <h3>
                  Marshaler
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Marshaler is the interface implemented by types that
can marshal themselves into valid JSON.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Marshaler interface {
MarshalJSON() ([]byte, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Unmarshaler">
               <h3>
                  Unmarshaler
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Unmarshaler is the interface implemented by types
that can unmarshal a JSON description of themselves.
The input can be assumed to be a valid encoding of
a JSON value. UnmarshalJSON must copy the JSON data
if it wishes to retain the data after returning.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Unmarshaler interface {
UnmarshalJSON([]byte) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="isZeroer">
               <h3>
                  isZeroer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type isZeroer interface {
IsZero() bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Decoder">
               <h3>
                  Decoder
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Decoder reads and decodes JSON values from an input stream.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Decoder struct {
r io.Reader
buf []byte
d decodeState
scanp int
scanned int64
scan scanner
err error
tokenState int
tokenStack []int
}</code></pre>
            </article>
            
            <article class="struct" data-name="Encoder">
               <h3>
                  Encoder
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Encoder writes JSON values to an output stream.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Encoder struct {
w io.Writer
err error
escapeHTML bool
indentBuf []byte
indentPrefix string
indentValue string
}</code></pre>
            </article>
            
            <article class="struct" data-name="InvalidUTF8Error">
               <h3>
                  InvalidUTF8Error
                  <span class="badge">struct</span>
               </h3>
               
               <p>Before Go 1.2, an InvalidUTF8Error was returned by [Marshal] when
attempting to encode a string value with invalid UTF-8 sequences.
As of Go 1.2, [Marshal] instead coerces the string to valid UTF-8 by
replacing invalid bytes with the Unicode replacement rune U+FFFD.
Deprecated: No longer used; kept for compatibility.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InvalidUTF8Error struct {
S string
}</code></pre>
            </article>
            
            <article class="struct" data-name="InvalidUnmarshalError">
               <h3>
                  InvalidUnmarshalError
                  <span class="badge">struct</span>
               </h3>
               
               <p>An InvalidUnmarshalError describes an invalid argument passed to [Unmarshal].
(The argument to [Unmarshal] must be a non-nil pointer.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InvalidUnmarshalError struct {
Type reflect.Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="MarshalerError">
               <h3>
                  MarshalerError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A MarshalerError represents an error from calling a
[Marshaler.MarshalJSON] or [encoding.TextMarshaler.MarshalText] method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MarshalerError struct {
Type reflect.Type
Err error
sourceFunc string
}</code></pre>
            </article>
            
            <article class="struct" data-name="SyntaxError">
               <h3>
                  SyntaxError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A SyntaxError is a description of a JSON syntax error.
[Unmarshal] will return a SyntaxError if the JSON can't be parsed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SyntaxError struct {
msg string
Offset int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="UnmarshalFieldError">
               <h3>
                  UnmarshalFieldError
                  <span class="badge">struct</span>
               </h3>
               
               <p>An UnmarshalFieldError describes a JSON object key that
led to an unexported (and therefore unwritable) struct field.
Deprecated: No longer used; kept for compatibility.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UnmarshalFieldError struct {
Key string
Type reflect.Type
Field reflect.StructField
}</code></pre>
            </article>
            
            <article class="struct" data-name="UnmarshalTypeError">
               <h3>
                  UnmarshalTypeError
                  <span class="badge">struct</span>
               </h3>
               
               <p>An UnmarshalTypeError describes a JSON value that was
not appropriate for a value of a specific Go type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UnmarshalTypeError struct {
Value string
Type reflect.Type
Offset int64
Struct string
Field string
}</code></pre>
            </article>
            
            <article class="struct" data-name="UnsupportedTypeError">
               <h3>
                  UnsupportedTypeError
                  <span class="badge">struct</span>
               </h3>
               
               <p>An UnsupportedTypeError is returned by [Marshal] when attempting
to encode an unsupported value type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UnsupportedTypeError struct {
Type reflect.Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="UnsupportedValueError">
               <h3>
                  UnsupportedValueError
                  <span class="badge">struct</span>
               </h3>
               
               <p>An UnsupportedValueError is returned by [Marshal] when attempting
to encode an unsupported value.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UnsupportedValueError struct {
Value reflect.Value
Str string
}</code></pre>
            </article>
            
            <article class="struct" data-name="arrayEncoder">
               <h3>
                  arrayEncoder
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type arrayEncoder struct {
elemEnc encoderFunc
}</code></pre>
            </article>
            
            <article class="struct" data-name="condAddrEncoder">
               <h3>
                  condAddrEncoder
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type condAddrEncoder struct {
canAddrEnc encoderFunc
elseEnc encoderFunc
}</code></pre>
            </article>
            
            <article class="struct" data-name="decodeState">
               <h3>
                  decodeState
                  <span class="badge">struct</span>
               </h3>
               
               <p>decodeState represents the state while decoding a JSON value.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type decodeState struct {
data []byte
off int
opcode int
scan scanner
errorContext *errorContext
savedError error
useNumber bool
disallowUnknownFields bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="encOpts">
               <h3>
                  encOpts
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type encOpts struct {
quoted bool
escapeHTML bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="encodeState">
               <h3>
                  encodeState
                  <span class="badge">struct</span>
               </h3>
               
               <p>An encodeState encodes JSON into a bytes.Buffer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type encodeState struct {
bytes.Buffer
ptrLevel uint
ptrSeen map[any]struct{...}
}</code></pre>
            </article>
            
            <article class="struct" data-name="errorContext">
               <h3>
                  errorContext
                  <span class="badge">struct</span>
               </h3>
               
               <p>An errorContext provides context for type errors during decoding.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type errorContext struct {
Struct reflect.Type
FieldStack []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="field">
               <h3>
                  field
                  <span class="badge">struct</span>
               </h3>
               
               <p>A field represents a single field found in a struct.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type field struct {
name string
nameBytes []byte
nameNonEsc string
nameEscHTML string
tag bool
index []int
typ reflect.Type
omitEmpty bool
omitZero bool
isZero func(reflect.Value) bool
quoted bool
encoder encoderFunc
}</code></pre>
            </article>
            
            <article class="struct" data-name="jsonError">
               <h3>
                  jsonError
                  <span class="badge">struct</span>
               </h3>
               
               <p>jsonError is an error wrapper type for internal use only.
Panics with errors are wrapped in jsonError so that the top-level recover
can distinguish intentional panics from this package.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type jsonError struct {
error
}</code></pre>
            </article>
            
            <article class="struct" data-name="mapEncoder">
               <h3>
                  mapEncoder
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mapEncoder struct {
elemEnc encoderFunc
}</code></pre>
            </article>
            
            <article class="struct" data-name="ptrEncoder">
               <h3>
                  ptrEncoder
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ptrEncoder struct {
elemEnc encoderFunc
}</code></pre>
            </article>
            
            <article class="struct" data-name="reflectWithString">
               <h3>
                  reflectWithString
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type reflectWithString struct {
v reflect.Value
ks string
}</code></pre>
            </article>
            
            <article class="struct" data-name="scanner">
               <h3>
                  scanner
                  <span class="badge">struct</span>
               </h3>
               
               <p>A scanner is a JSON scanning state machine.
Callers call scan.reset and then pass bytes in one at a time
by calling scan.step(&scan, c) for each byte.
The return value, referred to as an opcode, tells the
caller about significant parsing events like beginning
and ending literals, objects, and arrays, so that the
caller can follow along if it wishes.
The return value scanEnd indicates that a single top-level
JSON value has been completed, *before* the byte that
just got passed in.  (The indication must be delayed in order
to recognize the end of numbers: is 123 a whole value or
the beginning of 12345e+6?).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type scanner struct {
step func(*scanner, byte) int
endTop bool
parseState []int
err error
bytes int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="sliceEncoder">
               <h3>
                  sliceEncoder
                  <span class="badge">struct</span>
               </h3>
               
               <p>sliceEncoder just wraps an arrayEncoder, checking to make sure the value isn't nil.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sliceEncoder struct {
arrayEnc encoderFunc
}</code></pre>
            </article>
            
            <article class="struct" data-name="structEncoder">
               <h3>
                  structEncoder
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type structEncoder struct {
fields structFields
}</code></pre>
            </article>
            
            <article class="struct" data-name="structFields">
               <h3>
                  structFields
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type structFields struct {
list []field
byExactName map[string]*field
byFoldedName map[string]*field
}</code></pre>
            </article>
            
            <article class="struct" data-name="unquotedValue">
               <h3>
                  unquotedValue
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type unquotedValue struct {

}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Buffered">
               <h3>
                  Buffered 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Buffered returns a reader of the data remaining in the Decoder's
buffer. The reader is valid until the next call to [Decoder.Decode].</p>
               
               <pre><code>func (dec *Decoder) Buffered() io.Reader</code></pre>
            </article>
            
            <article class="function" data-name="Compact">
               <h3>
                  Compact 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Compact appends to dst the JSON-encoded src with
insignificant space characters elided.</p>
               
               <pre><code>func Compact(dst *bytes.Buffer, src []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="Contains">
               <h3>
                  Contains 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Contains reports whether a comma-separated list of options
contains a particular substr flag. substr must be surrounded by a
string boundary or commas.</p>
               
               <pre><code>func (o tagOptions) Contains(optionName string) bool</code></pre>
            </article>
            
            <article class="function" data-name="Decode">
               <h3>
                  Decode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Decode reads the next JSON-encoded value from its
input and stores it in the value pointed to by v.
See the documentation for [Unmarshal] for details about
the conversion of JSON into a Go value.</p>
               
               <pre><code>func (dec *Decoder) Decode(v any) error</code></pre>
            </article>
            
            <article class="function" data-name="DisallowUnknownFields">
               <h3>
                  DisallowUnknownFields 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DisallowUnknownFields causes the Decoder to return an error when the destination
is a struct and the input contains object keys which do not match any
non-ignored, exported fields in the destination.</p>
               
               <pre><code>func (dec *Decoder) DisallowUnknownFields()</code></pre>
            </article>
            
            <article class="function" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Encode writes the JSON encoding of v to the stream,
with insignificant space characters elided,
followed by a newline character.
See the documentation for [Marshal] for details about the
conversion of Go values to JSON.</p>
               
               <pre><code>func (enc *Encoder) Encode(v any) error</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *InvalidUnmarshalError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *UnsupportedTypeError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *SyntaxError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *MarshalerError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *UnmarshalTypeError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *InvalidUTF8Error) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *UnmarshalFieldError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *UnsupportedValueError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Float64">
               <h3>
                  Float64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Float64 returns the number as a float64.</p>
               
               <pre><code>func (n Number) Float64() (float64, error)</code></pre>
            </article>
            
            <article class="function" data-name="HTMLEscape">
               <h3>
                  HTMLEscape 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029
characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029
so that the JSON will be safe to embed inside HTML <script> tags.
For historical reasons, web browsers don't honor standard HTML
escaping within <script> tags, so an alternative JSON encoding must be used.</p>
               
               <pre><code>func HTMLEscape(dst *bytes.Buffer, src []byte)</code></pre>
            </article>
            
            <article class="function" data-name="Indent">
               <h3>
                  Indent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Indent appends to dst an indented form of the JSON-encoded src.
Each element in a JSON object or array begins on a new,
indented line beginning with prefix followed by one or more
copies of indent according to the indentation nesting.
The data appended to dst does not begin with the prefix nor
any indentation, to make it easier to embed inside other formatted JSON data.
Although leading space characters (space, tab, carriage return, newline)
at the beginning of src are dropped, trailing space characters
at the end of src are preserved and copied to dst.
For example, if src has no trailing spaces, neither will dst;
if src ends in a trailing newline, so will dst.</p>
               
               <pre><code>func Indent(dst *bytes.Buffer, src []byte, prefix string, indent string) error</code></pre>
            </article>
            
            <article class="function" data-name="InputOffset">
               <h3>
                  InputOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>InputOffset returns the input stream byte offset of the current decoder position.
The offset gives the location of the end of the most recently returned token
and the beginning of the next token.</p>
               
               <pre><code>func (dec *Decoder) InputOffset() int64</code></pre>
            </article>
            
            <article class="function" data-name="Int64">
               <h3>
                  Int64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Int64 returns the number as an int64.</p>
               
               <pre><code>func (n Number) Int64() (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="Marshal">
               <h3>
                  Marshal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Marshal returns the JSON encoding of v.
Marshal traverses the value v recursively.
If an encountered value implements [Marshaler]
and is not a nil pointer, Marshal calls [Marshaler.MarshalJSON]
to produce JSON. If no [Marshaler.MarshalJSON] method is present but the
value implements [encoding.TextMarshaler] instead, Marshal calls
[encoding.TextMarshaler.MarshalText] and encodes the result as a JSON string.
The nil pointer exception is not strictly necessary
but mimics a similar, necessary exception in the behavior of
[Unmarshaler.UnmarshalJSON].
Otherwise, Marshal uses the following type-dependent default encodings:
Boolean values encode as JSON booleans.
Floating point, integer, and [Number] values encode as JSON numbers.
NaN and +/-Inf values will return an [UnsupportedValueError].
String values encode as JSON strings coerced to valid UTF-8,
replacing invalid bytes with the Unicode replacement rune.
So that the JSON will be safe to embed inside HTML <script> tags,
the string is encoded using [HTMLEscape],
which replaces "<", ">", "&", U+2028, and U+2029 are escaped
to "\u003c","\u003e", "\u0026", "\u2028", and "\u2029".
This replacement can be disabled when using an [Encoder],
by calling [Encoder.SetEscapeHTML](false).
Array and slice values encode as JSON arrays, except that
[]byte encodes as a base64-encoded string, and a nil slice
encodes as the null JSON value.
Struct values encode as JSON objects.
Each exported struct field becomes a member of the object, using the
field name as the object key, unless the field is omitted for one of the
reasons given below.
The encoding of each struct field can be customized by the format string
stored under the "json" key in the struct field's tag.
The format string gives the name of the field, possibly followed by a
comma-separated list of options. The name may be empty in order to
specify options without overriding the default field name.
The "omitempty" option specifies that the field should be omitted
from the encoding if the field has an empty value, defined as
false, 0, a nil pointer, a nil interface value, and any array,
slice, map, or string of length zero.
As a special case, if the field tag is "-", the field is always omitted.
Note that a field with name "-" can still be generated using the tag "-,".
Examples of struct field tags and their meanings:
// Field appears in JSON as key "myName".
Field int `json:"myName"`
// Field appears in JSON as key "myName" and
// the field is omitted from the object if its value is empty,
// as defined above.
Field int `json:"myName,omitempty"`
// Field appears in JSON as key "Field" (the default), but
// the field is skipped if empty.
// Note the leading comma.
Field int `json:",omitempty"`
// Field is ignored by this package.
Field int `json:"-"`
// Field appears in JSON as key "-".
Field int `json:"-,"`
The "omitzero" option specifies that the field should be omitted
from the encoding if the field has a zero value, according to rules:
1) If the field type has an "IsZero() bool" method, that will be used to
determine whether the value is zero.
2) Otherwise, the value is zero if it is the zero value for its type.
If both "omitempty" and "omitzero" are specified, the field will be omitted
if the value is either empty or zero (or both).
The "string" option signals that a field is stored as JSON inside a
JSON-encoded string. It applies only to fields of string, floating point,
integer, or boolean types. This extra level of encoding is sometimes used
when communicating with JavaScript programs:
Int64String int64 `json:",string"`
The key name will be used if it's a non-empty string consisting of
only Unicode letters, digits, and ASCII punctuation except quotation
marks, backslash, and comma.
Embedded struct fields are usually marshaled as if their inner exported fields
were fields in the outer struct, subject to the usual Go visibility rules amended
as described in the next paragraph.
An anonymous struct field with a name given in its JSON tag is treated as
having that name, rather than being anonymous.
An anonymous struct field of interface type is treated the same as having
that type as its name, rather than being anonymous.
The Go visibility rules for struct fields are amended for JSON when
deciding which field to marshal or unmarshal. If there are
multiple fields at the same level, and that level is the least
nested (and would therefore be the nesting level selected by the
usual Go rules), the following extra rules apply:
1) Of those fields, if any are JSON-tagged, only tagged fields are considered,
even if there are multiple untagged fields that would otherwise conflict.
2) If there is exactly one field (tagged or not according to the first rule), that is selected.
3) Otherwise there are multiple fields, and all are ignored; no error occurs.
Handling of anonymous struct fields is new in Go 1.1.
Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of
an anonymous struct field in both current and earlier versions, give the field
a JSON tag of "-".
Map values encode as JSON objects. The map's key type must either be a
string, an integer type, or implement [encoding.TextMarshaler]. The map keys
are sorted and used as JSON object keys by applying the following rules,
subject to the UTF-8 coercion described for string values above:
- keys of any string type are used directly
- keys that implement [encoding.TextMarshaler] are marshaled
- integer keys are converted to strings
Pointer values encode as the value pointed to.
A nil pointer encodes as the null JSON value.
Interface values encode as the value contained in the interface.
A nil interface value encodes as the null JSON value.
Channel, complex, and function values cannot be encoded in JSON.
Attempting to encode such a value causes Marshal to return
an [UnsupportedTypeError].
JSON cannot represent cyclic data structures and Marshal does not
handle them. Passing cyclic structures to Marshal will result in
an error.</p>
               
               <pre><code>func Marshal(v any) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalIndent">
               <h3>
                  MarshalIndent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MarshalIndent is like [Marshal] but applies [Indent] to format the output.
Each JSON element in the output will begin on a new line beginning with prefix
followed by one or more copies of indent according to the indentation nesting.</p>
               
               <pre><code>func MarshalIndent(v any, prefix string, indent string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalJSON">
               <h3>
                  MarshalJSON 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalJSON returns m as the JSON encoding of m.</p>
               
               <pre><code>func (m RawMessage) MarshalJSON() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="More">
               <h3>
                  More 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>More reports whether there is another element in the
current array or object being parsed.</p>
               
               <pre><code>func (dec *Decoder) More() bool</code></pre>
            </article>
            
            <article class="function" data-name="NewDecoder">
               <h3>
                  NewDecoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewDecoder returns a new decoder that reads from r.
The decoder introduces its own buffering and may
read data from r beyond the JSON values requested.</p>
               
               <pre><code>func NewDecoder(r io.Reader) *Decoder</code></pre>
            </article>
            
            <article class="function" data-name="NewEncoder">
               <h3>
                  NewEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewEncoder returns a new encoder that writes to w.</p>
               
               <pre><code>func NewEncoder(w io.Writer) *Encoder</code></pre>
            </article>
            
            <article class="function" data-name="SetEscapeHTML">
               <h3>
                  SetEscapeHTML 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetEscapeHTML specifies whether problematic HTML characters
should be escaped inside JSON quoted strings.
The default behavior is to escape &, <, and > to \u0026, \u003c, and \u003e
to avoid certain safety problems that can arise when embedding JSON in HTML.
In non-HTML settings where the escaping interferes with the readability
of the output, SetEscapeHTML(false) disables this behavior.</p>
               
               <pre><code>func (enc *Encoder) SetEscapeHTML(on bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetIndent">
               <h3>
                  SetIndent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetIndent instructs the encoder to format each subsequent encoded
value as if indented by the package-level function Indent(dst, src, prefix, indent).
Calling SetIndent("", "") disables indentation.</p>
               
               <pre><code>func (enc *Encoder) SetIndent(prefix string, indent string)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the literal text of the number.</p>
               
               <pre><code>func (n Number) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d Delim) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Token">
               <h3>
                  Token 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Token returns the next JSON token in the input stream.
At the end of the input stream, Token returns nil, [io.EOF].
Token guarantees that the delimiters [ ] { } it returns are
properly nested and matched: if Token encounters an unexpected
delimiter in the input, it will return an error.
The input stream consists of basic JSON values—bool, string,
number, and null—along with delimiters [ ] { } of type [Delim]
to mark the start and end of arrays and objects.
Commas and colons are elided.</p>
               
               <pre><code>func (dec *Decoder) Token() (Token, error)</code></pre>
            </article>
            
            <article class="function" data-name="Unmarshal">
               <h3>
                  Unmarshal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Unmarshal parses the JSON-encoded data and stores the result
in the value pointed to by v. If v is nil or not a pointer,
Unmarshal returns an [InvalidUnmarshalError].
Unmarshal uses the inverse of the encodings that
[Marshal] uses, allocating maps, slices, and pointers as necessary,
with the following additional rules:
To unmarshal JSON into a pointer, Unmarshal first handles the case of
the JSON being the JSON literal null. In that case, Unmarshal sets
the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into
the value pointed at by the pointer. If the pointer is nil, Unmarshal
allocates a new value for it to point to.
To unmarshal JSON into a value implementing [Unmarshaler],
Unmarshal calls that value's [Unmarshaler.UnmarshalJSON] method, including
when the input is a JSON null.
Otherwise, if the value implements [encoding.TextUnmarshaler]
and the input is a JSON quoted string, Unmarshal calls
[encoding.TextUnmarshaler.UnmarshalText] with the unquoted form of the string.
To unmarshal JSON into a struct, Unmarshal matches incoming object
keys to the keys used by [Marshal] (either the struct field name or its tag),
preferring an exact match but also accepting a case-insensitive match. By
default, object keys which don't have a corresponding struct field are
ignored (see [Decoder.DisallowUnknownFields] for an alternative).
To unmarshal JSON into an interface value,
Unmarshal stores one of these in the interface value:
- bool, for JSON booleans
- float64, for JSON numbers
- string, for JSON strings
- []any, for JSON arrays
- map[string]any, for JSON objects
- nil for JSON null
To unmarshal a JSON array into a slice, Unmarshal resets the slice length
to zero and then appends each element to the slice.
As a special case, to unmarshal an empty JSON array into a slice,
Unmarshal replaces the slice with a new empty slice.
To unmarshal a JSON array into a Go array, Unmarshal decodes
JSON array elements into corresponding Go array elements.
If the Go array is smaller than the JSON array,
the additional JSON array elements are discarded.
If the JSON array is smaller than the Go array,
the additional Go array elements are set to zero values.
To unmarshal a JSON object into a map, Unmarshal first establishes a map to
use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal
reuses the existing map, keeping existing entries. Unmarshal then stores
key-value pairs from the JSON object into the map. The map's key type must
either be any string type, an integer, or implement [encoding.TextUnmarshaler].
If the JSON-encoded data contain a syntax error, Unmarshal returns a [SyntaxError].
If a JSON value is not appropriate for a given target type,
or if a JSON number overflows the target type, Unmarshal
skips that field and completes the unmarshaling as best it can.
If no more serious errors are encountered, Unmarshal returns
an [UnmarshalTypeError] describing the earliest such error. In any
case, it's not guaranteed that all the remaining fields following
the problematic one will be unmarshaled into the target object.
The JSON null value unmarshals into an interface, map, pointer, or slice
by setting that Go value to nil. Because null is often used in JSON to mean
“not present,” unmarshaling a JSON null into any other Go type has no effect
on the value and produces no error.
When unmarshaling quoted strings, invalid UTF-8 or
invalid UTF-16 surrogate pairs are not treated as an error.
Instead, they are replaced by the Unicode replacement
character U+FFFD.</p>
               
               <pre><code>func Unmarshal(data []byte, v any) error</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalJSON">
               <h3>
                  UnmarshalJSON 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalJSON sets *m to a copy of data.</p>
               
               <pre><code>func (m *RawMessage) UnmarshalJSON(data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Unwrap returns the underlying error.</p>
               
               <pre><code>func (e *MarshalerError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="UseNumber">
               <h3>
                  UseNumber 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UseNumber causes the Decoder to unmarshal a number into an
interface value as a [Number] instead of as a float64.</p>
               
               <pre><code>func (dec *Decoder) UseNumber()</code></pre>
            </article>
            
            <article class="function" data-name="Valid">
               <h3>
                  Valid 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Valid reports whether data is a valid JSON encoding.</p>
               
               <pre><code>func Valid(data []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="addErrorContext">
               <h3>
                  addErrorContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addErrorContext returns a new error enhanced with information from d.errorContext</p>
               
               <pre><code>func (d *decodeState) addErrorContext(err error) error</code></pre>
            </article>
            
            <article class="function" data-name="addrMarshalerEncoder">
               <h3>
                  addrMarshalerEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addrMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="addrTextMarshalerEncoder">
               <h3>
                  addrTextMarshalerEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addrTextMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="appendCompact">
               <h3>
                  appendCompact 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendCompact(dst []byte, src []byte, escape bool) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="appendFoldedName">
               <h3>
                  appendFoldedName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendFoldedName(out []byte, in []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendHTMLEscape">
               <h3>
                  appendHTMLEscape 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendHTMLEscape(dst []byte, src []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendIndent">
               <h3>
                  appendIndent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendIndent(dst []byte, src []byte, prefix string, indent string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="appendNewline">
               <h3>
                  appendNewline 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendNewline(dst []byte, prefix string, indent string, depth int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendString">
               <h3>
                  appendString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendString(dst []byte, src Bytes, escapeHTML bool) []byte</code></pre>
            </article>
            
            <article class="function" data-name="array">
               <h3>
                  array 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>array consumes an array from d.data[d.off-1:], decoding into v.
The first byte of the array ('[') has been read already.</p>
               
               <pre><code>func (d *decodeState) array(v reflect.Value) error</code></pre>
            </article>
            
            <article class="function" data-name="arrayInterface">
               <h3>
                  arrayInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>arrayInterface is like array but returns []any.</p>
               
               <pre><code>func (d *decodeState) arrayInterface() []any</code></pre>
            </article>
            
            <article class="function" data-name="boolEncoder">
               <h3>
                  boolEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func boolEncoder(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="cachedTypeFields">
               <h3>
                  cachedTypeFields 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>cachedTypeFields is like typeFields but uses a cache to avoid repeated work.</p>
               
               <pre><code>func cachedTypeFields(t reflect.Type) structFields</code></pre>
            </article>
            
            <article class="function" data-name="checkValid">
               <h3>
                  checkValid 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkValid verifies that data is valid JSON-encoded data.
scan is passed in for use by checkValid to avoid an allocation.
checkValid returns nil or a SyntaxError.</p>
               
               <pre><code>func checkValid(data []byte, scan *scanner) error</code></pre>
            </article>
            
            <article class="function" data-name="convertNumber">
               <h3>
                  convertNumber 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>convertNumber converts the number literal s to a float64 or a Number
depending on the setting of d.useNumber.</p>
               
               <pre><code>func (d *decodeState) convertNumber(s string) (any, error)</code></pre>
            </article>
            
            <article class="function" data-name="dominantField">
               <h3>
                  dominantField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dominantField looks through the fields, all of which are known to
have the same name, to find the single field that dominates the
others using Go's embedding rules, modified by the presence of
JSON tags. If there are multiple top-level fields, the boolean
will be false: This condition is an error in Go and we skip all
the fields.</p>
               
               <pre><code>func dominantField(fields []field) (field, bool)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ae arrayEncoder) encode(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ce condAddrEncoder) encode(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (me mapEncoder) encode(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (se structEncoder) encode(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (se sliceEncoder) encode(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (bits floatEncoder) encode(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pe ptrEncoder) encode(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="encodeByteSlice">
               <h3>
                  encodeByteSlice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeByteSlice(e *encodeState, v reflect.Value, _ encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="eof">
               <h3>
                  eof 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>eof tells the scanner that the end of input has been reached.
It returns a scan status just as s.step does.</p>
               
               <pre><code>func (s *scanner) eof() int</code></pre>
            </article>
            
            <article class="function" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>error aborts the encoding by panicking with err wrapped in jsonError.</p>
               
               <pre><code>func (e *encodeState) error(err error)</code></pre>
            </article>
            
            <article class="function" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>error records an error and switches to the error state.</p>
               
               <pre><code>func (s *scanner) error(c byte, context string) int</code></pre>
            </article>
            
            <article class="function" data-name="foldName">
               <h3>
                  foldName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>foldName returns a folded string such that foldName(x) == foldName(y)
is identical to bytes.EqualFold(x, y).</p>
               
               <pre><code>func foldName(in []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="foldRune">
               <h3>
                  foldRune 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>foldRune is returns the smallest rune for all runes in the same fold set.</p>
               
               <pre><code>func foldRune(r rune) rune</code></pre>
            </article>
            
            <article class="function" data-name="freeScanner">
               <h3>
                  freeScanner 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func freeScanner(scan *scanner)</code></pre>
            </article>
            
            <article class="function" data-name="getu4">
               <h3>
                  getu4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>getu4 decodes \uXXXX from the beginning of s, returning the hex value,
or it returns -1.</p>
               
               <pre><code>func getu4(s []byte) rune</code></pre>
            </article>
            
            <article class="function" data-name="indirect">
               <h3>
                  indirect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>indirect walks down v allocating pointers as needed,
until it gets to a non-pointer.
If it encounters an Unmarshaler, indirect stops and returns that.
If decodingNull is true, indirect stops at the first settable pointer so it
can be set to nil.</p>
               
               <pre><code>func indirect(v reflect.Value, decodingNull bool) (Unmarshaler, encoding.TextUnmarshaler, reflect.Value)</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *decodeState) init(data []byte) *decodeState</code></pre>
            </article>
            
            <article class="function" data-name="intEncoder">
               <h3>
                  intEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func intEncoder(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="interfaceEncoder">
               <h3>
                  interfaceEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func interfaceEncoder(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="invalidValueEncoder">
               <h3>
                  invalidValueEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func invalidValueEncoder(e *encodeState, v reflect.Value, _ encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="isEmptyValue">
               <h3>
                  isEmptyValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isEmptyValue(v reflect.Value) bool</code></pre>
            </article>
            
            <article class="function" data-name="isSpace">
               <h3>
                  isSpace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isSpace(c byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="isValidNumber">
               <h3>
                  isValidNumber 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isValidNumber reports whether s is a valid JSON number literal.
isValidNumber should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/bytedance/sonic
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname isValidNumber</p>
               
               <pre><code>func isValidNumber(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isValidTag">
               <h3>
                  isValidTag 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isValidTag(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="literalInterface">
               <h3>
                  literalInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>literalInterface consumes and returns a literal from d.data[d.off-1:] and
it reads the following byte ahead. The first byte of the literal has been
read already (that's how the caller knows it's a literal).</p>
               
               <pre><code>func (d *decodeState) literalInterface() any</code></pre>
            </article>
            
            <article class="function" data-name="literalStore">
               <h3>
                  literalStore 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>literalStore decodes a literal stored in item into v.
fromQuoted indicates whether this literal came from unwrapping a
string from the ",string" struct tag option. this is used only to
produce more helpful error messages.</p>
               
               <pre><code>func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool) error</code></pre>
            </article>
            
            <article class="function" data-name="marshal">
               <h3>
                  marshal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *encodeState) marshal(v any, opts encOpts) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="marshalerEncoder">
               <h3>
                  marshalerEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func marshalerEncoder(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="mayAppendQuote">
               <h3>
                  mayAppendQuote 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func mayAppendQuote(b []byte, quoted bool) []byte</code></pre>
            </article>
            
            <article class="function" data-name="newArrayEncoder">
               <h3>
                  newArrayEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newArrayEncoder(t reflect.Type) encoderFunc</code></pre>
            </article>
            
            <article class="function" data-name="newCondAddrEncoder">
               <h3>
                  newCondAddrEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newCondAddrEncoder returns an encoder that checks whether its value
CanAddr and delegates to canAddrEnc if so, else to elseEnc.</p>
               
               <pre><code>func newCondAddrEncoder(canAddrEnc encoderFunc, elseEnc encoderFunc) encoderFunc</code></pre>
            </article>
            
            <article class="function" data-name="newEncodeState">
               <h3>
                  newEncodeState 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newEncodeState() *encodeState</code></pre>
            </article>
            
            <article class="function" data-name="newMapEncoder">
               <h3>
                  newMapEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newMapEncoder(t reflect.Type) encoderFunc</code></pre>
            </article>
            
            <article class="function" data-name="newPtrEncoder">
               <h3>
                  newPtrEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newPtrEncoder(t reflect.Type) encoderFunc</code></pre>
            </article>
            
            <article class="function" data-name="newScanner">
               <h3>
                  newScanner 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newScanner() *scanner</code></pre>
            </article>
            
            <article class="function" data-name="newSliceEncoder">
               <h3>
                  newSliceEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newSliceEncoder(t reflect.Type) encoderFunc</code></pre>
            </article>
            
            <article class="function" data-name="newStructEncoder">
               <h3>
                  newStructEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newStructEncoder(t reflect.Type) encoderFunc</code></pre>
            </article>
            
            <article class="function" data-name="newTypeEncoder">
               <h3>
                  newTypeEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newTypeEncoder constructs an encoderFunc for a type.
The returned encoder only checks CanAddr when allowAddr is true.</p>
               
               <pre><code>func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc</code></pre>
            </article>
            
            <article class="function" data-name="nonSpace">
               <h3>
                  nonSpace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nonSpace(b []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="object">
               <h3>
                  object 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>object consumes an object from d.data[d.off-1:], decoding into v.
The first byte ('{') of the object has been read already.</p>
               
               <pre><code>func (d *decodeState) object(v reflect.Value) error</code></pre>
            </article>
            
            <article class="function" data-name="objectInterface">
               <h3>
                  objectInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>objectInterface is like object but returns map[string]any.</p>
               
               <pre><code>func (d *decodeState) objectInterface() map[string]any</code></pre>
            </article>
            
            <article class="function" data-name="parseTag">
               <h3>
                  parseTag 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseTag splits a struct field's json tag into its name and
comma-separated options.</p>
               
               <pre><code>func parseTag(tag string) (string, tagOptions)</code></pre>
            </article>
            
            <article class="function" data-name="peek">
               <h3>
                  peek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dec *Decoder) peek() (byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="popParseState">
               <h3>
                  popParseState 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>popParseState pops a parse state (already obtained) off the stack
and updates s.step accordingly.</p>
               
               <pre><code>func (s *scanner) popParseState()</code></pre>
            </article>
            
            <article class="function" data-name="pushParseState">
               <h3>
                  pushParseState 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pushParseState pushes a new parse state p onto the parse stack.
an error state is returned if maxNestingDepth was exceeded, otherwise successState is returned.</p>
               
               <pre><code>func (s *scanner) pushParseState(c byte, newParseState int, successState int) int</code></pre>
            </article>
            
            <article class="function" data-name="quoteChar">
               <h3>
                  quoteChar 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>quoteChar formats c as a quoted character literal.</p>
               
               <pre><code>func quoteChar(c byte) string</code></pre>
            </article>
            
            <article class="function" data-name="readIndex">
               <h3>
                  readIndex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>readIndex returns the position of the last byte read.</p>
               
               <pre><code>func (d *decodeState) readIndex() int</code></pre>
            </article>
            
            <article class="function" data-name="readValue">
               <h3>
                  readValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>readValue reads a JSON value into dec.buf.
It returns the length of the encoding.</p>
               
               <pre><code>func (dec *Decoder) readValue() (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="refill">
               <h3>
                  refill 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dec *Decoder) refill() error</code></pre>
            </article>
            
            <article class="function" data-name="reflectValue">
               <h3>
                  reflectValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *encodeState) reflectValue(v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="rescanLiteral">
               <h3>
                  rescanLiteral 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>rescanLiteral is similar to scanWhile(scanContinue), but it specialises the
common case where we're decoding a literal. The decoder scans the input
twice, once for syntax errors and to check the length of the value, and the
second to perform the decoding.
Only in the second step do we use decodeState to tokenize literals, so we
know there aren't any syntax errors. We can take advantage of that knowledge,
and scan a literal's bytes much more quickly.</p>
               
               <pre><code>func (d *decodeState) rescanLiteral()</code></pre>
            </article>
            
            <article class="function" data-name="reset">
               <h3>
                  reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>reset prepares the scanner for use.
It must be called before calling s.step.</p>
               
               <pre><code>func (s *scanner) reset()</code></pre>
            </article>
            
            <article class="function" data-name="resolveKeyName">
               <h3>
                  resolveKeyName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func resolveKeyName(k reflect.Value) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="saveError">
               <h3>
                  saveError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>saveError saves the first err it is called with,
for reporting at the end of the unmarshal.</p>
               
               <pre><code>func (d *decodeState) saveError(err error)</code></pre>
            </article>
            
            <article class="function" data-name="scanNext">
               <h3>
                  scanNext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scanNext processes the byte at d.data[d.off].</p>
               
               <pre><code>func (d *decodeState) scanNext()</code></pre>
            </article>
            
            <article class="function" data-name="scanWhile">
               <h3>
                  scanWhile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scanWhile processes bytes in d.data[d.off:] until it
receives a scan code not equal to op.</p>
               
               <pre><code>func (d *decodeState) scanWhile(op int)</code></pre>
            </article>
            
            <article class="function" data-name="skip">
               <h3>
                  skip 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>skip scans to the end of what was started.</p>
               
               <pre><code>func (d *decodeState) skip()</code></pre>
            </article>
            
            <article class="function" data-name="state0">
               <h3>
                  state0 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>state0 is the state after reading `0` during a number.</p>
               
               <pre><code>func state0(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="state1">
               <h3>
                  state1 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>state1 is the state after reading a non-zero integer during a number,
such as after reading `1` or `100` but not `0`.</p>
               
               <pre><code>func state1(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateBeginString">
               <h3>
                  stateBeginString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateBeginString is the state after reading `{"key": value,`.</p>
               
               <pre><code>func stateBeginString(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateBeginStringOrEmpty">
               <h3>
                  stateBeginStringOrEmpty 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateBeginStringOrEmpty is the state after reading `{`.</p>
               
               <pre><code>func stateBeginStringOrEmpty(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateBeginValue">
               <h3>
                  stateBeginValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateBeginValue is the state at the beginning of the input.</p>
               
               <pre><code>func stateBeginValue(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateBeginValueOrEmpty">
               <h3>
                  stateBeginValueOrEmpty 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateBeginValueOrEmpty is the state after reading `[`.</p>
               
               <pre><code>func stateBeginValueOrEmpty(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateDot">
               <h3>
                  stateDot 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateDot is the state after reading the integer and decimal point in a number,
such as after reading `1.`.</p>
               
               <pre><code>func stateDot(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateDot0">
               <h3>
                  stateDot0 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateDot0 is the state after reading the integer, decimal point, and subsequent
digits of a number, such as after reading `3.14`.</p>
               
               <pre><code>func stateDot0(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateE">
               <h3>
                  stateE 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateE is the state after reading the mantissa and e in a number,
such as after reading `314e` or `0.314e`.</p>
               
               <pre><code>func stateE(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateE0">
               <h3>
                  stateE0 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateE0 is the state after reading the mantissa, e, optional sign,
and at least one digit of the exponent in a number,
such as after reading `314e-2` or `0.314e+1` or `3.14e0`.</p>
               
               <pre><code>func stateE0(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateESign">
               <h3>
                  stateESign 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateESign is the state after reading the mantissa, e, and sign in a number,
such as after reading `314e-` or `0.314e+`.</p>
               
               <pre><code>func stateESign(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateEndTop">
               <h3>
                  stateEndTop 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateEndTop is the state after finishing the top-level value,
such as after reading `{}` or `[1,2,3]`.
Only space characters should be seen now.</p>
               
               <pre><code>func stateEndTop(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateEndValue">
               <h3>
                  stateEndValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateEndValue is the state after completing a value,
such as after reading `{}` or `true` or `["x"`.</p>
               
               <pre><code>func stateEndValue(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateError">
               <h3>
                  stateError 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateError is the state after reaching a syntax error,
such as after reading `[1}` or `5.1.2`.</p>
               
               <pre><code>func stateError(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateF">
               <h3>
                  stateF 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateF is the state after reading `f`.</p>
               
               <pre><code>func stateF(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateFa">
               <h3>
                  stateFa 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateFa is the state after reading `fa`.</p>
               
               <pre><code>func stateFa(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateFal">
               <h3>
                  stateFal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateFal is the state after reading `fal`.</p>
               
               <pre><code>func stateFal(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateFals">
               <h3>
                  stateFals 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateFals is the state after reading `fals`.</p>
               
               <pre><code>func stateFals(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateInString">
               <h3>
                  stateInString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateInString is the state after reading `"`.</p>
               
               <pre><code>func stateInString(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateInStringEsc">
               <h3>
                  stateInStringEsc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateInStringEsc is the state after reading `"\` during a quoted string.</p>
               
               <pre><code>func stateInStringEsc(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateInStringEscU">
               <h3>
                  stateInStringEscU 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateInStringEscU is the state after reading `"\u` during a quoted string.</p>
               
               <pre><code>func stateInStringEscU(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateInStringEscU1">
               <h3>
                  stateInStringEscU1 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateInStringEscU1 is the state after reading `"\u1` during a quoted string.</p>
               
               <pre><code>func stateInStringEscU1(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateInStringEscU12">
               <h3>
                  stateInStringEscU12 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateInStringEscU12 is the state after reading `"\u12` during a quoted string.</p>
               
               <pre><code>func stateInStringEscU12(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateInStringEscU123">
               <h3>
                  stateInStringEscU123 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateInStringEscU123 is the state after reading `"\u123` during a quoted string.</p>
               
               <pre><code>func stateInStringEscU123(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateN">
               <h3>
                  stateN 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateN is the state after reading `n`.</p>
               
               <pre><code>func stateN(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateNeg">
               <h3>
                  stateNeg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateNeg is the state after reading `-` during a number.</p>
               
               <pre><code>func stateNeg(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateNu">
               <h3>
                  stateNu 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateNu is the state after reading `nu`.</p>
               
               <pre><code>func stateNu(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateNul">
               <h3>
                  stateNul 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateNul is the state after reading `nul`.</p>
               
               <pre><code>func stateNul(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateT">
               <h3>
                  stateT 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateT is the state after reading `t`.</p>
               
               <pre><code>func stateT(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateTr">
               <h3>
                  stateTr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateTr is the state after reading `tr`.</p>
               
               <pre><code>func stateTr(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stateTru">
               <h3>
                  stateTru 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stateTru is the state after reading `tru`.</p>
               
               <pre><code>func stateTru(s *scanner, c byte) int</code></pre>
            </article>
            
            <article class="function" data-name="stringEncoder">
               <h3>
                  stringEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func stringEncoder(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="textMarshalerEncoder">
               <h3>
                  textMarshalerEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func textMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="tokenError">
               <h3>
                  tokenError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dec *Decoder) tokenError(c byte) (Token, error)</code></pre>
            </article>
            
            <article class="function" data-name="tokenPrepareForDecode">
               <h3>
                  tokenPrepareForDecode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>advance tokenstate from a separator state to a value state</p>
               
               <pre><code>func (dec *Decoder) tokenPrepareForDecode() error</code></pre>
            </article>
            
            <article class="function" data-name="tokenValueAllowed">
               <h3>
                  tokenValueAllowed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dec *Decoder) tokenValueAllowed() bool</code></pre>
            </article>
            
            <article class="function" data-name="tokenValueEnd">
               <h3>
                  tokenValueEnd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dec *Decoder) tokenValueEnd()</code></pre>
            </article>
            
            <article class="function" data-name="typeByIndex">
               <h3>
                  typeByIndex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func typeByIndex(t reflect.Type, index []int) reflect.Type</code></pre>
            </article>
            
            <article class="function" data-name="typeEncoder">
               <h3>
                  typeEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func typeEncoder(t reflect.Type) encoderFunc</code></pre>
            </article>
            
            <article class="function" data-name="typeFields">
               <h3>
                  typeFields 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typeFields returns a list of fields that JSON should recognize for the given type.
The algorithm is breadth-first search over the set of structs to include - the top struct
and then any reachable anonymous structs.
typeFields should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/bytedance/sonic
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname typeFields</p>
               
               <pre><code>func typeFields(t reflect.Type) structFields</code></pre>
            </article>
            
            <article class="function" data-name="uintEncoder">
               <h3>
                  uintEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func uintEncoder(e *encodeState, v reflect.Value, opts encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="unmarshal">
               <h3>
                  unmarshal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *decodeState) unmarshal(v any) error</code></pre>
            </article>
            
            <article class="function" data-name="unquote">
               <h3>
                  unquote 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>unquote converts a quoted JSON string literal s into an actual string t.
The rules are different than for Go, so cannot use strconv.Unquote.</p>
               
               <pre><code>func unquote(s []byte) (t string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="unquoteBytes">
               <h3>
                  unquoteBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>unquoteBytes should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/bytedance/sonic
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname unquoteBytes</p>
               
               <pre><code>func unquoteBytes(s []byte) (t []byte, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="unsupportedTypeEncoder">
               <h3>
                  unsupportedTypeEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func unsupportedTypeEncoder(e *encodeState, v reflect.Value, _ encOpts)</code></pre>
            </article>
            
            <article class="function" data-name="value">
               <h3>
                  value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>value consumes a JSON value from d.data[d.off-1:], decoding into v, and
reads the following byte ahead. If v is invalid, the value is discarded.
The first byte of the value has been read already.</p>
               
               <pre><code>func (d *decodeState) value(v reflect.Value) error</code></pre>
            </article>
            
            <article class="function" data-name="valueEncoder">
               <h3>
                  valueEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func valueEncoder(v reflect.Value) encoderFunc</code></pre>
            </article>
            
            <article class="function" data-name="valueInterface">
               <h3>
                  valueInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>valueInterface is like value but returns any.</p>
               
               <pre><code>func (d *decodeState) valueInterface() (val any)</code></pre>
            </article>
            
            <article class="function" data-name="valueQuoted">
               <h3>
                  valueQuoted 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>valueQuoted is like value but decodes a
quoted string literal or literal null into an interface value.
If it finds anything other than a quoted string literal or null,
valueQuoted returns unquotedValue{}.</p>
               
               <pre><code>func (d *decodeState) valueQuoted() any</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
