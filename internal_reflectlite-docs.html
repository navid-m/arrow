<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>reflectlite - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>reflectlite</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"internal/goarch"
"internal/unsafeheader"
"unsafe"
"internal/abi"
"unsafe"
"internal/abi"
"internal/goarch"
"internal/unsafeheader"
"runtime"
"unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="Interface" data-name="Interface">
               <h3>
                  Interface 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Interface" class="anchor" title="Link to Interface">#</a>
               </h3>
               
                  <p class="doc-comment">Import-and-export these constants as necessary</p>
               
               <pre><code class="language-go">const Interface = abi.Interface</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Ptr" data-name="Ptr">
               <h3>
                  Ptr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Ptr" class="anchor" title="Link to Ptr">#</a>
               </h3>
               
               <pre><code class="language-go">const Ptr = abi.Pointer</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Slice" data-name="Slice">
               <h3>
                  Slice 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Slice" class="anchor" title="Link to Slice">#</a>
               </h3>
               
               <pre><code class="language-go">const Slice = abi.Slice</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">const String = abi.String</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Struct" data-name="Struct">
               <h3>
                  Struct 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Struct" class="anchor" title="Link to Struct">#</a>
               </h3>
               
               <pre><code class="language-go">const Struct = abi.Struct</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dummy" data-name="dummy">
               <h3>
                  dummy 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dummy" class="anchor" title="Link to dummy">#</a>
               </h3>
               
               <pre><code class="language-go">var dummy struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagAddr" data-name="flagAddr">
               <h3>
                  flagAddr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagAddr" class="anchor" title="Link to flagAddr">#</a>
               </h3>
               
               <pre><code class="language-go">const flagAddr flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagEmbedRO" data-name="flagEmbedRO">
               <h3>
                  flagEmbedRO 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagEmbedRO" class="anchor" title="Link to flagEmbedRO">#</a>
               </h3>
               
               <pre><code class="language-go">const flagEmbedRO flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagIndir" data-name="flagIndir">
               <h3>
                  flagIndir 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagIndir" class="anchor" title="Link to flagIndir">#</a>
               </h3>
               
               <pre><code class="language-go">const flagIndir flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagKindMask" data-name="flagKindMask">
               <h3>
                  flagKindMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagKindMask" class="anchor" title="Link to flagKindMask">#</a>
               </h3>
               
               <pre><code class="language-go">const flagKindMask flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagKindWidth" data-name="flagKindWidth">
               <h3>
                  flagKindWidth 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagKindWidth" class="anchor" title="Link to flagKindWidth">#</a>
               </h3>
               
               <pre><code class="language-go">const flagKindWidth = 5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagMethod" data-name="flagMethod">
               <h3>
                  flagMethod 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagMethod" class="anchor" title="Link to flagMethod">#</a>
               </h3>
               
               <pre><code class="language-go">const flagMethod flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagMethodShift" data-name="flagMethodShift">
               <h3>
                  flagMethodShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagMethodShift" class="anchor" title="Link to flagMethodShift">#</a>
               </h3>
               
               <pre><code class="language-go">const flagMethodShift = 10</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagRO" data-name="flagRO">
               <h3>
                  flagRO 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagRO" class="anchor" title="Link to flagRO">#</a>
               </h3>
               
               <pre><code class="language-go">const flagRO flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagStickyRO" data-name="flagStickyRO">
               <h3>
                  flagStickyRO 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagStickyRO" class="anchor" title="Link to flagStickyRO">#</a>
               </h3>
               
               <pre><code class="language-go">const flagStickyRO flag = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Kind" data-name="Kind">
               <h3>
                  Kind
                  <span class="badge type-badge">type</span>
                  <a href="#Kind" class="anchor" title="Link to Kind">#</a>
               </h3>
               
               <p>A Kind represents the specific kind of type that a Type represents.
The zero Kind is not a valid kind.</p>
               
               <pre><code class="language-go">type Kind abi.Kind</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="arrayType" data-name="arrayType">
               <h3>
                  arrayType
                  <span class="badge type-badge">type</span>
                  <a href="#arrayType" class="anchor" title="Link to arrayType">#</a>
               </h3>
               
               <p>arrayType represents a fixed array type.</p>
               
               <pre><code class="language-go">type arrayType abi.ArrayType</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="chanType" data-name="chanType">
               <h3>
                  chanType
                  <span class="badge type-badge">type</span>
                  <a href="#chanType" class="anchor" title="Link to chanType">#</a>
               </h3>
               
               <p>chanType represents a channel type.</p>
               
               <pre><code class="language-go">type chanType abi.ChanType</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="flag" data-name="flag">
               <h3>
                  flag
                  <span class="badge type-badge">type</span>
                  <a href="#flag" class="anchor" title="Link to flag">#</a>
               </h3>
               
               <pre><code class="language-go">type flag uintptr</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="funcType" data-name="funcType">
               <h3>
                  funcType
                  <span class="badge type-badge">type</span>
                  <a href="#funcType" class="anchor" title="Link to funcType">#</a>
               </h3>
               
               <pre><code class="language-go">type funcType abi.FuncType</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="interfaceType" data-name="interfaceType">
               <h3>
                  interfaceType
                  <span class="badge type-badge">type</span>
                  <a href="#interfaceType" class="anchor" title="Link to interfaceType">#</a>
               </h3>
               
               <pre><code class="language-go">type interfaceType abi.InterfaceType</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="nameOff" data-name="nameOff">
               <h3>
                  nameOff
                  <span class="badge type-badge">type</span>
                  <a href="#nameOff" class="anchor" title="Link to nameOff">#</a>
               </h3>
               
               <pre><code class="language-go">type nameOff abi.NameOff</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ptrType" data-name="ptrType">
               <h3>
                  ptrType
                  <span class="badge type-badge">type</span>
                  <a href="#ptrType" class="anchor" title="Link to ptrType">#</a>
               </h3>
               
               <p>ptrType represents a pointer type.</p>
               
               <pre><code class="language-go">type ptrType abi.PtrType</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="sliceType" data-name="sliceType">
               <h3>
                  sliceType
                  <span class="badge type-badge">type</span>
                  <a href="#sliceType" class="anchor" title="Link to sliceType">#</a>
               </h3>
               
               <p>sliceType represents a slice type.</p>
               
               <pre><code class="language-go">type sliceType abi.SliceType</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="structType" data-name="structType">
               <h3>
                  structType
                  <span class="badge type-badge">type</span>
                  <a href="#structType" class="anchor" title="Link to structType">#</a>
               </h3>
               
               <p>structType represents a struct type.</p>
               
               <pre><code class="language-go">type structType abi.StructType</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="textOff" data-name="textOff">
               <h3>
                  textOff
                  <span class="badge type-badge">type</span>
                  <a href="#textOff" class="anchor" title="Link to textOff">#</a>
               </h3>
               
               <pre><code class="language-go">type textOff abi.TextOff</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="typeOff" data-name="typeOff">
               <h3>
                  typeOff
                  <span class="badge type-badge">type</span>
                  <a href="#typeOff" class="anchor" title="Link to typeOff">#</a>
               </h3>
               
               <pre><code class="language-go">type typeOff abi.TypeOff</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="uncommonType" data-name="uncommonType">
               <h3>
                  uncommonType
                  <span class="badge type-badge">type</span>
                  <a href="#uncommonType" class="anchor" title="Link to uncommonType">#</a>
               </h3>
               
               <p>uncommonType is present only for defined types or types with methods
(if T is a defined type, the uncommonTypes for T and *T have methods).
Using a pointer to this struct reduces the overall size required
to describe a non-defined type with no methods.</p>
               
               <pre><code class="language-go">type uncommonType abi.UncommonType</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type
                  <span class="badge interface-badge">interface</span>
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>Type is the representation of a Go type.
Not all methods apply to all kinds of types. Restrictions,
if any, are noted in the documentation for each method.
Use the Kind method to find out the kind of type before
calling kind-specific methods. Calling a method
inappropriate to the kind of type causes a run-time panic.
Type values are comparable, such as with the == operator,
so they can be used as map keys.
Two Type values are equal if they represent identical types.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Type interface {
Name() string
PkgPath() string
Size() uintptr
Kind() Kind
Implements(u Type) bool
AssignableTo(u Type) bool
Comparable() bool
String() string
Elem() Type
common() *abi.Type
uncommon() *uncommonType
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value
                  <span class="badge">struct</span>
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <p>Value is the reflection interface to a Go value.
Not all methods apply to all kinds of values. Restrictions,
if any, are noted in the documentation for each method.
Use the Kind method to find out the kind of value before
calling kind-specific methods. Calling a method
inappropriate to the kind of type causes a run time panic.
The zero Value represents no value.
Its IsValid method returns false, its Kind method returns Invalid,
its String method returns "<invalid Value>", and all other methods panic.
Most functions and methods never return an invalid value.
If one does, its documentation states the conditions explicitly.
A Value can be used concurrently by multiple goroutines provided that
the underlying Go value can be used concurrently for the equivalent
direct operations.
To compare two Values, compare the results of the Interface method.
Using == on two Values does not compare the underlying values
they represent.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Value struct {
typ_ *abi.Type
ptr unsafe.Pointer
flag
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ValueError" data-name="ValueError">
               <h3>
                  ValueError
                  <span class="badge">struct</span>
                  <a href="#ValueError" class="anchor" title="Link to ValueError">#</a>
               </h3>
               
               <p>A ValueError occurs when a Value method is invoked on
a Value that does not support it. Such cases are documented
in the description of each method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ValueError struct {
Method string
Kind Kind
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="name" data-name="name">
               <h3>
                  name
                  <span class="badge">struct</span>
                  <a href="#name" class="anchor" title="Link to name">#</a>
               </h3>
               
               <p>name is an encoded type name with optional extra data.
The first byte is a bit field containing:
1<<0 the name is exported
1<<1 tag data follows the name
1<<2 pkgPath nameOff follows the name and tag
The next two bytes are the data length:
l := uint16(data[1])<<8 | uint16(data[2])
Bytes [3:3+l] are the string data.
If tag data follows then bytes 3+l and 3+l+1 are the tag length,
with the data following.
If the import path follows, then 4 bytes at the end of
the data form a nameOff. The import path is only set for concrete
methods that are defined in a different package than their type.
If a name starts with "*", then the exported bit represents
whether the pointed to type is exported.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type name struct {
bytes *byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="rtype" data-name="rtype">
               <h3>
                  rtype
                  <span class="badge">struct</span>
                  <a href="#rtype" class="anchor" title="Link to rtype">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type rtype struct {
*abi.Type
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AssignableTo" data-name="AssignableTo">
               <h3>
                  AssignableTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AssignableTo" class="anchor" title="Link to AssignableTo">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) AssignableTo(u Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanSet" data-name="CanSet">
               <h3>
                  CanSet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanSet" class="anchor" title="Link to CanSet">#</a>
               </h3>
               
               <p>CanSet reports whether the value of v can be changed.
A Value can be changed only if it is addressable and was not
obtained by the use of unexported struct fields.
If CanSet returns false, calling Set or any type-specific
setter (e.g., SetBool, SetInt) will panic.</p>
               
               <pre><code class="language-go">func (v Value) CanSet() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Comparable" data-name="Comparable">
               <h3>
                  Comparable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Comparable" class="anchor" title="Link to Comparable">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) Comparable() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Elem" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Elem" class="anchor" title="Link to Elem">#</a>
               </h3>
               
               <p>Elem returns the value that the interface v contains
or that the pointer v points to.
It panics if v's Kind is not Interface or Pointer.
It returns the zero Value if v is nil.</p>
               
               <pre><code class="language-go">func (v Value) Elem() Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Elem" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Elem" class="anchor" title="Link to Elem">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) Elem() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ValueError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Implements" data-name="Implements">
               <h3>
                  Implements 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Implements" class="anchor" title="Link to Implements">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) Implements(u Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="In" data-name="In">
               <h3>
                  In 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#In" class="anchor" title="Link to In">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) In(i int) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsNil" data-name="IsNil">
               <h3>
                  IsNil 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsNil" class="anchor" title="Link to IsNil">#</a>
               </h3>
               
               <p>IsNil reports whether its argument v is nil. The argument must be
a chan, func, interface, map, pointer, or slice value; if it is
not, IsNil panics. Note that IsNil is not always equivalent to a
regular comparison with nil in Go. For example, if v was created
by calling ValueOf with an uninitialized interface variable i,
i==nil will be true but v.IsNil will panic as v will be the zero
Value.</p>
               
               <pre><code class="language-go">func (v Value) IsNil() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsValid" data-name="IsValid">
               <h3>
                  IsValid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsValid" class="anchor" title="Link to IsValid">#</a>
               </h3>
               
               <p>IsValid reports whether v represents a value.
It returns false if v is the zero Value.
If IsValid returns false, all other methods except String panic.
Most functions and methods never return an invalid Value.
If one does, its documentation states the conditions explicitly.</p>
               
               <pre><code class="language-go">func (v Value) IsValid() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Key" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Key" class="anchor" title="Link to Key">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) Key() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Kind" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Kind" class="anchor" title="Link to Kind">#</a>
               </h3>
               
               <p>Kind returns v's Kind.
If v is the zero Value (IsValid returns false), Kind returns Invalid.</p>
               
               <pre><code class="language-go">func (v Value) Kind() Kind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Len returns v's length.
It panics if v's Kind is not Array, Chan, Map, Slice, or String.</p>
               
               <pre><code class="language-go">func (v Value) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumField" data-name="NumField">
               <h3>
                  NumField 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumField" class="anchor" title="Link to NumField">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) NumField() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumIn" data-name="NumIn">
               <h3>
                  NumIn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumIn" class="anchor" title="Link to NumIn">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) NumIn() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumMethod" data-name="NumMethod">
               <h3>
                  NumMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumMethod" class="anchor" title="Link to NumMethod">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) NumMethod() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumOut" data-name="NumOut">
               <h3>
                  NumOut 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumOut" class="anchor" title="Link to NumOut">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) NumOut() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Out" data-name="Out">
               <h3>
                  Out 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Out" class="anchor" title="Link to Out">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) Out(i int) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PkgPath" data-name="PkgPath">
               <h3>
                  PkgPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PkgPath" class="anchor" title="Link to PkgPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) PkgPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set assigns x to the value v.
It panics if CanSet returns false.
As in Go, x's value must be assignable to v's type.</p>
               
               <pre><code class="language-go">func (v Value) Set(x Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swapper" data-name="Swapper">
               <h3>
                  Swapper 
                  <span class="badge">function</span>
                  
                  <a href="#Swapper" class="anchor" title="Link to Swapper">#</a>
               </h3>
               
               <p>Swapper returns a function that swaps the elements in the provided
slice.
Swapper panics if the provided interface is not a slice.</p>
               
               <pre><code class="language-go">func Swapper(slice any) (func(i int, j int))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>Type returns v's type.</p>
               
               <pre><code class="language-go">func (v Value) Type() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeOf" data-name="TypeOf">
               <h3>
                  TypeOf 
                  <span class="badge">function</span>
                  
                  <a href="#TypeOf" class="anchor" title="Link to TypeOf">#</a>
               </h3>
               
               <p>TypeOf returns the reflection Type that represents the dynamic type of i.
If i is a nil interface value, TypeOf returns nil.</p>
               
               <pre><code class="language-go">func TypeOf(i any) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ValueOf" data-name="ValueOf">
               <h3>
                  ValueOf 
                  <span class="badge">function</span>
                  
                  <a href="#ValueOf" class="anchor" title="Link to ValueOf">#</a>
               </h3>
               
               <p>ValueOf returns a new Value initialized to the concrete value
stored in the interface i. ValueOf(nil) returns the zero Value.</p>
               
               <pre><code class="language-go">func ValueOf(i any) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge">function</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add returns p+x.
The whySafe string is ignored, so that the function still inlines
as efficiently as p+x, but all call sites should use the string to
record why the addition is safe, which is to say why the addition
does not cause x to advance to the very end of p's allocation
and therefore point incorrectly at the next block in memory.</p>
               
               <pre><code class="language-go">func add(p unsafe.Pointer, x uintptr, whySafe string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="arrayAt" data-name="arrayAt">
               <h3>
                  arrayAt 
                  <span class="badge">function</span>
                  
                  <a href="#arrayAt" class="anchor" title="Link to arrayAt">#</a>
               </h3>
               
               <p>arrayAt returns the i-th element of p,
an array whose elements are eltSize bytes wide.
The array pointed at by p must have at least i+1 elements:
it is invalid (but impossible to check here) to pass i >= len,
because then the result will point outside the array.
whySafe must explain why i < len. (Passing "i < len" is fine;
the benefit is to surface this assumption at the call site.)</p>
               
               <pre><code class="language-go">func arrayAt(p unsafe.Pointer, i int, eltSize uintptr, whySafe string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignTo" data-name="assignTo">
               <h3>
                  assignTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignTo" class="anchor" title="Link to assignTo">#</a>
               </h3>
               
               <p>assignTo returns a value v that can be assigned directly to typ.
It panics if v is not assignable to typ.
For a conversion to an interface type, target is a suggested scratch space to use.</p>
               
               <pre><code class="language-go">func (v Value) assignTo(context string, dst *abi.Type, target unsafe.Pointer) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chanlen" data-name="chanlen">
               <h3>
                  chanlen 
                  <span class="badge">function</span>
                  
                  <a href="#chanlen" class="anchor" title="Link to chanlen">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func chanlen(unsafe.Pointer) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="common" data-name="common">
               <h3>
                  common 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#common" class="anchor" title="Link to common">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) common() *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="data" data-name="data">
               <h3>
                  data 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#data" class="anchor" title="Link to data">#</a>
               </h3>
               
               <pre><code class="language-go">func (n name) data(off int, whySafe string) *byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="directlyAssignable" data-name="directlyAssignable">
               <h3>
                  directlyAssignable 
                  <span class="badge">function</span>
                  
                  <a href="#directlyAssignable" class="anchor" title="Link to directlyAssignable">#</a>
               </h3>
               
               <p>directlyAssignable reports whether a value x of type V can be directly
assigned (using memmove) to a value of type T.
https://golang.org/doc/go_spec.html#Assignability
Ignoring the interface rules (implemented elsewhere)
and the ideal constant rules (no ideal constants at run time).</p>
               
               <pre><code class="language-go">func directlyAssignable(T *abi.Type, V *abi.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="elem" data-name="elem">
               <h3>
                  elem 
                  <span class="badge">function</span>
                  
                  <a href="#elem" class="anchor" title="Link to elem">#</a>
               </h3>
               
               <pre><code class="language-go">func elem(t *abi.Type) *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="embedded" data-name="embedded">
               <h3>
                  embedded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#embedded" class="anchor" title="Link to embedded">#</a>
               </h3>
               
               <pre><code class="language-go">func (n name) embedded() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="escapes" data-name="escapes">
               <h3>
                  escapes 
                  <span class="badge">function</span>
                  
                  <a href="#escapes" class="anchor" title="Link to escapes">#</a>
               </h3>
               
               <p>Dummy annotation marking that the value x escapes,
for use in cases where the reflect code is so clever that
the compiler cannot follow.</p>
               
               <pre><code class="language-go">func escapes(x any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exportedMethods" data-name="exportedMethods">
               <h3>
                  exportedMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exportedMethods" class="anchor" title="Link to exportedMethods">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) exportedMethods() []abi.Method</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasTag" data-name="hasTag">
               <h3>
                  hasTag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasTag" class="anchor" title="Link to hasTag">#</a>
               </h3>
               
               <pre><code class="language-go">func (n name) hasTag() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="haveIdenticalType" data-name="haveIdenticalType">
               <h3>
                  haveIdenticalType 
                  <span class="badge">function</span>
                  
                  <a href="#haveIdenticalType" class="anchor" title="Link to haveIdenticalType">#</a>
               </h3>
               
               <pre><code class="language-go">func haveIdenticalType(T *abi.Type, V *abi.Type, cmpTags bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="haveIdenticalUnderlyingType" data-name="haveIdenticalUnderlyingType">
               <h3>
                  haveIdenticalUnderlyingType 
                  <span class="badge">function</span>
                  
                  <a href="#haveIdenticalUnderlyingType" class="anchor" title="Link to haveIdenticalUnderlyingType">#</a>
               </h3>
               
               <pre><code class="language-go">func haveIdenticalUnderlyingType(T *abi.Type, V *abi.Type, cmpTags bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ifaceE2I" data-name="ifaceE2I">
               <h3>
                  ifaceE2I 
                  <span class="badge">function</span>
                  
                  <a href="#ifaceE2I" class="anchor" title="Link to ifaceE2I">#</a>
               </h3>
               
               <pre><code class="language-go">func ifaceE2I(t *abi.Type, src any, dst unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="implements" data-name="implements">
               <h3>
                  implements 
                  <span class="badge">function</span>
                  
                  <a href="#implements" class="anchor" title="Link to implements">#</a>
               </h3>
               
               <p>implements reports whether the type V implements the interface type T.</p>
               
               <pre><code class="language-go">func implements(T *abi.Type, V *abi.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isExported" data-name="isExported">
               <h3>
                  isExported 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isExported" class="anchor" title="Link to isExported">#</a>
               </h3>
               
               <pre><code class="language-go">func (n name) isExported() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="kind" data-name="kind">
               <h3>
                  kind 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#kind" class="anchor" title="Link to kind">#</a>
               </h3>
               
               <pre><code class="language-go">func (f flag) kind() Kind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maplen" data-name="maplen">
               <h3>
                  maplen 
                  <span class="badge">function</span>
                  
                  <a href="#maplen" class="anchor" title="Link to maplen">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func maplen(unsafe.Pointer) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methodName" data-name="methodName">
               <h3>
                  methodName 
                  <span class="badge">function</span>
                  
                  <a href="#methodName" class="anchor" title="Link to methodName">#</a>
               </h3>
               
               <p>methodName returns the name of the calling method,
assumed to be two stack frames above.</p>
               
               <pre><code class="language-go">func methodName() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustBeAssignable" data-name="mustBeAssignable">
               <h3>
                  mustBeAssignable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mustBeAssignable" class="anchor" title="Link to mustBeAssignable">#</a>
               </h3>
               
               <p>mustBeAssignable panics if f records that the value is not assignable,
which is to say that either it was obtained using an unexported field
or it is not addressable.</p>
               
               <pre><code class="language-go">func (f flag) mustBeAssignable()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustBeExported" data-name="mustBeExported">
               <h3>
                  mustBeExported 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mustBeExported" class="anchor" title="Link to mustBeExported">#</a>
               </h3>
               
               <p>mustBeExported panics if f records that the value was obtained using
an unexported field.</p>
               
               <pre><code class="language-go">func (f flag) mustBeExported()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="name" data-name="name">
               <h3>
                  name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#name" class="anchor" title="Link to name">#</a>
               </h3>
               
               <pre><code class="language-go">func (n name) name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nameOff" data-name="nameOff">
               <h3>
                  nameOff 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nameOff" class="anchor" title="Link to nameOff">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) nameOff(off nameOff) abi.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="numMethod" data-name="numMethod">
               <h3>
                  numMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#numMethod" class="anchor" title="Link to numMethod">#</a>
               </h3>
               
               <p>NumMethod returns the number of exported methods in the value's method set.</p>
               
               <pre><code class="language-go">func (v Value) numMethod() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="packEface" data-name="packEface">
               <h3>
                  packEface 
                  <span class="badge">function</span>
                  
                  <a href="#packEface" class="anchor" title="Link to packEface">#</a>
               </h3>
               
               <p>packEface converts v to the empty interface.</p>
               
               <pre><code class="language-go">func packEface(v Value) any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgPath" data-name="pkgPath">
               <h3>
                  pkgPath 
                  <span class="badge">function</span>
                  
                  <a href="#pkgPath" class="anchor" title="Link to pkgPath">#</a>
               </h3>
               
               <pre><code class="language-go">func pkgPath(n abi.Name) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pointer" data-name="pointer">
               <h3>
                  pointer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pointer" class="anchor" title="Link to pointer">#</a>
               </h3>
               
               <p>pointer returns the underlying pointer represented by v.
v.Kind() must be Pointer, Map, Chan, Func, or UnsafePointer</p>
               
               <pre><code class="language-go">func (v Value) pointer() unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readVarint" data-name="readVarint">
               <h3>
                  readVarint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readVarint" class="anchor" title="Link to readVarint">#</a>
               </h3>
               
               <p>readVarint parses a varint as encoded by encoding/binary.
It returns the number of encoded bytes and the encoded value.</p>
               
               <pre><code class="language-go">func (n name) readVarint(off int) (int, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveNameOff" data-name="resolveNameOff">
               <h3>
                  resolveNameOff 
                  <span class="badge">function</span>
                  
                  <a href="#resolveNameOff" class="anchor" title="Link to resolveNameOff">#</a>
               </h3>
               
               <p>resolveNameOff resolves a name offset from a base pointer.
The (*rtype).nameOff method is a convenience wrapper for this function.
Implemented in the runtime package.
go:noescape</p>
               
               <pre><code class="language-go">func resolveNameOff(ptrInModule unsafe.Pointer, off int32) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveTypeOff" data-name="resolveTypeOff">
               <h3>
                  resolveTypeOff 
                  <span class="badge">function</span>
                  
                  <a href="#resolveTypeOff" class="anchor" title="Link to resolveTypeOff">#</a>
               </h3>
               
               <p>resolveTypeOff resolves an *rtype offset from a base type.
The (*rtype).typeOff method is a convenience wrapper for this function.
Implemented in the runtime package.
go:noescape</p>
               
               <pre><code class="language-go">func resolveTypeOff(rtype unsafe.Pointer, off int32) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ro" data-name="ro">
               <h3>
                  ro 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ro" class="anchor" title="Link to ro">#</a>
               </h3>
               
               <pre><code class="language-go">func (f flag) ro() flag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tag" data-name="tag">
               <h3>
                  tag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tag" class="anchor" title="Link to tag">#</a>
               </h3>
               
               <pre><code class="language-go">func (n name) tag() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toRType" data-name="toRType">
               <h3>
                  toRType 
                  <span class="badge">function</span>
                  
                  <a href="#toRType" class="anchor" title="Link to toRType">#</a>
               </h3>
               
               <pre><code class="language-go">func toRType(t *abi.Type) rtype</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toType" data-name="toType">
               <h3>
                  toType 
                  <span class="badge">function</span>
                  
                  <a href="#toType" class="anchor" title="Link to toType">#</a>
               </h3>
               
               <p>toType converts from a *rtype to a Type that can be returned
to the client of package reflect. In gc, the only concern is that
a nil *rtype must be replaced by a nil Type, but in gccgo this
function takes care of ensuring that multiple *rtype for the same
type are coalesced into a single Type.</p>
               
               <pre><code class="language-go">func toType(t *abi.Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typ" data-name="typ">
               <h3>
                  typ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typ" class="anchor" title="Link to typ">#</a>
               </h3>
               
               <pre><code class="language-go">func (v Value) typ() *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeOff" data-name="typeOff">
               <h3>
                  typeOff 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeOff" class="anchor" title="Link to typeOff">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) typeOff(off typeOff) *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typedmemmove" data-name="typedmemmove">
               <h3>
                  typedmemmove 
                  <span class="badge">function</span>
                  
                  <a href="#typedmemmove" class="anchor" title="Link to typedmemmove">#</a>
               </h3>
               
               <p>typedmemmove copies a value of type t to dst from src.
go:noescape</p>
               
               <pre><code class="language-go">func typedmemmove(t *abi.Type, dst unsafe.Pointer, src unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uncommon" data-name="uncommon">
               <h3>
                  uncommon 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uncommon" class="anchor" title="Link to uncommon">#</a>
               </h3>
               
               <pre><code class="language-go">func (t rtype) uncommon() *uncommonType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unpackEface" data-name="unpackEface">
               <h3>
                  unpackEface 
                  <span class="badge">function</span>
                  
                  <a href="#unpackEface" class="anchor" title="Link to unpackEface">#</a>
               </h3>
               
               <p>unpackEface converts the empty interface i to a Value.</p>
               
               <pre><code class="language-go">func unpackEface(i any) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unsafe_New" data-name="unsafe_New">
               <h3>
                  unsafe_New 
                  <span class="badge">function</span>
                  
                  <a href="#unsafe_New" class="anchor" title="Link to unsafe_New">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func unsafe_New(*abi.Type) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="valueInterface" data-name="valueInterface">
               <h3>
                  valueInterface 
                  <span class="badge">function</span>
                  
                  <a href="#valueInterface" class="anchor" title="Link to valueInterface">#</a>
               </h3>
               
               <pre><code class="language-go">func valueInterface(v Value) any</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>