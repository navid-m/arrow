<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - asn1</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>asn1</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"errors"
"fmt"
"math"
"math/big"
"reflect"
"slices"
"strconv"
"strings"
"time"
"unicode/utf16"
"unicode/utf8"
"reflect"
"strconv"
"strings"
"bytes"
"errors"
"fmt"
"math/big"
"reflect"
"slices"
"time"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="ClassApplication">
               <h3>
                  ClassApplication 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 class types represent the namespace of the tag.</p>
               
               <pre><code>const ClassApplication = 1</code></pre>
            </article>
            
            <article class="global" data-name="ClassContextSpecific">
               <h3>
                  ClassContextSpecific 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 class types represent the namespace of the tag.</p>
               
               <pre><code>const ClassContextSpecific = 2</code></pre>
            </article>
            
            <article class="global" data-name="ClassPrivate">
               <h3>
                  ClassPrivate 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 class types represent the namespace of the tag.</p>
               
               <pre><code>const ClassPrivate = 3</code></pre>
            </article>
            
            <article class="global" data-name="ClassUniversal">
               <h3>
                  ClassUniversal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 class types represent the namespace of the tag.</p>
               
               <pre><code>const ClassUniversal = 0</code></pre>
            </article>
            
            <article class="global" data-name="NullBytes">
               <h3>
                  NullBytes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>NullBytes contains bytes representing the DER-encoded ASN.1 NULL type.</p>
               
               <pre><code>var NullBytes = []byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="NullRawValue">
               <h3>
                  NullRawValue 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>NullRawValue is a [RawValue] with its Tag set to the ASN.1 NULL type tag (5).</p>
               
               <pre><code>var NullRawValue = RawValue{...}</code></pre>
            </article>
            
            <article class="global" data-name="TagBMPString">
               <h3>
                  TagBMPString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagBMPString = 30</code></pre>
            </article>
            
            <article class="global" data-name="TagBitString">
               <h3>
                  TagBitString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagBitString = 3</code></pre>
            </article>
            
            <article class="global" data-name="TagBoolean">
               <h3>
                  TagBoolean 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagBoolean = 1</code></pre>
            </article>
            
            <article class="global" data-name="TagEnum">
               <h3>
                  TagEnum 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagEnum = 10</code></pre>
            </article>
            
            <article class="global" data-name="TagGeneralString">
               <h3>
                  TagGeneralString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagGeneralString = 27</code></pre>
            </article>
            
            <article class="global" data-name="TagGeneralizedTime">
               <h3>
                  TagGeneralizedTime 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagGeneralizedTime = 24</code></pre>
            </article>
            
            <article class="global" data-name="TagIA5String">
               <h3>
                  TagIA5String 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagIA5String = 22</code></pre>
            </article>
            
            <article class="global" data-name="TagInteger">
               <h3>
                  TagInteger 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagInteger = 2</code></pre>
            </article>
            
            <article class="global" data-name="TagNull">
               <h3>
                  TagNull 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagNull = 5</code></pre>
            </article>
            
            <article class="global" data-name="TagNumericString">
               <h3>
                  TagNumericString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagNumericString = 18</code></pre>
            </article>
            
            <article class="global" data-name="TagOID">
               <h3>
                  TagOID 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagOID = 6</code></pre>
            </article>
            
            <article class="global" data-name="TagOctetString">
               <h3>
                  TagOctetString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagOctetString = 4</code></pre>
            </article>
            
            <article class="global" data-name="TagPrintableString">
               <h3>
                  TagPrintableString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagPrintableString = 19</code></pre>
            </article>
            
            <article class="global" data-name="TagSequence">
               <h3>
                  TagSequence 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagSequence = 16</code></pre>
            </article>
            
            <article class="global" data-name="TagSet">
               <h3>
                  TagSet 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagSet = 17</code></pre>
            </article>
            
            <article class="global" data-name="TagT61String">
               <h3>
                  TagT61String 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagT61String = 20</code></pre>
            </article>
            
            <article class="global" data-name="TagUTCTime">
               <h3>
                  TagUTCTime 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagUTCTime = 23</code></pre>
            </article>
            
            <article class="global" data-name="TagUTF8String">
               <h3>
                  TagUTF8String 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ASN.1 tags represent the type of the following object.</p>
               
               <pre><code>const TagUTF8String = 12</code></pre>
            </article>
            
            <article class="global" data-name="allowAmpersand">
               <h3>
                  allowAmpersand 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const allowAmpersand ampersandFlag = true</code></pre>
            </article>
            
            <article class="global" data-name="allowAsterisk">
               <h3>
                  allowAsterisk 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const allowAsterisk asteriskFlag = true</code></pre>
            </article>
            
            <article class="global" data-name="bigIntType">
               <h3>
                  bigIntType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var bigIntType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="bigOne">
               <h3>
                  bigOne 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var bigOne = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="bitStringType">
               <h3>
                  bitStringType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var bitStringType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="byte00Encoder">
               <h3>
                  byte00Encoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var byte00Encoder encoder = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="byteFFEncoder">
               <h3>
                  byteFFEncoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var byteFFEncoder encoder = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="enumeratedType">
               <h3>
                  enumeratedType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var enumeratedType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagType">
               <h3>
                  flagType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var flagType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="objectIdentifierType">
               <h3>
                  objectIdentifierType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var objectIdentifierType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="rawContentsType">
               <h3>
                  rawContentsType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var rawContentsType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="rawValueType">
               <h3>
                  rawValueType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var rawValueType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="rejectAmpersand">
               <h3>
                  rejectAmpersand 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const rejectAmpersand ampersandFlag = false</code></pre>
            </article>
            
            <article class="global" data-name="rejectAsterisk">
               <h3>
                  rejectAsterisk 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const rejectAsterisk asteriskFlag = false</code></pre>
            </article>
            
            <article class="global" data-name="timeType">
               <h3>
                  timeType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var timeType = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Enumerated">
               <h3>
                  Enumerated
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An Enumerated is represented as a plain int.</p>
               
               <pre><code>type Enumerated int</code></pre>
            </article>
            
            <article class="type" data-name="Flag">
               <h3>
                  Flag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Flag accepts any data and is set to true if present.</p>
               
               <pre><code>type Flag bool</code></pre>
            </article>
            
            <article class="type" data-name="ObjectIdentifier">
               <h3>
                  ObjectIdentifier
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER.</p>
               
               <pre><code>type ObjectIdentifier []int</code></pre>
            </article>
            
            <article class="type" data-name="RawContent">
               <h3>
                  RawContent
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>RawContent is used to signal that the undecoded, DER data needs to be
preserved for a struct. To use it, the first field of the struct must have
this type. It's an error for any of the other fields to have this type.</p>
               
               <pre><code>type RawContent []byte</code></pre>
            </article>
            
            <article class="type" data-name="ampersandFlag">
               <h3>
                  ampersandFlag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type ampersandFlag bool</code></pre>
            </article>
            
            <article class="type" data-name="asteriskFlag">
               <h3>
                  asteriskFlag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type asteriskFlag bool</code></pre>
            </article>
            
            <article class="type" data-name="bitStringEncoder">
               <h3>
                  bitStringEncoder
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type bitStringEncoder BitString</code></pre>
            </article>
            
            <article class="type" data-name="byteEncoder">
               <h3>
                  byteEncoder
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type byteEncoder byte</code></pre>
            </article>
            
            <article class="type" data-name="bytesEncoder">
               <h3>
                  bytesEncoder
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type bytesEncoder []byte</code></pre>
            </article>
            
            <article class="type" data-name="int64Encoder">
               <h3>
                  int64Encoder
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type int64Encoder int64</code></pre>
            </article>
            
            <article class="type" data-name="multiEncoder">
               <h3>
                  multiEncoder
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type multiEncoder []encoder</code></pre>
            </article>
            
            <article class="type" data-name="oidEncoder">
               <h3>
                  oidEncoder
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type oidEncoder []int</code></pre>
            </article>
            
            <article class="type" data-name="setEncoder">
               <h3>
                  setEncoder
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type setEncoder []encoder</code></pre>
            </article>
            
            <article class="type" data-name="stringEncoder">
               <h3>
                  stringEncoder
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type stringEncoder string</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="encoder">
               <h3>
                  encoder
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>encoder represents an ASN.1 element that is waiting to be marshaled.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type encoder interface {
Len() int
Encode(dst []byte)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="BitString">
               <h3>
                  BitString
                  <span class="badge">struct</span>
               </h3>
               
               <p>BitString is the structure to use when you want an ASN.1 BIT STRING type. A
bit string is padded up to the nearest byte in memory and the number of
valid bits is recorded. Padding bits will be zero.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type BitString struct {
Bytes []byte
BitLength int
}</code></pre>
            </article>
            
            <article class="struct" data-name="RawValue">
               <h3>
                  RawValue
                  <span class="badge">struct</span>
               </h3>
               
               <p>A RawValue represents an undecoded ASN.1 object.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type RawValue struct {
Class int
Tag int
IsCompound bool
Bytes []byte
FullBytes []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="StructuralError">
               <h3>
                  StructuralError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A StructuralError suggests that the ASN.1 data is valid, but the Go type
which is receiving it doesn't match.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StructuralError struct {
Msg string
}</code></pre>
            </article>
            
            <article class="struct" data-name="SyntaxError">
               <h3>
                  SyntaxError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A SyntaxError suggests that the ASN.1 data is invalid.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SyntaxError struct {
Msg string
}</code></pre>
            </article>
            
            <article class="struct" data-name="fieldParameters">
               <h3>
                  fieldParameters
                  <span class="badge">struct</span>
               </h3>
               
               <p>fieldParameters is the parsed representation of tag string from a structure field.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fieldParameters struct {
optional bool
explicit bool
application bool
private bool
defaultValue *int64
tag *int
stringType int
timeType int
set bool
omitEmpty bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="invalidUnmarshalError">
               <h3>
                  invalidUnmarshalError
                  <span class="badge">struct</span>
               </h3>
               
               <p>An invalidUnmarshalError describes an invalid argument passed to Unmarshal.
(The argument to Unmarshal must be a non-nil pointer.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type invalidUnmarshalError struct {
Type reflect.Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="tagAndLength">
               <h3>
                  tagAndLength
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type tagAndLength struct {
class int
tag int
length int
isCompound bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="taggedEncoder">
               <h3>
                  taggedEncoder
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type taggedEncoder struct {
scratch [8]byte
tag encoder
body encoder
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="At">
               <h3>
                  At 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>At returns the bit at the given index. If the index is out of range it
returns 0.</p>
               
               <pre><code>func (b BitString) At(i int) int</code></pre>
            </article>
            
            <article class="function" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s setEncoder) Encode(dst []byte)</code></pre>
            </article>
            
            <article class="function" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (oid oidEncoder) Encode(dst []byte)</code></pre>
            </article>
            
            <article class="function" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b bitStringEncoder) Encode(dst []byte)</code></pre>
            </article>
            
            <article class="function" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i int64Encoder) Encode(dst []byte)</code></pre>
            </article>
            
            <article class="function" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *taggedEncoder) Encode(dst []byte)</code></pre>
            </article>
            
            <article class="function" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m multiEncoder) Encode(dst []byte)</code></pre>
            </article>
            
            <article class="function" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s stringEncoder) Encode(dst []byte)</code></pre>
            </article>
            
            <article class="function" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b bytesEncoder) Encode(dst []byte)</code></pre>
            </article>
            
            <article class="function" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c byteEncoder) Encode(dst []byte)</code></pre>
            </article>
            
            <article class="function" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Equal reports whether oi and other represent the same identifier.</p>
               
               <pre><code>func (oi ObjectIdentifier) Equal(other ObjectIdentifier) bool</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *invalidUnmarshalError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e SyntaxError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e StructuralError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b bytesEncoder) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *taggedEncoder) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (oid oidEncoder) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b bitStringEncoder) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i int64Encoder) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s setEncoder) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (m multiEncoder) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s stringEncoder) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c byteEncoder) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Marshal">
               <h3>
                  Marshal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Marshal returns the ASN.1 encoding of val.
In addition to the struct tags recognized by Unmarshal, the following can be
used:
ia5:         causes strings to be marshaled as ASN.1, IA5String values
omitempty:   causes empty slices to be skipped
printable:   causes strings to be marshaled as ASN.1, PrintableString values
utf8:        causes strings to be marshaled as ASN.1, UTF8String values
utc:         causes time.Time to be marshaled as ASN.1, UTCTime values
generalized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values</p>
               
               <pre><code>func Marshal(val any) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalWithParams">
               <h3>
                  MarshalWithParams 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MarshalWithParams allows field parameters to be specified for the
top-level element. The form of the params is the same as the field tags.</p>
               
               <pre><code>func MarshalWithParams(val any, params string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="RightAlign">
               <h3>
                  RightAlign 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RightAlign returns a slice where the padding bits are at the beginning. The
slice may share memory with the BitString.</p>
               
               <pre><code>func (b BitString) RightAlign() []byte</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (oi ObjectIdentifier) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Unmarshal">
               <h3>
                  Unmarshal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Unmarshal parses the DER-encoded ASN.1 data structure b
and uses the reflect package to fill in an arbitrary value pointed at by val.
Because Unmarshal uses the reflect package, the structs
being written to must use upper case field names. If val
is nil or not a pointer, Unmarshal returns an error.
After parsing b, any bytes that were leftover and not used to fill
val will be returned in rest. When parsing a SEQUENCE into a struct,
any trailing elements of the SEQUENCE that do not have matching
fields in val will not be included in rest, as these are considered
valid elements of the SEQUENCE and not trailing data.
- An ASN.1 INTEGER can be written to an int, int32, int64,
or *[big.Int].
If the encoded value does not fit in the Go type,
Unmarshal returns a parse error.
- An ASN.1 BIT STRING can be written to a [BitString].
- An ASN.1 OCTET STRING can be written to a []byte.
- An ASN.1 OBJECT IDENTIFIER can be written to an [ObjectIdentifier].
- An ASN.1 ENUMERATED can be written to an [Enumerated].
- An ASN.1 UTCTIME or GENERALIZEDTIME can be written to a [time.Time].
- An ASN.1 PrintableString, IA5String, or NumericString can be written to a string.
- Any of the above ASN.1 values can be written to an interface{}.
The value stored in the interface has the corresponding Go type.
For integers, that type is int64.
- An ASN.1 SEQUENCE OF x or SET OF x can be written
to a slice if an x can be written to the slice's element type.
- An ASN.1 SEQUENCE or SET can be written to a struct
if each of the elements in the sequence can be
written to the corresponding element in the struct.
The following tags on struct fields have special meaning to Unmarshal:
application specifies that an APPLICATION tag is used
private     specifies that a PRIVATE tag is used
default:x   sets the default value for optional integer fields (only used if optional is also present)
explicit    specifies that an additional, explicit tag wraps the implicit one
optional    marks the field as ASN.1 OPTIONAL
set         causes a SET, rather than a SEQUENCE type to be expected
tag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC
When decoding an ASN.1 value with an IMPLICIT tag into a string field,
Unmarshal will default to a PrintableString, which doesn't support
characters such as '@' and '&'. To force other encodings, use the following
tags:
ia5     causes strings to be unmarshaled as ASN.1 IA5String values
numeric causes strings to be unmarshaled as ASN.1 NumericString values
utf8    causes strings to be unmarshaled as ASN.1 UTF8String values
If the type of the first field of a structure is RawContent then the raw
ASN1 contents of the struct will be stored in it.
If the name of a slice type ends with "SET" then it's treated as if
the "set" tag was set on it. This results in interpreting the type as a
SET OF x rather than a SEQUENCE OF x. This can be used with nested slices
where a struct tag cannot be given.
Other ASN.1 types are not supported; if it encounters them,
Unmarshal returns a parse error.</p>
               
               <pre><code>func Unmarshal(b []byte, val any) (rest []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalWithParams">
               <h3>
                  UnmarshalWithParams 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>UnmarshalWithParams allows field parameters to be specified for the
top-level element. The form of the params is the same as the field tags.</p>
               
               <pre><code>func UnmarshalWithParams(b []byte, val any, params string) (rest []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="appendBase128Int">
               <h3>
                  appendBase128Int 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendBase128Int(dst []byte, n int64) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendFourDigits">
               <h3>
                  appendFourDigits 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendFourDigits(dst []byte, v int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendGeneralizedTime">
               <h3>
                  appendGeneralizedTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendGeneralizedTime(dst []byte, t time.Time) (ret []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="appendLength">
               <h3>
                  appendLength 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendLength(dst []byte, i int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendTagAndLength">
               <h3>
                  appendTagAndLength 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendTagAndLength(dst []byte, t tagAndLength) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendTimeCommon">
               <h3>
                  appendTimeCommon 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendTimeCommon(dst []byte, t time.Time) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendTwoDigits">
               <h3>
                  appendTwoDigits 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendTwoDigits(dst []byte, v int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendUTCTime">
               <h3>
                  appendUTCTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendUTCTime(dst []byte, t time.Time) (ret []byte, err error)</code></pre>
            </article>
            
            <article class="function" data-name="base128IntLength">
               <h3>
                  base128IntLength 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func base128IntLength(n int64) int</code></pre>
            </article>
            
            <article class="function" data-name="canHaveDefaultValue">
               <h3>
                  canHaveDefaultValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>canHaveDefaultValue reports whether k is a Kind that we will set a default
value for. (A signed integer, essentially.)</p>
               
               <pre><code>func canHaveDefaultValue(k reflect.Kind) bool</code></pre>
            </article>
            
            <article class="function" data-name="checkInteger">
               <h3>
                  checkInteger 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkInteger returns nil if the given bytes are a valid DER-encoded
INTEGER and an error otherwise.</p>
               
               <pre><code>func checkInteger(bytes []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="getUniversalType">
               <h3>
                  getUniversalType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Given a reflected Go type, getUniversalType returns the default tag number
and expected compound flag.</p>
               
               <pre><code>func getUniversalType(t reflect.Type) (matchAny bool, tagNumber int, isCompound bool, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="invalidLength">
               <h3>
                  invalidLength 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>invalidLength reports whether offset + length > sliceLength, or if the
addition would overflow.</p>
               
               <pre><code>func invalidLength(offset int, length int, sliceLength int) bool</code></pre>
            </article>
            
            <article class="function" data-name="isNumeric">
               <h3>
                  isNumeric 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isNumeric reports whether the given b is in the ASN.1 NumericString set.</p>
               
               <pre><code>func isNumeric(b byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="isPrintable">
               <h3>
                  isPrintable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isPrintable reports whether the given b is in the ASN.1 PrintableString set.
If asterisk is allowAsterisk then '*' is also allowed, reflecting existing
practice. If ampersand is allowAmpersand then '&' is allowed as well.</p>
               
               <pre><code>func isPrintable(b byte, asterisk asteriskFlag, ampersand ampersandFlag) bool</code></pre>
            </article>
            
            <article class="function" data-name="lengthLength">
               <h3>
                  lengthLength 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lengthLength(i int) (numBytes int)</code></pre>
            </article>
            
            <article class="function" data-name="makeBigInt">
               <h3>
                  makeBigInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeBigInt(n *big.Int) (encoder, error)</code></pre>
            </article>
            
            <article class="function" data-name="makeBody">
               <h3>
                  makeBody 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeBody(value reflect.Value, params fieldParameters) (e encoder, err error)</code></pre>
            </article>
            
            <article class="function" data-name="makeField">
               <h3>
                  makeField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeField(v reflect.Value, params fieldParameters) (e encoder, err error)</code></pre>
            </article>
            
            <article class="function" data-name="makeGeneralizedTime">
               <h3>
                  makeGeneralizedTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeGeneralizedTime(t time.Time) (e encoder, err error)</code></pre>
            </article>
            
            <article class="function" data-name="makeIA5String">
               <h3>
                  makeIA5String 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeIA5String(s string) (e encoder, err error)</code></pre>
            </article>
            
            <article class="function" data-name="makeNumericString">
               <h3>
                  makeNumericString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeNumericString(s string) (e encoder, err error)</code></pre>
            </article>
            
            <article class="function" data-name="makeObjectIdentifier">
               <h3>
                  makeObjectIdentifier 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeObjectIdentifier(oid []int) (e encoder, err error)</code></pre>
            </article>
            
            <article class="function" data-name="makePrintableString">
               <h3>
                  makePrintableString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makePrintableString(s string) (e encoder, err error)</code></pre>
            </article>
            
            <article class="function" data-name="makeUTCTime">
               <h3>
                  makeUTCTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeUTCTime(t time.Time) (e encoder, err error)</code></pre>
            </article>
            
            <article class="function" data-name="makeUTF8String">
               <h3>
                  makeUTF8String 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeUTF8String(s string) encoder</code></pre>
            </article>
            
            <article class="function" data-name="outsideUTCRange">
               <h3>
                  outsideUTCRange 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func outsideUTCRange(t time.Time) bool</code></pre>
            </article>
            
            <article class="function" data-name="parseBMPString">
               <h3>
                  parseBMPString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseBMPString parses an ASN.1 BMPString (Basic Multilingual Plane of
ISO/IEC/ITU 10646-1) from the given byte slice and returns it.</p>
               
               <pre><code>func parseBMPString(bmpString []byte) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="parseBase128Int">
               <h3>
                  parseBase128Int 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseBase128Int parses a base-128 encoded int from the given offset in the
given byte slice. It returns the value and the new offset.</p>
               
               <pre><code>func parseBase128Int(bytes []byte, initOffset int) (ret int, offset int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseBigInt">
               <h3>
                  parseBigInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseBigInt treats the given bytes as a big-endian, signed integer and returns
the result.</p>
               
               <pre><code>func parseBigInt(bytes []byte) (*big.Int, error)</code></pre>
            </article>
            
            <article class="function" data-name="parseBitString">
               <h3>
                  parseBitString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseBitString parses an ASN.1 bit string from the given byte slice and returns it.</p>
               
               <pre><code>func parseBitString(bytes []byte) (ret BitString, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseBool">
               <h3>
                  parseBool 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseBool(bytes []byte) (ret bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseField">
               <h3>
                  parseField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseField is the main parsing function. Given a byte slice and an offset
into the array, it will try to parse a suitable ASN.1 value out and store it
in the given Value.</p>
               
               <pre><code>func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParameters) (offset int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseFieldParameters">
               <h3>
                  parseFieldParameters 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Given a tag string with the format specified in the package comment,
parseFieldParameters will parse it into a fieldParameters structure,
ignoring unknown parts of the string.</p>
               
               <pre><code>func parseFieldParameters(str string) (ret fieldParameters)</code></pre>
            </article>
            
            <article class="function" data-name="parseGeneralizedTime">
               <h3>
                  parseGeneralizedTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseGeneralizedTime parses the GeneralizedTime from the given byte slice
and returns the resulting time.</p>
               
               <pre><code>func parseGeneralizedTime(bytes []byte) (ret time.Time, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseIA5String">
               <h3>
                  parseIA5String 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseIA5String parses an ASN.1 IA5String (ASCII string) from the given
byte slice and returns it.</p>
               
               <pre><code>func parseIA5String(bytes []byte) (ret string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseInt32">
               <h3>
                  parseInt32 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseInt32 treats the given bytes as a big-endian, signed integer and returns
the result.</p>
               
               <pre><code>func parseInt32(bytes []byte) (int32, error)</code></pre>
            </article>
            
            <article class="function" data-name="parseInt64">
               <h3>
                  parseInt64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseInt64 treats the given bytes as a big-endian, signed integer and
returns the result.</p>
               
               <pre><code>func parseInt64(bytes []byte) (ret int64, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseNumericString">
               <h3>
                  parseNumericString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseNumericString parses an ASN.1 NumericString from the given byte array
and returns it.</p>
               
               <pre><code>func parseNumericString(bytes []byte) (ret string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseObjectIdentifier">
               <h3>
                  parseObjectIdentifier 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseObjectIdentifier parses an OBJECT IDENTIFIER from the given bytes and
returns it. An object identifier is a sequence of variable length integers
that are assigned in a hierarchy.</p>
               
               <pre><code>func parseObjectIdentifier(bytes []byte) (s ObjectIdentifier, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parsePrintableString">
               <h3>
                  parsePrintableString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parsePrintableString parses an ASN.1 PrintableString from the given byte
array and returns it.</p>
               
               <pre><code>func parsePrintableString(bytes []byte) (ret string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseSequenceOf">
               <h3>
                  parseSequenceOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseSequenceOf is used for SEQUENCE OF and SET OF values. It tries to parse
a number of ASN.1 values from the given byte slice and returns them as a
slice of Go values of the given type.</p>
               
               <pre><code>func parseSequenceOf(bytes []byte, sliceType reflect.Type, elemType reflect.Type) (ret reflect.Value, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseT61String">
               <h3>
                  parseT61String 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseT61String parses an ASN.1 T61String (8-bit clean string) from the given
byte slice and returns it.</p>
               
               <pre><code>func parseT61String(bytes []byte) (ret string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseTagAndLength">
               <h3>
                  parseTagAndLength 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseTagAndLength parses an ASN.1 tag and length pair from the given offset
into a byte slice. It returns the parsed data and the new offset. SET and
SET OF (tag 17) are mapped to SEQUENCE and SEQUENCE OF (tag 16) since we
don't distinguish between ordered and unordered objects in this code.</p>
               
               <pre><code>func parseTagAndLength(bytes []byte, initOffset int) (ret tagAndLength, offset int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseUTCTime">
               <h3>
                  parseUTCTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseUTCTime(bytes []byte) (ret time.Time, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseUTF8String">
               <h3>
                  parseUTF8String 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseUTF8String parses an ASN.1 UTF8String (raw UTF-8) from the given byte
array and returns it.</p>
               
               <pre><code>func parseUTF8String(bytes []byte) (ret string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="setDefaultValue">
               <h3>
                  setDefaultValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>setDefaultValue is used to install a default value, from a tag string, into
a Value. It is successful if the field was optional, even if a default value
wasn't provided or it failed to install it into the Value.</p>
               
               <pre><code>func setDefaultValue(v reflect.Value, params fieldParameters) (ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="stripTagAndLength">
               <h3>
                  stripTagAndLength 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func stripTagAndLength(in []byte) []byte</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
