<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>context - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>context</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"errors"
"internal/reflectlite"
"sync"
"sync/atomic"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="Canceled" data-name="Canceled">
               <h3>
                  Canceled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Canceled" class="anchor" title="Link to Canceled">#</a>
               </h3>
               
                  <p class="doc-comment">Canceled is the error returned by [Context.Err] when the context is canceled
for some reason other than its deadline passing.</p>
               
               <pre><code class="language-go">var Canceled = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DeadlineExceeded" data-name="DeadlineExceeded">
               <h3>
                  DeadlineExceeded 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#DeadlineExceeded" class="anchor" title="Link to DeadlineExceeded">#</a>
               </h3>
               
                  <p class="doc-comment">DeadlineExceeded is the error returned by [Context.Err] when the context is canceled
due to its deadline passing.</p>
               
               <pre><code class="language-go">var DeadlineExceeded error = deadlineExceededError{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cancelCtxKey" data-name="cancelCtxKey">
               <h3>
                  cancelCtxKey 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cancelCtxKey" class="anchor" title="Link to cancelCtxKey">#</a>
               </h3>
               
                  <p class="doc-comment">&cancelCtxKey is the key that a cancelCtx returns itself for.</p>
               
               <pre><code class="language-go">var cancelCtxKey int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="closedchan" data-name="closedchan">
               <h3>
                  closedchan 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#closedchan" class="anchor" title="Link to closedchan">#</a>
               </h3>
               
                  <p class="doc-comment">closedchan is a reusable closed channel.</p>
               
               <pre><code class="language-go">var closedchan = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goroutines" data-name="goroutines">
               <h3>
                  goroutines 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goroutines" class="anchor" title="Link to goroutines">#</a>
               </h3>
               
                  <p class="doc-comment">goroutines counts the number of goroutines ever created; for testing.</p>
               
               <pre><code class="language-go">var goroutines atomic.Int32</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="CancelCauseFunc" data-name="CancelCauseFunc">
               <h3>
                  CancelCauseFunc
                  <span class="badge type-badge">type</span>
                  <a href="#CancelCauseFunc" class="anchor" title="Link to CancelCauseFunc">#</a>
               </h3>
               
               <p>A CancelCauseFunc behaves like a [CancelFunc] but additionally sets the cancellation cause.
This cause can be retrieved by calling [Cause] on the canceled Context or on
any of its derived Contexts.
If the context has already been canceled, CancelCauseFunc does not set the cause.
For example, if childContext is derived from parentContext:
- if parentContext is canceled with cause1 before childContext is canceled with cause2,
then Cause(parentContext) == Cause(childContext) == cause1
- if childContext is canceled with cause2 before parentContext is canceled with cause1,
then Cause(parentContext) == cause1 and Cause(childContext) == cause2</p>
               
               <pre><code class="language-go">type CancelCauseFunc func(cause error)</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="CancelFunc" data-name="CancelFunc">
               <h3>
                  CancelFunc
                  <span class="badge type-badge">type</span>
                  <a href="#CancelFunc" class="anchor" title="Link to CancelFunc">#</a>
               </h3>
               
               <p>A CancelFunc tells an operation to abandon its work.
A CancelFunc does not wait for the work to stop.
A CancelFunc may be called by multiple goroutines simultaneously.
After the first call, subsequent calls to a CancelFunc do nothing.</p>
               
               <pre><code class="language-go">type CancelFunc func()</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Context" data-name="Context">
               <h3>
                  Context
                  <span class="badge interface-badge">interface</span>
                  <a href="#Context" class="anchor" title="Link to Context">#</a>
               </h3>
               
               <p>A Context carries a deadline, a cancellation signal, and other values across
API boundaries.
Context's methods may be called by multiple goroutines simultaneously.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Context interface {
Deadline() (deadline time.Time, ok bool)
Done() <-chan struct{...}
Err() error
Value(key any) any
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="afterFuncer" data-name="afterFuncer">
               <h3>
                  afterFuncer
                  <span class="badge interface-badge">interface</span>
                  <a href="#afterFuncer" class="anchor" title="Link to afterFuncer">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type afterFuncer interface {
AfterFunc(func()) func() bool
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="canceler" data-name="canceler">
               <h3>
                  canceler
                  <span class="badge interface-badge">interface</span>
                  <a href="#canceler" class="anchor" title="Link to canceler">#</a>
               </h3>
               
               <p>A canceler is a context type that can be canceled directly. The
implementations are *cancelCtx and *timerCtx.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type canceler interface {
cancel(removeFromParent bool, err error, cause error)
Done() <-chan struct{...}
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="stringer" data-name="stringer">
               <h3>
                  stringer
                  <span class="badge interface-badge">interface</span>
                  <a href="#stringer" class="anchor" title="Link to stringer">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type stringer interface {
String() string
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="afterFuncCtx" data-name="afterFuncCtx">
               <h3>
                  afterFuncCtx
                  <span class="badge">struct</span>
                  <a href="#afterFuncCtx" class="anchor" title="Link to afterFuncCtx">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type afterFuncCtx struct {
cancelCtx
once sync.Once
f func()
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="backgroundCtx" data-name="backgroundCtx">
               <h3>
                  backgroundCtx
                  <span class="badge">struct</span>
                  <a href="#backgroundCtx" class="anchor" title="Link to backgroundCtx">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type backgroundCtx struct {
emptyCtx
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cancelCtx" data-name="cancelCtx">
               <h3>
                  cancelCtx
                  <span class="badge">struct</span>
                  <a href="#cancelCtx" class="anchor" title="Link to cancelCtx">#</a>
               </h3>
               
               <p>A cancelCtx can be canceled. When canceled, it also cancels any children
that implement canceler.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cancelCtx struct {
Context
mu sync.Mutex
done atomic.Value
children map[canceler]struct{...}
err error
cause error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="deadlineExceededError" data-name="deadlineExceededError">
               <h3>
                  deadlineExceededError
                  <span class="badge">struct</span>
                  <a href="#deadlineExceededError" class="anchor" title="Link to deadlineExceededError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type deadlineExceededError struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="emptyCtx" data-name="emptyCtx">
               <h3>
                  emptyCtx
                  <span class="badge">struct</span>
                  <a href="#emptyCtx" class="anchor" title="Link to emptyCtx">#</a>
               </h3>
               
               <p>An emptyCtx is never canceled, has no values, and has no deadline.
It is the common base of backgroundCtx and todoCtx.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type emptyCtx struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="stopCtx" data-name="stopCtx">
               <h3>
                  stopCtx
                  <span class="badge">struct</span>
                  <a href="#stopCtx" class="anchor" title="Link to stopCtx">#</a>
               </h3>
               
               <p>A stopCtx is used as the parent context of a cancelCtx when
an AfterFunc has been registered with the parent.
It holds the stop function used to unregister the AfterFunc.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type stopCtx struct {
Context
stop func() bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="timerCtx" data-name="timerCtx">
               <h3>
                  timerCtx
                  <span class="badge">struct</span>
                  <a href="#timerCtx" class="anchor" title="Link to timerCtx">#</a>
               </h3>
               
               <p>A timerCtx carries a timer and a deadline. It embeds a cancelCtx to
implement Done and Err. It implements cancel by stopping its timer then
delegating to cancelCtx.cancel.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type timerCtx struct {
cancelCtx
timer *time.Timer
deadline time.Time
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="todoCtx" data-name="todoCtx">
               <h3>
                  todoCtx
                  <span class="badge">struct</span>
                  <a href="#todoCtx" class="anchor" title="Link to todoCtx">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type todoCtx struct {
emptyCtx
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="valueCtx" data-name="valueCtx">
               <h3>
                  valueCtx
                  <span class="badge">struct</span>
                  <a href="#valueCtx" class="anchor" title="Link to valueCtx">#</a>
               </h3>
               
               <p>A valueCtx carries a key-value pair. It implements Value for that key and
delegates all other calls to the embedded Context.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type valueCtx struct {
Context
key any
val any
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="withoutCancelCtx" data-name="withoutCancelCtx">
               <h3>
                  withoutCancelCtx
                  <span class="badge">struct</span>
                  <a href="#withoutCancelCtx" class="anchor" title="Link to withoutCancelCtx">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type withoutCancelCtx struct {
c Context
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AfterFunc" data-name="AfterFunc">
               <h3>
                  AfterFunc 
                  <span class="badge">function</span>
                  
                  <a href="#AfterFunc" class="anchor" title="Link to AfterFunc">#</a>
               </h3>
               
               <p>AfterFunc arranges to call f in its own goroutine after ctx is canceled.
If ctx is already canceled, AfterFunc calls f immediately in its own goroutine.
Multiple calls to AfterFunc on a context operate independently;
one does not replace another.
Calling the returned stop function stops the association of ctx with f.
It returns true if the call stopped f from being run.
If stop returns false,
either the context is canceled and f has been started in its own goroutine;
or f was already stopped.
The stop function does not wait for f to complete before returning.
If the caller needs to know whether f is completed,
it must coordinate with f explicitly.
If ctx has a "AfterFunc(func()) func() bool" method,
AfterFunc will use it to schedule the call.</p>
               
               <pre><code class="language-go">func AfterFunc(ctx Context, f func()) (stop func() bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Background" data-name="Background">
               <h3>
                  Background 
                  <span class="badge">function</span>
                  
                  <a href="#Background" class="anchor" title="Link to Background">#</a>
               </h3>
               
               <p>Background returns a non-nil, empty [Context]. It is never canceled, has no
values, and has no deadline. It is typically used by the main function,
initialization, and tests, and as the top-level Context for incoming
requests.</p>
               
               <pre><code class="language-go">func Background() Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cause" data-name="Cause">
               <h3>
                  Cause 
                  <span class="badge">function</span>
                  
                  <a href="#Cause" class="anchor" title="Link to Cause">#</a>
               </h3>
               
               <p>Cause returns a non-nil error explaining why c was canceled.
The first cancellation of c or one of its parents sets the cause.
If that cancellation happened via a call to CancelCauseFunc(err),
then [Cause] returns err.
Otherwise Cause(c) returns the same value as c.Err().
Cause returns nil if c has not been canceled yet.</p>
               
               <pre><code class="language-go">func Cause(c Context) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Deadline" data-name="Deadline">
               <h3>
                  Deadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Deadline" class="anchor" title="Link to Deadline">#</a>
               </h3>
               
               <pre><code class="language-go">func (emptyCtx) Deadline() (deadline time.Time, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Deadline" data-name="Deadline">
               <h3>
                  Deadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Deadline" class="anchor" title="Link to Deadline">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *timerCtx) Deadline() (deadline time.Time, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Deadline" data-name="Deadline">
               <h3>
                  Deadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Deadline" class="anchor" title="Link to Deadline">#</a>
               </h3>
               
               <pre><code class="language-go">func (withoutCancelCtx) Deadline() (deadline time.Time, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Done" data-name="Done">
               <h3>
                  Done 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Done" class="anchor" title="Link to Done">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *cancelCtx) Done() (<-chan struct{...})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Done" data-name="Done">
               <h3>
                  Done 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Done" class="anchor" title="Link to Done">#</a>
               </h3>
               
               <pre><code class="language-go">func (withoutCancelCtx) Done() (<-chan struct{...})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Done" data-name="Done">
               <h3>
                  Done 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Done" class="anchor" title="Link to Done">#</a>
               </h3>
               
               <pre><code class="language-go">func (emptyCtx) Done() (<-chan struct{...})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Err" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Err" class="anchor" title="Link to Err">#</a>
               </h3>
               
               <pre><code class="language-go">func (emptyCtx) Err() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Err" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Err" class="anchor" title="Link to Err">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *cancelCtx) Err() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Err" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Err" class="anchor" title="Link to Err">#</a>
               </h3>
               
               <pre><code class="language-go">func (withoutCancelCtx) Err() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (deadlineExceededError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *cancelCtx) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *valueCtx) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (todoCtx) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (backgroundCtx) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *timerCtx) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (c withoutCancelCtx) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TODO" data-name="TODO">
               <h3>
                  TODO 
                  <span class="badge">function</span>
                  
                  <a href="#TODO" class="anchor" title="Link to TODO">#</a>
               </h3>
               
               <p>TODO returns a non-nil, empty [Context]. Code should use context.TODO when
it's unclear which Context to use or it is not yet available (because the
surrounding function has not yet been extended to accept a Context
parameter).</p>
               
               <pre><code class="language-go">func TODO() Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Temporary" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Temporary" class="anchor" title="Link to Temporary">#</a>
               </h3>
               
               <pre><code class="language-go">func (deadlineExceededError) Temporary() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Timeout" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Timeout" class="anchor" title="Link to Timeout">#</a>
               </h3>
               
               <pre><code class="language-go">func (deadlineExceededError) Timeout() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <pre><code class="language-go">func (emptyCtx) Value(key any) any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *cancelCtx) Value(key any) any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <pre><code class="language-go">func (c withoutCancelCtx) Value(key any) any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *valueCtx) Value(key any) any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithCancel" data-name="WithCancel">
               <h3>
                  WithCancel 
                  <span class="badge">function</span>
                  
                  <a href="#WithCancel" class="anchor" title="Link to WithCancel">#</a>
               </h3>
               
               <p>WithCancel returns a derived context that points to the parent context
but has a new Done channel. The returned context's Done channel is closed
when the returned cancel function is called or when the parent context's
Done channel is closed, whichever happens first.
Canceling this context releases resources associated with it, so code should
call cancel as soon as the operations running in this [Context] complete.</p>
               
               <pre><code class="language-go">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithCancelCause" data-name="WithCancelCause">
               <h3>
                  WithCancelCause 
                  <span class="badge">function</span>
                  
                  <a href="#WithCancelCause" class="anchor" title="Link to WithCancelCause">#</a>
               </h3>
               
               <p>WithCancelCause behaves like [WithCancel] but returns a [CancelCauseFunc] instead of a [CancelFunc].
Calling cancel with a non-nil error (the "cause") records that error in ctx;
it can then be retrieved using Cause(ctx).
Calling cancel with nil sets the cause to Canceled.
Example use:
ctx, cancel := context.WithCancelCause(parent)
cancel(myError)
ctx.Err() // returns context.Canceled
context.Cause(ctx) // returns myError</p>
               
               <pre><code class="language-go">func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithDeadline" data-name="WithDeadline">
               <h3>
                  WithDeadline 
                  <span class="badge">function</span>
                  
                  <a href="#WithDeadline" class="anchor" title="Link to WithDeadline">#</a>
               </h3>
               
               <p>WithDeadline returns a derived context that points to the parent context
but has the deadline adjusted to be no later than d. If the parent's
deadline is already earlier than d, WithDeadline(parent, d) is semantically
equivalent to parent. The returned [Context.Done] channel is closed when
the deadline expires, when the returned cancel function is called,
or when the parent context's Done channel is closed, whichever happens first.
Canceling this context releases resources associated with it, so code should
call cancel as soon as the operations running in this [Context] complete.</p>
               
               <pre><code class="language-go">func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithDeadlineCause" data-name="WithDeadlineCause">
               <h3>
                  WithDeadlineCause 
                  <span class="badge">function</span>
                  
                  <a href="#WithDeadlineCause" class="anchor" title="Link to WithDeadlineCause">#</a>
               </h3>
               
               <p>WithDeadlineCause behaves like [WithDeadline] but also sets the cause of the
returned Context when the deadline is exceeded. The returned [CancelFunc] does
not set the cause.</p>
               
               <pre><code class="language-go">func WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithTimeout" data-name="WithTimeout">
               <h3>
                  WithTimeout 
                  <span class="badge">function</span>
                  
                  <a href="#WithTimeout" class="anchor" title="Link to WithTimeout">#</a>
               </h3>
               
               <p>WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).
Canceling this context releases resources associated with it, so code should
call cancel as soon as the operations running in this [Context] complete:
func slowOperationWithTimeout(ctx context.Context) (Result, error) {
ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
defer cancel()  // releases resources if slowOperation completes before timeout elapses
return slowOperation(ctx)
}</p>
               
               <pre><code class="language-go">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithTimeoutCause" data-name="WithTimeoutCause">
               <h3>
                  WithTimeoutCause 
                  <span class="badge">function</span>
                  
                  <a href="#WithTimeoutCause" class="anchor" title="Link to WithTimeoutCause">#</a>
               </h3>
               
               <p>WithTimeoutCause behaves like [WithTimeout] but also sets the cause of the
returned Context when the timeout expires. The returned [CancelFunc] does
not set the cause.</p>
               
               <pre><code class="language-go">func WithTimeoutCause(parent Context, timeout time.Duration, cause error) (Context, CancelFunc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithValue" data-name="WithValue">
               <h3>
                  WithValue 
                  <span class="badge">function</span>
                  
                  <a href="#WithValue" class="anchor" title="Link to WithValue">#</a>
               </h3>
               
               <p>WithValue returns a derived context that points to the parent Context.
In the derived context, the value associated with key is val.
Use context Values only for request-scoped data that transits processes and
APIs, not for passing optional parameters to functions.
The provided key must be comparable and should not be of type
string or any other built-in type to avoid collisions between
packages using context. Users of WithValue should define their own
types for keys. To avoid allocating when assigning to an
interface{}, context keys often have concrete type
struct{}. Alternatively, exported context key variables' static
type should be a pointer or interface.</p>
               
               <pre><code class="language-go">func WithValue(parent Context, key any, val any) Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithoutCancel" data-name="WithoutCancel">
               <h3>
                  WithoutCancel 
                  <span class="badge">function</span>
                  
                  <a href="#WithoutCancel" class="anchor" title="Link to WithoutCancel">#</a>
               </h3>
               
               <p>WithoutCancel returns a derived context that points to the parent context
and is not canceled when parent is canceled.
The returned context returns no Deadline or Err, and its Done channel is nil.
Calling [Cause] on the returned context returns nil.</p>
               
               <pre><code class="language-go">func WithoutCancel(parent Context) Context</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cancel" data-name="cancel">
               <h3>
                  cancel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cancel" class="anchor" title="Link to cancel">#</a>
               </h3>
               
               <p>cancel closes c.done, cancels each of c's children, and, if
removeFromParent is true, removes c from its parent's children.
cancel sets c.cause to cause if this is the first time c is canceled.</p>
               
               <pre><code class="language-go">func (c *cancelCtx) cancel(removeFromParent bool, err error, cause error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cancel" data-name="cancel">
               <h3>
                  cancel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cancel" class="anchor" title="Link to cancel">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *afterFuncCtx) cancel(removeFromParent bool, err error, cause error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cancel" data-name="cancel">
               <h3>
                  cancel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cancel" class="anchor" title="Link to cancel">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *timerCtx) cancel(removeFromParent bool, err error, cause error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="contextName" data-name="contextName">
               <h3>
                  contextName 
                  <span class="badge">function</span>
                  
                  <a href="#contextName" class="anchor" title="Link to contextName">#</a>
               </h3>
               
               <pre><code class="language-go">func contextName(c Context) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parentCancelCtx" data-name="parentCancelCtx">
               <h3>
                  parentCancelCtx 
                  <span class="badge">function</span>
                  
                  <a href="#parentCancelCtx" class="anchor" title="Link to parentCancelCtx">#</a>
               </h3>
               
               <p>parentCancelCtx returns the underlying *cancelCtx for parent.
It does this by looking up parent.Value(&cancelCtxKey) to find
the innermost enclosing *cancelCtx and then checking whether
parent.Done() matches that *cancelCtx. (If not, the *cancelCtx
has been wrapped in a custom implementation providing a
different done channel, in which case we should not bypass it.)</p>
               
               <pre><code class="language-go">func parentCancelCtx(parent Context) (*cancelCtx, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="propagateCancel" data-name="propagateCancel">
               <h3>
                  propagateCancel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#propagateCancel" class="anchor" title="Link to propagateCancel">#</a>
               </h3>
               
               <p>propagateCancel arranges for child to be canceled when parent is.
It sets the parent context of cancelCtx.</p>
               
               <pre><code class="language-go">func (c *cancelCtx) propagateCancel(parent Context, child canceler)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeChild" data-name="removeChild">
               <h3>
                  removeChild 
                  <span class="badge">function</span>
                  
                  <a href="#removeChild" class="anchor" title="Link to removeChild">#</a>
               </h3>
               
               <p>removeChild removes a context from its parent.</p>
               
               <pre><code class="language-go">func removeChild(parent Context, child canceler)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stringify" data-name="stringify">
               <h3>
                  stringify 
                  <span class="badge">function</span>
                  
                  <a href="#stringify" class="anchor" title="Link to stringify">#</a>
               </h3>
               
               <p>stringify tries a bit to stringify v, without using fmt, since we don't
want context depending on the unicode tables. This is only used by
*valueCtx.String().</p>
               
               <pre><code class="language-go">func stringify(v any) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="value" data-name="value">
               <h3>
                  value 
                  <span class="badge">function</span>
                  
                  <a href="#value" class="anchor" title="Link to value">#</a>
               </h3>
               
               <pre><code class="language-go">func value(c Context, key any) any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="withCancel" data-name="withCancel">
               <h3>
                  withCancel 
                  <span class="badge">function</span>
                  
                  <a href="#withCancel" class="anchor" title="Link to withCancel">#</a>
               </h3>
               
               <pre><code class="language-go">func withCancel(parent Context) *cancelCtx</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>