<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - context</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>context</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"errors"
"internal/reflectlite"
"sync"
"sync/atomic"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="Canceled">
               <h3>
                  Canceled 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Canceled is the error returned by [Context.Err] when the context is canceled
for some reason other than its deadline passing.</p>
               
               <pre><code>var Canceled = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="DeadlineExceeded">
               <h3>
                  DeadlineExceeded 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>DeadlineExceeded is the error returned by [Context.Err] when the context is canceled
due to its deadline passing.</p>
               
               <pre><code>var DeadlineExceeded error = deadlineExceededError{...}</code></pre>
            </article>
            
            <article class="global" data-name="cancelCtxKey">
               <h3>
                  cancelCtxKey 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>&cancelCtxKey is the key that a cancelCtx returns itself for.</p>
               
               <pre><code>var cancelCtxKey int</code></pre>
            </article>
            
            <article class="global" data-name="closedchan">
               <h3>
                  closedchan 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>closedchan is a reusable closed channel.</p>
               
               <pre><code>var closedchan = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="goroutines">
               <h3>
                  goroutines 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>goroutines counts the number of goroutines ever created; for testing.</p>
               
               <pre><code>var goroutines atomic.Int32</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="CancelCauseFunc">
               <h3>
                  CancelCauseFunc
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A CancelCauseFunc behaves like a [CancelFunc] but additionally sets the cancellation cause.
This cause can be retrieved by calling [Cause] on the canceled Context or on
any of its derived Contexts.
If the context has already been canceled, CancelCauseFunc does not set the cause.
For example, if childContext is derived from parentContext:
- if parentContext is canceled with cause1 before childContext is canceled with cause2,
then Cause(parentContext) == Cause(childContext) == cause1
- if childContext is canceled with cause2 before parentContext is canceled with cause1,
then Cause(parentContext) == cause1 and Cause(childContext) == cause2</p>
               
               <pre><code>type CancelCauseFunc func(cause error)</code></pre>
            </article>
            
            <article class="type" data-name="CancelFunc">
               <h3>
                  CancelFunc
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A CancelFunc tells an operation to abandon its work.
A CancelFunc does not wait for the work to stop.
A CancelFunc may be called by multiple goroutines simultaneously.
After the first call, subsequent calls to a CancelFunc do nothing.</p>
               
               <pre><code>type CancelFunc func()</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Context">
               <h3>
                  Context
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A Context carries a deadline, a cancellation signal, and other values across
API boundaries.
Context's methods may be called by multiple goroutines simultaneously.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Context interface {
Deadline() (deadline time.Time, ok bool)
Done() <-chan struct{...}
Err() error
Value(key any) any
}</code></pre>
            </article>
            
            <article class="interface" data-name="afterFuncer">
               <h3>
                  afterFuncer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type afterFuncer interface {
AfterFunc(func()) func() bool
}</code></pre>
            </article>
            
            <article class="interface" data-name="canceler">
               <h3>
                  canceler
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A canceler is a context type that can be canceled directly. The
implementations are *cancelCtx and *timerCtx.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type canceler interface {
cancel(removeFromParent bool, err error, cause error)
Done() <-chan struct{...}
}</code></pre>
            </article>
            
            <article class="interface" data-name="stringer">
               <h3>
                  stringer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type stringer interface {
String() string
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="afterFuncCtx">
               <h3>
                  afterFuncCtx
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type afterFuncCtx struct {
cancelCtx
once sync.Once
f func()
}</code></pre>
            </article>
            
            <article class="struct" data-name="backgroundCtx">
               <h3>
                  backgroundCtx
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type backgroundCtx struct {
emptyCtx
}</code></pre>
            </article>
            
            <article class="struct" data-name="cancelCtx">
               <h3>
                  cancelCtx
                  <span class="badge">struct</span>
               </h3>
               
               <p>A cancelCtx can be canceled. When canceled, it also cancels any children
that implement canceler.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cancelCtx struct {
Context
mu sync.Mutex
done atomic.Value
children map[canceler]struct{...}
err error
cause error
}</code></pre>
            </article>
            
            <article class="struct" data-name="deadlineExceededError">
               <h3>
                  deadlineExceededError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type deadlineExceededError struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="emptyCtx">
               <h3>
                  emptyCtx
                  <span class="badge">struct</span>
               </h3>
               
               <p>An emptyCtx is never canceled, has no values, and has no deadline.
It is the common base of backgroundCtx and todoCtx.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type emptyCtx struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="stopCtx">
               <h3>
                  stopCtx
                  <span class="badge">struct</span>
               </h3>
               
               <p>A stopCtx is used as the parent context of a cancelCtx when
an AfterFunc has been registered with the parent.
It holds the stop function used to unregister the AfterFunc.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stopCtx struct {
Context
stop func() bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="timerCtx">
               <h3>
                  timerCtx
                  <span class="badge">struct</span>
               </h3>
               
               <p>A timerCtx carries a timer and a deadline. It embeds a cancelCtx to
implement Done and Err. It implements cancel by stopping its timer then
delegating to cancelCtx.cancel.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type timerCtx struct {
cancelCtx
timer *time.Timer
deadline time.Time
}</code></pre>
            </article>
            
            <article class="struct" data-name="todoCtx">
               <h3>
                  todoCtx
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type todoCtx struct {
emptyCtx
}</code></pre>
            </article>
            
            <article class="struct" data-name="valueCtx">
               <h3>
                  valueCtx
                  <span class="badge">struct</span>
               </h3>
               
               <p>A valueCtx carries a key-value pair. It implements Value for that key and
delegates all other calls to the embedded Context.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type valueCtx struct {
Context
key any
val any
}</code></pre>
            </article>
            
            <article class="struct" data-name="withoutCancelCtx">
               <h3>
                  withoutCancelCtx
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type withoutCancelCtx struct {
c Context
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AfterFunc">
               <h3>
                  AfterFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AfterFunc arranges to call f in its own goroutine after ctx is canceled.
If ctx is already canceled, AfterFunc calls f immediately in its own goroutine.
Multiple calls to AfterFunc on a context operate independently;
one does not replace another.
Calling the returned stop function stops the association of ctx with f.
It returns true if the call stopped f from being run.
If stop returns false,
either the context is canceled and f has been started in its own goroutine;
or f was already stopped.
The stop function does not wait for f to complete before returning.
If the caller needs to know whether f is completed,
it must coordinate with f explicitly.
If ctx has a "AfterFunc(func()) func() bool" method,
AfterFunc will use it to schedule the call.</p>
               
               <pre><code>func AfterFunc(ctx Context, f func()) (stop func() bool)</code></pre>
            </article>
            
            <article class="function" data-name="Background">
               <h3>
                  Background 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Background returns a non-nil, empty [Context]. It is never canceled, has no
values, and has no deadline. It is typically used by the main function,
initialization, and tests, and as the top-level Context for incoming
requests.</p>
               
               <pre><code>func Background() Context</code></pre>
            </article>
            
            <article class="function" data-name="Cause">
               <h3>
                  Cause 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Cause returns a non-nil error explaining why c was canceled.
The first cancellation of c or one of its parents sets the cause.
If that cancellation happened via a call to CancelCauseFunc(err),
then [Cause] returns err.
Otherwise Cause(c) returns the same value as c.Err().
Cause returns nil if c has not been canceled yet.</p>
               
               <pre><code>func Cause(c Context) error</code></pre>
            </article>
            
            <article class="function" data-name="Deadline">
               <h3>
                  Deadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (emptyCtx) Deadline() (deadline time.Time, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Deadline">
               <h3>
                  Deadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *timerCtx) Deadline() (deadline time.Time, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Deadline">
               <h3>
                  Deadline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (withoutCancelCtx) Deadline() (deadline time.Time, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Done">
               <h3>
                  Done 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *cancelCtx) Done() (<-chan struct{...})</code></pre>
            </article>
            
            <article class="function" data-name="Done">
               <h3>
                  Done 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (withoutCancelCtx) Done() (<-chan struct{...})</code></pre>
            </article>
            
            <article class="function" data-name="Done">
               <h3>
                  Done 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (emptyCtx) Done() (<-chan struct{...})</code></pre>
            </article>
            
            <article class="function" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (emptyCtx) Err() error</code></pre>
            </article>
            
            <article class="function" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *cancelCtx) Err() error</code></pre>
            </article>
            
            <article class="function" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (withoutCancelCtx) Err() error</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (deadlineExceededError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *cancelCtx) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *valueCtx) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (todoCtx) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (backgroundCtx) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *timerCtx) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c withoutCancelCtx) String() string</code></pre>
            </article>
            
            <article class="function" data-name="TODO">
               <h3>
                  TODO 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TODO returns a non-nil, empty [Context]. Code should use context.TODO when
it's unclear which Context to use or it is not yet available (because the
surrounding function has not yet been extended to accept a Context
parameter).</p>
               
               <pre><code>func TODO() Context</code></pre>
            </article>
            
            <article class="function" data-name="Temporary">
               <h3>
                  Temporary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (deadlineExceededError) Temporary() bool</code></pre>
            </article>
            
            <article class="function" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (deadlineExceededError) Timeout() bool</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (emptyCtx) Value(key any) any</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *cancelCtx) Value(key any) any</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c withoutCancelCtx) Value(key any) any</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *valueCtx) Value(key any) any</code></pre>
            </article>
            
            <article class="function" data-name="WithCancel">
               <h3>
                  WithCancel 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WithCancel returns a derived context that points to the parent context
but has a new Done channel. The returned context's Done channel is closed
when the returned cancel function is called or when the parent context's
Done channel is closed, whichever happens first.
Canceling this context releases resources associated with it, so code should
call cancel as soon as the operations running in this [Context] complete.</p>
               
               <pre><code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code></pre>
            </article>
            
            <article class="function" data-name="WithCancelCause">
               <h3>
                  WithCancelCause 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WithCancelCause behaves like [WithCancel] but returns a [CancelCauseFunc] instead of a [CancelFunc].
Calling cancel with a non-nil error (the "cause") records that error in ctx;
it can then be retrieved using Cause(ctx).
Calling cancel with nil sets the cause to Canceled.
Example use:
ctx, cancel := context.WithCancelCause(parent)
cancel(myError)
ctx.Err() // returns context.Canceled
context.Cause(ctx) // returns myError</p>
               
               <pre><code>func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc)</code></pre>
            </article>
            
            <article class="function" data-name="WithDeadline">
               <h3>
                  WithDeadline 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WithDeadline returns a derived context that points to the parent context
but has the deadline adjusted to be no later than d. If the parent's
deadline is already earlier than d, WithDeadline(parent, d) is semantically
equivalent to parent. The returned [Context.Done] channel is closed when
the deadline expires, when the returned cancel function is called,
or when the parent context's Done channel is closed, whichever happens first.
Canceling this context releases resources associated with it, so code should
call cancel as soon as the operations running in this [Context] complete.</p>
               
               <pre><code>func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)</code></pre>
            </article>
            
            <article class="function" data-name="WithDeadlineCause">
               <h3>
                  WithDeadlineCause 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WithDeadlineCause behaves like [WithDeadline] but also sets the cause of the
returned Context when the deadline is exceeded. The returned [CancelFunc] does
not set the cause.</p>
               
               <pre><code>func WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc)</code></pre>
            </article>
            
            <article class="function" data-name="WithTimeout">
               <h3>
                  WithTimeout 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).
Canceling this context releases resources associated with it, so code should
call cancel as soon as the operations running in this [Context] complete:
func slowOperationWithTimeout(ctx context.Context) (Result, error) {
ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
defer cancel()  // releases resources if slowOperation completes before timeout elapses
return slowOperation(ctx)
}</p>
               
               <pre><code>func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</code></pre>
            </article>
            
            <article class="function" data-name="WithTimeoutCause">
               <h3>
                  WithTimeoutCause 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WithTimeoutCause behaves like [WithTimeout] but also sets the cause of the
returned Context when the timeout expires. The returned [CancelFunc] does
not set the cause.</p>
               
               <pre><code>func WithTimeoutCause(parent Context, timeout time.Duration, cause error) (Context, CancelFunc)</code></pre>
            </article>
            
            <article class="function" data-name="WithValue">
               <h3>
                  WithValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WithValue returns a derived context that points to the parent Context.
In the derived context, the value associated with key is val.
Use context Values only for request-scoped data that transits processes and
APIs, not for passing optional parameters to functions.
The provided key must be comparable and should not be of type
string or any other built-in type to avoid collisions between
packages using context. Users of WithValue should define their own
types for keys. To avoid allocating when assigning to an
interface{}, context keys often have concrete type
struct{}. Alternatively, exported context key variables' static
type should be a pointer or interface.</p>
               
               <pre><code>func WithValue(parent Context, key any, val any) Context</code></pre>
            </article>
            
            <article class="function" data-name="WithoutCancel">
               <h3>
                  WithoutCancel 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WithoutCancel returns a derived context that points to the parent context
and is not canceled when parent is canceled.
The returned context returns no Deadline or Err, and its Done channel is nil.
Calling [Cause] on the returned context returns nil.</p>
               
               <pre><code>func WithoutCancel(parent Context) Context</code></pre>
            </article>
            
            <article class="function" data-name="cancel">
               <h3>
                  cancel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>cancel closes c.done, cancels each of c's children, and, if
removeFromParent is true, removes c from its parent's children.
cancel sets c.cause to cause if this is the first time c is canceled.</p>
               
               <pre><code>func (c *cancelCtx) cancel(removeFromParent bool, err error, cause error)</code></pre>
            </article>
            
            <article class="function" data-name="cancel">
               <h3>
                  cancel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *afterFuncCtx) cancel(removeFromParent bool, err error, cause error)</code></pre>
            </article>
            
            <article class="function" data-name="cancel">
               <h3>
                  cancel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *timerCtx) cancel(removeFromParent bool, err error, cause error)</code></pre>
            </article>
            
            <article class="function" data-name="contextName">
               <h3>
                  contextName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func contextName(c Context) string</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="parentCancelCtx">
               <h3>
                  parentCancelCtx 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parentCancelCtx returns the underlying *cancelCtx for parent.
It does this by looking up parent.Value(&cancelCtxKey) to find
the innermost enclosing *cancelCtx and then checking whether
parent.Done() matches that *cancelCtx. (If not, the *cancelCtx
has been wrapped in a custom implementation providing a
different done channel, in which case we should not bypass it.)</p>
               
               <pre><code>func parentCancelCtx(parent Context) (*cancelCtx, bool)</code></pre>
            </article>
            
            <article class="function" data-name="propagateCancel">
               <h3>
                  propagateCancel 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>propagateCancel arranges for child to be canceled when parent is.
It sets the parent context of cancelCtx.</p>
               
               <pre><code>func (c *cancelCtx) propagateCancel(parent Context, child canceler)</code></pre>
            </article>
            
            <article class="function" data-name="removeChild">
               <h3>
                  removeChild 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>removeChild removes a context from its parent.</p>
               
               <pre><code>func removeChild(parent Context, child canceler)</code></pre>
            </article>
            
            <article class="function" data-name="stringify">
               <h3>
                  stringify 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stringify tries a bit to stringify v, without using fmt, since we don't
want context depending on the unicode tables. This is only used by
*valueCtx.String().</p>
               
               <pre><code>func stringify(v any) string</code></pre>
            </article>
            
            <article class="function" data-name="value">
               <h3>
                  value 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func value(c Context, key any) any</code></pre>
            </article>
            
            <article class="function" data-name="withCancel">
               <h3>
                  withCancel 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func withCancel(parent Context) *cancelCtx</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
