<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>bytes - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>bytes</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"errors"
"io"
"unicode/utf8"
"internal/bytealg"
"math/bits"
"unicode"
"unicode/utf8"
_ "unsafe"
"iter"
"unicode"
"unicode/utf8"
"errors"
"io"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrTooLarge" data-name="ErrTooLarge">
               <h3>
                  ErrTooLarge 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrTooLarge" class="anchor" title="Link to ErrTooLarge">#</a>
               </h3>
               
                  <p class="doc-comment">ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.</p>
               
               <pre><code class="language-go">var ErrTooLarge = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MinRead" data-name="MinRead">
               <h3>
                  MinRead 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MinRead" class="anchor" title="Link to MinRead">#</a>
               </h3>
               
                  <p class="doc-comment">MinRead is the minimum slice size passed to a [Buffer.Read] call by
[Buffer.ReadFrom]. As long as the [Buffer] has at least MinRead bytes beyond
what is required to hold the contents of r, [Buffer.ReadFrom] will not grow the
underlying buffer.</p>
               
               <pre><code class="language-go">const MinRead = 512</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="asciiSpace" data-name="asciiSpace">
               <h3>
                  asciiSpace 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#asciiSpace" class="anchor" title="Link to asciiSpace">#</a>
               </h3>
               
               <pre><code class="language-go">var asciiSpace = [256]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNegativeRead" data-name="errNegativeRead">
               <h3>
                  errNegativeRead 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNegativeRead" class="anchor" title="Link to errNegativeRead">#</a>
               </h3>
               
               <pre><code class="language-go">var errNegativeRead = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errUnreadByte" data-name="errUnreadByte">
               <h3>
                  errUnreadByte 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errUnreadByte" class="anchor" title="Link to errUnreadByte">#</a>
               </h3>
               
               <pre><code class="language-go">var errUnreadByte = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxInt" data-name="maxInt">
               <h3>
                  maxInt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxInt" class="anchor" title="Link to maxInt">#</a>
               </h3>
               
               <pre><code class="language-go">const maxInt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="opInvalid" data-name="opInvalid">
               <h3>
                  opInvalid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#opInvalid" class="anchor" title="Link to opInvalid">#</a>
               </h3>
               
                  <p class="doc-comment">Don't use iota for these, as the values need to correspond with the
names and comments, which is easier to see when being explicit.</p>
               
               <pre><code class="language-go">const opInvalid readOp = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="opRead" data-name="opRead">
               <h3>
                  opRead 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#opRead" class="anchor" title="Link to opRead">#</a>
               </h3>
               
                  <p class="doc-comment">Don't use iota for these, as the values need to correspond with the
names and comments, which is easier to see when being explicit.</p>
               
               <pre><code class="language-go">const opRead readOp = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="opReadRune1" data-name="opReadRune1">
               <h3>
                  opReadRune1 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#opReadRune1" class="anchor" title="Link to opReadRune1">#</a>
               </h3>
               
                  <p class="doc-comment">Don't use iota for these, as the values need to correspond with the
names and comments, which is easier to see when being explicit.</p>
               
               <pre><code class="language-go">const opReadRune1 readOp = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="opReadRune2" data-name="opReadRune2">
               <h3>
                  opReadRune2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#opReadRune2" class="anchor" title="Link to opReadRune2">#</a>
               </h3>
               
                  <p class="doc-comment">Don't use iota for these, as the values need to correspond with the
names and comments, which is easier to see when being explicit.</p>
               
               <pre><code class="language-go">const opReadRune2 readOp = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="opReadRune3" data-name="opReadRune3">
               <h3>
                  opReadRune3 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#opReadRune3" class="anchor" title="Link to opReadRune3">#</a>
               </h3>
               
                  <p class="doc-comment">Don't use iota for these, as the values need to correspond with the
names and comments, which is easier to see when being explicit.</p>
               
               <pre><code class="language-go">const opReadRune3 readOp = 3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="opReadRune4" data-name="opReadRune4">
               <h3>
                  opReadRune4 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#opReadRune4" class="anchor" title="Link to opReadRune4">#</a>
               </h3>
               
                  <p class="doc-comment">Don't use iota for these, as the values need to correspond with the
names and comments, which is easier to see when being explicit.</p>
               
               <pre><code class="language-go">const opReadRune4 readOp = 4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="smallBufferSize" data-name="smallBufferSize">
               <h3>
                  smallBufferSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#smallBufferSize" class="anchor" title="Link to smallBufferSize">#</a>
               </h3>
               
                  <p class="doc-comment">smallBufferSize is an initial allocation minimal capacity.</p>
               
               <pre><code class="language-go">const smallBufferSize = 64</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="asciiSet" data-name="asciiSet">
               <h3>
                  asciiSet
                  <span class="badge type-badge">type</span>
                  <a href="#asciiSet" class="anchor" title="Link to asciiSet">#</a>
               </h3>
               
               <p>asciiSet is a 32-byte value, where each bit represents the presence of a
given ASCII character in the set. The 128-bits of the lower 16 bytes,
starting with the least-significant bit of the lowest word to the
most-significant bit of the highest word, map to the full range of all
128 ASCII characters. The 128-bits of the upper 16 bytes will be zeroed,
ensuring that any non-ASCII character will be reported as not in the set.
This allocates a total of 32 bytes even though the upper half
is unused to avoid bounds checks in asciiSet.contains.</p>
               
               <pre><code class="language-go">type asciiSet [8]uint32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="readOp" data-name="readOp">
               <h3>
                  readOp
                  <span class="badge type-badge">type</span>
                  <a href="#readOp" class="anchor" title="Link to readOp">#</a>
               </h3>
               
               <p>The readOp constants describe the last action performed on
the buffer, so that UnreadRune and UnreadByte can check for
invalid usage. opReadRuneX constants are chosen such that
converted to int they correspond to the rune size that was read.</p>
               
               <pre><code class="language-go">type readOp int8</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Buffer" data-name="Buffer">
               <h3>
                  Buffer
                  <span class="badge">struct</span>
                  <a href="#Buffer" class="anchor" title="Link to Buffer">#</a>
               </h3>
               
               <p>A Buffer is a variable-sized buffer of bytes with [Buffer.Read] and [Buffer.Write] methods.
The zero value for Buffer is an empty buffer ready to use.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Buffer struct {
buf []byte
off int
lastRead readOp
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Reader" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge">struct</span>
                  <a href="#Reader" class="anchor" title="Link to Reader">#</a>
               </h3>
               
               <p>A Reader implements the [io.Reader], [io.ReaderAt], [io.WriterTo], [io.Seeker],
[io.ByteScanner], and [io.RuneScanner] interfaces by reading from
a byte slice.
Unlike a [Buffer], a Reader is read-only and supports seeking.
The zero value for Reader operates like a Reader of an empty slice.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Reader struct {
s []byte
i int64
prevRune int
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Available" data-name="Available">
               <h3>
                  Available 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Available" class="anchor" title="Link to Available">#</a>
               </h3>
               
               <p>Available returns how many bytes are unused in the buffer.</p>
               
               <pre><code class="language-go">func (b *Buffer) Available() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AvailableBuffer" data-name="AvailableBuffer">
               <h3>
                  AvailableBuffer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AvailableBuffer" class="anchor" title="Link to AvailableBuffer">#</a>
               </h3>
               
               <p>AvailableBuffer returns an empty buffer with b.Available() capacity.
This buffer is intended to be appended to and
passed to an immediately succeeding [Buffer.Write] call.
The buffer is only valid until the next write operation on b.</p>
               
               <pre><code class="language-go">func (b *Buffer) AvailableBuffer() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <p>Bytes returns a slice of length b.Len() holding the unread portion of the buffer.
The slice is valid for use only until the next buffer modification (that is,
only until the next call to a method like [Buffer.Read], [Buffer.Write], [Buffer.Reset], or [Buffer.Truncate]).
The slice aliases the buffer content at least until the next buffer modification,
so immediate changes to the slice will affect the result of future reads.</p>
               
               <pre><code class="language-go">func (b *Buffer) Bytes() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cap" data-name="Cap">
               <h3>
                  Cap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cap" class="anchor" title="Link to Cap">#</a>
               </h3>
               
               <p>Cap returns the capacity of the buffer's underlying byte slice, that is, the
total space allocated for the buffer's data.</p>
               
               <pre><code class="language-go">func (b *Buffer) Cap() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clone" data-name="Clone">
               <h3>
                  Clone 
                  <span class="badge">function</span>
                  
                  <a href="#Clone" class="anchor" title="Link to Clone">#</a>
               </h3>
               
               <p>Clone returns a copy of b[:len(b)].
The result may have additional unused capacity.
Clone(nil) returns nil.</p>
               
               <pre><code class="language-go">func Clone(b []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Compare" data-name="Compare">
               <h3>
                  Compare 
                  <span class="badge">function</span>
                  
                  <a href="#Compare" class="anchor" title="Link to Compare">#</a>
               </h3>
               
               <p>Compare returns an integer comparing two byte slices lexicographically.
The result will be 0 if a == b, -1 if a < b, and +1 if a > b.
A nil argument is equivalent to an empty slice.</p>
               
               <pre><code class="language-go">func Compare(a []byte, b []byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Contains" data-name="Contains">
               <h3>
                  Contains 
                  <span class="badge">function</span>
                  
                  <a href="#Contains" class="anchor" title="Link to Contains">#</a>
               </h3>
               
               <p>Contains reports whether subslice is within b.</p>
               
               <pre><code class="language-go">func Contains(b []byte, subslice []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ContainsAny" data-name="ContainsAny">
               <h3>
                  ContainsAny 
                  <span class="badge">function</span>
                  
                  <a href="#ContainsAny" class="anchor" title="Link to ContainsAny">#</a>
               </h3>
               
               <p>ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.</p>
               
               <pre><code class="language-go">func ContainsAny(b []byte, chars string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ContainsFunc" data-name="ContainsFunc">
               <h3>
                  ContainsFunc 
                  <span class="badge">function</span>
                  
                  <a href="#ContainsFunc" class="anchor" title="Link to ContainsFunc">#</a>
               </h3>
               
               <p>ContainsFunc reports whether any of the UTF-8-encoded code points r within b satisfy f(r).</p>
               
               <pre><code class="language-go">func ContainsFunc(b []byte, f func(rune) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ContainsRune" data-name="ContainsRune">
               <h3>
                  ContainsRune 
                  <span class="badge">function</span>
                  
                  <a href="#ContainsRune" class="anchor" title="Link to ContainsRune">#</a>
               </h3>
               
               <p>ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.</p>
               
               <pre><code class="language-go">func ContainsRune(b []byte, r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Count" data-name="Count">
               <h3>
                  Count 
                  <span class="badge">function</span>
                  
                  <a href="#Count" class="anchor" title="Link to Count">#</a>
               </h3>
               
               <p>Count counts the number of non-overlapping instances of sep in s.
If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.</p>
               
               <pre><code class="language-go">func Count(s []byte, sep []byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cut" data-name="Cut">
               <h3>
                  Cut 
                  <span class="badge">function</span>
                  
                  <a href="#Cut" class="anchor" title="Link to Cut">#</a>
               </h3>
               
               <p>Cut slices s around the first instance of sep,
returning the text before and after sep.
The found result reports whether sep appears in s.
If sep does not appear in s, cut returns s, nil, false.
Cut returns slices of the original slice s, not copies.</p>
               
               <pre><code class="language-go">func Cut(s []byte, sep []byte) (before []byte, after []byte, found bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CutPrefix" data-name="CutPrefix">
               <h3>
                  CutPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#CutPrefix" class="anchor" title="Link to CutPrefix">#</a>
               </h3>
               
               <p>CutPrefix returns s without the provided leading prefix byte slice
and reports whether it found the prefix.
If s doesn't start with prefix, CutPrefix returns s, false.
If prefix is the empty byte slice, CutPrefix returns s, true.
CutPrefix returns slices of the original slice s, not copies.</p>
               
               <pre><code class="language-go">func CutPrefix(s []byte, prefix []byte) (after []byte, found bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CutSuffix" data-name="CutSuffix">
               <h3>
                  CutSuffix 
                  <span class="badge">function</span>
                  
                  <a href="#CutSuffix" class="anchor" title="Link to CutSuffix">#</a>
               </h3>
               
               <p>CutSuffix returns s without the provided ending suffix byte slice
and reports whether it found the suffix.
If s doesn't end with suffix, CutSuffix returns s, false.
If suffix is the empty byte slice, CutSuffix returns s, true.
CutSuffix returns slices of the original slice s, not copies.</p>
               
               <pre><code class="language-go">func CutSuffix(s []byte, suffix []byte) (before []byte, found bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Equal" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge">function</span>
                  
                  <a href="#Equal" class="anchor" title="Link to Equal">#</a>
               </h3>
               
               <p>Equal reports whether a and b
are the same length and contain the same bytes.
A nil argument is equivalent to an empty slice.</p>
               
               <pre><code class="language-go">func Equal(a []byte, b []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EqualFold" data-name="EqualFold">
               <h3>
                  EqualFold 
                  <span class="badge">function</span>
                  
                  <a href="#EqualFold" class="anchor" title="Link to EqualFold">#</a>
               </h3>
               
               <p>EqualFold reports whether s and t, interpreted as UTF-8 strings,
are equal under simple Unicode case-folding, which is a more general
form of case-insensitivity.</p>
               
               <pre><code class="language-go">func EqualFold(s []byte, t []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fields" data-name="Fields">
               <h3>
                  Fields 
                  <span class="badge">function</span>
                  
                  <a href="#Fields" class="anchor" title="Link to Fields">#</a>
               </h3>
               
               <p>Fields interprets s as a sequence of UTF-8-encoded code points.
It splits the slice s around each instance of one or more consecutive white space
characters, as defined by [unicode.IsSpace], returning a slice of subslices of s or an
empty slice if s contains only white space.</p>
               
               <pre><code class="language-go">func Fields(s []byte) [][]byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldsFunc" data-name="FieldsFunc">
               <h3>
                  FieldsFunc 
                  <span class="badge">function</span>
                  
                  <a href="#FieldsFunc" class="anchor" title="Link to FieldsFunc">#</a>
               </h3>
               
               <p>FieldsFunc interprets s as a sequence of UTF-8-encoded code points.
It splits the slice s at each run of code points c satisfying f(c) and
returns a slice of subslices of s. If all code points in s satisfy f(c), or
len(s) == 0, an empty slice is returned.
FieldsFunc makes no guarantees about the order in which it calls f(c)
and assumes that f always returns the same value for a given c.</p>
               
               <pre><code class="language-go">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldsFuncSeq" data-name="FieldsFuncSeq">
               <h3>
                  FieldsFuncSeq 
                  <span class="badge">function</span>
                  
                  <a href="#FieldsFuncSeq" class="anchor" title="Link to FieldsFuncSeq">#</a>
               </h3>
               
               <p>FieldsFuncSeq returns an iterator over subslices of s split around runs of
Unicode code points satisfying f(c).
The iterator yields the same subslices that would be returned by [FieldsFunc](s),
but without constructing a new slice containing the subslices.</p>
               
               <pre><code class="language-go">func FieldsFuncSeq(s []byte, f func(rune) bool) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldsSeq" data-name="FieldsSeq">
               <h3>
                  FieldsSeq 
                  <span class="badge">function</span>
                  
                  <a href="#FieldsSeq" class="anchor" title="Link to FieldsSeq">#</a>
               </h3>
               
               <p>FieldsSeq returns an iterator over subslices of s split around runs of
whitespace characters, as defined by [unicode.IsSpace].
The iterator yields the same subslices that would be returned by [Fields](s),
but without constructing a new slice containing the subslices.</p>
               
               <pre><code class="language-go">func FieldsSeq(s []byte) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Grow" data-name="Grow">
               <h3>
                  Grow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Grow" class="anchor" title="Link to Grow">#</a>
               </h3>
               
               <p>Grow grows the buffer's capacity, if necessary, to guarantee space for
another n bytes. After Grow(n), at least n bytes can be written to the
buffer without another allocation.
If n is negative, Grow will panic.
If the buffer can't grow it will panic with [ErrTooLarge].</p>
               
               <pre><code class="language-go">func (b *Buffer) Grow(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasPrefix" data-name="HasPrefix">
               <h3>
                  HasPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#HasPrefix" class="anchor" title="Link to HasPrefix">#</a>
               </h3>
               
               <p>HasPrefix reports whether the byte slice s begins with prefix.</p>
               
               <pre><code class="language-go">func HasPrefix(s []byte, prefix []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasSuffix" data-name="HasSuffix">
               <h3>
                  HasSuffix 
                  <span class="badge">function</span>
                  
                  <a href="#HasSuffix" class="anchor" title="Link to HasSuffix">#</a>
               </h3>
               
               <p>HasSuffix reports whether the byte slice s ends with suffix.</p>
               
               <pre><code class="language-go">func HasSuffix(s []byte, suffix []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Index" data-name="Index">
               <h3>
                  Index 
                  <span class="badge">function</span>
                  
                  <a href="#Index" class="anchor" title="Link to Index">#</a>
               </h3>
               
               <p>Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.</p>
               
               <pre><code class="language-go">func Index(s []byte, sep []byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IndexAny" data-name="IndexAny">
               <h3>
                  IndexAny 
                  <span class="badge">function</span>
                  
                  <a href="#IndexAny" class="anchor" title="Link to IndexAny">#</a>
               </h3>
               
               <p>IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.
It returns the byte index of the first occurrence in s of any of the Unicode
code points in chars. It returns -1 if chars is empty or if there is no code
point in common.</p>
               
               <pre><code class="language-go">func IndexAny(s []byte, chars string) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IndexByte" data-name="IndexByte">
               <h3>
                  IndexByte 
                  <span class="badge">function</span>
                  
                  <a href="#IndexByte" class="anchor" title="Link to IndexByte">#</a>
               </h3>
               
               <p>IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.</p>
               
               <pre><code class="language-go">func IndexByte(b []byte, c byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IndexFunc" data-name="IndexFunc">
               <h3>
                  IndexFunc 
                  <span class="badge">function</span>
                  
                  <a href="#IndexFunc" class="anchor" title="Link to IndexFunc">#</a>
               </h3>
               
               <p>IndexFunc interprets s as a sequence of UTF-8-encoded code points.
It returns the byte index in s of the first Unicode
code point satisfying f(c), or -1 if none do.</p>
               
               <pre><code class="language-go">func IndexFunc(s []byte, f func(r rune) bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IndexRune" data-name="IndexRune">
               <h3>
                  IndexRune 
                  <span class="badge">function</span>
                  
                  <a href="#IndexRune" class="anchor" title="Link to IndexRune">#</a>
               </h3>
               
               <p>IndexRune interprets s as a sequence of UTF-8-encoded code points.
It returns the byte index of the first occurrence in s of the given rune.
It returns -1 if rune is not present in s.
If r is [utf8.RuneError], it returns the first instance of any
invalid UTF-8 byte sequence.</p>
               
               <pre><code class="language-go">func IndexRune(s []byte, r rune) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Join" data-name="Join">
               <h3>
                  Join 
                  <span class="badge">function</span>
                  
                  <a href="#Join" class="anchor" title="Link to Join">#</a>
               </h3>
               
               <p>Join concatenates the elements of s to create a new byte slice. The separator
sep is placed between elements in the resulting slice.</p>
               
               <pre><code class="language-go">func Join(s [][]byte, sep []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LastIndex" data-name="LastIndex">
               <h3>
                  LastIndex 
                  <span class="badge">function</span>
                  
                  <a href="#LastIndex" class="anchor" title="Link to LastIndex">#</a>
               </h3>
               
               <p>LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.</p>
               
               <pre><code class="language-go">func LastIndex(s []byte, sep []byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LastIndexAny" data-name="LastIndexAny">
               <h3>
                  LastIndexAny 
                  <span class="badge">function</span>
                  
                  <a href="#LastIndexAny" class="anchor" title="Link to LastIndexAny">#</a>
               </h3>
               
               <p>LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code
points. It returns the byte index of the last occurrence in s of any of
the Unicode code points in chars. It returns -1 if chars is empty or if
there is no code point in common.</p>
               
               <pre><code class="language-go">func LastIndexAny(s []byte, chars string) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LastIndexByte" data-name="LastIndexByte">
               <h3>
                  LastIndexByte 
                  <span class="badge">function</span>
                  
                  <a href="#LastIndexByte" class="anchor" title="Link to LastIndexByte">#</a>
               </h3>
               
               <p>LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.</p>
               
               <pre><code class="language-go">func LastIndexByte(s []byte, c byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LastIndexFunc" data-name="LastIndexFunc">
               <h3>
                  LastIndexFunc 
                  <span class="badge">function</span>
                  
                  <a href="#LastIndexFunc" class="anchor" title="Link to LastIndexFunc">#</a>
               </h3>
               
               <p>LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.
It returns the byte index in s of the last Unicode
code point satisfying f(c), or -1 if none do.</p>
               
               <pre><code class="language-go">func LastIndexFunc(s []byte, f func(r rune) bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Len returns the number of bytes of the unread portion of the
slice.</p>
               
               <pre><code class="language-go">func (r *Reader) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Len returns the number of bytes of the unread portion of the buffer;
b.Len() == len(b.Bytes()).</p>
               
               <pre><code class="language-go">func (b *Buffer) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lines" data-name="Lines">
               <h3>
                  Lines 
                  <span class="badge">function</span>
                  
                  <a href="#Lines" class="anchor" title="Link to Lines">#</a>
               </h3>
               
               <p>Lines returns an iterator over the newline-terminated lines in the byte slice s.
The lines yielded by the iterator include their terminating newlines.
If s is empty, the iterator yields no lines at all.
If s does not end in a newline, the final yielded line will not end in a newline.
It returns a single-use iterator.</p>
               
               <pre><code class="language-go">func Lines(s []byte) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Map" data-name="Map">
               <h3>
                  Map 
                  <span class="badge">function</span>
                  
                  <a href="#Map" class="anchor" title="Link to Map">#</a>
               </h3>
               
               <p>Map returns a copy of the byte slice s with all its characters modified
according to the mapping function. If mapping returns a negative value, the character is
dropped from the byte slice with no replacement. The characters in s and the
output are interpreted as UTF-8-encoded code points.</p>
               
               <pre><code class="language-go">func Map(mapping func(r rune) rune, s []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewBuffer" data-name="NewBuffer">
               <h3>
                  NewBuffer 
                  <span class="badge">function</span>
                  
                  <a href="#NewBuffer" class="anchor" title="Link to NewBuffer">#</a>
               </h3>
               
               <p>NewBuffer creates and initializes a new [Buffer] using buf as its
initial contents. The new [Buffer] takes ownership of buf, and the
caller should not use buf after this call. NewBuffer is intended to
prepare a [Buffer] to read existing data. It can also be used to set
the initial size of the internal buffer for writing. To do that,
buf should have the desired capacity but a length of zero.
In most cases, new([Buffer]) (or just declaring a [Buffer] variable) is
sufficient to initialize a [Buffer].</p>
               
               <pre><code class="language-go">func NewBuffer(buf []byte) *Buffer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewBufferString" data-name="NewBufferString">
               <h3>
                  NewBufferString 
                  <span class="badge">function</span>
                  
                  <a href="#NewBufferString" class="anchor" title="Link to NewBufferString">#</a>
               </h3>
               
               <p>NewBufferString creates and initializes a new [Buffer] using string s as its
initial contents. It is intended to prepare a buffer to read an existing
string.
In most cases, new([Buffer]) (or just declaring a [Buffer] variable) is
sufficient to initialize a [Buffer].</p>
               
               <pre><code class="language-go">func NewBufferString(s string) *Buffer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewReader" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
                  <a href="#NewReader" class="anchor" title="Link to NewReader">#</a>
               </h3>
               
               <p>NewReader returns a new [Reader] reading from b.</p>
               
               <pre><code class="language-go">func NewReader(b []byte) *Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <p>Next returns a slice containing the next n bytes from the buffer,
advancing the buffer as if the bytes had been returned by [Buffer.Read].
If there are fewer than n bytes in the buffer, Next returns the entire buffer.
The slice is only valid until the next call to a read or write method.</p>
               
               <pre><code class="language-go">func (b *Buffer) Next(n int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read implements the [io.Reader] interface.</p>
               
               <pre><code class="language-go">func (r *Reader) Read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read reads the next len(p) bytes from the buffer or until the buffer
is drained. The return value n is the number of bytes read. If the
buffer has no data to return, err is [io.EOF] (unless len(p) is zero);
otherwise it is nil.</p>
               
               <pre><code class="language-go">func (b *Buffer) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadAt" data-name="ReadAt">
               <h3>
                  ReadAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadAt" class="anchor" title="Link to ReadAt">#</a>
               </h3>
               
               <p>ReadAt implements the [io.ReaderAt] interface.</p>
               
               <pre><code class="language-go">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadByte" data-name="ReadByte">
               <h3>
                  ReadByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadByte" class="anchor" title="Link to ReadByte">#</a>
               </h3>
               
               <p>ReadByte implements the [io.ByteReader] interface.</p>
               
               <pre><code class="language-go">func (r *Reader) ReadByte() (byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadByte" data-name="ReadByte">
               <h3>
                  ReadByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadByte" class="anchor" title="Link to ReadByte">#</a>
               </h3>
               
               <p>ReadByte reads and returns the next byte from the buffer.
If no byte is available, it returns error [io.EOF].</p>
               
               <pre><code class="language-go">func (b *Buffer) ReadByte() (byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadBytes" data-name="ReadBytes">
               <h3>
                  ReadBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadBytes" class="anchor" title="Link to ReadBytes">#</a>
               </h3>
               
               <p>ReadBytes reads until the first occurrence of delim in the input,
returning a slice containing the data up to and including the delimiter.
If ReadBytes encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often [io.EOF]).
ReadBytes returns err != nil if and only if the returned data does not end in
delim.</p>
               
               <pre><code class="language-go">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFrom" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFrom" class="anchor" title="Link to ReadFrom">#</a>
               </h3>
               
               <p>ReadFrom reads data from r until EOF and appends it to the buffer, growing
the buffer as needed. The return value n is the number of bytes read. Any
error except io.EOF encountered during the read is also returned. If the
buffer becomes too large, ReadFrom will panic with [ErrTooLarge].</p>
               
               <pre><code class="language-go">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadRune" data-name="ReadRune">
               <h3>
                  ReadRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadRune" class="anchor" title="Link to ReadRune">#</a>
               </h3>
               
               <p>ReadRune reads and returns the next UTF-8-encoded
Unicode code point from the buffer.
If no bytes are available, the error returned is io.EOF.
If the bytes are an erroneous UTF-8 encoding, it
consumes one byte and returns U+FFFD, 1.</p>
               
               <pre><code class="language-go">func (b *Buffer) ReadRune() (r rune, size int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadRune" data-name="ReadRune">
               <h3>
                  ReadRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadRune" class="anchor" title="Link to ReadRune">#</a>
               </h3>
               
               <p>ReadRune implements the [io.RuneReader] interface.</p>
               
               <pre><code class="language-go">func (r *Reader) ReadRune() (ch rune, size int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadString" data-name="ReadString">
               <h3>
                  ReadString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadString" class="anchor" title="Link to ReadString">#</a>
               </h3>
               
               <p>ReadString reads until the first occurrence of delim in the input,
returning a string containing the data up to and including the delimiter.
If ReadString encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often [io.EOF]).
ReadString returns err != nil if and only if the returned data does not end
in delim.</p>
               
               <pre><code class="language-go">func (b *Buffer) ReadString(delim byte) (line string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Repeat" data-name="Repeat">
               <h3>
                  Repeat 
                  <span class="badge">function</span>
                  
                  <a href="#Repeat" class="anchor" title="Link to Repeat">#</a>
               </h3>
               
               <p>Repeat returns a new byte slice consisting of count copies of b.
It panics if count is negative or if the result of (len(b) * count)
overflows.</p>
               
               <pre><code class="language-go">func Repeat(b []byte, count int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Replace" data-name="Replace">
               <h3>
                  Replace 
                  <span class="badge">function</span>
                  
                  <a href="#Replace" class="anchor" title="Link to Replace">#</a>
               </h3>
               
               <p>Replace returns a copy of the slice s with the first n
non-overlapping instances of old replaced by new.
If old is empty, it matches at the beginning of the slice
and after each UTF-8 sequence, yielding up to k+1 replacements
for a k-rune slice.
If n < 0, there is no limit on the number of replacements.</p>
               
               <pre><code class="language-go">func Replace(s []byte, old []byte, new []byte, n int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReplaceAll" data-name="ReplaceAll">
               <h3>
                  ReplaceAll 
                  <span class="badge">function</span>
                  
                  <a href="#ReplaceAll" class="anchor" title="Link to ReplaceAll">#</a>
               </h3>
               
               <p>ReplaceAll returns a copy of the slice s with all
non-overlapping instances of old replaced by new.
If old is empty, it matches at the beginning of the slice
and after each UTF-8 sequence, yielding up to k+1 replacements
for a k-rune slice.</p>
               
               <pre><code class="language-go">func ReplaceAll(s []byte, old []byte, new []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset resets the [Reader] to be reading from b.</p>
               
               <pre><code class="language-go">func (r *Reader) Reset(b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset resets the buffer to be empty,
but it retains the underlying storage for use by future writes.
Reset is the same as [Buffer.Truncate](0).</p>
               
               <pre><code class="language-go">func (b *Buffer) Reset()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Runes" data-name="Runes">
               <h3>
                  Runes 
                  <span class="badge">function</span>
                  
                  <a href="#Runes" class="anchor" title="Link to Runes">#</a>
               </h3>
               
               <p>Runes interprets s as a sequence of UTF-8-encoded code points.
It returns a slice of runes (Unicode code points) equivalent to s.</p>
               
               <pre><code class="language-go">func Runes(s []byte) []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Seek" data-name="Seek">
               <h3>
                  Seek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Seek" class="anchor" title="Link to Seek">#</a>
               </h3>
               
               <p>Seek implements the [io.Seeker] interface.</p>
               
               <pre><code class="language-go">func (r *Reader) Seek(offset int64, whence int) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <p>Size returns the original length of the underlying byte slice.
Size is the number of bytes available for reading via [Reader.ReadAt].
The result is unaffected by any method calls except [Reader.Reset].</p>
               
               <pre><code class="language-go">func (r *Reader) Size() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Split" data-name="Split">
               <h3>
                  Split 
                  <span class="badge">function</span>
                  
                  <a href="#Split" class="anchor" title="Link to Split">#</a>
               </h3>
               
               <p>Split slices s into all subslices separated by sep and returns a slice of
the subslices between those separators.
If sep is empty, Split splits after each UTF-8 sequence.
It is equivalent to SplitN with a count of -1.
To split around the first instance of a separator, see [Cut].</p>
               
               <pre><code class="language-go">func Split(s []byte, sep []byte) [][]byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SplitAfter" data-name="SplitAfter">
               <h3>
                  SplitAfter 
                  <span class="badge">function</span>
                  
                  <a href="#SplitAfter" class="anchor" title="Link to SplitAfter">#</a>
               </h3>
               
               <p>SplitAfter slices s into all subslices after each instance of sep and
returns a slice of those subslices.
If sep is empty, SplitAfter splits after each UTF-8 sequence.
It is equivalent to SplitAfterN with a count of -1.</p>
               
               <pre><code class="language-go">func SplitAfter(s []byte, sep []byte) [][]byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SplitAfterN" data-name="SplitAfterN">
               <h3>
                  SplitAfterN 
                  <span class="badge">function</span>
                  
                  <a href="#SplitAfterN" class="anchor" title="Link to SplitAfterN">#</a>
               </h3>
               
               <p>SplitAfterN slices s into subslices after each instance of sep and
returns a slice of those subslices.
If sep is empty, SplitAfterN splits after each UTF-8 sequence.
The count determines the number of subslices to return:
- n > 0: at most n subslices; the last subslice will be the unsplit remainder;
- n == 0: the result is nil (zero subslices);
- n < 0: all subslices.</p>
               
               <pre><code class="language-go">func SplitAfterN(s []byte, sep []byte, n int) [][]byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SplitAfterSeq" data-name="SplitAfterSeq">
               <h3>
                  SplitAfterSeq 
                  <span class="badge">function</span>
                  
                  <a href="#SplitAfterSeq" class="anchor" title="Link to SplitAfterSeq">#</a>
               </h3>
               
               <p>SplitAfterSeq returns an iterator over subslices of s split after each instance of sep.
The iterator yields the same subslices that would be returned by [SplitAfter](s, sep),
but without constructing a new slice containing the subslices.
It returns a single-use iterator.</p>
               
               <pre><code class="language-go">func SplitAfterSeq(s []byte, sep []byte) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SplitN" data-name="SplitN">
               <h3>
                  SplitN 
                  <span class="badge">function</span>
                  
                  <a href="#SplitN" class="anchor" title="Link to SplitN">#</a>
               </h3>
               
               <p>SplitN slices s into subslices separated by sep and returns a slice of
the subslices between those separators.
If sep is empty, SplitN splits after each UTF-8 sequence.
The count determines the number of subslices to return:
- n > 0: at most n subslices; the last subslice will be the unsplit remainder;
- n == 0: the result is nil (zero subslices);
- n < 0: all subslices.
To split around the first instance of a separator, see [Cut].</p>
               
               <pre><code class="language-go">func SplitN(s []byte, sep []byte, n int) [][]byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SplitSeq" data-name="SplitSeq">
               <h3>
                  SplitSeq 
                  <span class="badge">function</span>
                  
                  <a href="#SplitSeq" class="anchor" title="Link to SplitSeq">#</a>
               </h3>
               
               <p>SplitSeq returns an iterator over all subslices of s separated by sep.
The iterator yields the same subslices that would be returned by [Split](s, sep),
but without constructing a new slice containing the subslices.
It returns a single-use iterator.</p>
               
               <pre><code class="language-go">func SplitSeq(s []byte, sep []byte) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the contents of the unread portion of the buffer
as a string. If the [Buffer] is a nil pointer, it returns "<nil>".
To build strings more efficiently, see the [strings.Builder] type.</p>
               
               <pre><code class="language-go">func (b *Buffer) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Title" data-name="Title">
               <h3>
                  Title 
                  <span class="badge">function</span>
                  
                  <a href="#Title" class="anchor" title="Link to Title">#</a>
               </h3>
               
               <p>Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin
words mapped to their title case.
Deprecated: The rule Title uses for word boundaries does not handle Unicode
punctuation properly. Use golang.org/x/text/cases instead.</p>
               
               <pre><code class="language-go">func Title(s []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToLower" data-name="ToLower">
               <h3>
                  ToLower 
                  <span class="badge">function</span>
                  
                  <a href="#ToLower" class="anchor" title="Link to ToLower">#</a>
               </h3>
               
               <p>ToLower returns a copy of the byte slice s with all Unicode letters mapped to
their lower case.</p>
               
               <pre><code class="language-go">func ToLower(s []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToLowerSpecial" data-name="ToLowerSpecial">
               <h3>
                  ToLowerSpecial 
                  <span class="badge">function</span>
                  
                  <a href="#ToLowerSpecial" class="anchor" title="Link to ToLowerSpecial">#</a>
               </h3>
               
               <p>ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
lower case, giving priority to the special casing rules.</p>
               
               <pre><code class="language-go">func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToTitle" data-name="ToTitle">
               <h3>
                  ToTitle 
                  <span class="badge">function</span>
                  
                  <a href="#ToTitle" class="anchor" title="Link to ToTitle">#</a>
               </h3>
               
               <p>ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.</p>
               
               <pre><code class="language-go">func ToTitle(s []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToTitleSpecial" data-name="ToTitleSpecial">
               <h3>
                  ToTitleSpecial 
                  <span class="badge">function</span>
                  
                  <a href="#ToTitleSpecial" class="anchor" title="Link to ToTitleSpecial">#</a>
               </h3>
               
               <p>ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
title case, giving priority to the special casing rules.</p>
               
               <pre><code class="language-go">func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToUpper" data-name="ToUpper">
               <h3>
                  ToUpper 
                  <span class="badge">function</span>
                  
                  <a href="#ToUpper" class="anchor" title="Link to ToUpper">#</a>
               </h3>
               
               <p>ToUpper returns a copy of the byte slice s with all Unicode letters mapped to
their upper case.</p>
               
               <pre><code class="language-go">func ToUpper(s []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToUpperSpecial" data-name="ToUpperSpecial">
               <h3>
                  ToUpperSpecial 
                  <span class="badge">function</span>
                  
                  <a href="#ToUpperSpecial" class="anchor" title="Link to ToUpperSpecial">#</a>
               </h3>
               
               <p>ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
upper case, giving priority to the special casing rules.</p>
               
               <pre><code class="language-go">func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToValidUTF8" data-name="ToValidUTF8">
               <h3>
                  ToValidUTF8 
                  <span class="badge">function</span>
                  
                  <a href="#ToValidUTF8" class="anchor" title="Link to ToValidUTF8">#</a>
               </h3>
               
               <p>ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes
representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.</p>
               
               <pre><code class="language-go">func ToValidUTF8(s []byte, replacement []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Trim" data-name="Trim">
               <h3>
                  Trim 
                  <span class="badge">function</span>
                  
                  <a href="#Trim" class="anchor" title="Link to Trim">#</a>
               </h3>
               
               <p>Trim returns a subslice of s by slicing off all leading and
trailing UTF-8-encoded code points contained in cutset.</p>
               
               <pre><code class="language-go">func Trim(s []byte, cutset string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimFunc" data-name="TrimFunc">
               <h3>
                  TrimFunc 
                  <span class="badge">function</span>
                  
                  <a href="#TrimFunc" class="anchor" title="Link to TrimFunc">#</a>
               </h3>
               
               <p>TrimFunc returns a subslice of s by slicing off all leading and trailing
UTF-8-encoded code points c that satisfy f(c).</p>
               
               <pre><code class="language-go">func TrimFunc(s []byte, f func(r rune) bool) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimLeft" data-name="TrimLeft">
               <h3>
                  TrimLeft 
                  <span class="badge">function</span>
                  
                  <a href="#TrimLeft" class="anchor" title="Link to TrimLeft">#</a>
               </h3>
               
               <p>TrimLeft returns a subslice of s by slicing off all leading
UTF-8-encoded code points contained in cutset.</p>
               
               <pre><code class="language-go">func TrimLeft(s []byte, cutset string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimLeftFunc" data-name="TrimLeftFunc">
               <h3>
                  TrimLeftFunc 
                  <span class="badge">function</span>
                  
                  <a href="#TrimLeftFunc" class="anchor" title="Link to TrimLeftFunc">#</a>
               </h3>
               
               <p>TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off
all leading UTF-8-encoded code points c that satisfy f(c).</p>
               
               <pre><code class="language-go">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimPrefix" data-name="TrimPrefix">
               <h3>
                  TrimPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#TrimPrefix" class="anchor" title="Link to TrimPrefix">#</a>
               </h3>
               
               <p>TrimPrefix returns s without the provided leading prefix string.
If s doesn't start with prefix, s is returned unchanged.</p>
               
               <pre><code class="language-go">func TrimPrefix(s []byte, prefix []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimRight" data-name="TrimRight">
               <h3>
                  TrimRight 
                  <span class="badge">function</span>
                  
                  <a href="#TrimRight" class="anchor" title="Link to TrimRight">#</a>
               </h3>
               
               <p>TrimRight returns a subslice of s by slicing off all trailing
UTF-8-encoded code points that are contained in cutset.</p>
               
               <pre><code class="language-go">func TrimRight(s []byte, cutset string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimRightFunc" data-name="TrimRightFunc">
               <h3>
                  TrimRightFunc 
                  <span class="badge">function</span>
                  
                  <a href="#TrimRightFunc" class="anchor" title="Link to TrimRightFunc">#</a>
               </h3>
               
               <p>TrimRightFunc returns a subslice of s by slicing off all trailing
UTF-8-encoded code points c that satisfy f(c).</p>
               
               <pre><code class="language-go">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimSpace" data-name="TrimSpace">
               <h3>
                  TrimSpace 
                  <span class="badge">function</span>
                  
                  <a href="#TrimSpace" class="anchor" title="Link to TrimSpace">#</a>
               </h3>
               
               <p>TrimSpace returns a subslice of s by slicing off all leading and
trailing white space, as defined by Unicode.</p>
               
               <pre><code class="language-go">func TrimSpace(s []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrimSuffix" data-name="TrimSuffix">
               <h3>
                  TrimSuffix 
                  <span class="badge">function</span>
                  
                  <a href="#TrimSuffix" class="anchor" title="Link to TrimSuffix">#</a>
               </h3>
               
               <p>TrimSuffix returns s without the provided trailing suffix string.
If s doesn't end with suffix, s is returned unchanged.</p>
               
               <pre><code class="language-go">func TrimSuffix(s []byte, suffix []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Truncate" data-name="Truncate">
               <h3>
                  Truncate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Truncate" class="anchor" title="Link to Truncate">#</a>
               </h3>
               
               <p>Truncate discards all but the first n unread bytes from the buffer
but continues to use the same allocated storage.
It panics if n is negative or greater than the length of the buffer.</p>
               
               <pre><code class="language-go">func (b *Buffer) Truncate(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnreadByte" data-name="UnreadByte">
               <h3>
                  UnreadByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnreadByte" class="anchor" title="Link to UnreadByte">#</a>
               </h3>
               
               <p>UnreadByte unreads the last byte returned by the most recent successful
read operation that read at least one byte. If a write has happened since
the last read, if the last read returned an error, or if the read read zero
bytes, UnreadByte returns an error.</p>
               
               <pre><code class="language-go">func (b *Buffer) UnreadByte() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnreadByte" data-name="UnreadByte">
               <h3>
                  UnreadByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnreadByte" class="anchor" title="Link to UnreadByte">#</a>
               </h3>
               
               <p>UnreadByte complements [Reader.ReadByte] in implementing the [io.ByteScanner] interface.</p>
               
               <pre><code class="language-go">func (r *Reader) UnreadByte() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnreadRune" data-name="UnreadRune">
               <h3>
                  UnreadRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnreadRune" class="anchor" title="Link to UnreadRune">#</a>
               </h3>
               
               <p>UnreadRune unreads the last rune returned by [Buffer.ReadRune].
If the most recent read or write operation on the buffer was
not a successful [Buffer.ReadRune], UnreadRune returns an error.  (In this regard
it is stricter than [Buffer.UnreadByte], which will unread the last byte
from any read operation.)</p>
               
               <pre><code class="language-go">func (b *Buffer) UnreadRune() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnreadRune" data-name="UnreadRune">
               <h3>
                  UnreadRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnreadRune" class="anchor" title="Link to UnreadRune">#</a>
               </h3>
               
               <p>UnreadRune complements [Reader.ReadRune] in implementing the [io.RuneScanner] interface.</p>
               
               <pre><code class="language-go">func (r *Reader) UnreadRune() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write appends the contents of p to the buffer, growing the buffer as
needed. The return value n is the length of p; err is always nil. If the
buffer becomes too large, Write will panic with [ErrTooLarge].</p>
               
               <pre><code class="language-go">func (b *Buffer) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteByte" data-name="WriteByte">
               <h3>
                  WriteByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteByte" class="anchor" title="Link to WriteByte">#</a>
               </h3>
               
               <p>WriteByte appends the byte c to the buffer, growing the buffer as needed.
The returned error is always nil, but is included to match [bufio.Writer]'s
WriteByte. If the buffer becomes too large, WriteByte will panic with
[ErrTooLarge].</p>
               
               <pre><code class="language-go">func (b *Buffer) WriteByte(c byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteRune" data-name="WriteRune">
               <h3>
                  WriteRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteRune" class="anchor" title="Link to WriteRune">#</a>
               </h3>
               
               <p>WriteRune appends the UTF-8 encoding of Unicode code point r to the
buffer, returning its length and an error, which is always nil but is
included to match [bufio.Writer]'s WriteRune. The buffer is grown as needed;
if it becomes too large, WriteRune will panic with [ErrTooLarge].</p>
               
               <pre><code class="language-go">func (b *Buffer) WriteRune(r rune) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteString" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteString" class="anchor" title="Link to WriteString">#</a>
               </h3>
               
               <p>WriteString appends the contents of s to the buffer, growing the buffer as
needed. The return value n is the length of s; err is always nil. If the
buffer becomes too large, WriteString will panic with [ErrTooLarge].</p>
               
               <pre><code class="language-go">func (b *Buffer) WriteString(s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteTo" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteTo" class="anchor" title="Link to WriteTo">#</a>
               </h3>
               
               <p>WriteTo writes data to w until the buffer is drained or an error occurs.
The return value n is the number of bytes written; it always fits into an
int, but it is int64 to match the [io.WriterTo] interface. Any error
encountered during the write is also returned.</p>
               
               <pre><code class="language-go">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteTo" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteTo" class="anchor" title="Link to WriteTo">#</a>
               </h3>
               
               <p>WriteTo implements the [io.WriterTo] interface.</p>
               
               <pre><code class="language-go">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="contains" data-name="contains">
               <h3>
                  contains 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#contains" class="anchor" title="Link to contains">#</a>
               </h3>
               
               <p>contains reports whether c is inside the set.</p>
               
               <pre><code class="language-go">func (as *asciiSet) contains(c byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="containsRune" data-name="containsRune">
               <h3>
                  containsRune 
                  <span class="badge">function</span>
                  
                  <a href="#containsRune" class="anchor" title="Link to containsRune">#</a>
               </h3>
               
               <p>containsRune is a simplified version of strings.ContainsRune
to avoid importing the strings package.
We avoid bytes.ContainsRune to avoid allocating a temporary copy of s.</p>
               
               <pre><code class="language-go">func containsRune(s string, r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="empty" data-name="empty">
               <h3>
                  empty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#empty" class="anchor" title="Link to empty">#</a>
               </h3>
               
               <p>empty reports whether the unread portion of the buffer is empty.</p>
               
               <pre><code class="language-go">func (b *Buffer) empty() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="explode" data-name="explode">
               <h3>
                  explode 
                  <span class="badge">function</span>
                  
                  <a href="#explode" class="anchor" title="Link to explode">#</a>
               </h3>
               
               <p>explode splits s into a slice of UTF-8 sequences, one per Unicode code point (still slices of bytes),
up to a maximum of n byte slices. Invalid UTF-8 sequences are chopped into individual bytes.</p>
               
               <pre><code class="language-go">func explode(s []byte, n int) [][]byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="explodeSeq" data-name="explodeSeq">
               <h3>
                  explodeSeq 
                  <span class="badge">function</span>
                  
                  <a href="#explodeSeq" class="anchor" title="Link to explodeSeq">#</a>
               </h3>
               
               <p>explodeSeq returns an iterator over the runes in s.</p>
               
               <pre><code class="language-go">func explodeSeq(s []byte) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="genSplit" data-name="genSplit">
               <h3>
                  genSplit 
                  <span class="badge">function</span>
                  
                  <a href="#genSplit" class="anchor" title="Link to genSplit">#</a>
               </h3>
               
               <p>Generic split: splits after each instance of sep,
including sepSave bytes of sep in the subslices.</p>
               
               <pre><code class="language-go">func genSplit(s []byte, sep []byte, sepSave int, n int) [][]byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="grow" data-name="grow">
               <h3>
                  grow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#grow" class="anchor" title="Link to grow">#</a>
               </h3>
               
               <p>grow grows the buffer to guarantee space for n more bytes.
It returns the index where bytes should be written.
If the buffer can't grow it will panic with ErrTooLarge.</p>
               
               <pre><code class="language-go">func (b *Buffer) grow(n int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="growSlice" data-name="growSlice">
               <h3>
                  growSlice 
                  <span class="badge">function</span>
                  
                  <a href="#growSlice" class="anchor" title="Link to growSlice">#</a>
               </h3>
               
               <p>growSlice grows b by n, preserving the original content of b.
If the allocation fails, it panics with ErrTooLarge.</p>
               
               <pre><code class="language-go">func growSlice(b []byte, n int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexBytePortable" data-name="indexBytePortable">
               <h3>
                  indexBytePortable 
                  <span class="badge">function</span>
                  
                  <a href="#indexBytePortable" class="anchor" title="Link to indexBytePortable">#</a>
               </h3>
               
               <pre><code class="language-go">func indexBytePortable(s []byte, c byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexFunc" data-name="indexFunc">
               <h3>
                  indexFunc 
                  <span class="badge">function</span>
                  
                  <a href="#indexFunc" class="anchor" title="Link to indexFunc">#</a>
               </h3>
               
               <p>indexFunc is the same as IndexFunc except that if
truth==false, the sense of the predicate function is
inverted.</p>
               
               <pre><code class="language-go">func indexFunc(s []byte, f func(r rune) bool, truth bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isSeparator" data-name="isSeparator">
               <h3>
                  isSeparator 
                  <span class="badge">function</span>
                  
                  <a href="#isSeparator" class="anchor" title="Link to isSeparator">#</a>
               </h3>
               
               <p>isSeparator reports whether the rune could mark a word boundary.
TODO: update when package unicode captures more of the properties.</p>
               
               <pre><code class="language-go">func isSeparator(r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lastIndexFunc" data-name="lastIndexFunc">
               <h3>
                  lastIndexFunc 
                  <span class="badge">function</span>
                  
                  <a href="#lastIndexFunc" class="anchor" title="Link to lastIndexFunc">#</a>
               </h3>
               
               <p>lastIndexFunc is the same as LastIndexFunc except that if
truth==false, the sense of the predicate function is
inverted.</p>
               
               <pre><code class="language-go">func lastIndexFunc(s []byte, f func(r rune) bool, truth bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeASCIISet" data-name="makeASCIISet">
               <h3>
                  makeASCIISet 
                  <span class="badge">function</span>
                  
                  <a href="#makeASCIISet" class="anchor" title="Link to makeASCIISet">#</a>
               </h3>
               
               <p>makeASCIISet creates a set of ASCII characters and reports whether all
characters in chars are ASCII.</p>
               
               <pre><code class="language-go">func makeASCIISet(chars string) (as asciiSet, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readSlice" data-name="readSlice">
               <h3>
                  readSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readSlice" class="anchor" title="Link to readSlice">#</a>
               </h3>
               
               <p>readSlice is like ReadBytes but returns a reference to internal buffer data.</p>
               
               <pre><code class="language-go">func (b *Buffer) readSlice(delim byte) (line []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitSeq" data-name="splitSeq">
               <h3>
                  splitSeq 
                  <span class="badge">function</span>
                  
                  <a href="#splitSeq" class="anchor" title="Link to splitSeq">#</a>
               </h3>
               
               <p>splitSeq is SplitSeq or SplitAfterSeq, configured by how many
bytes of sep to include in the results (none or all).</p>
               
               <pre><code class="language-go">func splitSeq(s []byte, sep []byte, sepSave int) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimLeftASCII" data-name="trimLeftASCII">
               <h3>
                  trimLeftASCII 
                  <span class="badge">function</span>
                  
                  <a href="#trimLeftASCII" class="anchor" title="Link to trimLeftASCII">#</a>
               </h3>
               
               <pre><code class="language-go">func trimLeftASCII(s []byte, as *asciiSet) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimLeftByte" data-name="trimLeftByte">
               <h3>
                  trimLeftByte 
                  <span class="badge">function</span>
                  
                  <a href="#trimLeftByte" class="anchor" title="Link to trimLeftByte">#</a>
               </h3>
               
               <pre><code class="language-go">func trimLeftByte(s []byte, c byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimLeftUnicode" data-name="trimLeftUnicode">
               <h3>
                  trimLeftUnicode 
                  <span class="badge">function</span>
                  
                  <a href="#trimLeftUnicode" class="anchor" title="Link to trimLeftUnicode">#</a>
               </h3>
               
               <pre><code class="language-go">func trimLeftUnicode(s []byte, cutset string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimRightASCII" data-name="trimRightASCII">
               <h3>
                  trimRightASCII 
                  <span class="badge">function</span>
                  
                  <a href="#trimRightASCII" class="anchor" title="Link to trimRightASCII">#</a>
               </h3>
               
               <pre><code class="language-go">func trimRightASCII(s []byte, as *asciiSet) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimRightByte" data-name="trimRightByte">
               <h3>
                  trimRightByte 
                  <span class="badge">function</span>
                  
                  <a href="#trimRightByte" class="anchor" title="Link to trimRightByte">#</a>
               </h3>
               
               <pre><code class="language-go">func trimRightByte(s []byte, c byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimRightUnicode" data-name="trimRightUnicode">
               <h3>
                  trimRightUnicode 
                  <span class="badge">function</span>
                  
                  <a href="#trimRightUnicode" class="anchor" title="Link to trimRightUnicode">#</a>
               </h3>
               
               <pre><code class="language-go">func trimRightUnicode(s []byte, cutset string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryGrowByReslice" data-name="tryGrowByReslice">
               <h3>
                  tryGrowByReslice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tryGrowByReslice" class="anchor" title="Link to tryGrowByReslice">#</a>
               </h3>
               
               <p>tryGrowByReslice is an inlineable version of grow for the fast-case where the
internal buffer only needs to be resliced.
It returns the index where bytes should be written and whether it succeeded.</p>
               
               <pre><code class="language-go">func (b *Buffer) tryGrowByReslice(n int) (int, bool)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>