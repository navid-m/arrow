<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - sql</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="database_sql_driver-docs.html">driver</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>sql</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"database/sql/driver"
"errors"
"fmt"
"reflect"
"strconv"
"time"
"unicode"
"unicode/utf8"
_ "unsafe"
"context"
"database/sql/driver"
"errors"
"context"
"database/sql/driver"
"errors"
"fmt"
"io"
"maps"
"math/rand/v2"
"reflect"
"runtime"
"slices"
"strconv"
"sync"
"sync/atomic"
"time"
_ "unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="ErrConnDone">
               <h3>
                  ErrConnDone 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrConnDone is returned by any operation that is performed on a connection
that has already been returned to the connection pool.</p>
               
               <pre><code>var ErrConnDone = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrNoRows">
               <h3>
                  ErrNoRows 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrNoRows is returned by [Row.Scan] when [DB.QueryRow] doesn't return a
row. In such a case, QueryRow returns a placeholder [*Row] value that
defers this error until a Scan.</p>
               
               <pre><code>var ErrNoRows = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ErrTxDone">
               <h3>
                  ErrTxDone 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ErrTxDone is returned by any operation that is performed on a transaction
that has already been committed or rolled back.</p>
               
               <pre><code>var ErrTxDone = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="LevelDefault">
               <h3>
                  LevelDefault 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Various isolation levels that drivers may support in [DB.BeginTx].
If a driver does not support a given isolation level an error may be returned.
See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.</p>
               
               <pre><code>const LevelDefault IsolationLevel = iota</code></pre>
            </article>
            
            <article class="global" data-name="LevelLinearizable">
               <h3>
                  LevelLinearizable 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Various isolation levels that drivers may support in [DB.BeginTx].
If a driver does not support a given isolation level an error may be returned.
See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.</p>
               
               <pre><code>const LevelLinearizable</code></pre>
            </article>
            
            <article class="global" data-name="LevelReadCommitted">
               <h3>
                  LevelReadCommitted 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Various isolation levels that drivers may support in [DB.BeginTx].
If a driver does not support a given isolation level an error may be returned.
See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.</p>
               
               <pre><code>const LevelReadCommitted</code></pre>
            </article>
            
            <article class="global" data-name="LevelReadUncommitted">
               <h3>
                  LevelReadUncommitted 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Various isolation levels that drivers may support in [DB.BeginTx].
If a driver does not support a given isolation level an error may be returned.
See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.</p>
               
               <pre><code>const LevelReadUncommitted</code></pre>
            </article>
            
            <article class="global" data-name="LevelRepeatableRead">
               <h3>
                  LevelRepeatableRead 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Various isolation levels that drivers may support in [DB.BeginTx].
If a driver does not support a given isolation level an error may be returned.
See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.</p>
               
               <pre><code>const LevelRepeatableRead</code></pre>
            </article>
            
            <article class="global" data-name="LevelSerializable">
               <h3>
                  LevelSerializable 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Various isolation levels that drivers may support in [DB.BeginTx].
If a driver does not support a given isolation level an error may be returned.
See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.</p>
               
               <pre><code>const LevelSerializable</code></pre>
            </article>
            
            <article class="global" data-name="LevelSnapshot">
               <h3>
                  LevelSnapshot 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Various isolation levels that drivers may support in [DB.BeginTx].
If a driver does not support a given isolation level an error may be returned.
See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.</p>
               
               <pre><code>const LevelSnapshot</code></pre>
            </article>
            
            <article class="global" data-name="LevelWriteCommitted">
               <h3>
                  LevelWriteCommitted 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Various isolation levels that drivers may support in [DB.BeginTx].
If a driver does not support a given isolation level an error may be returned.
See https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels.</p>
               
               <pre><code>const LevelWriteCommitted</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ stmtConnGrabber = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ fmt.Stringer = LevelDefault</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _ stmtConnGrabber = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="alwaysNewConn">
               <h3>
                  alwaysNewConn 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>alwaysNewConn forces a new connection to the database.</p>
               
               <pre><code>const alwaysNewConn connReuseStrategy = iota</code></pre>
            </article>
            
            <article class="global" data-name="bypassRowsAwaitDone">
               <h3>
                  bypassRowsAwaitDone 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>bypassRowsAwaitDone is only used for testing.
If true, it will not close the Rows automatically from the context.</p>
               
               <pre><code>var bypassRowsAwaitDone = false</code></pre>
            </article>
            
            <article class="global" data-name="cachedOrNewConn">
               <h3>
                  cachedOrNewConn 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>cachedOrNewConn returns a cached connection, if available, else waits
for one to become available (if MaxOpenConns has been reached) or
creates a new database connection.</p>
               
               <pre><code>const cachedOrNewConn</code></pre>
            </article>
            
            <article class="global" data-name="connectionRequestQueueSize">
               <h3>
                  connectionRequestQueueSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>This is the size of the connectionOpener request chan (DB.openerCh).
This value should be larger than the maximum typical value
used for DB.maxOpen. If maxOpen is significantly larger than
connectionRequestQueueSize then it is possible for ALL calls into the *DB
to block until the connectionOpener can satisfy the backlog of requests.</p>
               
               <pre><code>var connectionRequestQueueSize = 1000000</code></pre>
            </article>
            
            <article class="global" data-name="debugGetPut">
               <h3>
                  debugGetPut 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>debugGetPut determines whether getConn & putConn calls' stack traces
are returned for more verbose crashes.</p>
               
               <pre><code>const debugGetPut = false</code></pre>
            </article>
            
            <article class="global" data-name="defaultMaxIdleConns">
               <h3>
                  defaultMaxIdleConns 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const defaultMaxIdleConns = 2</code></pre>
            </article>
            
            <article class="global" data-name="drivers">
               <h3>
                  drivers 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>drivers should be an internal detail,
but widely used packages access it using linkname.
(It is extra wrong that they linkname drivers but not driversMu.)
Notable members of the hall of shame include:
- github.com/instana/go-sensor
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname drivers</p>
               
               <pre><code>var drivers = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="driversMu">
               <h3>
                  driversMu 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var driversMu sync.RWMutex</code></pre>
            </article>
            
            <article class="global" data-name="errDBClosed">
               <h3>
                  errDBClosed 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errDBClosed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errNilPtr">
               <h3>
                  errNilPtr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errNilPtr = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errNoRows">
               <h3>
                  errNoRows 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errNoRows = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errRowsClosed">
               <h3>
                  errRowsClosed 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errRowsClosed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="hookTxGrabConn">
               <h3>
                  hookTxGrabConn 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>hookTxGrabConn specifies an optional hook to be called on
a successful call to (*Tx).grabConn. For tests.</p>
               
               <pre><code>var hookTxGrabConn func()</code></pre>
            </article>
            
            <article class="global" data-name="maxBadConnRetries">
               <h3>
                  maxBadConnRetries 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxBadConnRetries is the number of maximum retries if the driver returns
driver.ErrBadConn to signal a broken connection before forcing a new
connection to be opened.</p>
               
               <pre><code>const maxBadConnRetries = 2</code></pre>
            </article>
            
            <article class="global" data-name="nowFunc">
               <h3>
                  nowFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>nowFunc returns the current time; it's overridden in tests.</p>
               
               <pre><code>var nowFunc = time.Now</code></pre>
            </article>
            
            <article class="global" data-name="putConnHook">
               <h3>
                  putConnHook 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>putConnHook is a hook for testing.</p>
               
               <pre><code>var putConnHook func(*DB, *driverConn)</code></pre>
            </article>
            
            <article class="global" data-name="rollbackHook">
               <h3>
                  rollbackHook 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var rollbackHook func()</code></pre>
            </article>
            
            <article class="global" data-name="rowsCloseHook">
               <h3>
                  rowsCloseHook 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>rowsCloseHook returns a function so tests may install the
hook through a test only mutex.</p>
               
               <pre><code>var rowsCloseHook = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="valuerReflectType">
               <h3>
                  valuerReflectType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var valuerReflectType = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="IsolationLevel">
               <h3>
                  IsolationLevel
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>IsolationLevel is the transaction isolation level used in [TxOptions].</p>
               
               <pre><code>type IsolationLevel int</code></pre>
            </article>
            
            <article class="type" data-name="RawBytes">
               <h3>
                  RawBytes
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>RawBytes is a byte slice that holds a reference to memory owned by
the database itself. After a [Rows.Scan] into a RawBytes, the slice is only
valid until the next call to [Rows.Next], [Rows.Scan], or [Rows.Close].</p>
               
               <pre><code>type RawBytes []byte</code></pre>
            </article>
            
            <article class="type" data-name="connReuseStrategy">
               <h3>
                  connReuseStrategy
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>connReuseStrategy determines how (*DB).conn returns database connections.</p>
               
               <pre><code>type connReuseStrategy uint8</code></pre>
            </article>
            
            <article class="type" data-name="depSet">
               <h3>
                  depSet
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>depSet is a finalCloser's outstanding dependencies</p>
               
               <pre><code>type depSet map[any]bool</code></pre>
            </article>
            
            <article class="type" data-name="releaseConn">
               <h3>
                  releaseConn
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type releaseConn func(error)</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Result">
               <h3>
                  Result
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A Result summarizes an executed SQL command.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Result interface {
LastInsertId() (int64, error)
RowsAffected() (int64, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Scanner">
               <h3>
                  Scanner
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Scanner is an interface used by [Rows.Scan].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Scanner interface {
Scan(src any) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="decimal">
               <h3>
                  decimal
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>decimal composes or decomposes a decimal value to and from individual parts.
There are four parts: a boolean negative flag, a form byte with three possible states
(finite=0, infinite=1, NaN=2), a base-2 big-endian integer
coefficient (also known as a significand) as a []byte, and an int32 exponent.
These are composed into a final value as "decimal = (neg) (form=finite) coefficient * 10 ^ exponent".
A zero length coefficient is a zero value.
The big-endian integer coefficient stores the most significant byte first (at coefficient[0]).
If the form is not finite the coefficient and exponent should be ignored.
The negative parameter may be set to true for any form, although implementations are not required
to respect the negative parameter in the non-finite form.
Implementations may choose to set the negative parameter to true on a zero or NaN value,
but implementations that do not differentiate between negative and positive
zero or NaN values should ignore the negative parameter without error.
If an implementation does not support Infinity it may be converted into a NaN without error.
If a value is set that is larger than what is supported by an implementation,
an error must be returned.
Implementations must return an error if a NaN or Infinity is attempted to be set while neither
are supported.
NOTE(kardianos): This is an experimental interface. See https://golang.org/issue/30870</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type decimal interface {
decimalDecompose
decimalCompose
}</code></pre>
            </article>
            
            <article class="interface" data-name="decimalCompose">
               <h3>
                  decimalCompose
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type decimalCompose interface {
Compose(form byte, negative bool, coefficient []byte, exponent int32) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="decimalDecompose">
               <h3>
                  decimalDecompose
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type decimalDecompose interface {
Decompose(buf []byte) (form byte, negative bool, coefficient []byte, exponent int32)
}</code></pre>
            </article>
            
            <article class="interface" data-name="finalCloser">
               <h3>
                  finalCloser
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>The finalCloser interface is used by (*DB).addDep and related
dependency reference counting.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type finalCloser interface {
finalClose() error
}</code></pre>
            </article>
            
            <article class="interface" data-name="stmtConnGrabber">
               <h3>
                  stmtConnGrabber
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>stmtConnGrabber represents a Tx or Conn that will return the underlying
driverConn and release function.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type stmtConnGrabber interface {
grabConn(context.Context) (*driverConn, releaseConn, error)
txCtx() context.Context
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="ColumnType">
               <h3>
                  ColumnType
                  <span class="badge">struct</span>
               </h3>
               
               <p>ColumnType contains the name and type of a column.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ColumnType struct {
name string
hasNullable bool
hasLength bool
hasPrecisionScale bool
nullable bool
length int64
databaseType string
precision int64
scale int64
scanType reflect.Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="Conn">
               <h3>
                  Conn
                  <span class="badge">struct</span>
               </h3>
               
               <p>Conn represents a single database connection rather than a pool of database
connections. Prefer running queries from [DB] unless there is a specific
need for a continuous single database connection.
A Conn must call [Conn.Close] to return the connection to the database pool
and may do so concurrently with a running query.
After a call to [Conn.Close], all operations on the
connection fail with [ErrConnDone].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Conn struct {
db *DB
closemu sync.RWMutex
dc *driverConn
done atomic.Bool
releaseConnOnce sync.Once
releaseConnCache releaseConn
}</code></pre>
            </article>
            
            <article class="struct" data-name="DB">
               <h3>
                  DB
                  <span class="badge">struct</span>
               </h3>
               
               <p>DB is a database handle representing a pool of zero or more
underlying connections. It's safe for concurrent use by multiple
goroutines.
The sql package creates and frees connections automatically; it
also maintains a free pool of idle connections. If the database has
a concept of per-connection state, such state can be reliably observed
within a transaction ([Tx]) or connection ([Conn]). Once [DB.Begin] is called, the
returned [Tx] is bound to a single connection. Once [Tx.Commit] or
[Tx.Rollback] is called on the transaction, that transaction's
connection is returned to [DB]'s idle connection pool. The pool size
can be controlled with [DB.SetMaxIdleConns].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DB struct {
waitDuration atomic.Int64
connector driver.Connector
numClosed atomic.Uint64
mu sync.Mutex
freeConn []*driverConn
connRequests connRequestSet
numOpen int
openerCh chan struct{...}
closed bool
dep map[finalCloser]depSet
lastPut map[*driverConn]string
maxIdleCount int
maxOpen int
maxLifetime time.Duration
maxIdleTime time.Duration
cleanerCh chan struct{...}
waitCount int64
maxIdleClosed int64
maxIdleTimeClosed int64
maxLifetimeClosed int64
stop func()
}</code></pre>
            </article>
            
            <article class="struct" data-name="DBStats">
               <h3>
                  DBStats
                  <span class="badge">struct</span>
               </h3>
               
               <p>DBStats contains database statistics.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DBStats struct {
MaxOpenConnections int
OpenConnections int
InUse int
Idle int
WaitCount int64
WaitDuration time.Duration
MaxIdleClosed int64
MaxIdleTimeClosed int64
MaxLifetimeClosed int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="NamedArg">
               <h3>
                  NamedArg
                  <span class="badge">struct</span>
               </h3>
               
               <p>A NamedArg is a named argument. NamedArg values may be used as
arguments to [DB.Query] or [DB.Exec] and bind to the corresponding named
parameter in the SQL statement.
For a more concise way to create NamedArg values, see
the [Named] function.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NamedArg struct {
_NamedFieldsRequired struct{...}
Name string
Value any
}</code></pre>
            </article>
            
            <article class="struct" data-name="Null">
               <h3>
                  Null
                  <span class="badge">struct</span>
               </h3>
               
               <p>Null represents a value that may be null.
Null implements the [Scanner] interface so
it can be used as a scan destination:
var s Null[string]
err := db.QueryRow("SELECT name FROM foo WHERE id=?", id).Scan(&s)
...
if s.Valid {
// use s.V
} else {
// NULL value
}
T should be one of the types accepted by [driver.Value].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Null struct {
V T
Valid bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="NullBool">
               <h3>
                  NullBool
                  <span class="badge">struct</span>
               </h3>
               
               <p>NullBool represents a bool that may be null.
NullBool implements the [Scanner] interface so
it can be used as a scan destination, similar to [NullString].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NullBool struct {
Bool bool
Valid bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="NullByte">
               <h3>
                  NullByte
                  <span class="badge">struct</span>
               </h3>
               
               <p>NullByte represents a byte that may be null.
NullByte implements the [Scanner] interface so
it can be used as a scan destination, similar to [NullString].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NullByte struct {
Byte byte
Valid bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="NullFloat64">
               <h3>
                  NullFloat64
                  <span class="badge">struct</span>
               </h3>
               
               <p>NullFloat64 represents a float64 that may be null.
NullFloat64 implements the [Scanner] interface so
it can be used as a scan destination, similar to [NullString].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NullFloat64 struct {
Float64 float64
Valid bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="NullInt16">
               <h3>
                  NullInt16
                  <span class="badge">struct</span>
               </h3>
               
               <p>NullInt16 represents an int16 that may be null.
NullInt16 implements the [Scanner] interface so
it can be used as a scan destination, similar to [NullString].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NullInt16 struct {
Int16 int16
Valid bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="NullInt32">
               <h3>
                  NullInt32
                  <span class="badge">struct</span>
               </h3>
               
               <p>NullInt32 represents an int32 that may be null.
NullInt32 implements the [Scanner] interface so
it can be used as a scan destination, similar to [NullString].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NullInt32 struct {
Int32 int32
Valid bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="NullInt64">
               <h3>
                  NullInt64
                  <span class="badge">struct</span>
               </h3>
               
               <p>NullInt64 represents an int64 that may be null.
NullInt64 implements the [Scanner] interface so
it can be used as a scan destination, similar to [NullString].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NullInt64 struct {
Int64 int64
Valid bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="NullString">
               <h3>
                  NullString
                  <span class="badge">struct</span>
               </h3>
               
               <p>NullString represents a string that may be null.
NullString implements the [Scanner] interface so
it can be used as a scan destination:
var s NullString
err := db.QueryRow("SELECT name FROM foo WHERE id=?", id).Scan(&s)
...
if s.Valid {
// use s.String
} else {
// NULL value
}</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NullString struct {
String string
Valid bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="NullTime">
               <h3>
                  NullTime
                  <span class="badge">struct</span>
               </h3>
               
               <p>NullTime represents a [time.Time] that may be null.
NullTime implements the [Scanner] interface so
it can be used as a scan destination, similar to [NullString].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NullTime struct {
Time time.Time
Valid bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Out">
               <h3>
                  Out
                  <span class="badge">struct</span>
               </h3>
               
               <p>Out may be used to retrieve OUTPUT value parameters from stored procedures.
Not all drivers and databases support OUTPUT value parameters.
Example usage:
var outArg string
_, err := db.ExecContext(ctx, "ProcName", sql.Named("Arg1", sql.Out{Dest: &outArg}))</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Out struct {
_NamedFieldsRequired struct{...}
Dest any
In bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Row">
               <h3>
                  Row
                  <span class="badge">struct</span>
               </h3>
               
               <p>Row is the result of calling [DB.QueryRow] to select a single row.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Row struct {
err error
rows *Rows
}</code></pre>
            </article>
            
            <article class="struct" data-name="Rows">
               <h3>
                  Rows
                  <span class="badge">struct</span>
               </h3>
               
               <p>Rows is the result of a query. Its cursor starts before the first row
of the result set. Use [Rows.Next] to advance from row to row.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Rows struct {
dc *driverConn
releaseConn func(error)
rowsi driver.Rows
cancel func()
closeStmt *driverStmt
contextDone *ast.IndexExpr
closemu sync.RWMutex
lasterr error
closed bool
closemuScanHold bool
hitEOF bool
lastcols []driver.Value
raw []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="Stmt">
               <h3>
                  Stmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>Stmt is a prepared statement.
A Stmt is safe for concurrent use by multiple goroutines.
If a Stmt is prepared on a [Tx] or [Conn], it will be bound to a single
underlying connection forever. If the [Tx] or [Conn] closes, the Stmt will
become unusable and all operations will return an error.
If a Stmt is prepared on a [DB], it will remain usable for the lifetime of the
[DB]. When the Stmt needs to execute on a new underlying connection, it will
prepare itself on the new connection automatically.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Stmt struct {
db *DB
query string
stickyErr error
closemu sync.RWMutex
cg stmtConnGrabber
cgds *driverStmt
parentStmt *Stmt
mu sync.Mutex
closed bool
css []connStmt
lastNumClosed uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Tx">
               <h3>
                  Tx
                  <span class="badge">struct</span>
               </h3>
               
               <p>Tx is an in-progress database transaction.
A transaction must end with a call to [Tx.Commit] or [Tx.Rollback].
After a call to [Tx.Commit] or [Tx.Rollback], all operations on the
transaction fail with [ErrTxDone].
The statements prepared for a transaction by calling
the transaction's [Tx.Prepare] or [Tx.Stmt] methods are closed
by the call to [Tx.Commit] or [Tx.Rollback].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Tx struct {
db *DB
closemu sync.RWMutex
dc *driverConn
txi driver.Tx
releaseConn func(error)
done atomic.Bool
keepConnOnRollback bool
stmts struct{...}
cancel func()
ctx context.Context
}</code></pre>
            </article>
            
            <article class="struct" data-name="TxOptions">
               <h3>
                  TxOptions
                  <span class="badge">struct</span>
               </h3>
               
               <p>TxOptions holds the transaction options to be used in [DB.BeginTx].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TxOptions struct {
Isolation IsolationLevel
ReadOnly bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="ccChecker">
               <h3>
                  ccChecker
                  <span class="badge">struct</span>
               </h3>
               
               <p>ccChecker wraps the driver.ColumnConverter and allows it to be used
as if it were a NamedValueChecker. If the driver ColumnConverter
is not present then the NamedValueChecker will return driver.ErrSkip.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ccChecker struct {
cci driver.ColumnConverter
want int
}</code></pre>
            </article>
            
            <article class="struct" data-name="connRequest">
               <h3>
                  connRequest
                  <span class="badge">struct</span>
               </h3>
               
               <p>connRequest represents one request for a new connection
When there are no idle connections available, DB.conn will create
a new connRequest and put it on the db.connRequests list.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type connRequest struct {
conn *driverConn
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="connRequestAndIndex">
               <h3>
                  connRequestAndIndex
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type connRequestAndIndex struct {
req chan connRequest
curIdx *int
}</code></pre>
            </article>
            
            <article class="struct" data-name="connRequestDelHandle">
               <h3>
                  connRequestDelHandle
                  <span class="badge">struct</span>
               </h3>
               
               <p>connRequestDelHandle is an opaque handle to delete an
item from calling Add.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type connRequestDelHandle struct {
idx *int
}</code></pre>
            </article>
            
            <article class="struct" data-name="connRequestSet">
               <h3>
                  connRequestSet
                  <span class="badge">struct</span>
               </h3>
               
               <p>connRequestSet is a set of chan connRequest that's
optimized for:
- adding an element
- removing an element (only by the caller who added it)
- taking (get + delete) a random element
We previously used a map for this but the take of a random element
was expensive, making mapiters. This type avoids a map entirely
and just uses a slice.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type connRequestSet struct {
s []connRequestAndIndex
}</code></pre>
            </article>
            
            <article class="struct" data-name="connStmt">
               <h3>
                  connStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>connStmt is a prepared statement on a particular connection.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type connStmt struct {
dc *driverConn
ds *driverStmt
}</code></pre>
            </article>
            
            <article class="struct" data-name="driverConn">
               <h3>
                  driverConn
                  <span class="badge">struct</span>
               </h3>
               
               <p>driverConn wraps a driver.Conn with a mutex, to
be held during all calls into the Conn. (including any calls onto
interfaces returned via that Conn, such as calls on Tx, Stmt,
Result, Rows)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type driverConn struct {
db *DB
createdAt time.Time
sync.Mutex
ci driver.Conn
needReset bool
closed bool
finalClosed bool
openStmt map[*driverStmt]bool
inUse bool
dbmuClosed bool
returnedAt time.Time
onPut []func()
}</code></pre>
            </article>
            
            <article class="struct" data-name="driverResult">
               <h3>
                  driverResult
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type driverResult struct {
sync.Locker
resi driver.Result
}</code></pre>
            </article>
            
            <article class="struct" data-name="driverStmt">
               <h3>
                  driverStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>driverStmt associates a driver.Stmt with the
*driverConn from which it came, so the driverConn's lock can be
held during calls.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type driverStmt struct {
sync.Locker
si driver.Stmt
closed bool
closeErr error
}</code></pre>
            </article>
            
            <article class="struct" data-name="dsnConnector">
               <h3>
                  dsnConnector
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dsnConnector struct {
dsn string
driver driver.Driver
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add adds v to the set of waiting requests.
The returned connRequestDelHandle can be used to remove the item from
the set.</p>
               
               <pre><code>func (s *connRequestSet) Add(v chan connRequest) connRequestDelHandle</code></pre>
            </article>
            
            <article class="function" data-name="Begin">
               <h3>
                  Begin 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Begin starts a transaction. The default isolation level is dependent on
the driver.
Begin uses [context.Background] internally; to specify the context, use
[DB.BeginTx].</p>
               
               <pre><code>func (db *DB) Begin() (*Tx, error)</code></pre>
            </article>
            
            <article class="function" data-name="BeginTx">
               <h3>
                  BeginTx 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BeginTx starts a transaction.
The provided context is used until the transaction is committed or rolled back.
If the context is canceled, the sql package will roll back
the transaction. [Tx.Commit] will return an error if the context provided to
BeginTx is canceled.
The provided [TxOptions] is optional and may be nil if defaults should be used.
If a non-default isolation level is used that the driver doesn't support,
an error will be returned.</p>
               
               <pre><code>func (c *Conn) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)</code></pre>
            </article>
            
            <article class="function" data-name="BeginTx">
               <h3>
                  BeginTx 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BeginTx starts a transaction.
The provided context is used until the transaction is committed or rolled back.
If the context is canceled, the sql package will roll back
the transaction. [Tx.Commit] will return an error if the context provided to
BeginTx is canceled.
The provided [TxOptions] is optional and may be nil if defaults should be used.
If a non-default isolation level is used that the driver doesn't support,
an error will be returned.</p>
               
               <pre><code>func (db *DB) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)</code></pre>
            </article>
            
            <article class="function" data-name="CheckNamedValue">
               <h3>
                  CheckNamedValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c ccChecker) CheckNamedValue(nv *driver.NamedValue) error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the statement.</p>
               
               <pre><code>func (s *Stmt) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dc *driverConn) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the [Rows], preventing further enumeration. If [Rows.Next] is called
and returns false and there are no further result sets,
the [Rows] are closed automatically and it will suffice to check the
result of [Rows.Err]. Close is idempotent and does not affect the result of [Rows.Err].</p>
               
               <pre><code>func (rs *Rows) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the database and prevents new queries from starting.
Close then waits for all queries that have started processing on the server
to finish.
It is rare to Close a [DB], as the [DB] handle is meant to be
long-lived and shared between many goroutines.</p>
               
               <pre><code>func (db *DB) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close ensures driver.Stmt is only closed once and always returns the same
result.</p>
               
               <pre><code>func (ds *driverStmt) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close returns the connection to the connection pool.
All operations after a Close will return with [ErrConnDone].
Close is safe to call concurrently with other operations and will
block until all other operations finish. It may be useful to first
cancel any used context and then call close directly after.</p>
               
               <pre><code>func (c *Conn) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="CloseAndRemoveAll">
               <h3>
                  CloseAndRemoveAll 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CloseAndRemoveAll closes all channels in the set
and clears the set.</p>
               
               <pre><code>func (s *connRequestSet) CloseAndRemoveAll()</code></pre>
            </article>
            
            <article class="function" data-name="ColumnTypes">
               <h3>
                  ColumnTypes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ColumnTypes returns column information such as column type, length,
and nullable. Some information may not be available from some drivers.</p>
               
               <pre><code>func (rs *Rows) ColumnTypes() ([]*ColumnType, error)</code></pre>
            </article>
            
            <article class="function" data-name="Columns">
               <h3>
                  Columns 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Columns returns the column names.
Columns returns an error if the rows are closed.</p>
               
               <pre><code>func (rs *Rows) Columns() ([]string, error)</code></pre>
            </article>
            
            <article class="function" data-name="Commit">
               <h3>
                  Commit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Commit commits the transaction.</p>
               
               <pre><code>func (tx *Tx) Commit() error</code></pre>
            </article>
            
            <article class="function" data-name="Conn">
               <h3>
                  Conn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Conn returns a single connection by either opening a new connection
or returning an existing connection from the connection pool. Conn will
block until either a connection is returned or ctx is canceled.
Queries run on the same Conn will be run in the same database session.
Every Conn must be returned to the database pool after use by
calling [Conn.Close].</p>
               
               <pre><code>func (db *DB) Conn(ctx context.Context) (*Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="Connect">
               <h3>
                  Connect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t dsnConnector) Connect(_ context.Context) (driver.Conn, error)</code></pre>
            </article>
            
            <article class="function" data-name="DatabaseTypeName">
               <h3>
                  DatabaseTypeName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DatabaseTypeName returns the database system name of the column type. If an empty
string is returned, then the driver type name is not supported.
Consult your driver documentation for a list of driver data types. [ColumnType.Length] specifiers
are not included.
Common type names include "VARCHAR", "TEXT", "NVARCHAR", "DECIMAL", "BOOL",
"INT", and "BIGINT".</p>
               
               <pre><code>func (ci *ColumnType) DatabaseTypeName() string</code></pre>
            </article>
            
            <article class="function" data-name="DecimalSize">
               <h3>
                  DecimalSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DecimalSize returns the scale and precision of a decimal type.
If not applicable or if not supported ok is false.</p>
               
               <pre><code>func (ci *ColumnType) DecimalSize() (precision int64, scale int64, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Delete">
               <h3>
                  Delete 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Delete removes an element from the set.
It reports whether the element was deleted. (It can return false if a caller
of TakeRandom took it meanwhile, or upon the second call to Delete)</p>
               
               <pre><code>func (s *connRequestSet) Delete(h connRequestDelHandle) bool</code></pre>
            </article>
            
            <article class="function" data-name="Driver">
               <h3>
                  Driver 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t dsnConnector) Driver() driver.Driver</code></pre>
            </article>
            
            <article class="function" data-name="Driver">
               <h3>
                  Driver 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Driver returns the database's underlying driver.</p>
               
               <pre><code>func (db *DB) Driver() driver.Driver</code></pre>
            </article>
            
            <article class="function" data-name="Drivers">
               <h3>
                  Drivers 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Drivers returns a sorted list of the names of the registered drivers.</p>
               
               <pre><code>func Drivers() []string</code></pre>
            </article>
            
            <article class="function" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Err returns the error, if any, that was encountered during iteration.
Err may be called after an explicit or implicit [Rows.Close].</p>
               
               <pre><code>func (rs *Rows) Err() error</code></pre>
            </article>
            
            <article class="function" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Err provides a way for wrapping packages to check for
query errors without calling [Row.Scan].
Err returns the error, if any, that was encountered while running the query.
If this error is not nil, this error will also be returned from [Row.Scan].</p>
               
               <pre><code>func (r *Row) Err() error</code></pre>
            </article>
            
            <article class="function" data-name="Exec">
               <h3>
                  Exec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Exec executes a query without returning any rows.
The args are for any placeholder parameters in the query.
Exec uses [context.Background] internally; to specify the context, use
[DB.ExecContext].</p>
               
               <pre><code>func (db *DB) Exec(query string, args ...any) (Result, error)</code></pre>
            </article>
            
            <article class="function" data-name="Exec">
               <h3>
                  Exec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Exec executes a query that doesn't return rows.
For example: an INSERT and UPDATE.
Exec uses [context.Background] internally; to specify the context, use
[Tx.ExecContext].</p>
               
               <pre><code>func (tx *Tx) Exec(query string, args ...any) (Result, error)</code></pre>
            </article>
            
            <article class="function" data-name="Exec">
               <h3>
                  Exec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Exec executes a prepared statement with the given arguments and
returns a [Result] summarizing the effect of the statement.
Exec uses [context.Background] internally; to specify the context, use
[Stmt.ExecContext].</p>
               
               <pre><code>func (s *Stmt) Exec(args ...any) (Result, error)</code></pre>
            </article>
            
            <article class="function" data-name="ExecContext">
               <h3>
                  ExecContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ExecContext executes a query without returning any rows.
The args are for any placeholder parameters in the query.</p>
               
               <pre><code>func (c *Conn) ExecContext(ctx context.Context, query string, args ...any) (Result, error)</code></pre>
            </article>
            
            <article class="function" data-name="ExecContext">
               <h3>
                  ExecContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ExecContext executes a query without returning any rows.
The args are for any placeholder parameters in the query.</p>
               
               <pre><code>func (db *DB) ExecContext(ctx context.Context, query string, args ...any) (Result, error)</code></pre>
            </article>
            
            <article class="function" data-name="ExecContext">
               <h3>
                  ExecContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ExecContext executes a query that doesn't return rows.
For example: an INSERT and UPDATE.</p>
               
               <pre><code>func (tx *Tx) ExecContext(ctx context.Context, query string, args ...any) (Result, error)</code></pre>
            </article>
            
            <article class="function" data-name="ExecContext">
               <h3>
                  ExecContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ExecContext executes a prepared statement with the given arguments and
returns a [Result] summarizing the effect of the statement.</p>
               
               <pre><code>func (s *Stmt) ExecContext(ctx context.Context, args ...any) (Result, error)</code></pre>
            </article>
            
            <article class="function" data-name="LastInsertId">
               <h3>
                  LastInsertId 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dr driverResult) LastInsertId() (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Len returns the length of the set.</p>
               
               <pre><code>func (s *connRequestSet) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Length">
               <h3>
                  Length 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Length returns the column type length for variable length column types such
as text and binary field types. If the type length is unbounded the value will
be [math.MaxInt64] (any database limits will still apply).
If the column type is not variable length, such as an int, or if not supported
by the driver ok is false.</p>
               
               <pre><code>func (ci *ColumnType) Length() (length int64, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Name returns the name or alias of the column.</p>
               
               <pre><code>func (ci *ColumnType) Name() string</code></pre>
            </article>
            
            <article class="function" data-name="Named">
               <h3>
                  Named 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Named provides a more concise way to create [NamedArg] values.
Example usage:
db.ExecContext(ctx, `
delete from Invoice
where
TimeCreated < @end
and TimeCreated >= @start;`,
sql.Named("start", startTime),
sql.Named("end", endTime),
)</p>
               
               <pre><code>func Named(name string, value any) NamedArg</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Next prepares the next result row for reading with the [Rows.Scan] method. It
returns true on success, or false if there is no next result row or an error
happened while preparing it. [Rows.Err] should be consulted to distinguish between
the two cases.
Every call to [Rows.Scan], even the first one, must be preceded by a call to [Rows.Next].</p>
               
               <pre><code>func (rs *Rows) Next() bool</code></pre>
            </article>
            
            <article class="function" data-name="NextResultSet">
               <h3>
                  NextResultSet 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NextResultSet prepares the next result set for reading. It reports whether
there is further result sets, or false if there is no further result set
or if there is an error advancing to it. The [Rows.Err] method should be consulted
to distinguish between the two cases.
After calling NextResultSet, the [Rows.Next] method should always be called before
scanning. If there are further result sets they may not have rows in the result
set.</p>
               
               <pre><code>func (rs *Rows) NextResultSet() bool</code></pre>
            </article>
            
            <article class="function" data-name="Nullable">
               <h3>
                  Nullable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Nullable reports whether the column may be null.
If a driver does not support this property ok will be false.</p>
               
               <pre><code>func (ci *ColumnType) Nullable() (nullable bool, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Open opens a database specified by its database driver name and a
driver-specific data source name, usually consisting of at least a
database name and connection information.
Most users will open a database via a driver-specific connection
helper function that returns a [*DB]. No database drivers are included
in the Go standard library. See https://golang.org/s/sqldrivers for
a list of third-party drivers.
Open may just validate its arguments without creating a connection
to the database. To verify that the data source name is valid, call
[DB.Ping].
The returned [DB] is safe for concurrent use by multiple goroutines
and maintains its own pool of idle connections. Thus, the Open
function should be called just once. It is rarely necessary to
close a [DB].</p>
               
               <pre><code>func Open(driverName string, dataSourceName string) (*DB, error)</code></pre>
            </article>
            
            <article class="function" data-name="OpenDB">
               <h3>
                  OpenDB 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>OpenDB opens a database using a [driver.Connector], allowing drivers to
bypass a string based data source name.
Most users will open a database via a driver-specific connection
helper function that returns a [*DB]. No database drivers are included
in the Go standard library. See https://golang.org/s/sqldrivers for
a list of third-party drivers.
OpenDB may just validate its arguments without creating a connection
to the database. To verify that the data source name is valid, call
[DB.Ping].
The returned [DB] is safe for concurrent use by multiple goroutines
and maintains its own pool of idle connections. Thus, the OpenDB
function should be called just once. It is rarely necessary to
close a [DB].</p>
               
               <pre><code>func OpenDB(c driver.Connector) *DB</code></pre>
            </article>
            
            <article class="function" data-name="Ping">
               <h3>
                  Ping 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Ping verifies a connection to the database is still alive,
establishing a connection if necessary.
Ping uses [context.Background] internally; to specify the context, use
[DB.PingContext].</p>
               
               <pre><code>func (db *DB) Ping() error</code></pre>
            </article>
            
            <article class="function" data-name="PingContext">
               <h3>
                  PingContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PingContext verifies the connection to the database is still alive.</p>
               
               <pre><code>func (c *Conn) PingContext(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function" data-name="PingContext">
               <h3>
                  PingContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PingContext verifies a connection to the database is still alive,
establishing a connection if necessary.</p>
               
               <pre><code>func (db *DB) PingContext(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function" data-name="Prepare">
               <h3>
                  Prepare 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Prepare creates a prepared statement for use within a transaction.
The returned statement operates within the transaction and will be closed
when the transaction has been committed or rolled back.
To use an existing prepared statement on this transaction, see [Tx.Stmt].
Prepare uses [context.Background] internally; to specify the context, use
[Tx.PrepareContext].</p>
               
               <pre><code>func (tx *Tx) Prepare(query string) (*Stmt, error)</code></pre>
            </article>
            
            <article class="function" data-name="Prepare">
               <h3>
                  Prepare 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Prepare creates a prepared statement for later queries or executions.
Multiple queries or executions may be run concurrently from the
returned statement.
The caller must call the statement's [*Stmt.Close] method
when the statement is no longer needed.
Prepare uses [context.Background] internally; to specify the context, use
[DB.PrepareContext].</p>
               
               <pre><code>func (db *DB) Prepare(query string) (*Stmt, error)</code></pre>
            </article>
            
            <article class="function" data-name="PrepareContext">
               <h3>
                  PrepareContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PrepareContext creates a prepared statement for use within a transaction.
The returned statement operates within the transaction and will be closed
when the transaction has been committed or rolled back.
To use an existing prepared statement on this transaction, see [Tx.Stmt].
The provided context will be used for the preparation of the context, not
for the execution of the returned statement. The returned statement
will run in the transaction context.</p>
               
               <pre><code>func (tx *Tx) PrepareContext(ctx context.Context, query string) (*Stmt, error)</code></pre>
            </article>
            
            <article class="function" data-name="PrepareContext">
               <h3>
                  PrepareContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PrepareContext creates a prepared statement for later queries or executions.
Multiple queries or executions may be run concurrently from the
returned statement.
The caller must call the statement's [*Stmt.Close] method
when the statement is no longer needed.
The provided context is used for the preparation of the statement, not for the
execution of the statement.</p>
               
               <pre><code>func (c *Conn) PrepareContext(ctx context.Context, query string) (*Stmt, error)</code></pre>
            </article>
            
            <article class="function" data-name="PrepareContext">
               <h3>
                  PrepareContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PrepareContext creates a prepared statement for later queries or executions.
Multiple queries or executions may be run concurrently from the
returned statement.
The caller must call the statement's [*Stmt.Close] method
when the statement is no longer needed.
The provided context is used for the preparation of the statement, not for the
execution of the statement.</p>
               
               <pre><code>func (db *DB) PrepareContext(ctx context.Context, query string) (*Stmt, error)</code></pre>
            </article>
            
            <article class="function" data-name="Query">
               <h3>
                  Query 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Query executes a query that returns rows, typically a SELECT.
The args are for any placeholder parameters in the query.
Query uses [context.Background] internally; to specify the context, use
[DB.QueryContext].</p>
               
               <pre><code>func (db *DB) Query(query string, args ...any) (*Rows, error)</code></pre>
            </article>
            
            <article class="function" data-name="Query">
               <h3>
                  Query 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Query executes a prepared query statement with the given arguments
and returns the query results as a *Rows.
Query uses [context.Background] internally; to specify the context, use
[Stmt.QueryContext].</p>
               
               <pre><code>func (s *Stmt) Query(args ...any) (*Rows, error)</code></pre>
            </article>
            
            <article class="function" data-name="Query">
               <h3>
                  Query 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Query executes a query that returns rows, typically a SELECT.
Query uses [context.Background] internally; to specify the context, use
[Tx.QueryContext].</p>
               
               <pre><code>func (tx *Tx) Query(query string, args ...any) (*Rows, error)</code></pre>
            </article>
            
            <article class="function" data-name="QueryContext">
               <h3>
                  QueryContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QueryContext executes a prepared query statement with the given arguments
and returns the query results as a [*Rows].</p>
               
               <pre><code>func (s *Stmt) QueryContext(ctx context.Context, args ...any) (*Rows, error)</code></pre>
            </article>
            
            <article class="function" data-name="QueryContext">
               <h3>
                  QueryContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QueryContext executes a query that returns rows, typically a SELECT.</p>
               
               <pre><code>func (tx *Tx) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error)</code></pre>
            </article>
            
            <article class="function" data-name="QueryContext">
               <h3>
                  QueryContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QueryContext executes a query that returns rows, typically a SELECT.
The args are for any placeholder parameters in the query.</p>
               
               <pre><code>func (db *DB) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error)</code></pre>
            </article>
            
            <article class="function" data-name="QueryContext">
               <h3>
                  QueryContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QueryContext executes a query that returns rows, typically a SELECT.
The args are for any placeholder parameters in the query.</p>
               
               <pre><code>func (c *Conn) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error)</code></pre>
            </article>
            
            <article class="function" data-name="QueryRow">
               <h3>
                  QueryRow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QueryRow executes a prepared query statement with the given arguments.
If an error occurs during the execution of the statement, that error will
be returned by a call to Scan on the returned [*Row], which is always non-nil.
If the query selects no rows, the [*Row.Scan] will return [ErrNoRows].
Otherwise, the [*Row.Scan] scans the first selected row and discards
the rest.
Example usage:
var name string
err := nameByUseridStmt.QueryRow(id).Scan(&name)
QueryRow uses [context.Background] internally; to specify the context, use
[Stmt.QueryRowContext].</p>
               
               <pre><code>func (s *Stmt) QueryRow(args ...any) *Row</code></pre>
            </article>
            
            <article class="function" data-name="QueryRow">
               <h3>
                  QueryRow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QueryRow executes a query that is expected to return at most one row.
QueryRow always returns a non-nil value. Errors are deferred until
[Row]'s Scan method is called.
If the query selects no rows, the [*Row.Scan] will return [ErrNoRows].
Otherwise, [*Row.Scan] scans the first selected row and discards
the rest.
QueryRow uses [context.Background] internally; to specify the context, use
[DB.QueryRowContext].</p>
               
               <pre><code>func (db *DB) QueryRow(query string, args ...any) *Row</code></pre>
            </article>
            
            <article class="function" data-name="QueryRow">
               <h3>
                  QueryRow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QueryRow executes a query that is expected to return at most one row.
QueryRow always returns a non-nil value. Errors are deferred until
[Row]'s Scan method is called.
If the query selects no rows, the [*Row.Scan] will return [ErrNoRows].
Otherwise, the [*Row.Scan] scans the first selected row and discards
the rest.
QueryRow uses [context.Background] internally; to specify the context, use
[Tx.QueryRowContext].</p>
               
               <pre><code>func (tx *Tx) QueryRow(query string, args ...any) *Row</code></pre>
            </article>
            
            <article class="function" data-name="QueryRowContext">
               <h3>
                  QueryRowContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QueryRowContext executes a query that is expected to return at most one row.
QueryRowContext always returns a non-nil value. Errors are deferred until
[Row]'s Scan method is called.
If the query selects no rows, the [*Row.Scan] will return [ErrNoRows].
Otherwise, [*Row.Scan] scans the first selected row and discards
the rest.</p>
               
               <pre><code>func (db *DB) QueryRowContext(ctx context.Context, query string, args ...any) *Row</code></pre>
            </article>
            
            <article class="function" data-name="QueryRowContext">
               <h3>
                  QueryRowContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QueryRowContext executes a prepared query statement with the given arguments.
If an error occurs during the execution of the statement, that error will
be returned by a call to Scan on the returned [*Row], which is always non-nil.
If the query selects no rows, the [*Row.Scan] will return [ErrNoRows].
Otherwise, the [*Row.Scan] scans the first selected row and discards
the rest.</p>
               
               <pre><code>func (s *Stmt) QueryRowContext(ctx context.Context, args ...any) *Row</code></pre>
            </article>
            
            <article class="function" data-name="QueryRowContext">
               <h3>
                  QueryRowContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QueryRowContext executes a query that is expected to return at most one row.
QueryRowContext always returns a non-nil value. Errors are deferred until
the [*Row.Scan] method is called.
If the query selects no rows, the [*Row.Scan] will return [ErrNoRows].
Otherwise, the [*Row.Scan] scans the first selected row and discards
the rest.</p>
               
               <pre><code>func (c *Conn) QueryRowContext(ctx context.Context, query string, args ...any) *Row</code></pre>
            </article>
            
            <article class="function" data-name="QueryRowContext">
               <h3>
                  QueryRowContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>QueryRowContext executes a query that is expected to return at most one row.
QueryRowContext always returns a non-nil value. Errors are deferred until
[Row]'s Scan method is called.
If the query selects no rows, the [*Row.Scan] will return [ErrNoRows].
Otherwise, the [*Row.Scan] scans the first selected row and discards
the rest.</p>
               
               <pre><code>func (tx *Tx) QueryRowContext(ctx context.Context, query string, args ...any) *Row</code></pre>
            </article>
            
            <article class="function" data-name="Raw">
               <h3>
                  Raw 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Raw executes f exposing the underlying driver connection for the
duration of f. The driverConn must not be used outside of f.
Once f returns and err is not [driver.ErrBadConn], the [Conn] will continue to be usable
until [Conn.Close] is called.</p>
               
               <pre><code>func (c *Conn) Raw(f func(driverConn any) error) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="Register">
               <h3>
                  Register 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Register makes a database driver available by the provided name.
If Register is called twice with the same name or if driver is nil,
it panics.</p>
               
               <pre><code>func Register(name string, driver driver.Driver)</code></pre>
            </article>
            
            <article class="function" data-name="Rollback">
               <h3>
                  Rollback 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Rollback aborts the transaction.</p>
               
               <pre><code>func (tx *Tx) Rollback() error</code></pre>
            </article>
            
            <article class="function" data-name="RowsAffected">
               <h3>
                  RowsAffected 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dr driverResult) RowsAffected() (int64, error)</code></pre>
            </article>
            
            <article class="function" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Scan implements the [Scanner] interface.</p>
               
               <pre><code>func (n *NullInt32) Scan(value any) error</code></pre>
            </article>
            
            <article class="function" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Scan implements the [Scanner] interface.</p>
               
               <pre><code>func (n *NullTime) Scan(value any) error</code></pre>
            </article>
            
            <article class="function" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n **ast.IndexExpr) Scan(value any) error</code></pre>
            </article>
            
            <article class="function" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Scan implements the [Scanner] interface.</p>
               
               <pre><code>func (n *NullBool) Scan(value any) error</code></pre>
            </article>
            
            <article class="function" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Scan implements the [Scanner] interface.</p>
               
               <pre><code>func (n *NullFloat64) Scan(value any) error</code></pre>
            </article>
            
            <article class="function" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Scan implements the [Scanner] interface.</p>
               
               <pre><code>func (ns *NullString) Scan(value any) error</code></pre>
            </article>
            
            <article class="function" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Scan copies the columns in the current row into the values pointed
at by dest. The number of values in dest must be the same as the
number of columns in [Rows].
Scan converts columns read from the database into the following
common Go types and special types provided by the sql package:
*string
*[]byte
*int, *int8, *int16, *int32, *int64
*uint, *uint8, *uint16, *uint32, *uint64
*bool
*float32, *float64
*interface{}
*RawBytes
*Rows (cursor value)
any type implementing Scanner (see Scanner docs)
In the most simple case, if the type of the value from the source
column is an integer, bool or string type T and dest is of type *T,
Scan simply assigns the value through the pointer.
Scan also converts between string and numeric types, as long as no
information would be lost. While Scan stringifies all numbers
scanned from numeric database columns into *string, scans into
numeric types are checked for overflow. For example, a float64 with
value 300 or a string with value "300" can scan into a uint16, but
not into a uint8, though float64(255) or "255" can scan into a
uint8. One exception is that scans of some float64 numbers to
strings may lose information when stringifying. In general, scan
floating point columns into *float64.
If a dest argument has type *[]byte, Scan saves in that argument a
copy of the corresponding data. The copy is owned by the caller and
can be modified and held indefinitely. The copy can be avoided by
using an argument of type [*RawBytes] instead; see the documentation
for [RawBytes] for restrictions on its use.
If an argument has type *interface{}, Scan copies the value
provided by the underlying driver without conversion. When scanning
from a source value of type []byte to *interface{}, a copy of the
slice is made and the caller owns the result.
Source values of type [time.Time] may be scanned into values of type
*time.Time, *interface{}, *string, or *[]byte. When converting to
the latter two, [time.RFC3339Nano] is used.
Source values of type bool may be scanned into types *bool,
*interface{}, *string, *[]byte, or [*RawBytes].
For scanning into *bool, the source may be true, false, 1, 0, or
string inputs parseable by [strconv.ParseBool].
Scan can also convert a cursor returned from a query, such as
"select cursor(select * from my_table) from dual", into a
[*Rows] value that can itself be scanned from. The parent
select query will close any cursor [*Rows] if the parent [*Rows] is closed.
If any of the first arguments implementing [Scanner] returns an error,
that error will be wrapped in the returned error.</p>
               
               <pre><code>func (rs *Rows) Scan(dest ...any) error</code></pre>
            </article>
            
            <article class="function" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Scan implements the [Scanner] interface.</p>
               
               <pre><code>func (n *NullInt16) Scan(value any) error</code></pre>
            </article>
            
            <article class="function" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Scan implements the [Scanner] interface.</p>
               
               <pre><code>func (n *NullInt64) Scan(value any) error</code></pre>
            </article>
            
            <article class="function" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Scan implements the [Scanner] interface.</p>
               
               <pre><code>func (n *NullByte) Scan(value any) error</code></pre>
            </article>
            
            <article class="function" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Scan copies the columns from the matched row into the values
pointed at by dest. See the documentation on [Rows.Scan] for details.
If more than one row matches the query,
Scan uses the first row and discards the rest. If no row matches
the query, Scan returns [ErrNoRows].</p>
               
               <pre><code>func (r *Row) Scan(dest ...any) error</code></pre>
            </article>
            
            <article class="function" data-name="ScanType">
               <h3>
                  ScanType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScanType returns a Go type suitable for scanning into using [Rows.Scan].
If a driver does not support this property ScanType will return
the type of an empty interface.</p>
               
               <pre><code>func (ci *ColumnType) ScanType() reflect.Type</code></pre>
            </article>
            
            <article class="function" data-name="SetConnMaxIdleTime">
               <h3>
                  SetConnMaxIdleTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetConnMaxIdleTime sets the maximum amount of time a connection may be idle.
Expired connections may be closed lazily before reuse.
If d <= 0, connections are not closed due to a connection's idle time.</p>
               
               <pre><code>func (db *DB) SetConnMaxIdleTime(d time.Duration)</code></pre>
            </article>
            
            <article class="function" data-name="SetConnMaxLifetime">
               <h3>
                  SetConnMaxLifetime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetConnMaxLifetime sets the maximum amount of time a connection may be reused.
Expired connections may be closed lazily before reuse.
If d <= 0, connections are not closed due to a connection's age.</p>
               
               <pre><code>func (db *DB) SetConnMaxLifetime(d time.Duration)</code></pre>
            </article>
            
            <article class="function" data-name="SetMaxIdleConns">
               <h3>
                  SetMaxIdleConns 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetMaxIdleConns sets the maximum number of connections in the idle
connection pool.
If MaxOpenConns is greater than 0 but less than the new MaxIdleConns,
then the new MaxIdleConns will be reduced to match the MaxOpenConns limit.
If n <= 0, no idle connections are retained.
The default max idle connections is currently 2. This may change in
a future release.</p>
               
               <pre><code>func (db *DB) SetMaxIdleConns(n int)</code></pre>
            </article>
            
            <article class="function" data-name="SetMaxOpenConns">
               <h3>
                  SetMaxOpenConns 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetMaxOpenConns sets the maximum number of open connections to the database.
If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than
MaxIdleConns, then MaxIdleConns will be reduced to match the new
MaxOpenConns limit.
If n <= 0, then there is no limit on the number of open connections.
The default is 0 (unlimited).</p>
               
               <pre><code>func (db *DB) SetMaxOpenConns(n int)</code></pre>
            </article>
            
            <article class="function" data-name="Stats">
               <h3>
                  Stats 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Stats returns database statistics.</p>
               
               <pre><code>func (db *DB) Stats() DBStats</code></pre>
            </article>
            
            <article class="function" data-name="Stmt">
               <h3>
                  Stmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Stmt returns a transaction-specific prepared statement from
an existing statement.
Example:
updateMoney, err := db.Prepare("UPDATE balance SET money=money+? WHERE id=?")
...
tx, err := db.Begin()
...
res, err := tx.Stmt(updateMoney).Exec(123.45, 98293203)
The returned statement operates within the transaction and will be closed
when the transaction has been committed or rolled back.
Stmt uses [context.Background] internally; to specify the context, use
[Tx.StmtContext].</p>
               
               <pre><code>func (tx *Tx) Stmt(stmt *Stmt) *Stmt</code></pre>
            </article>
            
            <article class="function" data-name="StmtContext">
               <h3>
                  StmtContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>StmtContext returns a transaction-specific prepared statement from
an existing statement.
Example:
updateMoney, err := db.Prepare("UPDATE balance SET money=money+? WHERE id=?")
...
tx, err := db.Begin()
...
res, err := tx.StmtContext(ctx, updateMoney).Exec(123.45, 98293203)
The provided context is used for the preparation of the statement, not for the
execution of the statement.
The returned statement operates within the transaction and will be closed
when the transaction has been committed or rolled back.</p>
               
               <pre><code>func (tx *Tx) StmtContext(ctx context.Context, stmt *Stmt) *Stmt</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the name of the transaction isolation level.</p>
               
               <pre><code>func (i IsolationLevel) String() string</code></pre>
            </article>
            
            <article class="function" data-name="TakeRandom">
               <h3>
                  TakeRandom 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TakeRandom returns and removes a random element from s
and reports whether there was one to take. (It returns ok=false
if the set is empty.)</p>
               
               <pre><code>func (s *connRequestSet) TakeRandom() (v chan connRequest, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Value implements the [driver.Valuer] interface.</p>
               
               <pre><code>func (n NullFloat64) Value() (driver.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Value implements the [driver.Valuer] interface.</p>
               
               <pre><code>func (n NullByte) Value() (driver.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Value implements the [driver.Valuer] interface.</p>
               
               <pre><code>func (ns NullString) Value() (driver.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Value implements the [driver.Valuer] interface.</p>
               
               <pre><code>func (n NullInt32) Value() (driver.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Value implements the [driver.Valuer] interface.</p>
               
               <pre><code>func (n NullInt16) Value() (driver.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Value implements the [driver.Valuer] interface.</p>
               
               <pre><code>func (n NullInt64) Value() (driver.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Value implements the [driver.Valuer] interface.</p>
               
               <pre><code>func (n NullBool) Value() (driver.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ast.IndexExpr) Value() (driver.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Value implements the [driver.Valuer] interface.</p>
               
               <pre><code>func (n NullTime) Value() (driver.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="addDep">
               <h3>
                  addDep 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addDep notes that x now depends on dep, and x's finalClose won't be
called until all of x's dependencies are removed with removeDep.</p>
               
               <pre><code>func (db *DB) addDep(x finalCloser, dep any)</code></pre>
            </article>
            
            <article class="function" data-name="addDepLocked">
               <h3>
                  addDepLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (db *DB) addDepLocked(x finalCloser, dep any)</code></pre>
            </article>
            
            <article class="function" data-name="asBytes">
               <h3>
                  asBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func asBytes(buf []byte, rv reflect.Value) (b []byte, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="asString">
               <h3>
                  asString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func asString(src any) string</code></pre>
            </article>
            
            <article class="function" data-name="awaitDone">
               <h3>
                  awaitDone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>awaitDone blocks until ctx, txctx, or closectx is canceled.
The ctx is provided from the query context.
If the query was issued in a transaction, the transaction's context
is also provided in txctx, to ensure Rows is closed if the Tx is closed.
The closectx is closed by an explicit call to rs.Close.</p>
               
               <pre><code>func (rs *Rows) awaitDone(ctx context.Context, txctx context.Context, closectx context.Context)</code></pre>
            </article>
            
            <article class="function" data-name="awaitDone">
               <h3>
                  awaitDone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>awaitDone blocks until the context in Tx is canceled and rolls back
the transaction if it's not already done.</p>
               
               <pre><code>func (tx *Tx) awaitDone()</code></pre>
            </article>
            
            <article class="function" data-name="begin">
               <h3>
                  begin 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (db *DB) begin(ctx context.Context, opts *TxOptions, strategy connReuseStrategy) (tx *Tx, err error)</code></pre>
            </article>
            
            <article class="function" data-name="beginDC">
               <h3>
                  beginDC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>beginDC starts a transaction. The provided dc must be valid and ready to use.</p>
               
               <pre><code>func (db *DB) beginDC(ctx context.Context, dc *driverConn, release func(error), opts *TxOptions) (tx *Tx, err error)</code></pre>
            </article>
            
            <article class="function" data-name="callValuerValue">
               <h3>
                  callValuerValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>callValuerValue returns vr.Value(), with one exception:
If vr.Value is an auto-generated method on a pointer type and the
pointer is nil, it would panic at runtime in the panicwrap
method. Treat it like nil instead.
Issue 8415.
This is so people can implement driver.Value on value types and
still use nil pointers to those types to mean nil/NULL, just like
string/*string.
This function is mirrored in the database/sql/driver package.</p>
               
               <pre><code>func callValuerValue(vr driver.Valuer) (v driver.Value, err error)</code></pre>
            </article>
            
            <article class="function" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rs *Rows) close(err error) error</code></pre>
            </article>
            
            <article class="function" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *Conn) close(err error) error</code></pre>
            </article>
            
            <article class="function" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>close returns the connection to the pool and
must only be called by Tx.rollback or Tx.Commit while
tx is already canceled and won't be executed concurrently.</p>
               
               <pre><code>func (tx *Tx) close(err error)</code></pre>
            </article>
            
            <article class="function" data-name="closeDBLocked">
               <h3>
                  closeDBLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>the dc.db's Mutex is held.</p>
               
               <pre><code>func (dc *driverConn) closeDBLocked() (func() error)</code></pre>
            </article>
            
            <article class="function" data-name="closePrepared">
               <h3>
                  closePrepared 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Closes all Stmts prepared for this transaction.</p>
               
               <pre><code>func (tx *Tx) closePrepared()</code></pre>
            </article>
            
            <article class="function" data-name="closemuRUnlockCondReleaseConn">
               <h3>
                  closemuRUnlockCondReleaseConn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>closemuRUnlockCondReleaseConn read unlocks closemu
as the sql operation is done with the dc.</p>
               
               <pre><code>func (c *Conn) closemuRUnlockCondReleaseConn(err error)</code></pre>
            </article>
            
            <article class="function" data-name="closemuRUnlockIfHeldByScan">
               <h3>
                  closemuRUnlockIfHeldByScan 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>closemuRUnlockIfHeldByScan releases any closemu.RLock held open by a previous
call to Scan with *RawBytes.</p>
               
               <pre><code>func (rs *Rows) closemuRUnlockIfHeldByScan()</code></pre>
            </article>
            
            <article class="function" data-name="closemuRUnlockRelease">
               <h3>
                  closemuRUnlockRelease 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>closemuRUnlockRelease is used as a func(error) method value in
[DB.ExecContext] and [DB.QueryContext]. Unlocking in the releaseConn keeps
the driver conn from being returned to the connection pool until
the Rows has been closed.</p>
               
               <pre><code>func (tx *Tx) closemuRUnlockRelease(error)</code></pre>
            </article>
            
            <article class="function" data-name="conn">
               <h3>
                  conn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>conn returns a newly-opened or cached *driverConn.</p>
               
               <pre><code>func (db *DB) conn(ctx context.Context, strategy connReuseStrategy) (*driverConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="connStmt">
               <h3>
                  connStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>connStmt returns a free driver connection on which to execute the
statement, a function to call to release the connection, and a
statement bound to that connection.</p>
               
               <pre><code>func (s *Stmt) connStmt(ctx context.Context, strategy connReuseStrategy) (dc *driverConn, releaseConn func(error), ds *driverStmt, err error)</code></pre>
            </article>
            
            <article class="function" data-name="connectionCleaner">
               <h3>
                  connectionCleaner 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (db *DB) connectionCleaner(d time.Duration)</code></pre>
            </article>
            
            <article class="function" data-name="connectionCleanerRunLocked">
               <h3>
                  connectionCleanerRunLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>connectionCleanerRunLocked removes connections that should be closed from
freeConn and returns them along side an updated duration to the next check
if a quicker check is required to ensure connections are checked appropriately.</p>
               
               <pre><code>func (db *DB) connectionCleanerRunLocked(d time.Duration) (time.Duration, []*driverConn)</code></pre>
            </article>
            
            <article class="function" data-name="connectionOpener">
               <h3>
                  connectionOpener 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Runs in a separate goroutine, opens new connections when requested.</p>
               
               <pre><code>func (db *DB) connectionOpener(ctx context.Context)</code></pre>
            </article>
            
            <article class="function" data-name="convertAssign">
               <h3>
                  convertAssign 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertAssign is the same as convertAssignRows, but without the optional
rows argument.
convertAssign should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- ariga.io/entcache
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname convertAssign</p>
               
               <pre><code>func convertAssign(dest any, src any) error</code></pre>
            </article>
            
            <article class="function" data-name="convertAssignRows">
               <h3>
                  convertAssignRows 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertAssignRows copies to dest the value in src, converting it if possible.
An error is returned if the copy would result in loss of information.
dest should be a pointer type. If rows is passed in, the rows will
be used as the parent for any cursor values converted from a
driver.Rows to a *Rows.</p>
               
               <pre><code>func convertAssignRows(dest any, src any, rows *Rows) error</code></pre>
            </article>
            
            <article class="function" data-name="ctxDriverBegin">
               <h3>
                  ctxDriverBegin 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ctxDriverBegin(ctx context.Context, opts *TxOptions, ci driver.Conn) (driver.Tx, error)</code></pre>
            </article>
            
            <article class="function" data-name="ctxDriverExec">
               <h3>
                  ctxDriverExec 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ctxDriverExec(ctx context.Context, execerCtx driver.ExecerContext, execer driver.Execer, query string, nvdargs []driver.NamedValue) (driver.Result, error)</code></pre>
            </article>
            
            <article class="function" data-name="ctxDriverPrepare">
               <h3>
                  ctxDriverPrepare 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ctxDriverPrepare(ctx context.Context, ci driver.Conn, query string) (driver.Stmt, error)</code></pre>
            </article>
            
            <article class="function" data-name="ctxDriverQuery">
               <h3>
                  ctxDriverQuery 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ctxDriverQuery(ctx context.Context, queryerCtx driver.QueryerContext, queryer driver.Queryer, query string, nvdargs []driver.NamedValue) (driver.Rows, error)</code></pre>
            </article>
            
            <article class="function" data-name="ctxDriverStmtExec">
               <h3>
                  ctxDriverStmtExec 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ctxDriverStmtExec(ctx context.Context, si driver.Stmt, nvdargs []driver.NamedValue) (driver.Result, error)</code></pre>
            </article>
            
            <article class="function" data-name="ctxDriverStmtQuery">
               <h3>
                  ctxDriverStmtQuery 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ctxDriverStmtQuery(ctx context.Context, si driver.Stmt, nvdargs []driver.NamedValue) (driver.Rows, error)</code></pre>
            </article>
            
            <article class="function" data-name="defaultCheckNamedValue">
               <h3>
                  defaultCheckNamedValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>defaultCheckNamedValue wraps the default ColumnConverter to have the same
function signature as the CheckNamedValue in the driver.NamedValueChecker
interface.</p>
               
               <pre><code>func defaultCheckNamedValue(nv *driver.NamedValue) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="deleteIndex">
               <h3>
                  deleteIndex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *connRequestSet) deleteIndex(idx int)</code></pre>
            </article>
            
            <article class="function" data-name="describeNamedValue">
               <h3>
                  describeNamedValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func describeNamedValue(nv *driver.NamedValue) string</code></pre>
            </article>
            
            <article class="function" data-name="driverArgsConnLocked">
               <h3>
                  driverArgsConnLocked 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>driverArgsConnLocked converts arguments from callers of Stmt.Exec and
Stmt.Query into driver Values.
The statement ds may be nil, if no statement is available.
ci must be locked.</p>
               
               <pre><code>func driverArgsConnLocked(ci driver.Conn, ds *driverStmt, args []any) ([]driver.NamedValue, error)</code></pre>
            </article>
            
            <article class="function" data-name="exec">
               <h3>
                  exec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (db *DB) exec(ctx context.Context, query string, args []any, strategy connReuseStrategy) (Result, error)</code></pre>
            </article>
            
            <article class="function" data-name="execDC">
               <h3>
                  execDC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (db *DB) execDC(ctx context.Context, dc *driverConn, release func(error), query string, args []any) (res Result, err error)</code></pre>
            </article>
            
            <article class="function" data-name="expired">
               <h3>
                  expired 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dc *driverConn) expired(timeout time.Duration) bool</code></pre>
            </article>
            
            <article class="function" data-name="finalClose">
               <h3>
                  finalClose 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dc *driverConn) finalClose() error</code></pre>
            </article>
            
            <article class="function" data-name="finalClose">
               <h3>
                  finalClose 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Stmt) finalClose() error</code></pre>
            </article>
            
            <article class="function" data-name="grabConn">
               <h3>
                  grabConn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (tx *Tx) grabConn(ctx context.Context) (*driverConn, releaseConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="grabConn">
               <h3>
                  grabConn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>grabConn takes a context to implement stmtConnGrabber
but the context is not used.</p>
               
               <pre><code>func (c *Conn) grabConn(context.Context) (*driverConn, releaseConn, error)</code></pre>
            </article>
            
            <article class="function" data-name="initContextClose">
               <h3>
                  initContextClose 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rs *Rows) initContextClose(ctx context.Context, txctx context.Context)</code></pre>
            </article>
            
            <article class="function" data-name="isDone">
               <h3>
                  isDone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (tx *Tx) isDone() bool</code></pre>
            </article>
            
            <article class="function" data-name="lasterrOrErrLocked">
               <h3>
                  lasterrOrErrLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lasterrOrErrLocked returns either lasterr or the provided err.
rs.closemu must be read-locked.</p>
               
               <pre><code>func (rs *Rows) lasterrOrErrLocked(err error) error</code></pre>
            </article>
            
            <article class="function" data-name="maxIdleConnsLocked">
               <h3>
                  maxIdleConnsLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (db *DB) maxIdleConnsLocked() int</code></pre>
            </article>
            
            <article class="function" data-name="maybeOpenNewConnections">
               <h3>
                  maybeOpenNewConnections 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Assumes db.mu is locked.
If there are connRequests and the connection limit hasn't been reached,
then tell the connectionOpener to open new connections.</p>
               
               <pre><code>func (db *DB) maybeOpenNewConnections()</code></pre>
            </article>
            
            <article class="function" data-name="namedValueToValue">
               <h3>
                  namedValueToValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func namedValueToValue(named []driver.NamedValue) ([]driver.Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="nextLocked">
               <h3>
                  nextLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (rs *Rows) nextLocked() (doClose bool, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="noteUnusedDriverStatement">
               <h3>
                  noteUnusedDriverStatement 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>noteUnusedDriverStatement notes that ds is no longer used and should
be closed whenever possible (when c is next not in use), unless c is
already closed.</p>
               
               <pre><code>func (db *DB) noteUnusedDriverStatement(c *driverConn, ds *driverStmt)</code></pre>
            </article>
            
            <article class="function" data-name="openNewConnection">
               <h3>
                  openNewConnection 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Open one new connection</p>
               
               <pre><code>func (db *DB) openNewConnection(ctx context.Context)</code></pre>
            </article>
            
            <article class="function" data-name="pingDC">
               <h3>
                  pingDC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (db *DB) pingDC(ctx context.Context, dc *driverConn, release func(error)) error</code></pre>
            </article>
            
            <article class="function" data-name="prepare">
               <h3>
                  prepare 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (db *DB) prepare(ctx context.Context, query string, strategy connReuseStrategy) (*Stmt, error)</code></pre>
            </article>
            
            <article class="function" data-name="prepareDC">
               <h3>
                  prepareDC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>prepareDC prepares a query on the driverConn and calls release before
returning. When cg == nil it implies that a connection pool is used, and
when cg != nil only a single driver connection is used.</p>
               
               <pre><code>func (db *DB) prepareDC(ctx context.Context, dc *driverConn, release func(error), cg stmtConnGrabber, query string) (*Stmt, error)</code></pre>
            </article>
            
            <article class="function" data-name="prepareLocked">
               <h3>
                  prepareLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>prepareLocked prepares the query on dc. When cg == nil the dc must keep track of
the prepared statements in a pool.</p>
               
               <pre><code>func (dc *driverConn) prepareLocked(ctx context.Context, cg stmtConnGrabber, query string) (*driverStmt, error)</code></pre>
            </article>
            
            <article class="function" data-name="prepareOnConnLocked">
               <h3>
                  prepareOnConnLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>prepareOnConnLocked prepares the query in Stmt s on dc and adds it to the list of
open connStmt on the statement. It assumes the caller is holding the lock on dc.</p>
               
               <pre><code>func (s *Stmt) prepareOnConnLocked(ctx context.Context, dc *driverConn) (*driverStmt, error)</code></pre>
            </article>
            
            <article class="function" data-name="putConn">
               <h3>
                  putConn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>putConn adds a connection to the db's free pool.
err is optionally the last error that occurred on this connection.</p>
               
               <pre><code>func (db *DB) putConn(dc *driverConn, err error, resetSession bool)</code></pre>
            </article>
            
            <article class="function" data-name="putConnDBLocked">
               <h3>
                  putConnDBLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Satisfy a connRequest or put the driverConn in the idle pool and return true
or return false.
putConnDBLocked will satisfy a connRequest if there is one, or it will
return the *driverConn to the freeConn list if err == nil and the idle
connection limit will not be exceeded.
If err != nil, the value of dc is ignored.
If err == nil, then dc must not equal nil.
If a connRequest was fulfilled or the *driverConn was placed in the
freeConn list, then true is returned, otherwise false is returned.</p>
               
               <pre><code>func (db *DB) putConnDBLocked(dc *driverConn, err error) bool</code></pre>
            </article>
            
            <article class="function" data-name="query">
               <h3>
                  query 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (db *DB) query(ctx context.Context, query string, args []any, strategy connReuseStrategy) (*Rows, error)</code></pre>
            </article>
            
            <article class="function" data-name="queryDC">
               <h3>
                  queryDC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>queryDC executes a query on the given connection.
The connection gets released by the releaseConn function.
The ctx context is from a query method and the txctx context is from an
optional transaction context.</p>
               
               <pre><code>func (db *DB) queryDC(ctx context.Context, txctx context.Context, dc *driverConn, releaseConn func(error), query string, args []any) (*Rows, error)</code></pre>
            </article>
            
            <article class="function" data-name="rawbuf">
               <h3>
                  rawbuf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>rawbuf returns the buffer to append RawBytes values to.
This buffer is reused across calls to Rows.Scan.
Usage:
rawBytes = rows.setrawbuf(append(rows.rawbuf(), value...))</p>
               
               <pre><code>func (rs *Rows) rawbuf() []byte</code></pre>
            </article>
            
            <article class="function" data-name="releaseConn">
               <h3>
                  releaseConn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dc *driverConn) releaseConn(err error)</code></pre>
            </article>
            
            <article class="function" data-name="removeClosedStmtLocked">
               <h3>
                  removeClosedStmtLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>removeClosedStmtLocked removes closed conns in s.css.
To avoid lock contention on DB.mu, we do it only when
s.db.numClosed - s.lastNum is large enough.</p>
               
               <pre><code>func (s *Stmt) removeClosedStmtLocked()</code></pre>
            </article>
            
            <article class="function" data-name="removeDep">
               <h3>
                  removeDep 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>removeDep notes that x no longer depends on dep.
If x still has dependencies, nil is returned.
If x no longer has any dependencies, its finalClose method will be
called and its error value will be returned.</p>
               
               <pre><code>func (db *DB) removeDep(x finalCloser, dep any) error</code></pre>
            </article>
            
            <article class="function" data-name="removeDepLocked">
               <h3>
                  removeDepLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (db *DB) removeDepLocked(x finalCloser, dep any) (func() error)</code></pre>
            </article>
            
            <article class="function" data-name="removeOpenStmt">
               <h3>
                  removeOpenStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dc *driverConn) removeOpenStmt(ds *driverStmt)</code></pre>
            </article>
            
            <article class="function" data-name="resetSession">
               <h3>
                  resetSession 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>resetSession checks if the driver connection needs the
session to be reset and if required, resets it.</p>
               
               <pre><code>func (dc *driverConn) resetSession(ctx context.Context) error</code></pre>
            </article>
            
            <article class="function" data-name="resultFromStatement">
               <h3>
                  resultFromStatement 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func resultFromStatement(ctx context.Context, ci driver.Conn, ds *driverStmt, args ...any) (Result, error)</code></pre>
            </article>
            
            <article class="function" data-name="retry">
               <h3>
                  retry 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (db *DB) retry(fn func(strategy connReuseStrategy) error) error</code></pre>
            </article>
            
            <article class="function" data-name="rollback">
               <h3>
                  rollback 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>rollback aborts the transaction and optionally forces the pool to discard
the connection.</p>
               
               <pre><code>func (tx *Tx) rollback(discardConn bool) error</code></pre>
            </article>
            
            <article class="function" data-name="rowsColumnInfoSetupConnLocked">
               <h3>
                  rowsColumnInfoSetupConnLocked 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func rowsColumnInfoSetupConnLocked(rowsi driver.Rows) []*ColumnType</code></pre>
            </article>
            
            <article class="function" data-name="rowsiFromStatement">
               <h3>
                  rowsiFromStatement 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func rowsiFromStatement(ctx context.Context, ci driver.Conn, ds *driverStmt, args ...any) (driver.Rows, error)</code></pre>
            </article>
            
            <article class="function" data-name="scanArgsContainRawBytes">
               <h3>
                  scanArgsContainRawBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func scanArgsContainRawBytes(args []any) bool</code></pre>
            </article>
            
            <article class="function" data-name="setrawbuf">
               <h3>
                  setrawbuf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setrawbuf updates the RawBytes buffer with the result of appending a new value to it.
It returns the new value.</p>
               
               <pre><code>func (rs *Rows) setrawbuf(b []byte) RawBytes</code></pre>
            </article>
            
            <article class="function" data-name="shortestIdleTimeLocked">
               <h3>
                  shortestIdleTimeLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (db *DB) shortestIdleTimeLocked() time.Duration</code></pre>
            </article>
            
            <article class="function" data-name="stack">
               <h3>
                  stack 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func stack() string</code></pre>
            </article>
            
            <article class="function" data-name="startCleanerLocked">
               <h3>
                  startCleanerLocked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>startCleanerLocked starts connectionCleaner if needed.</p>
               
               <pre><code>func (db *DB) startCleanerLocked()</code></pre>
            </article>
            
            <article class="function" data-name="strconvErr">
               <h3>
                  strconvErr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func strconvErr(err error) error</code></pre>
            </article>
            
            <article class="function" data-name="txCtx">
               <h3>
                  txCtx 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (tx *Tx) txCtx() context.Context</code></pre>
            </article>
            
            <article class="function" data-name="txCtx">
               <h3>
                  txCtx 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *Conn) txCtx() context.Context</code></pre>
            </article>
            
            <article class="function" data-name="unregisterAllDrivers">
               <h3>
                  unregisterAllDrivers 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func unregisterAllDrivers()</code></pre>
            </article>
            
            <article class="function" data-name="validateConnection">
               <h3>
                  validateConnection 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>validateConnection checks if the connection is valid and can
still be used. It also marks the session for reset if required.</p>
               
               <pre><code>func (dc *driverConn) validateConnection(needsReset bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="validateNamedValueName">
               <h3>
                  validateNamedValueName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func validateNamedValueName(name string) error</code></pre>
            </article>
            
            <article class="function" data-name="withLock">
               <h3>
                  withLock 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>withLock runs while holding lk.</p>
               
               <pre><code>func withLock(lk sync.Locker, fn func())</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
