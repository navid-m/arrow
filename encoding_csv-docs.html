<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>csv - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>csv</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"bufio"
"bytes"
"errors"
"fmt"
"io"
"unicode"
"unicode/utf8"
"bufio"
"io"
"strings"
"unicode"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrBareQuote" data-name="ErrBareQuote">
               <h3>
                  ErrBareQuote 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrBareQuote" class="anchor" title="Link to ErrBareQuote">#</a>
               </h3>
               
                  <p class="doc-comment">These are the errors that can be returned in [ParseError.Err].</p>
               
               <pre><code class="language-go">var ErrBareQuote = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrFieldCount" data-name="ErrFieldCount">
               <h3>
                  ErrFieldCount 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrFieldCount" class="anchor" title="Link to ErrFieldCount">#</a>
               </h3>
               
                  <p class="doc-comment">These are the errors that can be returned in [ParseError.Err].</p>
               
               <pre><code class="language-go">var ErrFieldCount = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrQuote" data-name="ErrQuote">
               <h3>
                  ErrQuote 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrQuote" class="anchor" title="Link to ErrQuote">#</a>
               </h3>
               
                  <p class="doc-comment">These are the errors that can be returned in [ParseError.Err].</p>
               
               <pre><code class="language-go">var ErrQuote = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrTrailingComma" data-name="ErrTrailingComma">
               <h3>
                  ErrTrailingComma 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrTrailingComma" class="anchor" title="Link to ErrTrailingComma">#</a>
               </h3>
               
                  <p class="doc-comment">Deprecated: ErrTrailingComma is no longer used.</p>
               
               <pre><code class="language-go">var ErrTrailingComma = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errInvalidDelim" data-name="errInvalidDelim">
               <h3>
                  errInvalidDelim 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errInvalidDelim" class="anchor" title="Link to errInvalidDelim">#</a>
               </h3>
               
               <pre><code class="language-go">var errInvalidDelim = *ast.CallExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="ParseError" data-name="ParseError">
               <h3>
                  ParseError
                  <span class="badge">struct</span>
                  <a href="#ParseError" class="anchor" title="Link to ParseError">#</a>
               </h3>
               
               <p>A ParseError is returned for parsing errors.
Line and column numbers are 1-indexed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ParseError struct {
StartLine int
Line int
Column int
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Reader" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge">struct</span>
                  <a href="#Reader" class="anchor" title="Link to Reader">#</a>
               </h3>
               
               <p>A Reader reads records from a CSV-encoded file.
As returned by [NewReader], a Reader expects input conforming to RFC 4180.
The exported fields can be changed to customize the details before the
first call to [Reader.Read] or [Reader.ReadAll].
The Reader converts all \r\n sequences in its input to plain \n,
including in multiline field values, so that the returned data does
not depend on which line-ending convention an input file uses.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Reader struct {
Comma rune
Comment rune
FieldsPerRecord int
LazyQuotes bool
TrimLeadingSpace bool
ReuseRecord bool
TrailingComma bool
r *bufio.Reader
numLine int
offset int64
rawBuffer []byte
recordBuffer []byte
fieldIndexes []int
fieldPositions []position
lastRecord []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Writer" data-name="Writer">
               <h3>
                  Writer
                  <span class="badge">struct</span>
                  <a href="#Writer" class="anchor" title="Link to Writer">#</a>
               </h3>
               
               <p>A Writer writes records using CSV encoding.
As returned by [NewWriter], a Writer writes records terminated by a
newline and uses ',' as the field delimiter. The exported fields can be
changed to customize the details before
the first call to [Writer.Write] or [Writer.WriteAll].
[Writer.Comma] is the field delimiter.
If [Writer.UseCRLF] is true,
the Writer ends each output line with \r\n instead of \n.
The writes of individual records are buffered.
After all data has been written, the client should call the
[Writer.Flush] method to guarantee all data has been forwarded to
the underlying [io.Writer].  Any errors that occurred should
be checked by calling the [Writer.Error] method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Writer struct {
Comma rune
UseCRLF bool
w *bufio.Writer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="position" data-name="position">
               <h3>
                  position
                  <span class="badge">struct</span>
                  <a href="#position" class="anchor" title="Link to position">#</a>
               </h3>
               
               <p>pos holds the position of a field in the current line.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type position struct {
line int
col int
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>Error reports any error that has occurred during
a previous [Writer.Write] or [Writer.Flush].</p>
               
               <pre><code class="language-go">func (w *Writer) Error() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ParseError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldPos" data-name="FieldPos">
               <h3>
                  FieldPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldPos" class="anchor" title="Link to FieldPos">#</a>
               </h3>
               
               <p>FieldPos returns the line and column corresponding to
the start of the field with the given index in the slice most recently
returned by [Reader.Read]. Numbering of lines and columns starts at 1;
columns are counted in bytes, not runes.
If this is called with an out-of-bounds index, it panics.</p>
               
               <pre><code class="language-go">func (r *Reader) FieldPos(field int) (line int, column int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flush" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flush" class="anchor" title="Link to Flush">#</a>
               </h3>
               
               <p>Flush writes any buffered data to the underlying [io.Writer].
To check if an error occurred during Flush, call [Writer.Error].</p>
               
               <pre><code class="language-go">func (w *Writer) Flush()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InputOffset" data-name="InputOffset">
               <h3>
                  InputOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InputOffset" class="anchor" title="Link to InputOffset">#</a>
               </h3>
               
               <p>InputOffset returns the input stream byte offset of the current reader
position. The offset gives the location of the end of the most recently
read row and the beginning of the next row.</p>
               
               <pre><code class="language-go">func (r *Reader) InputOffset() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewReader" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
                  <a href="#NewReader" class="anchor" title="Link to NewReader">#</a>
               </h3>
               
               <p>NewReader returns a new Reader that reads from r.</p>
               
               <pre><code class="language-go">func NewReader(r io.Reader) *Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewWriter" data-name="NewWriter">
               <h3>
                  NewWriter 
                  <span class="badge">function</span>
                  
                  <a href="#NewWriter" class="anchor" title="Link to NewWriter">#</a>
               </h3>
               
               <p>NewWriter returns a new Writer that writes to w.</p>
               
               <pre><code class="language-go">func NewWriter(w io.Writer) *Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read reads one record (a slice of fields) from r.
If the record has an unexpected number of fields,
Read returns the record along with the error [ErrFieldCount].
If the record contains a field that cannot be parsed,
Read returns a partial record along with the parse error.
The partial record contains all fields read before the error.
If there is no data left to be read, Read returns nil, [io.EOF].
If [Reader.ReuseRecord] is true, the returned slice may be shared
between multiple calls to Read.</p>
               
               <pre><code class="language-go">func (r *Reader) Read() (record []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadAll" data-name="ReadAll">
               <h3>
                  ReadAll 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadAll" class="anchor" title="Link to ReadAll">#</a>
               </h3>
               
               <p>ReadAll reads all the remaining records from r.
Each record is a slice of fields.
A successful call returns err == nil, not err == [io.EOF]. Because ReadAll is
defined to read until EOF, it does not treat end of file as an error to be
reported.</p>
               
               <pre><code class="language-go">func (r *Reader) ReadAll() (records [][]string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ParseError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes a single CSV record to w along with any necessary quoting.
A record is a slice of strings with each string being one field.
Writes are buffered, so [Writer.Flush] must eventually be called to ensure
that the record is written to the underlying [io.Writer].</p>
               
               <pre><code class="language-go">func (w *Writer) Write(record []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteAll" data-name="WriteAll">
               <h3>
                  WriteAll 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteAll" class="anchor" title="Link to WriteAll">#</a>
               </h3>
               
               <p>WriteAll writes multiple CSV records to w using [Writer.Write] and
then calls [Writer.Flush], returning any error from the Flush.</p>
               
               <pre><code class="language-go">func (w *Writer) WriteAll(records [][]string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fieldNeedsQuotes" data-name="fieldNeedsQuotes">
               <h3>
                  fieldNeedsQuotes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fieldNeedsQuotes" class="anchor" title="Link to fieldNeedsQuotes">#</a>
               </h3>
               
               <p>fieldNeedsQuotes reports whether our field must be enclosed in quotes.
Fields with a Comma, fields with a quote or newline, and
fields which start with a space must be enclosed in quotes.
We used to quote empty strings, but we do not anymore (as of Go 1.4).
The two representations should be equivalent, but Postgres distinguishes
quoted vs non-quoted empty string during database imports, and it has
an option to force the quoted behavior for non-quoted CSV but it has
no option to force the non-quoted behavior for quoted CSV, making
CSV with quoted empty strings strictly less useful.
Not quoting the empty string also makes this package match the behavior
of Microsoft Excel and Google Drive.
For Postgres, quote the data terminating string `\.`.</p>
               
               <pre><code class="language-go">func (w *Writer) fieldNeedsQuotes(field string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lengthNL" data-name="lengthNL">
               <h3>
                  lengthNL 
                  <span class="badge">function</span>
                  
                  <a href="#lengthNL" class="anchor" title="Link to lengthNL">#</a>
               </h3>
               
               <p>lengthNL reports the number of bytes for the trailing \n.</p>
               
               <pre><code class="language-go">func lengthNL(b []byte) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextRune" data-name="nextRune">
               <h3>
                  nextRune 
                  <span class="badge">function</span>
                  
                  <a href="#nextRune" class="anchor" title="Link to nextRune">#</a>
               </h3>
               
               <p>nextRune returns the next rune in b or utf8.RuneError.</p>
               
               <pre><code class="language-go">func nextRune(b []byte) rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readLine" data-name="readLine">
               <h3>
                  readLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readLine" class="anchor" title="Link to readLine">#</a>
               </h3>
               
               <p>readLine reads the next line (with the trailing endline).
If EOF is hit without a trailing endline, it will be omitted.
If some bytes were read, then the error is never [io.EOF].
The result is only valid until the next call to readLine.</p>
               
               <pre><code class="language-go">func (r *Reader) readLine() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readRecord" data-name="readRecord">
               <h3>
                  readRecord 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readRecord" class="anchor" title="Link to readRecord">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *Reader) readRecord(dst []string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validDelim" data-name="validDelim">
               <h3>
                  validDelim 
                  <span class="badge">function</span>
                  
                  <a href="#validDelim" class="anchor" title="Link to validDelim">#</a>
               </h3>
               
               <pre><code class="language-go">func validDelim(r rune) bool</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>