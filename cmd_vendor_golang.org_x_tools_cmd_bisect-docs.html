<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - main</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>main</code>
         </h1>
         <hr />
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>Preserve import of bisect, to allow [bisect.Match] in the doc comment.</p>
            
            <pre><code>_ bisect.Matcher</code></pre>
         </article>
         
         <article class="global" data-name="searchFatal">
            <h2>searchFatal</h2>
            <hr />
            
            <p>&searchFatal is a special panic value to signal that Search failed.
This lets us unwind the search recursion on a fatal error
but have Search return normally.</p>
            
            <pre><code>searchFatal int</code></pre>
         </article>
          
         <article class="struct" data-name="Bisect">
            <h2>type Bisect struct</h2>
            <hr />
            
            <p>A Bisect holds the state for a bisect invocation.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Env []string
Cmd string
Args []string
Max int
MaxSet int
Timeout time.Duration
Count int
Verbose bool
Stdout io.Writer
Stderr io.Writer
TestRun func
Disable bool
SkipHexDigits int
Add []string
Skip []string</code></pre>
         </article>
         
         <article class="struct" data-name="Result">
            <h2>type Result struct</h2>
            <hr />
            
            <p>A Result holds the result of a single target trial.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Success bool
Cmd string
Out string
Suffix string
MatchIDs []uint64
MatchText []string
MatchFull []string</code></pre>
         </article>
          
         <article class="function" data-name="usage">
            <h2>usage</h2>
            <hr />
            
            <pre><code>func usage()</code></pre>
         </article>
         
         <article class="function" data-name="main">
            <h2>main</h2>
            <hr />
            
            <pre><code>func main()</code></pre>
         </article>
         
         <article class="function" data-name="Search">
            <h2>Search</h2>
            <hr />
            
            <p>Search runs a bisect search according to the configuration in b.
It reports whether any failing change sets were found.</p>
            
            <pre><code>func Search() bool</code></pre>
         </article>
         
         <article class="function" data-name="Fatalf">
            <h2>Fatalf</h2>
            <hr />
            
            <p>Fatalf prints a message to standard error and then panics,
causing Search to return false.</p>
            
            <pre><code>func Fatalf(format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Logf">
            <h2>Logf</h2>
            <hr />
            
            <p>Logf prints a message to standard error.</p>
            
            <pre><code>func Logf(format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="skipHexDigits">
            <h2>skipHexDigits</h2>
            <hr />
            
            <pre><code>func skipHexDigits(idY []uint64, idN []uint64) int</code></pre>
         </article>
         
         <article class="function" data-name="search">
            <h2>search</h2>
            <hr />
            
            <p>search searches for a single locally minimal change set.

Invariant: r describes the result of r.Suffix + b.Add, which failed.
(There's an implicit -b.Skip everywhere here. b.Skip does not change.)
We want to extend r.Suffix to preserve the failure, working toward
a suffix that identifies a single change.</p>
            
            <pre><code>func search(r *Result) []string</code></pre>
         </article>
         
         <article class="function" data-name="Run">
            <h2>Run</h2>
            <hr />
            
            <p>Run runs a set of trials selecting changes with the given suffix,
plus the ones in b.Add and not the ones in b.Skip.
The returned result's MatchIDs, MatchText, and MatchFull
only list the changes that match suffix.
When b.Count > 1, Run runs b.Count trials and requires
that they all succeed or they all fail. If not, it calls b.Fatalf.</p>
            
            <pre><code>func Run(suffix string) *Result</code></pre>
         </article>
         
         <article class="function" data-name="run">
            <h2>run</h2>
            <hr />
            
            <p>run runs a single trial for Run.</p>
            
            <pre><code>func run(suffix string) *Result</code></pre>
         </article>
         
         <article class="function" data-name="replace">
            <h2>replace</h2>
            <hr />
            
            <p>replace returns x with literal text PATTERN and RANDOM replaced by pattern and random.</p>
            
            <pre><code>func replace(x string, pattern string, random string) string</code></pre>
         </article>
         
         <article class="function" data-name="commonSuffix">
            <h2>commonSuffix</h2>
            <hr />
            
            <p>commonSuffix returns the longest common binary suffix shared by all uint64s in list.
If list is empty, commonSuffix returns an empty string.</p>
            
            <pre><code>func commonSuffix(list []uint64) string</code></pre>
         </article>
         
         <article class="function" data-name="cmdInterrupt">
            <h2>cmdInterrupt</h2>
            <hr />
            
            <pre><code>func cmdInterrupt(cmd *exec.Cmd)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
