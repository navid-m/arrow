<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>rsa - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>rsa</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"crypto/internal/boring"
"crypto/internal/fips140/rsa"
"crypto/internal/fips140only"
"crypto/internal/randutil"
"crypto/subtle"
"errors"
"io"
"crypto"
"crypto/internal/boring"
"crypto/internal/boring/bbig"
"crypto/internal/fips140/bigmod"
"crypto/internal/fips140/rsa"
"crypto/internal/fips140only"
"crypto/internal/randutil"
"crypto/rand"
"crypto/subtle"
"errors"
"fmt"
"internal/godebug"
"io"
"math"
"math/big"
"crypto/internal/boring"
"crypto/internal/boring/bbig"
"crypto/internal/boring/bcache"
"math/big"
"crypto"
"crypto/internal/boring"
"crypto/internal/fips140/rsa"
"crypto/internal/fips140hash"
"crypto/internal/fips140only"
"errors"
"hash"
"io"
"crypto/internal/boring"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrDecryption" data-name="ErrDecryption">
               <h3>
                  ErrDecryption 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrDecryption" class="anchor" title="Link to ErrDecryption">#</a>
               </h3>
               
                  <p class="doc-comment">ErrDecryption represents a failure to decrypt a message.
It is deliberately vague to avoid adaptive attacks.</p>
               
               <pre><code class="language-go">var ErrDecryption = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrMessageTooLong" data-name="ErrMessageTooLong">
               <h3>
                  ErrMessageTooLong 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrMessageTooLong" class="anchor" title="Link to ErrMessageTooLong">#</a>
               </h3>
               
                  <p class="doc-comment">ErrMessageTooLong is returned when attempting to encrypt or sign a message
which is too large for the size of the key. When using [SignPSS], this can also
be returned if the size of the salt is too large.</p>
               
               <pre><code class="language-go">var ErrMessageTooLong = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrVerification" data-name="ErrVerification">
               <h3>
                  ErrVerification 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrVerification" class="anchor" title="Link to ErrVerification">#</a>
               </h3>
               
                  <p class="doc-comment">ErrVerification represents a failure to verify a signature.
It is deliberately vague to avoid adaptive attacks.</p>
               
               <pre><code class="language-go">var ErrVerification = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PSSSaltLengthAuto" data-name="PSSSaltLengthAuto">
               <h3>
                  PSSSaltLengthAuto 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PSSSaltLengthAuto" class="anchor" title="Link to PSSSaltLengthAuto">#</a>
               </h3>
               
                  <p class="doc-comment">PSSSaltLengthAuto causes the salt in a PSS signature to be as large
as possible when signing, and to be auto-detected when verifying.
When signing in FIPS 140-3 mode, the salt length is capped at the length
of the hash function used in the signature.</p>
               
               <pre><code class="language-go">const PSSSaltLengthAuto = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PSSSaltLengthEqualsHash" data-name="PSSSaltLengthEqualsHash">
               <h3>
                  PSSSaltLengthEqualsHash 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PSSSaltLengthEqualsHash" class="anchor" title="Link to PSSSaltLengthEqualsHash">#</a>
               </h3>
               
                  <p class="doc-comment">PSSSaltLengthEqualsHash causes the salt length to equal the length
of the hash used in the signature.</p>
               
               <pre><code class="language-go">const PSSSaltLengthEqualsHash = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bigOne" data-name="bigOne">
               <h3>
                  bigOne 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bigOne" class="anchor" title="Link to bigOne">#</a>
               </h3>
               
               <pre><code class="language-go">var bigOne = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="privCache" data-name="privCache">
               <h3>
                  privCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#privCache" class="anchor" title="Link to privCache">#</a>
               </h3>
               
               <pre><code class="language-go">var privCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pubCache" data-name="pubCache">
               <h3>
                  pubCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#pubCache" class="anchor" title="Link to pubCache">#</a>
               </h3>
               
               <pre><code class="language-go">var pubCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="rsa1024min" data-name="rsa1024min">
               <h3>
                  rsa1024min 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#rsa1024min" class="anchor" title="Link to rsa1024min">#</a>
               </h3>
               
                  <p class="doc-comment">rsa1024min is a GODEBUG that re-enables weak RSA keys if set to "0".
See https://go.dev/issue/68762.</p>
               
               <pre><code class="language-go">var rsa1024min = *ast.CallExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="CRTValue" data-name="CRTValue">
               <h3>
                  CRTValue
                  <span class="badge">struct</span>
                  <a href="#CRTValue" class="anchor" title="Link to CRTValue">#</a>
               </h3>
               
               <p>CRTValue contains the precomputed Chinese remainder theorem values.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type CRTValue struct {
Exp *big.Int
Coeff *big.Int
R *big.Int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="OAEPOptions" data-name="OAEPOptions">
               <h3>
                  OAEPOptions
                  <span class="badge">struct</span>
                  <a href="#OAEPOptions" class="anchor" title="Link to OAEPOptions">#</a>
               </h3>
               
               <p>OAEPOptions is an interface for passing options to OAEP decryption using the
crypto.Decrypter interface.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type OAEPOptions struct {
Hash crypto.Hash
MGFHash crypto.Hash
Label []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PKCS1v15DecryptOptions" data-name="PKCS1v15DecryptOptions">
               <h3>
                  PKCS1v15DecryptOptions
                  <span class="badge">struct</span>
                  <a href="#PKCS1v15DecryptOptions" class="anchor" title="Link to PKCS1v15DecryptOptions">#</a>
               </h3>
               
               <p>PKCS1v15DecryptOptions is for passing options to PKCS #1 v1.5 decryption using
the [crypto.Decrypter] interface.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PKCS1v15DecryptOptions struct {
SessionKeyLen int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PSSOptions" data-name="PSSOptions">
               <h3>
                  PSSOptions
                  <span class="badge">struct</span>
                  <a href="#PSSOptions" class="anchor" title="Link to PSSOptions">#</a>
               </h3>
               
               <p>PSSOptions contains options for creating and verifying PSS signatures.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PSSOptions struct {
SaltLength int
Hash crypto.Hash
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PrecomputedValues" data-name="PrecomputedValues">
               <h3>
                  PrecomputedValues
                  <span class="badge">struct</span>
                  <a href="#PrecomputedValues" class="anchor" title="Link to PrecomputedValues">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PrecomputedValues struct {
Dp *big.Int
Dq *big.Int
Qinv *big.Int
CRTValues []CRTValue
fips *rsa.PrivateKey
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PrivateKey" data-name="PrivateKey">
               <h3>
                  PrivateKey
                  <span class="badge">struct</span>
                  <a href="#PrivateKey" class="anchor" title="Link to PrivateKey">#</a>
               </h3>
               
               <p>A PrivateKey represents an RSA key</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PrivateKey struct {
PublicKey
D *big.Int
Primes []*big.Int
Precomputed PrecomputedValues
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PublicKey" data-name="PublicKey">
               <h3>
                  PublicKey
                  <span class="badge">struct</span>
                  <a href="#PublicKey" class="anchor" title="Link to PublicKey">#</a>
               </h3>
               
               <p>A PublicKey represents the public part of an RSA key.
The value of the modulus N is considered secret by this library and protected
from leaking through timing side-channels. However, neither the value of the
exponent E nor the precise bit size of N are similarly protected.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PublicKey struct {
N *big.Int
E int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="boringPriv" data-name="boringPriv">
               <h3>
                  boringPriv
                  <span class="badge">struct</span>
                  <a href="#boringPriv" class="anchor" title="Link to boringPriv">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type boringPriv struct {
key *boring.PrivateKeyRSA
orig PrivateKey
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="boringPub" data-name="boringPub">
               <h3>
                  boringPub
                  <span class="badge">struct</span>
                  <a href="#boringPub" class="anchor" title="Link to boringPub">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type boringPub struct {
key *boring.PublicKeyRSA
orig PublicKey
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Decrypt" data-name="Decrypt">
               <h3>
                  Decrypt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Decrypt" class="anchor" title="Link to Decrypt">#</a>
               </h3>
               
               <p>Decrypt decrypts ciphertext with priv. If opts is nil or of type
*[PKCS1v15DecryptOptions] then PKCS #1 v1.5 decryption is performed. Otherwise
opts must have type *[OAEPOptions] and OAEP decryption is done.</p>
               
               <pre><code class="language-go">func (priv *PrivateKey) Decrypt(rand io.Reader, ciphertext []byte, opts crypto.DecrypterOpts) (plaintext []byte, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DecryptOAEP" data-name="DecryptOAEP">
               <h3>
                  DecryptOAEP 
                  <span class="badge">function</span>
                  
                  <a href="#DecryptOAEP" class="anchor" title="Link to DecryptOAEP">#</a>
               </h3>
               
               <p>DecryptOAEP decrypts ciphertext using RSA-OAEP.
OAEP is parameterised by a hash function that is used as a random oracle.
Encryption and decryption of a given message must use the same hash function
and sha256.New() is a reasonable choice.
The random parameter is legacy and ignored, and it can be nil.
The label parameter must match the value given when encrypting. See
[EncryptOAEP] for details.</p>
               
               <pre><code class="language-go">func DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DecryptPKCS1v15" data-name="DecryptPKCS1v15">
               <h3>
                  DecryptPKCS1v15 
                  <span class="badge">function</span>
                  
                  <a href="#DecryptPKCS1v15" class="anchor" title="Link to DecryptPKCS1v15">#</a>
               </h3>
               
               <p>DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS #1 v1.5.
The random parameter is legacy and ignored, and it can be nil.
Note that whether this function returns an error or not discloses secret
information. If an attacker can cause this function to run repeatedly and
learn whether each instance returned an error then they can decrypt and
forge signatures as if they had the private key. See
DecryptPKCS1v15SessionKey for a way of solving this problem.</p>
               
               <pre><code class="language-go">func DecryptPKCS1v15(random io.Reader, priv *PrivateKey, ciphertext []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DecryptPKCS1v15SessionKey" data-name="DecryptPKCS1v15SessionKey">
               <h3>
                  DecryptPKCS1v15SessionKey 
                  <span class="badge">function</span>
                  
                  <a href="#DecryptPKCS1v15SessionKey" class="anchor" title="Link to DecryptPKCS1v15SessionKey">#</a>
               </h3>
               
               <p>DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding
scheme from PKCS #1 v1.5. The random parameter is legacy and ignored, and it
can be nil.
DecryptPKCS1v15SessionKey returns an error if the ciphertext is the wrong
length or if the ciphertext is greater than the public modulus. Otherwise, no
error is returned. If the padding is valid, the resulting plaintext message
is copied into key. Otherwise, key is unchanged. These alternatives occur in
constant time. It is intended that the user of this function generate a
random session key beforehand and continue the protocol with the resulting
value.
Note that if the session key is too small then it may be possible for an
attacker to brute-force it. If they can do that then they can learn whether a
random value was used (because it'll be different for the same ciphertext)
and thus whether the padding was correct. This also defeats the point of this
function. Using at least a 16-byte key will protect against this attack.
This method implements protections against Bleichenbacher chosen ciphertext
attacks [0] described in RFC 3218 Section 2.3.2 [1]. While these protections
make a Bleichenbacher attack significantly more difficult, the protections
are only effective if the rest of the protocol which uses
DecryptPKCS1v15SessionKey is designed with these considerations in mind. In
particular, if any subsequent operations which use the decrypted session key
leak any information about the key (e.g. whether it is a static or random
key) then the mitigations are defeated. This method must be used extremely
carefully, and typically should only be used when absolutely necessary for
compatibility with an existing protocol (such as TLS) that is designed with
these properties in mind.
- [0] “Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption
Standard PKCS #1”, Daniel Bleichenbacher, Advances in Cryptology (Crypto '98)
- [1] RFC 3218, Preventing the Million Message Attack on CMS,
https://www.rfc-editor.org/rfc/rfc3218.html</p>
               
               <pre><code class="language-go">func DecryptPKCS1v15SessionKey(random io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EncryptOAEP" data-name="EncryptOAEP">
               <h3>
                  EncryptOAEP 
                  <span class="badge">function</span>
                  
                  <a href="#EncryptOAEP" class="anchor" title="Link to EncryptOAEP">#</a>
               </h3>
               
               <p>EncryptOAEP encrypts the given message with RSA-OAEP.
OAEP is parameterised by a hash function that is used as a random oracle.
Encryption and decryption of a given message must use the same hash function
and sha256.New() is a reasonable choice.
The random parameter is used as a source of entropy to ensure that
encrypting the same message twice doesn't result in the same ciphertext.
Most applications should use [crypto/rand.Reader] as random.
The label parameter may contain arbitrary data that will not be encrypted,
but which gives important context to the message. For example, if a given
public key is used to encrypt two types of messages then distinct label
values could be used to ensure that a ciphertext for one purpose cannot be
used for another by an attacker. If not required it can be empty.
The message must be no longer than the length of the public modulus minus
twice the hash length, minus a further 2.</p>
               
               <pre><code class="language-go">func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EncryptPKCS1v15" data-name="EncryptPKCS1v15">
               <h3>
                  EncryptPKCS1v15 
                  <span class="badge">function</span>
                  
                  <a href="#EncryptPKCS1v15" class="anchor" title="Link to EncryptPKCS1v15">#</a>
               </h3>
               
               <p>EncryptPKCS1v15 encrypts the given message with RSA and the padding
scheme from PKCS #1 v1.5.  The message must be no longer than the
length of the public modulus minus 11 bytes.
The random parameter is used as a source of entropy to ensure that
encrypting the same message twice doesn't result in the same
ciphertext. Most applications should use [crypto/rand.Reader]
as random. Note that the returned ciphertext does not depend
deterministically on the bytes read from random, and may change
between calls and/or between versions.
WARNING: use of this function to encrypt plaintexts other than
session keys is dangerous. Use RSA OAEP in new protocols.</p>
               
               <pre><code class="language-go">func EncryptPKCS1v15(random io.Reader, pub *PublicKey, msg []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Equal" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Equal" class="anchor" title="Link to Equal">#</a>
               </h3>
               
               <p>Equal reports whether pub and x have the same value.</p>
               
               <pre><code class="language-go">func (pub *PublicKey) Equal(x crypto.PublicKey) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Equal" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Equal" class="anchor" title="Link to Equal">#</a>
               </h3>
               
               <p>Equal reports whether priv and x have equivalent values. It ignores
Precomputed values.</p>
               
               <pre><code class="language-go">func (priv *PrivateKey) Equal(x crypto.PrivateKey) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GenerateKey" data-name="GenerateKey">
               <h3>
                  GenerateKey 
                  <span class="badge">function</span>
                  
                  <a href="#GenerateKey" class="anchor" title="Link to GenerateKey">#</a>
               </h3>
               
               <p>GenerateKey generates a random RSA private key of the given bit size.
If bits is less than 1024, [GenerateKey] returns an error. See the "[Minimum
key size]" section for further details.
Most applications should use [crypto/rand.Reader] as rand. Note that the
returned key does not depend deterministically on the bytes read from rand,
and may change between calls and/or between versions.
[Minimum key size]: #hdr-Minimum_key_size</p>
               
               <pre><code class="language-go">func GenerateKey(random io.Reader, bits int) (*PrivateKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GenerateMultiPrimeKey" data-name="GenerateMultiPrimeKey">
               <h3>
                  GenerateMultiPrimeKey 
                  <span class="badge">function</span>
                  
                  <a href="#GenerateMultiPrimeKey" class="anchor" title="Link to GenerateMultiPrimeKey">#</a>
               </h3>
               
               <p>GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit
size and the given random source.
Table 1 in "[On the Security of Multi-prime RSA]" suggests maximum numbers of
primes for a given bit size.
Although the public keys are compatible (actually, indistinguishable) from
the 2-prime case, the private keys are not. Thus it may not be possible to
export multi-prime private keys in certain formats or to subsequently import
them into other code.
This package does not implement CRT optimizations for multi-prime RSA, so the
keys with more than two primes will have worse performance.
Deprecated: The use of this function with a number of primes different from
two is not recommended for the above security, compatibility, and performance
reasons. Use [GenerateKey] instead.
[On the Security of Multi-prime RSA]: http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf</p>
               
               <pre><code class="language-go">func GenerateMultiPrimeKey(random io.Reader, nprimes int, bits int) (*PrivateKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HashFunc" data-name="HashFunc">
               <h3>
                  HashFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HashFunc" class="anchor" title="Link to HashFunc">#</a>
               </h3>
               
               <p>HashFunc returns opts.Hash so that [PSSOptions] implements [crypto.SignerOpts].</p>
               
               <pre><code class="language-go">func (opts *PSSOptions) HashFunc() crypto.Hash</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Precompute" data-name="Precompute">
               <h3>
                  Precompute 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Precompute" class="anchor" title="Link to Precompute">#</a>
               </h3>
               
               <p>Precompute performs some calculations that speed up private key operations
in the future. It is safe to run on non-validated private keys.</p>
               
               <pre><code class="language-go">func (priv *PrivateKey) Precompute()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Public" data-name="Public">
               <h3>
                  Public 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Public" class="anchor" title="Link to Public">#</a>
               </h3>
               
               <p>Public returns the public key corresponding to priv.</p>
               
               <pre><code class="language-go">func (priv *PrivateKey) Public() crypto.PublicKey</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sign" data-name="Sign">
               <h3>
                  Sign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sign" class="anchor" title="Link to Sign">#</a>
               </h3>
               
               <p>Sign signs digest with priv, reading randomness from rand. If opts is a
*[PSSOptions] then the PSS algorithm will be used, otherwise PKCS #1 v1.5 will
be used. digest must be the result of hashing the input message using
opts.HashFunc().
This method implements [crypto.Signer], which is an interface to support keys
where the private part is kept in, for example, a hardware module. Common
uses should use the Sign* functions in this package directly.</p>
               
               <pre><code class="language-go">func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SignPKCS1v15" data-name="SignPKCS1v15">
               <h3>
                  SignPKCS1v15 
                  <span class="badge">function</span>
                  
                  <a href="#SignPKCS1v15" class="anchor" title="Link to SignPKCS1v15">#</a>
               </h3>
               
               <p>SignPKCS1v15 calculates the signature of hashed using
RSASSA-PKCS1-V1_5-SIGN from RSA PKCS #1 v1.5.  Note that hashed must
be the result of hashing the input message using the given hash
function. If hash is zero, hashed is signed directly. This isn't
advisable except for interoperability.
The random parameter is legacy and ignored, and it can be nil.
This function is deterministic. Thus, if the set of possible
messages is small, an attacker may be able to build a map from
messages to signatures and identify the signed messages. As ever,
signatures provide authenticity, not confidentiality.</p>
               
               <pre><code class="language-go">func SignPKCS1v15(random io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SignPSS" data-name="SignPSS">
               <h3>
                  SignPSS 
                  <span class="badge">function</span>
                  
                  <a href="#SignPSS" class="anchor" title="Link to SignPSS">#</a>
               </h3>
               
               <p>SignPSS calculates the signature of digest using PSS.
digest must be the result of hashing the input message using the given hash
function. The opts argument may be nil, in which case sensible defaults are
used. If opts.Hash is set, it overrides hash.
The signature is randomized depending on the message, key, and salt size,
using bytes from rand. Most applications should use [crypto/rand.Reader] as
rand.</p>
               
               <pre><code class="language-go">func SignPSS(rand io.Reader, priv *PrivateKey, hash crypto.Hash, digest []byte, opts *PSSOptions) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <p>Size returns the modulus size in bytes. Raw signatures and ciphertexts
for or by this public key will have the same size.</p>
               
               <pre><code class="language-go">func (pub *PublicKey) Size() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Validate" data-name="Validate">
               <h3>
                  Validate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Validate" class="anchor" title="Link to Validate">#</a>
               </h3>
               
               <p>Validate performs basic sanity checks on the key.
It returns nil if the key is valid, or else an error describing a problem.
It runs faster on valid keys if run after [Precompute].</p>
               
               <pre><code class="language-go">func (priv *PrivateKey) Validate() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="VerifyPKCS1v15" data-name="VerifyPKCS1v15">
               <h3>
                  VerifyPKCS1v15 
                  <span class="badge">function</span>
                  
                  <a href="#VerifyPKCS1v15" class="anchor" title="Link to VerifyPKCS1v15">#</a>
               </h3>
               
               <p>VerifyPKCS1v15 verifies an RSA PKCS #1 v1.5 signature.
hashed is the result of hashing the input message using the given hash
function and sig is the signature. A valid signature is indicated by
returning a nil error. If hash is zero then hashed is used directly. This
isn't advisable except for interoperability.
The inputs are not considered confidential, and may leak through timing side
channels, or if an attacker has control of part of the inputs.</p>
               
               <pre><code class="language-go">func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="VerifyPSS" data-name="VerifyPSS">
               <h3>
                  VerifyPSS 
                  <span class="badge">function</span>
                  
                  <a href="#VerifyPSS" class="anchor" title="Link to VerifyPSS">#</a>
               </h3>
               
               <p>VerifyPSS verifies a PSS signature.
A valid signature is indicated by returning a nil error. digest must be the
result of hashing the input message using the given hash function. The opts
argument may be nil, in which case sensible defaults are used. opts.Hash is
ignored.
The inputs are not considered confidential, and may leak through timing side
channels, or if an attacker has control of part of the inputs.</p>
               
               <pre><code class="language-go">func VerifyPSS(pub *PublicKey, hash crypto.Hash, digest []byte, sig []byte, opts *PSSOptions) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bigIntEqual" data-name="bigIntEqual">
               <h3>
                  bigIntEqual 
                  <span class="badge">function</span>
                  
                  <a href="#bigIntEqual" class="anchor" title="Link to bigIntEqual">#</a>
               </h3>
               
               <p>bigIntEqual reports whether a and b are equal leaking only their bit length
through timing side-channels.</p>
               
               <pre><code class="language-go">func bigIntEqual(a *big.Int, b *big.Int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boringPrivateKey" data-name="boringPrivateKey">
               <h3>
                  boringPrivateKey 
                  <span class="badge">function</span>
                  
                  <a href="#boringPrivateKey" class="anchor" title="Link to boringPrivateKey">#</a>
               </h3>
               
               <pre><code class="language-go">func boringPrivateKey(*PrivateKey) (*boring.PrivateKeyRSA, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boringPrivateKey" data-name="boringPrivateKey">
               <h3>
                  boringPrivateKey 
                  <span class="badge">function</span>
                  
                  <a href="#boringPrivateKey" class="anchor" title="Link to boringPrivateKey">#</a>
               </h3>
               
               <pre><code class="language-go">func boringPrivateKey(priv *PrivateKey) (*boring.PrivateKeyRSA, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boringPublicKey" data-name="boringPublicKey">
               <h3>
                  boringPublicKey 
                  <span class="badge">function</span>
                  
                  <a href="#boringPublicKey" class="anchor" title="Link to boringPublicKey">#</a>
               </h3>
               
               <pre><code class="language-go">func boringPublicKey(pub *PublicKey) (*boring.PublicKeyRSA, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boringPublicKey" data-name="boringPublicKey">
               <h3>
                  boringPublicKey 
                  <span class="badge">function</span>
                  
                  <a href="#boringPublicKey" class="anchor" title="Link to boringPublicKey">#</a>
               </h3>
               
               <pre><code class="language-go">func boringPublicKey(*PublicKey) (*boring.PublicKeyRSA, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFIPS140OnlyPrivateKey" data-name="checkFIPS140OnlyPrivateKey">
               <h3>
                  checkFIPS140OnlyPrivateKey 
                  <span class="badge">function</span>
                  
                  <a href="#checkFIPS140OnlyPrivateKey" class="anchor" title="Link to checkFIPS140OnlyPrivateKey">#</a>
               </h3>
               
               <pre><code class="language-go">func checkFIPS140OnlyPrivateKey(priv *PrivateKey) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFIPS140OnlyPublicKey" data-name="checkFIPS140OnlyPublicKey">
               <h3>
                  checkFIPS140OnlyPublicKey 
                  <span class="badge">function</span>
                  
                  <a href="#checkFIPS140OnlyPublicKey" class="anchor" title="Link to checkFIPS140OnlyPublicKey">#</a>
               </h3>
               
               <pre><code class="language-go">func checkFIPS140OnlyPublicKey(pub *PublicKey) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkKeySize" data-name="checkKeySize">
               <h3>
                  checkKeySize 
                  <span class="badge">function</span>
                  
                  <a href="#checkKeySize" class="anchor" title="Link to checkKeySize">#</a>
               </h3>
               
               <pre><code class="language-go">func checkKeySize(size int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPublicKeySize" data-name="checkPublicKeySize">
               <h3>
                  checkPublicKeySize 
                  <span class="badge">function</span>
                  
                  <a href="#checkPublicKeySize" class="anchor" title="Link to checkPublicKeySize">#</a>
               </h3>
               
               <pre><code class="language-go">func checkPublicKeySize(k *PublicKey) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyPrivateKey" data-name="copyPrivateKey">
               <h3>
                  copyPrivateKey 
                  <span class="badge">function</span>
                  
                  <a href="#copyPrivateKey" class="anchor" title="Link to copyPrivateKey">#</a>
               </h3>
               
               <pre><code class="language-go">func copyPrivateKey(k *PrivateKey) PrivateKey</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyPublicKey" data-name="copyPublicKey">
               <h3>
                  copyPublicKey 
                  <span class="badge">function</span>
                  
                  <a href="#copyPublicKey" class="anchor" title="Link to copyPublicKey">#</a>
               </h3>
               
               <pre><code class="language-go">func copyPublicKey(k *PublicKey) PublicKey</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decryptOAEP" data-name="decryptOAEP">
               <h3>
                  decryptOAEP 
                  <span class="badge">function</span>
                  
                  <a href="#decryptOAEP" class="anchor" title="Link to decryptOAEP">#</a>
               </h3>
               
               <pre><code class="language-go">func decryptOAEP(hash hash.Hash, mgfHash hash.Hash, priv *PrivateKey, ciphertext []byte, label []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decryptPKCS1v15" data-name="decryptPKCS1v15">
               <h3>
                  decryptPKCS1v15 
                  <span class="badge">function</span>
                  
                  <a href="#decryptPKCS1v15" class="anchor" title="Link to decryptPKCS1v15">#</a>
               </h3>
               
               <p>decryptPKCS1v15 decrypts ciphertext using priv. It returns one or zero in
valid that indicates whether the plaintext was correctly structured.
In either case, the plaintext is returned in em so that it may be read
independently of whether it was valid in order to maintain constant memory
access patterns. If the plaintext was valid then index contains the index of
the original message in em, to allow constant time padding removal.</p>
               
               <pre><code class="language-go">func decryptPKCS1v15(priv *PrivateKey, ciphertext []byte) (valid int, em []byte, index int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fipsError" data-name="fipsError">
               <h3>
                  fipsError 
                  <span class="badge">function</span>
                  
                  <a href="#fipsError" class="anchor" title="Link to fipsError">#</a>
               </h3>
               
               <pre><code class="language-go">func fipsError(err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fipsError2" data-name="fipsError2">
               <h3>
                  fipsError2 
                  <span class="badge">function</span>
                  
                  <a href="#fipsError2" class="anchor" title="Link to fipsError2">#</a>
               </h3>
               
               <pre><code class="language-go">func fipsError2(x T, err error) (T, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fipsPrivateKey" data-name="fipsPrivateKey">
               <h3>
                  fipsPrivateKey 
                  <span class="badge">function</span>
                  
                  <a href="#fipsPrivateKey" class="anchor" title="Link to fipsPrivateKey">#</a>
               </h3>
               
               <pre><code class="language-go">func fipsPrivateKey(priv *PrivateKey) (*rsa.PrivateKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fipsPublicKey" data-name="fipsPublicKey">
               <h3>
                  fipsPublicKey 
                  <span class="badge">function</span>
                  
                  <a href="#fipsPublicKey" class="anchor" title="Link to fipsPublicKey">#</a>
               </h3>
               
               <pre><code class="language-go">func fipsPublicKey(pub *PublicKey) (*rsa.PublicKey, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nonZeroRandomBytes" data-name="nonZeroRandomBytes">
               <h3>
                  nonZeroRandomBytes 
                  <span class="badge">function</span>
                  
                  <a href="#nonZeroRandomBytes" class="anchor" title="Link to nonZeroRandomBytes">#</a>
               </h3>
               
               <p>nonZeroRandomBytes fills the given slice with non-zero random octets.</p>
               
               <pre><code class="language-go">func nonZeroRandomBytes(s []byte, random io.Reader) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="precompute" data-name="precompute">
               <h3>
                  precompute 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#precompute" class="anchor" title="Link to precompute">#</a>
               </h3>
               
               <pre><code class="language-go">func (priv *PrivateKey) precompute() (PrecomputedValues, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="precomputeLegacy" data-name="precomputeLegacy">
               <h3>
                  precomputeLegacy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#precomputeLegacy" class="anchor" title="Link to precomputeLegacy">#</a>
               </h3>
               
               <pre><code class="language-go">func (priv *PrivateKey) precomputeLegacy() (PrecomputedValues, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="privateKeyEqual" data-name="privateKeyEqual">
               <h3>
                  privateKeyEqual 
                  <span class="badge">function</span>
                  
                  <a href="#privateKeyEqual" class="anchor" title="Link to privateKeyEqual">#</a>
               </h3>
               
               <pre><code class="language-go">func privateKeyEqual(k1 *PrivateKey, k2 *PrivateKey) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="publicKeyEqual" data-name="publicKeyEqual">
               <h3>
                  publicKeyEqual 
                  <span class="badge">function</span>
                  
                  <a href="#publicKeyEqual" class="anchor" title="Link to publicKeyEqual">#</a>
               </h3>
               
               <pre><code class="language-go">func publicKeyEqual(k1 *PublicKey, k2 *PublicKey) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="saltLength" data-name="saltLength">
               <h3>
                  saltLength 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#saltLength" class="anchor" title="Link to saltLength">#</a>
               </h3>
               
               <pre><code class="language-go">func (opts *PSSOptions) saltLength() int</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>