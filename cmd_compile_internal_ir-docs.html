<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - ir</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>ir</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"cmd/compile/internal/base"
"cmd/internal/obj"
"fmt"
"io"
"os"
"reflect"
"regexp"
"cmd/compile/internal/base"
"cmd/compile/internal/types"
"cmd/internal/src"
"bytes"
"cmd/compile/internal/base"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/src"
"fmt"
"go/constant"
"go/token"
"cmd/compile/internal/base"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"fmt"
"go/constant"
"cmd/compile/internal/types"
"cmd/internal/obj"
"go/constant"
"math"
"math/big"
"cmd/compile/internal/base"
"cmd/compile/internal/types"
"cmd/internal/src"
"cmd/internal/src"
"cmd/compile/internal/base"
"cmd/internal/src"
"fmt"
"path/filepath"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/types"
"cmd/internal/src"
"go/constant"
"cmd/compile/internal/base"
"cmd/compile/internal/types"
"cmd/compile/internal/types"
"cmd/internal/src"
"fmt"
"go/constant"
"strconv"
"bytes"
"fmt"
"go/constant"
"io"
"os"
"path/filepath"
"reflect"
"strings"
"unicode/utf8"
"cmd/compile/internal/base"
"cmd/compile/internal/types"
"cmd/internal/src"
"strconv"
"cmd/compile/internal/base"
"cmd/compile/internal/base"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/src"
"go/constant"
"cmd/compile/internal/base"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/objabi"
"cmd/internal/src"
"fmt"
"strings"
"unicode/utf8"
"fmt"
"go/constant"
"cmd/compile/internal/base"
"cmd/compile/internal/types"
"cmd/internal/src"
"fmt"
"cmd/compile/internal/types"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="BlankNode">
               <h3>
                  BlankNode 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var BlankNode *Name</code></pre>
            </article>
            
            <article class="global" data-name="CgoUnsafeArgs">
               <h3>
                  CgoUnsafeArgs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const CgoUnsafeArgs</code></pre>
            </article>
            
            <article class="global" data-name="ConstPrec">
               <h3>
                  ConstPrec 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Maximum size in bits for big.Ints before signaling
overflow and also mantissa precision for big.Floats.</p>
               
               <pre><code>const ConstPrec = 512</code></pre>
            </article>
            
            <article class="global" data-name="CurFunc">
               <h3>
                  CurFunc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var CurFunc *Func</code></pre>
            </article>
            
            <article class="global" data-name="EscFmt">
               <h3>
                  EscFmt 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>EscFmt is set by the escape analysis code to add escape analysis details to the node print.</p>
               
               <pre><code>var EscFmt func(n Node) string</code></pre>
            </article>
            
            <article class="global" data-name="EscHeap">
               <h3>
                  EscHeap 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EscHeap</code></pre>
            </article>
            
            <article class="global" data-name="EscNever">
               <h3>
                  EscNever 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EscNever</code></pre>
            </article>
            
            <article class="global" data-name="EscNone">
               <h3>
                  EscNone 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EscNone</code></pre>
            </article>
            
            <article class="global" data-name="EscUnknown">
               <h3>
                  EscUnknown 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EscUnknown = iota</code></pre>
            </article>
            
            <article class="global" data-name="GoBuildPragma">
               <h3>
                  GoBuildPragma 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Go command pragmas</p>
               
               <pre><code>const GoBuildPragma</code></pre>
            </article>
            
            <article class="global" data-name="IsIntrinsicCall">
               <h3>
                  IsIntrinsicCall 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>IsIntrinsicCall reports whether the compiler back end will treat the call as an intrinsic operation.</p>
               
               <pre><code>var IsIntrinsicCall = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="MaxImplicitStackVarSize">
               <h3>
                  MaxImplicitStackVarSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>MaxImplicitStackVarSize is the maximum size of implicit variables that we will allocate on the stack.
p := new(T)          allocating T on the stack
p := &T{}            allocating T on the stack
s := make([]T, n)    allocating [n]T on the stack
s := []byte("...")   allocating [n]byte on the stack
Note: the flag smallframes can update this value.</p>
               
               <pre><code>var MaxImplicitStackVarSize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="MaxSmallArraySize">
               <h3>
                  MaxSmallArraySize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>MaxSmallArraySize is the maximum size of an array which is considered small.
Small arrays will be initialized directly with a sequence of constant stores.
Large arrays will be initialized by copying from a static temp.
256 bytes was chosen to minimize generated code + statictmp size.</p>
               
               <pre><code>var MaxSmallArraySize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="MaxStackVarSize">
               <h3>
                  MaxStackVarSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>MaxStackVarSize is the maximum size variable which we will allocate on the stack.
This limit is for explicit variable declarations like "var x T" or "x := ...".
Note: the flag smallframes can update this value.</p>
               
               <pre><code>var MaxStackVarSize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="NoCheckPtr">
               <h3>
                  NoCheckPtr 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NoCheckPtr</code></pre>
            </article>
            
            <article class="global" data-name="Noescape">
               <h3>
                  Noescape 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Noescape</code></pre>
            </article>
            
            <article class="global" data-name="Noinline">
               <h3>
                  Noinline 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Noinline</code></pre>
            </article>
            
            <article class="global" data-name="Nointerface">
               <h3>
                  Nointerface 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Func pragmas.</p>
               
               <pre><code>const Nointerface PragmaFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="Norace">
               <h3>
                  Norace 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Norace</code></pre>
            </article>
            
            <article class="global" data-name="Nosplit">
               <h3>
                  Nosplit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Nosplit</code></pre>
            </article>
            
            <article class="global" data-name="Nowritebarrier">
               <h3>
                  Nowritebarrier 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Nowritebarrier</code></pre>
            </article>
            
            <article class="global" data-name="Nowritebarrierrec">
               <h3>
                  Nowritebarrierrec 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Nowritebarrierrec</code></pre>
            </article>
            
            <article class="global" data-name="OADD">
               <h3>
                  OADD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>expressions</p>
               
               <pre><code>const OADD</code></pre>
            </article>
            
            <article class="global" data-name="OADDR">
               <h3>
                  OADDR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OADDR</code></pre>
            </article>
            
            <article class="global" data-name="OADDSTR">
               <h3>
                  OADDSTR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OADDSTR</code></pre>
            </article>
            
            <article class="global" data-name="OAND">
               <h3>
                  OAND 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OAND</code></pre>
            </article>
            
            <article class="global" data-name="OANDAND">
               <h3>
                  OANDAND 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OANDAND</code></pre>
            </article>
            
            <article class="global" data-name="OANDNOT">
               <h3>
                  OANDNOT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OANDNOT</code></pre>
            </article>
            
            <article class="global" data-name="OAPPEND">
               <h3>
                  OAPPEND 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OAPPEND</code></pre>
            </article>
            
            <article class="global" data-name="OARRAYLIT">
               <h3>
                  OARRAYLIT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OARRAYLIT</code></pre>
            </article>
            
            <article class="global" data-name="OAS">
               <h3>
                  OAS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>X = Y or (if Def=true) X := Y
If Def, then Init includes a DCL node for X.</p>
               
               <pre><code>const OAS</code></pre>
            </article>
            
            <article class="global" data-name="OAS2">
               <h3>
                  OAS2 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Lhs = Rhs (x, y, z = a, b, c) or (if Def=true) Lhs := Rhs
If Def, then Init includes DCL nodes for Lhs</p>
               
               <pre><code>const OAS2</code></pre>
            </article>
            
            <article class="global" data-name="OAS2DOTTYPE">
               <h3>
                  OAS2DOTTYPE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OAS2DOTTYPE</code></pre>
            </article>
            
            <article class="global" data-name="OAS2FUNC">
               <h3>
                  OAS2FUNC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OAS2FUNC</code></pre>
            </article>
            
            <article class="global" data-name="OAS2MAPR">
               <h3>
                  OAS2MAPR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OAS2MAPR</code></pre>
            </article>
            
            <article class="global" data-name="OAS2RECV">
               <h3>
                  OAS2RECV 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OAS2RECV</code></pre>
            </article>
            
            <article class="global" data-name="OASOP">
               <h3>
                  OASOP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OASOP</code></pre>
            </article>
            
            <article class="global" data-name="OBITNOT">
               <h3>
                  OBITNOT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OBITNOT</code></pre>
            </article>
            
            <article class="global" data-name="OBLOCK">
               <h3>
                  OBLOCK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>statements</p>
               
               <pre><code>const OBLOCK</code></pre>
            </article>
            
            <article class="global" data-name="OBREAK">
               <h3>
                  OBREAK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OBREAK</code></pre>
            </article>
            
            <article class="global" data-name="OBYTES2STR">
               <h3>
                  OBYTES2STR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OBYTES2STR</code></pre>
            </article>
            
            <article class="global" data-name="OBYTES2STRTMP">
               <h3>
                  OBYTES2STRTMP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OBYTES2STRTMP</code></pre>
            </article>
            
            <article class="global" data-name="OCALL">
               <h3>
                  OCALL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCALL</code></pre>
            </article>
            
            <article class="global" data-name="OCALLFUNC">
               <h3>
                  OCALLFUNC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>OCALLFUNC, OCALLMETH, and OCALLINTER have the same structure.
Prior to walk, they are: X(Args), where Args is all regular arguments.
After walk, if any argument whose evaluation might requires temporary variable,
that temporary variable will be pushed to Init, Args will contain an updated
set of arguments.</p>
               
               <pre><code>const OCALLFUNC</code></pre>
            </article>
            
            <article class="global" data-name="OCALLINTER">
               <h3>
                  OCALLINTER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCALLINTER</code></pre>
            </article>
            
            <article class="global" data-name="OCALLMETH">
               <h3>
                  OCALLMETH 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCALLMETH</code></pre>
            </article>
            
            <article class="global" data-name="OCAP">
               <h3>
                  OCAP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCAP</code></pre>
            </article>
            
            <article class="global" data-name="OCASE">
               <h3>
                  OCASE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>OCASE:  case List: Body (List==nil means default)
For OTYPESW, List is a OTYPE node for the specified type (or OLITERAL
for nil) or an ODYNAMICTYPE indicating a runtime type for generics.
If a type-switch variable is specified, Var is an
ONAME for the version of the type-switch variable with the specified
type.</p>
               
               <pre><code>const OCASE</code></pre>
            </article>
            
            <article class="global" data-name="OCFUNC">
               <h3>
                  OCFUNC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCFUNC</code></pre>
            </article>
            
            <article class="global" data-name="OCHECKNIL">
               <h3>
                  OCHECKNIL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCHECKNIL</code></pre>
            </article>
            
            <article class="global" data-name="OCLEAR">
               <h3>
                  OCLEAR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCLEAR</code></pre>
            </article>
            
            <article class="global" data-name="OCLOSE">
               <h3>
                  OCLOSE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCLOSE</code></pre>
            </article>
            
            <article class="global" data-name="OCLOSURE">
               <h3>
                  OCLOSURE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCLOSURE</code></pre>
            </article>
            
            <article class="global" data-name="OCOMPLEX">
               <h3>
                  OCOMPLEX 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCOMPLEX</code></pre>
            </article>
            
            <article class="global" data-name="OCOMPLIT">
               <h3>
                  OCOMPLIT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCOMPLIT</code></pre>
            </article>
            
            <article class="global" data-name="OCONTINUE">
               <h3>
                  OCONTINUE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCONTINUE</code></pre>
            </article>
            
            <article class="global" data-name="OCONV">
               <h3>
                  OCONV 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCONV</code></pre>
            </article>
            
            <article class="global" data-name="OCONVIFACE">
               <h3>
                  OCONVIFACE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCONVIFACE</code></pre>
            </article>
            
            <article class="global" data-name="OCONVNOP">
               <h3>
                  OCONVNOP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCONVNOP</code></pre>
            </article>
            
            <article class="global" data-name="OCOPY">
               <h3>
                  OCOPY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OCOPY</code></pre>
            </article>
            
            <article class="global" data-name="ODCL">
               <h3>
                  ODCL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODCL</code></pre>
            </article>
            
            <article class="global" data-name="ODCLFUNC">
               <h3>
                  ODCLFUNC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Used during parsing but don't last.</p>
               
               <pre><code>const ODCLFUNC</code></pre>
            </article>
            
            <article class="global" data-name="ODEFER">
               <h3>
                  ODEFER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODEFER</code></pre>
            </article>
            
            <article class="global" data-name="ODELETE">
               <h3>
                  ODELETE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODELETE</code></pre>
            </article>
            
            <article class="global" data-name="ODEREF">
               <h3>
                  ODEREF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODEREF</code></pre>
            </article>
            
            <article class="global" data-name="ODIV">
               <h3>
                  ODIV 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODIV</code></pre>
            </article>
            
            <article class="global" data-name="ODOT">
               <h3>
                  ODOT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODOT</code></pre>
            </article>
            
            <article class="global" data-name="ODOTINTER">
               <h3>
                  ODOTINTER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODOTINTER</code></pre>
            </article>
            
            <article class="global" data-name="ODOTMETH">
               <h3>
                  ODOTMETH 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODOTMETH</code></pre>
            </article>
            
            <article class="global" data-name="ODOTPTR">
               <h3>
                  ODOTPTR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODOTPTR</code></pre>
            </article>
            
            <article class="global" data-name="ODOTTYPE">
               <h3>
                  ODOTTYPE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODOTTYPE</code></pre>
            </article>
            
            <article class="global" data-name="ODOTTYPE2">
               <h3>
                  ODOTTYPE2 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODOTTYPE2</code></pre>
            </article>
            
            <article class="global" data-name="ODYNAMICDOTTYPE">
               <h3>
                  ODYNAMICDOTTYPE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>opcodes for generics</p>
               
               <pre><code>const ODYNAMICDOTTYPE</code></pre>
            </article>
            
            <article class="global" data-name="ODYNAMICDOTTYPE2">
               <h3>
                  ODYNAMICDOTTYPE2 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODYNAMICDOTTYPE2</code></pre>
            </article>
            
            <article class="global" data-name="ODYNAMICTYPE">
               <h3>
                  ODYNAMICTYPE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ODYNAMICTYPE</code></pre>
            </article>
            
            <article class="global" data-name="OEND">
               <h3>
                  OEND 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OEND</code></pre>
            </article>
            
            <article class="global" data-name="OEQ">
               <h3>
                  OEQ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OEQ</code></pre>
            </article>
            
            <article class="global" data-name="OFALL">
               <h3>
                  OFALL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OFALL</code></pre>
            </article>
            
            <article class="global" data-name="OFOR">
               <h3>
                  OFOR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OFOR</code></pre>
            </article>
            
            <article class="global" data-name="OGE">
               <h3>
                  OGE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OGE</code></pre>
            </article>
            
            <article class="global" data-name="OGETCALLERSP">
               <h3>
                  OGETCALLERSP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OGETCALLERSP</code></pre>
            </article>
            
            <article class="global" data-name="OGETG">
               <h3>
                  OGETG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OGETG</code></pre>
            </article>
            
            <article class="global" data-name="OGO">
               <h3>
                  OGO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OGO</code></pre>
            </article>
            
            <article class="global" data-name="OGOTO">
               <h3>
                  OGOTO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OGOTO</code></pre>
            </article>
            
            <article class="global" data-name="OGT">
               <h3>
                  OGT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OGT</code></pre>
            </article>
            
            <article class="global" data-name="OIDATA">
               <h3>
                  OIDATA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OIDATA</code></pre>
            </article>
            
            <article class="global" data-name="OIF">
               <h3>
                  OIF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OIF</code></pre>
            </article>
            
            <article class="global" data-name="OIMAG">
               <h3>
                  OIMAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OIMAG</code></pre>
            </article>
            
            <article class="global" data-name="OINDEX">
               <h3>
                  OINDEX 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OINDEX</code></pre>
            </article>
            
            <article class="global" data-name="OINDEXMAP">
               <h3>
                  OINDEXMAP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OINDEXMAP</code></pre>
            </article>
            
            <article class="global" data-name="OINLCALL">
               <h3>
                  OINLCALL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>misc
intermediate representation of an inlined call.  Uses Init (assignments
for the captured variables, parameters, retvars, & INLMARK op),
Body (body of the inlined function), and ReturnVars (list of
return values)</p>
               
               <pre><code>const OINLCALL</code></pre>
            </article>
            
            <article class="global" data-name="OINLMARK">
               <h3>
                  OINLMARK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OINLMARK</code></pre>
            </article>
            
            <article class="global" data-name="OINTERFACESWITCH">
               <h3>
                  OINTERFACESWITCH 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OINTERFACESWITCH</code></pre>
            </article>
            
            <article class="global" data-name="OITAB">
               <h3>
                  OITAB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OITAB</code></pre>
            </article>
            
            <article class="global" data-name="OJUMPTABLE">
               <h3>
                  OJUMPTABLE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OJUMPTABLE</code></pre>
            </article>
            
            <article class="global" data-name="OKEY">
               <h3>
                  OKEY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OKEY</code></pre>
            </article>
            
            <article class="global" data-name="OKForConst">
               <h3>
                  OKForConst 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var OKForConst [types.NTYPE]bool</code></pre>
            </article>
            
            <article class="global" data-name="OLABEL">
               <h3>
                  OLABEL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OLABEL</code></pre>
            </article>
            
            <article class="global" data-name="OLE">
               <h3>
                  OLE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OLE</code></pre>
            </article>
            
            <article class="global" data-name="OLEN">
               <h3>
                  OLEN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OLEN</code></pre>
            </article>
            
            <article class="global" data-name="OLINKSYMOFFSET">
               <h3>
                  OLINKSYMOFFSET 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OLINKSYMOFFSET</code></pre>
            </article>
            
            <article class="global" data-name="OLITERAL">
               <h3>
                  OLITERAL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OLITERAL</code></pre>
            </article>
            
            <article class="global" data-name="OLSH">
               <h3>
                  OLSH 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OLSH</code></pre>
            </article>
            
            <article class="global" data-name="OLT">
               <h3>
                  OLT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OLT</code></pre>
            </article>
            
            <article class="global" data-name="OMAKE">
               <h3>
                  OMAKE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OMAKE</code></pre>
            </article>
            
            <article class="global" data-name="OMAKECHAN">
               <h3>
                  OMAKECHAN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OMAKECHAN</code></pre>
            </article>
            
            <article class="global" data-name="OMAKEFACE">
               <h3>
                  OMAKEFACE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OMAKEFACE</code></pre>
            </article>
            
            <article class="global" data-name="OMAKEMAP">
               <h3>
                  OMAKEMAP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OMAKEMAP</code></pre>
            </article>
            
            <article class="global" data-name="OMAKESLICE">
               <h3>
                  OMAKESLICE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OMAKESLICE</code></pre>
            </article>
            
            <article class="global" data-name="OMAKESLICECOPY">
               <h3>
                  OMAKESLICECOPY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OMAKESLICECOPY</code></pre>
            </article>
            
            <article class="global" data-name="OMAPLIT">
               <h3>
                  OMAPLIT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OMAPLIT</code></pre>
            </article>
            
            <article class="global" data-name="OMAX">
               <h3>
                  OMAX 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OMAX</code></pre>
            </article>
            
            <article class="global" data-name="OMETHEXPR">
               <h3>
                  OMETHEXPR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OMETHEXPR</code></pre>
            </article>
            
            <article class="global" data-name="OMETHVALUE">
               <h3>
                  OMETHVALUE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OMETHVALUE</code></pre>
            </article>
            
            <article class="global" data-name="OMIN">
               <h3>
                  OMIN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OMIN</code></pre>
            </article>
            
            <article class="global" data-name="OMOD">
               <h3>
                  OMOD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OMOD</code></pre>
            </article>
            
            <article class="global" data-name="OMUL">
               <h3>
                  OMUL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>OMAKESLICECOPY is created by the order pass and corresponds to:
s = make(Type, Len); copy(s, Cap)
Bounded can be set on the node when Len == len(Cap) is known at compile time.
This node is created so the walk pass can optimize this pattern which would
otherwise be hard to detect after the order pass.</p>
               
               <pre><code>const OMUL</code></pre>
            </article>
            
            <article class="global" data-name="ONAME">
               <h3>
                  ONAME 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>names</p>
               
               <pre><code>const ONAME</code></pre>
            </article>
            
            <article class="global" data-name="ONE">
               <h3>
                  ONE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ONE</code></pre>
            </article>
            
            <article class="global" data-name="ONEG">
               <h3>
                  ONEG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ONEG</code></pre>
            </article>
            
            <article class="global" data-name="ONEW">
               <h3>
                  ONEW 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ONEW</code></pre>
            </article>
            
            <article class="global" data-name="ONIL">
               <h3>
                  ONIL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ONIL</code></pre>
            </article>
            
            <article class="global" data-name="ONONAME">
               <h3>
                  ONONAME 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Unnamed arg or return value: f(int, string) (int, error) { etc }
Also used for a qualified package identifier that hasn't been resolved yet.</p>
               
               <pre><code>const ONONAME</code></pre>
            </article>
            
            <article class="global" data-name="ONOT">
               <h3>
                  ONOT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ONOT</code></pre>
            </article>
            
            <article class="global" data-name="OOR">
               <h3>
                  OOR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OOR</code></pre>
            </article>
            
            <article class="global" data-name="OOROR">
               <h3>
                  OOROR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OOROR</code></pre>
            </article>
            
            <article class="global" data-name="OPANIC">
               <h3>
                  OPANIC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OPANIC</code></pre>
            </article>
            
            <article class="global" data-name="OPAREN">
               <h3>
                  OPAREN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OPAREN</code></pre>
            </article>
            
            <article class="global" data-name="OPLUS">
               <h3>
                  OPLUS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OPLUS</code></pre>
            </article>
            
            <article class="global" data-name="OPRINT">
               <h3>
                  OPRINT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OPRINT</code></pre>
            </article>
            
            <article class="global" data-name="OPRINTLN">
               <h3>
                  OPRINTLN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OPRINTLN</code></pre>
            </article>
            
            <article class="global" data-name="OPTRLIT">
               <h3>
                  OPTRLIT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OPTRLIT</code></pre>
            </article>
            
            <article class="global" data-name="ORANGE">
               <h3>
                  ORANGE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ORANGE</code></pre>
            </article>
            
            <article class="global" data-name="OREAL">
               <h3>
                  OREAL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OREAL</code></pre>
            </article>
            
            <article class="global" data-name="ORECOVER">
               <h3>
                  ORECOVER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ORECOVER</code></pre>
            </article>
            
            <article class="global" data-name="ORECOVERFP">
               <h3>
                  ORECOVERFP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ORECOVERFP</code></pre>
            </article>
            
            <article class="global" data-name="ORECV">
               <h3>
                  ORECV 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ORECV</code></pre>
            </article>
            
            <article class="global" data-name="ORESULT">
               <h3>
                  ORESULT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ORESULT</code></pre>
            </article>
            
            <article class="global" data-name="ORETURN">
               <h3>
                  ORETURN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ORETURN</code></pre>
            </article>
            
            <article class="global" data-name="ORSH">
               <h3>
                  ORSH 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ORSH</code></pre>
            </article>
            
            <article class="global" data-name="ORUNES2STR">
               <h3>
                  ORUNES2STR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ORUNES2STR</code></pre>
            </article>
            
            <article class="global" data-name="ORUNESTR">
               <h3>
                  ORUNESTR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const ORUNESTR</code></pre>
            </article>
            
            <article class="global" data-name="OSELECT">
               <h3>
                  OSELECT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSELECT</code></pre>
            </article>
            
            <article class="global" data-name="OSELRECV2">
               <h3>
                  OSELRECV2 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSELRECV2</code></pre>
            </article>
            
            <article class="global" data-name="OSEND">
               <h3>
                  OSEND 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSEND</code></pre>
            </article>
            
            <article class="global" data-name="OSLICE">
               <h3>
                  OSLICE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSLICE</code></pre>
            </article>
            
            <article class="global" data-name="OSLICE2ARR">
               <h3>
                  OSLICE2ARR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSLICE2ARR</code></pre>
            </article>
            
            <article class="global" data-name="OSLICE2ARRPTR">
               <h3>
                  OSLICE2ARRPTR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSLICE2ARRPTR</code></pre>
            </article>
            
            <article class="global" data-name="OSLICE3">
               <h3>
                  OSLICE3 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSLICE3</code></pre>
            </article>
            
            <article class="global" data-name="OSLICE3ARR">
               <h3>
                  OSLICE3ARR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSLICE3ARR</code></pre>
            </article>
            
            <article class="global" data-name="OSLICEARR">
               <h3>
                  OSLICEARR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSLICEARR</code></pre>
            </article>
            
            <article class="global" data-name="OSLICEHEADER">
               <h3>
                  OSLICEHEADER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSLICEHEADER</code></pre>
            </article>
            
            <article class="global" data-name="OSLICELIT">
               <h3>
                  OSLICELIT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSLICELIT</code></pre>
            </article>
            
            <article class="global" data-name="OSLICESTR">
               <h3>
                  OSLICESTR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSLICESTR</code></pre>
            </article>
            
            <article class="global" data-name="OSPTR">
               <h3>
                  OSPTR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSPTR</code></pre>
            </article>
            
            <article class="global" data-name="OSTR2BYTES">
               <h3>
                  OSTR2BYTES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSTR2BYTES</code></pre>
            </article>
            
            <article class="global" data-name="OSTR2BYTESTMP">
               <h3>
                  OSTR2BYTESTMP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSTR2BYTESTMP</code></pre>
            </article>
            
            <article class="global" data-name="OSTR2RUNES">
               <h3>
                  OSTR2RUNES 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSTR2RUNES</code></pre>
            </article>
            
            <article class="global" data-name="OSTRINGHEADER">
               <h3>
                  OSTRINGHEADER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSTRINGHEADER</code></pre>
            </article>
            
            <article class="global" data-name="OSTRUCTKEY">
               <h3>
                  OSTRUCTKEY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSTRUCTKEY</code></pre>
            </article>
            
            <article class="global" data-name="OSTRUCTLIT">
               <h3>
                  OSTRUCTLIT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSTRUCTLIT</code></pre>
            </article>
            
            <article class="global" data-name="OSUB">
               <h3>
                  OSUB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSUB</code></pre>
            </article>
            
            <article class="global" data-name="OSWITCH">
               <h3>
                  OSWITCH 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OSWITCH</code></pre>
            </article>
            
            <article class="global" data-name="OTAILCALL">
               <h3>
                  OTAILCALL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>arch-specific opcodes</p>
               
               <pre><code>const OTAILCALL</code></pre>
            </article>
            
            <article class="global" data-name="OTYPE">
               <h3>
                  OTYPE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OTYPE</code></pre>
            </article>
            
            <article class="global" data-name="OTYPESW">
               <h3>
                  OTYPESW 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>OTYPESW:  X := Y.(type) (appears as .Tag of OSWITCH)
X is nil if there is no type-switch variable</p>
               
               <pre><code>const OTYPESW</code></pre>
            </article>
            
            <article class="global" data-name="OUNSAFEADD">
               <h3>
                  OUNSAFEADD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OUNSAFEADD</code></pre>
            </article>
            
            <article class="global" data-name="OUNSAFESLICE">
               <h3>
                  OUNSAFESLICE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OUNSAFESLICE</code></pre>
            </article>
            
            <article class="global" data-name="OUNSAFESLICEDATA">
               <h3>
                  OUNSAFESLICEDATA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OUNSAFESLICEDATA</code></pre>
            </article>
            
            <article class="global" data-name="OUNSAFESTRING">
               <h3>
                  OUNSAFESTRING 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OUNSAFESTRING</code></pre>
            </article>
            
            <article class="global" data-name="OUNSAFESTRINGDATA">
               <h3>
                  OUNSAFESTRINGDATA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OUNSAFESTRINGDATA</code></pre>
            </article>
            
            <article class="global" data-name="OXDOT">
               <h3>
                  OXDOT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OXDOT</code></pre>
            </article>
            
            <article class="global" data-name="OXOR">
               <h3>
                  OXOR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OXOR</code></pre>
            </article>
            
            <article class="global" data-name="OXXX">
               <h3>
                  OXXX 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Node ops.</p>
               
               <pre><code>const OXXX Op = iota</code></pre>
            </article>
            
            <article class="global" data-name="OpNames">
               <h3>
                  OpNames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var OpNames = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="OpPrec">
               <h3>
                  OpPrec 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var OpPrec = []int{...}</code></pre>
            </article>
            
            <article class="global" data-name="PAUTO">
               <h3>
                  PAUTO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>go:generate stringer -type=Class name.go</p>
               
               <pre><code>const PAUTO</code></pre>
            </article>
            
            <article class="global" data-name="PAUTOHEAP">
               <h3>
                  PAUTOHEAP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>go:generate stringer -type=Class name.go</p>
               
               <pre><code>const PAUTOHEAP</code></pre>
            </article>
            
            <article class="global" data-name="PEXTERN">
               <h3>
                  PEXTERN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>go:generate stringer -type=Class name.go</p>
               
               <pre><code>const PEXTERN</code></pre>
            </article>
            
            <article class="global" data-name="PFUNC">
               <h3>
                  PFUNC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>go:generate stringer -type=Class name.go</p>
               
               <pre><code>const PFUNC</code></pre>
            </article>
            
            <article class="global" data-name="PPARAM">
               <h3>
                  PPARAM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>go:generate stringer -type=Class name.go</p>
               
               <pre><code>const PPARAM</code></pre>
            </article>
            
            <article class="global" data-name="PPARAMOUT">
               <h3>
                  PPARAMOUT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>go:generate stringer -type=Class name.go</p>
               
               <pre><code>const PPARAMOUT</code></pre>
            </article>
            
            <article class="global" data-name="PTYPEPARAM">
               <h3>
                  PTYPEPARAM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>go:generate stringer -type=Class name.go</p>
               
               <pre><code>const PTYPEPARAM</code></pre>
            </article>
            
            <article class="global" data-name="Pkgs">
               <h3>
                  Pkgs 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Pkgs holds known packages.</p>
               
               <pre><code>var Pkgs struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="Pxxx">
               <h3>
                  Pxxx 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>go:generate stringer -type=Class name.go</p>
               
               <pre><code>const Pxxx Class = iota</code></pre>
            </article>
            
            <article class="global" data-name="RegisterParams">
               <h3>
                  RegisterParams 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const RegisterParams</code></pre>
            </article>
            
            <article class="global" data-name="Syms">
               <h3>
                  Syms 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Syms holds known symbols.</p>
               
               <pre><code>var Syms symsStruct</code></pre>
            </article>
            
            <article class="global" data-name="Systemstack">
               <h3>
                  Systemstack 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Runtime-only func pragmas.
See ../../../../runtime/HACKING.md for detailed descriptions.</p>
               
               <pre><code>const Systemstack</code></pre>
            </article>
            
            <article class="global" data-name="UintptrEscapes">
               <h3>
                  UintptrEscapes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const UintptrEscapes</code></pre>
            </article>
            
            <article class="global" data-name="UintptrKeepAlive">
               <h3>
                  UintptrKeepAlive 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const UintptrKeepAlive</code></pre>
            </article>
            
            <article class="global" data-name="Yeswritebarrierrec">
               <h3>
                  Yeswritebarrierrec 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Yeswritebarrierrec</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Careful: Class is stored in three bits in Node.flags.</p>
               
               <pre><code>const _ = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_Class_index">
               <h3>
                  _Class_index 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _Class_index = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="_Class_name">
               <h3>
                  _Class_name 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Class_name = "PxxxPEXTERNPAUTOPAUTOHEAPPPARAMPPARAMOUTPTYPEPARAMPFUNC"</code></pre>
            </article>
            
            <article class="global" data-name="_Op_index">
               <h3>
                  _Op_index 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _Op_index = [...]uint16{...}</code></pre>
            </article>
            
            <article class="global" data-name="_Op_name">
               <h3>
                  _Op_name 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Op_name = "XXXNAMENONAMETYPELITERALNILADDSUBORXORADDSTRADDRANDANDAPPENDBYTES2STRBYTES2STRTMPRUNES2STRSTR2BYTESSTR2BYTESTMPSTR2RUNESSLICE2ARRSLICE2ARRPTRASAS2AS2DOTTYPEAS2FUNCAS2MAPRAS2RECVASOPCALLCALLFUNCCALLMETHCALLINTERCAPCLEARCLOSECLOSURECOMPLITMAPLITSTRUCTLITARRAYLITSLICELITPTRLITCONVCONVIFACECONVNOPCOPYDCLDCLFUNCDELETEDOTDOTPTRDOTMETHDOTINTERXDOTDOTTYPEDOTTYPE2EQNELTLEGEGTDEREFINDEXINDEXMAPKEYSTRUCTKEYLENMAKEMAKECHANMAKEMAPMAKESLICEMAKESLICECOPYMULDIVMODLSHRSHANDANDNOTNEWNOTBITNOTPLUSNEGORORPANICPRINTPRINTLNPARENSENDSLICESLICEARRSLICESTRSLICE3SLICE3ARRSLICEHEADERSTRINGHEADERRECOVERRECOVERFPRECVRUNESTRSELRECV2MINMAXREALIMAGCOMPLEXUNSAFEADDUNSAFESLICEUNSAFESLICEDATAUNSAFESTRINGUNSAFESTRINGDATAMETHEXPRMETHVALUEBLOCKBREAKCASECONTINUEDEFERFALLFORGOTOIFLABELGORANGERETURNSELECTSWITCHTYPESWINLCALLMAKEFACEITABIDATASPTRCFUNCCHECKNILRESULTINLMARKLINKSYMOFFSETJUMPTABLEINTERFACESWITCHDYNAMICDOTTYPEDYNAMICDOTTYPE2DYNAMICTYPETAILCALLGETGGETCALLERSPEND"</code></pre>
            </article>
            
            <article class="global" data-name="complexOne">
               <h3>
                  complexOne 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var complexOne = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="complexZero">
               <h3>
                  complexZero 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var complexZero = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="consistencyCheckEnabled">
               <h3>
                  consistencyCheckEnabled 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const consistencyCheckEnabled = true</code></pre>
            </article>
            
            <article class="global" data-name="consistencyCheckEnabled">
               <h3>
                  consistencyCheckEnabled 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const consistencyCheckEnabled = false</code></pre>
            </article>
            
            <article class="global" data-name="floatOne">
               <h3>
                  floatOne 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var floatOne = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="floatZero">
               <h3>
                  floatZero 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var floatZero = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="funcABIWrapper">
               <h3>
                  funcABIWrapper 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const funcABIWrapper</code></pre>
            </article>
            
            <article class="global" data-name="funcClosureResultsLost">
               <h3>
                  funcClosureResultsLost 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const funcClosureResultsLost</code></pre>
            </article>
            
            <article class="global" data-name="funcDupok">
               <h3>
                  funcDupok 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const funcDupok = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="funcHasDefer">
               <h3>
                  funcHasDefer 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const funcHasDefer</code></pre>
            </article>
            
            <article class="global" data-name="funcInlinabilityChecked">
               <h3>
                  funcInlinabilityChecked 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const funcInlinabilityChecked</code></pre>
            </article>
            
            <article class="global" data-name="funcNeedctxt">
               <h3>
                  funcNeedctxt 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const funcNeedctxt</code></pre>
            </article>
            
            <article class="global" data-name="funcNeverReturns">
               <h3>
                  funcNeverReturns 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const funcNeverReturns</code></pre>
            </article>
            
            <article class="global" data-name="funcNilCheckDisabled">
               <h3>
                  funcNilCheckDisabled 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const funcNilCheckDisabled</code></pre>
            </article>
            
            <article class="global" data-name="funcOpenCodedDeferDisallowed">
               <h3>
                  funcOpenCodedDeferDisallowed 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const funcOpenCodedDeferDisallowed</code></pre>
            </article>
            
            <article class="global" data-name="funcPackageInit">
               <h3>
                  funcPackageInit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const funcPackageInit</code></pre>
            </article>
            
            <article class="global" data-name="funcWrapper">
               <h3>
                  funcWrapper 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const funcWrapper</code></pre>
            </article>
            
            <article class="global" data-name="globClosgen">
               <h3>
                  globClosgen 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>globClosgen is like Func.Closgen, but for the global scope.</p>
               
               <pre><code>var globClosgen int32</code></pre>
            </article>
            
            <article class="global" data-name="indentBytes">
               <h3>
                  indentBytes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var indentBytes = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="intOne">
               <h3>
                  intOne 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var intOne = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="intZero">
               <h3>
                  intZero 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var intZero = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="miniExprBounded">
               <h3>
                  miniExprBounded 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const miniExprBounded</code></pre>
            </article>
            
            <article class="global" data-name="miniExprCheckPtr">
               <h3>
                  miniExprCheckPtr 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const miniExprCheckPtr</code></pre>
            </article>
            
            <article class="global" data-name="miniExprImplicit">
               <h3>
                  miniExprImplicit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const miniExprImplicit</code></pre>
            </article>
            
            <article class="global" data-name="miniExprNonNil">
               <h3>
                  miniExprNonNil 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const miniExprNonNil = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="miniExprTransient">
               <h3>
                  miniExprTransient 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const miniExprTransient</code></pre>
            </article>
            
            <article class="global" data-name="miniTypecheckShift">
               <h3>
                  miniTypecheckShift 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const miniTypecheckShift = 0</code></pre>
            </article>
            
            <article class="global" data-name="miniWalked">
               <h3>
                  miniWalked 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const miniWalked = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="nameAddrtaken">
               <h3>
                  nameAddrtaken 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameAddrtaken</code></pre>
            </article>
            
            <article class="global" data-name="nameAlias">
               <h3>
                  nameAlias 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameAlias</code></pre>
            </article>
            
            <article class="global" data-name="nameAutoTemp">
               <h3>
                  nameAutoTemp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameAutoTemp</code></pre>
            </article>
            
            <article class="global" data-name="nameByval">
               <h3>
                  nameByval 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameByval</code></pre>
            </article>
            
            <article class="global" data-name="nameCoverageAuxVar">
               <h3>
                  nameCoverageAuxVar 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameCoverageAuxVar</code></pre>
            </article>
            
            <article class="global" data-name="nameInlFormal">
               <h3>
                  nameInlFormal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameInlFormal</code></pre>
            </article>
            
            <article class="global" data-name="nameInlLocal">
               <h3>
                  nameInlLocal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameInlLocal</code></pre>
            </article>
            
            <article class="global" data-name="nameIsClosureVar">
               <h3>
                  nameIsClosureVar 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameIsClosureVar</code></pre>
            </article>
            
            <article class="global" data-name="nameIsOutputParamHeapAddr">
               <h3>
                  nameIsOutputParamHeapAddr 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameIsOutputParamHeapAddr</code></pre>
            </article>
            
            <article class="global" data-name="nameIsOutputParamInRegisters">
               <h3>
                  nameIsOutputParamInRegisters 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameIsOutputParamInRegisters</code></pre>
            </article>
            
            <article class="global" data-name="nameLibfuzzer8BitCounter">
               <h3>
                  nameLibfuzzer8BitCounter 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameLibfuzzer8BitCounter</code></pre>
            </article>
            
            <article class="global" data-name="nameNeedzero">
               <h3>
                  nameNeedzero 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameNeedzero</code></pre>
            </article>
            
            <article class="global" data-name="nameNonMergeable">
               <h3>
                  nameNonMergeable 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameNonMergeable</code></pre>
            </article>
            
            <article class="global" data-name="nameOpenDeferSlot">
               <h3>
                  nameOpenDeferSlot 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameOpenDeferSlot</code></pre>
            </article>
            
            <article class="global" data-name="nameReadonly">
               <h3>
                  nameReadonly 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameReadonly = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="nameUsed">
               <h3>
                  nameUsed 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nameUsed</code></pre>
            </article>
            
            <article class="global" data-name="nodeType">
               <h3>
                  nodeType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nodeType = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Class">
               <h3>
                  Class
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>The Class of a variable/function describes the "storage class"
of a variable or function. During parsing, storage classes are
called declaration contexts.</p>
               
               <pre><code>type Class uint8</code></pre>
            </article>
            
            <article class="type" data-name="NameSet">
               <h3>
                  NameSet
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>NameSet is a set of Names.</p>
               
               <pre><code>type NameSet map[*Name]struct{...}</code></pre>
            </article>
            
            <article class="type" data-name="Nodes">
               <h3>
                  Nodes
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Nodes is a slice of Node.</p>
               
               <pre><code>type Nodes []Node</code></pre>
            </article>
            
            <article class="type" data-name="Op">
               <h3>
                  Op
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type Op uint8</code></pre>
            </article>
            
            <article class="type" data-name="PragmaFlag">
               <h3>
                  PragmaFlag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type PragmaFlag uint16</code></pre>
            </article>
            
            <article class="type" data-name="ScopeID">
               <h3>
                  ScopeID
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A ScopeID represents a lexical scope within a function.</p>
               
               <pre><code>type ScopeID int32</code></pre>
            </article>
            
            <article class="type" data-name="bitset16">
               <h3>
                  bitset16
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type bitset16 uint16</code></pre>
            </article>
            
            <article class="type" data-name="bitset8">
               <h3>
                  bitset8
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type bitset8 uint8</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Expr">
               <h3>
                  Expr
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>An Expr is a Node that can appear as an expression.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Expr interface {
Node
isExpr()
}</code></pre>
            </article>
            
            <article class="interface" data-name="InitNode">
               <h3>
                  InitNode
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type InitNode interface {
Node
PtrInit() *Nodes
SetInit(x Nodes)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Node">
               <h3>
                  Node
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A Node is the abstract interface to an IR node.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Node interface {
Format(s fmt.State, verb rune)
Pos() src.XPos
SetPos(x src.XPos)
copy() Node
doChildren(func(Node) bool) bool
doChildrenWithHidden(func(Node) bool) bool
editChildren(func(Node) Node)
editChildrenWithHidden(func(Node) Node)
Op() Op
Init() Nodes
Type() *types.Type
SetType(t *types.Type)
Name() *Name
Sym() *types.Sym
Val() constant.Value
SetVal(v constant.Value)
Esc() uint16
SetEsc(x uint16)
Typecheck() uint8
SetTypecheck(x uint8)
NonNil() bool
MarkNonNil()
}</code></pre>
            </article>
            
            <article class="interface" data-name="Stmt">
               <h3>
                  Stmt
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A Stmt is a Node that can appear as a statement.
This includes statement-like expressions such as f().
(It's possible it should include <-c, but that would require
splitting ORECV out of UnaryExpr, which hasn't yet been
necessary. Maybe instead we will introduce ExprStmt at
some point.)</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Stmt interface {
Node
isStmt()
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="AddStringExpr">
               <h3>
                  AddStringExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>An AddStringExpr is a string concatenation List[0] + List[1] + ... + List[len(List)-1].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type AddStringExpr struct {
miniExpr
List Nodes
Prealloc *Name
}</code></pre>
            </article>
            
            <article class="struct" data-name="AddrExpr">
               <h3>
                  AddrExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>An AddrExpr is an address-of expression &X.
It may end up being a normal address-of or an allocation of a composite literal.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type AddrExpr struct {
miniExpr
X Node
Prealloc *Name
}</code></pre>
            </article>
            
            <article class="struct" data-name="AssignListStmt">
               <h3>
                  AssignListStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>An AssignListStmt is an assignment statement with
more than one item on at least one side: Lhs = Rhs.
If Def is true, the assignment is a :=.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type AssignListStmt struct {
miniStmt
Lhs Nodes
Def bool
Rhs Nodes
}</code></pre>
            </article>
            
            <article class="struct" data-name="AssignOpStmt">
               <h3>
                  AssignOpStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>An AssignOpStmt is an AsOp= assignment statement: X AsOp= Y.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type AssignOpStmt struct {
miniStmt
X Node
AsOp Op
Y Node
IncDec bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="AssignStmt">
               <h3>
                  AssignStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>An AssignStmt is a simple assignment statement: X = Y.
If Def is true, the assignment is a :=.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type AssignStmt struct {
miniStmt
X Node
Def bool
Y Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="BasicLit">
               <h3>
                  BasicLit
                  <span class="badge">struct</span>
               </h3>
               
               <p>A BasicLit is a literal of basic type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type BasicLit struct {
miniExpr
val constant.Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="BinaryExpr">
               <h3>
                  BinaryExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A BinaryExpr is a binary expression X Op Y,
or Op(X, Y) for builtin functions that do not become calls.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type BinaryExpr struct {
miniExpr
X Node
Y Node
RType Node `mknode:"-"`
}</code></pre>
            </article>
            
            <article class="struct" data-name="BlockStmt">
               <h3>
                  BlockStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A BlockStmt is a block: { List }.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type BlockStmt struct {
miniStmt
List Nodes
}</code></pre>
            </article>
            
            <article class="struct" data-name="BranchStmt">
               <h3>
                  BranchStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A BranchStmt is a break, continue, fallthrough, or goto statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type BranchStmt struct {
miniStmt
Label *types.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="CallExpr">
               <h3>
                  CallExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A CallExpr is a function call Fun(Args).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CallExpr struct {
miniExpr
Fun Node
Args Nodes
DeferAt Node
RType Node `mknode:"-"`
KeepAlive []*Name
IsDDD bool
GoDefer bool
NoInline bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="CaseClause">
               <h3>
                  CaseClause
                  <span class="badge">struct</span>
               </h3>
               
               <p>A CaseClause is a case statement in a switch or select: case List: Body.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CaseClause struct {
miniStmt
Var *Name
List Nodes
RTypes Nodes
Body Nodes
}</code></pre>
            </article>
            
            <article class="struct" data-name="ClosureExpr">
               <h3>
                  ClosureExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ClosureExpr is a function literal expression.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ClosureExpr struct {
miniExpr
Func *Func `mknode:"-"`
Prealloc *Name
IsGoWrap bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="CommClause">
               <h3>
                  CommClause
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CommClause struct {
miniStmt
Comm Node
Body Nodes
}</code></pre>
            </article>
            
            <article class="struct" data-name="CompLitExpr">
               <h3>
                  CompLitExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A CompLitExpr is a composite literal Type{Vals}.
Before type-checking, the type is Ntype.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CompLitExpr struct {
miniExpr
List Nodes
RType Node `mknode:"-"`
Prealloc *Name
Len int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="ConvExpr">
               <h3>
                  ConvExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ConvExpr is a conversion Type(X).
It may end up being a value or a type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ConvExpr struct {
miniExpr
X Node
TypeWord Node `mknode:"-"`
SrcRType Node `mknode:"-"`
ElemRType Node `mknode:"-"`
ElemElemRType Node `mknode:"-"`
}</code></pre>
            </article>
            
            <article class="struct" data-name="Decl">
               <h3>
                  Decl
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Decl is a declaration of a const, type, or var. (A declared func is a Func.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Decl struct {
miniNode
X *Name
}</code></pre>
            </article>
            
            <article class="struct" data-name="DynamicType">
               <h3>
                  DynamicType
                  <span class="badge">struct</span>
               </h3>
               
               <p>A DynamicType represents a type expression whose exact type must be
computed dynamically.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DynamicType struct {
miniExpr
RType Node
ITab Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="DynamicTypeAssertExpr">
               <h3>
                  DynamicTypeAssertExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A DynamicTypeAssertExpr asserts that X is of dynamic type RType.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DynamicTypeAssertExpr struct {
miniExpr
X Node
SrcRType Node
RType Node
ITab Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="Embed">
               <h3>
                  Embed
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Embed struct {
Pos src.XPos
Patterns []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="ForStmt">
               <h3>
                  ForStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ForStmt is a non-range for loop: for Init; Cond; Post { Body }</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ForStmt struct {
miniStmt
Label *types.Sym
Cond Node
Post Node
Body Nodes
DistinctVars bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Func">
               <h3>
                  Func
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Func corresponds to a single function in a Go program
(and vice versa: each function is denoted by exactly one *Func).
There are multiple nodes that represent a Func in the IR.
The ONAME node (Func.Nname) is used for plain references to it.
The ODCLFUNC node (the Func itself) is used for its declaration code.
The OCLOSURE node (Func.OClosure) is used for a reference to a
function literal.
An imported function will have an ONAME node which points to a Func
with an empty body.
A declared function or method has an ODCLFUNC (the Func itself) and an ONAME.
A function literal is represented directly by an OCLOSURE, but it also
has an ODCLFUNC (and a matching ONAME) representing the compiled
underlying form of the closure, which accesses the captured variables
using a special data structure passed in a register.
A method declaration is represented like functions, except f.Sym
will be the qualified method name (e.g., "T.m").
A method expression (T.M) is represented as an OMETHEXPR node,
in which n.Left and n.Right point to the type and method, respectively.
Each distinct mention of a method expression in the source code
constructs a fresh node.
A method value (t.M) is represented by ODOTMETH/ODOTINTER
when it is called directly and by OMETHVALUE otherwise.
These are like method expressions, except that for ODOTMETH/ODOTINTER,
the method name is stored in Sym instead of Right.
Each OMETHVALUE ends up being implemented as a new
function, a bit like a closure, with its own ODCLFUNC.
The OMETHVALUE uses n.Func to record the linkage to
the generated ODCLFUNC, but there is no
pointer from the Func back to the OMETHVALUE.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Func struct {
miniNode
Body Nodes
Nname *Name
OClosure *ClosureExpr
Dcl []*Name
ClosureVars []*Name
Closures []*Func
ClosureParent *Func
Parents []ScopeID
Marks []Mark
FieldTrack map[*obj.LSym]struct{...}
DebugInfo interface{}
LSym *obj.LSym
Inl *Inline
RangeParent *Func
funcLitGen int32
rangeLitGen int32
goDeferGen int32
Label int32
Endlineno src.XPos
WBPos src.XPos
Pragma PragmaFlag
flags bitset16
ABI obj.ABI
ABIRefs obj.ABISet
NumDefers int32
NumReturns int32
NWBRCalls *[]SymAndPos
WrappedFunc *Func
WasmImport *WasmImport
WasmExport *WasmExport
}</code></pre>
            </article>
            
            <article class="struct" data-name="GoDeferStmt">
               <h3>
                  GoDeferStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A GoDeferStmt is a go or defer statement: go Call / defer Call.
The two opcodes use a single syntax because the implementations
are very similar: both are concerned with saving Call and running it
in a different context (a separate goroutine or a later time).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type GoDeferStmt struct {
miniStmt
Call Node
DeferAt Expr
}</code></pre>
            </article>
            
            <article class="struct" data-name="Ident">
               <h3>
                  Ident
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Ident is an identifier, possibly qualified.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Ident struct {
miniExpr
sym *types.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="IfStmt">
               <h3>
                  IfStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>An IfStmt is a return statement: if Init; Cond { Body } else { Else }.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type IfStmt struct {
miniStmt
Cond Node
Body Nodes
Else Nodes
Likely bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="IndexExpr">
               <h3>
                  IndexExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>An IndexExpr is an index expression X[Index].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type IndexExpr struct {
miniExpr
X Node
Index Node
RType Node `mknode:"-"`
Assigned bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Inline">
               <h3>
                  Inline
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Inline holds fields used for function bodies that can be inlined.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Inline struct {
Cost int32
Dcl []*Name
HaveDcl bool
Properties string
CanDelayResults bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="InlineMarkStmt">
               <h3>
                  InlineMarkStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>An InlineMarkStmt is a marker placed just before an inlined body.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InlineMarkStmt struct {
miniStmt
Index int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="InlinedCallExpr">
               <h3>
                  InlinedCallExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>An InlinedCallExpr is an inlined function call.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InlinedCallExpr struct {
miniExpr
Body Nodes
ReturnVars Nodes
}</code></pre>
            </article>
            
            <article class="struct" data-name="InterfaceSwitchStmt">
               <h3>
                  InterfaceSwitchStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>An InterfaceSwitchStmt is used to implement type switches.
Its semantics are:
if RuntimeType implements Descriptor.Cases[0] {
Case, Itab = 0, itab<RuntimeType, Descriptor.Cases[0]>
} else if RuntimeType implements Descriptor.Cases[1] {
Case, Itab = 1, itab<RuntimeType, Descriptor.Cases[1]>
...
} else if RuntimeType implements Descriptor.Cases[N-1] {
Case, Itab = N-1, itab<RuntimeType, Descriptor.Cases[N-1]>
} else {
Case, Itab = len(cases), nil
}
RuntimeType must be a non-nil *runtime._type.
Hash must be the hash field of RuntimeType (or its copy loaded from an itab).
Descriptor must represent an abi.InterfaceSwitch global variable.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InterfaceSwitchStmt struct {
miniStmt
Case Node
Itab Node
RuntimeType Node
Hash Node
Descriptor *obj.LSym
}</code></pre>
            </article>
            
            <article class="struct" data-name="JumpTableStmt">
               <h3>
                  JumpTableStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A JumpTableStmt is used to implement switches. Its semantics are:
tmp := jt.Idx
if tmp == Cases[0] goto Targets[0]
if tmp == Cases[1] goto Targets[1]
...
if tmp == Cases[n] goto Targets[n]
Note that a JumpTableStmt is more like a multiway-goto than
a multiway-if. In particular, the case bodies are just
labels to jump to, not full Nodes lists.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type JumpTableStmt struct {
miniStmt
Idx Node
Cases []constant.Value
Targets []*types.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="KeyExpr">
               <h3>
                  KeyExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A KeyExpr is a Key: Value composite literal key.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type KeyExpr struct {
miniExpr
Key Node
Value Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="LabelStmt">
               <h3>
                  LabelStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A LabelStmt is a label statement (just the label, not including the statement it labels).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type LabelStmt struct {
miniStmt
Label *types.Sym
}</code></pre>
            </article>
            
            <article class="struct" data-name="LinksymOffsetExpr">
               <h3>
                  LinksymOffsetExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A LinksymOffsetExpr refers to an offset within a global variable.
It is like a SelectorExpr but without the field name.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type LinksymOffsetExpr struct {
miniExpr
Linksym *obj.LSym
Offset_ int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="LogicalExpr">
               <h3>
                  LogicalExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A LogicalExpr is an expression X Op Y where Op is && or ||.
It is separate from BinaryExpr to make room for statements
that must be executed before Y but after X.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type LogicalExpr struct {
miniExpr
X Node
Y Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="MakeExpr">
               <h3>
                  MakeExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A MakeExpr is a make expression: make(Type[, Len[, Cap]]).
Op is OMAKECHAN, OMAKEMAP, OMAKESLICE, or OMAKESLICECOPY,
but *not* OMAKE (that's a pre-typechecking CallExpr).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MakeExpr struct {
miniExpr
RType Node `mknode:"-"`
Len Node
Cap Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="Mark">
               <h3>
                  Mark
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Mark represents a scope boundary.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Mark struct {
Pos src.XPos
Scope ScopeID
}</code></pre>
            </article>
            
            <article class="struct" data-name="Name">
               <h3>
                  Name
                  <span class="badge">struct</span>
               </h3>
               
               <p>Name holds Node fields used only by named nodes (ONAME, OTYPE, some OLITERAL).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Name struct {
miniExpr
BuiltinOp Op
Class Class
pragma PragmaFlag
flags bitset16
DictIndex uint16
sym *types.Sym
Func *Func
Offset_ int64
val constant.Value
Opt interface{}
Embed *[]Embed
Defn Node
Curfn *Func
Heapaddr *Name
Outer *Name
}</code></pre>
            </article>
            
            <article class="struct" data-name="NameQueue">
               <h3>
                  NameQueue
                  <span class="badge">struct</span>
               </h3>
               
               <p>NameQueue is a FIFO queue of *Name. The zero value of NameQueue is
a ready-to-use empty queue.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NameQueue struct {
ring []*Name
head int
tail int
}</code></pre>
            </article>
            
            <article class="struct" data-name="NilExpr">
               <h3>
                  NilExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A NilExpr represents the predefined untyped constant nil.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NilExpr struct {
miniExpr
}</code></pre>
            </article>
            
            <article class="struct" data-name="Package">
               <h3>
                  Package
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Package holds information about the package being compiled.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Package struct {
Imports []*types.Pkg
Inits []*Func
Funcs []*Func
Externs []*Name
AsmHdrDecls []*Name
CgoPragmas [][]string
Embeds []*Name
PluginExports []*Name
}</code></pre>
            </article>
            
            <article class="struct" data-name="ParenExpr">
               <h3>
                  ParenExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ParenExpr is a parenthesized expression (X).
It may end up being a value or a type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ParenExpr struct {
miniExpr
X Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="RangeStmt">
               <h3>
                  RangeStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A RangeStmt is a range loop: for Key, Value = range X { Body }</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type RangeStmt struct {
miniStmt
Label *types.Sym
Def bool
X Node
RType Node `mknode:"-"`
Key Node
Value Node
Body Nodes
DistinctVars bool
Prealloc *Name
KeyTypeWord Node `mknode:"-"`
KeySrcRType Node `mknode:"-"`
ValueTypeWord Node `mknode:"-"`
ValueSrcRType Node `mknode:"-"`
}</code></pre>
            </article>
            
            <article class="struct" data-name="ReassignOracle">
               <h3>
                  ReassignOracle
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ReassignOracle efficiently answers queries about whether local
variables are reassigned. This helper works by looking for function
params and short variable declarations (e.g.
https://go.dev/ref/spec#Short_variable_declarations) that are
neither address taken nor subsequently re-assigned. It is intended
to operate much like "ir.StaticValue" and "ir.Reassigned", but in a
way that does just a single walk of the containing function (as
opposed to a new walk on every call).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ReassignOracle struct {
fn *Func
singleDef map[*Name]Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="ResultExpr">
               <h3>
                  ResultExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ResultExpr represents a direct access to a result.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ResultExpr struct {
miniExpr
Index int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="ReturnStmt">
               <h3>
                  ReturnStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ReturnStmt is a return statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ReturnStmt struct {
miniStmt
Results Nodes
}</code></pre>
            </article>
            
            <article class="struct" data-name="SelectStmt">
               <h3>
                  SelectStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A SelectStmt is a block: { Cases }.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SelectStmt struct {
miniStmt
Label *types.Sym
Cases []*CommClause
Compiled Nodes
}</code></pre>
            </article>
            
            <article class="struct" data-name="SelectorExpr">
               <h3>
                  SelectorExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A SelectorExpr is a selector expression X.Sel.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SelectorExpr struct {
miniExpr
X Node
Sel *types.Sym
Selection *types.Field
Prealloc *Name
}</code></pre>
            </article>
            
            <article class="struct" data-name="SendStmt">
               <h3>
                  SendStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A SendStmt is a send statement: X <- Y.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SendStmt struct {
miniStmt
Chan Node
Value Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="SliceExpr">
               <h3>
                  SliceExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A SliceExpr is a slice expression X[Low:High] or X[Low:High:Max].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SliceExpr struct {
miniExpr
X Node
Low Node
High Node
Max Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="SliceHeaderExpr">
               <h3>
                  SliceHeaderExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A SliceHeader expression constructs a slice header from its parts.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SliceHeaderExpr struct {
miniExpr
Ptr Node
Len Node
Cap Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="StarExpr">
               <h3>
                  StarExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A StarExpr is a dereference expression *X.
It may end up being a value or a type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StarExpr struct {
miniExpr
X Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="StringHeaderExpr">
               <h3>
                  StringHeaderExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A StringHeaderExpr expression constructs a string header from its parts.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StringHeaderExpr struct {
miniExpr
Ptr Node
Len Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="StructKeyExpr">
               <h3>
                  StructKeyExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A StructKeyExpr is a Field: Value composite literal key.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StructKeyExpr struct {
miniExpr
Field *types.Field
Value Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="SwitchStmt">
               <h3>
                  SwitchStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A SwitchStmt is a switch statement: switch Init; Tag { Cases }.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SwitchStmt struct {
miniStmt
Tag Node
Cases []*CaseClause
Label *types.Sym
Compiled Nodes
}</code></pre>
            </article>
            
            <article class="struct" data-name="SymAndPos">
               <h3>
                  SymAndPos
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SymAndPos struct {
Sym *obj.LSym
Pos src.XPos
}</code></pre>
            </article>
            
            <article class="struct" data-name="TailCallStmt">
               <h3>
                  TailCallStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A TailCallStmt is a tail call statement, which is used for back-end
code generation to jump directly to another function entirely.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TailCallStmt struct {
miniStmt
Call *CallExpr
}</code></pre>
            </article>
            
            <article class="struct" data-name="TypeAssertExpr">
               <h3>
                  TypeAssertExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A TypeAssertionExpr is a selector expression X.(Type).
Before type-checking, the type is Ntype.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TypeAssertExpr struct {
miniExpr
X Node
ITab Node `mknode:"-"`
Descriptor *obj.LSym
}</code></pre>
            </article>
            
            <article class="struct" data-name="TypeSwitchGuard">
               <h3>
                  TypeSwitchGuard
                  <span class="badge">struct</span>
               </h3>
               
               <p>A TypeSwitchGuard is the [Name :=] X.(type) in a type switch.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TypeSwitchGuard struct {
miniNode
Tag *Ident
X Node
Used bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="UnaryExpr">
               <h3>
                  UnaryExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A UnaryExpr is a unary expression Op X,
or Op(X) for a builtin function that does not end up being a call.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UnaryExpr struct {
miniExpr
X Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="WasmExport">
               <h3>
                  WasmExport
                  <span class="badge">struct</span>
               </h3>
               
               <p>WasmExport stores metadata associated with the //go:wasmexport pragma.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type WasmExport struct {
Name string
}</code></pre>
            </article>
            
            <article class="struct" data-name="WasmImport">
               <h3>
                  WasmImport
                  <span class="badge">struct</span>
               </h3>
               
               <p>WasmImport stores metadata associated with the //go:wasmimport pragma.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type WasmImport struct {
Module string
Name string
}</code></pre>
            </article>
            
            <article class="struct" data-name="bottomUpVisitor">
               <h3>
                  bottomUpVisitor
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bottomUpVisitor struct {
analyze func([]*Func, bool)
visitgen uint32
nodeID map[*Func]uint32
stack []*Func
}</code></pre>
            </article>
            
            <article class="struct" data-name="dumper">
               <h3>
                  dumper
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dumper struct {
output io.Writer
fieldrx *regexp.Regexp
ptrmap map[uintptr]int
lastadr string
indent int
last byte
line int
}</code></pre>
            </article>
            
            <article class="struct" data-name="miniExpr">
               <h3>
                  miniExpr
                  <span class="badge">struct</span>
               </h3>
               
               <p>A miniExpr is a miniNode with extra fields common to expressions.
TODO(rsc): Once we are sure about the contents, compact the bools
into a bit field and leave extra bits available for implementations
embedding miniExpr. Right now there are ~60 unused bits sitting here.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type miniExpr struct {
miniNode
typ *types.Type
init Nodes
flags bitset8
}</code></pre>
            </article>
            
            <article class="struct" data-name="miniNode">
               <h3>
                  miniNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>A miniNode is a minimal node implementation,
meant to be embedded as the first field in a larger node implementation,
at a cost of 8 bytes.
A miniNode is NOT a valid Node by itself: the embedding struct
must at the least provide:
func (n *MyNode) String() string { return fmt.Sprint(n) }
func (n *MyNode) rawCopy() Node { c := *n; return &c }
func (n *MyNode) Format(s fmt.State, verb rune) { FmtNode(n, s, verb) }
The embedding struct should also fill in n.op in its constructor,
for more useful panic messages when invalid methods are called,
instead of implementing Op itself.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type miniNode struct {
pos src.XPos
op Op
bits bitset8
esc uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="miniStmt">
               <h3>
                  miniStmt
                  <span class="badge">struct</span>
               </h3>
               
               <p>A miniStmt is a miniNode with extra fields common to statements.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type miniStmt struct {
miniNode
init Nodes
}</code></pre>
            </article>
            
            <article class="struct" data-name="symsStruct">
               <h3>
                  symsStruct
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type symsStruct struct {
AssertE2I *obj.LSym
AssertE2I2 *obj.LSym
Asanread *obj.LSym
Asanwrite *obj.LSym
CgoCheckMemmove *obj.LSym
CgoCheckPtrWrite *obj.LSym
CheckPtrAlignment *obj.LSym
Deferproc *obj.LSym
Deferprocat *obj.LSym
DeferprocStack *obj.LSym
Deferreturn *obj.LSym
Duffcopy *obj.LSym
Duffzero *obj.LSym
GCWriteBarrier [8]*obj.LSym
Goschedguarded *obj.LSym
Growslice *obj.LSym
InterfaceSwitch *obj.LSym
Memmove *obj.LSym
Msanread *obj.LSym
Msanwrite *obj.LSym
Msanmove *obj.LSym
Newobject *obj.LSym
Newproc *obj.LSym
Panicdivide *obj.LSym
Panicshift *obj.LSym
PanicdottypeE *obj.LSym
PanicdottypeI *obj.LSym
Panicnildottype *obj.LSym
Panicoverflow *obj.LSym
Racefuncenter *obj.LSym
Racefuncexit *obj.LSym
Raceread *obj.LSym
Racereadrange *obj.LSym
Racewrite *obj.LSym
Racewriterange *obj.LSym
TypeAssert *obj.LSym
WBZero *obj.LSym
WBMove *obj.LSym
SigPanic *obj.LSym
Staticuint64s *obj.LSym
Typedmemmove *obj.LSym
Udiv *obj.LSym
WriteBarrier *obj.LSym
Zerobase *obj.LSym
ARM64HasATOMICS *obj.LSym
ARMHasVFPv4 *obj.LSym
Loong64HasLAMCAS *obj.LSym
Loong64HasLAM_BH *obj.LSym
Loong64HasLSX *obj.LSym
X86HasFMA *obj.LSym
X86HasPOPCNT *obj.LSym
X86HasSSE41 *obj.LSym
WasmDiv *obj.LSym
WasmTruncS *obj.LSym
WasmTruncU *obj.LSym
}</code></pre>
            </article>
            
            <article class="struct" data-name="typeNode">
               <h3>
                  typeNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>A typeNode is a Node wrapper for type t.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type typeNode struct {
miniNode
typ *types.Type
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="ABIWrapper">
               <h3>
                  ABIWrapper 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) ABIWrapper() bool</code></pre>
            </article>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add adds n to s.</p>
               
               <pre><code>func (s *NameSet) Add(n *Name)</code></pre>
            </article>
            
            <article class="function" data-name="Addrtaken">
               <h3>
                  Addrtaken 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) Addrtaken() bool</code></pre>
            </article>
            
            <article class="function" data-name="Alias">
               <h3>
                  Alias 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Alias reports whether p, which must be for an OTYPE, is a type alias.</p>
               
               <pre><code>func (n *Name) Alias() bool</code></pre>
            </article>
            
            <article class="function" data-name="Any">
               <h3>
                  Any 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Any looks for a non-nil node x in the IR tree rooted at n
for which cond(x) returns true.
Any considers nodes in a depth-first, preorder traversal.
When Any finds a node x such that cond(x) is true,
Any ends the traversal and returns true immediately.
Otherwise Any returns false after completing the entire traversal.</p>
               
               <pre><code>func Any(n Node, cond func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="AnyList">
               <h3>
                  AnyList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AnyList calls Any(x, cond) for each node x in the list, in order.
If any call returns true, AnyList stops and returns true.
Otherwise, AnyList returns false after calling Any(x, cond)
for every x in the list.</p>
               
               <pre><code>func AnyList(list Nodes, cond func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="Append">
               <h3>
                  Append 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Append appends entries to Nodes.</p>
               
               <pre><code>func (n *Nodes) Append(a ...Node)</code></pre>
            </article>
            
            <article class="function" data-name="AssertValidTypeForConst">
               <h3>
                  AssertValidTypeForConst 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func AssertValidTypeForConst(t *types.Type, v constant.Value)</code></pre>
            </article>
            
            <article class="function" data-name="AutoTemp">
               <h3>
                  AutoTemp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) AutoTemp() bool</code></pre>
            </article>
            
            <article class="function" data-name="BigFloat">
               <h3>
                  BigFloat 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func BigFloat(v constant.Value) *big.Float</code></pre>
            </article>
            
            <article class="function" data-name="BoolVal">
               <h3>
                  BoolVal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>BoolVal returns n as a bool.
n must be a boolean constant.</p>
               
               <pre><code>func BoolVal(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="Bounded">
               <h3>
                  Bounded 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniExpr) Bounded() bool</code></pre>
            </article>
            
            <article class="function" data-name="Byval">
               <h3>
                  Byval 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) Byval() bool</code></pre>
            </article>
            
            <article class="function" data-name="CanBeAnSSAAux">
               <h3>
                  CanBeAnSSAAux 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*Name) CanBeAnSSAAux()</code></pre>
            </article>
            
            <article class="function" data-name="CanBeAnSSASym">
               <h3>
                  CanBeAnSSASym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*Name) CanBeAnSSASym()</code></pre>
            </article>
            
            <article class="function" data-name="CanBeNtype">
               <h3>
                  CanBeNtype 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*Name) CanBeNtype()</code></pre>
            </article>
            
            <article class="function" data-name="Canonical">
               <h3>
                  Canonical 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Canonical returns the logical declaration that n represents. If n
is a closure variable, then Canonical returns the original Name as
it appears in the function that immediately contains the
declaration. Otherwise, Canonical simply returns n itself.</p>
               
               <pre><code>func (n *Name) Canonical() *Name</code></pre>
            </article>
            
            <article class="function" data-name="CheckPtr">
               <h3>
                  CheckPtr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ConvExpr) CheckPtr() bool</code></pre>
            </article>
            
            <article class="function" data-name="ClosureDebugRuntimeCheck">
               <h3>
                  ClosureDebugRuntimeCheck 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ClosureDebugRuntimeCheck applies boilerplate checks for debug flags
and compiling runtime.</p>
               
               <pre><code>func ClosureDebugRuntimeCheck(clo *ClosureExpr)</code></pre>
            </article>
            
            <article class="function" data-name="ClosureResultsLost">
               <h3>
                  ClosureResultsLost 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) ClosureResultsLost() bool</code></pre>
            </article>
            
            <article class="function" data-name="ConstOverflow">
               <h3>
                  ConstOverflow 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ConstOverflow reports whether constant value v is too large
to represent with type t.</p>
               
               <pre><code>func ConstOverflow(v constant.Value, t *types.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="ConstType">
               <h3>
                  ConstType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ConstType(n Node) constant.Kind</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copy returns a copy of the content of the slice.</p>
               
               <pre><code>func (n Nodes) Copy() Nodes</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Copy returns a shallow copy of n.</p>
               
               <pre><code>func Copy(n Node) Node</code></pre>
            </article>
            
            <article class="function" data-name="CoverageAuxVar">
               <h3>
                  CoverageAuxVar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) CoverageAuxVar() bool</code></pre>
            </article>
            
            <article class="function" data-name="DeclareParams">
               <h3>
                  DeclareParams 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DeclareParams creates Names for all of the parameters in fn's
signature and adds them to fn.Dcl.
If setNname is true, then it also sets types.Field.Nname for each
parameter.</p>
               
               <pre><code>func (fn *Func) DeclareParams(setNname bool)</code></pre>
            </article>
            
            <article class="function" data-name="DeclaredBy">
               <h3>
                  DeclaredBy 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DeclaredBy reports whether expression x refers (directly) to a
variable that was declared by the given statement.</p>
               
               <pre><code>func DeclaredBy(x Node, stmt Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="DeepCopy">
               <h3>
                  DeepCopy 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DeepCopy returns a “deep” copy of n, with its entire structure copied
(except for shared nodes like ONAME, ONONAME, OLITERAL, and OTYPE).
If pos.IsKnown(), it sets the source position of newly allocated Nodes to pos.</p>
               
               <pre><code>func DeepCopy(pos src.XPos, n Node) Node</code></pre>
            </article>
            
            <article class="function" data-name="DeepCopyList">
               <h3>
                  DeepCopyList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DeepCopyList returns a list of deep copies (using DeepCopy) of the nodes in list.</p>
               
               <pre><code>func DeepCopyList(pos src.XPos, list []Node) []Node</code></pre>
            </article>
            
            <article class="function" data-name="DoChildren">
               <h3>
                  DoChildren 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DoChildren calls do(x) on each of n's non-nil child nodes x.
If any call returns true, DoChildren stops and returns true.
Otherwise, DoChildren returns false.
Note that DoChildren(n, do) only calls do(x) for n's immediate children.
If x's children should be processed, then do(x) must call DoChildren(x, do).
DoChildren allows constructing general traversals of the IR graph
that can stop early if needed. The most general usage is:
var do func(ir.Node) bool
do = func(x ir.Node) bool {
... processing BEFORE visiting children ...
if ... should visit children ... {
ir.DoChildren(x, do)
... processing AFTER visiting children ...
}
if ... should stop parent DoChildren call from visiting siblings ... {
return true
}
return false
}
do(root)
Since DoChildren does not return true itself, if the do function
never wants to stop the traversal, it can assume that DoChildren
itself will always return false, simplifying to:
var do func(ir.Node) bool
do = func(x ir.Node) bool {
... processing BEFORE visiting children ...
if ... should visit children ... {
ir.DoChildren(x, do)
}
... processing AFTER visiting children ...
return false
}
do(root)
The Visit function illustrates a further simplification of the pattern,
only processing before visiting children and never stopping:
func Visit(n ir.Node, visit func(ir.Node)) {
if n == nil {
return
}
var do func(ir.Node) bool
do = func(x ir.Node) bool {
visit(x)
return ir.DoChildren(x, do)
}
do(n)
}
The Any function illustrates a different simplification of the pattern,
visiting each node and then its children, recursively, until finding
a node x for which cond(x) returns true, at which point the entire
traversal stops and returns true.
func Any(n ir.Node, cond(ir.Node) bool) bool {
if n == nil {
return false
}
var do func(ir.Node) bool
do = func(x ir.Node) bool {
return cond(x) || ir.DoChildren(x, do)
}
return do(n)
}
Visit and Any are presented above as examples of how to use
DoChildren effectively, but of course, usage that fits within the
simplifications captured by Visit or Any will be best served
by directly calling the ones provided by this package.</p>
               
               <pre><code>func DoChildren(n Node, do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="DoChildrenWithHidden">
               <h3>
                  DoChildrenWithHidden 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DoChildrenWithHidden is like DoChildren, but also visits
Node-typed fields tagged with `mknode:"-"`.
TODO(mdempsky): Remove the `mknode:"-"` tags so this function can
go away.</p>
               
               <pre><code>func DoChildrenWithHidden(n Node, do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="Dump">
               <h3>
                  Dump 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Dump prints the message s followed by a debug dump of n.</p>
               
               <pre><code>func Dump(s string, n Node)</code></pre>
            </article>
            
            <article class="function" data-name="DumpAny">
               <h3>
                  DumpAny 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DumpAny is like FDumpAny but prints to stderr.</p>
               
               <pre><code>func DumpAny(root interface{}, filter string, depth int)</code></pre>
            </article>
            
            <article class="function" data-name="DumpList">
               <h3>
                  DumpList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DumpList prints the message s followed by a debug dump of each node in the list.</p>
               
               <pre><code>func DumpList(s string, list Nodes)</code></pre>
            </article>
            
            <article class="function" data-name="Dupok">
               <h3>
                  Dupok 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) Dupok() bool</code></pre>
            </article>
            
            <article class="function" data-name="EditChildren">
               <h3>
                  EditChildren 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>EditChildren edits the child nodes of n, replacing each child x with edit(x).
Note that EditChildren(n, edit) only calls edit(x) for n's immediate children.
If x's children should be processed, then edit(x) must call EditChildren(x, edit).
EditChildren allows constructing general editing passes of the IR graph.
The most general usage is:
var edit func(ir.Node) ir.Node
edit = func(x ir.Node) ir.Node {
... processing BEFORE editing children ...
if ... should edit children ... {
EditChildren(x, edit)
... processing AFTER editing children ...
}
... return x ...
}
n = edit(n)
EditChildren edits the node in place. To edit a copy, call Copy first.
As an example, a simple deep copy implementation would be:
func deepCopy(n ir.Node) ir.Node {
var edit func(ir.Node) ir.Node
edit = func(x ir.Node) ir.Node {
x = ir.Copy(x)
ir.EditChildren(x, edit)
return x
}
return edit(n)
}
Of course, in this case it is better to call ir.DeepCopy than to build one anew.</p>
               
               <pre><code>func EditChildren(n Node, edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="EditChildrenWithHidden">
               <h3>
                  EditChildrenWithHidden 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>EditChildrenWithHidden is like EditChildren, but also edits
Node-typed fields tagged with `mknode:"-"`.
TODO(mdempsky): Remove the `mknode:"-"` tags so this function can
go away.</p>
               
               <pre><code>func EditChildrenWithHidden(n Node, edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="Empty">
               <h3>
                  Empty 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Empty reports whether q contains no Names.</p>
               
               <pre><code>func (q *NameQueue) Empty() bool</code></pre>
            </article>
            
            <article class="function" data-name="Esc">
               <h3>
                  Esc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) Esc() uint16</code></pre>
            </article>
            
            <article class="function" data-name="FDumpAny">
               <h3>
                  FDumpAny 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FDumpAny prints the structure of a rooted data structure
to w by depth-first traversal of the data structure.
The filter parameter is a regular expression. If it is
non-empty, only struct fields whose names match filter
are printed.
The depth parameter controls how deep traversal recurses
before it returns (higher value means greater depth).
If an empty field filter is given, a good depth default value
is 4. A negative depth means no depth limit, which may be fine
for small data structures or if there is a non-empty filter.
In the output, Node structs are identified by their Op name
rather than their type; struct fields with zero values or
non-matching field names are omitted, and "…" means recursion
depth has been reached or struct fields have been omitted.</p>
               
               <pre><code>func FDumpAny(w io.Writer, root interface{}, filter string, depth int)</code></pre>
            </article>
            
            <article class="function" data-name="FDumpList">
               <h3>
                  FDumpList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FDumpList prints to w the message s followed by a debug dump of each node in the list.</p>
               
               <pre><code>func FDumpList(w io.Writer, s string, list Nodes)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ReturnStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SendStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LabelStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *KeyExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LogicalExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *JumpTableStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *MakeExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddStringExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InterfaceSwitchStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlinedCallExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NilExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlineMarkStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ParenExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IndexExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Format implements formatting for an Op.
The valid formats are:
%v	Go syntax ("+", "<-", "print")
%+v	Debug syntax ("ADD", "RECV", "PRINT")</p>
               
               <pre><code>func (o Op) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *RangeStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ResultExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IfStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Format implements formatting for a Nodes.
The valid formats are:
%v	Go syntax, semicolon-separated
%.v	Go syntax, comma-separated
%+v	Debug syntax, as in DumpList.</p>
               
               <pre><code>func (l Nodes) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddrExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignListStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectorExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Ident) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *GoDeferStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignOpStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Func) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *typeNode) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LinksymOffsetExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ForStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BranchStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceHeaderExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *UnaryExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BasicLit) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicTypeAssertExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StarExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicType) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StringHeaderExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Decl) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StructKeyExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ConvExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeSwitchGuard) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BinaryExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CompLitExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CommClause) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BlockStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ClosureExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SwitchStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CaseClause) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CallExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TailCallStmt) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeAssertExpr) Format(s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="FrameOffset">
               <h3>
                  FrameOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) FrameOffset() int64</code></pre>
            </article>
            
            <article class="function" data-name="FuncName">
               <h3>
                  FuncName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FuncName returns the name (without the package) of the function f.</p>
               
               <pre><code>func FuncName(f *Func) string</code></pre>
            </article>
            
            <article class="function" data-name="FuncName">
               <h3>
                  FuncName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectorExpr) FuncName() *Name</code></pre>
            </article>
            
            <article class="function" data-name="FuncPC">
               <h3>
                  FuncPC 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FuncPC returns a uintptr-typed expression that evaluates to the PC of a
function as uintptr, as returned by internal/abi.FuncPC{ABI0,ABIInternal}.
n should be a Node of an interface type, as is passed to
internal/abi.FuncPC{ABI0,ABIInternal}.
TODO(prattmic): Since n is simply an interface{} there is no assertion that
it is actually a function at all. Perhaps we should emit a runtime type
assertion?</p>
               
               <pre><code>func FuncPC(pos src.XPos, n Node, wantABI obj.ABI) Node</code></pre>
            </article>
            
            <article class="function" data-name="FuncSymName">
               <h3>
                  FuncSymName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func FuncSymName(s *types.Sym) string</code></pre>
            </article>
            
            <article class="function" data-name="GoString">
               <h3>
                  GoString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GoString returns the Go syntax for the Op, or else its name.</p>
               
               <pre><code>func (o Op) GoString() string</code></pre>
            </article>
            
            <article class="function" data-name="Has">
               <h3>
                  Has 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Has reports whether s contains n.</p>
               
               <pre><code>func (s NameSet) Has(n *Name) bool</code></pre>
            </article>
            
            <article class="function" data-name="HasDefer">
               <h3>
                  HasDefer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) HasDefer() bool</code></pre>
            </article>
            
            <article class="function" data-name="HasUniquePos">
               <h3>
                  HasUniquePos 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>HasUniquePos reports whether n has a unique position that can be
used for reporting error messages.
It's primarily used to distinguish references to named objects,
whose Pos will point back to their declaration position rather than
their usage position.</p>
               
               <pre><code>func HasUniquePos(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="Implicit">
               <h3>
                  Implicit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ParenExpr) Implicit() bool</code></pre>
            </article>
            
            <article class="function" data-name="Implicit">
               <h3>
                  Implicit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddrExpr) Implicit() bool</code></pre>
            </article>
            
            <article class="function" data-name="Implicit">
               <h3>
                  Implicit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StarExpr) Implicit() bool</code></pre>
            </article>
            
            <article class="function" data-name="Implicit">
               <h3>
                  Implicit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CompLitExpr) Implicit() bool</code></pre>
            </article>
            
            <article class="function" data-name="Implicit">
               <h3>
                  Implicit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectorExpr) Implicit() bool</code></pre>
            </article>
            
            <article class="function" data-name="Implicit">
               <h3>
                  Implicit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ConvExpr) Implicit() bool</code></pre>
            </article>
            
            <article class="function" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) Init() Nodes</code></pre>
            </article>
            
            <article class="function" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniExpr) Init() Nodes</code></pre>
            </article>
            
            <article class="function" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Init initializes the oracle based on the IR in function fn, laying
the groundwork for future calls to the StaticValue and Reassigned
methods. If the fn's IR is subsequently modified, Init must be
called again.</p>
               
               <pre><code>func (ro *ReassignOracle) Init(fn *Func)</code></pre>
            </article>
            
            <article class="function" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniStmt) Init() Nodes</code></pre>
            </article>
            
            <article class="function" data-name="InitExpr">
               <h3>
                  InitExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>The result of InitExpr MUST be assigned back to n, e.g.
n.X = InitExpr(init, n.X)</p>
               
               <pre><code>func InitExpr(init []Node, expr Node) Node</code></pre>
            </article>
            
            <article class="function" data-name="InitLSym">
               <h3>
                  InitLSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>InitLSym defines f's obj.LSym and initializes it based on the
properties of f. This includes setting the symbol flags and ABI and
creating and initializing related DWARF symbols.
InitLSym must be called exactly once per function and must be
called for both functions with bodies and functions without bodies.
For body-less functions, we only create the LSym; for functions
with bodies call a helper to setup up / populate the LSym.</p>
               
               <pre><code>func InitLSym(f *Func, hasBody bool)</code></pre>
            </article>
            
            <article class="function" data-name="InlFormal">
               <h3>
                  InlFormal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) InlFormal() bool</code></pre>
            </article>
            
            <article class="function" data-name="InlLocal">
               <h3>
                  InlLocal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) InlLocal() bool</code></pre>
            </article>
            
            <article class="function" data-name="InlinabilityChecked">
               <h3>
                  InlinabilityChecked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) InlinabilityChecked() bool</code></pre>
            </article>
            
            <article class="function" data-name="Int64Val">
               <h3>
                  Int64Val 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Int64Val returns n as an int64.
n must be an integer or rune constant.</p>
               
               <pre><code>func Int64Val(n Node) int64</code></pre>
            </article>
            
            <article class="function" data-name="IntVal">
               <h3>
                  IntVal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IntVal returns v converted to int64.
Note: if t is uint64, very large values will be converted to negative int64.</p>
               
               <pre><code>func IntVal(t *types.Type, v constant.Value) int64</code></pre>
            </article>
            
            <article class="function" data-name="IsAddressable">
               <h3>
                  IsAddressable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lvalue etc</p>
               
               <pre><code>func IsAddressable(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsAutoTmp">
               <h3>
                  IsAutoTmp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsAutoTmp indicates if n was created by the compiler as a temporary,
based on the setting of the .AutoTemp flag in n's Name.</p>
               
               <pre><code>func IsAutoTmp(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsBlank">
               <h3>
                  IsBlank 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func IsBlank(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsClosure">
               <h3>
                  IsClosure 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsClosure reports whether f is a function literal that captures at least one value.</p>
               
               <pre><code>func (f *Func) IsClosure() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsClosureVar">
               <h3>
                  IsClosureVar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) IsClosureVar() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsCmp">
               <h3>
                  IsCmp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsCmp reports whether op is a comparison operation (==, !=, <, <=,
>, or >=).</p>
               
               <pre><code>func (op Op) IsCmp() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsConst">
               <h3>
                  IsConst 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func IsConst(n Node, ct constant.Kind) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsConstNode">
               <h3>
                  IsConstNode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsConstNode reports whether n is a Go language constant (as opposed to a
compile-time constant).
Expressions derived from nil, like string([]byte(nil)), while they
may be known at compile time, are not Go language constants.</p>
               
               <pre><code>func IsConstNode(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsFuncPCIntrinsic">
               <h3>
                  IsFuncPCIntrinsic 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsFuncPCIntrinsic returns whether n is a direct call of internal/abi.FuncPCABIxxx functions.</p>
               
               <pre><code>func IsFuncPCIntrinsic(n *CallExpr) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsIfaceOfFunc">
               <h3>
                  IsIfaceOfFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsIfaceOfFunc inspects whether n is an interface conversion from a direct
reference of a func. If so, it returns referenced Func; otherwise nil.
This is only usable before walk.walkConvertInterface, which converts to an
OMAKEFACE.</p>
               
               <pre><code>func IsIfaceOfFunc(n Node) *Func</code></pre>
            </article>
            
            <article class="function" data-name="IsMethod">
               <h3>
                  IsMethod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsMethod reports whether n is a method.
n must be a function or a method.</p>
               
               <pre><code>func IsMethod(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsNil">
               <h3>
                  IsNil 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsNil reports whether n represents the universal untyped zero value "nil".</p>
               
               <pre><code>func IsNil(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsOutputParamHeapAddr">
               <h3>
                  IsOutputParamHeapAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) IsOutputParamHeapAddr() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsOutputParamInRegisters">
               <h3>
                  IsOutputParamInRegisters 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) IsOutputParamInRegisters() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPackageInit">
               <h3>
                  IsPackageInit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) IsPackageInit() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsReflectHeaderDataField">
               <h3>
                  IsReflectHeaderDataField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsReflectHeaderDataField reports whether l is an expression p.Data
where p has type reflect.SliceHeader or reflect.StringHeader.</p>
               
               <pre><code>func IsReflectHeaderDataField(l Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsSlice3">
               <h3>
                  IsSlice3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsSlice3 reports whether o is a slice3 op (OSLICE3, OSLICE3ARR).
o must be a slicing op.</p>
               
               <pre><code>func (o Op) IsSlice3() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsSmallIntConst">
               <h3>
                  IsSmallIntConst 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func IsSmallIntConst(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsSynthetic">
               <h3>
                  IsSynthetic 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func IsSynthetic(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsZero">
               <h3>
                  IsZero 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func IsZero(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="Libfuzzer8BitCounter">
               <h3>
                  Libfuzzer8BitCounter 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) Libfuzzer8BitCounter() bool</code></pre>
            </article>
            
            <article class="function" data-name="Line">
               <h3>
                  Line 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Line returns n's position as a string. If n has been inlined,
it uses the outermost position where n has been inlined.</p>
               
               <pre><code>func Line(n Node) string</code></pre>
            </article>
            
            <article class="function" data-name="LinkFuncName">
               <h3>
                  LinkFuncName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LinkFuncName returns the name of the function f, as it will appear in the
symbol table of the final linked binary.</p>
               
               <pre><code>func LinkFuncName(f *Func) string</code></pre>
            </article>
            
            <article class="function" data-name="Linksym">
               <h3>
                  Linksym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) Linksym() *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="Linksym">
               <h3>
                  Linksym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) Linksym() *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="LinksymABI">
               <h3>
                  LinksymABI 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) LinksymABI(abi obj.ABI) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="LinksymABI">
               <h3>
                  LinksymABI 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) LinksymABI(abi obj.ABI) *obj.LSym</code></pre>
            </article>
            
            <article class="function" data-name="LookupMethodSelector">
               <h3>
                  LookupMethodSelector 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LookupMethodSelector returns the types.Sym of the selector for a method
named in local symbol name, as well as the types.Sym of the receiver.
TODO(prattmic): this does not attempt to handle method suffixes (wrappers).</p>
               
               <pre><code>func LookupMethodSelector(pkg *types.Pkg, name string) (typ *types.Sym, meth *types.Sym, err error)</code></pre>
            </article>
            
            <article class="function" data-name="MarkNonNil">
               <h3>
                  MarkNonNil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniExpr) MarkNonNil()</code></pre>
            </article>
            
            <article class="function" data-name="MarkNonNil">
               <h3>
                  MarkNonNil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) MarkNonNil()</code></pre>
            </article>
            
            <article class="function" data-name="MarkReadonly">
               <h3>
                  MarkReadonly 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarkReadonly indicates that n is an ONAME with readonly contents.</p>
               
               <pre><code>func (n *Name) MarkReadonly()</code></pre>
            </article>
            
            <article class="function" data-name="MayBeShared">
               <h3>
                  MayBeShared 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MayBeShared reports whether n may occur in multiple places in the AST.
Extra care must be taken when mutating such a node.</p>
               
               <pre><code>func MayBeShared(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="MethodExprFunc">
               <h3>
                  MethodExprFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MethodExprFunc is like MethodExprName, but returns the types.Field instead.</p>
               
               <pre><code>func MethodExprFunc(n Node) *types.Field</code></pre>
            </article>
            
            <article class="function" data-name="MethodExprName">
               <h3>
                  MethodExprName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MethodExprName returns the ONAME representing the method
referenced by expression n, which must be a method selector,
method expression, or method value.</p>
               
               <pre><code>func MethodExprName(n Node) *Name</code></pre>
            </article>
            
            <article class="function" data-name="MethodSym">
               <h3>
                  MethodSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MethodSym returns the method symbol representing a method name
associated with a specific receiver type.
Method symbols can be used to distinguish the same method appearing
in different method sets. For example, T.M and (*T).M have distinct
method symbols.
The returned symbol will be marked as a function.</p>
               
               <pre><code>func MethodSym(recv *types.Type, msym *types.Sym) *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="MethodSymSuffix">
               <h3>
                  MethodSymSuffix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MethodSymSuffix is like MethodSym, but allows attaching a
distinguisher suffix. To avoid collisions, the suffix must not
start with a letter, number, or period.</p>
               
               <pre><code>func MethodSymSuffix(recv *types.Type, msym *types.Sym, suffix string) *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) Name() *Name</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) Name() *Name</code></pre>
            </article>
            
            <article class="function" data-name="Needctxt">
               <h3>
                  Needctxt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) Needctxt() bool</code></pre>
            </article>
            
            <article class="function" data-name="Needzero">
               <h3>
                  Needzero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) Needzero() bool</code></pre>
            </article>
            
            <article class="function" data-name="NeverReturns">
               <h3>
                  NeverReturns 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) NeverReturns() bool</code></pre>
            </article>
            
            <article class="function" data-name="NewAddStringExpr">
               <h3>
                  NewAddStringExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewAddStringExpr(pos src.XPos, list []Node) *AddStringExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewAddrExpr">
               <h3>
                  NewAddrExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewAddrExpr(pos src.XPos, x Node) *AddrExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewAssignListStmt">
               <h3>
                  NewAssignListStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewAssignListStmt(pos src.XPos, op Op, lhs []Node, rhs []Node) *AssignListStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewAssignOpStmt">
               <h3>
                  NewAssignOpStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewAssignOpStmt(pos src.XPos, asOp Op, x Node, y Node) *AssignOpStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewAssignStmt">
               <h3>
                  NewAssignStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewAssignStmt(pos src.XPos, x Node, y Node) *AssignStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewBasicLit">
               <h3>
                  NewBasicLit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewBasicLit returns an OLITERAL representing val with the given type.</p>
               
               <pre><code>func NewBasicLit(pos src.XPos, typ *types.Type, val constant.Value) Node</code></pre>
            </article>
            
            <article class="function" data-name="NewBinaryExpr">
               <h3>
                  NewBinaryExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewBinaryExpr(pos src.XPos, op Op, x Node, y Node) *BinaryExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewBlockStmt">
               <h3>
                  NewBlockStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewBlockStmt(pos src.XPos, list []Node) *BlockStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewBool">
               <h3>
                  NewBool 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewBool returns an OLITERAL representing b as an untyped boolean.</p>
               
               <pre><code>func NewBool(pos src.XPos, b bool) Node</code></pre>
            </article>
            
            <article class="function" data-name="NewBranchStmt">
               <h3>
                  NewBranchStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewBranchStmt(pos src.XPos, op Op, label *types.Sym) *BranchStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewBuiltin">
               <h3>
                  NewBuiltin 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewBuiltin returns a new Name representing a builtin function,
either predeclared or from package unsafe.</p>
               
               <pre><code>func NewBuiltin(sym *types.Sym, op Op) *Name</code></pre>
            </article>
            
            <article class="function" data-name="NewCallExpr">
               <h3>
                  NewCallExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewCallExpr(pos src.XPos, op Op, fun Node, args []Node) *CallExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewCaseStmt">
               <h3>
                  NewCaseStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewCaseStmt(pos src.XPos, list []Node, body []Node) *CaseClause</code></pre>
            </article>
            
            <article class="function" data-name="NewClosureFunc">
               <h3>
                  NewClosureFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewClosureFunc creates a new Func to represent a function literal
with the given type.
fpos the position used for the underlying ODCLFUNC and ONAME,
whereas cpos is the position used for the OCLOSURE. They're
separate because in the presence of inlining, the OCLOSURE node
should have an inline-adjusted position, whereas the ODCLFUNC and
ONAME must not.
outerfn is the enclosing function. The returned function is
appending to pkg.Funcs.
why is the reason we're generating this Func. It can be OCLOSURE
(for a normal function literal) or OGO or ODEFER (for wrapping a
call expression that has parameters or results).</p>
               
               <pre><code>func NewClosureFunc(fpos src.XPos, cpos src.XPos, why Op, typ *types.Type, outerfn *Func, pkg *Package) *Func</code></pre>
            </article>
            
            <article class="function" data-name="NewClosureVar">
               <h3>
                  NewClosureVar 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewClosureVar returns a new closure variable for fn to refer to
outer variable n.</p>
               
               <pre><code>func NewClosureVar(pos src.XPos, fn *Func, n *Name) *Name</code></pre>
            </article>
            
            <article class="function" data-name="NewCommStmt">
               <h3>
                  NewCommStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewCommStmt(pos src.XPos, comm Node, body []Node) *CommClause</code></pre>
            </article>
            
            <article class="function" data-name="NewCompLitExpr">
               <h3>
                  NewCompLitExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewCompLitExpr(pos src.XPos, op Op, typ *types.Type, list []Node) *CompLitExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewConstAt">
               <h3>
                  NewConstAt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewConstAt returns a new OLITERAL Node associated with symbol s at position pos.</p>
               
               <pre><code>func NewConstAt(pos src.XPos, sym *types.Sym, typ *types.Type, val constant.Value) *Name</code></pre>
            </article>
            
            <article class="function" data-name="NewConstExpr">
               <h3>
                  NewConstExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewConstExpr returns an OLITERAL representing val, copying the
position and type from orig.</p>
               
               <pre><code>func NewConstExpr(val constant.Value, orig Node) Node</code></pre>
            </article>
            
            <article class="function" data-name="NewConvExpr">
               <h3>
                  NewConvExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewConvExpr(pos src.XPos, op Op, typ *types.Type, x Node) *ConvExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewDecl">
               <h3>
                  NewDecl 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewDecl(pos src.XPos, op Op, x *Name) *Decl</code></pre>
            </article>
            
            <article class="function" data-name="NewDeclNameAt">
               <h3>
                  NewDeclNameAt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewDeclNameAt returns a new Name associated with symbol s at position pos.
The caller is responsible for setting Curfn.</p>
               
               <pre><code>func NewDeclNameAt(pos src.XPos, op Op, sym *types.Sym) *Name</code></pre>
            </article>
            
            <article class="function" data-name="NewDynamicType">
               <h3>
                  NewDynamicType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewDynamicType(pos src.XPos, rtype Node) *DynamicType</code></pre>
            </article>
            
            <article class="function" data-name="NewDynamicTypeAssertExpr">
               <h3>
                  NewDynamicTypeAssertExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewDynamicTypeAssertExpr(pos src.XPos, op Op, x Node, rtype Node) *DynamicTypeAssertExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewForStmt">
               <h3>
                  NewForStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewForStmt(pos src.XPos, init Node, cond Node, post Node, body []Node, distinctVars bool) *ForStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewFunc">
               <h3>
                  NewFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewFunc returns a new Func with the given name and type.
fpos is the position of the "func" token, and npos is the position
of the name identifier.
TODO(mdempsky): I suspect there's no need for separate fpos and
npos.</p>
               
               <pre><code>func NewFunc(fpos src.XPos, npos src.XPos, sym *types.Sym, typ *types.Type) *Func</code></pre>
            </article>
            
            <article class="function" data-name="NewGoDeferStmt">
               <h3>
                  NewGoDeferStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewGoDeferStmt(pos src.XPos, op Op, call Node) *GoDeferStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewHiddenParam">
               <h3>
                  NewHiddenParam 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewHiddenParam returns a new hidden parameter for fn with the given
name and type.</p>
               
               <pre><code>func NewHiddenParam(pos src.XPos, fn *Func, sym *types.Sym, typ *types.Type) *Name</code></pre>
            </article>
            
            <article class="function" data-name="NewIdent">
               <h3>
                  NewIdent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewIdent(pos src.XPos, sym *types.Sym) *Ident</code></pre>
            </article>
            
            <article class="function" data-name="NewIfStmt">
               <h3>
                  NewIfStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewIfStmt(pos src.XPos, cond Node, body []Node, els []Node) *IfStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewIndexExpr">
               <h3>
                  NewIndexExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewIndexExpr(pos src.XPos, x Node, index Node) *IndexExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewInlineMarkStmt">
               <h3>
                  NewInlineMarkStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewInlineMarkStmt(pos src.XPos, index int64) *InlineMarkStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewInlinedCallExpr">
               <h3>
                  NewInlinedCallExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewInlinedCallExpr(pos src.XPos, body []Node, retvars []Node) *InlinedCallExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewInt">
               <h3>
                  NewInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewInt returns an OLITERAL representing v as an untyped integer.</p>
               
               <pre><code>func NewInt(pos src.XPos, v int64) Node</code></pre>
            </article>
            
            <article class="function" data-name="NewInterfaceSwitchStmt">
               <h3>
                  NewInterfaceSwitchStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewInterfaceSwitchStmt(pos src.XPos, case_ Node, itab Node, runtimeType Node, hash Node, descriptor *obj.LSym) *InterfaceSwitchStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewJumpTableStmt">
               <h3>
                  NewJumpTableStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewJumpTableStmt(pos src.XPos, idx Node) *JumpTableStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewKeyExpr">
               <h3>
                  NewKeyExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewKeyExpr(pos src.XPos, key Node, value Node) *KeyExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewLabelStmt">
               <h3>
                  NewLabelStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewLabelStmt(pos src.XPos, label *types.Sym) *LabelStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewLinksymExpr">
               <h3>
                  NewLinksymExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewLinksymExpr is NewLinksymOffsetExpr, but with offset fixed at 0.</p>
               
               <pre><code>func NewLinksymExpr(pos src.XPos, lsym *obj.LSym, typ *types.Type) *LinksymOffsetExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewLinksymOffsetExpr">
               <h3>
                  NewLinksymOffsetExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewLinksymOffsetExpr(pos src.XPos, lsym *obj.LSym, offset int64, typ *types.Type) *LinksymOffsetExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewLocal">
               <h3>
                  NewLocal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NewLocal returns a new function-local variable with the given name and type.</p>
               
               <pre><code>func (fn *Func) NewLocal(pos src.XPos, sym *types.Sym, typ *types.Type) *Name</code></pre>
            </article>
            
            <article class="function" data-name="NewLogicalExpr">
               <h3>
                  NewLogicalExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewLogicalExpr(pos src.XPos, op Op, x Node, y Node) *LogicalExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewMakeExpr">
               <h3>
                  NewMakeExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewMakeExpr(pos src.XPos, op Op, len Node, cap Node) *MakeExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewNameAt">
               <h3>
                  NewNameAt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewNameAt returns a new ONAME Node associated with symbol s at position pos.
The caller is responsible for setting Curfn.</p>
               
               <pre><code>func NewNameAt(pos src.XPos, sym *types.Sym, typ *types.Type) *Name</code></pre>
            </article>
            
            <article class="function" data-name="NewNameOffsetExpr">
               <h3>
                  NewNameOffsetExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewNameOffsetExpr is NewLinksymOffsetExpr, but taking a *Name
representing a global variable instead of an *obj.LSym directly.</p>
               
               <pre><code>func NewNameOffsetExpr(pos src.XPos, name *Name, offset int64, typ *types.Type) *LinksymOffsetExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewNilExpr">
               <h3>
                  NewNilExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewNilExpr(pos src.XPos, typ *types.Type) *NilExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewOne">
               <h3>
                  NewOne 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewOne returns an OLITERAL representing 1 with the given type.</p>
               
               <pre><code>func NewOne(pos src.XPos, typ *types.Type) Node</code></pre>
            </article>
            
            <article class="function" data-name="NewParenExpr">
               <h3>
                  NewParenExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewParenExpr(pos src.XPos, x Node) *ParenExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewRangeStmt">
               <h3>
                  NewRangeStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewRangeStmt(pos src.XPos, key Node, value Node, x Node, body []Node, distinctVars bool) *RangeStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewResultExpr">
               <h3>
                  NewResultExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewResultExpr(pos src.XPos, typ *types.Type, index int64) *ResultExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewReturnStmt">
               <h3>
                  NewReturnStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewReturnStmt(pos src.XPos, results []Node) *ReturnStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewSelectStmt">
               <h3>
                  NewSelectStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewSelectStmt(pos src.XPos, cases []*CommClause) *SelectStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewSelectorExpr">
               <h3>
                  NewSelectorExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewSelectorExpr(pos src.XPos, op Op, x Node, sel *types.Sym) *SelectorExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewSendStmt">
               <h3>
                  NewSendStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewSendStmt(pos src.XPos, ch Node, value Node) *SendStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewSliceExpr">
               <h3>
                  NewSliceExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewSliceExpr(pos src.XPos, op Op, x Node, low Node, high Node, max Node) *SliceExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewSliceHeaderExpr">
               <h3>
                  NewSliceHeaderExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewSliceHeaderExpr(pos src.XPos, typ *types.Type, ptr Node, len Node, cap Node) *SliceHeaderExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewStarExpr">
               <h3>
                  NewStarExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewStarExpr(pos src.XPos, x Node) *StarExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewString">
               <h3>
                  NewString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewString returns an OLITERAL representing s as an untyped string.</p>
               
               <pre><code>func NewString(pos src.XPos, s string) Node</code></pre>
            </article>
            
            <article class="function" data-name="NewStringHeaderExpr">
               <h3>
                  NewStringHeaderExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewStringHeaderExpr(pos src.XPos, ptr Node, len Node) *StringHeaderExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewStructKeyExpr">
               <h3>
                  NewStructKeyExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewStructKeyExpr(pos src.XPos, field *types.Field, value Node) *StructKeyExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewSwitchStmt">
               <h3>
                  NewSwitchStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewSwitchStmt(pos src.XPos, tag Node, cases []*CaseClause) *SwitchStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewTailCallStmt">
               <h3>
                  NewTailCallStmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewTailCallStmt(pos src.XPos, call *CallExpr) *TailCallStmt</code></pre>
            </article>
            
            <article class="function" data-name="NewTypeAssertExpr">
               <h3>
                  NewTypeAssertExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewTypeAssertExpr(pos src.XPos, x Node, typ *types.Type) *TypeAssertExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewTypeSwitchGuard">
               <h3>
                  NewTypeSwitchGuard 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewTypeSwitchGuard(pos src.XPos, tag *Ident, x Node) *TypeSwitchGuard</code></pre>
            </article>
            
            <article class="function" data-name="NewUintptr">
               <h3>
                  NewUintptr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewUintptr returns an OLITERAL representing v as a uintptr.</p>
               
               <pre><code>func NewUintptr(pos src.XPos, v int64) Node</code></pre>
            </article>
            
            <article class="function" data-name="NewUnaryExpr">
               <h3>
                  NewUnaryExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewUnaryExpr(pos src.XPos, op Op, x Node) *UnaryExpr</code></pre>
            </article>
            
            <article class="function" data-name="NewZero">
               <h3>
                  NewZero 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewZero returns a zero value of the given type.</p>
               
               <pre><code>func NewZero(pos src.XPos, typ *types.Type) Node</code></pre>
            </article>
            
            <article class="function" data-name="NilCheckDisabled">
               <h3>
                  NilCheckDisabled 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) NilCheckDisabled() bool</code></pre>
            </article>
            
            <article class="function" data-name="NonMergeable">
               <h3>
                  NonMergeable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) NonMergeable() bool</code></pre>
            </article>
            
            <article class="function" data-name="NonNil">
               <h3>
                  NonNil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) NonNil() bool</code></pre>
            </article>
            
            <article class="function" data-name="NonNil">
               <h3>
                  NonNil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniExpr) NonNil() bool</code></pre>
            </article>
            
            <article class="function" data-name="Offset">
               <h3>
                  Offset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlineMarkStmt) Offset() int64</code></pre>
            </article>
            
            <article class="function" data-name="Offset">
               <h3>
                  Offset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectorExpr) Offset() int64</code></pre>
            </article>
            
            <article class="function" data-name="OnStack">
               <h3>
                  OnStack 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>OnStack reports whether variable n may reside on the stack.</p>
               
               <pre><code>func (n *Name) OnStack() bool</code></pre>
            </article>
            
            <article class="function" data-name="Op">
               <h3>
                  Op 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>op can be read, but not written.
An embedding implementation can provide a SetOp if desired.
(The panicking SetOp is with the other panics below.)</p>
               
               <pre><code>func (n *miniNode) Op() Op</code></pre>
            </article>
            
            <article class="function" data-name="OpenCodedDeferDisallowed">
               <h3>
                  OpenCodedDeferDisallowed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) OpenCodedDeferDisallowed() bool</code></pre>
            </article>
            
            <article class="function" data-name="OpenDeferSlot">
               <h3>
                  OpenDeferSlot 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) OpenDeferSlot() bool</code></pre>
            </article>
            
            <article class="function" data-name="OuterValue">
               <h3>
                  OuterValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>what's the outer value that a write to n affects?
outer value means containing struct or array.</p>
               
               <pre><code>func OuterValue(n Node) Node</code></pre>
            </article>
            
            <article class="function" data-name="ParamNames">
               <h3>
                  ParamNames 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ParamNames(ft *types.Type) []Node</code></pre>
            </article>
            
            <article class="function" data-name="ParseLinkFuncName">
               <h3>
                  ParseLinkFuncName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseLinkFuncName parsers a symbol name (as returned from LinkFuncName) back
to the package path and local symbol name.</p>
               
               <pre><code>func ParseLinkFuncName(name string) (pkg string, sym string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="PkgFuncName">
               <h3>
                  PkgFuncName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PkgFuncName returns the name of the function referenced by f, with package
prepended.
This differs from the compiler's internal convention where local functions
lack a package. This is primarily useful when the ultimate consumer of this
is a human looking at message.</p>
               
               <pre><code>func PkgFuncName(f *Func) string</code></pre>
            </article>
            
            <article class="function" data-name="PopLeft">
               <h3>
                  PopLeft 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PopLeft pops a Name from the left of the queue. It panics if q is
empty.</p>
               
               <pre><code>func (q *NameQueue) PopLeft() *Name</code></pre>
            </article>
            
            <article class="function" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) Pos() src.XPos</code></pre>
            </article>
            
            <article class="function" data-name="Pragma">
               <h3>
                  Pragma 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pragma returns the PragmaFlag for p, which must be for an OTYPE.</p>
               
               <pre><code>func (n *Name) Pragma() PragmaFlag</code></pre>
            </article>
            
            <article class="function" data-name="Prepend">
               <h3>
                  Prepend 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Prepend prepends entries to Nodes.
If a slice is passed in, this will take ownership of it.</p>
               
               <pre><code>func (n *Nodes) Prepend(a ...Node)</code></pre>
            </article>
            
            <article class="function" data-name="PtrInit">
               <h3>
                  PtrInit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniExpr) PtrInit() *Nodes</code></pre>
            </article>
            
            <article class="function" data-name="PtrInit">
               <h3>
                  PtrInit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniStmt) PtrInit() *Nodes</code></pre>
            </article>
            
            <article class="function" data-name="PushRight">
               <h3>
                  PushRight 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PushRight appends n to the right of the queue.</p>
               
               <pre><code>func (q *NameQueue) PushRight(n *Name)</code></pre>
            </article>
            
            <article class="function" data-name="Readonly">
               <h3>
                  Readonly 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) Readonly() bool</code></pre>
            </article>
            
            <article class="function" data-name="Reassigned">
               <h3>
                  Reassigned 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reassigned method has the same semantics as the ir package function
of the same name; see comments on [Reassigned] for more info.</p>
               
               <pre><code>func (ro *ReassignOracle) Reassigned(n *Name) bool</code></pre>
            </article>
            
            <article class="function" data-name="Reassigned">
               <h3>
                  Reassigned 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Reassigned takes an ONAME node, walks the function in which it is
defined, and returns a boolean indicating whether the name has any
assignments other than its declaration.
NB: global variables are always considered to be re-assigned.
TODO: handle initial declaration not including an assignment and
followed by a single assignment?
NOTE: any changes made here should also be made in the corresponding
code in the ReassignOracle.Init method.</p>
               
               <pre><code>func Reassigned(name *Name) bool</code></pre>
            </article>
            
            <article class="function" data-name="RecordFrameOffset">
               <h3>
                  RecordFrameOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RecordFrameOffset records the frame offset for the name.
It is used by package types when laying out function arguments.</p>
               
               <pre><code>func (n *Name) RecordFrameOffset(offset int64)</code></pre>
            </article>
            
            <article class="function" data-name="SameSafeExpr">
               <h3>
                  SameSafeExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SameSafeExpr checks whether it is safe to reuse one of l and r
instead of computing both. SameSafeExpr assumes that l and r are
used in the same statement or expression. In order for it to be
safe to reuse l or r, they must:
- be the same expression
- not have side-effects (no function calls, no channel ops);
however, panics are ok
- not cause inappropriate aliasing; e.g. two string to []byte
conversions, must result in two distinct slices
The handling of OINDEXMAP is subtle. OINDEXMAP can occur both
as an lvalue (map assignment) and an rvalue (map access). This is
currently OK, since the only place SameSafeExpr gets used on an
lvalue expression is for OSLICE and OAPPEND optimizations, and it
is correct in those settings.</p>
               
               <pre><code>func SameSafeExpr(l Node, r Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="SameSource">
               <h3>
                  SameSource 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SameSource reports whether two nodes refer to the same source
element.
It exists to help incrementally migrate the compiler towards
allowing the introduction of IdentExpr (#42990). Once we have
IdentExpr, it will no longer be safe to directly compare Node
values to tell if they refer to the same Name. Instead, code will
need to explicitly get references to the underlying Name object(s),
and compare those instead.
It will still be safe to compare Nodes directly for checking if two
nodes are syntactically the same. The SameSource function exists to
indicate code that intentionally compares Nodes for syntactic
equality as opposed to code that has yet to be updated in
preparation for IdentExpr.</p>
               
               <pre><code>func SameSource(n1 Node, n2 Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="SetABIWrapper">
               <h3>
                  SetABIWrapper 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) SetABIWrapper(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAddrtaken">
               <h3>
                  SetAddrtaken 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetAddrtaken(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAlias">
               <h3>
                  SetAlias 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetAlias sets whether p, which must be for an OTYPE, is a type alias.</p>
               
               <pre><code>func (n *Name) SetAlias(alias bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetAutoTemp">
               <h3>
                  SetAutoTemp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetAutoTemp(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetBounded">
               <h3>
                  SetBounded 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniExpr) SetBounded(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetByval">
               <h3>
                  SetByval 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetByval(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetCheckPtr">
               <h3>
                  SetCheckPtr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ConvExpr) SetCheckPtr(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetClosureResultsLost">
               <h3>
                  SetClosureResultsLost 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) SetClosureResultsLost(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetCoverageAuxVar">
               <h3>
                  SetCoverageAuxVar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetCoverageAuxVar(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetDupok">
               <h3>
                  SetDupok 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) SetDupok(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetEsc">
               <h3>
                  SetEsc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) SetEsc(x uint16)</code></pre>
            </article>
            
            <article class="function" data-name="SetFrameOffset">
               <h3>
                  SetFrameOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetFrameOffset(x int64)</code></pre>
            </article>
            
            <article class="function" data-name="SetFunc">
               <h3>
                  SetFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetFunc(x *Func)</code></pre>
            </article>
            
            <article class="function" data-name="SetHasDefer">
               <h3>
                  SetHasDefer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) SetHasDefer(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetImplicit">
               <h3>
                  SetImplicit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CompLitExpr) SetImplicit(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetImplicit">
               <h3>
                  SetImplicit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectorExpr) SetImplicit(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetImplicit">
               <h3>
                  SetImplicit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StarExpr) SetImplicit(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetImplicit">
               <h3>
                  SetImplicit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ConvExpr) SetImplicit(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetImplicit">
               <h3>
                  SetImplicit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ParenExpr) SetImplicit(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetImplicit">
               <h3>
                  SetImplicit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddrExpr) SetImplicit(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetInit">
               <h3>
                  SetInit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniExpr) SetInit(x Nodes)</code></pre>
            </article>
            
            <article class="function" data-name="SetInit">
               <h3>
                  SetInit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniStmt) SetInit(x Nodes)</code></pre>
            </article>
            
            <article class="function" data-name="SetInlFormal">
               <h3>
                  SetInlFormal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetInlFormal(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetInlLocal">
               <h3>
                  SetInlLocal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetInlLocal(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetInlinabilityChecked">
               <h3>
                  SetInlinabilityChecked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) SetInlinabilityChecked(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetIsClosureVar">
               <h3>
                  SetIsClosureVar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetIsClosureVar(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetIsOutputParamHeapAddr">
               <h3>
                  SetIsOutputParamHeapAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetIsOutputParamHeapAddr(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetIsOutputParamInRegisters">
               <h3>
                  SetIsOutputParamInRegisters 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetIsOutputParamInRegisters(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetIsPackageInit">
               <h3>
                  SetIsPackageInit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) SetIsPackageInit(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetLibfuzzer8BitCounter">
               <h3>
                  SetLibfuzzer8BitCounter 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetLibfuzzer8BitCounter(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetNeedctxt">
               <h3>
                  SetNeedctxt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) SetNeedctxt(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetNeedzero">
               <h3>
                  SetNeedzero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetNeedzero(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetNeverReturns">
               <h3>
                  SetNeverReturns 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) SetNeverReturns(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetNilCheckDisabled">
               <h3>
                  SetNilCheckDisabled 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) SetNilCheckDisabled(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetNonMergeable">
               <h3>
                  SetNonMergeable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetNonMergeable(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetOffset">
               <h3>
                  SetOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlineMarkStmt) SetOffset(x int64)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CompLitExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddrExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CallExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BranchStmt) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *UnaryExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *MakeExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicTypeAssertExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ConvExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IndexExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignListStmt) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeAssertExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LogicalExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectorExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignStmt) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOp">
               <h3>
                  SetOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BinaryExpr) SetOp(op Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetOpenCodedDeferDisallowed">
               <h3>
                  SetOpenCodedDeferDisallowed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) SetOpenCodedDeferDisallowed(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetOpenDeferSlot">
               <h3>
                  SetOpenDeferSlot 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetOpenDeferSlot(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetPos">
               <h3>
                  SetPos 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func SetPos(n Node) src.XPos</code></pre>
            </article>
            
            <article class="function" data-name="SetPos">
               <h3>
                  SetPos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) SetPos(x src.XPos)</code></pre>
            </article>
            
            <article class="function" data-name="SetPragma">
               <h3>
                  SetPragma 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetPragma sets the PragmaFlag for p, which must be for an OTYPE.</p>
               
               <pre><code>func (n *Name) SetPragma(flag PragmaFlag)</code></pre>
            </article>
            
            <article class="function" data-name="SetSubOp">
               <h3>
                  SetSubOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetSubOp(x Op)</code></pre>
            </article>
            
            <article class="function" data-name="SetSym">
               <h3>
                  SetSym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetSym(x *types.Sym)</code></pre>
            </article>
            
            <article class="function" data-name="SetTransient">
               <h3>
                  SetTransient 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniExpr) SetTransient(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetType">
               <h3>
                  SetType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniExpr) SetType(x *types.Type)</code></pre>
            </article>
            
            <article class="function" data-name="SetType">
               <h3>
                  SetType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) SetType(*types.Type)</code></pre>
            </article>
            
            <article class="function" data-name="SetTypecheck">
               <h3>
                  SetTypecheck 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) SetTypecheck(x uint8)</code></pre>
            </article>
            
            <article class="function" data-name="SetUsed">
               <h3>
                  SetUsed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SetUsed(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetVal">
               <h3>
                  SetVal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) SetVal(v constant.Value)</code></pre>
            </article>
            
            <article class="function" data-name="SetVal">
               <h3>
                  SetVal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BasicLit) SetVal(val constant.Value)</code></pre>
            </article>
            
            <article class="function" data-name="SetVal">
               <h3>
                  SetVal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetVal sets the constant.Value for the node.</p>
               
               <pre><code>func (n *Name) SetVal(v constant.Value)</code></pre>
            </article>
            
            <article class="function" data-name="SetWBPos">
               <h3>
                  SetWBPos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) SetWBPos(pos src.XPos)</code></pre>
            </article>
            
            <article class="function" data-name="SetWalked">
               <h3>
                  SetWalked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) SetWalked(x bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetWrapper">
               <h3>
                  SetWrapper 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) SetWrapper(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="ShouldAsanCheckPtr">
               <h3>
                  ShouldAsanCheckPtr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ShouldAsanCheckPtr reports whether pointer checking should be enabled for
function fn when -asan is enabled.</p>
               
               <pre><code>func ShouldAsanCheckPtr(fn *Func) bool</code></pre>
            </article>
            
            <article class="function" data-name="ShouldCheckPtr">
               <h3>
                  ShouldCheckPtr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ShouldCheckPtr reports whether pointer checking should be enabled for
function fn at a given level. See debugHelpFooter for defined
levels.</p>
               
               <pre><code>func ShouldCheckPtr(fn *Func, level int) bool</code></pre>
            </article>
            
            <article class="function" data-name="SingleResult">
               <h3>
                  SingleResult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlinedCallExpr) SingleResult() Node</code></pre>
            </article>
            
            <article class="function" data-name="StaticCalleeName">
               <h3>
                  StaticCalleeName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>StaticCalleeName returns the ONAME/PFUNC for n, if known.</p>
               
               <pre><code>func StaticCalleeName(n Node) *Name</code></pre>
            </article>
            
            <article class="function" data-name="StaticValue">
               <h3>
                  StaticValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>StaticValue analyzes n to find the earliest expression that always
evaluates to the same value as n, which might be from an enclosing
function.
For example, given:
var x int = g()
func() {
y := x
*p = int(y)
}
calling StaticValue on the "int(y)" expression returns the outer
"g()" expression.</p>
               
               <pre><code>func StaticValue(n Node) Node</code></pre>
            </article>
            
            <article class="function" data-name="StaticValue">
               <h3>
                  StaticValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>StaticValue method has the same semantics as the ir package function
of the same name; see comments on [StaticValue].</p>
               
               <pre><code>func (ro *ReassignOracle) StaticValue(n Node) Node</code></pre>
            </article>
            
            <article class="function" data-name="StmtWithInit">
               <h3>
                  StmtWithInit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>StmtWithInit reports whether op is a statement with an explicit init list.</p>
               
               <pre><code>func StmtWithInit(op Op) bool</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i Class) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i Op) String() string</code></pre>
            </article>
            
            <article class="function" data-name="StringVal">
               <h3>
                  StringVal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>StringVal returns the value of a literal string Node as a string.
n must be a string constant.</p>
               
               <pre><code>func StringVal(n Node) string</code></pre>
            </article>
            
            <article class="function" data-name="SubOp">
               <h3>
                  SubOp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) SubOp() Op</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StructKeyExpr) Sym() *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectorExpr) Sym() *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BranchStmt) Sym() *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) Sym() *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) Sym() *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LabelStmt) Sym() *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) Sym() *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Ident) Sym() *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="Sym">
               <h3>
                  Sym 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *typeNode) Sym() *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="Take">
               <h3>
                  Take 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Take clears n, returning its former contents.</p>
               
               <pre><code>func (n *Nodes) Take() []Node</code></pre>
            </article>
            
            <article class="function" data-name="TakeInit">
               <h3>
                  TakeInit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func TakeInit(n Node) Nodes</code></pre>
            </article>
            
            <article class="function" data-name="ToNodes">
               <h3>
                  ToNodes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ToNodes returns s as a slice of Nodes.</p>
               
               <pre><code>func ToNodes(s []T) Nodes</code></pre>
            </article>
            
            <article class="function" data-name="ToStatic">
               <h3>
                  ToStatic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ToStatic returns static type of dt if it is actually static.</p>
               
               <pre><code>func (dt *DynamicType) ToStatic() Node</code></pre>
            </article>
            
            <article class="function" data-name="Transient">
               <h3>
                  Transient 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniExpr) Transient() bool</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) Type() *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *typeNode) Type() *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniExpr) Type() *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) Type() *types.Type</code></pre>
            </article>
            
            <article class="function" data-name="TypeNode">
               <h3>
                  TypeNode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TypeNode returns the Node representing the type t.</p>
               
               <pre><code>func TypeNode(t *types.Type) Node</code></pre>
            </article>
            
            <article class="function" data-name="Typecheck">
               <h3>
                  Typecheck 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) Typecheck() uint8</code></pre>
            </article>
            
            <article class="function" data-name="Uint64Val">
               <h3>
                  Uint64Val 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Uint64Val returns n as a uint64.
n must be an integer or rune constant.</p>
               
               <pre><code>func Uint64Val(n Node) uint64</code></pre>
            </article>
            
            <article class="function" data-name="Used">
               <h3>
                  Used 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) Used() bool</code></pre>
            </article>
            
            <article class="function" data-name="Uses">
               <h3>
                  Uses 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Uses reports whether expression x is a (direct) use of the given
variable.</p>
               
               <pre><code>func Uses(x Node, v *Name) bool</code></pre>
            </article>
            
            <article class="function" data-name="Val">
               <h3>
                  Val 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Val returns the constant.Value for the node.</p>
               
               <pre><code>func (n *Name) Val() constant.Value</code></pre>
            </article>
            
            <article class="function" data-name="Val">
               <h3>
                  Val 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BasicLit) Val() constant.Value</code></pre>
            </article>
            
            <article class="function" data-name="Val">
               <h3>
                  Val 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) Val() constant.Value</code></pre>
            </article>
            
            <article class="function" data-name="ValidTypeForConst">
               <h3>
                  ValidTypeForConst 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ValidTypeForConst(t *types.Type, v constant.Value) bool</code></pre>
            </article>
            
            <article class="function" data-name="Visit">
               <h3>
                  Visit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Visit visits each non-nil node x in the IR tree rooted at n
in a depth-first preorder traversal, calling visit on each node visited.</p>
               
               <pre><code>func Visit(n Node, visit func(Node))</code></pre>
            </article>
            
            <article class="function" data-name="VisitFuncAndClosures">
               <h3>
                  VisitFuncAndClosures 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>VisitFuncAndClosures calls visit on each non-nil node in fn.Body,
including any nested closure bodies.</p>
               
               <pre><code>func VisitFuncAndClosures(fn *Func, visit func(n Node))</code></pre>
            </article>
            
            <article class="function" data-name="VisitFuncsBottomUp">
               <h3>
                  VisitFuncsBottomUp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>VisitFuncsBottomUp invokes analyze on the ODCLFUNC nodes listed in list.
It calls analyze with successive groups of functions, working from
the bottom of the call graph upward. Each time analyze is called with
a list of functions, every function on that list only calls other functions
on the list or functions that have been passed in previous invocations of
analyze. Closures appear in the same list as their outer functions.
The lists are as short as possible while preserving those requirements.
(In a typical program, many invocations of analyze will be passed just
a single function.) The boolean argument 'recursive' passed to analyze
specifies whether the functions on the list are mutually recursive.
If recursive is false, the list consists of only a single function and its closures.
If recursive is true, the list may still contain only a single function,
if that function is itself recursive.</p>
               
               <pre><code>func VisitFuncsBottomUp(list []*Func, analyze func(list []*Func, recursive bool))</code></pre>
            </article>
            
            <article class="function" data-name="VisitList">
               <h3>
                  VisitList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>VisitList calls Visit(x, visit) for each node x in the list.</p>
               
               <pre><code>func VisitList(list Nodes, visit func(Node))</code></pre>
            </article>
            
            <article class="function" data-name="Walked">
               <h3>
                  Walked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) Walked() bool</code></pre>
            </article>
            
            <article class="function" data-name="WithFunc">
               <h3>
                  WithFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WithFunc invokes do with CurFunc and base.Pos set to curfn and
curfn.Pos(), respectively, and then restores their previous values
before returning.</p>
               
               <pre><code>func WithFunc(curfn *Func, do func())</code></pre>
            </article>
            
            <article class="function" data-name="Wrapper">
               <h3>
                  Wrapper 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) Wrapper() bool</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *dumper) Write(data []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function" data-name="addr">
               <h3>
                  addr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addr returns the (hexadecimal) address string of the object
represented by x (or "?" if x is not addressable), with the
common prefix between this and the prior address replaced by
"0x…" to make it easier to visually match addresses.</p>
               
               <pre><code>func (p *dumper) addr(x reflect.Value) string</code></pre>
            </article>
            
            <article class="function" data-name="checkReassignedResult">
               <h3>
                  checkReassignedResult 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkReassignedResult compares the result from ReassignOracle.Reassigned
with the corresponding result from ir.Reassigned to make sure they agree.
This method is called only when turned on via build tag.</p>
               
               <pre><code>func checkReassignedResult(n *Name, newres bool)</code></pre>
            </article>
            
            <article class="function" data-name="checkStaticValueResult">
               <h3>
                  checkStaticValueResult 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkStaticValueResult compares the result from ReassignOracle.StaticValue
with the corresponding result from ir.StaticValue to make sure they agree.
This method is called only when turned on via build tag.</p>
               
               <pre><code>func checkStaticValueResult(n Node, newres Node)</code></pre>
            </article>
            
            <article class="function" data-name="closureName">
               <h3>
                  closureName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>closureName generates a new unique name for a closure within outerfn at pos.</p>
               
               <pre><code>func closureName(outerfn *Func, pos src.XPos, why Op) *types.Sym</code></pre>
            </article>
            
            <article class="function" data-name="commonPrefixLen">
               <h3>
                  commonPrefixLen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func commonPrefixLen(a string, b string) (i int)</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicTypeAssertExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Decl) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IfStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *GoDeferStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignListStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IndexExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlineMarkStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ForStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlinedCallExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InterfaceSwitchStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignOpStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *JumpTableStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *typeNode) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddStringExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *UnaryExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *KeyExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicType) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LabelStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeSwitchGuard) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Ident) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BasicLit) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LinksymOffsetExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeAssertExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Func) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TailCallStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LogicalExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BinaryExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ConvExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SwitchStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *MakeExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StructKeyExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NilExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BlockStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CompLitExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StringHeaderExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ParenExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StarExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *RangeStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BranchStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CommClause) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceHeaderExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ResultExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ReturnStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CallExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ClosureExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SendStmt) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectorExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddrExpr) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copy">
               <h3>
                  copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CaseClause) copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="copyCaseClauses">
               <h3>
                  copyCaseClauses 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func copyCaseClauses(list []*CaseClause) []*CaseClause</code></pre>
            </article>
            
            <article class="function" data-name="copyCommClauses">
               <h3>
                  copyCommClauses 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func copyCommClauses(list []*CommClause) []*CommClause</code></pre>
            </article>
            
            <article class="function" data-name="copyNames">
               <h3>
                  copyNames 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func copyNames(list []*Name) []*Name</code></pre>
            </article>
            
            <article class="function" data-name="copyNodes">
               <h3>
                  copyNodes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func copyNodes(list []Node) []Node</code></pre>
            </article>
            
            <article class="function" data-name="doCaseClauses">
               <h3>
                  doCaseClauses 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func doCaseClauses(list []*CaseClause, do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BinaryExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlineMarkStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SendStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ReturnStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CallExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ClosureExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddrExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ResultExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *RangeStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BranchStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CommClause) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceHeaderExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ParenExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StarExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NilExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BlockStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CompLitExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StringHeaderExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *MakeExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BasicLit) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LogicalExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CaseClause) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ConvExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SwitchStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectorExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TailCallStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StructKeyExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeAssertExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Decl) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Func) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LabelStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeSwitchGuard) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddStringExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicType) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *KeyExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *JumpTableStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *UnaryExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignOpStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicTypeAssertExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InterfaceSwitchStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *typeNode) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlinedCallExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ForStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LinksymOffsetExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IndexExpr) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignListStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IfStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *GoDeferStmt) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildren">
               <h3>
                  doChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Ident) doChildren(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ConvExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StarExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *MakeExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CompLitExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Ident) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LinksymOffsetExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignListStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NilExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *GoDeferStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *typeNode) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IfStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignOpStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *UnaryExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeSwitchGuard) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IndexExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeAssertExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BasicLit) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TailCallStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddStringExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ForStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlineMarkStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SwitchStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BinaryExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Decl) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StructKeyExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StringHeaderExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlinedCallExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddrExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BlockStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ParenExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LogicalExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicTypeAssertExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InterfaceSwitchStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CommClause) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceHeaderExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BranchStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SendStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *JumpTableStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CallExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectorExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CaseClause) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicType) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *KeyExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ReturnStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ClosureExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Func) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ResultExpr) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *RangeStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doChildrenWithHidden">
               <h3>
                  doChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LabelStmt) doChildrenWithHidden(do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doCommClauses">
               <h3>
                  doCommClauses 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func doCommClauses(list []*CommClause, do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doNames">
               <h3>
                  doNames 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func doNames(list []*Name, do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doNodes">
               <h3>
                  doNodes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func doNodes(list []Node, do func(Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="dump">
               <h3>
                  dump 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>dump prints the contents of x.</p>
               
               <pre><code>func (p *dumper) dump(x reflect.Value, depth int)</code></pre>
            </article>
            
            <article class="function" data-name="dumpNode">
               <h3>
                  dumpNode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dumpNode(w io.Writer, n Node, depth int)</code></pre>
            </article>
            
            <article class="function" data-name="dumpNodeHeader">
               <h3>
                  dumpNodeHeader 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dumpNodeHeader prints the debug-format node header line to w.</p>
               
               <pre><code>func dumpNodeHeader(w io.Writer, n Node)</code></pre>
            </article>
            
            <article class="function" data-name="dumpNodes">
               <h3>
                  dumpNodes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dumpNodes(w io.Writer, list Nodes, depth int)</code></pre>
            </article>
            
            <article class="function" data-name="editCaseClauses">
               <h3>
                  editCaseClauses 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func editCaseClauses(list []*CaseClause, edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BinaryExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectorExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddStringExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ConvExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LogicalExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *GoDeferStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Ident) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CompLitExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignListStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *MakeExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *typeNode) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IfStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *UnaryExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LinksymOffsetExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignOpStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeSwitchGuard) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NilExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeAssertExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IndexExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CommClause) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TailCallStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ParenExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BasicLit) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ForStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LabelStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SwitchStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Decl) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *RangeStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlineMarkStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StructKeyExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StringHeaderExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ClosureExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlinedCallExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ResultExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StarExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicTypeAssertExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BlockStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InterfaceSwitchStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *KeyExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ReturnStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceHeaderExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddrExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CaseClause) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicType) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BranchStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SendStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Func) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *JumpTableStmt) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildren">
               <h3>
                  editChildren 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CallExpr) editChildren(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InterfaceSwitchStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddStringExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *GoDeferStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *JumpTableStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CallExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicType) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AddrExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SendStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LogicalExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BranchStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CompLitExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CaseClause) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Ident) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Func) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LinksymOffsetExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignListStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ReturnStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SliceHeaderExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BlockStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *KeyExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *typeNode) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ResultExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StarExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *MakeExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlinedCallExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Decl) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *DynamicTypeAssertExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ClosureExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StringHeaderExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IfStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BinaryExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *UnaryExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SelectorExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignOpStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *StructKeyExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeSwitchGuard) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *InlineMarkStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ConvExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *RangeStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ForStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *SwitchStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NilExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *BasicLit) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *ParenExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TypeAssertExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *LabelStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *TailCallStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *CommClause) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *IndexExpr) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editChildrenWithHidden">
               <h3>
                  editChildrenWithHidden 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *AssignStmt) editChildrenWithHidden(edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editCommClauses">
               <h3>
                  editCommClauses 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func editCommClauses(list []*CommClause, edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editNames">
               <h3>
                  editNames 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func editNames(list []*Name, edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="editNodes">
               <h3>
                  editNodes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func editNodes(list []Node, edit func(Node) Node)</code></pre>
            </article>
            
            <article class="function" data-name="ellipsisIf">
               <h3>
                  ellipsisIf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ellipsisIf(b bool) string</code></pre>
            </article>
            
            <article class="function" data-name="escapedImportPathOK">
               <h3>
                  escapedImportPathOK 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func escapedImportPathOK(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="exprFmt">
               <h3>
                  exprFmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func exprFmt(n Node, s fmt.State, prec int)</code></pre>
            </article>
            
            <article class="function" data-name="fmtFullPos">
               <h3>
                  fmtFullPos 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fmtFullPos returns a verbose dump for pos p, including inlines.</p>
               
               <pre><code>func fmtFullPos(p src.XPos) string</code></pre>
            </article>
            
            <article class="function" data-name="fmtNode">
               <h3>
                  fmtNode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fmtNode implements formatting for a Node n.
Every Node implementation must define a Format method that calls fmtNode.
The valid formats are:
%v	Go syntax
%L	Go syntax followed by " (type T)" if type is known.
%+v	Debug syntax, as in Dump.</p>
               
               <pre><code>func fmtNode(n Node, s fmt.State, verb rune)</code></pre>
            </article>
            
            <article class="function" data-name="get2">
               <h3>
                  get2 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f bitset8) get2(shift uint8) uint8</code></pre>
            </article>
            
            <article class="function" data-name="indent">
               <h3>
                  indent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>indent prints indentation to w.</p>
               
               <pre><code>func indent(w io.Writer, depth int)</code></pre>
            </article>
            
            <article class="function" data-name="isExpr">
               <h3>
                  isExpr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*miniExpr) isExpr()</code></pre>
            </article>
            
            <article class="function" data-name="isExpr">
               <h3>
                  isExpr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) isExpr()</code></pre>
            </article>
            
            <article class="function" data-name="isStmt">
               <h3>
                  isStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*miniStmt) isStmt()</code></pre>
            </article>
            
            <article class="function" data-name="isStmt">
               <h3>
                  isStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *Func) isStmt()</code></pre>
            </article>
            
            <article class="function" data-name="isStmt">
               <h3>
                  isStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*Decl) isStmt()</code></pre>
            </article>
            
            <article class="function" data-name="isStmt">
               <h3>
                  isStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*CallExpr) isStmt()</code></pre>
            </article>
            
            <article class="function" data-name="modPathOK">
               <h3>
                  modPathOK 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Borrowed from x/mod.</p>
               
               <pre><code>func modPathOK(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="newNameAt">
               <h3>
                  newNameAt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newNameAt is like NewNameAt but allows sym == nil.</p>
               
               <pre><code>func newNameAt(pos src.XPos, op Op, sym *types.Sym) *Name</code></pre>
            </article>
            
            <article class="function" data-name="newTypeNode">
               <h3>
                  newTypeNode 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newTypeNode(typ *types.Type) *typeNode</code></pre>
            </article>
            
            <article class="function" data-name="no">
               <h3>
                  no 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *miniNode) no(name string) string</code></pre>
            </article>
            
            <article class="function" data-name="posOr">
               <h3>
                  posOr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>posOr returns pos if known, or else n.pos.
For use in DeepCopy.</p>
               
               <pre><code>func (n *miniNode) posOr(pos src.XPos) src.XPos</code></pre>
            </article>
            
            <article class="function" data-name="printf">
               <h3>
                  printf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>printf is a convenience wrapper.</p>
               
               <pre><code>func (p *dumper) printf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *bitset8) set(mask uint8, b bool)</code></pre>
            </article>
            
            <article class="function" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *bitset16) set(mask uint16, b bool)</code></pre>
            </article>
            
            <article class="function" data-name="set2">
               <h3>
                  set2 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>set2 sets two bits in f using the bottom two bits of b.</p>
               
               <pre><code>func (f *bitset8) set2(shift uint8, b uint8)</code></pre>
            </article>
            
            <article class="function" data-name="setReadonly">
               <h3>
                  setReadonly 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Name) setReadonly(b bool)</code></pre>
            </article>
            
            <article class="function" data-name="setupTextLSym">
               <h3>
                  setupTextLSym 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>setupTextLSym initializes the LSym for a with-body text symbol.</p>
               
               <pre><code>func setupTextLSym(f *Func, flag int)</code></pre>
            </article>
            
            <article class="function" data-name="splitPkg">
               <h3>
                  splitPkg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>splitPkg splits the full linker symbol name into package and local symbol
name.</p>
               
               <pre><code>func splitPkg(name string) (pkgpath string, sym string)</code></pre>
            </article>
            
            <article class="function" data-name="splitType">
               <h3>
                  splitType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>splitType splits a local symbol name into type and method (fn). If this a
free function, typ == "".
N.B. closures and methods can be ambiguous (e.g., bar.func1). These cases
are returned as methods.</p>
               
               <pre><code>func splitType(name string) (typ string, fn string)</code></pre>
            </article>
            
            <article class="function" data-name="staticValue1">
               <h3>
                  staticValue1 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ro *ReassignOracle) staticValue1(nn Node) Node</code></pre>
            </article>
            
            <article class="function" data-name="staticValue1">
               <h3>
                  staticValue1 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func staticValue1(nn Node) Node</code></pre>
            </article>
            
            <article class="function" data-name="stmtFmt">
               <h3>
                  stmtFmt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func stmtFmt(n Node, s fmt.State)</code></pre>
            </article>
            
            <article class="function" data-name="visit">
               <h3>
                  visit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *bottomUpVisitor) visit(n *Func) uint32</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
