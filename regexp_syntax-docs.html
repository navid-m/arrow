<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - syntax</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>syntax</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"unicode"
"strconv"
"sort"
"strings"
"unicode"
"unicode/utf8"
"strconv"
"strings"
"unicode"
"unicode/utf8"
"slices"
"strconv"
"strings"
"unicode"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ClassNL" data-name="ClassNL">
               <h3>
                  ClassNL 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ClassNL" class="anchor" title="Link to ClassNL">#</a>
               </h3>
               
               <pre><code>const ClassNL</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DotNL" data-name="DotNL">
               <h3>
                  DotNL 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DotNL" class="anchor" title="Link to DotNL">#</a>
               </h3>
               
               <pre><code>const DotNL</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EmptyBeginLine" data-name="EmptyBeginLine">
               <h3>
                  EmptyBeginLine 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EmptyBeginLine" class="anchor" title="Link to EmptyBeginLine">#</a>
               </h3>
               
               <pre><code>const EmptyBeginLine EmptyOp = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EmptyBeginText" data-name="EmptyBeginText">
               <h3>
                  EmptyBeginText 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EmptyBeginText" class="anchor" title="Link to EmptyBeginText">#</a>
               </h3>
               
               <pre><code>const EmptyBeginText</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EmptyEndLine" data-name="EmptyEndLine">
               <h3>
                  EmptyEndLine 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EmptyEndLine" class="anchor" title="Link to EmptyEndLine">#</a>
               </h3>
               
               <pre><code>const EmptyEndLine</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EmptyEndText" data-name="EmptyEndText">
               <h3>
                  EmptyEndText 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EmptyEndText" class="anchor" title="Link to EmptyEndText">#</a>
               </h3>
               
               <pre><code>const EmptyEndText</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EmptyNoWordBoundary" data-name="EmptyNoWordBoundary">
               <h3>
                  EmptyNoWordBoundary 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EmptyNoWordBoundary" class="anchor" title="Link to EmptyNoWordBoundary">#</a>
               </h3>
               
               <pre><code>const EmptyNoWordBoundary</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EmptyWordBoundary" data-name="EmptyWordBoundary">
               <h3>
                  EmptyWordBoundary 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EmptyWordBoundary" class="anchor" title="Link to EmptyWordBoundary">#</a>
               </h3>
               
               <pre><code>const EmptyWordBoundary</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInternalError" data-name="ErrInternalError">
               <h3>
                  ErrInternalError 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrInternalError" class="anchor" title="Link to ErrInternalError">#</a>
               </h3>
               
               <p>Unexpected error</p>
               
               <pre><code>const ErrInternalError ErrorCode = "regexp/syntax: internal error"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInvalidCharClass" data-name="ErrInvalidCharClass">
               <h3>
                  ErrInvalidCharClass 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrInvalidCharClass" class="anchor" title="Link to ErrInvalidCharClass">#</a>
               </h3>
               
               <p>Parse errors</p>
               
               <pre><code>const ErrInvalidCharClass ErrorCode = "invalid character class"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInvalidCharRange" data-name="ErrInvalidCharRange">
               <h3>
                  ErrInvalidCharRange 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrInvalidCharRange" class="anchor" title="Link to ErrInvalidCharRange">#</a>
               </h3>
               
               <pre><code>const ErrInvalidCharRange ErrorCode = "invalid character class range"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInvalidEscape" data-name="ErrInvalidEscape">
               <h3>
                  ErrInvalidEscape 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrInvalidEscape" class="anchor" title="Link to ErrInvalidEscape">#</a>
               </h3>
               
               <pre><code>const ErrInvalidEscape ErrorCode = "invalid escape sequence"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInvalidNamedCapture" data-name="ErrInvalidNamedCapture">
               <h3>
                  ErrInvalidNamedCapture 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrInvalidNamedCapture" class="anchor" title="Link to ErrInvalidNamedCapture">#</a>
               </h3>
               
               <pre><code>const ErrInvalidNamedCapture ErrorCode = "invalid named capture"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInvalidPerlOp" data-name="ErrInvalidPerlOp">
               <h3>
                  ErrInvalidPerlOp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrInvalidPerlOp" class="anchor" title="Link to ErrInvalidPerlOp">#</a>
               </h3>
               
               <pre><code>const ErrInvalidPerlOp ErrorCode = "invalid or unsupported Perl syntax"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInvalidRepeatOp" data-name="ErrInvalidRepeatOp">
               <h3>
                  ErrInvalidRepeatOp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrInvalidRepeatOp" class="anchor" title="Link to ErrInvalidRepeatOp">#</a>
               </h3>
               
               <pre><code>const ErrInvalidRepeatOp ErrorCode = "invalid nested repetition operator"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInvalidRepeatSize" data-name="ErrInvalidRepeatSize">
               <h3>
                  ErrInvalidRepeatSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrInvalidRepeatSize" class="anchor" title="Link to ErrInvalidRepeatSize">#</a>
               </h3>
               
               <pre><code>const ErrInvalidRepeatSize ErrorCode = "invalid repeat count"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInvalidUTF8" data-name="ErrInvalidUTF8">
               <h3>
                  ErrInvalidUTF8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrInvalidUTF8" class="anchor" title="Link to ErrInvalidUTF8">#</a>
               </h3>
               
               <pre><code>const ErrInvalidUTF8 ErrorCode = "invalid UTF-8"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrLarge" data-name="ErrLarge">
               <h3>
                  ErrLarge 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrLarge" class="anchor" title="Link to ErrLarge">#</a>
               </h3>
               
               <pre><code>const ErrLarge ErrorCode = "expression too large"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrMissingBracket" data-name="ErrMissingBracket">
               <h3>
                  ErrMissingBracket 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrMissingBracket" class="anchor" title="Link to ErrMissingBracket">#</a>
               </h3>
               
               <pre><code>const ErrMissingBracket ErrorCode = "missing closing ]"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrMissingParen" data-name="ErrMissingParen">
               <h3>
                  ErrMissingParen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrMissingParen" class="anchor" title="Link to ErrMissingParen">#</a>
               </h3>
               
               <pre><code>const ErrMissingParen ErrorCode = "missing closing )"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrMissingRepeatArgument" data-name="ErrMissingRepeatArgument">
               <h3>
                  ErrMissingRepeatArgument 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrMissingRepeatArgument" class="anchor" title="Link to ErrMissingRepeatArgument">#</a>
               </h3>
               
               <pre><code>const ErrMissingRepeatArgument ErrorCode = "missing argument to repetition operator"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNestingDepth" data-name="ErrNestingDepth">
               <h3>
                  ErrNestingDepth 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrNestingDepth" class="anchor" title="Link to ErrNestingDepth">#</a>
               </h3>
               
               <pre><code>const ErrNestingDepth ErrorCode = "expression nests too deeply"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrTrailingBackslash" data-name="ErrTrailingBackslash">
               <h3>
                  ErrTrailingBackslash 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrTrailingBackslash" class="anchor" title="Link to ErrTrailingBackslash">#</a>
               </h3>
               
               <pre><code>const ErrTrailingBackslash ErrorCode = "trailing backslash at end of expression"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrUnexpectedParen" data-name="ErrUnexpectedParen">
               <h3>
                  ErrUnexpectedParen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ErrUnexpectedParen" class="anchor" title="Link to ErrUnexpectedParen">#</a>
               </h3>
               
               <pre><code>const ErrUnexpectedParen ErrorCode = "unexpected )"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FoldCase" data-name="FoldCase">
               <h3>
                  FoldCase 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FoldCase" class="anchor" title="Link to FoldCase">#</a>
               </h3>
               
               <pre><code>const FoldCase Flags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InstAlt" data-name="InstAlt">
               <h3>
                  InstAlt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InstAlt" class="anchor" title="Link to InstAlt">#</a>
               </h3>
               
               <pre><code>const InstAlt InstOp = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InstAltMatch" data-name="InstAltMatch">
               <h3>
                  InstAltMatch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InstAltMatch" class="anchor" title="Link to InstAltMatch">#</a>
               </h3>
               
               <pre><code>const InstAltMatch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InstCapture" data-name="InstCapture">
               <h3>
                  InstCapture 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InstCapture" class="anchor" title="Link to InstCapture">#</a>
               </h3>
               
               <pre><code>const InstCapture</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InstEmptyWidth" data-name="InstEmptyWidth">
               <h3>
                  InstEmptyWidth 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InstEmptyWidth" class="anchor" title="Link to InstEmptyWidth">#</a>
               </h3>
               
               <pre><code>const InstEmptyWidth</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InstFail" data-name="InstFail">
               <h3>
                  InstFail 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InstFail" class="anchor" title="Link to InstFail">#</a>
               </h3>
               
               <pre><code>const InstFail</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InstMatch" data-name="InstMatch">
               <h3>
                  InstMatch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InstMatch" class="anchor" title="Link to InstMatch">#</a>
               </h3>
               
               <pre><code>const InstMatch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InstNop" data-name="InstNop">
               <h3>
                  InstNop 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InstNop" class="anchor" title="Link to InstNop">#</a>
               </h3>
               
               <pre><code>const InstNop</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InstRune" data-name="InstRune">
               <h3>
                  InstRune 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InstRune" class="anchor" title="Link to InstRune">#</a>
               </h3>
               
               <pre><code>const InstRune</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InstRune1" data-name="InstRune1">
               <h3>
                  InstRune1 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InstRune1" class="anchor" title="Link to InstRune1">#</a>
               </h3>
               
               <pre><code>const InstRune1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InstRuneAny" data-name="InstRuneAny">
               <h3>
                  InstRuneAny 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InstRuneAny" class="anchor" title="Link to InstRuneAny">#</a>
               </h3>
               
               <pre><code>const InstRuneAny</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InstRuneAnyNotNL" data-name="InstRuneAnyNotNL">
               <h3>
                  InstRuneAnyNotNL 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InstRuneAnyNotNL" class="anchor" title="Link to InstRuneAnyNotNL">#</a>
               </h3>
               
               <pre><code>const InstRuneAnyNotNL</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Literal" data-name="Literal">
               <h3>
                  Literal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Literal" class="anchor" title="Link to Literal">#</a>
               </h3>
               
               <pre><code>const Literal</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MatchNL" data-name="MatchNL">
               <h3>
                  MatchNL 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MatchNL" class="anchor" title="Link to MatchNL">#</a>
               </h3>
               
               <pre><code>const MatchNL = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NonGreedy" data-name="NonGreedy">
               <h3>
                  NonGreedy 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NonGreedy" class="anchor" title="Link to NonGreedy">#</a>
               </h3>
               
               <pre><code>const NonGreedy</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OneLine" data-name="OneLine">
               <h3>
                  OneLine 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OneLine" class="anchor" title="Link to OneLine">#</a>
               </h3>
               
               <pre><code>const OneLine</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpAlternate" data-name="OpAlternate">
               <h3>
                  OpAlternate 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpAlternate" class="anchor" title="Link to OpAlternate">#</a>
               </h3>
               
               <pre><code>const OpAlternate</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpAnyChar" data-name="OpAnyChar">
               <h3>
                  OpAnyChar 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpAnyChar" class="anchor" title="Link to OpAnyChar">#</a>
               </h3>
               
               <pre><code>const OpAnyChar</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpAnyCharNotNL" data-name="OpAnyCharNotNL">
               <h3>
                  OpAnyCharNotNL 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpAnyCharNotNL" class="anchor" title="Link to OpAnyCharNotNL">#</a>
               </h3>
               
               <pre><code>const OpAnyCharNotNL</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpBeginLine" data-name="OpBeginLine">
               <h3>
                  OpBeginLine 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpBeginLine" class="anchor" title="Link to OpBeginLine">#</a>
               </h3>
               
               <pre><code>const OpBeginLine</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpBeginText" data-name="OpBeginText">
               <h3>
                  OpBeginText 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpBeginText" class="anchor" title="Link to OpBeginText">#</a>
               </h3>
               
               <pre><code>const OpBeginText</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpCapture" data-name="OpCapture">
               <h3>
                  OpCapture 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpCapture" class="anchor" title="Link to OpCapture">#</a>
               </h3>
               
               <pre><code>const OpCapture</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpCharClass" data-name="OpCharClass">
               <h3>
                  OpCharClass 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpCharClass" class="anchor" title="Link to OpCharClass">#</a>
               </h3>
               
               <pre><code>const OpCharClass</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpConcat" data-name="OpConcat">
               <h3>
                  OpConcat 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpConcat" class="anchor" title="Link to OpConcat">#</a>
               </h3>
               
               <pre><code>const OpConcat</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpEmptyMatch" data-name="OpEmptyMatch">
               <h3>
                  OpEmptyMatch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpEmptyMatch" class="anchor" title="Link to OpEmptyMatch">#</a>
               </h3>
               
               <pre><code>const OpEmptyMatch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpEndLine" data-name="OpEndLine">
               <h3>
                  OpEndLine 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpEndLine" class="anchor" title="Link to OpEndLine">#</a>
               </h3>
               
               <pre><code>const OpEndLine</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpEndText" data-name="OpEndText">
               <h3>
                  OpEndText 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpEndText" class="anchor" title="Link to OpEndText">#</a>
               </h3>
               
               <pre><code>const OpEndText</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpLiteral" data-name="OpLiteral">
               <h3>
                  OpLiteral 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpLiteral" class="anchor" title="Link to OpLiteral">#</a>
               </h3>
               
               <pre><code>const OpLiteral</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpNoMatch" data-name="OpNoMatch">
               <h3>
                  OpNoMatch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpNoMatch" class="anchor" title="Link to OpNoMatch">#</a>
               </h3>
               
               <pre><code>const OpNoMatch Op = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpNoWordBoundary" data-name="OpNoWordBoundary">
               <h3>
                  OpNoWordBoundary 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpNoWordBoundary" class="anchor" title="Link to OpNoWordBoundary">#</a>
               </h3>
               
               <pre><code>const OpNoWordBoundary</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpPlus" data-name="OpPlus">
               <h3>
                  OpPlus 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpPlus" class="anchor" title="Link to OpPlus">#</a>
               </h3>
               
               <pre><code>const OpPlus</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpQuest" data-name="OpQuest">
               <h3>
                  OpQuest 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpQuest" class="anchor" title="Link to OpQuest">#</a>
               </h3>
               
               <pre><code>const OpQuest</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpRepeat" data-name="OpRepeat">
               <h3>
                  OpRepeat 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpRepeat" class="anchor" title="Link to OpRepeat">#</a>
               </h3>
               
               <pre><code>const OpRepeat</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpStar" data-name="OpStar">
               <h3>
                  OpStar 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpStar" class="anchor" title="Link to OpStar">#</a>
               </h3>
               
               <pre><code>const OpStar</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OpWordBoundary" data-name="OpWordBoundary">
               <h3>
                  OpWordBoundary 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OpWordBoundary" class="anchor" title="Link to OpWordBoundary">#</a>
               </h3>
               
               <pre><code>const OpWordBoundary</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="POSIX" data-name="POSIX">
               <h3>
                  POSIX 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#POSIX" class="anchor" title="Link to POSIX">#</a>
               </h3>
               
               <pre><code>const POSIX Flags = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Perl" data-name="Perl">
               <h3>
                  Perl 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Perl" class="anchor" title="Link to Perl">#</a>
               </h3>
               
               <pre><code>const Perl = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PerlX" data-name="PerlX">
               <h3>
                  PerlX 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PerlX" class="anchor" title="Link to PerlX">#</a>
               </h3>
               
               <pre><code>const PerlX</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Simple" data-name="Simple">
               <h3>
                  Simple 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Simple" class="anchor" title="Link to Simple">#</a>
               </h3>
               
               <pre><code>const Simple</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnicodeGroups" data-name="UnicodeGroups">
               <h3>
                  UnicodeGroups 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnicodeGroups" class="anchor" title="Link to UnicodeGroups">#</a>
               </h3>
               
               <pre><code>const UnicodeGroups</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WasDollar" data-name="WasDollar">
               <h3>
                  WasDollar 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#WasDollar" class="anchor" title="Link to WasDollar">#</a>
               </h3>
               
               <pre><code>const WasDollar</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Op_index_0" data-name="_Op_index_0">
               <h3>
                  _Op_index_0 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_Op_index_0" class="anchor" title="Link to _Op_index_0">#</a>
               </h3>
               
               <pre><code>var _Op_index_0 = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Op_name_0" data-name="_Op_name_0">
               <h3>
                  _Op_name_0 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Op_name_0" class="anchor" title="Link to _Op_name_0">#</a>
               </h3>
               
               <pre><code>const _Op_name_0 = "NoMatchEmptyMatchLiteralCharClassAnyCharNotNLAnyCharBeginLineEndLineBeginTextEndTextWordBoundaryNoWordBoundaryCaptureStarPlusQuestRepeatConcatAlternate"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_Op_name_1" data-name="_Op_name_1">
               <h3>
                  _Op_name_1 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_Op_name_1" class="anchor" title="Link to _Op_name_1">#</a>
               </h3>
               
               <pre><code>const _Op_name_1 = "opPseudo"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="anyRune" data-name="anyRune">
               <h3>
                  anyRune 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#anyRune" class="anchor" title="Link to anyRune">#</a>
               </h3>
               
               <pre><code>var anyRune = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="anyRuneNotNL" data-name="anyRuneNotNL">
               <h3>
                  anyRuneNotNL 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#anyRuneNotNL" class="anchor" title="Link to anyRuneNotNL">#</a>
               </h3>
               
               <pre><code>var anyRuneNotNL = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="anyTable" data-name="anyTable">
               <h3>
                  anyTable 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#anyTable" class="anchor" title="Link to anyTable">#</a>
               </h3>
               
               <pre><code>var anyTable = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code1" data-name="code1">
               <h3>
                  code1 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code1" class="anchor" title="Link to code1">#</a>
               </h3>
               
               <pre><code>var code1 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code10" data-name="code10">
               <h3>
                  code10 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code10" class="anchor" title="Link to code10">#</a>
               </h3>
               
               <pre><code>var code10 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code11" data-name="code11">
               <h3>
                  code11 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code11" class="anchor" title="Link to code11">#</a>
               </h3>
               
               <pre><code>var code11 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code12" data-name="code12">
               <h3>
                  code12 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code12" class="anchor" title="Link to code12">#</a>
               </h3>
               
               <pre><code>var code12 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code13" data-name="code13">
               <h3>
                  code13 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code13" class="anchor" title="Link to code13">#</a>
               </h3>
               
               <pre><code>var code13 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code14" data-name="code14">
               <h3>
                  code14 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code14" class="anchor" title="Link to code14">#</a>
               </h3>
               
               <pre><code>var code14 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code15" data-name="code15">
               <h3>
                  code15 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code15" class="anchor" title="Link to code15">#</a>
               </h3>
               
               <pre><code>var code15 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code16" data-name="code16">
               <h3>
                  code16 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code16" class="anchor" title="Link to code16">#</a>
               </h3>
               
               <pre><code>var code16 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code17" data-name="code17">
               <h3>
                  code17 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code17" class="anchor" title="Link to code17">#</a>
               </h3>
               
               <pre><code>var code17 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code2" data-name="code2">
               <h3>
                  code2 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code2" class="anchor" title="Link to code2">#</a>
               </h3>
               
               <pre><code>var code2 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code3" data-name="code3">
               <h3>
                  code3 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code3" class="anchor" title="Link to code3">#</a>
               </h3>
               
               <pre><code>var code3 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code4" data-name="code4">
               <h3>
                  code4 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code4" class="anchor" title="Link to code4">#</a>
               </h3>
               
               <pre><code>var code4 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code5" data-name="code5">
               <h3>
                  code5 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code5" class="anchor" title="Link to code5">#</a>
               </h3>
               
               <pre><code>var code5 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code6" data-name="code6">
               <h3>
                  code6 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code6" class="anchor" title="Link to code6">#</a>
               </h3>
               
               <pre><code>var code6 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code7" data-name="code7">
               <h3>
                  code7 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code7" class="anchor" title="Link to code7">#</a>
               </h3>
               
               <pre><code>var code7 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code8" data-name="code8">
               <h3>
                  code8 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code8" class="anchor" title="Link to code8">#</a>
               </h3>
               
               <pre><code>var code8 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="code9" data-name="code9">
               <h3>
                  code9 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#code9" class="anchor" title="Link to code9">#</a>
               </h3>
               
               <pre><code>var code9 = []rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagI" data-name="flagI">
               <h3>
                  flagI 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagI" class="anchor" title="Link to flagI">#</a>
               </h3>
               
               <pre><code>const flagI printFlags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagM" data-name="flagM">
               <h3>
                  flagM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagM" class="anchor" title="Link to flagM">#</a>
               </h3>
               
               <pre><code>const flagM</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagOff" data-name="flagOff">
               <h3>
                  flagOff 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagOff" class="anchor" title="Link to flagOff">#</a>
               </h3>
               
               <pre><code>const flagOff</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagPrec" data-name="flagPrec">
               <h3>
                  flagPrec 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagPrec" class="anchor" title="Link to flagPrec">#</a>
               </h3>
               
               <pre><code>const flagPrec</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagS" data-name="flagS">
               <h3>
                  flagS 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagS" class="anchor" title="Link to flagS">#</a>
               </h3>
               
               <pre><code>const flagS</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="instOpNames" data-name="instOpNames">
               <h3>
                  instOpNames 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#instOpNames" class="anchor" title="Link to instOpNames">#</a>
               </h3>
               
               <pre><code>var instOpNames = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="instSize" data-name="instSize">
               <h3>
                  instSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#instSize" class="anchor" title="Link to instSize">#</a>
               </h3>
               
               <p>maxSize is the maximum size of a compiled regexp in Insts.
It too is somewhat arbitrarily chosen, but the idea is to be large enough
to allow significant regexps while at the same time small enough that
the compiled form will not take up too much memory.
128 MB is enough for a 3.3 million Inst structures, which roughly
corresponds to a 3.3 MB regexp.</p>
               
               <pre><code>const instSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxFold" data-name="maxFold">
               <h3>
                  maxFold 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxFold" class="anchor" title="Link to maxFold">#</a>
               </h3>
               
               <pre><code>const maxFold = 0x1e943</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxHeight" data-name="maxHeight">
               <h3>
                  maxHeight 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxHeight" class="anchor" title="Link to maxHeight">#</a>
               </h3>
               
               <p>maxHeight is the maximum height of a regexp parse tree.
It is somewhat arbitrarily chosen, but the idea is to be large enough
that no one will actually hit in real use but at the same time small enough
that recursion on the Regexp tree will not hit the 1GB Go stack limit.
The maximum amount of stack for a single recursive frame is probably
closer to 1kB, so this could potentially be raised, but it seems unlikely
that people have regexps nested even this deeply.
We ran a test on Google's C++ code base and turned up only
a single use case with depth > 100; it had depth 128.
Using depth 1000 should be plenty of margin.
As an optimization, we don't even bother calculating heights
until we've allocated at least maxHeight Regexp structures.</p>
               
               <pre><code>const maxHeight = 1000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxRunes" data-name="maxRunes">
               <h3>
                  maxRunes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxRunes" class="anchor" title="Link to maxRunes">#</a>
               </h3>
               
               <p>maxRunes is the maximum number of runes allowed in a regexp tree
counting the runes in all the nodes.
Ignoring character classes p.numRunes is always less than the length of the regexp.
Character classes can make it much larger: each \pL adds 1292 runes.
128 MB is enough for 32M runes, which is over 26k \pL instances.
Note that repetitions do not make copies of the rune slices,
so \pL{1000} is only one rune slice, not 1000.
We could keep a cache of character classes we've seen,
so that all the \pL we see use the same rune list,
but that doesn't remove the problem entirely:
consider something like [\pL01234][\pL01235][\pL01236]...[\pL^&*()].
And because the Rune slice is exposed directly in the Regexp,
there is not an opportunity to change the representation to allow
partial sharing between different character classes.
So the limit is the best we can do.</p>
               
               <pre><code>const maxRunes = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxSize" data-name="maxSize">
               <h3>
                  maxSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxSize" class="anchor" title="Link to maxSize">#</a>
               </h3>
               
               <p>maxSize is the maximum size of a compiled regexp in Insts.
It too is somewhat arbitrarily chosen, but the idea is to be large enough
to allow significant regexps while at the same time small enough that
the compiled form will not take up too much memory.
128 MB is enough for a 3.3 million Inst structures, which roughly
corresponds to a 3.3 MB regexp.</p>
               
               <pre><code>const maxSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="meta" data-name="meta">
               <h3>
                  meta 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#meta" class="anchor" title="Link to meta">#</a>
               </h3>
               
               <pre><code>const meta = `\.+*?()|[]{}^$`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="minFold" data-name="minFold">
               <h3>
                  minFold 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#minFold" class="anchor" title="Link to minFold">#</a>
               </h3>
               
               <p>minimum and maximum runes involved in folding.
checked during test.</p>
               
               <pre><code>const minFold = 0x0041</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="negShift" data-name="negShift">
               <h3>
                  negShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#negShift" class="anchor" title="Link to negShift">#</a>
               </h3>
               
               <pre><code>const negShift = 5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noMatch" data-name="noMatch">
               <h3>
                  noMatch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#noMatch" class="anchor" title="Link to noMatch">#</a>
               </h3>
               
               <pre><code>const noMatch = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="opLeftParen" data-name="opLeftParen">
               <h3>
                  opLeftParen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#opLeftParen" class="anchor" title="Link to opLeftParen">#</a>
               </h3>
               
               <p>Pseudo-ops for parsing stack.</p>
               
               <pre><code>const opLeftParen = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="opPseudo" data-name="opPseudo">
               <h3>
                  opPseudo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#opPseudo" class="anchor" title="Link to opPseudo">#</a>
               </h3>
               
               <pre><code>const opPseudo Op = 128</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="opVerticalBar" data-name="opVerticalBar">
               <h3>
                  opVerticalBar 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#opVerticalBar" class="anchor" title="Link to opVerticalBar">#</a>
               </h3>
               
               <p>Pseudo-ops for parsing stack.</p>
               
               <pre><code>const opVerticalBar</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="perlGroup" data-name="perlGroup">
               <h3>
                  perlGroup 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#perlGroup" class="anchor" title="Link to perlGroup">#</a>
               </h3>
               
               <pre><code>var perlGroup = map[string]charGroup{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="posixGroup" data-name="posixGroup">
               <h3>
                  posixGroup 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#posixGroup" class="anchor" title="Link to posixGroup">#</a>
               </h3>
               
               <pre><code>var posixGroup = map[string]charGroup{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="runeSize" data-name="runeSize">
               <h3>
                  runeSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#runeSize" class="anchor" title="Link to runeSize">#</a>
               </h3>
               
               <p>maxRunes is the maximum number of runes allowed in a regexp tree
counting the runes in all the nodes.
Ignoring character classes p.numRunes is always less than the length of the regexp.
Character classes can make it much larger: each \pL adds 1292 runes.
128 MB is enough for 32M runes, which is over 26k \pL instances.
Note that repetitions do not make copies of the rune slices,
so \pL{1000} is only one rune slice, not 1000.
We could keep a cache of character classes we've seen,
so that all the \pL we see use the same rune list,
but that doesn't remove the problem entirely:
consider something like [\pL01234][\pL01235][\pL01236]...[\pL^&*()].
And because the Rune slice is exposed directly in the Regexp,
there is not an opportunity to change the representation to allow
partial sharing between different character classes.
So the limit is the best we can do.</p>
               
               <pre><code>const runeSize = 4</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="EmptyOp" data-name="EmptyOp">
               <h3>
                  EmptyOp
                  <span class="badge type-badge">type</span>
                  <a href="#EmptyOp" class="anchor" title="Link to EmptyOp">#</a>
               </h3>
               
               <p>An EmptyOp specifies a kind or mixture of zero-width assertions.</p>
               
               <pre><code>type EmptyOp uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ErrorCode" data-name="ErrorCode">
               <h3>
                  ErrorCode
                  <span class="badge type-badge">type</span>
                  <a href="#ErrorCode" class="anchor" title="Link to ErrorCode">#</a>
               </h3>
               
               <p>An ErrorCode describes a failure to parse a regular expression.</p>
               
               <pre><code>type ErrorCode string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Flags" data-name="Flags">
               <h3>
                  Flags
                  <span class="badge type-badge">type</span>
                  <a href="#Flags" class="anchor" title="Link to Flags">#</a>
               </h3>
               
               <p>Flags control the behavior of the parser and record information about regexp context.</p>
               
               <pre><code>type Flags uint16</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="InstOp" data-name="InstOp">
               <h3>
                  InstOp
                  <span class="badge type-badge">type</span>
                  <a href="#InstOp" class="anchor" title="Link to InstOp">#</a>
               </h3>
               
               <p>An InstOp is an instruction opcode.</p>
               
               <pre><code>type InstOp uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Op" data-name="Op">
               <h3>
                  Op
                  <span class="badge type-badge">type</span>
                  <a href="#Op" class="anchor" title="Link to Op">#</a>
               </h3>
               
               <p>An Op is a single regular expression operator.</p>
               
               <pre><code>type Op uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="printFlags" data-name="printFlags">
               <h3>
                  printFlags
                  <span class="badge type-badge">type</span>
                  <a href="#printFlags" class="anchor" title="Link to printFlags">#</a>
               </h3>
               
               <p>printFlags is a bit set indicating which flags (including non-capturing parens) to print around a regexp.</p>
               
               <pre><code>type printFlags uint8</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error
                  <span class="badge">struct</span>
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>An Error describes a failure to parse a regular expression
and gives the offending expression.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Error struct {
Code ErrorCode
Expr string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Inst" data-name="Inst">
               <h3>
                  Inst
                  <span class="badge">struct</span>
                  <a href="#Inst" class="anchor" title="Link to Inst">#</a>
               </h3>
               
               <p>An Inst is a single instruction in a regular expression program.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Inst struct {
Op InstOp
Out uint32
Arg uint32
Rune []rune
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Prog" data-name="Prog">
               <h3>
                  Prog
                  <span class="badge">struct</span>
                  <a href="#Prog" class="anchor" title="Link to Prog">#</a>
               </h3>
               
               <p>A Prog is a compiled regular expression program.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Prog struct {
Inst []Inst
Start int
NumCap int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Regexp" data-name="Regexp">
               <h3>
                  Regexp
                  <span class="badge">struct</span>
                  <a href="#Regexp" class="anchor" title="Link to Regexp">#</a>
               </h3>
               
               <p>A Regexp is a node in a regular expression syntax tree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Regexp struct {
Op Op
Flags Flags
Sub []*Regexp
Sub0 [1]*Regexp
Rune []rune
Rune0 [2]rune
Min int
Max int
Cap int
Name string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="charGroup" data-name="charGroup">
               <h3>
                  charGroup
                  <span class="badge">struct</span>
                  <a href="#charGroup" class="anchor" title="Link to charGroup">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type charGroup struct {
sign int
class []rune
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="compiler" data-name="compiler">
               <h3>
                  compiler
                  <span class="badge">struct</span>
                  <a href="#compiler" class="anchor" title="Link to compiler">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type compiler struct {
p *Prog
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="frag" data-name="frag">
               <h3>
                  frag
                  <span class="badge">struct</span>
                  <a href="#frag" class="anchor" title="Link to frag">#</a>
               </h3>
               
               <p>A frag represents a compiled program fragment.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type frag struct {
i uint32
out patchList
nullable bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="parser" data-name="parser">
               <h3>
                  parser
                  <span class="badge">struct</span>
                  <a href="#parser" class="anchor" title="Link to parser">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type parser struct {
flags Flags
stack []*Regexp
free *Regexp
numCap int
wholeRegexp string
tmpClass []rune
numRegexp int
numRunes int
repeats int64
height map[*Regexp]int
size map[*Regexp]int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="patchList" data-name="patchList">
               <h3>
                  patchList
                  <span class="badge">struct</span>
                  <a href="#patchList" class="anchor" title="Link to patchList">#</a>
               </h3>
               
               <p>A patchList is a list of instruction pointers that need to be filled in (patched).
Because the pointers haven't been filled in yet, we can reuse their storage
to hold the list. It's kind of sleazy, but works well in practice.
See https://swtch.com/~rsc/regexp/regexp1.html for inspiration.
These aren't really pointers: they're integers, so we can reinterpret them
this way without using package unsafe. A value l.head denotes
p.inst[l.head>>1].Out (l.head&1==0) or .Arg (l.head&1==1).
head == 0 denotes the empty list, okay because we start every program
with a fail instruction, so we'll never want to point at its output link.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type patchList struct {
head uint32
tail uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ranges" data-name="ranges">
               <h3>
                  ranges
                  <span class="badge">struct</span>
                  <a href="#ranges" class="anchor" title="Link to ranges">#</a>
               </h3>
               
               <p>ranges implements sort.Interface on a []rune.
The choice of receiver type definition is strange
but avoids an allocation since we already have
a *[]rune.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ranges struct {
p *[]rune
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="CapNames" data-name="CapNames">
               <h3>
                  CapNames 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CapNames" class="anchor" title="Link to CapNames">#</a>
               </h3>
               
               <p>CapNames walks the regexp to find the names of capturing groups.</p>
               
               <pre><code>func (re *Regexp) CapNames() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Compile" data-name="Compile">
               <h3>
                  Compile 
                  <span class="badge">function</span>
                  
                  <a href="#Compile" class="anchor" title="Link to Compile">#</a>
               </h3>
               
               <p>Compile compiles the regexp into a program to be executed.
The regexp should have been simplified already (returned from re.Simplify).</p>
               
               <pre><code>func Compile(re *Regexp) (*Prog, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EmptyOpContext" data-name="EmptyOpContext">
               <h3>
                  EmptyOpContext 
                  <span class="badge">function</span>
                  
                  <a href="#EmptyOpContext" class="anchor" title="Link to EmptyOpContext">#</a>
               </h3>
               
               <p>EmptyOpContext returns the zero-width assertions
satisfied at the position between the runes r1 and r2.
Passing r1 == -1 indicates that the position is
at the beginning of the text.
Passing r2 == -1 indicates that the position is
at the end of the text.</p>
               
               <pre><code>func EmptyOpContext(r1 rune, r2 rune) EmptyOp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Equal" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Equal" class="anchor" title="Link to Equal">#</a>
               </h3>
               
               <p>Equal reports whether x and y have identical structure.</p>
               
               <pre><code>func (x *Regexp) Equal(y *Regexp) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *Error) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsWordChar" data-name="IsWordChar">
               <h3>
                  IsWordChar 
                  <span class="badge">function</span>
                  
                  <a href="#IsWordChar" class="anchor" title="Link to IsWordChar">#</a>
               </h3>
               
               <p>IsWordChar reports whether r is considered a “word character”
during the evaluation of the \b and \B zero-width assertions.
These assertions are ASCII-only: the word characters are [A-Za-z0-9_].</p>
               
               <pre><code>func IsWordChar(r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code>func (ra ranges) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code>func (ra ranges) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MatchEmptyWidth" data-name="MatchEmptyWidth">
               <h3>
                  MatchEmptyWidth 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MatchEmptyWidth" class="anchor" title="Link to MatchEmptyWidth">#</a>
               </h3>
               
               <p>MatchEmptyWidth reports whether the instruction matches
an empty string between the runes before and after.
It should only be called when i.Op == [InstEmptyWidth].</p>
               
               <pre><code>func (i *Inst) MatchEmptyWidth(before rune, after rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MatchRune" data-name="MatchRune">
               <h3>
                  MatchRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MatchRune" class="anchor" title="Link to MatchRune">#</a>
               </h3>
               
               <p>MatchRune reports whether the instruction matches (and consumes) r.
It should only be called when i.Op == [InstRune].</p>
               
               <pre><code>func (i *Inst) MatchRune(r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MatchRunePos" data-name="MatchRunePos">
               <h3>
                  MatchRunePos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MatchRunePos" class="anchor" title="Link to MatchRunePos">#</a>
               </h3>
               
               <p>MatchRunePos checks whether the instruction matches (and consumes) r.
If so, MatchRunePos returns the index of the matching rune pair
(or, when len(i.Rune) == 1, rune singleton).
If not, MatchRunePos returns -1.
MatchRunePos should only be called when i.Op == [InstRune].</p>
               
               <pre><code>func (i *Inst) MatchRunePos(r rune) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MaxCap" data-name="MaxCap">
               <h3>
                  MaxCap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MaxCap" class="anchor" title="Link to MaxCap">#</a>
               </h3>
               
               <p>MaxCap walks the regexp to find the maximum capture index.</p>
               
               <pre><code>func (re *Regexp) MaxCap() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parse" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge">function</span>
                  
                  <a href="#Parse" class="anchor" title="Link to Parse">#</a>
               </h3>
               
               <p>Parse parses a regular expression string s, controlled by the specified
Flags, and returns a regular expression parse tree. The syntax is
described in the top-level comment.</p>
               
               <pre><code>func Parse(s string, flags Flags) (*Regexp, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Prefix" data-name="Prefix">
               <h3>
                  Prefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Prefix" class="anchor" title="Link to Prefix">#</a>
               </h3>
               
               <p>Prefix returns a literal string that all matches for the
regexp must start with. Complete is true if the prefix
is the entire match.</p>
               
               <pre><code>func (p *Prog) Prefix() (prefix string, complete bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Simplify" data-name="Simplify">
               <h3>
                  Simplify 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Simplify" class="anchor" title="Link to Simplify">#</a>
               </h3>
               
               <p>Simplify returns a regexp equivalent to re but without counted repetitions
and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/.
The resulting regexp will execute correctly but its string representation
will not produce the same parse tree, because capturing parentheses
may have been duplicated or removed. For example, the simplified form
for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1.
The returned regexp may share structure with or be the original.</p>
               
               <pre><code>func (re *Regexp) Simplify() *Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StartCond" data-name="StartCond">
               <h3>
                  StartCond 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StartCond" class="anchor" title="Link to StartCond">#</a>
               </h3>
               
               <p>StartCond returns the leading empty-width conditions that must
be true in any match. It returns ^EmptyOp(0) if no matches are possible.</p>
               
               <pre><code>func (p *Prog) StartCond() EmptyOp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (e ErrorCode) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (re *Regexp) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (i InstOp) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (i Op) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (i *Inst) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (p *Prog) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code>func (ra ranges) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addSpan" data-name="addSpan">
               <h3>
                  addSpan 
                  <span class="badge">function</span>
                  
                  <a href="#addSpan" class="anchor" title="Link to addSpan">#</a>
               </h3>
               
               <p>addSpan enables the flags f around start..last,
by setting flags[start] = f and flags[last] = flagOff.</p>
               
               <pre><code>func addSpan(start *Regexp, last *Regexp, f printFlags, flags *map[*Regexp]printFlags)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="alt" data-name="alt">
               <h3>
                  alt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#alt" class="anchor" title="Link to alt">#</a>
               </h3>
               
               <pre><code>func (c *compiler) alt(f1 frag, f2 frag) frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="alternate" data-name="alternate">
               <h3>
                  alternate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#alternate" class="anchor" title="Link to alternate">#</a>
               </h3>
               
               <p>alternate replaces the top of the stack (above the topmost '(') with its alternation.</p>
               
               <pre><code>func (p *parser) alternate() *Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="append" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#append" class="anchor" title="Link to append">#</a>
               </h3>
               
               <pre><code>func (l1 patchList) append(p *Prog, l2 patchList) patchList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendClass" data-name="appendClass">
               <h3>
                  appendClass 
                  <span class="badge">function</span>
                  
                  <a href="#appendClass" class="anchor" title="Link to appendClass">#</a>
               </h3>
               
               <p>appendClass returns the result of appending the class x to the class r.
It assume x is clean.</p>
               
               <pre><code>func appendClass(r []rune, x []rune) []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendFoldedClass" data-name="appendFoldedClass">
               <h3>
                  appendFoldedClass 
                  <span class="badge">function</span>
                  
                  <a href="#appendFoldedClass" class="anchor" title="Link to appendFoldedClass">#</a>
               </h3>
               
               <p>appendFoldedClass returns the result of appending the case folding of the class x to the class r.</p>
               
               <pre><code>func appendFoldedClass(r []rune, x []rune) []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendFoldedRange" data-name="appendFoldedRange">
               <h3>
                  appendFoldedRange 
                  <span class="badge">function</span>
                  
                  <a href="#appendFoldedRange" class="anchor" title="Link to appendFoldedRange">#</a>
               </h3>
               
               <p>appendFoldedRange returns the result of appending the range lo-hi
and its case folding-equivalent runes to the class r.</p>
               
               <pre><code>func appendFoldedRange(r []rune, lo rune, hi rune) []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendGroup" data-name="appendGroup">
               <h3>
                  appendGroup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#appendGroup" class="anchor" title="Link to appendGroup">#</a>
               </h3>
               
               <pre><code>func (p *parser) appendGroup(r []rune, g charGroup) []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendLiteral" data-name="appendLiteral">
               <h3>
                  appendLiteral 
                  <span class="badge">function</span>
                  
                  <a href="#appendLiteral" class="anchor" title="Link to appendLiteral">#</a>
               </h3>
               
               <p>appendLiteral returns the result of appending the literal x to the class r.</p>
               
               <pre><code>func appendLiteral(r []rune, x rune, flags Flags) []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendNegatedClass" data-name="appendNegatedClass">
               <h3>
                  appendNegatedClass 
                  <span class="badge">function</span>
                  
                  <a href="#appendNegatedClass" class="anchor" title="Link to appendNegatedClass">#</a>
               </h3>
               
               <p>appendNegatedClass returns the result of appending the negation of the class x to the class r.
It assumes x is clean.</p>
               
               <pre><code>func appendNegatedClass(r []rune, x []rune) []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendNegatedTable" data-name="appendNegatedTable">
               <h3>
                  appendNegatedTable 
                  <span class="badge">function</span>
                  
                  <a href="#appendNegatedTable" class="anchor" title="Link to appendNegatedTable">#</a>
               </h3>
               
               <p>appendNegatedTable returns the result of appending the negation of x to the class r.</p>
               
               <pre><code>func appendNegatedTable(r []rune, x *unicode.RangeTable) []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendRange" data-name="appendRange">
               <h3>
                  appendRange 
                  <span class="badge">function</span>
                  
                  <a href="#appendRange" class="anchor" title="Link to appendRange">#</a>
               </h3>
               
               <p>appendRange returns the result of appending the range lo-hi to the class r.</p>
               
               <pre><code>func appendRange(r []rune, lo rune, hi rune) []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendTable" data-name="appendTable">
               <h3>
                  appendTable 
                  <span class="badge">function</span>
                  
                  <a href="#appendTable" class="anchor" title="Link to appendTable">#</a>
               </h3>
               
               <p>appendTable returns the result of appending x to the class r.</p>
               
               <pre><code>func appendTable(r []rune, x *unicode.RangeTable) []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bw" data-name="bw">
               <h3>
                  bw 
                  <span class="badge">function</span>
                  
                  <a href="#bw" class="anchor" title="Link to bw">#</a>
               </h3>
               
               <pre><code>func bw(b *strings.Builder, args ...string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="calcFlags" data-name="calcFlags">
               <h3>
                  calcFlags 
                  <span class="badge">function</span>
                  
                  <a href="#calcFlags" class="anchor" title="Link to calcFlags">#</a>
               </h3>
               
               <p>calcFlags calculates the flags to print around each subexpression in re,
storing that information in (*flags)[sub] for each affected subexpression.
The first time an entry needs to be written to *flags, calcFlags allocates the map.
calcFlags also calculates the flags that must be active or can't be active
around re and returns those flags.</p>
               
               <pre><code>func calcFlags(re *Regexp, flags *map[*Regexp]printFlags) (must printFlags, cant printFlags)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="calcHeight" data-name="calcHeight">
               <h3>
                  calcHeight 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#calcHeight" class="anchor" title="Link to calcHeight">#</a>
               </h3>
               
               <pre><code>func (p *parser) calcHeight(re *Regexp, force bool) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="calcSize" data-name="calcSize">
               <h3>
                  calcSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#calcSize" class="anchor" title="Link to calcSize">#</a>
               </h3>
               
               <pre><code>func (p *parser) calcSize(re *Regexp, force bool) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cap" data-name="cap">
               <h3>
                  cap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cap" class="anchor" title="Link to cap">#</a>
               </h3>
               
               <pre><code>func (c *compiler) cap(arg uint32) frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="capNames" data-name="capNames">
               <h3>
                  capNames 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#capNames" class="anchor" title="Link to capNames">#</a>
               </h3>
               
               <pre><code>func (re *Regexp) capNames(names []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cat" data-name="cat">
               <h3>
                  cat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cat" class="anchor" title="Link to cat">#</a>
               </h3>
               
               <pre><code>func (c *compiler) cat(f1 frag, f2 frag) frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkHeight" data-name="checkHeight">
               <h3>
                  checkHeight 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkHeight" class="anchor" title="Link to checkHeight">#</a>
               </h3>
               
               <pre><code>func (p *parser) checkHeight(re *Regexp)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkLimits" data-name="checkLimits">
               <h3>
                  checkLimits 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkLimits" class="anchor" title="Link to checkLimits">#</a>
               </h3>
               
               <pre><code>func (p *parser) checkLimits(re *Regexp)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkSize" data-name="checkSize">
               <h3>
                  checkSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkSize" class="anchor" title="Link to checkSize">#</a>
               </h3>
               
               <pre><code>func (p *parser) checkSize(re *Regexp)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkUTF8" data-name="checkUTF8">
               <h3>
                  checkUTF8 
                  <span class="badge">function</span>
                  
                  <a href="#checkUTF8" class="anchor" title="Link to checkUTF8">#</a>
               </h3>
               
               <pre><code>func checkUTF8(s string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanAlt" data-name="cleanAlt">
               <h3>
                  cleanAlt 
                  <span class="badge">function</span>
                  
                  <a href="#cleanAlt" class="anchor" title="Link to cleanAlt">#</a>
               </h3>
               
               <p>cleanAlt cleans re for eventual inclusion in an alternation.</p>
               
               <pre><code>func cleanAlt(re *Regexp)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanClass" data-name="cleanClass">
               <h3>
                  cleanClass 
                  <span class="badge">function</span>
                  
                  <a href="#cleanClass" class="anchor" title="Link to cleanClass">#</a>
               </h3>
               
               <p>cleanClass sorts the ranges (pairs of elements of r),
merges them, and eliminates duplicates.</p>
               
               <pre><code>func cleanClass(rp *[]rune) []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="collapse" data-name="collapse">
               <h3>
                  collapse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#collapse" class="anchor" title="Link to collapse">#</a>
               </h3>
               
               <p>collapse returns the result of applying op to sub.
If sub contains op nodes, they all get hoisted up
so that there is never a concat of a concat or an
alternate of an alternate.</p>
               
               <pre><code>func (p *parser) collapse(subs []*Regexp, op Op) *Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="compile" data-name="compile">
               <h3>
                  compile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#compile" class="anchor" title="Link to compile">#</a>
               </h3>
               
               <pre><code>func (c *compiler) compile(re *Regexp) frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="concat" data-name="concat">
               <h3>
                  concat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#concat" class="anchor" title="Link to concat">#</a>
               </h3>
               
               <p>concat replaces the top of the stack (above the topmost '|' or '(') with its concatenation.</p>
               
               <pre><code>func (p *parser) concat() *Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dumpInst" data-name="dumpInst">
               <h3>
                  dumpInst 
                  <span class="badge">function</span>
                  
                  <a href="#dumpInst" class="anchor" title="Link to dumpInst">#</a>
               </h3>
               
               <pre><code>func dumpInst(b *strings.Builder, i *Inst)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dumpProg" data-name="dumpProg">
               <h3>
                  dumpProg 
                  <span class="badge">function</span>
                  
                  <a href="#dumpProg" class="anchor" title="Link to dumpProg">#</a>
               </h3>
               
               <pre><code>func dumpProg(b *strings.Builder, p *Prog)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="empty" data-name="empty">
               <h3>
                  empty 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#empty" class="anchor" title="Link to empty">#</a>
               </h3>
               
               <pre><code>func (c *compiler) empty(op EmptyOp) frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="escape" data-name="escape">
               <h3>
                  escape 
                  <span class="badge">function</span>
                  
                  <a href="#escape" class="anchor" title="Link to escape">#</a>
               </h3>
               
               <pre><code>func escape(b *strings.Builder, r rune, force bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="factor" data-name="factor">
               <h3>
                  factor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#factor" class="anchor" title="Link to factor">#</a>
               </h3>
               
               <p>factor factors common prefixes from the alternation list sub.
It returns a replacement list that reuses the same storage and
frees (passes to p.reuse) any removed *Regexps.
For example,
ABC|ABD|AEF|BCX|BCY
simplifies by literal prefix extraction to
A(B(C|D)|EF)|BC(X|Y)
which simplifies by character class introduction to
A(B[CD]|EF)|BC[XY]</p>
               
               <pre><code>func (p *parser) factor(sub []*Regexp) []*Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fail" data-name="fail">
               <h3>
                  fail 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fail" class="anchor" title="Link to fail">#</a>
               </h3>
               
               <pre><code>func (c *compiler) fail() frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inCharClass" data-name="inCharClass">
               <h3>
                  inCharClass 
                  <span class="badge">function</span>
                  
                  <a href="#inCharClass" class="anchor" title="Link to inCharClass">#</a>
               </h3>
               
               <p>inCharClass reports whether r is in the class.
It assumes the class has been cleaned by cleanClass.</p>
               
               <pre><code>func inCharClass(r rune, class []rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func (c *compiler) init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inst" data-name="inst">
               <h3>
                  inst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#inst" class="anchor" title="Link to inst">#</a>
               </h3>
               
               <pre><code>func (c *compiler) inst(op InstOp) frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isCharClass" data-name="isCharClass">
               <h3>
                  isCharClass 
                  <span class="badge">function</span>
                  
                  <a href="#isCharClass" class="anchor" title="Link to isCharClass">#</a>
               </h3>
               
               <p>can this be represented as a character class?
single-rune literal string, char class, ., and .|\n.</p>
               
               <pre><code>func isCharClass(re *Regexp) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValidCaptureName" data-name="isValidCaptureName">
               <h3>
                  isValidCaptureName 
                  <span class="badge">function</span>
                  
                  <a href="#isValidCaptureName" class="anchor" title="Link to isValidCaptureName">#</a>
               </h3>
               
               <p>isValidCaptureName reports whether name
is a valid capture name: [A-Za-z0-9_]+.
PCRE limits names to 32 bytes.
Python rejects names starting with digits.
We don't enforce either of those.</p>
               
               <pre><code>func isValidCaptureName(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isalnum" data-name="isalnum">
               <h3>
                  isalnum 
                  <span class="badge">function</span>
                  
                  <a href="#isalnum" class="anchor" title="Link to isalnum">#</a>
               </h3>
               
               <pre><code>func isalnum(c rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="leadingRegexp" data-name="leadingRegexp">
               <h3>
                  leadingRegexp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#leadingRegexp" class="anchor" title="Link to leadingRegexp">#</a>
               </h3>
               
               <p>leadingRegexp returns the leading regexp that re begins with.
The regexp refers to storage in re or its children.</p>
               
               <pre><code>func (p *parser) leadingRegexp(re *Regexp) *Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="leadingString" data-name="leadingString">
               <h3>
                  leadingString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#leadingString" class="anchor" title="Link to leadingString">#</a>
               </h3>
               
               <p>leadingString returns the leading literal string that re begins with.
The string refers to storage in re or its children.</p>
               
               <pre><code>func (p *parser) leadingString(re *Regexp) ([]rune, Flags)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="literal" data-name="literal">
               <h3>
                  literal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#literal" class="anchor" title="Link to literal">#</a>
               </h3>
               
               <p>literal pushes a literal regexp for the rune r on the stack.</p>
               
               <pre><code>func (p *parser) literal(r rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="literalRegexp" data-name="literalRegexp">
               <h3>
                  literalRegexp 
                  <span class="badge">function</span>
                  
                  <a href="#literalRegexp" class="anchor" title="Link to literalRegexp">#</a>
               </h3>
               
               <pre><code>func literalRegexp(s string, flags Flags) *Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loop" data-name="loop">
               <h3>
                  loop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loop" class="anchor" title="Link to loop">#</a>
               </h3>
               
               <p>loop returns the fragment for the main loop of a plus or star.
For plus, it can be used after changing the entry to f1.i.
For star, it can be used directly when f1 can't match an empty string.
(When f1 can match an empty string, f1* must be implemented as (f1+)?
to get the priority match order correct.)</p>
               
               <pre><code>func (c *compiler) loop(f1 frag, nongreedy bool) frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makePatchList" data-name="makePatchList">
               <h3>
                  makePatchList 
                  <span class="badge">function</span>
                  
                  <a href="#makePatchList" class="anchor" title="Link to makePatchList">#</a>
               </h3>
               
               <pre><code>func makePatchList(n uint32) patchList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchRune" data-name="matchRune">
               <h3>
                  matchRune 
                  <span class="badge">function</span>
                  
                  <a href="#matchRune" class="anchor" title="Link to matchRune">#</a>
               </h3>
               
               <p>does re match r?</p>
               
               <pre><code>func matchRune(re *Regexp, r rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maybeConcat" data-name="maybeConcat">
               <h3>
                  maybeConcat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maybeConcat" class="anchor" title="Link to maybeConcat">#</a>
               </h3>
               
               <p>maybeConcat implements incremental concatenation
of literal runes into string nodes. The parser calls this
before each push, so only the top fragment of the stack
might need processing. Since this is called before a push,
the topmost literal is no longer subject to operators like *
(Otherwise ab* would turn into (ab)*.)
If r >= 0 and there's a node left over, maybeConcat uses it
to push r with the given flags.
maybeConcat reports whether r was pushed.</p>
               
               <pre><code>func (p *parser) maybeConcat(r rune, flags Flags) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mergeCharClass" data-name="mergeCharClass">
               <h3>
                  mergeCharClass 
                  <span class="badge">function</span>
                  
                  <a href="#mergeCharClass" class="anchor" title="Link to mergeCharClass">#</a>
               </h3>
               
               <p>mergeCharClass makes dst = dst|src.
The caller must ensure that dst.Op >= src.Op,
to reduce the amount of copying.</p>
               
               <pre><code>func mergeCharClass(dst *Regexp, src *Regexp)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="minFoldRune" data-name="minFoldRune">
               <h3>
                  minFoldRune 
                  <span class="badge">function</span>
                  
                  <a href="#minFoldRune" class="anchor" title="Link to minFoldRune">#</a>
               </h3>
               
               <p>minFoldRune returns the minimum rune fold-equivalent to r.</p>
               
               <pre><code>func minFoldRune(r rune) rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="negateClass" data-name="negateClass">
               <h3>
                  negateClass 
                  <span class="badge">function</span>
                  
                  <a href="#negateClass" class="anchor" title="Link to negateClass">#</a>
               </h3>
               
               <p>negateClass overwrites r and returns r's negation.
It assumes the class r is already clean.</p>
               
               <pre><code>func negateClass(r []rune) []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newRegexp" data-name="newRegexp">
               <h3>
                  newRegexp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newRegexp" class="anchor" title="Link to newRegexp">#</a>
               </h3>
               
               <pre><code>func (p *parser) newRegexp(op Op) *Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextRune" data-name="nextRune">
               <h3>
                  nextRune 
                  <span class="badge">function</span>
                  
                  <a href="#nextRune" class="anchor" title="Link to nextRune">#</a>
               </h3>
               
               <pre><code>func nextRune(s string) (c rune, t string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nop" data-name="nop">
               <h3>
                  nop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nop" class="anchor" title="Link to nop">#</a>
               </h3>
               
               <pre><code>func (c *compiler) nop() frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="op" data-name="op">
               <h3>
                  op 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#op" class="anchor" title="Link to op">#</a>
               </h3>
               
               <p>op returns i.Op but merges all the Rune special cases into InstRune</p>
               
               <pre><code>func (i *Inst) op() InstOp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="op" data-name="op">
               <h3>
                  op 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#op" class="anchor" title="Link to op">#</a>
               </h3>
               
               <p>op pushes a regexp with the given op onto the stack
and returns that regexp.</p>
               
               <pre><code>func (p *parser) op(op Op) *Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parse" data-name="parse">
               <h3>
                  parse 
                  <span class="badge">function</span>
                  
                  <a href="#parse" class="anchor" title="Link to parse">#</a>
               </h3>
               
               <pre><code>func parse(s string, flags Flags) (_ *Regexp, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseClass" data-name="parseClass">
               <h3>
                  parseClass 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseClass" class="anchor" title="Link to parseClass">#</a>
               </h3>
               
               <p>parseClass parses a character class at the beginning of s
and pushes it onto the parse stack.</p>
               
               <pre><code>func (p *parser) parseClass(s string) (rest string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseClassChar" data-name="parseClassChar">
               <h3>
                  parseClassChar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseClassChar" class="anchor" title="Link to parseClassChar">#</a>
               </h3>
               
               <p>parseClassChar parses a character class character at the beginning of s
and returns it.</p>
               
               <pre><code>func (p *parser) parseClassChar(s string, wholeClass string) (r rune, rest string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseEscape" data-name="parseEscape">
               <h3>
                  parseEscape 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseEscape" class="anchor" title="Link to parseEscape">#</a>
               </h3>
               
               <p>parseEscape parses an escape sequence at the beginning of s
and returns the rune.</p>
               
               <pre><code>func (p *parser) parseEscape(s string) (r rune, rest string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseInt" data-name="parseInt">
               <h3>
                  parseInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseInt" class="anchor" title="Link to parseInt">#</a>
               </h3>
               
               <p>parseInt parses a decimal integer.</p>
               
               <pre><code>func (p *parser) parseInt(s string) (n int, rest string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseNamedClass" data-name="parseNamedClass">
               <h3>
                  parseNamedClass 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseNamedClass" class="anchor" title="Link to parseNamedClass">#</a>
               </h3>
               
               <p>parseNamedClass parses a leading POSIX named character class like [:alnum:]
from the beginning of s. If one is present, it appends the characters to r
and returns the new slice r and the remainder of the string.</p>
               
               <pre><code>func (p *parser) parseNamedClass(s string, r []rune) (out []rune, rest string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePerlClassEscape" data-name="parsePerlClassEscape">
               <h3>
                  parsePerlClassEscape 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parsePerlClassEscape" class="anchor" title="Link to parsePerlClassEscape">#</a>
               </h3>
               
               <p>parsePerlClassEscape parses a leading Perl character class escape like \d
from the beginning of s. If one is present, it appends the characters to r
and returns the new slice r and the remainder of the string.</p>
               
               <pre><code>func (p *parser) parsePerlClassEscape(s string, r []rune) (out []rune, rest string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePerlFlags" data-name="parsePerlFlags">
               <h3>
                  parsePerlFlags 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parsePerlFlags" class="anchor" title="Link to parsePerlFlags">#</a>
               </h3>
               
               <p>parsePerlFlags parses a Perl flag setting or non-capturing group or both,
like (?i) or (?: or (?i:.  It removes the prefix from s and updates the parse state.
The caller must have ensured that s begins with "(?".</p>
               
               <pre><code>func (p *parser) parsePerlFlags(s string) (rest string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseRepeat" data-name="parseRepeat">
               <h3>
                  parseRepeat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseRepeat" class="anchor" title="Link to parseRepeat">#</a>
               </h3>
               
               <p>parseRepeat parses {min} (max=min) or {min,} (max=-1) or {min,max}.
If s is not of that form, it returns ok == false.
If s has the right form but the values are too big, it returns min == -1, ok == true.</p>
               
               <pre><code>func (p *parser) parseRepeat(s string) (min int, max int, rest string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseRightParen" data-name="parseRightParen">
               <h3>
                  parseRightParen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseRightParen" class="anchor" title="Link to parseRightParen">#</a>
               </h3>
               
               <p>parseRightParen handles a ) in the input.</p>
               
               <pre><code>func (p *parser) parseRightParen() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseUnicodeClass" data-name="parseUnicodeClass">
               <h3>
                  parseUnicodeClass 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseUnicodeClass" class="anchor" title="Link to parseUnicodeClass">#</a>
               </h3>
               
               <p>parseUnicodeClass parses a leading Unicode character class like \p{Han}
from the beginning of s. If one is present, it appends the characters to r
and returns the new slice r and the remainder of the string.</p>
               
               <pre><code>func (p *parser) parseUnicodeClass(s string, r []rune) (out []rune, rest string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseVerticalBar" data-name="parseVerticalBar">
               <h3>
                  parseVerticalBar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseVerticalBar" class="anchor" title="Link to parseVerticalBar">#</a>
               </h3>
               
               <p>parseVerticalBar handles a | in the input.</p>
               
               <pre><code>func (p *parser) parseVerticalBar()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="patch" data-name="patch">
               <h3>
                  patch 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#patch" class="anchor" title="Link to patch">#</a>
               </h3>
               
               <pre><code>func (l patchList) patch(p *Prog, val uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="plus" data-name="plus">
               <h3>
                  plus 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#plus" class="anchor" title="Link to plus">#</a>
               </h3>
               
               <pre><code>func (c *compiler) plus(f1 frag, nongreedy bool) frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="push" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#push" class="anchor" title="Link to push">#</a>
               </h3>
               
               <p>push pushes the regexp re onto the parse stack and returns the regexp.</p>
               
               <pre><code>func (p *parser) push(re *Regexp) *Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="quest" data-name="quest">
               <h3>
                  quest 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#quest" class="anchor" title="Link to quest">#</a>
               </h3>
               
               <pre><code>func (c *compiler) quest(f1 frag, nongreedy bool) frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeLeadingRegexp" data-name="removeLeadingRegexp">
               <h3>
                  removeLeadingRegexp 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#removeLeadingRegexp" class="anchor" title="Link to removeLeadingRegexp">#</a>
               </h3>
               
               <p>removeLeadingRegexp removes the leading regexp in re.
It returns the replacement for re.
If reuse is true, it passes the removed regexp (if no longer needed) to p.reuse.</p>
               
               <pre><code>func (p *parser) removeLeadingRegexp(re *Regexp, reuse bool) *Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeLeadingString" data-name="removeLeadingString">
               <h3>
                  removeLeadingString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#removeLeadingString" class="anchor" title="Link to removeLeadingString">#</a>
               </h3>
               
               <p>removeLeadingString removes the first n leading runes
from the beginning of re. It returns the replacement for re.</p>
               
               <pre><code>func (p *parser) removeLeadingString(re *Regexp, n int) *Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="repeat" data-name="repeat">
               <h3>
                  repeat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#repeat" class="anchor" title="Link to repeat">#</a>
               </h3>
               
               <p>repeat replaces the top stack element with itself repeated according to op, min, max.
before is the regexp suffix starting at the repetition operator.
after is the regexp suffix following after the repetition operator.
repeat returns an updated 'after' and an error, if any.</p>
               
               <pre><code>func (p *parser) repeat(op Op, min int, max int, before string, after string, lastRepeat string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="repeatIsValid" data-name="repeatIsValid">
               <h3>
                  repeatIsValid 
                  <span class="badge">function</span>
                  
                  <a href="#repeatIsValid" class="anchor" title="Link to repeatIsValid">#</a>
               </h3>
               
               <p>repeatIsValid reports whether the repetition re is valid.
Valid means that the combination of the top-level repetition
and any inner repetitions does not exceed n copies of the
innermost thing.
This function rewalks the regexp tree and is called for every repetition,
so we have to worry about inducing quadratic behavior in the parser.
We avoid this by only calling repeatIsValid when min or max >= 2.
In that case the depth of any >= 2 nesting can only get to 9 without
triggering a parse error, so each subtree can only be rewalked 9 times.</p>
               
               <pre><code>func repeatIsValid(re *Regexp, n int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reuse" data-name="reuse">
               <h3>
                  reuse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reuse" class="anchor" title="Link to reuse">#</a>
               </h3>
               
               <pre><code>func (p *parser) reuse(re *Regexp)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rune" data-name="rune">
               <h3>
                  rune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rune" class="anchor" title="Link to rune">#</a>
               </h3>
               
               <pre><code>func (c *compiler) rune(r []rune, flags Flags) frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="simplify1" data-name="simplify1">
               <h3>
                  simplify1 
                  <span class="badge">function</span>
                  
                  <a href="#simplify1" class="anchor" title="Link to simplify1">#</a>
               </h3>
               
               <p>simplify1 implements Simplify for the unary OpStar,
OpPlus, and OpQuest operators. It returns the simple regexp
equivalent to
Regexp{Op: op, Flags: flags, Sub: {sub}}
under the assumption that sub is already simple, and
without first allocating that structure. If the regexp
to be returned turns out to be equivalent to re, simplify1
returns re instead.
simplify1 is factored out of Simplify because the implementation
for other operators generates these unary expressions.
Letting them call simplify1 makes sure the expressions they
generate are simple.</p>
               
               <pre><code>func simplify1(op Op, flags Flags, sub *Regexp, re *Regexp) *Regexp</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skipNop" data-name="skipNop">
               <h3>
                  skipNop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#skipNop" class="anchor" title="Link to skipNop">#</a>
               </h3>
               
               <p>skipNop follows any no-op or capturing instructions.</p>
               
               <pre><code>func (p *Prog) skipNop(pc uint32) *Inst</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="star" data-name="star">
               <h3>
                  star 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#star" class="anchor" title="Link to star">#</a>
               </h3>
               
               <pre><code>func (c *compiler) star(f1 frag, nongreedy bool) frag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="swapVerticalBar" data-name="swapVerticalBar">
               <h3>
                  swapVerticalBar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#swapVerticalBar" class="anchor" title="Link to swapVerticalBar">#</a>
               </h3>
               
               <p>If the top of the stack is an element followed by an opVerticalBar
swapVerticalBar swaps the two and returns true.
Otherwise it returns false.</p>
               
               <pre><code>func (p *parser) swapVerticalBar() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="u32" data-name="u32">
               <h3>
                  u32 
                  <span class="badge">function</span>
                  
                  <a href="#u32" class="anchor" title="Link to u32">#</a>
               </h3>
               
               <pre><code>func u32(i uint32) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unhex" data-name="unhex">
               <h3>
                  unhex 
                  <span class="badge">function</span>
                  
                  <a href="#unhex" class="anchor" title="Link to unhex">#</a>
               </h3>
               
               <pre><code>func unhex(c rune) rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unicodeTable" data-name="unicodeTable">
               <h3>
                  unicodeTable 
                  <span class="badge">function</span>
                  
                  <a href="#unicodeTable" class="anchor" title="Link to unicodeTable">#</a>
               </h3>
               
               <p>unicodeTable returns the unicode.RangeTable identified by name
and the table of additional fold-equivalent code points.</p>
               
               <pre><code>func unicodeTable(name string) (*unicode.RangeTable, *unicode.RangeTable)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeRegexp" data-name="writeRegexp">
               <h3>
                  writeRegexp 
                  <span class="badge">function</span>
                  
                  <a href="#writeRegexp" class="anchor" title="Link to writeRegexp">#</a>
               </h3>
               
               <p>writeRegexp writes the Perl syntax for the regular expression re to b.</p>
               
               <pre><code>func writeRegexp(b *strings.Builder, re *Regexp, f printFlags, flags map[*Regexp]printFlags)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>