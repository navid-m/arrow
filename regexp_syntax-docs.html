<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - syntax</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>syntax</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"sort"
"strings"
"unicode"
"unicode/utf8"
"strconv"
"strings"
"unicode"
"unicode/utf8"
"slices"
"strconv"
"strings"
"unicode"
"unicode"
"strconv"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="ClassNL">
               <h3>
                  ClassNL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ClassNL</code></pre>
            </article>
            
            <article class="global" data-name="DotNL">
               <h3>
                  DotNL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const DotNL</code></pre>
            </article>
            
            <article class="global" data-name="EmptyBeginLine">
               <h3>
                  EmptyBeginLine 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EmptyBeginLine EmptyOp = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="EmptyBeginText">
               <h3>
                  EmptyBeginText 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EmptyBeginText</code></pre>
            </article>
            
            <article class="global" data-name="EmptyEndLine">
               <h3>
                  EmptyEndLine 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EmptyEndLine</code></pre>
            </article>
            
            <article class="global" data-name="EmptyEndText">
               <h3>
                  EmptyEndText 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EmptyEndText</code></pre>
            </article>
            
            <article class="global" data-name="EmptyNoWordBoundary">
               <h3>
                  EmptyNoWordBoundary 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EmptyNoWordBoundary</code></pre>
            </article>
            
            <article class="global" data-name="EmptyWordBoundary">
               <h3>
                  EmptyWordBoundary 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EmptyWordBoundary</code></pre>
            </article>
            
            <article class="global" data-name="ErrInternalError">
               <h3>
                  ErrInternalError 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Unexpected error</p>
               
               <pre><code>const ErrInternalError ErrorCode = "regexp/syntax: internal error"</code></pre>
            </article>
            
            <article class="global" data-name="ErrInvalidCharClass">
               <h3>
                  ErrInvalidCharClass 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Parse errors</p>
               
               <pre><code>const ErrInvalidCharClass ErrorCode = "invalid character class"</code></pre>
            </article>
            
            <article class="global" data-name="ErrInvalidCharRange">
               <h3>
                  ErrInvalidCharRange 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrInvalidCharRange ErrorCode = "invalid character class range"</code></pre>
            </article>
            
            <article class="global" data-name="ErrInvalidEscape">
               <h3>
                  ErrInvalidEscape 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrInvalidEscape ErrorCode = "invalid escape sequence"</code></pre>
            </article>
            
            <article class="global" data-name="ErrInvalidNamedCapture">
               <h3>
                  ErrInvalidNamedCapture 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrInvalidNamedCapture ErrorCode = "invalid named capture"</code></pre>
            </article>
            
            <article class="global" data-name="ErrInvalidPerlOp">
               <h3>
                  ErrInvalidPerlOp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrInvalidPerlOp ErrorCode = "invalid or unsupported Perl syntax"</code></pre>
            </article>
            
            <article class="global" data-name="ErrInvalidRepeatOp">
               <h3>
                  ErrInvalidRepeatOp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrInvalidRepeatOp ErrorCode = "invalid nested repetition operator"</code></pre>
            </article>
            
            <article class="global" data-name="ErrInvalidRepeatSize">
               <h3>
                  ErrInvalidRepeatSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrInvalidRepeatSize ErrorCode = "invalid repeat count"</code></pre>
            </article>
            
            <article class="global" data-name="ErrInvalidUTF8">
               <h3>
                  ErrInvalidUTF8 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrInvalidUTF8 ErrorCode = "invalid UTF-8"</code></pre>
            </article>
            
            <article class="global" data-name="ErrLarge">
               <h3>
                  ErrLarge 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrLarge ErrorCode = "expression too large"</code></pre>
            </article>
            
            <article class="global" data-name="ErrMissingBracket">
               <h3>
                  ErrMissingBracket 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrMissingBracket ErrorCode = "missing closing ]"</code></pre>
            </article>
            
            <article class="global" data-name="ErrMissingParen">
               <h3>
                  ErrMissingParen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrMissingParen ErrorCode = "missing closing )"</code></pre>
            </article>
            
            <article class="global" data-name="ErrMissingRepeatArgument">
               <h3>
                  ErrMissingRepeatArgument 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrMissingRepeatArgument ErrorCode = "missing argument to repetition operator"</code></pre>
            </article>
            
            <article class="global" data-name="ErrNestingDepth">
               <h3>
                  ErrNestingDepth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrNestingDepth ErrorCode = "expression nests too deeply"</code></pre>
            </article>
            
            <article class="global" data-name="ErrTrailingBackslash">
               <h3>
                  ErrTrailingBackslash 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrTrailingBackslash ErrorCode = "trailing backslash at end of expression"</code></pre>
            </article>
            
            <article class="global" data-name="ErrUnexpectedParen">
               <h3>
                  ErrUnexpectedParen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ErrUnexpectedParen ErrorCode = "unexpected )"</code></pre>
            </article>
            
            <article class="global" data-name="FoldCase">
               <h3>
                  FoldCase 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FoldCase Flags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="InstAlt">
               <h3>
                  InstAlt 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const InstAlt InstOp = iota</code></pre>
            </article>
            
            <article class="global" data-name="InstAltMatch">
               <h3>
                  InstAltMatch 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const InstAltMatch</code></pre>
            </article>
            
            <article class="global" data-name="InstCapture">
               <h3>
                  InstCapture 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const InstCapture</code></pre>
            </article>
            
            <article class="global" data-name="InstEmptyWidth">
               <h3>
                  InstEmptyWidth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const InstEmptyWidth</code></pre>
            </article>
            
            <article class="global" data-name="InstFail">
               <h3>
                  InstFail 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const InstFail</code></pre>
            </article>
            
            <article class="global" data-name="InstMatch">
               <h3>
                  InstMatch 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const InstMatch</code></pre>
            </article>
            
            <article class="global" data-name="InstNop">
               <h3>
                  InstNop 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const InstNop</code></pre>
            </article>
            
            <article class="global" data-name="InstRune">
               <h3>
                  InstRune 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const InstRune</code></pre>
            </article>
            
            <article class="global" data-name="InstRune1">
               <h3>
                  InstRune1 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const InstRune1</code></pre>
            </article>
            
            <article class="global" data-name="InstRuneAny">
               <h3>
                  InstRuneAny 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const InstRuneAny</code></pre>
            </article>
            
            <article class="global" data-name="InstRuneAnyNotNL">
               <h3>
                  InstRuneAnyNotNL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const InstRuneAnyNotNL</code></pre>
            </article>
            
            <article class="global" data-name="Literal">
               <h3>
                  Literal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Literal</code></pre>
            </article>
            
            <article class="global" data-name="MatchNL">
               <h3>
                  MatchNL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MatchNL = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="NonGreedy">
               <h3>
                  NonGreedy 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NonGreedy</code></pre>
            </article>
            
            <article class="global" data-name="OneLine">
               <h3>
                  OneLine 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OneLine</code></pre>
            </article>
            
            <article class="global" data-name="OpAlternate">
               <h3>
                  OpAlternate 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpAlternate</code></pre>
            </article>
            
            <article class="global" data-name="OpAnyChar">
               <h3>
                  OpAnyChar 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpAnyChar</code></pre>
            </article>
            
            <article class="global" data-name="OpAnyCharNotNL">
               <h3>
                  OpAnyCharNotNL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpAnyCharNotNL</code></pre>
            </article>
            
            <article class="global" data-name="OpBeginLine">
               <h3>
                  OpBeginLine 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpBeginLine</code></pre>
            </article>
            
            <article class="global" data-name="OpBeginText">
               <h3>
                  OpBeginText 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpBeginText</code></pre>
            </article>
            
            <article class="global" data-name="OpCapture">
               <h3>
                  OpCapture 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpCapture</code></pre>
            </article>
            
            <article class="global" data-name="OpCharClass">
               <h3>
                  OpCharClass 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpCharClass</code></pre>
            </article>
            
            <article class="global" data-name="OpConcat">
               <h3>
                  OpConcat 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpConcat</code></pre>
            </article>
            
            <article class="global" data-name="OpEmptyMatch">
               <h3>
                  OpEmptyMatch 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpEmptyMatch</code></pre>
            </article>
            
            <article class="global" data-name="OpEndLine">
               <h3>
                  OpEndLine 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpEndLine</code></pre>
            </article>
            
            <article class="global" data-name="OpEndText">
               <h3>
                  OpEndText 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpEndText</code></pre>
            </article>
            
            <article class="global" data-name="OpLiteral">
               <h3>
                  OpLiteral 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpLiteral</code></pre>
            </article>
            
            <article class="global" data-name="OpNoMatch">
               <h3>
                  OpNoMatch 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpNoMatch Op = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="OpNoWordBoundary">
               <h3>
                  OpNoWordBoundary 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpNoWordBoundary</code></pre>
            </article>
            
            <article class="global" data-name="OpPlus">
               <h3>
                  OpPlus 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpPlus</code></pre>
            </article>
            
            <article class="global" data-name="OpQuest">
               <h3>
                  OpQuest 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpQuest</code></pre>
            </article>
            
            <article class="global" data-name="OpRepeat">
               <h3>
                  OpRepeat 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpRepeat</code></pre>
            </article>
            
            <article class="global" data-name="OpStar">
               <h3>
                  OpStar 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpStar</code></pre>
            </article>
            
            <article class="global" data-name="OpWordBoundary">
               <h3>
                  OpWordBoundary 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const OpWordBoundary</code></pre>
            </article>
            
            <article class="global" data-name="POSIX">
               <h3>
                  POSIX 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const POSIX Flags = 0</code></pre>
            </article>
            
            <article class="global" data-name="Perl">
               <h3>
                  Perl 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Perl = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="PerlX">
               <h3>
                  PerlX 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const PerlX</code></pre>
            </article>
            
            <article class="global" data-name="Simple">
               <h3>
                  Simple 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Simple</code></pre>
            </article>
            
            <article class="global" data-name="UnicodeGroups">
               <h3>
                  UnicodeGroups 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const UnicodeGroups</code></pre>
            </article>
            
            <article class="global" data-name="WasDollar">
               <h3>
                  WasDollar 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const WasDollar</code></pre>
            </article>
            
            <article class="global" data-name="_Op_index_0">
               <h3>
                  _Op_index_0 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _Op_index_0 = [...]uint8{...}</code></pre>
            </article>
            
            <article class="global" data-name="_Op_name_0">
               <h3>
                  _Op_name_0 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Op_name_0 = "NoMatchEmptyMatchLiteralCharClassAnyCharNotNLAnyCharBeginLineEndLineBeginTextEndTextWordBoundaryNoWordBoundaryCaptureStarPlusQuestRepeatConcatAlternate"</code></pre>
            </article>
            
            <article class="global" data-name="_Op_name_1">
               <h3>
                  _Op_name_1 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _Op_name_1 = "opPseudo"</code></pre>
            </article>
            
            <article class="global" data-name="anyRune">
               <h3>
                  anyRune 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var anyRune = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="anyRuneNotNL">
               <h3>
                  anyRuneNotNL 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var anyRuneNotNL = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="anyTable">
               <h3>
                  anyTable 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var anyTable = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="code1">
               <h3>
                  code1 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code1 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code10">
               <h3>
                  code10 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code10 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code11">
               <h3>
                  code11 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code11 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code12">
               <h3>
                  code12 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code12 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code13">
               <h3>
                  code13 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code13 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code14">
               <h3>
                  code14 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code14 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code15">
               <h3>
                  code15 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code15 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code16">
               <h3>
                  code16 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code16 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code17">
               <h3>
                  code17 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code17 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code2">
               <h3>
                  code2 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code2 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code3">
               <h3>
                  code3 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code3 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code4">
               <h3>
                  code4 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code4 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code5">
               <h3>
                  code5 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code5 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code6">
               <h3>
                  code6 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code6 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code7">
               <h3>
                  code7 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code7 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code8">
               <h3>
                  code8 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code8 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="code9">
               <h3>
                  code9 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var code9 = []rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="flagI">
               <h3>
                  flagI 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagI printFlags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagM">
               <h3>
                  flagM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagM</code></pre>
            </article>
            
            <article class="global" data-name="flagOff">
               <h3>
                  flagOff 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagOff</code></pre>
            </article>
            
            <article class="global" data-name="flagPrec">
               <h3>
                  flagPrec 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagPrec</code></pre>
            </article>
            
            <article class="global" data-name="flagS">
               <h3>
                  flagS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagS</code></pre>
            </article>
            
            <article class="global" data-name="instOpNames">
               <h3>
                  instOpNames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var instOpNames = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="instSize">
               <h3>
                  instSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxSize is the maximum size of a compiled regexp in Insts.
It too is somewhat arbitrarily chosen, but the idea is to be large enough
to allow significant regexps while at the same time small enough that
the compiled form will not take up too much memory.
128 MB is enough for a 3.3 million Inst structures, which roughly
corresponds to a 3.3 MB regexp.</p>
               
               <pre><code>const instSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxFold">
               <h3>
                  maxFold 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxFold = 0x1e943</code></pre>
            </article>
            
            <article class="global" data-name="maxHeight">
               <h3>
                  maxHeight 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxHeight is the maximum height of a regexp parse tree.
It is somewhat arbitrarily chosen, but the idea is to be large enough
that no one will actually hit in real use but at the same time small enough
that recursion on the Regexp tree will not hit the 1GB Go stack limit.
The maximum amount of stack for a single recursive frame is probably
closer to 1kB, so this could potentially be raised, but it seems unlikely
that people have regexps nested even this deeply.
We ran a test on Google's C++ code base and turned up only
a single use case with depth > 100; it had depth 128.
Using depth 1000 should be plenty of margin.
As an optimization, we don't even bother calculating heights
until we've allocated at least maxHeight Regexp structures.</p>
               
               <pre><code>const maxHeight = 1000</code></pre>
            </article>
            
            <article class="global" data-name="maxRunes">
               <h3>
                  maxRunes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxRunes is the maximum number of runes allowed in a regexp tree
counting the runes in all the nodes.
Ignoring character classes p.numRunes is always less than the length of the regexp.
Character classes can make it much larger: each \pL adds 1292 runes.
128 MB is enough for 32M runes, which is over 26k \pL instances.
Note that repetitions do not make copies of the rune slices,
so \pL{1000} is only one rune slice, not 1000.
We could keep a cache of character classes we've seen,
so that all the \pL we see use the same rune list,
but that doesn't remove the problem entirely:
consider something like [\pL01234][\pL01235][\pL01236]...[\pL^&*()].
And because the Rune slice is exposed directly in the Regexp,
there is not an opportunity to change the representation to allow
partial sharing between different character classes.
So the limit is the best we can do.</p>
               
               <pre><code>const maxRunes = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxSize">
               <h3>
                  maxSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxSize is the maximum size of a compiled regexp in Insts.
It too is somewhat arbitrarily chosen, but the idea is to be large enough
to allow significant regexps while at the same time small enough that
the compiled form will not take up too much memory.
128 MB is enough for a 3.3 million Inst structures, which roughly
corresponds to a 3.3 MB regexp.</p>
               
               <pre><code>const maxSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="meta">
               <h3>
                  meta 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const meta = `\.+*?()|[]{}^$`</code></pre>
            </article>
            
            <article class="global" data-name="minFold">
               <h3>
                  minFold 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>minimum and maximum runes involved in folding.
checked during test.</p>
               
               <pre><code>const minFold = 0x0041</code></pre>
            </article>
            
            <article class="global" data-name="negShift">
               <h3>
                  negShift 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const negShift = 5</code></pre>
            </article>
            
            <article class="global" data-name="noMatch">
               <h3>
                  noMatch 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const noMatch = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="opLeftParen">
               <h3>
                  opLeftParen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Pseudo-ops for parsing stack.</p>
               
               <pre><code>const opLeftParen = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="opPseudo">
               <h3>
                  opPseudo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const opPseudo Op = 128</code></pre>
            </article>
            
            <article class="global" data-name="opVerticalBar">
               <h3>
                  opVerticalBar 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Pseudo-ops for parsing stack.</p>
               
               <pre><code>const opVerticalBar</code></pre>
            </article>
            
            <article class="global" data-name="perlGroup">
               <h3>
                  perlGroup 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var perlGroup = map[string]charGroup{...}</code></pre>
            </article>
            
            <article class="global" data-name="posixGroup">
               <h3>
                  posixGroup 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var posixGroup = map[string]charGroup{...}</code></pre>
            </article>
            
            <article class="global" data-name="runeSize">
               <h3>
                  runeSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxRunes is the maximum number of runes allowed in a regexp tree
counting the runes in all the nodes.
Ignoring character classes p.numRunes is always less than the length of the regexp.
Character classes can make it much larger: each \pL adds 1292 runes.
128 MB is enough for 32M runes, which is over 26k \pL instances.
Note that repetitions do not make copies of the rune slices,
so \pL{1000} is only one rune slice, not 1000.
We could keep a cache of character classes we've seen,
so that all the \pL we see use the same rune list,
but that doesn't remove the problem entirely:
consider something like [\pL01234][\pL01235][\pL01236]...[\pL^&*()].
And because the Rune slice is exposed directly in the Regexp,
there is not an opportunity to change the representation to allow
partial sharing between different character classes.
So the limit is the best we can do.</p>
               
               <pre><code>const runeSize = 4</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="EmptyOp">
               <h3>
                  EmptyOp
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An EmptyOp specifies a kind or mixture of zero-width assertions.</p>
               
               <pre><code>type EmptyOp uint8</code></pre>
            </article>
            
            <article class="type" data-name="ErrorCode">
               <h3>
                  ErrorCode
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An ErrorCode describes a failure to parse a regular expression.</p>
               
               <pre><code>type ErrorCode string</code></pre>
            </article>
            
            <article class="type" data-name="Flags">
               <h3>
                  Flags
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Flags control the behavior of the parser and record information about regexp context.</p>
               
               <pre><code>type Flags uint16</code></pre>
            </article>
            
            <article class="type" data-name="InstOp">
               <h3>
                  InstOp
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An InstOp is an instruction opcode.</p>
               
               <pre><code>type InstOp uint8</code></pre>
            </article>
            
            <article class="type" data-name="Op">
               <h3>
                  Op
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An Op is a single regular expression operator.</p>
               
               <pre><code>type Op uint8</code></pre>
            </article>
            
            <article class="type" data-name="printFlags">
               <h3>
                  printFlags
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>printFlags is a bit set indicating which flags (including non-capturing parens) to print around a regexp.</p>
               
               <pre><code>type printFlags uint8</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Error">
               <h3>
                  Error
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Error describes a failure to parse a regular expression
and gives the offending expression.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Error struct {
Code ErrorCode
Expr string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Inst">
               <h3>
                  Inst
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Inst is a single instruction in a regular expression program.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Inst struct {
Op InstOp
Out uint32
Arg uint32
Rune []rune
}</code></pre>
            </article>
            
            <article class="struct" data-name="Prog">
               <h3>
                  Prog
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Prog is a compiled regular expression program.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Prog struct {
Inst []Inst
Start int
NumCap int
}</code></pre>
            </article>
            
            <article class="struct" data-name="Regexp">
               <h3>
                  Regexp
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Regexp is a node in a regular expression syntax tree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Regexp struct {
Op Op
Flags Flags
Sub []*Regexp
Sub0 [1]*Regexp
Rune []rune
Rune0 [2]rune
Min int
Max int
Cap int
Name string
}</code></pre>
            </article>
            
            <article class="struct" data-name="charGroup">
               <h3>
                  charGroup
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type charGroup struct {
sign int
class []rune
}</code></pre>
            </article>
            
            <article class="struct" data-name="compiler">
               <h3>
                  compiler
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type compiler struct {
p *Prog
}</code></pre>
            </article>
            
            <article class="struct" data-name="frag">
               <h3>
                  frag
                  <span class="badge">struct</span>
               </h3>
               
               <p>A frag represents a compiled program fragment.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type frag struct {
i uint32
out patchList
nullable bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="parser">
               <h3>
                  parser
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type parser struct {
flags Flags
stack []*Regexp
free *Regexp
numCap int
wholeRegexp string
tmpClass []rune
numRegexp int
numRunes int
repeats int64
height map[*Regexp]int
size map[*Regexp]int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="patchList">
               <h3>
                  patchList
                  <span class="badge">struct</span>
               </h3>
               
               <p>A patchList is a list of instruction pointers that need to be filled in (patched).
Because the pointers haven't been filled in yet, we can reuse their storage
to hold the list. It's kind of sleazy, but works well in practice.
See https://swtch.com/~rsc/regexp/regexp1.html for inspiration.
These aren't really pointers: they're integers, so we can reinterpret them
this way without using package unsafe. A value l.head denotes
p.inst[l.head>>1].Out (l.head&1==0) or .Arg (l.head&1==1).
head == 0 denotes the empty list, okay because we start every program
with a fail instruction, so we'll never want to point at its output link.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type patchList struct {
head uint32
tail uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="ranges">
               <h3>
                  ranges
                  <span class="badge">struct</span>
               </h3>
               
               <p>ranges implements sort.Interface on a []rune.
The choice of receiver type definition is strange
but avoids an allocation since we already have
a *[]rune.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ranges struct {
p *[]rune
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="CapNames">
               <h3>
                  CapNames 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CapNames walks the regexp to find the names of capturing groups.</p>
               
               <pre><code>func (re *Regexp) CapNames() []string</code></pre>
            </article>
            
            <article class="function" data-name="Compile">
               <h3>
                  Compile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Compile compiles the regexp into a program to be executed.
The regexp should have been simplified already (returned from re.Simplify).</p>
               
               <pre><code>func Compile(re *Regexp) (*Prog, error)</code></pre>
            </article>
            
            <article class="function" data-name="EmptyOpContext">
               <h3>
                  EmptyOpContext 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>EmptyOpContext returns the zero-width assertions
satisfied at the position between the runes r1 and r2.
Passing r1 == -1 indicates that the position is
at the beginning of the text.
Passing r2 == -1 indicates that the position is
at the end of the text.</p>
               
               <pre><code>func EmptyOpContext(r1 rune, r2 rune) EmptyOp</code></pre>
            </article>
            
            <article class="function" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Equal reports whether x and y have identical structure.</p>
               
               <pre><code>func (x *Regexp) Equal(y *Regexp) bool</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *Error) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="IsWordChar">
               <h3>
                  IsWordChar 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsWordChar reports whether r is considered a “word character”
during the evaluation of the \b and \B zero-width assertions.
These assertions are ASCII-only: the word characters are [A-Za-z0-9_].</p>
               
               <pre><code>func IsWordChar(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ra ranges) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ra ranges) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="MatchEmptyWidth">
               <h3>
                  MatchEmptyWidth 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MatchEmptyWidth reports whether the instruction matches
an empty string between the runes before and after.
It should only be called when i.Op == [InstEmptyWidth].</p>
               
               <pre><code>func (i *Inst) MatchEmptyWidth(before rune, after rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="MatchRune">
               <h3>
                  MatchRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MatchRune reports whether the instruction matches (and consumes) r.
It should only be called when i.Op == [InstRune].</p>
               
               <pre><code>func (i *Inst) MatchRune(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="MatchRunePos">
               <h3>
                  MatchRunePos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MatchRunePos checks whether the instruction matches (and consumes) r.
If so, MatchRunePos returns the index of the matching rune pair
(or, when len(i.Rune) == 1, rune singleton).
If not, MatchRunePos returns -1.
MatchRunePos should only be called when i.Op == [InstRune].</p>
               
               <pre><code>func (i *Inst) MatchRunePos(r rune) int</code></pre>
            </article>
            
            <article class="function" data-name="MaxCap">
               <h3>
                  MaxCap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MaxCap walks the regexp to find the maximum capture index.</p>
               
               <pre><code>func (re *Regexp) MaxCap() int</code></pre>
            </article>
            
            <article class="function" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Parse parses a regular expression string s, controlled by the specified
Flags, and returns a regular expression parse tree. The syntax is
described in the top-level comment.</p>
               
               <pre><code>func Parse(s string, flags Flags) (*Regexp, error)</code></pre>
            </article>
            
            <article class="function" data-name="Prefix">
               <h3>
                  Prefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Prefix returns a literal string that all matches for the
regexp must start with. Complete is true if the prefix
is the entire match.</p>
               
               <pre><code>func (p *Prog) Prefix() (prefix string, complete bool)</code></pre>
            </article>
            
            <article class="function" data-name="Simplify">
               <h3>
                  Simplify 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Simplify returns a regexp equivalent to re but without counted repetitions
and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/.
The resulting regexp will execute correctly but its string representation
will not produce the same parse tree, because capturing parentheses
may have been duplicated or removed. For example, the simplified form
for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1.
The returned regexp may share structure with or be the original.</p>
               
               <pre><code>func (re *Regexp) Simplify() *Regexp</code></pre>
            </article>
            
            <article class="function" data-name="StartCond">
               <h3>
                  StartCond 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>StartCond returns the leading empty-width conditions that must
be true in any match. It returns ^EmptyOp(0) if no matches are possible.</p>
               
               <pre><code>func (p *Prog) StartCond() EmptyOp</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i *Inst) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i Op) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e ErrorCode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Prog) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (re *Regexp) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i InstOp) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (ra ranges) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func _()</code></pre>
            </article>
            
            <article class="function" data-name="addSpan">
               <h3>
                  addSpan 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addSpan enables the flags f around start..last,
by setting flags[start] = f and flags[last] = flagOff.</p>
               
               <pre><code>func addSpan(start *Regexp, last *Regexp, f printFlags, flags *map[*Regexp]printFlags)</code></pre>
            </article>
            
            <article class="function" data-name="alt">
               <h3>
                  alt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) alt(f1 frag, f2 frag) frag</code></pre>
            </article>
            
            <article class="function" data-name="alternate">
               <h3>
                  alternate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>alternate replaces the top of the stack (above the topmost '(') with its alternation.</p>
               
               <pre><code>func (p *parser) alternate() *Regexp</code></pre>
            </article>
            
            <article class="function" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l1 patchList) append(p *Prog, l2 patchList) patchList</code></pre>
            </article>
            
            <article class="function" data-name="appendClass">
               <h3>
                  appendClass 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendClass returns the result of appending the class x to the class r.
It assume x is clean.</p>
               
               <pre><code>func appendClass(r []rune, x []rune) []rune</code></pre>
            </article>
            
            <article class="function" data-name="appendFoldedClass">
               <h3>
                  appendFoldedClass 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendFoldedClass returns the result of appending the case folding of the class x to the class r.</p>
               
               <pre><code>func appendFoldedClass(r []rune, x []rune) []rune</code></pre>
            </article>
            
            <article class="function" data-name="appendFoldedRange">
               <h3>
                  appendFoldedRange 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendFoldedRange returns the result of appending the range lo-hi
and its case folding-equivalent runes to the class r.</p>
               
               <pre><code>func appendFoldedRange(r []rune, lo rune, hi rune) []rune</code></pre>
            </article>
            
            <article class="function" data-name="appendGroup">
               <h3>
                  appendGroup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) appendGroup(r []rune, g charGroup) []rune</code></pre>
            </article>
            
            <article class="function" data-name="appendLiteral">
               <h3>
                  appendLiteral 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendLiteral returns the result of appending the literal x to the class r.</p>
               
               <pre><code>func appendLiteral(r []rune, x rune, flags Flags) []rune</code></pre>
            </article>
            
            <article class="function" data-name="appendNegatedClass">
               <h3>
                  appendNegatedClass 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendNegatedClass returns the result of appending the negation of the class x to the class r.
It assumes x is clean.</p>
               
               <pre><code>func appendNegatedClass(r []rune, x []rune) []rune</code></pre>
            </article>
            
            <article class="function" data-name="appendNegatedTable">
               <h3>
                  appendNegatedTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendNegatedTable returns the result of appending the negation of x to the class r.</p>
               
               <pre><code>func appendNegatedTable(r []rune, x *unicode.RangeTable) []rune</code></pre>
            </article>
            
            <article class="function" data-name="appendRange">
               <h3>
                  appendRange 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendRange returns the result of appending the range lo-hi to the class r.</p>
               
               <pre><code>func appendRange(r []rune, lo rune, hi rune) []rune</code></pre>
            </article>
            
            <article class="function" data-name="appendTable">
               <h3>
                  appendTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendTable returns the result of appending x to the class r.</p>
               
               <pre><code>func appendTable(r []rune, x *unicode.RangeTable) []rune</code></pre>
            </article>
            
            <article class="function" data-name="bw">
               <h3>
                  bw 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func bw(b *strings.Builder, args ...string)</code></pre>
            </article>
            
            <article class="function" data-name="calcFlags">
               <h3>
                  calcFlags 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>calcFlags calculates the flags to print around each subexpression in re,
storing that information in (*flags)[sub] for each affected subexpression.
The first time an entry needs to be written to *flags, calcFlags allocates the map.
calcFlags also calculates the flags that must be active or can't be active
around re and returns those flags.</p>
               
               <pre><code>func calcFlags(re *Regexp, flags *map[*Regexp]printFlags) (must printFlags, cant printFlags)</code></pre>
            </article>
            
            <article class="function" data-name="calcHeight">
               <h3>
                  calcHeight 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) calcHeight(re *Regexp, force bool) int</code></pre>
            </article>
            
            <article class="function" data-name="calcSize">
               <h3>
                  calcSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) calcSize(re *Regexp, force bool) int64</code></pre>
            </article>
            
            <article class="function" data-name="cap">
               <h3>
                  cap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) cap(arg uint32) frag</code></pre>
            </article>
            
            <article class="function" data-name="capNames">
               <h3>
                  capNames 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (re *Regexp) capNames(names []string)</code></pre>
            </article>
            
            <article class="function" data-name="cat">
               <h3>
                  cat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) cat(f1 frag, f2 frag) frag</code></pre>
            </article>
            
            <article class="function" data-name="checkHeight">
               <h3>
                  checkHeight 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) checkHeight(re *Regexp)</code></pre>
            </article>
            
            <article class="function" data-name="checkLimits">
               <h3>
                  checkLimits 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) checkLimits(re *Regexp)</code></pre>
            </article>
            
            <article class="function" data-name="checkSize">
               <h3>
                  checkSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) checkSize(re *Regexp)</code></pre>
            </article>
            
            <article class="function" data-name="checkUTF8">
               <h3>
                  checkUTF8 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkUTF8(s string) error</code></pre>
            </article>
            
            <article class="function" data-name="cleanAlt">
               <h3>
                  cleanAlt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>cleanAlt cleans re for eventual inclusion in an alternation.</p>
               
               <pre><code>func cleanAlt(re *Regexp)</code></pre>
            </article>
            
            <article class="function" data-name="cleanClass">
               <h3>
                  cleanClass 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>cleanClass sorts the ranges (pairs of elements of r),
merges them, and eliminates duplicates.</p>
               
               <pre><code>func cleanClass(rp *[]rune) []rune</code></pre>
            </article>
            
            <article class="function" data-name="collapse">
               <h3>
                  collapse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>collapse returns the result of applying op to sub.
If sub contains op nodes, they all get hoisted up
so that there is never a concat of a concat or an
alternate of an alternate.</p>
               
               <pre><code>func (p *parser) collapse(subs []*Regexp, op Op) *Regexp</code></pre>
            </article>
            
            <article class="function" data-name="compile">
               <h3>
                  compile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) compile(re *Regexp) frag</code></pre>
            </article>
            
            <article class="function" data-name="concat">
               <h3>
                  concat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>concat replaces the top of the stack (above the topmost '|' or '(') with its concatenation.</p>
               
               <pre><code>func (p *parser) concat() *Regexp</code></pre>
            </article>
            
            <article class="function" data-name="dumpInst">
               <h3>
                  dumpInst 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dumpInst(b *strings.Builder, i *Inst)</code></pre>
            </article>
            
            <article class="function" data-name="dumpProg">
               <h3>
                  dumpProg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dumpProg(b *strings.Builder, p *Prog)</code></pre>
            </article>
            
            <article class="function" data-name="empty">
               <h3>
                  empty 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) empty(op EmptyOp) frag</code></pre>
            </article>
            
            <article class="function" data-name="escape">
               <h3>
                  escape 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func escape(b *strings.Builder, r rune, force bool)</code></pre>
            </article>
            
            <article class="function" data-name="factor">
               <h3>
                  factor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>factor factors common prefixes from the alternation list sub.
It returns a replacement list that reuses the same storage and
frees (passes to p.reuse) any removed *Regexps.
For example,
ABC|ABD|AEF|BCX|BCY
simplifies by literal prefix extraction to
A(B(C|D)|EF)|BC(X|Y)
which simplifies by character class introduction to
A(B[CD]|EF)|BC[XY]</p>
               
               <pre><code>func (p *parser) factor(sub []*Regexp) []*Regexp</code></pre>
            </article>
            
            <article class="function" data-name="fail">
               <h3>
                  fail 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) fail() frag</code></pre>
            </article>
            
            <article class="function" data-name="inCharClass">
               <h3>
                  inCharClass 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>inCharClass reports whether r is in the class.
It assumes the class has been cleaned by cleanClass.</p>
               
               <pre><code>func inCharClass(r rune, class []rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) init()</code></pre>
            </article>
            
            <article class="function" data-name="inst">
               <h3>
                  inst 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) inst(op InstOp) frag</code></pre>
            </article>
            
            <article class="function" data-name="isCharClass">
               <h3>
                  isCharClass 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>can this be represented as a character class?
single-rune literal string, char class, ., and .|\n.</p>
               
               <pre><code>func isCharClass(re *Regexp) bool</code></pre>
            </article>
            
            <article class="function" data-name="isValidCaptureName">
               <h3>
                  isValidCaptureName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isValidCaptureName reports whether name
is a valid capture name: [A-Za-z0-9_]+.
PCRE limits names to 32 bytes.
Python rejects names starting with digits.
We don't enforce either of those.</p>
               
               <pre><code>func isValidCaptureName(name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isalnum">
               <h3>
                  isalnum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isalnum(c rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="leadingRegexp">
               <h3>
                  leadingRegexp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>leadingRegexp returns the leading regexp that re begins with.
The regexp refers to storage in re or its children.</p>
               
               <pre><code>func (p *parser) leadingRegexp(re *Regexp) *Regexp</code></pre>
            </article>
            
            <article class="function" data-name="leadingString">
               <h3>
                  leadingString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>leadingString returns the leading literal string that re begins with.
The string refers to storage in re or its children.</p>
               
               <pre><code>func (p *parser) leadingString(re *Regexp) ([]rune, Flags)</code></pre>
            </article>
            
            <article class="function" data-name="literal">
               <h3>
                  literal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>literal pushes a literal regexp for the rune r on the stack.</p>
               
               <pre><code>func (p *parser) literal(r rune)</code></pre>
            </article>
            
            <article class="function" data-name="literalRegexp">
               <h3>
                  literalRegexp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func literalRegexp(s string, flags Flags) *Regexp</code></pre>
            </article>
            
            <article class="function" data-name="loop">
               <h3>
                  loop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>loop returns the fragment for the main loop of a plus or star.
For plus, it can be used after changing the entry to f1.i.
For star, it can be used directly when f1 can't match an empty string.
(When f1 can match an empty string, f1* must be implemented as (f1+)?
to get the priority match order correct.)</p>
               
               <pre><code>func (c *compiler) loop(f1 frag, nongreedy bool) frag</code></pre>
            </article>
            
            <article class="function" data-name="makePatchList">
               <h3>
                  makePatchList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makePatchList(n uint32) patchList</code></pre>
            </article>
            
            <article class="function" data-name="matchRune">
               <h3>
                  matchRune 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>does re match r?</p>
               
               <pre><code>func matchRune(re *Regexp, r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="maybeConcat">
               <h3>
                  maybeConcat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>maybeConcat implements incremental concatenation
of literal runes into string nodes. The parser calls this
before each push, so only the top fragment of the stack
might need processing. Since this is called before a push,
the topmost literal is no longer subject to operators like *
(Otherwise ab* would turn into (ab)*.)
If r >= 0 and there's a node left over, maybeConcat uses it
to push r with the given flags.
maybeConcat reports whether r was pushed.</p>
               
               <pre><code>func (p *parser) maybeConcat(r rune, flags Flags) bool</code></pre>
            </article>
            
            <article class="function" data-name="mergeCharClass">
               <h3>
                  mergeCharClass 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mergeCharClass makes dst = dst|src.
The caller must ensure that dst.Op >= src.Op,
to reduce the amount of copying.</p>
               
               <pre><code>func mergeCharClass(dst *Regexp, src *Regexp)</code></pre>
            </article>
            
            <article class="function" data-name="minFoldRune">
               <h3>
                  minFoldRune 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>minFoldRune returns the minimum rune fold-equivalent to r.</p>
               
               <pre><code>func minFoldRune(r rune) rune</code></pre>
            </article>
            
            <article class="function" data-name="negateClass">
               <h3>
                  negateClass 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>negateClass overwrites r and returns r's negation.
It assumes the class r is already clean.</p>
               
               <pre><code>func negateClass(r []rune) []rune</code></pre>
            </article>
            
            <article class="function" data-name="newRegexp">
               <h3>
                  newRegexp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) newRegexp(op Op) *Regexp</code></pre>
            </article>
            
            <article class="function" data-name="nextRune">
               <h3>
                  nextRune 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nextRune(s string) (c rune, t string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="nop">
               <h3>
                  nop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) nop() frag</code></pre>
            </article>
            
            <article class="function" data-name="op">
               <h3>
                  op 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>op pushes a regexp with the given op onto the stack
and returns that regexp.</p>
               
               <pre><code>func (p *parser) op(op Op) *Regexp</code></pre>
            </article>
            
            <article class="function" data-name="op">
               <h3>
                  op 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>op returns i.Op but merges all the Rune special cases into InstRune</p>
               
               <pre><code>func (i *Inst) op() InstOp</code></pre>
            </article>
            
            <article class="function" data-name="parse">
               <h3>
                  parse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parse(s string, flags Flags) (_ *Regexp, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseClass">
               <h3>
                  parseClass 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseClass parses a character class at the beginning of s
and pushes it onto the parse stack.</p>
               
               <pre><code>func (p *parser) parseClass(s string) (rest string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseClassChar">
               <h3>
                  parseClassChar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseClassChar parses a character class character at the beginning of s
and returns it.</p>
               
               <pre><code>func (p *parser) parseClassChar(s string, wholeClass string) (r rune, rest string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseEscape">
               <h3>
                  parseEscape 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseEscape parses an escape sequence at the beginning of s
and returns the rune.</p>
               
               <pre><code>func (p *parser) parseEscape(s string) (r rune, rest string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseInt">
               <h3>
                  parseInt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseInt parses a decimal integer.</p>
               
               <pre><code>func (p *parser) parseInt(s string) (n int, rest string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="parseNamedClass">
               <h3>
                  parseNamedClass 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseNamedClass parses a leading POSIX named character class like [:alnum:]
from the beginning of s. If one is present, it appends the characters to r
and returns the new slice r and the remainder of the string.</p>
               
               <pre><code>func (p *parser) parseNamedClass(s string, r []rune) (out []rune, rest string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parsePerlClassEscape">
               <h3>
                  parsePerlClassEscape 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parsePerlClassEscape parses a leading Perl character class escape like \d
from the beginning of s. If one is present, it appends the characters to r
and returns the new slice r and the remainder of the string.</p>
               
               <pre><code>func (p *parser) parsePerlClassEscape(s string, r []rune) (out []rune, rest string)</code></pre>
            </article>
            
            <article class="function" data-name="parsePerlFlags">
               <h3>
                  parsePerlFlags 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parsePerlFlags parses a Perl flag setting or non-capturing group or both,
like (?i) or (?: or (?i:.  It removes the prefix from s and updates the parse state.
The caller must have ensured that s begins with "(?".</p>
               
               <pre><code>func (p *parser) parsePerlFlags(s string) (rest string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseRepeat">
               <h3>
                  parseRepeat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseRepeat parses {min} (max=min) or {min,} (max=-1) or {min,max}.
If s is not of that form, it returns ok == false.
If s has the right form but the values are too big, it returns min == -1, ok == true.</p>
               
               <pre><code>func (p *parser) parseRepeat(s string) (min int, max int, rest string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="parseRightParen">
               <h3>
                  parseRightParen 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseRightParen handles a ) in the input.</p>
               
               <pre><code>func (p *parser) parseRightParen() error</code></pre>
            </article>
            
            <article class="function" data-name="parseUnicodeClass">
               <h3>
                  parseUnicodeClass 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseUnicodeClass parses a leading Unicode character class like \p{Han}
from the beginning of s. If one is present, it appends the characters to r
and returns the new slice r and the remainder of the string.</p>
               
               <pre><code>func (p *parser) parseUnicodeClass(s string, r []rune) (out []rune, rest string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseVerticalBar">
               <h3>
                  parseVerticalBar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseVerticalBar handles a | in the input.</p>
               
               <pre><code>func (p *parser) parseVerticalBar()</code></pre>
            </article>
            
            <article class="function" data-name="patch">
               <h3>
                  patch 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l patchList) patch(p *Prog, val uint32)</code></pre>
            </article>
            
            <article class="function" data-name="plus">
               <h3>
                  plus 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) plus(f1 frag, nongreedy bool) frag</code></pre>
            </article>
            
            <article class="function" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>push pushes the regexp re onto the parse stack and returns the regexp.</p>
               
               <pre><code>func (p *parser) push(re *Regexp) *Regexp</code></pre>
            </article>
            
            <article class="function" data-name="quest">
               <h3>
                  quest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) quest(f1 frag, nongreedy bool) frag</code></pre>
            </article>
            
            <article class="function" data-name="removeLeadingRegexp">
               <h3>
                  removeLeadingRegexp 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>removeLeadingRegexp removes the leading regexp in re.
It returns the replacement for re.
If reuse is true, it passes the removed regexp (if no longer needed) to p.reuse.</p>
               
               <pre><code>func (p *parser) removeLeadingRegexp(re *Regexp, reuse bool) *Regexp</code></pre>
            </article>
            
            <article class="function" data-name="removeLeadingString">
               <h3>
                  removeLeadingString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>removeLeadingString removes the first n leading runes
from the beginning of re. It returns the replacement for re.</p>
               
               <pre><code>func (p *parser) removeLeadingString(re *Regexp, n int) *Regexp</code></pre>
            </article>
            
            <article class="function" data-name="repeat">
               <h3>
                  repeat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>repeat replaces the top stack element with itself repeated according to op, min, max.
before is the regexp suffix starting at the repetition operator.
after is the regexp suffix following after the repetition operator.
repeat returns an updated 'after' and an error, if any.</p>
               
               <pre><code>func (p *parser) repeat(op Op, min int, max int, before string, after string, lastRepeat string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="repeatIsValid">
               <h3>
                  repeatIsValid 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>repeatIsValid reports whether the repetition re is valid.
Valid means that the combination of the top-level repetition
and any inner repetitions does not exceed n copies of the
innermost thing.
This function rewalks the regexp tree and is called for every repetition,
so we have to worry about inducing quadratic behavior in the parser.
We avoid this by only calling repeatIsValid when min or max >= 2.
In that case the depth of any >= 2 nesting can only get to 9 without
triggering a parse error, so each subtree can only be rewalked 9 times.</p>
               
               <pre><code>func repeatIsValid(re *Regexp, n int) bool</code></pre>
            </article>
            
            <article class="function" data-name="reuse">
               <h3>
                  reuse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) reuse(re *Regexp)</code></pre>
            </article>
            
            <article class="function" data-name="rune">
               <h3>
                  rune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) rune(r []rune, flags Flags) frag</code></pre>
            </article>
            
            <article class="function" data-name="simplify1">
               <h3>
                  simplify1 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>simplify1 implements Simplify for the unary OpStar,
OpPlus, and OpQuest operators. It returns the simple regexp
equivalent to
Regexp{Op: op, Flags: flags, Sub: {sub}}
under the assumption that sub is already simple, and
without first allocating that structure. If the regexp
to be returned turns out to be equivalent to re, simplify1
returns re instead.
simplify1 is factored out of Simplify because the implementation
for other operators generates these unary expressions.
Letting them call simplify1 makes sure the expressions they
generate are simple.</p>
               
               <pre><code>func simplify1(op Op, flags Flags, sub *Regexp, re *Regexp) *Regexp</code></pre>
            </article>
            
            <article class="function" data-name="skipNop">
               <h3>
                  skipNop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>skipNop follows any no-op or capturing instructions.</p>
               
               <pre><code>func (p *Prog) skipNop(pc uint32) *Inst</code></pre>
            </article>
            
            <article class="function" data-name="star">
               <h3>
                  star 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *compiler) star(f1 frag, nongreedy bool) frag</code></pre>
            </article>
            
            <article class="function" data-name="swapVerticalBar">
               <h3>
                  swapVerticalBar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>If the top of the stack is an element followed by an opVerticalBar
swapVerticalBar swaps the two and returns true.
Otherwise it returns false.</p>
               
               <pre><code>func (p *parser) swapVerticalBar() bool</code></pre>
            </article>
            
            <article class="function" data-name="u32">
               <h3>
                  u32 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func u32(i uint32) string</code></pre>
            </article>
            
            <article class="function" data-name="unhex">
               <h3>
                  unhex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func unhex(c rune) rune</code></pre>
            </article>
            
            <article class="function" data-name="unicodeTable">
               <h3>
                  unicodeTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>unicodeTable returns the unicode.RangeTable identified by name
and the table of additional fold-equivalent code points.</p>
               
               <pre><code>func unicodeTable(name string) (*unicode.RangeTable, *unicode.RangeTable)</code></pre>
            </article>
            
            <article class="function" data-name="writeRegexp">
               <h3>
                  writeRegexp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writeRegexp writes the Perl syntax for the regular expression re to b.</p>
               
               <pre><code>func writeRegexp(b *strings.Builder, re *Regexp, f printFlags, flags map[*Regexp]printFlags)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
