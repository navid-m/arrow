<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - syntax</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>syntax</code>
         </h1>
         <hr />
         
         <article class="global" data-name="ErrInternalError">
            <h2>ErrInternalError</h2>
            <hr />
            
            <p>Unexpected error</p>
            
            <pre><code>ErrInternalError ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrInvalidCharClass">
            <h2>ErrInvalidCharClass</h2>
            <hr />
            
            <p>Parse errors</p>
            
            <pre><code>ErrInvalidCharClass ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrInvalidCharRange">
            <h2>ErrInvalidCharRange</h2>
            <hr />
            
            <pre><code>ErrInvalidCharRange ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrInvalidEscape">
            <h2>ErrInvalidEscape</h2>
            <hr />
            
            <pre><code>ErrInvalidEscape ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrInvalidNamedCapture">
            <h2>ErrInvalidNamedCapture</h2>
            <hr />
            
            <pre><code>ErrInvalidNamedCapture ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrInvalidPerlOp">
            <h2>ErrInvalidPerlOp</h2>
            <hr />
            
            <pre><code>ErrInvalidPerlOp ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrInvalidRepeatOp">
            <h2>ErrInvalidRepeatOp</h2>
            <hr />
            
            <pre><code>ErrInvalidRepeatOp ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrInvalidRepeatSize">
            <h2>ErrInvalidRepeatSize</h2>
            <hr />
            
            <pre><code>ErrInvalidRepeatSize ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrInvalidUTF8">
            <h2>ErrInvalidUTF8</h2>
            <hr />
            
            <pre><code>ErrInvalidUTF8 ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrMissingBracket">
            <h2>ErrMissingBracket</h2>
            <hr />
            
            <pre><code>ErrMissingBracket ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrMissingParen">
            <h2>ErrMissingParen</h2>
            <hr />
            
            <pre><code>ErrMissingParen ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrMissingRepeatArgument">
            <h2>ErrMissingRepeatArgument</h2>
            <hr />
            
            <pre><code>ErrMissingRepeatArgument ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrTrailingBackslash">
            <h2>ErrTrailingBackslash</h2>
            <hr />
            
            <pre><code>ErrTrailingBackslash ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrUnexpectedParen">
            <h2>ErrUnexpectedParen</h2>
            <hr />
            
            <pre><code>ErrUnexpectedParen ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrNestingDepth">
            <h2>ErrNestingDepth</h2>
            <hr />
            
            <pre><code>ErrNestingDepth ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="ErrLarge">
            <h2>ErrLarge</h2>
            <hr />
            
            <pre><code>ErrLarge ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="FoldCase">
            <h2>FoldCase</h2>
            <hr />
            
            <pre><code>FoldCase Flags</code></pre>
         </article>
         
         <article class="global" data-name="Literal">
            <h2>Literal</h2>
            <hr />
            
            <pre><code>Literal</code></pre>
         </article>
         
         <article class="global" data-name="ClassNL">
            <h2>ClassNL</h2>
            <hr />
            
            <pre><code>ClassNL</code></pre>
         </article>
         
         <article class="global" data-name="DotNL">
            <h2>DotNL</h2>
            <hr />
            
            <pre><code>DotNL</code></pre>
         </article>
         
         <article class="global" data-name="OneLine">
            <h2>OneLine</h2>
            <hr />
            
            <pre><code>OneLine</code></pre>
         </article>
         
         <article class="global" data-name="NonGreedy">
            <h2>NonGreedy</h2>
            <hr />
            
            <pre><code>NonGreedy</code></pre>
         </article>
         
         <article class="global" data-name="PerlX">
            <h2>PerlX</h2>
            <hr />
            
            <pre><code>PerlX</code></pre>
         </article>
         
         <article class="global" data-name="UnicodeGroups">
            <h2>UnicodeGroups</h2>
            <hr />
            
            <pre><code>UnicodeGroups</code></pre>
         </article>
         
         <article class="global" data-name="WasDollar">
            <h2>WasDollar</h2>
            <hr />
            
            <pre><code>WasDollar</code></pre>
         </article>
         
         <article class="global" data-name="Simple">
            <h2>Simple</h2>
            <hr />
            
            <pre><code>Simple</code></pre>
         </article>
         
         <article class="global" data-name="MatchNL">
            <h2>MatchNL</h2>
            <hr />
            
            <pre><code>MatchNL</code></pre>
         </article>
         
         <article class="global" data-name="Perl">
            <h2>Perl</h2>
            <hr />
            
            <pre><code>Perl</code></pre>
         </article>
         
         <article class="global" data-name="POSIX">
            <h2>POSIX</h2>
            <hr />
            
            <pre><code>POSIX Flags</code></pre>
         </article>
         
         <article class="global" data-name="opLeftParen">
            <h2>opLeftParen</h2>
            <hr />
            
            <p>Pseudo-ops for parsing stack.</p>
            
            <pre><code>opLeftParen</code></pre>
         </article>
         
         <article class="global" data-name="opVerticalBar">
            <h2>opVerticalBar</h2>
            <hr />
            
            <p>Pseudo-ops for parsing stack.</p>
            
            <pre><code>opVerticalBar</code></pre>
         </article>
         
         <article class="global" data-name="maxHeight">
            <h2>maxHeight</h2>
            <hr />
            
            <p>maxHeight is the maximum height of a regexp parse tree.
It is somewhat arbitrarily chosen, but the idea is to be large enough
that no one will actually hit in real use but at the same time small enough
that recursion on the Regexp tree will not hit the 1GB Go stack limit.
The maximum amount of stack for a single recursive frame is probably
closer to 1kB, so this could potentially be raised, but it seems unlikely
that people have regexps nested even this deeply.
We ran a test on Google's C++ code base and turned up only
a single use case with depth > 100; it had depth 128.
Using depth 1000 should be plenty of margin.
As an optimization, we don't even bother calculating heights
until we've allocated at least maxHeight Regexp structures.</p>
            
            <pre><code>maxHeight</code></pre>
         </article>
         
         <article class="global" data-name="maxSize">
            <h2>maxSize</h2>
            <hr />
            
            <p>maxSize is the maximum size of a compiled regexp in Insts.
It too is somewhat arbitrarily chosen, but the idea is to be large enough
to allow significant regexps while at the same time small enough that
the compiled form will not take up too much memory.
128 MB is enough for a 3.3 million Inst structures, which roughly
corresponds to a 3.3 MB regexp.</p>
            
            <pre><code>maxSize</code></pre>
         </article>
         
         <article class="global" data-name="instSize">
            <h2>instSize</h2>
            <hr />
            
            <p>maxSize is the maximum size of a compiled regexp in Insts.
It too is somewhat arbitrarily chosen, but the idea is to be large enough
to allow significant regexps while at the same time small enough that
the compiled form will not take up too much memory.
128 MB is enough for a 3.3 million Inst structures, which roughly
corresponds to a 3.3 MB regexp.</p>
            
            <pre><code>instSize</code></pre>
         </article>
         
         <article class="global" data-name="maxRunes">
            <h2>maxRunes</h2>
            <hr />
            
            <p>maxRunes is the maximum number of runes allowed in a regexp tree
counting the runes in all the nodes.
Ignoring character classes p.numRunes is always less than the length of the regexp.
Character classes can make it much larger: each \pL adds 1292 runes.
128 MB is enough for 32M runes, which is over 26k \pL instances.
Note that repetitions do not make copies of the rune slices,
so \pL{1000} is only one rune slice, not 1000.
We could keep a cache of character classes we've seen,
so that all the \pL we see use the same rune list,
but that doesn't remove the problem entirely:
consider something like [\pL01234][\pL01235][\pL01236]...[\pL^&*()].
And because the Rune slice is exposed directly in the Regexp,
there is not an opportunity to change the representation to allow
partial sharing between different character classes.
So the limit is the best we can do.</p>
            
            <pre><code>maxRunes</code></pre>
         </article>
         
         <article class="global" data-name="runeSize">
            <h2>runeSize</h2>
            <hr />
            
            <p>maxRunes is the maximum number of runes allowed in a regexp tree
counting the runes in all the nodes.
Ignoring character classes p.numRunes is always less than the length of the regexp.
Character classes can make it much larger: each \pL adds 1292 runes.
128 MB is enough for 32M runes, which is over 26k \pL instances.
Note that repetitions do not make copies of the rune slices,
so \pL{1000} is only one rune slice, not 1000.
We could keep a cache of character classes we've seen,
so that all the \pL we see use the same rune list,
but that doesn't remove the problem entirely:
consider something like [\pL01234][\pL01235][\pL01236]...[\pL^&*()].
And because the Rune slice is exposed directly in the Regexp,
there is not an opportunity to change the representation to allow
partial sharing between different character classes.
So the limit is the best we can do.</p>
            
            <pre><code>runeSize</code></pre>
         </article>
         
         <article class="global" data-name="anyTable">
            <h2>anyTable</h2>
            <hr />
            
            <pre><code>anyTable</code></pre>
         </article>
         
         <article class="global" data-name="minFold">
            <h2>minFold</h2>
            <hr />
            
            <p>minimum and maximum runes involved in folding.
checked during test.</p>
            
            <pre><code>minFold</code></pre>
         </article>
         
         <article class="global" data-name="maxFold">
            <h2>maxFold</h2>
            <hr />
            
            <pre><code>maxFold</code></pre>
         </article>
         
         <article class="global" data-name="parseTests">
            <h2>parseTests</h2>
            <hr />
            
            <pre><code>parseTests</code></pre>
         </article>
         
         <article class="global" data-name="testFlags">
            <h2>testFlags</h2>
            <hr />
            
            <pre><code>testFlags</code></pre>
         </article>
         
         <article class="global" data-name="foldcaseTests">
            <h2>foldcaseTests</h2>
            <hr />
            
            <pre><code>foldcaseTests</code></pre>
         </article>
         
         <article class="global" data-name="literalTests">
            <h2>literalTests</h2>
            <hr />
            
            <pre><code>literalTests</code></pre>
         </article>
         
         <article class="global" data-name="matchnlTests">
            <h2>matchnlTests</h2>
            <hr />
            
            <pre><code>matchnlTests</code></pre>
         </article>
         
         <article class="global" data-name="nomatchnlTests">
            <h2>nomatchnlTests</h2>
            <hr />
            
            <pre><code>nomatchnlTests</code></pre>
         </article>
         
         <article class="global" data-name="opNames">
            <h2>opNames</h2>
            <hr />
            
            <pre><code>opNames</code></pre>
         </article>
         
         <article class="global" data-name="invalidRegexps">
            <h2>invalidRegexps</h2>
            <hr />
            
            <pre><code>invalidRegexps</code></pre>
         </article>
         
         <article class="global" data-name="onlyPerl">
            <h2>onlyPerl</h2>
            <hr />
            
            <pre><code>onlyPerl</code></pre>
         </article>
         
         <article class="global" data-name="onlyPOSIX">
            <h2>onlyPOSIX</h2>
            <hr />
            
            <pre><code>onlyPOSIX</code></pre>
         </article>
         
         <article class="global" data-name="stringTests">
            <h2>stringTests</h2>
            <hr />
            
            <pre><code>stringTests</code></pre>
         </article>
         
         <article class="global" data-name="code1">
            <h2>code1</h2>
            <hr />
            
            <pre><code>code1</code></pre>
         </article>
         
         <article class="global" data-name="code2">
            <h2>code2</h2>
            <hr />
            
            <pre><code>code2</code></pre>
         </article>
         
         <article class="global" data-name="code3">
            <h2>code3</h2>
            <hr />
            
            <pre><code>code3</code></pre>
         </article>
         
         <article class="global" data-name="perlGroup">
            <h2>perlGroup</h2>
            <hr />
            
            <pre><code>perlGroup</code></pre>
         </article>
         
         <article class="global" data-name="code4">
            <h2>code4</h2>
            <hr />
            
            <pre><code>code4</code></pre>
         </article>
         
         <article class="global" data-name="code5">
            <h2>code5</h2>
            <hr />
            
            <pre><code>code5</code></pre>
         </article>
         
         <article class="global" data-name="code6">
            <h2>code6</h2>
            <hr />
            
            <pre><code>code6</code></pre>
         </article>
         
         <article class="global" data-name="code7">
            <h2>code7</h2>
            <hr />
            
            <pre><code>code7</code></pre>
         </article>
         
         <article class="global" data-name="code8">
            <h2>code8</h2>
            <hr />
            
            <pre><code>code8</code></pre>
         </article>
         
         <article class="global" data-name="code9">
            <h2>code9</h2>
            <hr />
            
            <pre><code>code9</code></pre>
         </article>
         
         <article class="global" data-name="code10">
            <h2>code10</h2>
            <hr />
            
            <pre><code>code10</code></pre>
         </article>
         
         <article class="global" data-name="code11">
            <h2>code11</h2>
            <hr />
            
            <pre><code>code11</code></pre>
         </article>
         
         <article class="global" data-name="code12">
            <h2>code12</h2>
            <hr />
            
            <pre><code>code12</code></pre>
         </article>
         
         <article class="global" data-name="code13">
            <h2>code13</h2>
            <hr />
            
            <pre><code>code13</code></pre>
         </article>
         
         <article class="global" data-name="code14">
            <h2>code14</h2>
            <hr />
            
            <pre><code>code14</code></pre>
         </article>
         
         <article class="global" data-name="code15">
            <h2>code15</h2>
            <hr />
            
            <pre><code>code15</code></pre>
         </article>
         
         <article class="global" data-name="code16">
            <h2>code16</h2>
            <hr />
            
            <pre><code>code16</code></pre>
         </article>
         
         <article class="global" data-name="code17">
            <h2>code17</h2>
            <hr />
            
            <pre><code>code17</code></pre>
         </article>
         
         <article class="global" data-name="posixGroup">
            <h2>posixGroup</h2>
            <hr />
            
            <pre><code>posixGroup</code></pre>
         </article>
         
         <article class="global" data-name="InstAlt">
            <h2>InstAlt</h2>
            <hr />
            
            <pre><code>InstAlt InstOp</code></pre>
         </article>
         
         <article class="global" data-name="InstAltMatch">
            <h2>InstAltMatch</h2>
            <hr />
            
            <pre><code>InstAltMatch</code></pre>
         </article>
         
         <article class="global" data-name="InstCapture">
            <h2>InstCapture</h2>
            <hr />
            
            <pre><code>InstCapture</code></pre>
         </article>
         
         <article class="global" data-name="InstEmptyWidth">
            <h2>InstEmptyWidth</h2>
            <hr />
            
            <pre><code>InstEmptyWidth</code></pre>
         </article>
         
         <article class="global" data-name="InstMatch">
            <h2>InstMatch</h2>
            <hr />
            
            <pre><code>InstMatch</code></pre>
         </article>
         
         <article class="global" data-name="InstFail">
            <h2>InstFail</h2>
            <hr />
            
            <pre><code>InstFail</code></pre>
         </article>
         
         <article class="global" data-name="InstNop">
            <h2>InstNop</h2>
            <hr />
            
            <pre><code>InstNop</code></pre>
         </article>
         
         <article class="global" data-name="InstRune">
            <h2>InstRune</h2>
            <hr />
            
            <pre><code>InstRune</code></pre>
         </article>
         
         <article class="global" data-name="InstRune1">
            <h2>InstRune1</h2>
            <hr />
            
            <pre><code>InstRune1</code></pre>
         </article>
         
         <article class="global" data-name="InstRuneAny">
            <h2>InstRuneAny</h2>
            <hr />
            
            <pre><code>InstRuneAny</code></pre>
         </article>
         
         <article class="global" data-name="InstRuneAnyNotNL">
            <h2>InstRuneAnyNotNL</h2>
            <hr />
            
            <pre><code>InstRuneAnyNotNL</code></pre>
         </article>
         
         <article class="global" data-name="instOpNames">
            <h2>instOpNames</h2>
            <hr />
            
            <pre><code>instOpNames</code></pre>
         </article>
         
         <article class="global" data-name="EmptyBeginLine">
            <h2>EmptyBeginLine</h2>
            <hr />
            
            <pre><code>EmptyBeginLine EmptyOp</code></pre>
         </article>
         
         <article class="global" data-name="EmptyEndLine">
            <h2>EmptyEndLine</h2>
            <hr />
            
            <pre><code>EmptyEndLine</code></pre>
         </article>
         
         <article class="global" data-name="EmptyBeginText">
            <h2>EmptyBeginText</h2>
            <hr />
            
            <pre><code>EmptyBeginText</code></pre>
         </article>
         
         <article class="global" data-name="EmptyEndText">
            <h2>EmptyEndText</h2>
            <hr />
            
            <pre><code>EmptyEndText</code></pre>
         </article>
         
         <article class="global" data-name="EmptyWordBoundary">
            <h2>EmptyWordBoundary</h2>
            <hr />
            
            <pre><code>EmptyWordBoundary</code></pre>
         </article>
         
         <article class="global" data-name="EmptyNoWordBoundary">
            <h2>EmptyNoWordBoundary</h2>
            <hr />
            
            <pre><code>EmptyNoWordBoundary</code></pre>
         </article>
         
         <article class="global" data-name="noMatch">
            <h2>noMatch</h2>
            <hr />
            
            <pre><code>noMatch</code></pre>
         </article>
         
         <article class="global" data-name="anyRuneNotNL">
            <h2>anyRuneNotNL</h2>
            <hr />
            
            <pre><code>anyRuneNotNL</code></pre>
         </article>
         
         <article class="global" data-name="anyRune">
            <h2>anyRune</h2>
            <hr />
            
            <pre><code>anyRune</code></pre>
         </article>
         
         <article class="global" data-name="_Op_name_0">
            <h2>_Op_name_0</h2>
            <hr />
            
            <pre><code>_Op_name_0</code></pre>
         </article>
         
         <article class="global" data-name="_Op_name_1">
            <h2>_Op_name_1</h2>
            <hr />
            
            <pre><code>_Op_name_1</code></pre>
         </article>
         
         <article class="global" data-name="_Op_index_0">
            <h2>_Op_index_0</h2>
            <hr />
            
            <pre><code>_Op_index_0</code></pre>
         </article>
         
         <article class="global" data-name="compileTests">
            <h2>compileTests</h2>
            <hr />
            
            <pre><code>compileTests</code></pre>
         </article>
         
         <article class="global" data-name="sink">
            <h2>sink</h2>
            <hr />
            
            <pre><code>sink any</code></pre>
         </article>
         
         <article class="global" data-name="OpNoMatch">
            <h2>OpNoMatch</h2>
            <hr />
            
            <pre><code>OpNoMatch Op</code></pre>
         </article>
         
         <article class="global" data-name="OpEmptyMatch">
            <h2>OpEmptyMatch</h2>
            <hr />
            
            <pre><code>OpEmptyMatch</code></pre>
         </article>
         
         <article class="global" data-name="OpLiteral">
            <h2>OpLiteral</h2>
            <hr />
            
            <pre><code>OpLiteral</code></pre>
         </article>
         
         <article class="global" data-name="OpCharClass">
            <h2>OpCharClass</h2>
            <hr />
            
            <pre><code>OpCharClass</code></pre>
         </article>
         
         <article class="global" data-name="OpAnyCharNotNL">
            <h2>OpAnyCharNotNL</h2>
            <hr />
            
            <pre><code>OpAnyCharNotNL</code></pre>
         </article>
         
         <article class="global" data-name="OpAnyChar">
            <h2>OpAnyChar</h2>
            <hr />
            
            <pre><code>OpAnyChar</code></pre>
         </article>
         
         <article class="global" data-name="OpBeginLine">
            <h2>OpBeginLine</h2>
            <hr />
            
            <pre><code>OpBeginLine</code></pre>
         </article>
         
         <article class="global" data-name="OpEndLine">
            <h2>OpEndLine</h2>
            <hr />
            
            <pre><code>OpEndLine</code></pre>
         </article>
         
         <article class="global" data-name="OpBeginText">
            <h2>OpBeginText</h2>
            <hr />
            
            <pre><code>OpBeginText</code></pre>
         </article>
         
         <article class="global" data-name="OpEndText">
            <h2>OpEndText</h2>
            <hr />
            
            <pre><code>OpEndText</code></pre>
         </article>
         
         <article class="global" data-name="OpWordBoundary">
            <h2>OpWordBoundary</h2>
            <hr />
            
            <pre><code>OpWordBoundary</code></pre>
         </article>
         
         <article class="global" data-name="OpNoWordBoundary">
            <h2>OpNoWordBoundary</h2>
            <hr />
            
            <pre><code>OpNoWordBoundary</code></pre>
         </article>
         
         <article class="global" data-name="OpCapture">
            <h2>OpCapture</h2>
            <hr />
            
            <pre><code>OpCapture</code></pre>
         </article>
         
         <article class="global" data-name="OpStar">
            <h2>OpStar</h2>
            <hr />
            
            <pre><code>OpStar</code></pre>
         </article>
         
         <article class="global" data-name="OpPlus">
            <h2>OpPlus</h2>
            <hr />
            
            <pre><code>OpPlus</code></pre>
         </article>
         
         <article class="global" data-name="OpQuest">
            <h2>OpQuest</h2>
            <hr />
            
            <pre><code>OpQuest</code></pre>
         </article>
         
         <article class="global" data-name="OpRepeat">
            <h2>OpRepeat</h2>
            <hr />
            
            <pre><code>OpRepeat</code></pre>
         </article>
         
         <article class="global" data-name="OpConcat">
            <h2>OpConcat</h2>
            <hr />
            
            <pre><code>OpConcat</code></pre>
         </article>
         
         <article class="global" data-name="OpAlternate">
            <h2>OpAlternate</h2>
            <hr />
            
            <pre><code>OpAlternate</code></pre>
         </article>
         
         <article class="global" data-name="opPseudo">
            <h2>opPseudo</h2>
            <hr />
            
            <pre><code>opPseudo Op</code></pre>
         </article>
         
         <article class="global" data-name="flagI">
            <h2>flagI</h2>
            <hr />
            
            <pre><code>flagI printFlags</code></pre>
         </article>
         
         <article class="global" data-name="flagM">
            <h2>flagM</h2>
            <hr />
            
            <pre><code>flagM</code></pre>
         </article>
         
         <article class="global" data-name="flagS">
            <h2>flagS</h2>
            <hr />
            
            <pre><code>flagS</code></pre>
         </article>
         
         <article class="global" data-name="flagOff">
            <h2>flagOff</h2>
            <hr />
            
            <pre><code>flagOff</code></pre>
         </article>
         
         <article class="global" data-name="flagPrec">
            <h2>flagPrec</h2>
            <hr />
            
            <pre><code>flagPrec</code></pre>
         </article>
         
         <article class="global" data-name="negShift">
            <h2>negShift</h2>
            <hr />
            
            <pre><code>negShift</code></pre>
         </article>
         
         <article class="global" data-name="meta">
            <h2>meta</h2>
            <hr />
            
            <pre><code>meta</code></pre>
         </article>
         
         <article class="global" data-name="simplifyTests">
            <h2>simplifyTests</h2>
            <hr />
            
            <pre><code>simplifyTests</code></pre>
         </article>
          
         <article class="struct" data-name="Error">
            <h2>type Error struct</h2>
            <hr />
            
            <p>An Error describes a failure to parse a regular expression
and gives the offending expression.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Code ErrorCode
Expr string</code></pre>
         </article>
         
         <article class="struct" data-name="parser">
            <h2>type parser struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">flags Flags
stack []*Regexp
free *Regexp
numCap int
wholeRegexp string
tmpClass []rune
numRegexp int
numRunes int
repeats int64
height *ast.MapType
size *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="charGroup">
            <h2>type charGroup struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">sign int
class []rune</code></pre>
         </article>
         
         <article class="struct" data-name="ranges">
            <h2>type ranges struct</h2>
            <hr />
            
            <p>ranges implements sort.Interface on a []rune.
The choice of receiver type definition is strange
but avoids an allocation since we already have
a *[]rune.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">p *[]rune</code></pre>
         </article>
         
         <article class="struct" data-name="parseTest">
            <h2>type parseTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Regexp string
Dump string</code></pre>
         </article>
         
         <article class="struct" data-name="Prog">
            <h2>type Prog struct</h2>
            <hr />
            
            <p>A Prog is a compiled regular expression program.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Inst []Inst
Start int
NumCap int</code></pre>
         </article>
         
         <article class="struct" data-name="Inst">
            <h2>type Inst struct</h2>
            <hr />
            
            <p>An Inst is a single instruction in a regular expression program.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Op InstOp
Out uint32
Arg uint32
Rune []rune</code></pre>
         </article>
         
         <article class="struct" data-name="patchList">
            <h2>type patchList struct</h2>
            <hr />
            
            <p>A patchList is a list of instruction pointers that need to be filled in (patched).
Because the pointers haven't been filled in yet, we can reuse their storage
to hold the list. It's kind of sleazy, but works well in practice.
See https://swtch.com/~rsc/regexp/regexp1.html for inspiration.

These aren't really pointers: they're integers, so we can reinterpret them
this way without using package unsafe. A value l.head denotes
p.inst[l.head>>1].Out (l.head&1==0) or .Arg (l.head&1==1).
head == 0 denotes the empty list, okay because we start every program
with a fail instruction, so we'll never want to point at its output link.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">head uint32
tail uint32</code></pre>
         </article>
         
         <article class="struct" data-name="frag">
            <h2>type frag struct</h2>
            <hr />
            
            <p>A frag represents a compiled program fragment.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">i uint32
out patchList
nullable bool</code></pre>
         </article>
         
         <article class="struct" data-name="compiler">
            <h2>type compiler struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">p *Prog</code></pre>
         </article>
         
         <article class="struct" data-name="Regexp">
            <h2>type Regexp struct</h2>
            <hr />
            
            <p>A Regexp is a node in a regular expression syntax tree.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Op Op
Flags Flags
Sub []*Regexp
Sub0 []*Regexp
Rune []rune
Rune0 []rune
Min int
Max int
Cap int
Name string</code></pre>
         </article>
          
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="newRegexp">
            <h2>newRegexp</h2>
            <hr />
            
            <pre><code>func newRegexp(op Op) *Regexp</code></pre>
         </article>
         
         <article class="function" data-name="reuse">
            <h2>reuse</h2>
            <hr />
            
            <pre><code>func reuse(re *Regexp)</code></pre>
         </article>
         
         <article class="function" data-name="checkLimits">
            <h2>checkLimits</h2>
            <hr />
            
            <pre><code>func checkLimits(re *Regexp)</code></pre>
         </article>
         
         <article class="function" data-name="checkSize">
            <h2>checkSize</h2>
            <hr />
            
            <pre><code>func checkSize(re *Regexp)</code></pre>
         </article>
         
         <article class="function" data-name="calcSize">
            <h2>calcSize</h2>
            <hr />
            
            <pre><code>func calcSize(re *Regexp, force bool) int64</code></pre>
         </article>
         
         <article class="function" data-name="checkHeight">
            <h2>checkHeight</h2>
            <hr />
            
            <pre><code>func checkHeight(re *Regexp)</code></pre>
         </article>
         
         <article class="function" data-name="calcHeight">
            <h2>calcHeight</h2>
            <hr />
            
            <pre><code>func calcHeight(re *Regexp, force bool) int</code></pre>
         </article>
         
         <article class="function" data-name="push">
            <h2>push</h2>
            <hr />
            
            <p>push pushes the regexp re onto the parse stack and returns the regexp.</p>
            
            <pre><code>func push(re *Regexp) *Regexp</code></pre>
         </article>
         
         <article class="function" data-name="maybeConcat">
            <h2>maybeConcat</h2>
            <hr />
            
            <p>maybeConcat implements incremental concatenation
of literal runes into string nodes. The parser calls this
before each push, so only the top fragment of the stack
might need processing. Since this is called before a push,
the topmost literal is no longer subject to operators like *
(Otherwise ab* would turn into (ab)*.)
If r >= 0 and there's a node left over, maybeConcat uses it
to push r with the given flags.
maybeConcat reports whether r was pushed.</p>
            
            <pre><code>func maybeConcat(r rune, flags Flags) bool</code></pre>
         </article>
         
         <article class="function" data-name="literal">
            <h2>literal</h2>
            <hr />
            
            <p>literal pushes a literal regexp for the rune r on the stack.</p>
            
            <pre><code>func literal(r rune)</code></pre>
         </article>
         
         <article class="function" data-name="minFoldRune">
            <h2>minFoldRune</h2>
            <hr />
            
            <p>minFoldRune returns the minimum rune fold-equivalent to r.</p>
            
            <pre><code>func minFoldRune(r rune) rune</code></pre>
         </article>
         
         <article class="function" data-name="op">
            <h2>op</h2>
            <hr />
            
            <p>op pushes a regexp with the given op onto the stack
and returns that regexp.</p>
            
            <pre><code>func op(op Op) *Regexp</code></pre>
         </article>
         
         <article class="function" data-name="repeat">
            <h2>repeat</h2>
            <hr />
            
            <p>repeat replaces the top stack element with itself repeated according to op, min, max.
before is the regexp suffix starting at the repetition operator.
after is the regexp suffix following after the repetition operator.
repeat returns an updated 'after' and an error, if any.</p>
            
            <pre><code>func repeat(op Op, min int, max int, before string, after string, lastRepeat string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="repeatIsValid">
            <h2>repeatIsValid</h2>
            <hr />
            
            <p>repeatIsValid reports whether the repetition re is valid.
Valid means that the combination of the top-level repetition
and any inner repetitions does not exceed n copies of the
innermost thing.
This function rewalks the regexp tree and is called for every repetition,
so we have to worry about inducing quadratic behavior in the parser.
We avoid this by only calling repeatIsValid when min or max >= 2.
In that case the depth of any >= 2 nesting can only get to 9 without
triggering a parse error, so each subtree can only be rewalked 9 times.</p>
            
            <pre><code>func repeatIsValid(re *Regexp, n int) bool</code></pre>
         </article>
         
         <article class="function" data-name="concat">
            <h2>concat</h2>
            <hr />
            
            <p>concat replaces the top of the stack (above the topmost '|' or '(') with its concatenation.</p>
            
            <pre><code>func concat() *Regexp</code></pre>
         </article>
         
         <article class="function" data-name="alternate">
            <h2>alternate</h2>
            <hr />
            
            <p>alternate replaces the top of the stack (above the topmost '(') with its alternation.</p>
            
            <pre><code>func alternate() *Regexp</code></pre>
         </article>
         
         <article class="function" data-name="cleanAlt">
            <h2>cleanAlt</h2>
            <hr />
            
            <p>cleanAlt cleans re for eventual inclusion in an alternation.</p>
            
            <pre><code>func cleanAlt(re *Regexp)</code></pre>
         </article>
         
         <article class="function" data-name="collapse">
            <h2>collapse</h2>
            <hr />
            
            <p>collapse returns the result of applying op to sub.
If sub contains op nodes, they all get hoisted up
so that there is never a concat of a concat or an
alternate of an alternate.</p>
            
            <pre><code>func collapse(subs []*Regexp, op Op) *Regexp</code></pre>
         </article>
         
         <article class="function" data-name="factor">
            <h2>factor</h2>
            <hr />
            
            <p>factor factors common prefixes from the alternation list sub.
It returns a replacement list that reuses the same storage and
frees (passes to p.reuse) any removed *Regexps.

For example,

	ABC|ABD|AEF|BCX|BCY

simplifies by literal prefix extraction to

	A(B(C|D)|EF)|BC(X|Y)

which simplifies by character class introduction to

	A(B[CD]|EF)|BC[XY]</p>
            
            <pre><code>func factor(sub []*Regexp) []*Regexp</code></pre>
         </article>
         
         <article class="function" data-name="leadingString">
            <h2>leadingString</h2>
            <hr />
            
            <p>leadingString returns the leading literal string that re begins with.
The string refers to storage in re or its children.</p>
            
            <pre><code>func leadingString(re *Regexp) ([]rune, Flags)</code></pre>
         </article>
         
         <article class="function" data-name="removeLeadingString">
            <h2>removeLeadingString</h2>
            <hr />
            
            <p>removeLeadingString removes the first n leading runes
from the beginning of re. It returns the replacement for re.</p>
            
            <pre><code>func removeLeadingString(re *Regexp, n int) *Regexp</code></pre>
         </article>
         
         <article class="function" data-name="leadingRegexp">
            <h2>leadingRegexp</h2>
            <hr />
            
            <p>leadingRegexp returns the leading regexp that re begins with.
The regexp refers to storage in re or its children.</p>
            
            <pre><code>func leadingRegexp(re *Regexp) *Regexp</code></pre>
         </article>
         
         <article class="function" data-name="removeLeadingRegexp">
            <h2>removeLeadingRegexp</h2>
            <hr />
            
            <p>removeLeadingRegexp removes the leading regexp in re.
It returns the replacement for re.
If reuse is true, it passes the removed regexp (if no longer needed) to p.reuse.</p>
            
            <pre><code>func removeLeadingRegexp(re *Regexp, reuse bool) *Regexp</code></pre>
         </article>
         
         <article class="function" data-name="literalRegexp">
            <h2>literalRegexp</h2>
            <hr />
            
            <pre><code>func literalRegexp(s string, flags Flags) *Regexp</code></pre>
         </article>
         
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <p>Parse parses a regular expression string s, controlled by the specified
Flags, and returns a regular expression parse tree. The syntax is
described in the top-level comment.</p>
            
            <pre><code>func Parse(s string, flags Flags) (*Regexp, error)</code></pre>
         </article>
         
         <article class="function" data-name="parse">
            <h2>parse</h2>
            <hr />
            
            <pre><code>func parse(s string, flags Flags) (_ *Regexp, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseRepeat">
            <h2>parseRepeat</h2>
            <hr />
            
            <p>parseRepeat parses {min} (max=min) or {min,} (max=-1) or {min,max}.
If s is not of that form, it returns ok == false.
If s has the right form but the values are too big, it returns min == -1, ok == true.</p>
            
            <pre><code>func parseRepeat(s string) (min int, max int, rest string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="parsePerlFlags">
            <h2>parsePerlFlags</h2>
            <hr />
            
            <p>parsePerlFlags parses a Perl flag setting or non-capturing group or both,
like (?i) or (?: or (?i:.  It removes the prefix from s and updates the parse state.
The caller must have ensured that s begins with "(?".</p>
            
            <pre><code>func parsePerlFlags(s string) (rest string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="isValidCaptureName">
            <h2>isValidCaptureName</h2>
            <hr />
            
            <p>isValidCaptureName reports whether name
is a valid capture name: [A-Za-z0-9_]+.
PCRE limits names to 32 bytes.
Python rejects names starting with digits.
We don't enforce either of those.</p>
            
            <pre><code>func isValidCaptureName(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="parseInt">
            <h2>parseInt</h2>
            <hr />
            
            <p>parseInt parses a decimal integer.</p>
            
            <pre><code>func parseInt(s string) (n int, rest string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="isCharClass">
            <h2>isCharClass</h2>
            <hr />
            
            <p>can this be represented as a character class?
single-rune literal string, char class, ., and .|\n.</p>
            
            <pre><code>func isCharClass(re *Regexp) bool</code></pre>
         </article>
         
         <article class="function" data-name="matchRune">
            <h2>matchRune</h2>
            <hr />
            
            <p>does re match r?</p>
            
            <pre><code>func matchRune(re *Regexp, r rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="parseVerticalBar">
            <h2>parseVerticalBar</h2>
            <hr />
            
            <p>parseVerticalBar handles a | in the input.</p>
            
            <pre><code>func parseVerticalBar()</code></pre>
         </article>
         
         <article class="function" data-name="mergeCharClass">
            <h2>mergeCharClass</h2>
            <hr />
            
            <p>mergeCharClass makes dst = dst|src.
The caller must ensure that dst.Op >= src.Op,
to reduce the amount of copying.</p>
            
            <pre><code>func mergeCharClass(dst *Regexp, src *Regexp)</code></pre>
         </article>
         
         <article class="function" data-name="swapVerticalBar">
            <h2>swapVerticalBar</h2>
            <hr />
            
            <p>If the top of the stack is an element followed by an opVerticalBar
swapVerticalBar swaps the two and returns true.
Otherwise it returns false.</p>
            
            <pre><code>func swapVerticalBar() bool</code></pre>
         </article>
         
         <article class="function" data-name="parseRightParen">
            <h2>parseRightParen</h2>
            <hr />
            
            <p>parseRightParen handles a ) in the input.</p>
            
            <pre><code>func parseRightParen() error</code></pre>
         </article>
         
         <article class="function" data-name="parseEscape">
            <h2>parseEscape</h2>
            <hr />
            
            <p>parseEscape parses an escape sequence at the beginning of s
and returns the rune.</p>
            
            <pre><code>func parseEscape(s string) (r rune, rest string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseClassChar">
            <h2>parseClassChar</h2>
            <hr />
            
            <p>parseClassChar parses a character class character at the beginning of s
and returns it.</p>
            
            <pre><code>func parseClassChar(s string, wholeClass string) (r rune, rest string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parsePerlClassEscape">
            <h2>parsePerlClassEscape</h2>
            <hr />
            
            <p>parsePerlClassEscape parses a leading Perl character class escape like \d
from the beginning of s. If one is present, it appends the characters to r
and returns the new slice r and the remainder of the string.</p>
            
            <pre><code>func parsePerlClassEscape(s string, r []rune) (out []rune, rest string)</code></pre>
         </article>
         
         <article class="function" data-name="parseNamedClass">
            <h2>parseNamedClass</h2>
            <hr />
            
            <p>parseNamedClass parses a leading POSIX named character class like [:alnum:]
from the beginning of s. If one is present, it appends the characters to r
and returns the new slice r and the remainder of the string.</p>
            
            <pre><code>func parseNamedClass(s string, r []rune) (out []rune, rest string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="appendGroup">
            <h2>appendGroup</h2>
            <hr />
            
            <pre><code>func appendGroup(r []rune, g charGroup) []rune</code></pre>
         </article>
         
         <article class="function" data-name="unicodeTable">
            <h2>unicodeTable</h2>
            <hr />
            
            <p>unicodeTable returns the unicode.RangeTable identified by name
and the table of additional fold-equivalent code points.</p>
            
            <pre><code>func unicodeTable(name string) (*unicode.RangeTable, *unicode.RangeTable)</code></pre>
         </article>
         
         <article class="function" data-name="parseUnicodeClass">
            <h2>parseUnicodeClass</h2>
            <hr />
            
            <p>parseUnicodeClass parses a leading Unicode character class like \p{Han}
from the beginning of s. If one is present, it appends the characters to r
and returns the new slice r and the remainder of the string.</p>
            
            <pre><code>func parseUnicodeClass(s string, r []rune) (out []rune, rest string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseClass">
            <h2>parseClass</h2>
            <hr />
            
            <p>parseClass parses a character class at the beginning of s
and pushes it onto the parse stack.</p>
            
            <pre><code>func parseClass(s string) (rest string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="cleanClass">
            <h2>cleanClass</h2>
            <hr />
            
            <p>cleanClass sorts the ranges (pairs of elements of r),
merges them, and eliminates duplicates.</p>
            
            <pre><code>func cleanClass(rp *[]rune) []rune</code></pre>
         </article>
         
         <article class="function" data-name="inCharClass">
            <h2>inCharClass</h2>
            <hr />
            
            <p>inCharClass reports whether r is in the class.
It assumes the class has been cleaned by cleanClass.</p>
            
            <pre><code>func inCharClass(r rune, class []rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="appendLiteral">
            <h2>appendLiteral</h2>
            <hr />
            
            <p>appendLiteral returns the result of appending the literal x to the class r.</p>
            
            <pre><code>func appendLiteral(r []rune, x rune, flags Flags) []rune</code></pre>
         </article>
         
         <article class="function" data-name="appendRange">
            <h2>appendRange</h2>
            <hr />
            
            <p>appendRange returns the result of appending the range lo-hi to the class r.</p>
            
            <pre><code>func appendRange(r []rune, lo rune, hi rune) []rune</code></pre>
         </article>
         
         <article class="function" data-name="appendFoldedRange">
            <h2>appendFoldedRange</h2>
            <hr />
            
            <p>appendFoldedRange returns the result of appending the range lo-hi
and its case folding-equivalent runes to the class r.</p>
            
            <pre><code>func appendFoldedRange(r []rune, lo rune, hi rune) []rune</code></pre>
         </article>
         
         <article class="function" data-name="appendClass">
            <h2>appendClass</h2>
            <hr />
            
            <p>appendClass returns the result of appending the class x to the class r.
It assume x is clean.</p>
            
            <pre><code>func appendClass(r []rune, x []rune) []rune</code></pre>
         </article>
         
         <article class="function" data-name="appendFoldedClass">
            <h2>appendFoldedClass</h2>
            <hr />
            
            <p>appendFoldedClass returns the result of appending the case folding of the class x to the class r.</p>
            
            <pre><code>func appendFoldedClass(r []rune, x []rune) []rune</code></pre>
         </article>
         
         <article class="function" data-name="appendNegatedClass">
            <h2>appendNegatedClass</h2>
            <hr />
            
            <p>appendNegatedClass returns the result of appending the negation of the class x to the class r.
It assumes x is clean.</p>
            
            <pre><code>func appendNegatedClass(r []rune, x []rune) []rune</code></pre>
         </article>
         
         <article class="function" data-name="appendTable">
            <h2>appendTable</h2>
            <hr />
            
            <p>appendTable returns the result of appending x to the class r.</p>
            
            <pre><code>func appendTable(r []rune, x *unicode.RangeTable) []rune</code></pre>
         </article>
         
         <article class="function" data-name="appendNegatedTable">
            <h2>appendNegatedTable</h2>
            <hr />
            
            <p>appendNegatedTable returns the result of appending the negation of x to the class r.</p>
            
            <pre><code>func appendNegatedTable(r []rune, x *unicode.RangeTable) []rune</code></pre>
         </article>
         
         <article class="function" data-name="negateClass">
            <h2>negateClass</h2>
            <hr />
            
            <p>negateClass overwrites r and returns r's negation.
It assumes the class r is already clean.</p>
            
            <pre><code>func negateClass(r []rune) []rune</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="checkUTF8">
            <h2>checkUTF8</h2>
            <hr />
            
            <pre><code>func checkUTF8(s string) error</code></pre>
         </article>
         
         <article class="function" data-name="nextRune">
            <h2>nextRune</h2>
            <hr />
            
            <pre><code>func nextRune(s string) (c rune, t string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="isalnum">
            <h2>isalnum</h2>
            <hr />
            
            <pre><code>func isalnum(c rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="unhex">
            <h2>unhex</h2>
            <hr />
            
            <pre><code>func unhex(c rune) rune</code></pre>
         </article>
         
         <article class="function" data-name="TestParseSimple">
            <h2>TestParseSimple</h2>
            <hr />
            
            <pre><code>func TestParseSimple(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseFoldCase">
            <h2>TestParseFoldCase</h2>
            <hr />
            
            <pre><code>func TestParseFoldCase(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseLiteral">
            <h2>TestParseLiteral</h2>
            <hr />
            
            <pre><code>func TestParseLiteral(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseMatchNL">
            <h2>TestParseMatchNL</h2>
            <hr />
            
            <pre><code>func TestParseMatchNL(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseNoMatchNL">
            <h2>TestParseNoMatchNL</h2>
            <hr />
            
            <pre><code>func TestParseNoMatchNL(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testParseDump">
            <h2>testParseDump</h2>
            <hr />
            
            <p>Test Parse -> Dump.</p>
            
            <pre><code>func testParseDump(t *testing.T, tests []parseTest, flags Flags)</code></pre>
         </article>
         
         <article class="function" data-name="dump">
            <h2>dump</h2>
            <hr />
            
            <p>dump prints a string representation of the regexp showing
the structure explicitly.</p>
            
            <pre><code>func dump(re *Regexp) string</code></pre>
         </article>
         
         <article class="function" data-name="dumpRegexp">
            <h2>dumpRegexp</h2>
            <hr />
            
            <p>dumpRegexp writes an encoding of the syntax tree for the regexp re to b.
It is used during testing to distinguish between parses that might print
the same using re's String method.</p>
            
            <pre><code>func dumpRegexp(b *strings.Builder, re *Regexp)</code></pre>
         </article>
         
         <article class="function" data-name="mkCharClass">
            <h2>mkCharClass</h2>
            <hr />
            
            <pre><code>func mkCharClass(f func) string</code></pre>
         </article>
         
         <article class="function" data-name="isUpperFold">
            <h2>isUpperFold</h2>
            <hr />
            
            <pre><code>func isUpperFold(r rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestFoldConstants">
            <h2>TestFoldConstants</h2>
            <hr />
            
            <pre><code>func TestFoldConstants(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAppendRangeCollapse">
            <h2>TestAppendRangeCollapse</h2>
            <hr />
            
            <pre><code>func TestAppendRangeCollapse(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseInvalidRegexps">
            <h2>TestParseInvalidRegexps</h2>
            <hr />
            
            <pre><code>func TestParseInvalidRegexps(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestToStringEquivalentParse">
            <h2>TestToStringEquivalentParse</h2>
            <hr />
            
            <pre><code>func TestToStringEquivalentParse(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestString">
            <h2>TestString</h2>
            <hr />
            
            <pre><code>func TestString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="EmptyOpContext">
            <h2>EmptyOpContext</h2>
            <hr />
            
            <p>EmptyOpContext returns the zero-width assertions
satisfied at the position between the runes r1 and r2.
Passing r1 == -1 indicates that the position is
at the beginning of the text.
Passing r2 == -1 indicates that the position is
at the end of the text.</p>
            
            <pre><code>func EmptyOpContext(r1 rune, r2 rune) EmptyOp</code></pre>
         </article>
         
         <article class="function" data-name="IsWordChar">
            <h2>IsWordChar</h2>
            <hr />
            
            <p>IsWordChar reports whether r is considered a “word character”
during the evaluation of the \b and \B zero-width assertions.
These assertions are ASCII-only: the word characters are [A-Za-z0-9_].</p>
            
            <pre><code>func IsWordChar(r rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="skipNop">
            <h2>skipNop</h2>
            <hr />
            
            <p>skipNop follows any no-op or capturing instructions.</p>
            
            <pre><code>func skipNop(pc uint32) *Inst</code></pre>
         </article>
         
         <article class="function" data-name="op">
            <h2>op</h2>
            <hr />
            
            <p>op returns i.Op but merges all the Rune special cases into InstRune</p>
            
            <pre><code>func op() InstOp</code></pre>
         </article>
         
         <article class="function" data-name="Prefix">
            <h2>Prefix</h2>
            <hr />
            
            <p>Prefix returns a literal string that all matches for the
regexp must start with. Complete is true if the prefix
is the entire match.</p>
            
            <pre><code>func Prefix() (prefix string, complete bool)</code></pre>
         </article>
         
         <article class="function" data-name="StartCond">
            <h2>StartCond</h2>
            <hr />
            
            <p>StartCond returns the leading empty-width conditions that must
be true in any match. It returns ^EmptyOp(0) if no matches are possible.</p>
            
            <pre><code>func StartCond() EmptyOp</code></pre>
         </article>
         
         <article class="function" data-name="MatchRune">
            <h2>MatchRune</h2>
            <hr />
            
            <p>MatchRune reports whether the instruction matches (and consumes) r.
It should only be called when i.Op == [InstRune].</p>
            
            <pre><code>func MatchRune(r rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="MatchRunePos">
            <h2>MatchRunePos</h2>
            <hr />
            
            <p>MatchRunePos checks whether the instruction matches (and consumes) r.
If so, MatchRunePos returns the index of the matching rune pair
(or, when len(i.Rune) == 1, rune singleton).
If not, MatchRunePos returns -1.
MatchRunePos should only be called when i.Op == [InstRune].</p>
            
            <pre><code>func MatchRunePos(r rune) int</code></pre>
         </article>
         
         <article class="function" data-name="MatchEmptyWidth">
            <h2>MatchEmptyWidth</h2>
            <hr />
            
            <p>MatchEmptyWidth reports whether the instruction matches
an empty string between the runes before and after.
It should only be called when i.Op == [InstEmptyWidth].</p>
            
            <pre><code>func MatchEmptyWidth(before rune, after rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="bw">
            <h2>bw</h2>
            <hr />
            
            <pre><code>func bw(b *strings.Builder, args ...string)</code></pre>
         </article>
         
         <article class="function" data-name="dumpProg">
            <h2>dumpProg</h2>
            <hr />
            
            <pre><code>func dumpProg(b *strings.Builder, p *Prog)</code></pre>
         </article>
         
         <article class="function" data-name="u32">
            <h2>u32</h2>
            <hr />
            
            <pre><code>func u32(i uint32) string</code></pre>
         </article>
         
         <article class="function" data-name="dumpInst">
            <h2>dumpInst</h2>
            <hr />
            
            <pre><code>func dumpInst(b *strings.Builder, i *Inst)</code></pre>
         </article>
         
         <article class="function" data-name="Simplify">
            <h2>Simplify</h2>
            <hr />
            
            <p>Simplify returns a regexp equivalent to re but without counted repetitions
and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/.
The resulting regexp will execute correctly but its string representation
will not produce the same parse tree, because capturing parentheses
may have been duplicated or removed. For example, the simplified form
for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1.
The returned regexp may share structure with or be the original.</p>
            
            <pre><code>func Simplify() *Regexp</code></pre>
         </article>
         
         <article class="function" data-name="simplify1">
            <h2>simplify1</h2>
            <hr />
            
            <p>simplify1 implements Simplify for the unary OpStar,
OpPlus, and OpQuest operators. It returns the simple regexp
equivalent to

	Regexp{Op: op, Flags: flags, Sub: {sub}}

under the assumption that sub is already simple, and
without first allocating that structure. If the regexp
to be returned turns out to be equivalent to re, simplify1
returns re instead.

simplify1 is factored out of Simplify because the implementation
for other operators generates these unary expressions.
Letting them call simplify1 makes sure the expressions they
generate are simple.</p>
            
            <pre><code>func simplify1(op Op, flags Flags, sub *Regexp, re *Regexp) *Regexp</code></pre>
         </article>
         
         <article class="function" data-name="makePatchList">
            <h2>makePatchList</h2>
            <hr />
            
            <pre><code>func makePatchList(n uint32) patchList</code></pre>
         </article>
         
         <article class="function" data-name="patch">
            <h2>patch</h2>
            <hr />
            
            <pre><code>func patch(p *Prog, val uint32)</code></pre>
         </article>
         
         <article class="function" data-name="append">
            <h2>append</h2>
            <hr />
            
            <pre><code>func append(p *Prog, l2 patchList) patchList</code></pre>
         </article>
         
         <article class="function" data-name="Compile">
            <h2>Compile</h2>
            <hr />
            
            <p>Compile compiles the regexp into a program to be executed.
The regexp should have been simplified already (returned from re.Simplify).</p>
            
            <pre><code>func Compile(re *Regexp) (*Prog, error)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="compile">
            <h2>compile</h2>
            <hr />
            
            <pre><code>func compile(re *Regexp) frag</code></pre>
         </article>
         
         <article class="function" data-name="inst">
            <h2>inst</h2>
            <hr />
            
            <pre><code>func inst(op InstOp) frag</code></pre>
         </article>
         
         <article class="function" data-name="nop">
            <h2>nop</h2>
            <hr />
            
            <pre><code>func nop() frag</code></pre>
         </article>
         
         <article class="function" data-name="fail">
            <h2>fail</h2>
            <hr />
            
            <pre><code>func fail() frag</code></pre>
         </article>
         
         <article class="function" data-name="cap">
            <h2>cap</h2>
            <hr />
            
            <pre><code>func cap(arg uint32) frag</code></pre>
         </article>
         
         <article class="function" data-name="cat">
            <h2>cat</h2>
            <hr />
            
            <pre><code>func cat(f1 frag, f2 frag) frag</code></pre>
         </article>
         
         <article class="function" data-name="alt">
            <h2>alt</h2>
            <hr />
            
            <pre><code>func alt(f1 frag, f2 frag) frag</code></pre>
         </article>
         
         <article class="function" data-name="quest">
            <h2>quest</h2>
            <hr />
            
            <pre><code>func quest(f1 frag, nongreedy bool) frag</code></pre>
         </article>
         
         <article class="function" data-name="loop">
            <h2>loop</h2>
            <hr />
            
            <p>loop returns the fragment for the main loop of a plus or star.
For plus, it can be used after changing the entry to f1.i.
For star, it can be used directly when f1 can't match an empty string.
(When f1 can match an empty string, f1* must be implemented as (f1+)?
to get the priority match order correct.)</p>
            
            <pre><code>func loop(f1 frag, nongreedy bool) frag</code></pre>
         </article>
         
         <article class="function" data-name="star">
            <h2>star</h2>
            <hr />
            
            <pre><code>func star(f1 frag, nongreedy bool) frag</code></pre>
         </article>
         
         <article class="function" data-name="plus">
            <h2>plus</h2>
            <hr />
            
            <pre><code>func plus(f1 frag, nongreedy bool) frag</code></pre>
         </article>
         
         <article class="function" data-name="empty">
            <h2>empty</h2>
            <hr />
            
            <pre><code>func empty(op EmptyOp) frag</code></pre>
         </article>
         
         <article class="function" data-name="rune">
            <h2>rune</h2>
            <hr />
            
            <pre><code>func rune(r []rune, flags Flags) frag</code></pre>
         </article>
         
         <article class="function" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>func _()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="TestCompile">
            <h2>TestCompile</h2>
            <hr />
            
            <pre><code>func TestCompile(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEmptyOpContext">
            <h2>BenchmarkEmptyOpContext</h2>
            <hr />
            
            <pre><code>func BenchmarkEmptyOpContext(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkIsWordChar">
            <h2>BenchmarkIsWordChar</h2>
            <hr />
            
            <pre><code>func BenchmarkIsWordChar(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="Equal">
            <h2>Equal</h2>
            <hr />
            
            <p>Equal reports whether x and y have identical structure.</p>
            
            <pre><code>func Equal(y *Regexp) bool</code></pre>
         </article>
         
         <article class="function" data-name="addSpan">
            <h2>addSpan</h2>
            <hr />
            
            <p>addSpan enables the flags f around start..last,
by setting flags[start] = f and flags[last] = flagOff.</p>
            
            <pre><code>func addSpan(start *Regexp, last *Regexp, f printFlags, flags **ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="calcFlags">
            <h2>calcFlags</h2>
            <hr />
            
            <p>calcFlags calculates the flags to print around each subexpression in re,
storing that information in (*flags)[sub] for each affected subexpression.
The first time an entry needs to be written to *flags, calcFlags allocates the map.
calcFlags also calculates the flags that must be active or can't be active
around re and returns those flags.</p>
            
            <pre><code>func calcFlags(re *Regexp, flags **ast.MapType) (must printFlags, cant printFlags)</code></pre>
         </article>
         
         <article class="function" data-name="writeRegexp">
            <h2>writeRegexp</h2>
            <hr />
            
            <p>writeRegexp writes the Perl syntax for the regular expression re to b.</p>
            
            <pre><code>func writeRegexp(b *strings.Builder, re *Regexp, f printFlags, flags *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="escape">
            <h2>escape</h2>
            <hr />
            
            <pre><code>func escape(b *strings.Builder, r rune, force bool)</code></pre>
         </article>
         
         <article class="function" data-name="MaxCap">
            <h2>MaxCap</h2>
            <hr />
            
            <p>MaxCap walks the regexp to find the maximum capture index.</p>
            
            <pre><code>func MaxCap() int</code></pre>
         </article>
         
         <article class="function" data-name="CapNames">
            <h2>CapNames</h2>
            <hr />
            
            <p>CapNames walks the regexp to find the names of capturing groups.</p>
            
            <pre><code>func CapNames() []string</code></pre>
         </article>
         
         <article class="function" data-name="capNames">
            <h2>capNames</h2>
            <hr />
            
            <pre><code>func capNames(names []string)</code></pre>
         </article>
         
         <article class="function" data-name="TestSimplify">
            <h2>TestSimplify</h2>
            <hr />
            
            <pre><code>func TestSimplify(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
