<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - reflect</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>reflect</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"unsafe"
"iter"
"internal/abi"
"unsafe"
"internal/abi"
"internal/race"
"internal/runtime/maps"
"internal/runtime/sys"
"unsafe"
"internal/abi"
"internal/goarch"
"unsafe"
"internal/abi"
"internal/goarch"
"internal/unsafeheader"
"unsafe"
"errors"
"internal/abi"
"internal/goarch"
"internal/itoa"
"internal/unsafeheader"
"math"
"runtime"
"unsafe"
"arena"
"internal/abi"
"internal/goarch"
"runtime"
"strconv"
"sync"
"unicode"
"unicode/utf8"
"unsafe"
"internal/abi"
"internal/goarch"
"unsafe"
"internal/abi"
"unsafe"
_ "unsafe"
"internal/bytealg"
"unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="Array">
               <h3>
                  Array 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Array</code></pre>
            </article>
            
            <article class="global" data-name="Bool">
               <h3>
                  Bool 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Bool</code></pre>
            </article>
            
            <article class="global" data-name="BothDir">
               <h3>
                  BothDir 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BothDir = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="Chan">
               <h3>
                  Chan 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Chan</code></pre>
            </article>
            
            <article class="global" data-name="Complex128">
               <h3>
                  Complex128 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Complex128</code></pre>
            </article>
            
            <article class="global" data-name="Complex64">
               <h3>
                  Complex64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Complex64</code></pre>
            </article>
            
            <article class="global" data-name="Float32">
               <h3>
                  Float32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Float32</code></pre>
            </article>
            
            <article class="global" data-name="Float64">
               <h3>
                  Float64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Float64</code></pre>
            </article>
            
            <article class="global" data-name="Func">
               <h3>
                  Func 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Func</code></pre>
            </article>
            
            <article class="global" data-name="Int">
               <h3>
                  Int 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Int</code></pre>
            </article>
            
            <article class="global" data-name="Int16">
               <h3>
                  Int16 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Int16</code></pre>
            </article>
            
            <article class="global" data-name="Int32">
               <h3>
                  Int32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Int32</code></pre>
            </article>
            
            <article class="global" data-name="Int64">
               <h3>
                  Int64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Int64</code></pre>
            </article>
            
            <article class="global" data-name="Int8">
               <h3>
                  Int8 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Int8</code></pre>
            </article>
            
            <article class="global" data-name="Interface">
               <h3>
                  Interface 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Interface</code></pre>
            </article>
            
            <article class="global" data-name="Invalid">
               <h3>
                  Invalid 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Invalid Kind = iota</code></pre>
            </article>
            
            <article class="global" data-name="Map">
               <h3>
                  Map 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Map</code></pre>
            </article>
            
            <article class="global" data-name="Pointer">
               <h3>
                  Pointer 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Pointer</code></pre>
            </article>
            
            <article class="global" data-name="Ptr">
               <h3>
                  Ptr 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Ptr is the old name for the [Pointer] kind.</p>
               
               <pre><code>const Ptr = Pointer</code></pre>
            </article>
            
            <article class="global" data-name="RecvDir">
               <h3>
                  RecvDir 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const RecvDir ChanDir = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="SelectDefault">
               <h3>
                  SelectDefault 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SelectDefault</code></pre>
            </article>
            
            <article class="global" data-name="SelectRecv">
               <h3>
                  SelectRecv 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SelectRecv</code></pre>
            </article>
            
            <article class="global" data-name="SelectSend">
               <h3>
                  SelectSend 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SelectSend</code></pre>
            </article>
            
            <article class="global" data-name="SendDir">
               <h3>
                  SendDir 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SendDir</code></pre>
            </article>
            
            <article class="global" data-name="Slice">
               <h3>
                  Slice 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Slice</code></pre>
            </article>
            
            <article class="global" data-name="String">
               <h3>
                  String 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const String</code></pre>
            </article>
            
            <article class="global" data-name="Struct">
               <h3>
                  Struct 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Struct</code></pre>
            </article>
            
            <article class="global" data-name="Uint">
               <h3>
                  Uint 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Uint</code></pre>
            </article>
            
            <article class="global" data-name="Uint16">
               <h3>
                  Uint16 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Uint16</code></pre>
            </article>
            
            <article class="global" data-name="Uint32">
               <h3>
                  Uint32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Uint32</code></pre>
            </article>
            
            <article class="global" data-name="Uint64">
               <h3>
                  Uint64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Uint64</code></pre>
            </article>
            
            <article class="global" data-name="Uint8">
               <h3>
                  Uint8 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Uint8</code></pre>
            </article>
            
            <article class="global" data-name="Uintptr">
               <h3>
                  Uintptr 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Uintptr</code></pre>
            </article>
            
            <article class="global" data-name="UnsafePointer">
               <h3>
                  UnsafePointer 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const UnsafePointer</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _ SelectDir = iota</code></pre>
            </article>
            
            <article class="global" data-name="abiStepBad">
               <h3>
                  abiStepBad 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const abiStepBad abiStepKind = iota</code></pre>
            </article>
            
            <article class="global" data-name="abiStepFloatReg">
               <h3>
                  abiStepFloatReg 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const abiStepFloatReg</code></pre>
            </article>
            
            <article class="global" data-name="abiStepIntReg">
               <h3>
                  abiStepIntReg 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const abiStepIntReg</code></pre>
            </article>
            
            <article class="global" data-name="abiStepPointer">
               <h3>
                  abiStepPointer 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const abiStepPointer</code></pre>
            </article>
            
            <article class="global" data-name="abiStepStack">
               <h3>
                  abiStepStack 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const abiStepStack</code></pre>
            </article>
            
            <article class="global" data-name="bytesType">
               <h3>
                  bytesType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var bytesType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="callGC">
               <h3>
                  callGC 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var callGC bool</code></pre>
            </article>
            
            <article class="global" data-name="debugReflectCall">
               <h3>
                  debugReflectCall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const debugReflectCall = false</code></pre>
            </article>
            
            <article class="global" data-name="dummy">
               <h3>
                  dummy 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dummy struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="flagAddr">
               <h3>
                  flagAddr 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagAddr flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagEmbedRO">
               <h3>
                  flagEmbedRO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagEmbedRO flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagIndir">
               <h3>
                  flagIndir 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagIndir flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagKindMask">
               <h3>
                  flagKindMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagKindMask flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagKindWidth">
               <h3>
                  flagKindWidth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagKindWidth = 5</code></pre>
            </article>
            
            <article class="global" data-name="flagMethod">
               <h3>
                  flagMethod 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagMethod flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagMethodShift">
               <h3>
                  flagMethodShift 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagMethodShift = 10</code></pre>
            </article>
            
            <article class="global" data-name="flagRO">
               <h3>
                  flagRO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagRO flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="flagStickyRO">
               <h3>
                  flagStickyRO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const flagStickyRO flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="floatArgRegs">
               <h3>
                  floatArgRegs 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>These variables are used by the register assignment
algorithm in this file.
They should be modified with care (no other reflect code
may be executing) and are generally only modified
when testing this package.
They should never be set higher than their internal/abi
constant counterparts, because the system relies on a
structure that is at least large enough to hold the
registers the system supports.
Currently they're set to zero because using the actual
constants will break every part of the toolchain that
uses reflect to call functions (e.g. go test, or anything
that uses text/template). The values that are currently
commented out there should be the actual values once
we're ready to use the register ABI everywhere.</p>
               
               <pre><code>var floatArgRegs = abi.FloatArgRegs</code></pre>
            </article>
            
            <article class="global" data-name="floatRegSize">
               <h3>
                  floatRegSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>These variables are used by the register assignment
algorithm in this file.
They should be modified with care (no other reflect code
may be executing) and are generally only modified
when testing this package.
They should never be set higher than their internal/abi
constant counterparts, because the system relies on a
structure that is at least large enough to hold the
registers the system supports.
Currently they're set to zero because using the actual
constants will break every part of the toolchain that
uses reflect to call functions (e.g. go test, or anything
that uses text/template). The values that are currently
commented out there should be the actual values once
we're ready to use the register ABI everywhere.</p>
               
               <pre><code>var floatRegSize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="funcLookupCache">
               <h3>
                  funcLookupCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>The funcLookupCache caches FuncOf lookups.
FuncOf does not share the common lookupCache since cacheKey is not
sufficient to represent functions unambiguously.</p>
               
               <pre><code>var funcLookupCache struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="funcTypes">
               <h3>
                  funcTypes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var funcTypes []Type</code></pre>
            </article>
            
            <article class="global" data-name="funcTypesMutex">
               <h3>
                  funcTypesMutex 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var funcTypesMutex sync.Mutex</code></pre>
            </article>
            
            <article class="global" data-name="intArgRegs">
               <h3>
                  intArgRegs 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>These variables are used by the register assignment
algorithm in this file.
They should be modified with care (no other reflect code
may be executing) and are generally only modified
when testing this package.
They should never be set higher than their internal/abi
constant counterparts, because the system relies on a
structure that is at least large enough to hold the
registers the system supports.
Currently they're set to zero because using the actual
constants will break every part of the toolchain that
uses reflect to call functions (e.g. go test, or anything
that uses text/template). The values that are currently
commented out there should be the actual values once
we're ready to use the register ABI everywhere.</p>
               
               <pre><code>var intArgRegs = abi.IntArgRegs</code></pre>
            </article>
            
            <article class="global" data-name="kindNames">
               <h3>
                  kindNames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var kindNames = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="layoutCache">
               <h3>
                  layoutCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var layoutCache sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="lookupCache">
               <h3>
                  lookupCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>The lookupCache caches ArrayOf, ChanOf, MapOf and SliceOf lookups.</p>
               
               <pre><code>var lookupCache sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="ptrMap">
               <h3>
                  ptrMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>ptrMap is the cache for PointerTo.</p>
               
               <pre><code>var ptrMap sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="stringType">
               <h3>
                  stringType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var stringType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="stringType">
               <h3>
                  stringType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var stringType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="structLookupCache">
               <h3>
                  structLookupCache 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>The structLookupCache caches StructOf lookups.
StructOf does not share the common lookupCache since we need to pin
the memory associated with *structTypeFixedN.</p>
               
               <pre><code>var structLookupCache struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="uint8Type">
               <h3>
                  uint8Type 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var uint8Type = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="zeroVal">
               <h3>
                  zeroVal 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>go:linkname zeroVal runtime.zeroVal</p>
               
               <pre><code>var zeroVal [abi.ZeroValSize]byte</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="ChanDir">
               <h3>
                  ChanDir
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>ChanDir represents a channel type's direction.</p>
               
               <pre><code>type ChanDir int</code></pre>
            </article>
            
            <article class="type" data-name="Kind">
               <h3>
                  Kind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Kind represents the specific kind of type that a [Type] represents.
The zero Kind is not a valid kind.</p>
               
               <pre><code>type Kind uint</code></pre>
            </article>
            
            <article class="type" data-name="SelectDir">
               <h3>
                  SelectDir
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A SelectDir describes the communication direction of a select case.</p>
               
               <pre><code>type SelectDir int</code></pre>
            </article>
            
            <article class="type" data-name="StructTag">
               <h3>
                  StructTag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A StructTag is the tag string in a struct field.
By convention, tag strings are a concatenation of
optionally space-separated key:"value" pairs.
Each key is a non-empty string consisting of non-control
characters other than space (U+0020 ' '), quote (U+0022 '"'),
and colon (U+003A ':').  Each value is quoted using U+0022 '"'
characters and Go string literal syntax.</p>
               
               <pre><code>type StructTag string</code></pre>
            </article>
            
            <article class="type" data-name="aNameOff">
               <h3>
                  aNameOff
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type aNameOff abi.NameOff</code></pre>
            </article>
            
            <article class="type" data-name="aTextOff">
               <h3>
                  aTextOff
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type aTextOff abi.TextOff</code></pre>
            </article>
            
            <article class="type" data-name="aTypeOff">
               <h3>
                  aTypeOff
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type aTypeOff abi.TypeOff</code></pre>
            </article>
            
            <article class="type" data-name="abiStepKind">
               <h3>
                  abiStepKind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>abiStepKind is the "op-code" for an abiStep instruction.</p>
               
               <pre><code>type abiStepKind int</code></pre>
            </article>
            
            <article class="type" data-name="arrayType">
               <h3>
                  arrayType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>arrayType represents a fixed array type.</p>
               
               <pre><code>type arrayType abi.ArrayType</code></pre>
            </article>
            
            <article class="type" data-name="chanType">
               <h3>
                  chanType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>chanType represents a channel type.</p>
               
               <pre><code>type chanType abi.ChanType</code></pre>
            </article>
            
            <article class="type" data-name="flag">
               <h3>
                  flag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type flag uintptr</code></pre>
            </article>
            
            <article class="type" data-name="funcType">
               <h3>
                  funcType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>funcType represents a function type.
A *rtype for each in and out parameter is stored in an array that
directly follows the funcType (and possibly its uncommonType). So
a function type with one method, one input, and one output is:
struct {
funcType
uncommonType
[2]*rtype    // [0] is in, [1] is out
}</p>
               
               <pre><code>type funcType abi.FuncType</code></pre>
            </article>
            
            <article class="type" data-name="hiter">
               <h3>
                  hiter
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>TODO(prattmic): only for sharing the linkname declarations with old maps.
Remove with old maps.</p>
               
               <pre><code>type hiter maps.Iter</code></pre>
            </article>
            
            <article class="type" data-name="mapType">
               <h3>
                  mapType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>mapType represents a map type.
TODO(prattmic): Only used within this file, could be cleaned up.</p>
               
               <pre><code>type mapType abi.SwissMapType</code></pre>
            </article>
            
            <article class="type" data-name="structField">
               <h3>
                  structField
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Struct field</p>
               
               <pre><code>type structField abi.StructField</code></pre>
            </article>
            
            <article class="type" data-name="uncommonType">
               <h3>
                  uncommonType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>uncommonType is present only for defined types or types with methods
(if T is a defined type, the uncommonTypes for T and *T have methods).
Using a pointer to this struct reduces the overall size required
to describe a non-defined type with no methods.</p>
               
               <pre><code>type uncommonType abi.UncommonType</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Type">
               <h3>
                  Type
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Type is the representation of a Go type.
Not all methods apply to all kinds of types. Restrictions,
if any, are noted in the documentation for each method.
Use the Kind method to find out the kind of type before
calling kind-specific methods. Calling a method
inappropriate to the kind of type causes a run-time panic.
Type values are comparable, such as with the == operator,
so they can be used as map keys.
Two Type values are equal if they represent identical types.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Type interface {
Align() int
FieldAlign() int
Method(int) Method
MethodByName(string) (Method, bool)
NumMethod() int
Name() string
PkgPath() string
Size() uintptr
String() string
Kind() Kind
Implements(u Type) bool
AssignableTo(u Type) bool
ConvertibleTo(u Type) bool
Comparable() bool
Bits() int
ChanDir() ChanDir
IsVariadic() bool
Elem() Type
Field(i int) StructField
FieldByIndex(index []int) StructField
FieldByName(name string) (StructField, bool)
FieldByNameFunc(match func(string) bool) (StructField, bool)
In(i int) Type
Key() Type
Len() int
NumField() int
NumIn() int
NumOut() int
Out(i int) Type
OverflowComplex(x complex128) bool
OverflowFloat(x float64) bool
OverflowInt(x int64) bool
OverflowUint(x uint64) bool
CanSeq() bool
CanSeq2() bool
common() *abi.Type
uncommon() *uncommonType
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="MapIter">
               <h3>
                  MapIter
                  <span class="badge">struct</span>
               </h3>
               
               <p>A MapIter is an iterator for ranging over a map.
See [Value.MapRange].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MapIter struct {
m Value
hiter hiter
}</code></pre>
            </article>
            
            <article class="struct" data-name="MapIter">
               <h3>
                  MapIter
                  <span class="badge">struct</span>
               </h3>
               
               <p>A MapIter is an iterator for ranging over a map.
See [Value.MapRange].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MapIter struct {
m Value
hiter maps.Iter
}</code></pre>
            </article>
            
            <article class="struct" data-name="Method">
               <h3>
                  Method
                  <span class="badge">struct</span>
               </h3>
               
               <p>Method represents a single method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Method struct {
Name string
PkgPath string
Type Type
Func Value
Index int
}</code></pre>
            </article>
            
            <article class="struct" data-name="SelectCase">
               <h3>
                  SelectCase
                  <span class="badge">struct</span>
               </h3>
               
               <p>A SelectCase describes a single case in a select operation.
The kind of case depends on Dir, the communication direction.
If Dir is SelectDefault, the case represents a default case.
Chan and Send must be zero Values.
If Dir is SelectSend, the case represents a send operation.
Normally Chan's underlying value must be a channel, and Send's underlying value must be
assignable to the channel's element type. As a special case, if Chan is a zero Value,
then the case is ignored, and the field Send will also be ignored and may be either zero
or non-zero.
If Dir is [SelectRecv], the case represents a receive operation.
Normally Chan's underlying value must be a channel and Send must be a zero Value.
If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value.
When a receive operation is selected, the received Value is returned by Select.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SelectCase struct {
Dir SelectDir
Chan Value
Send Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="SliceHeader">
               <h3>
                  SliceHeader
                  <span class="badge">struct</span>
               </h3>
               
               <p>SliceHeader is the runtime representation of a slice.
It cannot be used safely or portably and its representation may
change in a later release.
Moreover, the Data field is not sufficient to guarantee the data
it references will not be garbage collected, so programs must keep
a separate, correctly typed pointer to the underlying data.
Deprecated: Use unsafe.Slice or unsafe.SliceData instead.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SliceHeader struct {
Data uintptr
Len int
Cap int
}</code></pre>
            </article>
            
            <article class="struct" data-name="StringHeader">
               <h3>
                  StringHeader
                  <span class="badge">struct</span>
               </h3>
               
               <p>StringHeader is the runtime representation of a string.
It cannot be used safely or portably and its representation may
change in a later release.
Moreover, the Data field is not sufficient to guarantee the data
it references will not be garbage collected, so programs must keep
a separate, correctly typed pointer to the underlying data.
Deprecated: Use unsafe.String or unsafe.StringData instead.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StringHeader struct {
Data uintptr
Len int
}</code></pre>
            </article>
            
            <article class="struct" data-name="StructField">
               <h3>
                  StructField
                  <span class="badge">struct</span>
               </h3>
               
               <p>A StructField describes a single field in a struct.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StructField struct {
Name string
PkgPath string
Type Type
Tag StructTag
Offset uintptr
Index []int
Anonymous bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Value">
               <h3>
                  Value
                  <span class="badge">struct</span>
               </h3>
               
               <p>Value is the reflection interface to a Go value.
Not all methods apply to all kinds of values. Restrictions,
if any, are noted in the documentation for each method.
Use the Kind method to find out the kind of value before
calling kind-specific methods. Calling a method
inappropriate to the kind of type causes a run time panic.
The zero Value represents no value.
Its [Value.IsValid] method returns false, its Kind method returns [Invalid],
its String method returns "<invalid Value>", and all other methods panic.
Most functions and methods never return an invalid value.
If one does, its documentation states the conditions explicitly.
A Value can be used concurrently by multiple goroutines provided that
the underlying Go value can be used concurrently for the equivalent
direct operations.
To compare two Values, compare the results of the Interface method.
Using == on two Values does not compare the underlying values
they represent.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Value struct {
typ_ *abi.Type
ptr unsafe.Pointer
flag
}</code></pre>
            </article>
            
            <article class="struct" data-name="ValueError">
               <h3>
                  ValueError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ValueError occurs when a Value method is invoked on
a [Value] that does not support it. Such cases are documented
in the description of each method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ValueError struct {
Method string
Kind Kind
}</code></pre>
            </article>
            
            <article class="struct" data-name="abiDesc">
               <h3>
                  abiDesc
                  <span class="badge">struct</span>
               </h3>
               
               <p>abiDesc describes the ABI for a function or method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type abiDesc struct {
call abiSeq
ret abiSeq
stackCallArgsSize uintptr
retOffset uintptr
spill uintptr
stackPtrs *bitVector
inRegPtrs abi.IntArgRegBitmap
outRegPtrs abi.IntArgRegBitmap
}</code></pre>
            </article>
            
            <article class="struct" data-name="abiSeq">
               <h3>
                  abiSeq
                  <span class="badge">struct</span>
               </h3>
               
               <p>abiSeq represents a sequence of ABI instructions for copying
from a series of reflect.Values to a call frame (for call arguments)
or vice-versa (for call results).
An abiSeq should be populated by calling its addArg method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type abiSeq struct {
steps []abiStep
valueStart []int
stackBytes uintptr
iregs int
fregs int
}</code></pre>
            </article>
            
            <article class="struct" data-name="abiStep">
               <h3>
                  abiStep
                  <span class="badge">struct</span>
               </h3>
               
               <p>abiStep represents an ABI "instruction." Each instruction
describes one part of how to translate between a Go value
in memory and a call frame.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type abiStep struct {
kind abiStepKind
offset uintptr
size uintptr
stkOff uintptr
ireg int
freg int
}</code></pre>
            </article>
            
            <article class="struct" data-name="bitVector">
               <h3>
                  bitVector
                  <span class="badge">struct</span>
               </h3>
               
               <p>Note: this type must agree with runtime.bitvector.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type bitVector struct {
n uint32
data []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="cacheKey">
               <h3>
                  cacheKey
                  <span class="badge">struct</span>
               </h3>
               
               <p>A cacheKey is the key for use in the lookupCache.
Four values describe any of the types we are looking for:
type kind, one or two subtypes, and an extra integer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cacheKey struct {
kind Kind
t1 *abi.Type
t2 *abi.Type
extra uintptr
}</code></pre>
            </article>
            
            <article class="struct" data-name="common">
               <h3>
                  common
                  <span class="badge">struct</span>
               </h3>
               
               <p>Embed this type to get common/uncommon</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type common struct {
abi.Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="fieldScan">
               <h3>
                  fieldScan
                  <span class="badge">struct</span>
               </h3>
               
               <p>A fieldScan represents an item on the fieldByNameFunc scan work list.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fieldScan struct {
typ *structType
index []int
}</code></pre>
            </article>
            
            <article class="struct" data-name="hiter">
               <h3>
                  hiter
                  <span class="badge">struct</span>
               </h3>
               
               <p>hiter's structure matches runtime.hiter's structure.
Having a clone here allows us to embed a map iterator
inside type MapIter so that MapIters can be re-used
without doing any allocations.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type hiter struct {
key unsafe.Pointer
elem unsafe.Pointer
t unsafe.Pointer
h unsafe.Pointer
buckets unsafe.Pointer
bptr unsafe.Pointer
overflow *[]unsafe.Pointer
oldoverflow *[]unsafe.Pointer
startBucket uintptr
offset uint8
wrapped bool
B uint8
i uint8
bucket uintptr
checkBucket uintptr
clearSeq uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="interfaceType">
               <h3>
                  interfaceType
                  <span class="badge">struct</span>
               </h3>
               
               <p>interfaceType represents an interface type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type interfaceType struct {
abi.InterfaceType
}</code></pre>
            </article>
            
            <article class="struct" data-name="layoutKey">
               <h3>
                  layoutKey
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type layoutKey struct {
ftyp *funcType
rcvr *abi.Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="layoutType">
               <h3>
                  layoutType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type layoutType struct {
t *abi.Type
framePool *sync.Pool
abid abiDesc
}</code></pre>
            </article>
            
            <article class="struct" data-name="makeFuncCtxt">
               <h3>
                  makeFuncCtxt
                  <span class="badge">struct</span>
               </h3>
               
               <p>This structure must be kept in sync with runtime.reflectMethodValue.
Any changes should be reflected in all both.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type makeFuncCtxt struct {
fn uintptr
stack *bitVector
argLen uintptr
regPtrs abi.IntArgRegBitmap
}</code></pre>
            </article>
            
            <article class="struct" data-name="makeFuncImpl">
               <h3>
                  makeFuncImpl
                  <span class="badge">struct</span>
               </h3>
               
               <p>makeFuncImpl is the closure value implementing the function
returned by MakeFunc.
The first three words of this type must be kept in sync with
methodValue and runtime.reflectMethodValue.
Any changes should be reflected in all three.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type makeFuncImpl struct {
makeFuncCtxt
ftyp *funcType
fn func([]Value) []Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="mapType">
               <h3>
                  mapType
                  <span class="badge">struct</span>
               </h3>
               
               <p>mapType represents a map type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mapType struct {
abi.OldMapType
}</code></pre>
            </article>
            
            <article class="struct" data-name="methodValue">
               <h3>
                  methodValue
                  <span class="badge">struct</span>
               </h3>
               
               <p>The first 3 words of this type must be kept in sync with
makeFuncImpl and runtime.reflectMethodValue.
Any changes should be reflected in all three.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type methodValue struct {
makeFuncCtxt
method int
rcvr Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="nonEmptyInterface">
               <h3>
                  nonEmptyInterface
                  <span class="badge">struct</span>
               </h3>
               
               <p>nonEmptyInterface is the header for an interface value with methods.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nonEmptyInterface struct {
itab *abi.ITab
word unsafe.Pointer
}</code></pre>
            </article>
            
            <article class="struct" data-name="ptrType">
               <h3>
                  ptrType
                  <span class="badge">struct</span>
               </h3>
               
               <p>ptrType represents a pointer type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ptrType struct {
abi.PtrType
}</code></pre>
            </article>
            
            <article class="struct" data-name="rtype">
               <h3>
                  rtype
                  <span class="badge">struct</span>
               </h3>
               
               <p>rtype is the common implementation of most values.
It is embedded in other struct types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rtype struct {
t abi.Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="runtimeSelect">
               <h3>
                  runtimeSelect
                  <span class="badge">struct</span>
               </h3>
               
               <p>A runtimeSelect is a single case passed to rselect.
This must match ../runtime/select.go:/runtimeSelect</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type runtimeSelect struct {
dir SelectDir
typ *rtype
ch unsafe.Pointer
val unsafe.Pointer
}</code></pre>
            </article>
            
            <article class="struct" data-name="sliceType">
               <h3>
                  sliceType
                  <span class="badge">struct</span>
               </h3>
               
               <p>sliceType represents a slice type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sliceType struct {
abi.SliceType
}</code></pre>
            </article>
            
            <article class="struct" data-name="structType">
               <h3>
                  structType
                  <span class="badge">struct</span>
               </h3>
               
               <p>structType represents a struct type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type structType struct {
abi.StructType
}</code></pre>
            </article>
            
            <article class="struct" data-name="structTypeUncommon">
               <h3>
                  structTypeUncommon
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type structTypeUncommon struct {
structType
u uncommonType
}</code></pre>
            </article>
            
            <article class="struct" data-name="visibleFieldsWalker">
               <h3>
                  visibleFieldsWalker
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type visibleFieldsWalker struct {
byName map[string]int
visiting map[Type]bool
fields []StructField
index []int
}</code></pre>
            </article>
            
            <article class="struct" data-name="visit">
               <h3>
                  visit
                  <span class="badge">struct</span>
               </h3>
               
               <p>During deepValueEqual, must keep track of checks that are
in progress. The comparison algorithm assumes that all
checks in progress are true when it reencounters them.
Visited comparisons are stored in a map indexed by visit.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type visit struct {
a1 unsafe.Pointer
a2 unsafe.Pointer
typ Type
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Addr">
               <h3>
                  Addr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Addr returns a pointer value representing the address of v.
It panics if [Value.CanAddr] returns false.
Addr is typically used to obtain a pointer to a struct field
or slice element in order to call a method that requires a
pointer receiver.</p>
               
               <pre><code>func (v Value) Addr() Value</code></pre>
            </article>
            
            <article class="function" data-name="Align">
               <h3>
                  Align 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Align() int</code></pre>
            </article>
            
            <article class="function" data-name="Append">
               <h3>
                  Append 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Append appends the values x to a slice s and returns the resulting slice.
As in Go, each x's value must be assignable to the slice's element type.</p>
               
               <pre><code>func Append(s Value, x ...Value) Value</code></pre>
            </article>
            
            <article class="function" data-name="AppendSlice">
               <h3>
                  AppendSlice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AppendSlice appends a slice t to a slice s and returns the resulting slice.
The slices s and t must have the same element type.</p>
               
               <pre><code>func AppendSlice(s Value, t Value) Value</code></pre>
            </article>
            
            <article class="function" data-name="ArenaNew">
               <h3>
                  ArenaNew 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ArenaNew returns a [Value] representing a pointer to a new zero value for the
specified type, allocating storage for it in the provided arena. That is,
the returned Value's Type is [PointerTo](typ).</p>
               
               <pre><code>func ArenaNew(a *arena.Arena, typ Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="ArrayOf">
               <h3>
                  ArrayOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ArrayOf returns the array type with the given length and element type.
For example, if t represents int, ArrayOf(5, t) represents [5]int.
If the resulting type would be larger than the available address space,
ArrayOf panics.</p>
               
               <pre><code>func ArrayOf(length int, elem Type) Type</code></pre>
            </article>
            
            <article class="function" data-name="AssignableTo">
               <h3>
                  AssignableTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) AssignableTo(u Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="Bits">
               <h3>
                  Bits 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Bits() int</code></pre>
            </article>
            
            <article class="function" data-name="Bool">
               <h3>
                  Bool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bool returns v's underlying value.
It panics if v's kind is not [Bool].</p>
               
               <pre><code>func (v Value) Bool() bool</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bytes returns v's underlying value.
It panics if v's underlying value is not a slice of bytes or
an addressable array of bytes.</p>
               
               <pre><code>func (v Value) Bytes() []byte</code></pre>
            </article>
            
            <article class="function" data-name="Call">
               <h3>
                  Call 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Call calls the function v with the input arguments in.
For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]).
Call panics if v's Kind is not [Func].
It returns the output results as Values.
As in Go, each input argument must be assignable to the
type of the function's corresponding input parameter.
If v is a variadic function, Call creates the variadic slice parameter
itself, copying in the corresponding values.</p>
               
               <pre><code>func (v Value) Call(in []Value) []Value</code></pre>
            </article>
            
            <article class="function" data-name="CallSlice">
               <h3>
                  CallSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CallSlice calls the variadic function v with the input arguments in,
assigning the slice in[len(in)-1] to v's final variadic argument.
For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...).
CallSlice panics if v's Kind is not [Func] or if v is not variadic.
It returns the output results as Values.
As in Go, each input argument must be assignable to the
type of the function's corresponding input parameter.</p>
               
               <pre><code>func (v Value) CallSlice(in []Value) []Value</code></pre>
            </article>
            
            <article class="function" data-name="CanAddr">
               <h3>
                  CanAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CanAddr reports whether the value's address can be obtained with [Value.Addr].
Such values are called addressable. A value is addressable if it is
an element of a slice, an element of an addressable array,
a field of an addressable struct, or the result of dereferencing a pointer.
If CanAddr returns false, calling [Value.Addr] will panic.</p>
               
               <pre><code>func (v Value) CanAddr() bool</code></pre>
            </article>
            
            <article class="function" data-name="CanComplex">
               <h3>
                  CanComplex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CanComplex reports whether [Value.Complex] can be used without panicking.</p>
               
               <pre><code>func (v Value) CanComplex() bool</code></pre>
            </article>
            
            <article class="function" data-name="CanConvert">
               <h3>
                  CanConvert 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CanConvert reports whether the value v can be converted to type t.
If v.CanConvert(t) returns true then v.Convert(t) will not panic.</p>
               
               <pre><code>func (v Value) CanConvert(t Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="CanFloat">
               <h3>
                  CanFloat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CanFloat reports whether [Value.Float] can be used without panicking.</p>
               
               <pre><code>func (v Value) CanFloat() bool</code></pre>
            </article>
            
            <article class="function" data-name="CanInt">
               <h3>
                  CanInt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CanInt reports whether Int can be used without panicking.</p>
               
               <pre><code>func (v Value) CanInt() bool</code></pre>
            </article>
            
            <article class="function" data-name="CanInterface">
               <h3>
                  CanInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CanInterface reports whether [Value.Interface] can be used without panicking.</p>
               
               <pre><code>func (v Value) CanInterface() bool</code></pre>
            </article>
            
            <article class="function" data-name="CanSeq">
               <h3>
                  CanSeq 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) CanSeq() bool</code></pre>
            </article>
            
            <article class="function" data-name="CanSeq2">
               <h3>
                  CanSeq2 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) CanSeq2() bool</code></pre>
            </article>
            
            <article class="function" data-name="CanSet">
               <h3>
                  CanSet 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CanSet reports whether the value of v can be changed.
A [Value] can be changed only if it is addressable and was not
obtained by the use of unexported struct fields.
If CanSet returns false, calling [Value.Set] or any type-specific
setter (e.g., [Value.SetBool], [Value.SetInt]) will panic.</p>
               
               <pre><code>func (v Value) CanSet() bool</code></pre>
            </article>
            
            <article class="function" data-name="CanUint">
               <h3>
                  CanUint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CanUint reports whether [Value.Uint] can be used without panicking.</p>
               
               <pre><code>func (v Value) CanUint() bool</code></pre>
            </article>
            
            <article class="function" data-name="Cap">
               <h3>
                  Cap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Cap returns v's capacity.
It panics if v's Kind is not [Array], [Chan], [Slice] or pointer to [Array].</p>
               
               <pre><code>func (v Value) Cap() int</code></pre>
            </article>
            
            <article class="function" data-name="ChanDir">
               <h3>
                  ChanDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) ChanDir() ChanDir</code></pre>
            </article>
            
            <article class="function" data-name="ChanOf">
               <h3>
                  ChanOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ChanOf returns the channel type with the given direction and element type.
For example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.
The gc runtime imposes a limit of 64 kB on channel element types.
If t's size is equal to or exceeds this limit, ChanOf panics.</p>
               
               <pre><code>func ChanOf(dir ChanDir, t Type) Type</code></pre>
            </article>
            
            <article class="function" data-name="Clear">
               <h3>
                  Clear 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Clear clears the contents of a map or zeros the contents of a slice.
It panics if v's Kind is not [Map] or [Slice].</p>
               
               <pre><code>func (v Value) Clear()</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the channel v.
It panics if v's Kind is not [Chan] or
v is a receive-only channel.</p>
               
               <pre><code>func (v Value) Close()</code></pre>
            </article>
            
            <article class="function" data-name="Comparable">
               <h3>
                  Comparable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Comparable() bool</code></pre>
            </article>
            
            <article class="function" data-name="Comparable">
               <h3>
                  Comparable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Comparable reports whether the value v is comparable.
If the type of v is an interface, this checks the dynamic type.
If this reports true then v.Interface() == x will not panic for any x,
nor will v.Equal(u) for any Value u.</p>
               
               <pre><code>func (v Value) Comparable() bool</code></pre>
            </article>
            
            <article class="function" data-name="Complex">
               <h3>
                  Complex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Complex returns v's underlying value, as a complex128.
It panics if v's Kind is not [Complex64] or [Complex128]</p>
               
               <pre><code>func (v Value) Complex() complex128</code></pre>
            </article>
            
            <article class="function" data-name="Convert">
               <h3>
                  Convert 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Convert returns the value v converted to type t.
If the usual Go conversion rules do not allow conversion
of the value v to type t, or if converting v to type t panics, Convert panics.</p>
               
               <pre><code>func (v Value) Convert(t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="ConvertibleTo">
               <h3>
                  ConvertibleTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) ConvertibleTo(u Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Copy copies the contents of src into dst until either
dst has been filled or src has been exhausted.
It returns the number of elements copied.
Dst and src each must have kind [Slice] or [Array], and
dst and src must have the same element type.
It dst is an [Array], it panics if [Value.CanSet] returns false.
As a special case, src can have kind [String] if the element type of dst is kind [Uint8].</p>
               
               <pre><code>func Copy(dst Value, src Value) int</code></pre>
            </article>
            
            <article class="function" data-name="DeepEqual">
               <h3>
                  DeepEqual 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DeepEqual reports whether x and y are “deeply equal,” defined as follows.
Two values of identical type are deeply equal if one of the following cases applies.
Values of distinct types are never deeply equal.
Array values are deeply equal when their corresponding elements are deeply equal.
Struct values are deeply equal if their corresponding fields,
both exported and unexported, are deeply equal.
Func values are deeply equal if both are nil; otherwise they are not deeply equal.
Interface values are deeply equal if they hold deeply equal concrete values.
Map values are deeply equal when all of the following are true:
they are both nil or both non-nil, they have the same length,
and either they are the same map object or their corresponding keys
(matched using Go equality) map to deeply equal values.
Pointer values are deeply equal if they are equal using Go's == operator
or if they point to deeply equal values.
Slice values are deeply equal when all of the following are true:
they are both nil or both non-nil, they have the same length,
and either they point to the same initial entry of the same underlying array
(that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal.
Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))
are not deeply equal.
Other values - numbers, bools, strings, and channels - are deeply equal
if they are equal using Go's == operator.
In general DeepEqual is a recursive relaxation of Go's == operator.
However, this idea is impossible to implement without some inconsistency.
Specifically, it is possible for a value to be unequal to itself,
either because it is of func type (uncomparable in general)
or because it is a floating-point NaN value (not equal to itself in floating-point comparison),
or because it is an array, struct, or interface containing
such a value.
On the other hand, pointer values are always equal to themselves,
even if they point at or contain such problematic values,
because they compare equal using Go's == operator, and that
is a sufficient condition to be deeply equal, regardless of content.
DeepEqual has been defined so that the same short-cut applies
to slices and maps: if x and y are the same slice or the same map,
they are deeply equal regardless of content.
As DeepEqual traverses the data values it may find a cycle. The
second and subsequent times that DeepEqual compares two pointer
values that have been compared before, it treats the values as
equal rather than examining the values to which they point.
This ensures that DeepEqual terminates.</p>
               
               <pre><code>func DeepEqual(x any, y any) bool</code></pre>
            </article>
            
            <article class="function" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Elem() Type</code></pre>
            </article>
            
            <article class="function" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Elem returns the value that the interface v contains
or that the pointer v points to.
It panics if v's Kind is not [Interface] or [Pointer].
It returns the zero Value if v is nil.</p>
               
               <pre><code>func (v Value) Elem() Value</code></pre>
            </article>
            
            <article class="function" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Equal reports true if v is equal to u.
For two invalid values, Equal will report true.
For an interface value, Equal will compare the value within the interface.
Otherwise, If the values have different types, Equal will report false.
Otherwise, for arrays and structs Equal will compare each element in order,
and report false if it finds non-equal elements.
During all comparisons, if values of the same type are compared,
and the type is not comparable, Equal will panic.</p>
               
               <pre><code>func (v Value) Equal(u Value) bool</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *ValueError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Field">
               <h3>
                  Field 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Field returns the i'th struct field.</p>
               
               <pre><code>func (t *structType) Field(i int) (f StructField)</code></pre>
            </article>
            
            <article class="function" data-name="Field">
               <h3>
                  Field 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Field returns the i'th field of the struct v.
It panics if v's Kind is not [Struct] or i is out of range.</p>
               
               <pre><code>func (v Value) Field(i int) Value</code></pre>
            </article>
            
            <article class="function" data-name="Field">
               <h3>
                  Field 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Field(i int) StructField</code></pre>
            </article>
            
            <article class="function" data-name="FieldAlign">
               <h3>
                  FieldAlign 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) FieldAlign() int</code></pre>
            </article>
            
            <article class="function" data-name="FieldByIndex">
               <h3>
                  FieldByIndex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) FieldByIndex(index []int) StructField</code></pre>
            </article>
            
            <article class="function" data-name="FieldByIndex">
               <h3>
                  FieldByIndex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FieldByIndex returns the nested field corresponding to index.
It panics if evaluation requires stepping through a nil
pointer or a field that is not a struct.</p>
               
               <pre><code>func (v Value) FieldByIndex(index []int) Value</code></pre>
            </article>
            
            <article class="function" data-name="FieldByIndex">
               <h3>
                  FieldByIndex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FieldByIndex returns the nested field corresponding to index.</p>
               
               <pre><code>func (t *structType) FieldByIndex(index []int) (f StructField)</code></pre>
            </article>
            
            <article class="function" data-name="FieldByIndexErr">
               <h3>
                  FieldByIndexErr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FieldByIndexErr returns the nested field corresponding to index.
It returns an error if evaluation requires stepping through a nil
pointer, but panics if it must step through a field that
is not a struct.</p>
               
               <pre><code>func (v Value) FieldByIndexErr(index []int) (Value, error)</code></pre>
            </article>
            
            <article class="function" data-name="FieldByName">
               <h3>
                  FieldByName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FieldByName returns the struct field with the given name
and a boolean to indicate if the field was found.</p>
               
               <pre><code>func (t *structType) FieldByName(name string) (f StructField, present bool)</code></pre>
            </article>
            
            <article class="function" data-name="FieldByName">
               <h3>
                  FieldByName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FieldByName returns the struct field with the given name.
It returns the zero Value if no field was found.
It panics if v's Kind is not [Struct].</p>
               
               <pre><code>func (v Value) FieldByName(name string) Value</code></pre>
            </article>
            
            <article class="function" data-name="FieldByName">
               <h3>
                  FieldByName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) FieldByName(name string) (StructField, bool)</code></pre>
            </article>
            
            <article class="function" data-name="FieldByNameFunc">
               <h3>
                  FieldByNameFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FieldByNameFunc returns the struct field with a name that satisfies the
match function and a boolean to indicate if the field was found.</p>
               
               <pre><code>func (t *structType) FieldByNameFunc(match func(string) bool) (result StructField, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="FieldByNameFunc">
               <h3>
                  FieldByNameFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FieldByNameFunc returns the struct field with a name
that satisfies the match function.
It panics if v's Kind is not [Struct].
It returns the zero Value if no field was found.</p>
               
               <pre><code>func (v Value) FieldByNameFunc(match func(string) bool) Value</code></pre>
            </article>
            
            <article class="function" data-name="FieldByNameFunc">
               <h3>
                  FieldByNameFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) FieldByNameFunc(match func(string) bool) (StructField, bool)</code></pre>
            </article>
            
            <article class="function" data-name="Float">
               <h3>
                  Float 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Float returns v's underlying value, as a float64.
It panics if v's Kind is not [Float32] or [Float64]</p>
               
               <pre><code>func (v Value) Float() float64</code></pre>
            </article>
            
            <article class="function" data-name="FuncOf">
               <h3>
                  FuncOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FuncOf returns the function type with the given argument and result types.
For example if k represents int and e represents string,
FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.
The variadic argument controls whether the function is variadic. FuncOf
panics if the in[len(in)-1] does not represent a slice and variadic is
true.</p>
               
               <pre><code>func FuncOf(in []Type, out []Type, variadic bool) Type</code></pre>
            </article>
            
            <article class="function" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Get returns the value associated with key in the tag string.
If there is no such key in the tag, Get returns the empty string.
If the tag does not have the conventional format, the value
returned by Get is unspecified. To determine whether a tag is
explicitly set to the empty string, use [StructTag.Lookup].</p>
               
               <pre><code>func (tag StructTag) Get(key string) string</code></pre>
            </article>
            
            <article class="function" data-name="Grow">
               <h3>
                  Grow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Grow increases the slice's capacity, if necessary, to guarantee space for
another n elements. After Grow(n), at least n elements can be appended
to the slice without another allocation.
It panics if v's Kind is not a [Slice], or if n is negative or too large to
allocate the memory, or if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) Grow(n int)</code></pre>
            </article>
            
            <article class="function" data-name="Implements">
               <h3>
                  Implements 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Implements(u Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="In">
               <h3>
                  In 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) In(i int) Type</code></pre>
            </article>
            
            <article class="function" data-name="Index">
               <h3>
                  Index 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Index returns v's i'th element.
It panics if v's Kind is not [Array], [Slice], or [String] or i is out of range.</p>
               
               <pre><code>func (v Value) Index(i int) Value</code></pre>
            </article>
            
            <article class="function" data-name="Indirect">
               <h3>
                  Indirect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Indirect returns the value that v points to.
If v is a nil pointer, Indirect returns a zero Value.
If v is not a pointer, Indirect returns v.</p>
               
               <pre><code>func Indirect(v Value) Value</code></pre>
            </article>
            
            <article class="function" data-name="Int">
               <h3>
                  Int 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Int returns v's underlying value, as an int64.
It panics if v's Kind is not [Int], [Int8], [Int16], [Int32], or [Int64].</p>
               
               <pre><code>func (v Value) Int() int64</code></pre>
            </article>
            
            <article class="function" data-name="Interface">
               <h3>
                  Interface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Interface returns v's current value as an interface{}.
It is equivalent to:
var i interface{} = (v's underlying value)
It panics if the Value was obtained by accessing
unexported struct fields.</p>
               
               <pre><code>func (v Value) Interface() (i any)</code></pre>
            </article>
            
            <article class="function" data-name="InterfaceData">
               <h3>
                  InterfaceData 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>InterfaceData returns a pair of unspecified uintptr values.
It panics if v's Kind is not Interface.
In earlier versions of Go, this function returned the interface's
value as a uintptr pair. As of Go 1.4, the implementation of
interface values precludes any defined use of InterfaceData.
Deprecated: The memory representation of interface values is not
compatible with InterfaceData.</p>
               
               <pre><code>func (v Value) InterfaceData() [2]uintptr</code></pre>
            </article>
            
            <article class="function" data-name="IsExported">
               <h3>
                  IsExported 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsExported reports whether the method is exported.</p>
               
               <pre><code>func (m Method) IsExported() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsExported">
               <h3>
                  IsExported 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsExported reports whether the field is exported.</p>
               
               <pre><code>func (f StructField) IsExported() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsNil">
               <h3>
                  IsNil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsNil reports whether its argument v is nil. The argument must be
a chan, func, interface, map, pointer, or slice value; if it is
not, IsNil panics. Note that IsNil is not always equivalent to a
regular comparison with nil in Go. For example, if v was created
by calling [ValueOf] with an uninitialized interface variable i,
i==nil will be true but v.IsNil will panic as v will be the zero
Value.</p>
               
               <pre><code>func (v Value) IsNil() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsValid">
               <h3>
                  IsValid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsValid reports whether v represents a value.
It returns false if v is the zero Value.
If [Value.IsValid] returns false, all other methods except String panic.
Most functions and methods never return an invalid Value.
If one does, its documentation states the conditions explicitly.</p>
               
               <pre><code>func (v Value) IsValid() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsVariadic">
               <h3>
                  IsVariadic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) IsVariadic() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsZero">
               <h3>
                  IsZero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsZero reports whether v is the zero value for its type.
It panics if the argument is invalid.</p>
               
               <pre><code>func (v Value) IsZero() bool</code></pre>
            </article>
            
            <article class="function" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Key() Type</code></pre>
            </article>
            
            <article class="function" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Key returns the key of iter's current map entry.</p>
               
               <pre><code>func (iter *MapIter) Key() Value</code></pre>
            </article>
            
            <article class="function" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Key returns the key of iter's current map entry.</p>
               
               <pre><code>func (iter *MapIter) Key() Value</code></pre>
            </article>
            
            <article class="function" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Key() Type</code></pre>
            </article>
            
            <article class="function" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Kind returns v's Kind.
If v is the zero Value ([Value.IsValid] returns false), Kind returns Invalid.</p>
               
               <pre><code>func (v Value) Kind() Kind</code></pre>
            </article>
            
            <article class="function" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Kind() Kind</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Len returns v's length.
It panics if v's Kind is not [Array], [Chan], [Map], [Slice], [String], or pointer to [Array].</p>
               
               <pre><code>func (v Value) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Lookup returns the value associated with key in the tag string.
If the key is present in the tag the value (which may be empty)
is returned. Otherwise the returned value will be the empty string.
The ok return value reports whether the value was explicitly set in
the tag string. If the tag does not have the conventional format,
the value returned by Lookup is unspecified.</p>
               
               <pre><code>func (tag StructTag) Lookup(key string) (value string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="MakeChan">
               <h3>
                  MakeChan 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MakeChan creates a new channel with the specified type and buffer size.</p>
               
               <pre><code>func MakeChan(typ Type, buffer int) Value</code></pre>
            </article>
            
            <article class="function" data-name="MakeFunc">
               <h3>
                  MakeFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MakeFunc returns a new function of the given [Type]
that wraps the function fn. When called, that new function
does the following:
- converts its arguments to a slice of Values.
- runs results := fn(args).
- returns the results as a slice of Values, one per formal result.
The implementation fn can assume that the argument [Value] slice
has the number and type of arguments given by typ.
If typ describes a variadic function, the final Value is itself
a slice representing the variadic arguments, as in the
body of a variadic function. The result Value slice returned by fn
must have the number and type of results given by typ.
The [Value.Call] method allows the caller to invoke a typed function
in terms of Values; in contrast, MakeFunc allows the caller to implement
a typed function in terms of Values.
The Examples section of the documentation includes an illustration
of how to use MakeFunc to build a swap function for different types.</p>
               
               <pre><code>func MakeFunc(typ Type, fn func(args []Value) results []Value) Value</code></pre>
            </article>
            
            <article class="function" data-name="MakeMap">
               <h3>
                  MakeMap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MakeMap creates a new map with the specified type.</p>
               
               <pre><code>func MakeMap(typ Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="MakeMapWithSize">
               <h3>
                  MakeMapWithSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MakeMapWithSize creates a new map with the specified type
and initial space for approximately n elements.</p>
               
               <pre><code>func MakeMapWithSize(typ Type, n int) Value</code></pre>
            </article>
            
            <article class="function" data-name="MakeSlice">
               <h3>
                  MakeSlice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MakeSlice creates a new zero-initialized slice value
for the specified slice type, length, and capacity.</p>
               
               <pre><code>func MakeSlice(typ Type, len int, cap int) Value</code></pre>
            </article>
            
            <article class="function" data-name="MapIndex">
               <h3>
                  MapIndex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MapIndex returns the value associated with key in the map v.
It panics if v's Kind is not [Map].
It returns the zero Value if key is not found in the map or if v represents a nil map.
As in Go, the key's value must be assignable to the map's key type.</p>
               
               <pre><code>func (v Value) MapIndex(key Value) Value</code></pre>
            </article>
            
            <article class="function" data-name="MapIndex">
               <h3>
                  MapIndex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MapIndex returns the value associated with key in the map v.
It panics if v's Kind is not [Map].
It returns the zero Value if key is not found in the map or if v represents a nil map.
As in Go, the key's value must be assignable to the map's key type.</p>
               
               <pre><code>func (v Value) MapIndex(key Value) Value</code></pre>
            </article>
            
            <article class="function" data-name="MapKeys">
               <h3>
                  MapKeys 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MapKeys returns a slice containing all the keys present in the map,
in unspecified order.
It panics if v's Kind is not [Map].
It returns an empty slice if v represents a nil map.</p>
               
               <pre><code>func (v Value) MapKeys() []Value</code></pre>
            </article>
            
            <article class="function" data-name="MapKeys">
               <h3>
                  MapKeys 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MapKeys returns a slice containing all the keys present in the map,
in unspecified order.
It panics if v's Kind is not [Map].
It returns an empty slice if v represents a nil map.</p>
               
               <pre><code>func (v Value) MapKeys() []Value</code></pre>
            </article>
            
            <article class="function" data-name="MapOf">
               <h3>
                  MapOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MapOf returns the map type with the given key and element types.
For example, if k represents int and e represents string,
MapOf(k, e) represents map[int]string.
If the key type is not a valid map key type (that is, if it does
not implement Go's == operator), MapOf panics.</p>
               
               <pre><code>func MapOf(key Type, elem Type) Type</code></pre>
            </article>
            
            <article class="function" data-name="MapOf">
               <h3>
                  MapOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MapOf returns the map type with the given key and element types.
For example, if k represents int and e represents string,
MapOf(k, e) represents map[int]string.
If the key type is not a valid map key type (that is, if it does
not implement Go's == operator), MapOf panics.</p>
               
               <pre><code>func MapOf(key Type, elem Type) Type</code></pre>
            </article>
            
            <article class="function" data-name="MapRange">
               <h3>
                  MapRange 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MapRange returns a range iterator for a map.
It panics if v's Kind is not [Map].
Call [MapIter.Next] to advance the iterator, and [MapIter.Key]/[MapIter.Value] to access each entry.
[MapIter.Next] returns false when the iterator is exhausted.
MapRange follows the same iteration semantics as a range statement.
Example:
iter := reflect.ValueOf(m).MapRange()
for iter.Next() {
k := iter.Key()
v := iter.Value()
...
}</p>
               
               <pre><code>func (v Value) MapRange() *MapIter</code></pre>
            </article>
            
            <article class="function" data-name="MapRange">
               <h3>
                  MapRange 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MapRange returns a range iterator for a map.
It panics if v's Kind is not [Map].
Call [MapIter.Next] to advance the iterator, and [MapIter.Key]/[MapIter.Value] to access each entry.
[MapIter.Next] returns false when the iterator is exhausted.
MapRange follows the same iteration semantics as a range statement.
Example:
iter := reflect.ValueOf(m).MapRange()
for iter.Next() {
k := iter.Key()
v := iter.Value()
...
}</p>
               
               <pre><code>func (v Value) MapRange() *MapIter</code></pre>
            </article>
            
            <article class="function" data-name="Method">
               <h3>
                  Method 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Method returns a function value corresponding to v's i'th method.
The arguments to a Call on the returned function should not include
a receiver; the returned function will always use v as the receiver.
Method panics if i is out of range or if v is a nil interface value.</p>
               
               <pre><code>func (v Value) Method(i int) Value</code></pre>
            </article>
            
            <article class="function" data-name="Method">
               <h3>
                  Method 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Method returns the i'th method in the type's method set.</p>
               
               <pre><code>func (t *interfaceType) Method(i int) (m Method)</code></pre>
            </article>
            
            <article class="function" data-name="Method">
               <h3>
                  Method 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Method(i int) (m Method)</code></pre>
            </article>
            
            <article class="function" data-name="MethodByName">
               <h3>
                  MethodByName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MethodByName method with the given name in the type's method set.</p>
               
               <pre><code>func (t *interfaceType) MethodByName(name string) (m Method, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="MethodByName">
               <h3>
                  MethodByName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MethodByName returns a function value corresponding to the method
of v with the given name.
The arguments to a Call on the returned function should not include
a receiver; the returned function will always use v as the receiver.
It returns the zero Value if no method was found.</p>
               
               <pre><code>func (v Value) MethodByName(name string) Value</code></pre>
            </article>
            
            <article class="function" data-name="MethodByName">
               <h3>
                  MethodByName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) MethodByName(name string) (m Method, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Name() string</code></pre>
            </article>
            
            <article class="function" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>New returns a Value representing a pointer to a new zero value
for the specified type. That is, the returned Value's Type is [PointerTo](typ).</p>
               
               <pre><code>func New(typ Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="NewAt">
               <h3>
                  NewAt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewAt returns a Value representing a pointer to a value of the
specified type, using p as that pointer.</p>
               
               <pre><code>func NewAt(typ Type, p unsafe.Pointer) Value</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Next advances the map iterator and reports whether there is another
entry. It returns false when iter is exhausted; subsequent
calls to [MapIter.Key], [MapIter.Value], or [MapIter.Next] will panic.</p>
               
               <pre><code>func (iter *MapIter) Next() bool</code></pre>
            </article>
            
            <article class="function" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Next advances the map iterator and reports whether there is another
entry. It returns false when iter is exhausted; subsequent
calls to [MapIter.Key], [MapIter.Value], or [MapIter.Next] will panic.</p>
               
               <pre><code>func (iter *MapIter) Next() bool</code></pre>
            </article>
            
            <article class="function" data-name="NumField">
               <h3>
                  NumField 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) NumField() int</code></pre>
            </article>
            
            <article class="function" data-name="NumField">
               <h3>
                  NumField 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NumField returns the number of fields in the struct v.
It panics if v's Kind is not [Struct].</p>
               
               <pre><code>func (v Value) NumField() int</code></pre>
            </article>
            
            <article class="function" data-name="NumIn">
               <h3>
                  NumIn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) NumIn() int</code></pre>
            </article>
            
            <article class="function" data-name="NumMethod">
               <h3>
                  NumMethod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NumMethod returns the number of methods in the value's method set.
For a non-interface type, it returns the number of exported methods.
For an interface type, it returns the number of exported and unexported methods.</p>
               
               <pre><code>func (v Value) NumMethod() int</code></pre>
            </article>
            
            <article class="function" data-name="NumMethod">
               <h3>
                  NumMethod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NumMethod returns the number of interface methods in the type's method set.</p>
               
               <pre><code>func (t *interfaceType) NumMethod() int</code></pre>
            </article>
            
            <article class="function" data-name="NumMethod">
               <h3>
                  NumMethod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) NumMethod() int</code></pre>
            </article>
            
            <article class="function" data-name="NumOut">
               <h3>
                  NumOut 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) NumOut() int</code></pre>
            </article>
            
            <article class="function" data-name="Out">
               <h3>
                  Out 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Out(i int) Type</code></pre>
            </article>
            
            <article class="function" data-name="OverflowComplex">
               <h3>
                  OverflowComplex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) OverflowComplex(x complex128) bool</code></pre>
            </article>
            
            <article class="function" data-name="OverflowComplex">
               <h3>
                  OverflowComplex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>OverflowComplex reports whether the complex128 x cannot be represented by v's type.
It panics if v's Kind is not [Complex64] or [Complex128].</p>
               
               <pre><code>func (v Value) OverflowComplex(x complex128) bool</code></pre>
            </article>
            
            <article class="function" data-name="OverflowFloat">
               <h3>
                  OverflowFloat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>OverflowFloat reports whether the float64 x cannot be represented by v's type.
It panics if v's Kind is not [Float32] or [Float64].</p>
               
               <pre><code>func (v Value) OverflowFloat(x float64) bool</code></pre>
            </article>
            
            <article class="function" data-name="OverflowFloat">
               <h3>
                  OverflowFloat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) OverflowFloat(x float64) bool</code></pre>
            </article>
            
            <article class="function" data-name="OverflowInt">
               <h3>
                  OverflowInt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) OverflowInt(x int64) bool</code></pre>
            </article>
            
            <article class="function" data-name="OverflowInt">
               <h3>
                  OverflowInt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>OverflowInt reports whether the int64 x cannot be represented by v's type.
It panics if v's Kind is not [Int], [Int8], [Int16], [Int32], or [Int64].</p>
               
               <pre><code>func (v Value) OverflowInt(x int64) bool</code></pre>
            </article>
            
            <article class="function" data-name="OverflowUint">
               <h3>
                  OverflowUint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) OverflowUint(x uint64) bool</code></pre>
            </article>
            
            <article class="function" data-name="OverflowUint">
               <h3>
                  OverflowUint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>OverflowUint reports whether the uint64 x cannot be represented by v's type.
It panics if v's Kind is not [Uint], [Uintptr], [Uint8], [Uint16], [Uint32], or [Uint64].</p>
               
               <pre><code>func (v Value) OverflowUint(x uint64) bool</code></pre>
            </article>
            
            <article class="function" data-name="PkgPath">
               <h3>
                  PkgPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) PkgPath() string</code></pre>
            </article>
            
            <article class="function" data-name="Pointer">
               <h3>
                  Pointer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pointer returns v's value as a uintptr.
It panics if v's Kind is not [Chan], [Func], [Map], [Pointer], [Slice], [String], or [UnsafePointer].
If v's Kind is [Func], the returned pointer is an underlying
code pointer, but not necessarily enough to identify a
single function uniquely. The only guarantee is that the
result is zero if and only if v is a nil func Value.
If v's Kind is [Slice], the returned pointer is to the first
element of the slice. If the slice is nil the returned value
is 0.  If the slice is empty but non-nil the return value is non-zero.
If v's Kind is [String], the returned pointer is to the first
element of the underlying bytes of string.
It's preferred to use uintptr(Value.UnsafePointer()) to get the equivalent result.</p>
               
               <pre><code>func (v Value) Pointer() uintptr</code></pre>
            </article>
            
            <article class="function" data-name="PointerTo">
               <h3>
                  PointerTo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PointerTo returns the pointer type with element t.
For example, if t represents type Foo, PointerTo(t) represents *Foo.</p>
               
               <pre><code>func PointerTo(t Type) Type</code></pre>
            </article>
            
            <article class="function" data-name="PtrTo">
               <h3>
                  PtrTo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PtrTo returns the pointer type with element t.
For example, if t represents type Foo, PtrTo(t) represents *Foo.
PtrTo is the old spelling of [PointerTo].
The two functions behave identically.
Deprecated: Superseded by [PointerTo].</p>
               
               <pre><code>func PtrTo(t Type) Type</code></pre>
            </article>
            
            <article class="function" data-name="Recv">
               <h3>
                  Recv 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Recv receives and returns a value from the channel v.
It panics if v's Kind is not [Chan].
The receive blocks until a value is ready.
The boolean value ok is true if the value x corresponds to a send
on the channel, false if it is a zero value received because the channel is closed.</p>
               
               <pre><code>func (v Value) Recv() (x Value, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset modifies iter to iterate over v.
It panics if v's Kind is not [Map] and v is not the zero Value.
Reset(Value{}) causes iter to not to refer to any map,
which may allow the previously iterated-over map to be garbage collected.</p>
               
               <pre><code>func (iter *MapIter) Reset(v Value)</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset modifies iter to iterate over v.
It panics if v's Kind is not [Map] and v is not the zero Value.
Reset(Value{}) causes iter to not to refer to any map,
which may allow the previously iterated-over map to be garbage collected.</p>
               
               <pre><code>func (iter *MapIter) Reset(v Value)</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Select executes a select operation described by the list of cases.
Like the Go select statement, it blocks until at least one of the cases
can proceed, makes a uniform pseudo-random choice,
and then executes that case. It returns the index of the chosen case
and, if that case was a receive operation, the value received and a
boolean indicating whether the value corresponds to a send on the channel
(as opposed to a zero value received because the channel is closed).
Select supports a maximum of 65536 cases.</p>
               
               <pre><code>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</code></pre>
            </article>
            
            <article class="function" data-name="Send">
               <h3>
                  Send 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Send sends x on the channel v.
It panics if v's kind is not [Chan] or if x's type is not the same type as v's element type.
As in Go, x's value must be assignable to the channel's element type.</p>
               
               <pre><code>func (v Value) Send(x Value)</code></pre>
            </article>
            
            <article class="function" data-name="Seq">
               <h3>
                  Seq 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Seq returns an iter.Seq[Value] that loops over the elements of v.
If v's kind is Func, it must be a function that has no results and
that takes a single argument of type func(T) bool for some type T.
If v's kind is Pointer, the pointer element type must have kind Array.
Otherwise v's kind must be Int, Int8, Int16, Int32, Int64,
Uint, Uint8, Uint16, Uint32, Uint64, Uintptr,
Array, Chan, Map, Slice, or String.</p>
               
               <pre><code>func (v Value) Seq() *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function" data-name="Seq2">
               <h3>
                  Seq2 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Seq2 returns an iter.Seq2[Value, Value] that loops over the elements of v.
If v's kind is Func, it must be a function that has no results and
that takes a single argument of type func(K, V) bool for some type K, V.
If v's kind is Pointer, the pointer element type must have kind Array.
Otherwise v's kind must be Array, Map, Slice, or String.</p>
               
               <pre><code>func (v Value) Seq2() *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set assigns x to the value v.
It panics if [Value.CanSet] returns false.
As in Go, x's value must be assignable to v's type and
must not be derived from an unexported field.</p>
               
               <pre><code>func (v Value) Set(x Value)</code></pre>
            </article>
            
            <article class="function" data-name="SetBool">
               <h3>
                  SetBool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBool sets v's underlying value.
It panics if v's Kind is not [Bool] or if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetBool(x bool)</code></pre>
            </article>
            
            <article class="function" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBytes sets v's underlying value.
It panics if v's underlying value is not a slice of bytes
or if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetBytes(x []byte)</code></pre>
            </article>
            
            <article class="function" data-name="SetCap">
               <h3>
                  SetCap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetCap sets v's capacity to n.
It panics if v's Kind is not [Slice], or if n is smaller than the length or
greater than the capacity of the slice,
or if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetCap(n int)</code></pre>
            </article>
            
            <article class="function" data-name="SetComplex">
               <h3>
                  SetComplex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetComplex sets v's underlying value to x.
It panics if v's Kind is not [Complex64] or [Complex128],
or if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetComplex(x complex128)</code></pre>
            </article>
            
            <article class="function" data-name="SetFloat">
               <h3>
                  SetFloat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetFloat sets v's underlying value to x.
It panics if v's Kind is not [Float32] or [Float64],
or if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetFloat(x float64)</code></pre>
            </article>
            
            <article class="function" data-name="SetInt">
               <h3>
                  SetInt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetInt sets v's underlying value to x.
It panics if v's Kind is not [Int], [Int8], [Int16], [Int32], or [Int64],
or if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetInt(x int64)</code></pre>
            </article>
            
            <article class="function" data-name="SetIterKey">
               <h3>
                  SetIterKey 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetIterKey assigns to v the key of iter's current map entry.
It is equivalent to v.Set(iter.Key()), but it avoids allocating a new Value.
As in Go, the key must be assignable to v's type and
must not be derived from an unexported field.
It panics if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetIterKey(iter *MapIter)</code></pre>
            </article>
            
            <article class="function" data-name="SetIterKey">
               <h3>
                  SetIterKey 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetIterKey assigns to v the key of iter's current map entry.
It is equivalent to v.Set(iter.Key()), but it avoids allocating a new Value.
As in Go, the key must be assignable to v's type and
must not be derived from an unexported field.
It panics if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetIterKey(iter *MapIter)</code></pre>
            </article>
            
            <article class="function" data-name="SetIterValue">
               <h3>
                  SetIterValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetIterValue assigns to v the value of iter's current map entry.
It is equivalent to v.Set(iter.Value()), but it avoids allocating a new Value.
As in Go, the value must be assignable to v's type and
must not be derived from an unexported field.
It panics if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetIterValue(iter *MapIter)</code></pre>
            </article>
            
            <article class="function" data-name="SetIterValue">
               <h3>
                  SetIterValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetIterValue assigns to v the value of iter's current map entry.
It is equivalent to v.Set(iter.Value()), but it avoids allocating a new Value.
As in Go, the value must be assignable to v's type and
must not be derived from an unexported field.
It panics if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetIterValue(iter *MapIter)</code></pre>
            </article>
            
            <article class="function" data-name="SetLen">
               <h3>
                  SetLen 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetLen sets v's length to n.
It panics if v's Kind is not [Slice], or if n is negative or
greater than the capacity of the slice,
or if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetLen(n int)</code></pre>
            </article>
            
            <article class="function" data-name="SetMapIndex">
               <h3>
                  SetMapIndex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetMapIndex sets the element associated with key in the map v to elem.
It panics if v's Kind is not [Map].
If elem is the zero Value, SetMapIndex deletes the key from the map.
Otherwise if v holds a nil map, SetMapIndex will panic.
As in Go, key's elem must be assignable to the map's key type,
and elem's value must be assignable to the map's elem type.</p>
               
               <pre><code>func (v Value) SetMapIndex(key Value, elem Value)</code></pre>
            </article>
            
            <article class="function" data-name="SetMapIndex">
               <h3>
                  SetMapIndex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetMapIndex sets the element associated with key in the map v to elem.
It panics if v's Kind is not [Map].
If elem is the zero Value, SetMapIndex deletes the key from the map.
Otherwise if v holds a nil map, SetMapIndex will panic.
As in Go, key's elem must be assignable to the map's key type,
and elem's value must be assignable to the map's elem type.</p>
               
               <pre><code>func (v Value) SetMapIndex(key Value, elem Value)</code></pre>
            </article>
            
            <article class="function" data-name="SetPointer">
               <h3>
                  SetPointer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetPointer sets the [unsafe.Pointer] value v to x.
It panics if v's Kind is not [UnsafePointer]
or if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetPointer(x unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="SetString">
               <h3>
                  SetString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetString sets v's underlying value to x.
It panics if v's Kind is not [String] or if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetString(x string)</code></pre>
            </article>
            
            <article class="function" data-name="SetUint">
               <h3>
                  SetUint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetUint sets v's underlying value to x.
It panics if v's Kind is not [Uint], [Uintptr], [Uint8], [Uint16], [Uint32], or [Uint64],
or if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetUint(x uint64)</code></pre>
            </article>
            
            <article class="function" data-name="SetZero">
               <h3>
                  SetZero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetZero sets v to be the zero value of v's type.
It panics if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) SetZero()</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) Size() uintptr</code></pre>
            </article>
            
            <article class="function" data-name="Slice">
               <h3>
                  Slice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Slice returns v[i:j].
It panics if v's Kind is not [Array], [Slice] or [String], or if v is an unaddressable array,
or if the indexes are out of bounds.</p>
               
               <pre><code>func (v Value) Slice(i int, j int) Value</code></pre>
            </article>
            
            <article class="function" data-name="Slice3">
               <h3>
                  Slice3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Slice3 is the 3-index form of the slice operation: it returns v[i:j:k].
It panics if v's Kind is not [Array] or [Slice], or if v is an unaddressable array,
or if the indexes are out of bounds.</p>
               
               <pre><code>func (v Value) Slice3(i int, j int, k int) Value</code></pre>
            </article>
            
            <article class="function" data-name="SliceAt">
               <h3>
                  SliceAt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SliceAt returns a [Value] representing a slice whose underlying
data starts at p, with length and capacity equal to n.
This is like [unsafe.Slice].</p>
               
               <pre><code>func SliceAt(typ Type, p unsafe.Pointer, n int) Value</code></pre>
            </article>
            
            <article class="function" data-name="SliceOf">
               <h3>
                  SliceOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SliceOf returns the slice type with element type t.
For example, if t represents int, SliceOf(t) represents []int.</p>
               
               <pre><code>func SliceOf(t Type) Type</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d ChanDir) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the name of k.</p>
               
               <pre><code>func (k Kind) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the string v's underlying value, as a string.
String is a special case because of Go's String method convention.
Unlike the other getters, it does not panic if v's Kind is not [String].
Instead, it returns a string of the form "<T value>" where T is v's type.
The fmt package treats Values specially. It does not call their String
method implicitly but instead prints the concrete values they hold.</p>
               
               <pre><code>func (v Value) String() string</code></pre>
            </article>
            
            <article class="function" data-name="StructOf">
               <h3>
                  StructOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>StructOf returns the struct type containing fields.
The Offset and Index fields are ignored and computed as they would be
by the compiler.
StructOf currently does not support promoted methods of embedded fields
and panics if passed unexported StructFields.</p>
               
               <pre><code>func StructOf(fields []StructField) Type</code></pre>
            </article>
            
            <article class="function" data-name="Swapper">
               <h3>
                  Swapper 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Swapper returns a function that swaps the elements in the provided
slice.
Swapper panics if the provided interface is not a slice.</p>
               
               <pre><code>func Swapper(slice any) (func(i int, j int))</code></pre>
            </article>
            
            <article class="function" data-name="TryRecv">
               <h3>
                  TryRecv 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TryRecv attempts to receive a value from the channel v but will not block.
It panics if v's Kind is not [Chan].
If the receive delivers a value, x is the transferred value and ok is true.
If the receive cannot finish without blocking, x is the zero Value and ok is false.
If the channel is closed, x is the zero value for the channel's element type and ok is false.</p>
               
               <pre><code>func (v Value) TryRecv() (x Value, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="TrySend">
               <h3>
                  TrySend 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TrySend attempts to send x on the channel v but will not block.
It panics if v's Kind is not [Chan].
It reports whether the value was sent.
As in Go, x's value must be assignable to the channel's element type.</p>
               
               <pre><code>func (v Value) TrySend(x Value) bool</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Type returns v's type.</p>
               
               <pre><code>func (v Value) Type() Type</code></pre>
            </article>
            
            <article class="function" data-name="TypeFor">
               <h3>
                  TypeFor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TypeFor returns the [Type] that represents the type argument T.</p>
               
               <pre><code>func TypeFor() Type</code></pre>
            </article>
            
            <article class="function" data-name="TypeOf">
               <h3>
                  TypeOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TypeOf returns the reflection [Type] that represents the dynamic type of i.
If i is a nil interface value, TypeOf returns nil.</p>
               
               <pre><code>func TypeOf(i any) Type</code></pre>
            </article>
            
            <article class="function" data-name="Uint">
               <h3>
                  Uint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Uint returns v's underlying value, as a uint64.
It panics if v's Kind is not [Uint], [Uintptr], [Uint8], [Uint16], [Uint32], or [Uint64].</p>
               
               <pre><code>func (v Value) Uint() uint64</code></pre>
            </article>
            
            <article class="function" data-name="UnsafeAddr">
               <h3>
                  UnsafeAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnsafeAddr returns a pointer to v's data, as a uintptr.
It panics if v is not addressable.
It's preferred to use uintptr(Value.Addr().UnsafePointer()) to get the equivalent result.</p>
               
               <pre><code>func (v Value) UnsafeAddr() uintptr</code></pre>
            </article>
            
            <article class="function" data-name="UnsafePointer">
               <h3>
                  UnsafePointer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnsafePointer returns v's value as a [unsafe.Pointer].
It panics if v's Kind is not [Chan], [Func], [Map], [Pointer], [Slice], [String] or [UnsafePointer].
If v's Kind is [Func], the returned pointer is an underlying
code pointer, but not necessarily enough to identify a
single function uniquely. The only guarantee is that the
result is zero if and only if v is a nil func Value.
If v's Kind is [Slice], the returned pointer is to the first
element of the slice. If the slice is nil the returned value
is nil.  If the slice is empty but non-nil the return value is non-nil.
If v's Kind is [String], the returned pointer is to the first
element of the underlying bytes of string.</p>
               
               <pre><code>func (v Value) UnsafePointer() unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Value returns the value of iter's current map entry.</p>
               
               <pre><code>func (iter *MapIter) Value() Value</code></pre>
            </article>
            
            <article class="function" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Value returns the value of iter's current map entry.</p>
               
               <pre><code>func (iter *MapIter) Value() Value</code></pre>
            </article>
            
            <article class="function" data-name="ValueOf">
               <h3>
                  ValueOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ValueOf returns a new Value initialized to the concrete value
stored in the interface i. ValueOf(nil) returns the zero Value.</p>
               
               <pre><code>func ValueOf(i any) Value</code></pre>
            </article>
            
            <article class="function" data-name="VisibleFields">
               <h3>
                  VisibleFields 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>VisibleFields returns all the visible fields in t, which must be a
struct type. A field is defined as visible if it's accessible
directly with a FieldByName call. The returned fields include fields
inside anonymous struct members and unexported fields. They follow
the same order found in the struct, with anonymous fields followed
immediately by their promoted fields.
For each element e of the returned slice, the corresponding field
can be retrieved from a value v of type t by calling v.FieldByIndex(e.Index).</p>
               
               <pre><code>func VisibleFields(t Type) []StructField</code></pre>
            </article>
            
            <article class="function" data-name="Zero">
               <h3>
                  Zero 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Zero returns a Value representing the zero value for the specified type.
The result is different from the zero value of the Value struct,
which represents no value at all.
For example, Zero(TypeOf(42)) returns a Value with Kind [Int] and value 0.
The returned value is neither addressable nor settable.</p>
               
               <pre><code>func Zero(typ Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="abiType">
               <h3>
                  abiType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) abiType() *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="abiTypeSlow">
               <h3>
                  abiTypeSlow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) abiTypeSlow() *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>add returns p+x.
The whySafe string is ignored, so that the function still inlines
as efficiently as p+x, but all call sites should use the string to
record why the addition is safe, which is to say why the addition
does not cause x to advance to the very end of p's allocation
and therefore point incorrectly at the next block in memory.
add should be an internal detail (and is trivially copyable),
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/pinpoint-apm/pinpoint-go-agent
- github.com/vmware/govmomi
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname add</p>
               
               <pre><code>func add(p unsafe.Pointer, x uintptr, whySafe string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="addArg">
               <h3>
                  addArg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addArg extends the abiSeq with a new Go value of type t.
If the value was stack-assigned, returns the single
abiStep describing that translation, and nil otherwise.</p>
               
               <pre><code>func (a *abiSeq) addArg(t *abi.Type) *abiStep</code></pre>
            </article>
            
            <article class="function" data-name="addRcvr">
               <h3>
                  addRcvr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addRcvr extends the abiSeq with a new method call
receiver according to the interface calling convention.
If the receiver was stack-assigned, returns the single
abiStep describing that translation, and nil otherwise.
Returns true if the receiver is a pointer.</p>
               
               <pre><code>func (a *abiSeq) addRcvr(rcvr *abi.Type) (*abiStep, bool)</code></pre>
            </article>
            
            <article class="function" data-name="addReflectOff">
               <h3>
                  addReflectOff 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addReflectOff adds a pointer to the reflection lookup map in the runtime.
It returns a new ID that can be used as a typeOff or textOff, and will
be resolved correctly. Implemented in the runtime package.
addReflectOff should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/goplus/reflectx
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname addReflectOff
go:noescape</p>
               
               <pre><code>func addReflectOff(ptr unsafe.Pointer) int32</code></pre>
            </article>
            
            <article class="function" data-name="addTypeBits">
               <h3>
                  addTypeBits 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addTypeBits(bv *bitVector, offset uintptr, t *abi.Type)</code></pre>
            </article>
            
            <article class="function" data-name="align">
               <h3>
                  align 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>align returns the result of rounding x up to a multiple of n.
n must be a power of two.</p>
               
               <pre><code>func align(x uintptr, n uintptr) uintptr</code></pre>
            </article>
            
            <article class="function" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>append a bit to the bitmap.</p>
               
               <pre><code>func (bv *bitVector) append(bit uint8)</code></pre>
            </article>
            
            <article class="function" data-name="appendVarint">
               <h3>
                  appendVarint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendVarint(x []byte, v uintptr) []byte</code></pre>
            </article>
            
            <article class="function" data-name="archFloat32FromReg">
               <h3>
                  archFloat32FromReg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func archFloat32FromReg(reg uint64) float32</code></pre>
            </article>
            
            <article class="function" data-name="archFloat32FromReg">
               <h3>
                  archFloat32FromReg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func archFloat32FromReg(reg uint64) float32</code></pre>
            </article>
            
            <article class="function" data-name="archFloat32FromReg">
               <h3>
                  archFloat32FromReg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func archFloat32FromReg(reg uint64) float32</code></pre>
            </article>
            
            <article class="function" data-name="archFloat32ToReg">
               <h3>
                  archFloat32ToReg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func archFloat32ToReg(val float32) uint64</code></pre>
            </article>
            
            <article class="function" data-name="archFloat32ToReg">
               <h3>
                  archFloat32ToReg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func archFloat32ToReg(val float32) uint64</code></pre>
            </article>
            
            <article class="function" data-name="archFloat32ToReg">
               <h3>
                  archFloat32ToReg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func archFloat32ToReg(val float32) uint64</code></pre>
            </article>
            
            <article class="function" data-name="arena_New">
               <h3>
                  arena_New 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func arena_New(a *arena.Arena, typ any) any</code></pre>
            </article>
            
            <article class="function" data-name="arrayAt">
               <h3>
                  arrayAt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>arrayAt returns the i-th element of p,
an array whose elements are eltSize bytes wide.
The array pointed at by p must have at least i+1 elements:
it is invalid (but impossible to check here) to pass i >= len,
because then the result will point outside the array.
whySafe must explain why i < len. (Passing "i < len" is fine;
the benefit is to surface this assumption at the call site.)</p>
               
               <pre><code>func arrayAt(p unsafe.Pointer, i int, eltSize uintptr, whySafe string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="assignFloatN">
               <h3>
                  assignFloatN 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>assignFloatN assigns n values to registers, each "size" bytes large,
from the data at [offset, offset+n*size) in memory. Each value at
[offset+i*size, offset+(i+1)*size) for i < n is assigned to the
next n floating-point registers.
Returns whether assignment succeeded.</p>
               
               <pre><code>func (a *abiSeq) assignFloatN(offset uintptr, size uintptr, n int) bool</code></pre>
            </article>
            
            <article class="function" data-name="assignIntN">
               <h3>
                  assignIntN 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>assignIntN assigns n values to registers, each "size" bytes large,
from the data at [offset, offset+n*size) in memory. Each value at
[offset+i*size, offset+(i+1)*size) for i < n is assigned to the
next n integer registers.
Bit i in ptrMap indicates whether the i'th value is a pointer.
n must be <= 8.
Returns whether assignment succeeded.</p>
               
               <pre><code>func (a *abiSeq) assignIntN(offset uintptr, size uintptr, n int, ptrMap uint8) bool</code></pre>
            </article>
            
            <article class="function" data-name="assignTo">
               <h3>
                  assignTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>assignTo returns a value v that can be assigned directly to dst.
It panics if v is not assignable to dst.
For a conversion to an interface type, target, if not nil,
is a suggested scratch space to use.
target must be initialized memory (or nil).</p>
               
               <pre><code>func (v Value) assignTo(context string, dst *abi.Type, target unsafe.Pointer) Value</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_Value_pointer">
               <h3>
                  badlinkname_Value_pointer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_Value_pointer reflect.(*Value).pointer</p>
               
               <pre><code>func badlinkname_Value_pointer(Value) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Align">
               <h3>
                  badlinkname_rtype_Align 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Align reflect.(*rtype).Align</p>
               
               <pre><code>func badlinkname_rtype_Align(*rtype) int</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_AssignableTo">
               <h3>
                  badlinkname_rtype_AssignableTo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_AssignableTo reflect.(*rtype).AssignableTo</p>
               
               <pre><code>func badlinkname_rtype_AssignableTo(*rtype, Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Bits">
               <h3>
                  badlinkname_rtype_Bits 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Bits reflect.(*rtype).Bits</p>
               
               <pre><code>func badlinkname_rtype_Bits(*rtype) int</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_ChanDir">
               <h3>
                  badlinkname_rtype_ChanDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_ChanDir reflect.(*rtype).ChanDir</p>
               
               <pre><code>func badlinkname_rtype_ChanDir(*rtype) ChanDir</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Comparable">
               <h3>
                  badlinkname_rtype_Comparable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Comparable reflect.(*rtype).Comparable</p>
               
               <pre><code>func badlinkname_rtype_Comparable(*rtype) bool</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_ConvertibleTo">
               <h3>
                  badlinkname_rtype_ConvertibleTo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_ConvertibleTo reflect.(*rtype).ConvertibleTo</p>
               
               <pre><code>func badlinkname_rtype_ConvertibleTo(*rtype, Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Elem">
               <h3>
                  badlinkname_rtype_Elem 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Elem reflect.(*rtype).Elem</p>
               
               <pre><code>func badlinkname_rtype_Elem(*rtype) Type</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Field">
               <h3>
                  badlinkname_rtype_Field 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Field reflect.(*rtype).Field</p>
               
               <pre><code>func badlinkname_rtype_Field(*rtype, int) StructField</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_FieldAlign">
               <h3>
                  badlinkname_rtype_FieldAlign 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_FieldAlign reflect.(*rtype).FieldAlign</p>
               
               <pre><code>func badlinkname_rtype_FieldAlign(*rtype) int</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_FieldByIndex">
               <h3>
                  badlinkname_rtype_FieldByIndex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_FieldByIndex reflect.(*rtype).FieldByIndex</p>
               
               <pre><code>func badlinkname_rtype_FieldByIndex(*rtype, []int) StructField</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_FieldByName">
               <h3>
                  badlinkname_rtype_FieldByName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_FieldByName reflect.(*rtype).FieldByName</p>
               
               <pre><code>func badlinkname_rtype_FieldByName(*rtype, string) (StructField, bool)</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_FieldByNameFunc">
               <h3>
                  badlinkname_rtype_FieldByNameFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_FieldByNameFunc reflect.(*rtype).FieldByNameFunc</p>
               
               <pre><code>func badlinkname_rtype_FieldByNameFunc(*rtype, func(string) bool) (StructField, bool)</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Implements">
               <h3>
                  badlinkname_rtype_Implements 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Implements reflect.(*rtype).Implements</p>
               
               <pre><code>func badlinkname_rtype_Implements(*rtype, Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_In">
               <h3>
                  badlinkname_rtype_In 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_In reflect.(*rtype).In</p>
               
               <pre><code>func badlinkname_rtype_In(*rtype, int) Type</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_IsVariadic">
               <h3>
                  badlinkname_rtype_IsVariadic 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_IsVariadic reflect.(*rtype).IsVariadic</p>
               
               <pre><code>func badlinkname_rtype_IsVariadic(*rtype) bool</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Key">
               <h3>
                  badlinkname_rtype_Key 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Key reflect.(*rtype).Key</p>
               
               <pre><code>func badlinkname_rtype_Key(*rtype) Type</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Kind">
               <h3>
                  badlinkname_rtype_Kind 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Kind reflect.(*rtype).Kind</p>
               
               <pre><code>func badlinkname_rtype_Kind(*rtype) Kind</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Len">
               <h3>
                  badlinkname_rtype_Len 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Len reflect.(*rtype).Len</p>
               
               <pre><code>func badlinkname_rtype_Len(*rtype) int</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Method">
               <h3>
                  badlinkname_rtype_Method 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Method reflect.(*rtype).Method</p>
               
               <pre><code>func badlinkname_rtype_Method(*rtype, int) Method</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_MethodByName">
               <h3>
                  badlinkname_rtype_MethodByName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_MethodByName reflect.(*rtype).MethodByName</p>
               
               <pre><code>func badlinkname_rtype_MethodByName(*rtype, string) (Method, bool)</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Name">
               <h3>
                  badlinkname_rtype_Name 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Name reflect.(*rtype).Name</p>
               
               <pre><code>func badlinkname_rtype_Name(*rtype) string</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_NumField">
               <h3>
                  badlinkname_rtype_NumField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_NumField reflect.(*rtype).NumField</p>
               
               <pre><code>func badlinkname_rtype_NumField(*rtype) int</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_NumIn">
               <h3>
                  badlinkname_rtype_NumIn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_NumIn reflect.(*rtype).NumIn</p>
               
               <pre><code>func badlinkname_rtype_NumIn(*rtype) int</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_NumMethod">
               <h3>
                  badlinkname_rtype_NumMethod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_NumMethod reflect.(*rtype).NumMethod</p>
               
               <pre><code>func badlinkname_rtype_NumMethod(*rtype) int</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_NumOut">
               <h3>
                  badlinkname_rtype_NumOut 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_NumOut reflect.(*rtype).NumOut</p>
               
               <pre><code>func badlinkname_rtype_NumOut(*rtype) int</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Out">
               <h3>
                  badlinkname_rtype_Out 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Out reflect.(*rtype).Out</p>
               
               <pre><code>func badlinkname_rtype_Out(*rtype, int) Type</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_PkgPath">
               <h3>
                  badlinkname_rtype_PkgPath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_PkgPath reflect.(*rtype).PkgPath</p>
               
               <pre><code>func badlinkname_rtype_PkgPath(*rtype) string</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_Size">
               <h3>
                  badlinkname_rtype_Size 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_Size reflect.(*rtype).Size</p>
               
               <pre><code>func badlinkname_rtype_Size(*rtype) uintptr</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_String">
               <h3>
                  badlinkname_rtype_String 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_String reflect.(*rtype).String</p>
               
               <pre><code>func badlinkname_rtype_String(*rtype) string</code></pre>
            </article>
            
            <article class="function" data-name="badlinkname_rtype_ptrTo">
               <h3>
                  badlinkname_rtype_ptrTo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname badlinkname_rtype_ptrTo reflect.(*rtype).ptrTo</p>
               
               <pre><code>func badlinkname_rtype_ptrTo(*rtype) *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="bucketOf">
               <h3>
                  bucketOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func bucketOf(ktyp *abi.Type, etyp *abi.Type) *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="bytesSlow">
               <h3>
                  bytesSlow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) bytesSlow() []byte</code></pre>
            </article>
            
            <article class="function" data-name="call">
               <h3>
                  call 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>call calls fn with "stackArgsSize" bytes of stack arguments laid out
at stackArgs and register arguments laid out in regArgs. frameSize is
the total amount of stack space that will be reserved by call, so this
should include enough space to spill register arguments to the stack in
case of preemption.
After fn returns, call copies stackArgsSize-stackRetOffset result bytes
back into stackArgs+stackRetOffset before returning, for any return
values passed on the stack. Register-based return values will be found
in the same regArgs structure.
regArgs must also be prepared with an appropriate ReturnIsPtr bitmap
indicating which registers will contain pointer-valued return values. The
purpose of this bitmap is to keep pointers visible to the GC between
returning from reflectcall and actually using them.
If copying result bytes back from the stack, the caller must pass the
argument frame type as stackArgsType, so that call can execute appropriate
write barriers during the copy.
Arguments passed through to call do not escape. The type is used only in a
very limited callee of call, the stackArgs are copied, and regArgs is only
used in the call frame.
go:noescape
go:linkname call runtime.reflectcall</p>
               
               <pre><code>func call(stackArgsType *abi.Type, f unsafe.Pointer, stackArgs unsafe.Pointer, stackArgsSize uint32, stackRetOffset uint32, frameSize uint32, regArgs *abi.RegArgs)</code></pre>
            </article>
            
            <article class="function" data-name="call">
               <h3>
                  call 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) call(op string, in []Value) []Value</code></pre>
            </article>
            
            <article class="function" data-name="callMethod">
               <h3>
                  callMethod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>callMethod is the call implementation used by a function returned
by makeMethodValue (used by v.Method(i).Interface()).
It is a streamlined version of the usual reflect call: the caller has
already laid out the argument frame for us, so we don't have
to deal with individual Values for each argument.
It is in this file so that it can be next to the two similar functions above.
The remainder of the makeMethodValue implementation is in makefunc.go.
NOTE: This function must be marked as a "wrapper" in the generated code,
so that the linker can make it work correctly for panic and recover.
The gc compilers know to do that for the name "reflect.callMethod".
ctxt is the "closure" generated by makeMethodValue.
frame is a pointer to the arguments to that closure on the stack.
retValid points to a boolean which should be set when the results
section of frame is set.
regs contains the argument values passed in registers and will contain
the values returned from ctxt.fn in registers.</p>
               
               <pre><code>func callMethod(ctxt *methodValue, frame unsafe.Pointer, retValid *bool, regs *abi.RegArgs)</code></pre>
            </article>
            
            <article class="function" data-name="callReflect">
               <h3>
                  callReflect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>callReflect is the call implementation used by a function
returned by MakeFunc. In many ways it is the opposite of the
method Value.call above. The method above converts a call using Values
into a call of a function with a concrete argument frame, while
callReflect converts a call of a function with a concrete argument
frame into a call using Values.
It is in this file so that it can be next to the call method above.
The remainder of the MakeFunc implementation is in makefunc.go.
NOTE: This function must be marked as a "wrapper" in the generated code,
so that the linker can make it work correctly for panic and recover.
The gc compilers know to do that for the name "reflect.callReflect".
ctxt is the "closure" generated by MakeFunc.
frame is a pointer to the arguments to that closure on the stack.
retValid points to a boolean which should be set when the results
section of frame is set.
regs contains the argument values passed in registers and will contain
the values returned from ctxt.fn in registers.</p>
               
               <pre><code>func callReflect(ctxt *makeFuncImpl, frame unsafe.Pointer, retValid *bool, regs *abi.RegArgs)</code></pre>
            </article>
            
            <article class="function" data-name="canRangeFunc">
               <h3>
                  canRangeFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func canRangeFunc(t *abi.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="canRangeFunc2">
               <h3>
                  canRangeFunc2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func canRangeFunc2(t *abi.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="capNonSlice">
               <h3>
                  capNonSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) capNonSlice() int</code></pre>
            </article>
            
            <article class="function" data-name="chancap">
               <h3>
                  chancap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>implemented in ../runtime
go:noescape</p>
               
               <pre><code>func chancap(ch unsafe.Pointer) int</code></pre>
            </article>
            
            <article class="function" data-name="chanclose">
               <h3>
                  chanclose 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func chanclose(ch unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="chanlen">
               <h3>
                  chanlen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func chanlen(ch unsafe.Pointer) int</code></pre>
            </article>
            
            <article class="function" data-name="chanrecv">
               <h3>
                  chanrecv 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func chanrecv(ch unsafe.Pointer, nb bool, val unsafe.Pointer) (selected bool, received bool)</code></pre>
            </article>
            
            <article class="function" data-name="chansend">
               <h3>
                  chansend 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func chansend(ch unsafe.Pointer, val unsafe.Pointer, nb bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="chansend0">
               <h3>
                  chansend0 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func chansend0(ch unsafe.Pointer, val unsafe.Pointer, nb bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="common">
               <h3>
                  common 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) common() *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="common">
               <h3>
                  common 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *interfaceType) common() *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="contentEscapes">
               <h3>
                  contentEscapes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Dummy annotation marking that the content of value x
escapes (i.e. modeling roughly heap=*x),
for use in cases where the reflect code is so clever that
the compiler cannot follow.</p>
               
               <pre><code>func contentEscapes(x unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="convertOp">
               <h3>
                  convertOp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp returns the function to convert a value of type src
to a value of type dst. If the conversion is illegal, convertOp returns nil.</p>
               
               <pre><code>func convertOp(dst *abi.Type, src *abi.Type) (func(Value, Type) Value)</code></pre>
            </article>
            
            <article class="function" data-name="copyVal">
               <h3>
                  copyVal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>copyVal returns a Value containing the map key or value at ptr,
allocating a new variable as needed.</p>
               
               <pre><code>func copyVal(typ *abi.Type, fl flag, ptr unsafe.Pointer) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtBytesString">
               <h3>
                  cvtBytesString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: []byte -> string</p>
               
               <pre><code>func cvtBytesString(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtComplex">
               <h3>
                  cvtComplex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: complexXX -> complexXX</p>
               
               <pre><code>func cvtComplex(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtDirect">
               <h3>
                  cvtDirect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: direct copy</p>
               
               <pre><code>func cvtDirect(v Value, typ Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtFloat">
               <h3>
                  cvtFloat 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: floatXX -> floatXX</p>
               
               <pre><code>func cvtFloat(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtFloatInt">
               <h3>
                  cvtFloatInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: floatXX -> intXX</p>
               
               <pre><code>func cvtFloatInt(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtFloatUint">
               <h3>
                  cvtFloatUint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: floatXX -> uintXX</p>
               
               <pre><code>func cvtFloatUint(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtI2I">
               <h3>
                  cvtI2I 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: interface -> interface</p>
               
               <pre><code>func cvtI2I(v Value, typ Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtInt">
               <h3>
                  cvtInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: intXX -> [u]intXX</p>
               
               <pre><code>func cvtInt(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtIntFloat">
               <h3>
                  cvtIntFloat 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: intXX -> floatXX</p>
               
               <pre><code>func cvtIntFloat(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtIntString">
               <h3>
                  cvtIntString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: intXX -> string</p>
               
               <pre><code>func cvtIntString(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtRunesString">
               <h3>
                  cvtRunesString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: []rune -> string</p>
               
               <pre><code>func cvtRunesString(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtSliceArray">
               <h3>
                  cvtSliceArray 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: []T -> [N]T</p>
               
               <pre><code>func cvtSliceArray(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtSliceArrayPtr">
               <h3>
                  cvtSliceArrayPtr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: []T -> *[N]T</p>
               
               <pre><code>func cvtSliceArrayPtr(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtStringBytes">
               <h3>
                  cvtStringBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: string -> []byte</p>
               
               <pre><code>func cvtStringBytes(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtStringRunes">
               <h3>
                  cvtStringRunes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: string -> []rune</p>
               
               <pre><code>func cvtStringRunes(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtT2I">
               <h3>
                  cvtT2I 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: concrete -> interface</p>
               
               <pre><code>func cvtT2I(v Value, typ Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtUint">
               <h3>
                  cvtUint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: uintXX -> [u]intXX</p>
               
               <pre><code>func cvtUint(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtUintFloat">
               <h3>
                  cvtUintFloat 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: uintXX -> floatXX</p>
               
               <pre><code>func cvtUintFloat(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="cvtUintString">
               <h3>
                  cvtUintString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>convertOp: uintXX -> string</p>
               
               <pre><code>func cvtUintString(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="deepValueEqual">
               <h3>
                  deepValueEqual 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Tests for deep equality using reflected types. The map argument tracks
comparisons that have already been seen, which allows short circuiting on
recursive types.</p>
               
               <pre><code>func deepValueEqual(v1 Value, v2 Value, visited map[visit]bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="directlyAssignable">
               <h3>
                  directlyAssignable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>directlyAssignable reports whether a value x of type V can be directly
assigned (using memmove) to a value of type T.
https://golang.org/doc/go_spec.html#Assignability
Ignoring the interface rules (implemented elsewhere)
and the ideal constant rules (no ideal constants at run time).</p>
               
               <pre><code>func directlyAssignable(T *abi.Type, V *abi.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="dump">
               <h3>
                  dump 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *abiDesc) dump()</code></pre>
            </article>
            
            <article class="function" data-name="dump">
               <h3>
                  dump 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *abiSeq) dump()</code></pre>
            </article>
            
            <article class="function" data-name="dumpPtrBitMap">
               <h3>
                  dumpPtrBitMap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func dumpPtrBitMap(b abi.IntArgRegBitmap)</code></pre>
            </article>
            
            <article class="function" data-name="elem">
               <h3>
                  elem 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func elem(t *abi.Type) *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="embeddedIfaceMethStub">
               <h3>
                  embeddedIfaceMethStub 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func embeddedIfaceMethStub()</code></pre>
            </article>
            
            <article class="function" data-name="emitGCMask">
               <h3>
                  emitGCMask 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>emitGCMask writes the GC mask for [n]typ into out, starting at bit
offset base.</p>
               
               <pre><code>func emitGCMask(out []byte, base uintptr, typ *abi.Type, n uintptr)</code></pre>
            </article>
            
            <article class="function" data-name="escapes">
               <h3>
                  escapes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Dummy annotation marking that the value x escapes,
for use in cases where the reflect code is so clever that
the compiler cannot follow.</p>
               
               <pre><code>func escapes(x any)</code></pre>
            </article>
            
            <article class="function" data-name="exportedMethods">
               <h3>
                  exportedMethods 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) exportedMethods() []abi.Method</code></pre>
            </article>
            
            <article class="function" data-name="extendSlice">
               <h3>
                  extendSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>extendSlice extends a slice by n elements.
Unlike Value.grow, which modifies the slice in place and
does not change the length of the slice in place,
extendSlice returns a new slice value with the length
incremented by the number of specified elements.</p>
               
               <pre><code>func (v Value) extendSlice(n int) Value</code></pre>
            </article>
            
            <article class="function" data-name="floatFromReg">
               <h3>
                  floatFromReg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>floatFromReg loads a float value from its register representation in r.
argSize must be 4 or 8.</p>
               
               <pre><code>func floatFromReg(r *abi.RegArgs, reg int, argSize uintptr, to unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="floatToReg">
               <h3>
                  floatToReg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>floatToReg stores a float value in its register representation in r.
argSize must be either 4 or 8.</p>
               
               <pre><code>func floatToReg(r *abi.RegArgs, reg int, argSize uintptr, from unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="fnv1">
               <h3>
                  fnv1 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fnv1 incorporates the list of bytes into the hash x using the FNV-1 hash function.</p>
               
               <pre><code>func fnv1(x uint32, list ...byte) uint32</code></pre>
            </article>
            
            <article class="function" data-name="funcLayout">
               <h3>
                  funcLayout 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>funcLayout computes a struct type representing the layout of the
stack-assigned function arguments and return values for the function
type t.
If rcvr != nil, rcvr specifies the type of the receiver.
The returned type exists only for GC, so we only fill out GC relevant info.
Currently, that's just size and the GC program. We also fill in
the name for possible debugging use.</p>
               
               <pre><code>func funcLayout(t *funcType, rcvr *abi.Type) (frametype *abi.Type, framePool *sync.Pool, abid abiDesc)</code></pre>
            </article>
            
            <article class="function" data-name="funcName">
               <h3>
                  funcName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>funcName returns the name of f, for use in error messages.</p>
               
               <pre><code>func funcName(f func([]Value) []Value) string</code></pre>
            </article>
            
            <article class="function" data-name="funcStr">
               <h3>
                  funcStr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>funcStr builds a string representation of a funcType.</p>
               
               <pre><code>func funcStr(ft *funcType) string</code></pre>
            </article>
            
            <article class="function" data-name="getStaticuint64s">
               <h3>
                  getStaticuint64s 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>getStaticuint64s returns a pointer to an array of 256 uint64 values,
defined in the runtime package in read-only memory.
staticuint64s[0] == 0, staticuint64s[1] == 1, and so forth.
go:linkname getStaticuint64s runtime.getStaticuint64s</p>
               
               <pre><code>func getStaticuint64s() *[256]uint64</code></pre>
            </article>
            
            <article class="function" data-name="groupAndSlotOf">
               <h3>
                  groupAndSlotOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func groupAndSlotOf(ktyp Type, etyp Type) (Type, Type)</code></pre>
            </article>
            
            <article class="function" data-name="grow">
               <h3>
                  grow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>grow is identical to Grow but does not check for assignability.</p>
               
               <pre><code>func (v Value) grow(n int)</code></pre>
            </article>
            
            <article class="function" data-name="growslice">
               <h3>
                  growslice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func growslice(t *abi.Type, old unsafeheader.Slice, num int) unsafeheader.Slice</code></pre>
            </article>
            
            <article class="function" data-name="hashMightPanic">
               <h3>
                  hashMightPanic 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hashMightPanic reports whether the hash of a map key of type t might panic.</p>
               
               <pre><code>func hashMightPanic(t *abi.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="haveIdenticalType">
               <h3>
                  haveIdenticalType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func haveIdenticalType(T *abi.Type, V *abi.Type, cmpTags bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="haveIdenticalUnderlyingType">
               <h3>
                  haveIdenticalUnderlyingType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func haveIdenticalUnderlyingType(T *abi.Type, V *abi.Type, cmpTags bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="ifaceE2I">
               <h3>
                  ifaceE2I 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ifaceE2I(t *abi.Type, src any, dst unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="implements">
               <h3>
                  implements 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>implements reports whether the type V implements the interface type T.</p>
               
               <pre><code>func implements(T *abi.Type, V *abi.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="initFuncTypes">
               <h3>
                  initFuncTypes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initFuncTypes(n int) Type</code></pre>
            </article>
            
            <article class="function" data-name="initialized">
               <h3>
                  initialized 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *hiter) initialized() bool</code></pre>
            </article>
            
            <article class="function" data-name="intFromReg">
               <h3>
                  intFromReg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>intFromReg loads an argSize sized integer from reg and places it at to.
argSize must be non-zero, fit in a register, and a power-of-two.</p>
               
               <pre><code>func intFromReg(r *abi.RegArgs, reg int, argSize uintptr, to unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="intToReg">
               <h3>
                  intToReg 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>intToReg loads an argSize sized integer and stores it into reg.
argSize must be non-zero, fit in a register, and a power-of-two.</p>
               
               <pre><code>func intToReg(r *abi.RegArgs, reg int, argSize uintptr, from unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="isLetter">
               <h3>
                  isLetter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isLetter reports whether a given 'rune' is classified as a Letter.</p>
               
               <pre><code>func isLetter(ch rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="isPaddedField">
               <h3>
                  isPaddedField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isPaddedField reports whether the i'th field of struct type t is followed
by padding.</p>
               
               <pre><code>func isPaddedField(t Type, i int) bool</code></pre>
            </article>
            
            <article class="function" data-name="isReflexive">
               <h3>
                  isReflexive 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isReflexive reports whether the == operation on the type is reflexive.
That is, x == x for all values x of type t.</p>
               
               <pre><code>func isReflexive(t *abi.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="isRegularMemory">
               <h3>
                  isRegularMemory 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>This must match cmd/compile/internal/compare.IsRegularMemory</p>
               
               <pre><code>func isRegularMemory(t Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="isValidFieldName">
               <h3>
                  isValidFieldName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isValidFieldName checks if a string is a valid (struct) field name or not.
According to the language spec, a field name should be an identifier.
identifier = letter { letter | unicode_digit } .
letter = unicode_letter | "_" .</p>
               
               <pre><code>func isValidFieldName(fieldName string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isZero">
               <h3>
                  isZero 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isZero For all zeros, performance is not as good as
return bytealg.Count(b, byte(0)) == len(b)</p>
               
               <pre><code>func isZero(b []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="kind">
               <h3>
                  kind 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f flag) kind() Kind</code></pre>
            </article>
            
            <article class="function" data-name="lenNonSlice">
               <h3>
                  lenNonSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) lenNonSlice() int</code></pre>
            </article>
            
            <article class="function" data-name="makeBytes">
               <h3>
                  makeBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeBytes(f flag, v []byte, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="makeComplex">
               <h3>
                  makeComplex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeComplex returns a Value of type t equal to v (possibly truncated to complex64),
where t is a complex64 or complex128 type.</p>
               
               <pre><code>func makeComplex(f flag, v complex128, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="makeFloat">
               <h3>
                  makeFloat 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeFloat returns a Value of type t equal to v (possibly truncated to float32),
where t is a float32 or float64 type.</p>
               
               <pre><code>func makeFloat(f flag, v float64, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="makeFloat32">
               <h3>
                  makeFloat32 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeFloat32 returns a Value of type t equal to v, where t is a float32 type.</p>
               
               <pre><code>func makeFloat32(f flag, v float32, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="makeFuncStub">
               <h3>
                  makeFuncStub 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeFuncStub is an assembly function that is the code half of
the function returned from MakeFunc. It expects a *callReflectFunc
as its context register, and its job is to invoke callReflect(ctxt, frame)
where ctxt is the context register and frame is a pointer to the first
word in the passed-in argument frame.</p>
               
               <pre><code>func makeFuncStub()</code></pre>
            </article>
            
            <article class="function" data-name="makeInt">
               <h3>
                  makeInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeInt returns a Value of type t equal to bits (possibly truncated),
where t is a signed or unsigned int type.</p>
               
               <pre><code>func makeInt(f flag, bits uint64, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="makeMethodValue">
               <h3>
                  makeMethodValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>makeMethodValue converts v from the rcvr+method index representation
of a method value to an actual method func value, which is
basically the receiver value with a special bit set, into a true
func value - a value holding an actual func. The output is
semantically equivalent to the input as far as the user of package
reflect can tell, but the true func representation can be handled
by code like Convert and Interface and Assign.</p>
               
               <pre><code>func makeMethodValue(op string, v Value) Value</code></pre>
            </article>
            
            <article class="function" data-name="makeRunes">
               <h3>
                  makeRunes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeRunes(f flag, v []rune, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="makeString">
               <h3>
                  makeString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makeString(f flag, v string, t Type) Value</code></pre>
            </article>
            
            <article class="function" data-name="makechan">
               <h3>
                  makechan 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makechan(typ *abi.Type, size int) (ch unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="makemap">
               <h3>
                  makemap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func makemap(t *abi.Type, cap int) (m unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="mapIterNext">
               <h3>
                  mapIterNext 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Equivalent to runtime.mapIterNext.
go:noinline</p>
               
               <pre><code>func mapIterNext(it *maps.Iter)</code></pre>
            </article>
            
            <article class="function" data-name="mapIterStart">
               <h3>
                  mapIterStart 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Equivalent to runtime.mapIterStart.
go:noinline</p>
               
               <pre><code>func mapIterStart(t *abi.SwissMapType, m *maps.Map, it *maps.Iter)</code></pre>
            </article>
            
            <article class="function" data-name="mapaccess">
               <h3>
                  mapaccess 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func mapaccess(t *abi.Type, m unsafe.Pointer, key unsafe.Pointer) (val unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="mapaccess_faststr">
               <h3>
                  mapaccess_faststr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func mapaccess_faststr(t *abi.Type, m unsafe.Pointer, key string) (val unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="mapassign">
               <h3>
                  mapassign 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mapassign should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/modern-go/reflect2
- github.com/goccy/go-json
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname mapassign</p>
               
               <pre><code>func mapassign(t *abi.Type, m unsafe.Pointer, key unsafe.Pointer, val unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="mapassign0">
               <h3>
                  mapassign0 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func mapassign0(t *abi.Type, m unsafe.Pointer, key unsafe.Pointer, val unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="mapassign_faststr">
               <h3>
                  mapassign_faststr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func mapassign_faststr(t *abi.Type, m unsafe.Pointer, key string, val unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="mapassign_faststr0">
               <h3>
                  mapassign_faststr0 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func mapassign_faststr0(t *abi.Type, m unsafe.Pointer, key string, val unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="mapclear">
               <h3>
                  mapclear 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func mapclear(t *abi.Type, m unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="mapdelete">
               <h3>
                  mapdelete 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func mapdelete(t *abi.Type, m unsafe.Pointer, key unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="mapdelete_faststr">
               <h3>
                  mapdelete_faststr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func mapdelete_faststr(t *abi.Type, m unsafe.Pointer, key string)</code></pre>
            </article>
            
            <article class="function" data-name="mapiterinit">
               <h3>
                  mapiterinit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func mapiterinit(t *abi.Type, m unsafe.Pointer, it *hiter)</code></pre>
            </article>
            
            <article class="function" data-name="mapiternext">
               <h3>
                  mapiternext 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func mapiternext(it *hiter)</code></pre>
            </article>
            
            <article class="function" data-name="maplen">
               <h3>
                  maplen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func maplen(m unsafe.Pointer) int</code></pre>
            </article>
            
            <article class="function" data-name="memmove">
               <h3>
                  memmove 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>memmove copies size bytes to dst from src. No write barriers are used.
go:noescape</p>
               
               <pre><code>func memmove(dst unsafe.Pointer, src unsafe.Pointer, size uintptr)</code></pre>
            </article>
            
            <article class="function" data-name="methodReceiver">
               <h3>
                  methodReceiver 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>methodReceiver returns information about the receiver
described by v. The Value v may or may not have the
flagMethod bit set, so the kind cached in v.flag should
not be used.
The return value rcvrtype gives the method's actual receiver type.
The return value t gives the method type signature (without the receiver).
The return value fn is a pointer to the method code.</p>
               
               <pre><code>func methodReceiver(op string, v Value, methodIndex int) (rcvrtype *abi.Type, t *funcType, fn unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="methodValueCall">
               <h3>
                  methodValueCall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>methodValueCall is an assembly function that is the code half of
the function returned from makeMethodValue. It expects a *methodValue
as its context register, and its job is to invoke callMethod(ctxt, frame)
where ctxt is the context register and frame is a pointer to the first
word in the passed-in argument frame.</p>
               
               <pre><code>func methodValueCall()</code></pre>
            </article>
            
            <article class="function" data-name="methodValueCallCodePtr">
               <h3>
                  methodValueCallCodePtr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func methodValueCallCodePtr() uintptr</code></pre>
            </article>
            
            <article class="function" data-name="moveMakeFuncArgPtrs">
               <h3>
                  moveMakeFuncArgPtrs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>moveMakeFuncArgPtrs uses ctxt.regPtrs to copy integer pointer arguments
in args.Ints to args.Ptrs where the GC can see them.
This is similar to what reflectcallmove does in the runtime, except
that happens on the return path, whereas this happens on the call path.
nosplit because pointers are being held in uintptr slots in args, so
having our stack scanned now could lead to accidentally freeing
memory.
go:nosplit</p>
               
               <pre><code>func moveMakeFuncArgPtrs(ctxt *makeFuncCtxt, args *abi.RegArgs)</code></pre>
            </article>
            
            <article class="function" data-name="mustBe">
               <h3>
                  mustBe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mustBe panics if f's kind is not expected.
Making this a method on flag instead of on Value
(and embedding flag in Value) means that we can write
the very clear v.mustBe(Bool) and have it compile into
v.flag.mustBe(Bool), which will only bother to copy the
single important word for the receiver.</p>
               
               <pre><code>func (f flag) mustBe(expected Kind)</code></pre>
            </article>
            
            <article class="function" data-name="mustBeAssignable">
               <h3>
                  mustBeAssignable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mustBeAssignable panics if f records that the value is not assignable,
which is to say that either it was obtained using an unexported field
or it is not addressable.</p>
               
               <pre><code>func (f flag) mustBeAssignable()</code></pre>
            </article>
            
            <article class="function" data-name="mustBeAssignableSlow">
               <h3>
                  mustBeAssignableSlow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f flag) mustBeAssignableSlow()</code></pre>
            </article>
            
            <article class="function" data-name="mustBeExported">
               <h3>
                  mustBeExported 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mustBeExported panics if f records that the value was obtained using
an unexported field.</p>
               
               <pre><code>func (f flag) mustBeExported()</code></pre>
            </article>
            
            <article class="function" data-name="mustBeExportedSlow">
               <h3>
                  mustBeExportedSlow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f flag) mustBeExportedSlow()</code></pre>
            </article>
            
            <article class="function" data-name="nameFor">
               <h3>
                  nameFor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nameFor(t *abi.Type) string</code></pre>
            </article>
            
            <article class="function" data-name="nameOff">
               <h3>
                  nameOff 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *interfaceType) nameOff(off aNameOff) abi.Name</code></pre>
            </article>
            
            <article class="function" data-name="nameOff">
               <h3>
                  nameOff 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) nameOff(off aNameOff) abi.Name</code></pre>
            </article>
            
            <article class="function" data-name="nameOffFor">
               <h3>
                  nameOffFor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nameOffFor(t *abi.Type, off aNameOff) abi.Name</code></pre>
            </article>
            
            <article class="function" data-name="needKeyUpdate">
               <h3>
                  needKeyUpdate 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>needKeyUpdate reports whether map overwrites require the key to be copied.</p>
               
               <pre><code>func needKeyUpdate(t *abi.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="newAbiDesc">
               <h3>
                  newAbiDesc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newAbiDesc(t *funcType, rcvr *abi.Type) abiDesc</code></pre>
            </article>
            
            <article class="function" data-name="newName">
               <h3>
                  newName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newName(n string, tag string, exported bool, embedded bool) abi.Name</code></pre>
            </article>
            
            <article class="function" data-name="overflowFloat32">
               <h3>
                  overflowFloat32 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func overflowFloat32(x float64) bool</code></pre>
            </article>
            
            <article class="function" data-name="packEface">
               <h3>
                  packEface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>packEface converts v to the empty interface.</p>
               
               <pre><code>func packEface(v Value) any</code></pre>
            </article>
            
            <article class="function" data-name="panicNotBool">
               <h3>
                  panicNotBool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) panicNotBool()</code></pre>
            </article>
            
            <article class="function" data-name="panicNotMap">
               <h3>
                  panicNotMap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Force slow panicking path not inlined, so it won't add to the
inlining budget of the caller.
TODO: undo when the inliner is no longer bottom-up only.
go:noinline</p>
               
               <pre><code>func (f flag) panicNotMap()</code></pre>
            </article>
            
            <article class="function" data-name="panicNotMap">
               <h3>
                  panicNotMap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Force slow panicking path not inlined, so it won't add to the
inlining budget of the caller.
TODO: undo when the inliner is no longer bottom-up only.
go:noinline</p>
               
               <pre><code>func (f flag) panicNotMap()</code></pre>
            </article>
            
            <article class="function" data-name="pkgPath">
               <h3>
                  pkgPath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func pkgPath(n abi.Name) string</code></pre>
            </article>
            
            <article class="function" data-name="pkgPathFor">
               <h3>
                  pkgPathFor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func pkgPathFor(t *abi.Type) string</code></pre>
            </article>
            
            <article class="function" data-name="pointer">
               <h3>
                  pointer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>pointer returns the underlying pointer represented by v.
v.Kind() must be Pointer, Map, Chan, Func, or UnsafePointer
if v.Kind() == Pointer, the base type must not be not-in-heap.</p>
               
               <pre><code>func (v Value) pointer() unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="ptrTo">
               <h3>
                  ptrTo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func ptrTo(t *abi.Type) *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="ptrTo">
               <h3>
                  ptrTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) ptrTo() *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="rangeNum">
               <h3>
                  rangeNum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func rangeNum(num N, t Type) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function" data-name="recv">
               <h3>
                  recv 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>internal recv, possibly non-blocking (nb).
v is known to be a channel.</p>
               
               <pre><code>func (v Value) recv(nb bool) (val Value, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="regAssign">
               <h3>
                  regAssign 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>regAssign attempts to reserve argument registers for a value of
type t, stored at some offset.
It returns whether or not the assignment succeeded, but
leaves any changes it made to a.steps behind, so the caller
must undo that work by adjusting a.steps if it fails.
This method along with the assign* methods represent the
complete register-assignment algorithm for the Go ABI.</p>
               
               <pre><code>func (a *abiSeq) regAssign(t *abi.Type, offset uintptr) bool</code></pre>
            </article>
            
            <article class="function" data-name="resolveNameOff">
               <h3>
                  resolveNameOff 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>resolveNameOff resolves a name offset from a base pointer.
The (*rtype).nameOff method is a convenience wrapper for this function.
Implemented in the runtime package.
go:noescape</p>
               
               <pre><code>func resolveNameOff(ptrInModule unsafe.Pointer, off int32) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="resolveReflectName">
               <h3>
                  resolveReflectName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>resolveReflectName adds a name to the reflection lookup map in the runtime.
It returns a new nameOff that can be used to refer to the pointer.</p>
               
               <pre><code>func resolveReflectName(n abi.Name) aNameOff</code></pre>
            </article>
            
            <article class="function" data-name="resolveReflectText">
               <h3>
                  resolveReflectText 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>resolveReflectText adds a function pointer to the reflection lookup map in
the runtime. It returns a new textOff that can be used to refer to the
pointer.</p>
               
               <pre><code>func resolveReflectText(ptr unsafe.Pointer) aTextOff</code></pre>
            </article>
            
            <article class="function" data-name="resolveReflectType">
               <h3>
                  resolveReflectType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>resolveReflectType adds a *rtype to the reflection lookup map in the runtime.
It returns a new typeOff that can be used to refer to the pointer.</p>
               
               <pre><code>func resolveReflectType(t *abi.Type) aTypeOff</code></pre>
            </article>
            
            <article class="function" data-name="resolveTextOff">
               <h3>
                  resolveTextOff 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>resolveTextOff resolves a function pointer offset from a base type.
The (*rtype).textOff method is a convenience wrapper for this function.
Implemented in the runtime package.
go:noescape</p>
               
               <pre><code>func resolveTextOff(rtype unsafe.Pointer, off int32) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="resolveTypeOff">
               <h3>
                  resolveTypeOff 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>resolveTypeOff resolves an *rtype offset from a base type.
The (*rtype).typeOff method is a convenience wrapper for this function.
Implemented in the runtime package.
go:noescape</p>
               
               <pre><code>func resolveTypeOff(rtype unsafe.Pointer, off int32) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="ro">
               <h3>
                  ro 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f flag) ro() flag</code></pre>
            </article>
            
            <article class="function" data-name="rselect">
               <h3>
                  rselect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>rselect runs a select. It returns the index of the chosen case.
If the case was a receive, val is filled in with the received value.
The conventional OK bool indicates whether the receive corresponds
to a sent value.
rselect generally doesn't escape the runtimeSelect slice, except
that for the send case the value to send needs to escape. We don't
have a way to represent that in the function signature. So we handle
that with a forced escape in function Select.
go:noescape</p>
               
               <pre><code>func rselect([]runtimeSelect) (chosen int, recvOK bool)</code></pre>
            </article>
            
            <article class="function" data-name="rtypeOf">
               <h3>
                  rtypeOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>rtypeOf directly extracts the *rtype of the provided value.</p>
               
               <pre><code>func rtypeOf(i any) *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="rtypeOff">
               <h3>
                  rtypeOff 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>rtypeOff should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/goccy/go-json
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname rtypeOff</p>
               
               <pre><code>func rtypeOff(section unsafe.Pointer, off int32) *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="runes">
               <h3>
                  runes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>runes returns v's underlying value.
It panics if v's underlying value is not a slice of runes (int32s).</p>
               
               <pre><code>func (v Value) runes() []rune</code></pre>
            </article>
            
            <article class="function" data-name="runtimeStructField">
               <h3>
                  runtimeStructField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>runtimeStructField takes a StructField value passed to StructOf and
returns both the corresponding internal representation, of type
structField, and the pkgpath value to use for this field.</p>
               
               <pre><code>func runtimeStructField(field StructField) (structField, string)</code></pre>
            </article>
            
            <article class="function" data-name="send">
               <h3>
                  send 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>internal send, possibly non-blocking.
v is known to be a channel.</p>
               
               <pre><code>func (v Value) send(x Value, nb bool) (selected bool)</code></pre>
            </article>
            
            <article class="function" data-name="setRunes">
               <h3>
                  setRunes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setRunes sets v's underlying value.
It panics if v's underlying value is not a slice of runes (int32s)
or if [Value.CanSet] returns false.</p>
               
               <pre><code>func (v Value) setRunes(x []rune)</code></pre>
            </article>
            
            <article class="function" data-name="specialChannelAssignability">
               <h3>
                  specialChannelAssignability 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>specialChannelAssignability reports whether a value x of channel type V
can be directly assigned (using memmove) to another channel type T.
https://golang.org/doc/go_spec.html#Assignability
T and V must be both of Chan kind.</p>
               
               <pre><code>func specialChannelAssignability(T *abi.Type, V *abi.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="stackAssign">
               <h3>
                  stackAssign 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>stackAssign reserves space for one value that is "size" bytes
large with alignment "alignment" to the stack.
Should not be called directly; use addArg instead.</p>
               
               <pre><code>func (a *abiSeq) stackAssign(size uintptr, alignment uintptr)</code></pre>
            </article>
            
            <article class="function" data-name="stepsForValue">
               <h3>
                  stepsForValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>stepsForValue returns the ABI instructions for translating
the i'th Go argument or return value represented by this
abiSeq to the Go ABI.</p>
               
               <pre><code>func (a *abiSeq) stepsForValue(i int) []abiStep</code></pre>
            </article>
            
            <article class="function" data-name="storeRcvr">
               <h3>
                  storeRcvr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>v is a method receiver. Store at p the word which is used to
encode that receiver at the start of the argument list.
Reflect uses the "interface" calling convention for
methods, which always uses one word to record the receiver.</p>
               
               <pre><code>func storeRcvr(v Value, p unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="stringFor">
               <h3>
                  stringFor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func stringFor(t *abi.Type) string</code></pre>
            </article>
            
            <article class="function" data-name="stringNonString">
               <h3>
                  stringNonString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) stringNonString() string</code></pre>
            </article>
            
            <article class="function" data-name="textOff">
               <h3>
                  textOff 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) textOff(off aTextOff) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="textOffFor">
               <h3>
                  textOffFor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func textOffFor(t *abi.Type, off aTextOff) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="toRType">
               <h3>
                  toRType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func toRType(t *abi.Type) *rtype</code></pre>
            </article>
            
            <article class="function" data-name="toType">
               <h3>
                  toType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>toType converts from a *rtype to a Type that can be returned
to the client of package reflect. In gc, the only concern is that
a nil *rtype must be replaced by a nil Type, but in gccgo this
function takes care of ensuring that multiple *rtype for the same
type are coalesced into a single Type.
toType should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- fortio.org/log
- github.com/goccy/go-json
- github.com/goccy/go-reflect
- github.com/sohaha/zlsgo
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname toType</p>
               
               <pre><code>func toType(t *abi.Type) Type</code></pre>
            </article>
            
            <article class="function" data-name="typ">
               <h3>
                  typ 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>typ returns the *abi.Type stored in the Value. This method is fast,
but it doesn't always return the correct type for the Value.
See abiType and Type, which do return the correct type.</p>
               
               <pre><code>func (v Value) typ() *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="typeOff">
               <h3>
                  typeOff 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) typeOff(off aTypeOff) *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="typeOff">
               <h3>
                  typeOff 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *interfaceType) typeOff(off aTypeOff) *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="typeOffFor">
               <h3>
                  typeOffFor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func typeOffFor(t *abi.Type, off aTypeOff) *abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="typeSlow">
               <h3>
                  typeSlow 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>go:noinline</p>
               
               <pre><code>func (v Value) typeSlow() Type</code></pre>
            </article>
            
            <article class="function" data-name="typedarrayclear">
               <h3>
                  typedarrayclear 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typedarrayclear zeroes the value at ptr of an array of elemType,
only clears len elem.
go:noescape</p>
               
               <pre><code>func typedarrayclear(elemType *abi.Type, ptr unsafe.Pointer, len int)</code></pre>
            </article>
            
            <article class="function" data-name="typedmemclr">
               <h3>
                  typedmemclr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typedmemclr zeros the value at ptr of type t.
go:noescape</p>
               
               <pre><code>func typedmemclr(t *abi.Type, ptr unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="typedmemclrpartial">
               <h3>
                  typedmemclrpartial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typedmemclrpartial is like typedmemclr but assumes that
dst points off bytes into the value and only clears size bytes.
go:noescape</p>
               
               <pre><code>func typedmemclrpartial(t *abi.Type, ptr unsafe.Pointer, off uintptr, size uintptr)</code></pre>
            </article>
            
            <article class="function" data-name="typedmemmove">
               <h3>
                  typedmemmove 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typedmemmove copies a value of type t to dst from src.
go:noescape</p>
               
               <pre><code>func typedmemmove(t *abi.Type, dst unsafe.Pointer, src unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function" data-name="typedslicecopy">
               <h3>
                  typedslicecopy 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typedslicecopy copies a slice of elemType values from src to dst,
returning the number of elements copied.
go:noescape</p>
               
               <pre><code>func typedslicecopy(t *abi.Type, dst unsafeheader.Slice, src unsafeheader.Slice) int</code></pre>
            </article>
            
            <article class="function" data-name="typehash">
               <h3>
                  typehash 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func typehash(t *abi.Type, p unsafe.Pointer, h uintptr) uintptr</code></pre>
            </article>
            
            <article class="function" data-name="typelinks">
               <h3>
                  typelinks 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typelinks is implemented in package runtime.
It returns a slice of the sections in each module,
and a slice of *rtype offsets in each module.
The types in each module are sorted by string. That is, the first
two linked types of the first module are:
d0 := sections[0]
t1 := (*rtype)(add(d0, offset[0][0]))
t2 := (*rtype)(add(d0, offset[0][1]))
and
t1.String() < t2.String()
Note that strings are not unique identifiers for types:
there can be more than one with a given string.
Only types we might want to look up are included:
pointers, channels, maps, slices, and arrays.</p>
               
               <pre><code>func typelinks() (sections []unsafe.Pointer, offset [][]int32)</code></pre>
            </article>
            
            <article class="function" data-name="typeptrdata">
               <h3>
                  typeptrdata 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typeptrdata returns the length in bytes of the prefix of t
containing pointer data. Anything after this offset is scalar data.
keep in sync with ../cmd/compile/internal/reflectdata/reflect.go</p>
               
               <pre><code>func typeptrdata(t *abi.Type) uintptr</code></pre>
            </article>
            
            <article class="function" data-name="typesByString">
               <h3>
                  typesByString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typesByString returns the subslice of typelinks() whose elements have
the given string representation.
It may be empty (no known types with that string) or may have
multiple elements (multiple types with that string).
typesByString should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/aristanetworks/goarista
- fortio.org/log
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname typesByString</p>
               
               <pre><code>func typesByString(s string) []*abi.Type</code></pre>
            </article>
            
            <article class="function" data-name="typesMustMatch">
               <h3>
                  typesMustMatch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func typesMustMatch(what string, t1 Type, t2 Type)</code></pre>
            </article>
            
            <article class="function" data-name="uncommon">
               <h3>
                  uncommon 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *interfaceType) uncommon() *abi.UncommonType</code></pre>
            </article>
            
            <article class="function" data-name="uncommon">
               <h3>
                  uncommon 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *rtype) uncommon() *abi.UncommonType</code></pre>
            </article>
            
            <article class="function" data-name="unpackEface">
               <h3>
                  unpackEface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>unpackEface converts the empty interface i to a Value.</p>
               
               <pre><code>func unpackEface(i any) Value</code></pre>
            </article>
            
            <article class="function" data-name="unsafe_New">
               <h3>
                  unsafe_New 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func unsafe_New(*abi.Type) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="unsafe_NewArray">
               <h3>
                  unsafe_NewArray 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func unsafe_NewArray(*abi.Type, int) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="unsafeslice">
               <h3>
                  unsafeslice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code>func unsafeslice(t *abi.Type, ptr unsafe.Pointer, len int)</code></pre>
            </article>
            
            <article class="function" data-name="unusedIfaceIndir">
               <h3>
                  unusedIfaceIndir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ifaceIndir reports whether t is stored indirectly in an interface value.
It is no longer used by this package and is here entirely for the
linkname uses.
go:linkname unusedIfaceIndir reflect.ifaceIndir</p>
               
               <pre><code>func unusedIfaceIndir(t *abi.Type) bool</code></pre>
            </article>
            
            <article class="function" data-name="valueInterface">
               <h3>
                  valueInterface 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func valueInterface(v Value, safe bool) any</code></pre>
            </article>
            
            <article class="function" data-name="valueMethodName">
               <h3>
                  valueMethodName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>valueMethodName returns the name of the exported calling method on Value.</p>
               
               <pre><code>func valueMethodName() string</code></pre>
            </article>
            
            <article class="function" data-name="verifyNotInHeapPtr">
               <h3>
                  verifyNotInHeapPtr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func verifyNotInHeapPtr(p uintptr) bool</code></pre>
            </article>
            
            <article class="function" data-name="walk">
               <h3>
                  walk 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>walk walks all the fields in the struct type t, visiting
fields in index preorder and appending them to w.fields
(this maintains the required ordering).
Fields that have been overridden have their
Name field cleared.</p>
               
               <pre><code>func (w *visibleFieldsWalker) walk(t Type)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
