<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>reflect - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>reflect</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"internal/abi"
"internal/goarch"
"internal/unsafeheader"
"unsafe"
"internal/abi"
"internal/goarch"
"runtime"
"strconv"
"sync"
"unicode"
"unicode/utf8"
"unsafe"
"errors"
"internal/abi"
"internal/goarch"
"internal/itoa"
"internal/unsafeheader"
"math"
"runtime"
"unsafe"
"internal/abi"
"internal/goarch"
"unsafe"
"internal/bytealg"
"unsafe"
"internal/abi"
"unsafe"
"internal/abi"
"internal/race"
"internal/runtime/maps"
"internal/runtime/sys"
"unsafe"
"arena"
"internal/abi"
"unsafe"
_ "unsafe"
"unsafe"
"iter"
"internal/abi"
"internal/goarch"
"unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="Array" data-name="Array">
               <h3>
                  Array 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Array" class="anchor" title="Link to Array">#</a>
               </h3>
               
               <pre><code class="language-go">const Array</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Bool" data-name="Bool">
               <h3>
                  Bool 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Bool" class="anchor" title="Link to Bool">#</a>
               </h3>
               
               <pre><code class="language-go">const Bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BothDir" data-name="BothDir">
               <h3>
                  BothDir 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BothDir" class="anchor" title="Link to BothDir">#</a>
               </h3>
               
               <pre><code class="language-go">const BothDir = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Chan" data-name="Chan">
               <h3>
                  Chan 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Chan" class="anchor" title="Link to Chan">#</a>
               </h3>
               
               <pre><code class="language-go">const Chan</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Complex128" data-name="Complex128">
               <h3>
                  Complex128 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Complex128" class="anchor" title="Link to Complex128">#</a>
               </h3>
               
               <pre><code class="language-go">const Complex128</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Complex64" data-name="Complex64">
               <h3>
                  Complex64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Complex64" class="anchor" title="Link to Complex64">#</a>
               </h3>
               
               <pre><code class="language-go">const Complex64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Float32" data-name="Float32">
               <h3>
                  Float32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Float32" class="anchor" title="Link to Float32">#</a>
               </h3>
               
               <pre><code class="language-go">const Float32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Float64" data-name="Float64">
               <h3>
                  Float64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Float64" class="anchor" title="Link to Float64">#</a>
               </h3>
               
               <pre><code class="language-go">const Float64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Func" data-name="Func">
               <h3>
                  Func 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Func" class="anchor" title="Link to Func">#</a>
               </h3>
               
               <pre><code class="language-go">const Func</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int" data-name="Int">
               <h3>
                  Int 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int" class="anchor" title="Link to Int">#</a>
               </h3>
               
               <pre><code class="language-go">const Int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int16" data-name="Int16">
               <h3>
                  Int16 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int16" class="anchor" title="Link to Int16">#</a>
               </h3>
               
               <pre><code class="language-go">const Int16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int32" data-name="Int32">
               <h3>
                  Int32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int32" class="anchor" title="Link to Int32">#</a>
               </h3>
               
               <pre><code class="language-go">const Int32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int64" data-name="Int64">
               <h3>
                  Int64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int64" class="anchor" title="Link to Int64">#</a>
               </h3>
               
               <pre><code class="language-go">const Int64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int8" data-name="Int8">
               <h3>
                  Int8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int8" class="anchor" title="Link to Int8">#</a>
               </h3>
               
               <pre><code class="language-go">const Int8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Interface" data-name="Interface">
               <h3>
                  Interface 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Interface" class="anchor" title="Link to Interface">#</a>
               </h3>
               
               <pre><code class="language-go">const Interface</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Invalid" data-name="Invalid">
               <h3>
                  Invalid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Invalid" class="anchor" title="Link to Invalid">#</a>
               </h3>
               
               <pre><code class="language-go">const Invalid Kind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Map" data-name="Map">
               <h3>
                  Map 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Map" class="anchor" title="Link to Map">#</a>
               </h3>
               
               <pre><code class="language-go">const Map</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Pointer" data-name="Pointer">
               <h3>
                  Pointer 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Pointer" class="anchor" title="Link to Pointer">#</a>
               </h3>
               
               <pre><code class="language-go">const Pointer</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Ptr" data-name="Ptr">
               <h3>
                  Ptr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Ptr" class="anchor" title="Link to Ptr">#</a>
               </h3>
               
                  <p class="doc-comment">Ptr is the old name for the [Pointer] kind.</p>
               
               <pre><code class="language-go">const Ptr = Pointer</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RecvDir" data-name="RecvDir">
               <h3>
                  RecvDir 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RecvDir" class="anchor" title="Link to RecvDir">#</a>
               </h3>
               
               <pre><code class="language-go">const RecvDir ChanDir = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SelectDefault" data-name="SelectDefault">
               <h3>
                  SelectDefault 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SelectDefault" class="anchor" title="Link to SelectDefault">#</a>
               </h3>
               
               <pre><code class="language-go">const SelectDefault</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SelectRecv" data-name="SelectRecv">
               <h3>
                  SelectRecv 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SelectRecv" class="anchor" title="Link to SelectRecv">#</a>
               </h3>
               
               <pre><code class="language-go">const SelectRecv</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SelectSend" data-name="SelectSend">
               <h3>
                  SelectSend 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SelectSend" class="anchor" title="Link to SelectSend">#</a>
               </h3>
               
               <pre><code class="language-go">const SelectSend</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SendDir" data-name="SendDir">
               <h3>
                  SendDir 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SendDir" class="anchor" title="Link to SendDir">#</a>
               </h3>
               
               <pre><code class="language-go">const SendDir</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Slice" data-name="Slice">
               <h3>
                  Slice 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Slice" class="anchor" title="Link to Slice">#</a>
               </h3>
               
               <pre><code class="language-go">const Slice</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">const String</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Struct" data-name="Struct">
               <h3>
                  Struct 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Struct" class="anchor" title="Link to Struct">#</a>
               </h3>
               
               <pre><code class="language-go">const Struct</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint" data-name="Uint">
               <h3>
                  Uint 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint" class="anchor" title="Link to Uint">#</a>
               </h3>
               
               <pre><code class="language-go">const Uint</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint16" data-name="Uint16">
               <h3>
                  Uint16 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint16" class="anchor" title="Link to Uint16">#</a>
               </h3>
               
               <pre><code class="language-go">const Uint16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint32" data-name="Uint32">
               <h3>
                  Uint32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint32" class="anchor" title="Link to Uint32">#</a>
               </h3>
               
               <pre><code class="language-go">const Uint32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint64" data-name="Uint64">
               <h3>
                  Uint64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint64" class="anchor" title="Link to Uint64">#</a>
               </h3>
               
               <pre><code class="language-go">const Uint64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint8" data-name="Uint8">
               <h3>
                  Uint8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint8" class="anchor" title="Link to Uint8">#</a>
               </h3>
               
               <pre><code class="language-go">const Uint8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uintptr" data-name="Uintptr">
               <h3>
                  Uintptr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uintptr" class="anchor" title="Link to Uintptr">#</a>
               </h3>
               
               <pre><code class="language-go">const Uintptr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnsafePointer" data-name="UnsafePointer">
               <h3>
                  UnsafePointer 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnsafePointer" class="anchor" title="Link to UnsafePointer">#</a>
               </h3>
               
               <pre><code class="language-go">const UnsafePointer</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">const _ SelectDir = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="abiStepBad" data-name="abiStepBad">
               <h3>
                  abiStepBad 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#abiStepBad" class="anchor" title="Link to abiStepBad">#</a>
               </h3>
               
               <pre><code class="language-go">const abiStepBad abiStepKind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="abiStepFloatReg" data-name="abiStepFloatReg">
               <h3>
                  abiStepFloatReg 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#abiStepFloatReg" class="anchor" title="Link to abiStepFloatReg">#</a>
               </h3>
               
               <pre><code class="language-go">const abiStepFloatReg</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="abiStepIntReg" data-name="abiStepIntReg">
               <h3>
                  abiStepIntReg 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#abiStepIntReg" class="anchor" title="Link to abiStepIntReg">#</a>
               </h3>
               
               <pre><code class="language-go">const abiStepIntReg</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="abiStepPointer" data-name="abiStepPointer">
               <h3>
                  abiStepPointer 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#abiStepPointer" class="anchor" title="Link to abiStepPointer">#</a>
               </h3>
               
               <pre><code class="language-go">const abiStepPointer</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="abiStepStack" data-name="abiStepStack">
               <h3>
                  abiStepStack 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#abiStepStack" class="anchor" title="Link to abiStepStack">#</a>
               </h3>
               
               <pre><code class="language-go">const abiStepStack</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bytesType" data-name="bytesType">
               <h3>
                  bytesType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bytesType" class="anchor" title="Link to bytesType">#</a>
               </h3>
               
               <pre><code class="language-go">var bytesType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="callGC" data-name="callGC">
               <h3>
                  callGC 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#callGC" class="anchor" title="Link to callGC">#</a>
               </h3>
               
               <pre><code class="language-go">var callGC bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugReflectCall" data-name="debugReflectCall">
               <h3>
                  debugReflectCall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debugReflectCall" class="anchor" title="Link to debugReflectCall">#</a>
               </h3>
               
               <pre><code class="language-go">const debugReflectCall = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dummy" data-name="dummy">
               <h3>
                  dummy 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dummy" class="anchor" title="Link to dummy">#</a>
               </h3>
               
               <pre><code class="language-go">var dummy struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagAddr" data-name="flagAddr">
               <h3>
                  flagAddr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagAddr" class="anchor" title="Link to flagAddr">#</a>
               </h3>
               
               <pre><code class="language-go">const flagAddr flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagEmbedRO" data-name="flagEmbedRO">
               <h3>
                  flagEmbedRO 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagEmbedRO" class="anchor" title="Link to flagEmbedRO">#</a>
               </h3>
               
               <pre><code class="language-go">const flagEmbedRO flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagIndir" data-name="flagIndir">
               <h3>
                  flagIndir 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagIndir" class="anchor" title="Link to flagIndir">#</a>
               </h3>
               
               <pre><code class="language-go">const flagIndir flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagKindMask" data-name="flagKindMask">
               <h3>
                  flagKindMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagKindMask" class="anchor" title="Link to flagKindMask">#</a>
               </h3>
               
               <pre><code class="language-go">const flagKindMask flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagKindWidth" data-name="flagKindWidth">
               <h3>
                  flagKindWidth 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagKindWidth" class="anchor" title="Link to flagKindWidth">#</a>
               </h3>
               
               <pre><code class="language-go">const flagKindWidth = 5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagMethod" data-name="flagMethod">
               <h3>
                  flagMethod 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagMethod" class="anchor" title="Link to flagMethod">#</a>
               </h3>
               
               <pre><code class="language-go">const flagMethod flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagMethodShift" data-name="flagMethodShift">
               <h3>
                  flagMethodShift 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagMethodShift" class="anchor" title="Link to flagMethodShift">#</a>
               </h3>
               
               <pre><code class="language-go">const flagMethodShift = 10</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagRO" data-name="flagRO">
               <h3>
                  flagRO 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagRO" class="anchor" title="Link to flagRO">#</a>
               </h3>
               
               <pre><code class="language-go">const flagRO flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagStickyRO" data-name="flagStickyRO">
               <h3>
                  flagStickyRO 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagStickyRO" class="anchor" title="Link to flagStickyRO">#</a>
               </h3>
               
               <pre><code class="language-go">const flagStickyRO flag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="floatArgRegs" data-name="floatArgRegs">
               <h3>
                  floatArgRegs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#floatArgRegs" class="anchor" title="Link to floatArgRegs">#</a>
               </h3>
               
                  <p class="doc-comment">These variables are used by the register assignment
algorithm in this file.
They should be modified with care (no other reflect code
may be executing) and are generally only modified
when testing this package.
They should never be set higher than their internal/abi
constant counterparts, because the system relies on a
structure that is at least large enough to hold the
registers the system supports.
Currently they're set to zero because using the actual
constants will break every part of the toolchain that
uses reflect to call functions (e.g. go test, or anything
that uses text/template). The values that are currently
commented out there should be the actual values once
we're ready to use the register ABI everywhere.</p>
               
               <pre><code class="language-go">var floatArgRegs = abi.FloatArgRegs</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="floatRegSize" data-name="floatRegSize">
               <h3>
                  floatRegSize 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#floatRegSize" class="anchor" title="Link to floatRegSize">#</a>
               </h3>
               
                  <p class="doc-comment">These variables are used by the register assignment
algorithm in this file.
They should be modified with care (no other reflect code
may be executing) and are generally only modified
when testing this package.
They should never be set higher than their internal/abi
constant counterparts, because the system relies on a
structure that is at least large enough to hold the
registers the system supports.
Currently they're set to zero because using the actual
constants will break every part of the toolchain that
uses reflect to call functions (e.g. go test, or anything
that uses text/template). The values that are currently
commented out there should be the actual values once
we're ready to use the register ABI everywhere.</p>
               
               <pre><code class="language-go">var floatRegSize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="funcLookupCache" data-name="funcLookupCache">
               <h3>
                  funcLookupCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#funcLookupCache" class="anchor" title="Link to funcLookupCache">#</a>
               </h3>
               
                  <p class="doc-comment">The funcLookupCache caches FuncOf lookups.
FuncOf does not share the common lookupCache since cacheKey is not
sufficient to represent functions unambiguously.</p>
               
               <pre><code class="language-go">var funcLookupCache struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="funcTypes" data-name="funcTypes">
               <h3>
                  funcTypes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#funcTypes" class="anchor" title="Link to funcTypes">#</a>
               </h3>
               
               <pre><code class="language-go">var funcTypes []Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="funcTypesMutex" data-name="funcTypesMutex">
               <h3>
                  funcTypesMutex 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#funcTypesMutex" class="anchor" title="Link to funcTypesMutex">#</a>
               </h3>
               
               <pre><code class="language-go">var funcTypesMutex sync.Mutex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="intArgRegs" data-name="intArgRegs">
               <h3>
                  intArgRegs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#intArgRegs" class="anchor" title="Link to intArgRegs">#</a>
               </h3>
               
                  <p class="doc-comment">These variables are used by the register assignment
algorithm in this file.
They should be modified with care (no other reflect code
may be executing) and are generally only modified
when testing this package.
They should never be set higher than their internal/abi
constant counterparts, because the system relies on a
structure that is at least large enough to hold the
registers the system supports.
Currently they're set to zero because using the actual
constants will break every part of the toolchain that
uses reflect to call functions (e.g. go test, or anything
that uses text/template). The values that are currently
commented out there should be the actual values once
we're ready to use the register ABI everywhere.</p>
               
               <pre><code class="language-go">var intArgRegs = abi.IntArgRegs</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="kindNames" data-name="kindNames">
               <h3>
                  kindNames 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#kindNames" class="anchor" title="Link to kindNames">#</a>
               </h3>
               
               <pre><code class="language-go">var kindNames = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="layoutCache" data-name="layoutCache">
               <h3>
                  layoutCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#layoutCache" class="anchor" title="Link to layoutCache">#</a>
               </h3>
               
               <pre><code class="language-go">var layoutCache sync.Map</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lookupCache" data-name="lookupCache">
               <h3>
                  lookupCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#lookupCache" class="anchor" title="Link to lookupCache">#</a>
               </h3>
               
                  <p class="doc-comment">The lookupCache caches ArrayOf, ChanOf, MapOf and SliceOf lookups.</p>
               
               <pre><code class="language-go">var lookupCache sync.Map</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ptrMap" data-name="ptrMap">
               <h3>
                  ptrMap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ptrMap" class="anchor" title="Link to ptrMap">#</a>
               </h3>
               
                  <p class="doc-comment">ptrMap is the cache for PointerTo.</p>
               
               <pre><code class="language-go">var ptrMap sync.Map</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stringType" data-name="stringType">
               <h3>
                  stringType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#stringType" class="anchor" title="Link to stringType">#</a>
               </h3>
               
               <pre><code class="language-go">var stringType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stringType" data-name="stringType">
               <h3>
                  stringType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#stringType" class="anchor" title="Link to stringType">#</a>
               </h3>
               
               <pre><code class="language-go">var stringType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="structLookupCache" data-name="structLookupCache">
               <h3>
                  structLookupCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#structLookupCache" class="anchor" title="Link to structLookupCache">#</a>
               </h3>
               
                  <p class="doc-comment">The structLookupCache caches StructOf lookups.
StructOf does not share the common lookupCache since we need to pin
the memory associated with *structTypeFixedN.</p>
               
               <pre><code class="language-go">var structLookupCache struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="uint8Type" data-name="uint8Type">
               <h3>
                  uint8Type 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#uint8Type" class="anchor" title="Link to uint8Type">#</a>
               </h3>
               
               <pre><code class="language-go">var uint8Type = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="zeroVal" data-name="zeroVal">
               <h3>
                  zeroVal 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#zeroVal" class="anchor" title="Link to zeroVal">#</a>
               </h3>
               
                  <p class="doc-comment">go:linkname zeroVal runtime.zeroVal</p>
               
               <pre><code class="language-go">var zeroVal [abi.ZeroValSize]byte</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ChanDir" data-name="ChanDir">
               <h3>
                  ChanDir
                  <span class="badge type-badge">type</span>
                  <a href="#ChanDir" class="anchor" title="Link to ChanDir">#</a>
               </h3>
               
               <p>ChanDir represents a channel type's direction.</p>
               
               <pre><code class="language-go">type ChanDir int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Kind" data-name="Kind">
               <h3>
                  Kind
                  <span class="badge type-badge">type</span>
                  <a href="#Kind" class="anchor" title="Link to Kind">#</a>
               </h3>
               
               <p>A Kind represents the specific kind of type that a [Type] represents.
The zero Kind is not a valid kind.</p>
               
               <pre><code class="language-go">type Kind uint</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="SelectDir" data-name="SelectDir">
               <h3>
                  SelectDir
                  <span class="badge type-badge">type</span>
                  <a href="#SelectDir" class="anchor" title="Link to SelectDir">#</a>
               </h3>
               
               <p>A SelectDir describes the communication direction of a select case.</p>
               
               <pre><code class="language-go">type SelectDir int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="StructTag" data-name="StructTag">
               <h3>
                  StructTag
                  <span class="badge type-badge">type</span>
                  <a href="#StructTag" class="anchor" title="Link to StructTag">#</a>
               </h3>
               
               <p>A StructTag is the tag string in a struct field.
By convention, tag strings are a concatenation of
optionally space-separated key:"value" pairs.
Each key is a non-empty string consisting of non-control
characters other than space (U+0020 ' '), quote (U+0022 '"'),
and colon (U+003A ':').  Each value is quoted using U+0022 '"'
characters and Go string literal syntax.</p>
               
               <pre><code class="language-go">type StructTag string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="aNameOff" data-name="aNameOff">
               <h3>
                  aNameOff
                  <span class="badge type-badge">type</span>
                  <a href="#aNameOff" class="anchor" title="Link to aNameOff">#</a>
               </h3>
               
               <pre><code class="language-go">type aNameOff abi.NameOff</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="aTextOff" data-name="aTextOff">
               <h3>
                  aTextOff
                  <span class="badge type-badge">type</span>
                  <a href="#aTextOff" class="anchor" title="Link to aTextOff">#</a>
               </h3>
               
               <pre><code class="language-go">type aTextOff abi.TextOff</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="aTypeOff" data-name="aTypeOff">
               <h3>
                  aTypeOff
                  <span class="badge type-badge">type</span>
                  <a href="#aTypeOff" class="anchor" title="Link to aTypeOff">#</a>
               </h3>
               
               <pre><code class="language-go">type aTypeOff abi.TypeOff</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="abiStepKind" data-name="abiStepKind">
               <h3>
                  abiStepKind
                  <span class="badge type-badge">type</span>
                  <a href="#abiStepKind" class="anchor" title="Link to abiStepKind">#</a>
               </h3>
               
               <p>abiStepKind is the "op-code" for an abiStep instruction.</p>
               
               <pre><code class="language-go">type abiStepKind int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="arrayType" data-name="arrayType">
               <h3>
                  arrayType
                  <span class="badge type-badge">type</span>
                  <a href="#arrayType" class="anchor" title="Link to arrayType">#</a>
               </h3>
               
               <p>arrayType represents a fixed array type.</p>
               
               <pre><code class="language-go">type arrayType abi.ArrayType</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="chanType" data-name="chanType">
               <h3>
                  chanType
                  <span class="badge type-badge">type</span>
                  <a href="#chanType" class="anchor" title="Link to chanType">#</a>
               </h3>
               
               <p>chanType represents a channel type.</p>
               
               <pre><code class="language-go">type chanType abi.ChanType</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="flag" data-name="flag">
               <h3>
                  flag
                  <span class="badge type-badge">type</span>
                  <a href="#flag" class="anchor" title="Link to flag">#</a>
               </h3>
               
               <pre><code class="language-go">type flag uintptr</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="funcType" data-name="funcType">
               <h3>
                  funcType
                  <span class="badge type-badge">type</span>
                  <a href="#funcType" class="anchor" title="Link to funcType">#</a>
               </h3>
               
               <p>funcType represents a function type.
A *rtype for each in and out parameter is stored in an array that
directly follows the funcType (and possibly its uncommonType). So
a function type with one method, one input, and one output is:
struct {
funcType
uncommonType
[2]*rtype    // [0] is in, [1] is out
}</p>
               
               <pre><code class="language-go">type funcType abi.FuncType</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="hiter" data-name="hiter">
               <h3>
                  hiter
                  <span class="badge type-badge">type</span>
                  <a href="#hiter" class="anchor" title="Link to hiter">#</a>
               </h3>
               
               <p>TODO(prattmic): only for sharing the linkname declarations with old maps.
Remove with old maps.</p>
               
               <pre><code class="language-go">type hiter maps.Iter</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="mapType" data-name="mapType">
               <h3>
                  mapType
                  <span class="badge type-badge">type</span>
                  <a href="#mapType" class="anchor" title="Link to mapType">#</a>
               </h3>
               
               <p>mapType represents a map type.
TODO(prattmic): Only used within this file, could be cleaned up.</p>
               
               <pre><code class="language-go">type mapType abi.SwissMapType</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="structField" data-name="structField">
               <h3>
                  structField
                  <span class="badge type-badge">type</span>
                  <a href="#structField" class="anchor" title="Link to structField">#</a>
               </h3>
               
               <p>Struct field</p>
               
               <pre><code class="language-go">type structField abi.StructField</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="uncommonType" data-name="uncommonType">
               <h3>
                  uncommonType
                  <span class="badge type-badge">type</span>
                  <a href="#uncommonType" class="anchor" title="Link to uncommonType">#</a>
               </h3>
               
               <p>uncommonType is present only for defined types or types with methods
(if T is a defined type, the uncommonTypes for T and *T have methods).
Using a pointer to this struct reduces the overall size required
to describe a non-defined type with no methods.</p>
               
               <pre><code class="language-go">type uncommonType abi.UncommonType</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type
                  <span class="badge interface-badge">interface</span>
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>Type is the representation of a Go type.
Not all methods apply to all kinds of types. Restrictions,
if any, are noted in the documentation for each method.
Use the Kind method to find out the kind of type before
calling kind-specific methods. Calling a method
inappropriate to the kind of type causes a run-time panic.
Type values are comparable, such as with the == operator,
so they can be used as map keys.
Two Type values are equal if they represent identical types.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Type interface {
Align() int
FieldAlign() int
Method(int) Method
MethodByName(string) (Method, bool)
NumMethod() int
Name() string
PkgPath() string
Size() uintptr
String() string
Kind() Kind
Implements(u Type) bool
AssignableTo(u Type) bool
ConvertibleTo(u Type) bool
Comparable() bool
Bits() int
ChanDir() ChanDir
IsVariadic() bool
Elem() Type
Field(i int) StructField
FieldByIndex(index []int) StructField
FieldByName(name string) (StructField, bool)
FieldByNameFunc(match func(string) bool) (StructField, bool)
In(i int) Type
Key() Type
Len() int
NumField() int
NumIn() int
NumOut() int
Out(i int) Type
OverflowComplex(x complex128) bool
OverflowFloat(x float64) bool
OverflowInt(x int64) bool
OverflowUint(x uint64) bool
CanSeq() bool
CanSeq2() bool
common() *abi.Type
uncommon() *uncommonType
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="MapIter" data-name="MapIter">
               <h3>
                  MapIter
                  <span class="badge">struct</span>
                  <a href="#MapIter" class="anchor" title="Link to MapIter">#</a>
               </h3>
               
               <p>A MapIter is an iterator for ranging over a map.
See [Value.MapRange].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type MapIter struct {
m Value
hiter maps.Iter
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="MapIter" data-name="MapIter">
               <h3>
                  MapIter
                  <span class="badge">struct</span>
                  <a href="#MapIter" class="anchor" title="Link to MapIter">#</a>
               </h3>
               
               <p>A MapIter is an iterator for ranging over a map.
See [Value.MapRange].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type MapIter struct {
m Value
hiter hiter
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Method" data-name="Method">
               <h3>
                  Method
                  <span class="badge">struct</span>
                  <a href="#Method" class="anchor" title="Link to Method">#</a>
               </h3>
               
               <p>Method represents a single method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Method struct {
Name string
PkgPath string
Type Type
Func Value
Index int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="SelectCase" data-name="SelectCase">
               <h3>
                  SelectCase
                  <span class="badge">struct</span>
                  <a href="#SelectCase" class="anchor" title="Link to SelectCase">#</a>
               </h3>
               
               <p>A SelectCase describes a single case in a select operation.
The kind of case depends on Dir, the communication direction.
If Dir is SelectDefault, the case represents a default case.
Chan and Send must be zero Values.
If Dir is SelectSend, the case represents a send operation.
Normally Chan's underlying value must be a channel, and Send's underlying value must be
assignable to the channel's element type. As a special case, if Chan is a zero Value,
then the case is ignored, and the field Send will also be ignored and may be either zero
or non-zero.
If Dir is [SelectRecv], the case represents a receive operation.
Normally Chan's underlying value must be a channel and Send must be a zero Value.
If Chan is a zero Value, then the case is ignored, but Send must still be a zero Value.
When a receive operation is selected, the received Value is returned by Select.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type SelectCase struct {
Dir SelectDir
Chan Value
Send Value
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="SliceHeader" data-name="SliceHeader">
               <h3>
                  SliceHeader
                  <span class="badge">struct</span>
                  <a href="#SliceHeader" class="anchor" title="Link to SliceHeader">#</a>
               </h3>
               
               <p>SliceHeader is the runtime representation of a slice.
It cannot be used safely or portably and its representation may
change in a later release.
Moreover, the Data field is not sufficient to guarantee the data
it references will not be garbage collected, so programs must keep
a separate, correctly typed pointer to the underlying data.
Deprecated: Use unsafe.Slice or unsafe.SliceData instead.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type SliceHeader struct {
Data uintptr
Len int
Cap int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="StringHeader" data-name="StringHeader">
               <h3>
                  StringHeader
                  <span class="badge">struct</span>
                  <a href="#StringHeader" class="anchor" title="Link to StringHeader">#</a>
               </h3>
               
               <p>StringHeader is the runtime representation of a string.
It cannot be used safely or portably and its representation may
change in a later release.
Moreover, the Data field is not sufficient to guarantee the data
it references will not be garbage collected, so programs must keep
a separate, correctly typed pointer to the underlying data.
Deprecated: Use unsafe.String or unsafe.StringData instead.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type StringHeader struct {
Data uintptr
Len int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="StructField" data-name="StructField">
               <h3>
                  StructField
                  <span class="badge">struct</span>
                  <a href="#StructField" class="anchor" title="Link to StructField">#</a>
               </h3>
               
               <p>A StructField describes a single field in a struct.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type StructField struct {
Name string
PkgPath string
Type Type
Tag StructTag
Offset uintptr
Index []int
Anonymous bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value
                  <span class="badge">struct</span>
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <p>Value is the reflection interface to a Go value.
Not all methods apply to all kinds of values. Restrictions,
if any, are noted in the documentation for each method.
Use the Kind method to find out the kind of value before
calling kind-specific methods. Calling a method
inappropriate to the kind of type causes a run time panic.
The zero Value represents no value.
Its [Value.IsValid] method returns false, its Kind method returns [Invalid],
its String method returns "<invalid Value>", and all other methods panic.
Most functions and methods never return an invalid value.
If one does, its documentation states the conditions explicitly.
A Value can be used concurrently by multiple goroutines provided that
the underlying Go value can be used concurrently for the equivalent
direct operations.
To compare two Values, compare the results of the Interface method.
Using == on two Values does not compare the underlying values
they represent.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Value struct {
typ_ *abi.Type
ptr unsafe.Pointer
flag
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ValueError" data-name="ValueError">
               <h3>
                  ValueError
                  <span class="badge">struct</span>
                  <a href="#ValueError" class="anchor" title="Link to ValueError">#</a>
               </h3>
               
               <p>A ValueError occurs when a Value method is invoked on
a [Value] that does not support it. Such cases are documented
in the description of each method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ValueError struct {
Method string
Kind Kind
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="abiDesc" data-name="abiDesc">
               <h3>
                  abiDesc
                  <span class="badge">struct</span>
                  <a href="#abiDesc" class="anchor" title="Link to abiDesc">#</a>
               </h3>
               
               <p>abiDesc describes the ABI for a function or method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type abiDesc struct {
call abiSeq
ret abiSeq
stackCallArgsSize uintptr
retOffset uintptr
spill uintptr
stackPtrs *bitVector
inRegPtrs abi.IntArgRegBitmap
outRegPtrs abi.IntArgRegBitmap
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="abiSeq" data-name="abiSeq">
               <h3>
                  abiSeq
                  <span class="badge">struct</span>
                  <a href="#abiSeq" class="anchor" title="Link to abiSeq">#</a>
               </h3>
               
               <p>abiSeq represents a sequence of ABI instructions for copying
from a series of reflect.Values to a call frame (for call arguments)
or vice-versa (for call results).
An abiSeq should be populated by calling its addArg method.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type abiSeq struct {
steps []abiStep
valueStart []int
stackBytes uintptr
iregs int
fregs int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="abiStep" data-name="abiStep">
               <h3>
                  abiStep
                  <span class="badge">struct</span>
                  <a href="#abiStep" class="anchor" title="Link to abiStep">#</a>
               </h3>
               
               <p>abiStep represents an ABI "instruction." Each instruction
describes one part of how to translate between a Go value
in memory and a call frame.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type abiStep struct {
kind abiStepKind
offset uintptr
size uintptr
stkOff uintptr
ireg int
freg int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="bitVector" data-name="bitVector">
               <h3>
                  bitVector
                  <span class="badge">struct</span>
                  <a href="#bitVector" class="anchor" title="Link to bitVector">#</a>
               </h3>
               
               <p>Note: this type must agree with runtime.bitvector.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type bitVector struct {
n uint32
data []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cacheKey" data-name="cacheKey">
               <h3>
                  cacheKey
                  <span class="badge">struct</span>
                  <a href="#cacheKey" class="anchor" title="Link to cacheKey">#</a>
               </h3>
               
               <p>A cacheKey is the key for use in the lookupCache.
Four values describe any of the types we are looking for:
type kind, one or two subtypes, and an extra integer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cacheKey struct {
kind Kind
t1 *abi.Type
t2 *abi.Type
extra uintptr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="common" data-name="common">
               <h3>
                  common
                  <span class="badge">struct</span>
                  <a href="#common" class="anchor" title="Link to common">#</a>
               </h3>
               
               <p>Embed this type to get common/uncommon</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type common struct {
abi.Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fieldScan" data-name="fieldScan">
               <h3>
                  fieldScan
                  <span class="badge">struct</span>
                  <a href="#fieldScan" class="anchor" title="Link to fieldScan">#</a>
               </h3>
               
               <p>A fieldScan represents an item on the fieldByNameFunc scan work list.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fieldScan struct {
typ *structType
index []int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="hiter" data-name="hiter">
               <h3>
                  hiter
                  <span class="badge">struct</span>
                  <a href="#hiter" class="anchor" title="Link to hiter">#</a>
               </h3>
               
               <p>hiter's structure matches runtime.hiter's structure.
Having a clone here allows us to embed a map iterator
inside type MapIter so that MapIters can be re-used
without doing any allocations.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type hiter struct {
key unsafe.Pointer
elem unsafe.Pointer
t unsafe.Pointer
h unsafe.Pointer
buckets unsafe.Pointer
bptr unsafe.Pointer
overflow *[]unsafe.Pointer
oldoverflow *[]unsafe.Pointer
startBucket uintptr
offset uint8
wrapped bool
B uint8
i uint8
bucket uintptr
checkBucket uintptr
clearSeq uint64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="interfaceType" data-name="interfaceType">
               <h3>
                  interfaceType
                  <span class="badge">struct</span>
                  <a href="#interfaceType" class="anchor" title="Link to interfaceType">#</a>
               </h3>
               
               <p>interfaceType represents an interface type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type interfaceType struct {
abi.InterfaceType
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="layoutKey" data-name="layoutKey">
               <h3>
                  layoutKey
                  <span class="badge">struct</span>
                  <a href="#layoutKey" class="anchor" title="Link to layoutKey">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type layoutKey struct {
ftyp *funcType
rcvr *abi.Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="layoutType" data-name="layoutType">
               <h3>
                  layoutType
                  <span class="badge">struct</span>
                  <a href="#layoutType" class="anchor" title="Link to layoutType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type layoutType struct {
t *abi.Type
framePool *sync.Pool
abid abiDesc
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="makeFuncCtxt" data-name="makeFuncCtxt">
               <h3>
                  makeFuncCtxt
                  <span class="badge">struct</span>
                  <a href="#makeFuncCtxt" class="anchor" title="Link to makeFuncCtxt">#</a>
               </h3>
               
               <p>This structure must be kept in sync with runtime.reflectMethodValue.
Any changes should be reflected in all both.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type makeFuncCtxt struct {
fn uintptr
stack *bitVector
argLen uintptr
regPtrs abi.IntArgRegBitmap
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="makeFuncImpl" data-name="makeFuncImpl">
               <h3>
                  makeFuncImpl
                  <span class="badge">struct</span>
                  <a href="#makeFuncImpl" class="anchor" title="Link to makeFuncImpl">#</a>
               </h3>
               
               <p>makeFuncImpl is the closure value implementing the function
returned by MakeFunc.
The first three words of this type must be kept in sync with
methodValue and runtime.reflectMethodValue.
Any changes should be reflected in all three.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type makeFuncImpl struct {
makeFuncCtxt
ftyp *funcType
fn func([]Value) []Value
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mapType" data-name="mapType">
               <h3>
                  mapType
                  <span class="badge">struct</span>
                  <a href="#mapType" class="anchor" title="Link to mapType">#</a>
               </h3>
               
               <p>mapType represents a map type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type mapType struct {
abi.OldMapType
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="methodValue" data-name="methodValue">
               <h3>
                  methodValue
                  <span class="badge">struct</span>
                  <a href="#methodValue" class="anchor" title="Link to methodValue">#</a>
               </h3>
               
               <p>The first 3 words of this type must be kept in sync with
makeFuncImpl and runtime.reflectMethodValue.
Any changes should be reflected in all three.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type methodValue struct {
makeFuncCtxt
method int
rcvr Value
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="nonEmptyInterface" data-name="nonEmptyInterface">
               <h3>
                  nonEmptyInterface
                  <span class="badge">struct</span>
                  <a href="#nonEmptyInterface" class="anchor" title="Link to nonEmptyInterface">#</a>
               </h3>
               
               <p>nonEmptyInterface is the header for an interface value with methods.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type nonEmptyInterface struct {
itab *abi.ITab
word unsafe.Pointer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ptrType" data-name="ptrType">
               <h3>
                  ptrType
                  <span class="badge">struct</span>
                  <a href="#ptrType" class="anchor" title="Link to ptrType">#</a>
               </h3>
               
               <p>ptrType represents a pointer type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ptrType struct {
abi.PtrType
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="rtype" data-name="rtype">
               <h3>
                  rtype
                  <span class="badge">struct</span>
                  <a href="#rtype" class="anchor" title="Link to rtype">#</a>
               </h3>
               
               <p>rtype is the common implementation of most values.
It is embedded in other struct types.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type rtype struct {
t abi.Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="runtimeSelect" data-name="runtimeSelect">
               <h3>
                  runtimeSelect
                  <span class="badge">struct</span>
                  <a href="#runtimeSelect" class="anchor" title="Link to runtimeSelect">#</a>
               </h3>
               
               <p>A runtimeSelect is a single case passed to rselect.
This must match ../runtime/select.go:/runtimeSelect</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type runtimeSelect struct {
dir SelectDir
typ *rtype
ch unsafe.Pointer
val unsafe.Pointer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sliceType" data-name="sliceType">
               <h3>
                  sliceType
                  <span class="badge">struct</span>
                  <a href="#sliceType" class="anchor" title="Link to sliceType">#</a>
               </h3>
               
               <p>sliceType represents a slice type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type sliceType struct {
abi.SliceType
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="structType" data-name="structType">
               <h3>
                  structType
                  <span class="badge">struct</span>
                  <a href="#structType" class="anchor" title="Link to structType">#</a>
               </h3>
               
               <p>structType represents a struct type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type structType struct {
abi.StructType
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="structTypeUncommon" data-name="structTypeUncommon">
               <h3>
                  structTypeUncommon
                  <span class="badge">struct</span>
                  <a href="#structTypeUncommon" class="anchor" title="Link to structTypeUncommon">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type structTypeUncommon struct {
structType
u uncommonType
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="visibleFieldsWalker" data-name="visibleFieldsWalker">
               <h3>
                  visibleFieldsWalker
                  <span class="badge">struct</span>
                  <a href="#visibleFieldsWalker" class="anchor" title="Link to visibleFieldsWalker">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type visibleFieldsWalker struct {
byName map[string]int
visiting map[Type]bool
fields []StructField
index []int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="visit" data-name="visit">
               <h3>
                  visit
                  <span class="badge">struct</span>
                  <a href="#visit" class="anchor" title="Link to visit">#</a>
               </h3>
               
               <p>During deepValueEqual, must keep track of checks that are
in progress. The comparison algorithm assumes that all
checks in progress are true when it reencounters them.
Visited comparisons are stored in a map indexed by visit.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type visit struct {
a1 unsafe.Pointer
a2 unsafe.Pointer
typ Type
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Addr" data-name="Addr">
               <h3>
                  Addr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Addr" class="anchor" title="Link to Addr">#</a>
               </h3>
               
               <p>Addr returns a pointer value representing the address of v.
It panics if [Value.CanAddr] returns false.
Addr is typically used to obtain a pointer to a struct field
or slice element in order to call a method that requires a
pointer receiver.</p>
               
               <pre><code class="language-go">func (v Value) Addr() Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Align" data-name="Align">
               <h3>
                  Align 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Align" class="anchor" title="Link to Align">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Align() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Append" data-name="Append">
               <h3>
                  Append 
                  <span class="badge">function</span>
                  
                  <a href="#Append" class="anchor" title="Link to Append">#</a>
               </h3>
               
               <p>Append appends the values x to a slice s and returns the resulting slice.
As in Go, each x's value must be assignable to the slice's element type.</p>
               
               <pre><code class="language-go">func Append(s Value, x ...Value) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendSlice" data-name="AppendSlice">
               <h3>
                  AppendSlice 
                  <span class="badge">function</span>
                  
                  <a href="#AppendSlice" class="anchor" title="Link to AppendSlice">#</a>
               </h3>
               
               <p>AppendSlice appends a slice t to a slice s and returns the resulting slice.
The slices s and t must have the same element type.</p>
               
               <pre><code class="language-go">func AppendSlice(s Value, t Value) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ArenaNew" data-name="ArenaNew">
               <h3>
                  ArenaNew 
                  <span class="badge">function</span>
                  
                  <a href="#ArenaNew" class="anchor" title="Link to ArenaNew">#</a>
               </h3>
               
               <p>ArenaNew returns a [Value] representing a pointer to a new zero value for the
specified type, allocating storage for it in the provided arena. That is,
the returned Value's Type is [PointerTo](typ).</p>
               
               <pre><code class="language-go">func ArenaNew(a *arena.Arena, typ Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ArrayOf" data-name="ArrayOf">
               <h3>
                  ArrayOf 
                  <span class="badge">function</span>
                  
                  <a href="#ArrayOf" class="anchor" title="Link to ArrayOf">#</a>
               </h3>
               
               <p>ArrayOf returns the array type with the given length and element type.
For example, if t represents int, ArrayOf(5, t) represents [5]int.
If the resulting type would be larger than the available address space,
ArrayOf panics.</p>
               
               <pre><code class="language-go">func ArrayOf(length int, elem Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AssignableTo" data-name="AssignableTo">
               <h3>
                  AssignableTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AssignableTo" class="anchor" title="Link to AssignableTo">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) AssignableTo(u Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bits" data-name="Bits">
               <h3>
                  Bits 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bits" class="anchor" title="Link to Bits">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Bits() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bool" data-name="Bool">
               <h3>
                  Bool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bool" class="anchor" title="Link to Bool">#</a>
               </h3>
               
               <p>Bool returns v's underlying value.
It panics if v's kind is not [Bool].</p>
               
               <pre><code class="language-go">func (v Value) Bool() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <p>Bytes returns v's underlying value.
It panics if v's underlying value is not a slice of bytes or
an addressable array of bytes.</p>
               
               <pre><code class="language-go">func (v Value) Bytes() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Call" data-name="Call">
               <h3>
                  Call 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Call" class="anchor" title="Link to Call">#</a>
               </h3>
               
               <p>Call calls the function v with the input arguments in.
For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]).
Call panics if v's Kind is not [Func].
It returns the output results as Values.
As in Go, each input argument must be assignable to the
type of the function's corresponding input parameter.
If v is a variadic function, Call creates the variadic slice parameter
itself, copying in the corresponding values.</p>
               
               <pre><code class="language-go">func (v Value) Call(in []Value) []Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CallSlice" data-name="CallSlice">
               <h3>
                  CallSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CallSlice" class="anchor" title="Link to CallSlice">#</a>
               </h3>
               
               <p>CallSlice calls the variadic function v with the input arguments in,
assigning the slice in[len(in)-1] to v's final variadic argument.
For example, if len(in) == 3, v.CallSlice(in) represents the Go call v(in[0], in[1], in[2]...).
CallSlice panics if v's Kind is not [Func] or if v is not variadic.
It returns the output results as Values.
As in Go, each input argument must be assignable to the
type of the function's corresponding input parameter.</p>
               
               <pre><code class="language-go">func (v Value) CallSlice(in []Value) []Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanAddr" data-name="CanAddr">
               <h3>
                  CanAddr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanAddr" class="anchor" title="Link to CanAddr">#</a>
               </h3>
               
               <p>CanAddr reports whether the value's address can be obtained with [Value.Addr].
Such values are called addressable. A value is addressable if it is
an element of a slice, an element of an addressable array,
a field of an addressable struct, or the result of dereferencing a pointer.
If CanAddr returns false, calling [Value.Addr] will panic.</p>
               
               <pre><code class="language-go">func (v Value) CanAddr() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanComplex" data-name="CanComplex">
               <h3>
                  CanComplex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanComplex" class="anchor" title="Link to CanComplex">#</a>
               </h3>
               
               <p>CanComplex reports whether [Value.Complex] can be used without panicking.</p>
               
               <pre><code class="language-go">func (v Value) CanComplex() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanConvert" data-name="CanConvert">
               <h3>
                  CanConvert 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanConvert" class="anchor" title="Link to CanConvert">#</a>
               </h3>
               
               <p>CanConvert reports whether the value v can be converted to type t.
If v.CanConvert(t) returns true then v.Convert(t) will not panic.</p>
               
               <pre><code class="language-go">func (v Value) CanConvert(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanFloat" data-name="CanFloat">
               <h3>
                  CanFloat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanFloat" class="anchor" title="Link to CanFloat">#</a>
               </h3>
               
               <p>CanFloat reports whether [Value.Float] can be used without panicking.</p>
               
               <pre><code class="language-go">func (v Value) CanFloat() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanInt" data-name="CanInt">
               <h3>
                  CanInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanInt" class="anchor" title="Link to CanInt">#</a>
               </h3>
               
               <p>CanInt reports whether Int can be used without panicking.</p>
               
               <pre><code class="language-go">func (v Value) CanInt() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanInterface" data-name="CanInterface">
               <h3>
                  CanInterface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanInterface" class="anchor" title="Link to CanInterface">#</a>
               </h3>
               
               <p>CanInterface reports whether [Value.Interface] can be used without panicking.</p>
               
               <pre><code class="language-go">func (v Value) CanInterface() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanSeq" data-name="CanSeq">
               <h3>
                  CanSeq 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanSeq" class="anchor" title="Link to CanSeq">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) CanSeq() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanSeq2" data-name="CanSeq2">
               <h3>
                  CanSeq2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanSeq2" class="anchor" title="Link to CanSeq2">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) CanSeq2() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanSet" data-name="CanSet">
               <h3>
                  CanSet 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanSet" class="anchor" title="Link to CanSet">#</a>
               </h3>
               
               <p>CanSet reports whether the value of v can be changed.
A [Value] can be changed only if it is addressable and was not
obtained by the use of unexported struct fields.
If CanSet returns false, calling [Value.Set] or any type-specific
setter (e.g., [Value.SetBool], [Value.SetInt]) will panic.</p>
               
               <pre><code class="language-go">func (v Value) CanSet() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanUint" data-name="CanUint">
               <h3>
                  CanUint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CanUint" class="anchor" title="Link to CanUint">#</a>
               </h3>
               
               <p>CanUint reports whether [Value.Uint] can be used without panicking.</p>
               
               <pre><code class="language-go">func (v Value) CanUint() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cap" data-name="Cap">
               <h3>
                  Cap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cap" class="anchor" title="Link to Cap">#</a>
               </h3>
               
               <p>Cap returns v's capacity.
It panics if v's Kind is not [Array], [Chan], [Slice] or pointer to [Array].</p>
               
               <pre><code class="language-go">func (v Value) Cap() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ChanDir" data-name="ChanDir">
               <h3>
                  ChanDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ChanDir" class="anchor" title="Link to ChanDir">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) ChanDir() ChanDir</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ChanOf" data-name="ChanOf">
               <h3>
                  ChanOf 
                  <span class="badge">function</span>
                  
                  <a href="#ChanOf" class="anchor" title="Link to ChanOf">#</a>
               </h3>
               
               <p>ChanOf returns the channel type with the given direction and element type.
For example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.
The gc runtime imposes a limit of 64 kB on channel element types.
If t's size is equal to or exceeds this limit, ChanOf panics.</p>
               
               <pre><code class="language-go">func ChanOf(dir ChanDir, t Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clear" data-name="Clear">
               <h3>
                  Clear 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Clear" class="anchor" title="Link to Clear">#</a>
               </h3>
               
               <p>Clear clears the contents of a map or zeros the contents of a slice.
It panics if v's Kind is not [Map] or [Slice].</p>
               
               <pre><code class="language-go">func (v Value) Clear()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the channel v.
It panics if v's Kind is not [Chan] or
v is a receive-only channel.</p>
               
               <pre><code class="language-go">func (v Value) Close()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Comparable" data-name="Comparable">
               <h3>
                  Comparable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Comparable" class="anchor" title="Link to Comparable">#</a>
               </h3>
               
               <p>Comparable reports whether the value v is comparable.
If the type of v is an interface, this checks the dynamic type.
If this reports true then v.Interface() == x will not panic for any x,
nor will v.Equal(u) for any Value u.</p>
               
               <pre><code class="language-go">func (v Value) Comparable() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Comparable" data-name="Comparable">
               <h3>
                  Comparable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Comparable" class="anchor" title="Link to Comparable">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Comparable() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Complex" data-name="Complex">
               <h3>
                  Complex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Complex" class="anchor" title="Link to Complex">#</a>
               </h3>
               
               <p>Complex returns v's underlying value, as a complex128.
It panics if v's Kind is not [Complex64] or [Complex128]</p>
               
               <pre><code class="language-go">func (v Value) Complex() complex128</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Convert" data-name="Convert">
               <h3>
                  Convert 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Convert" class="anchor" title="Link to Convert">#</a>
               </h3>
               
               <p>Convert returns the value v converted to type t.
If the usual Go conversion rules do not allow conversion
of the value v to type t, or if converting v to type t panics, Convert panics.</p>
               
               <pre><code class="language-go">func (v Value) Convert(t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ConvertibleTo" data-name="ConvertibleTo">
               <h3>
                  ConvertibleTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ConvertibleTo" class="anchor" title="Link to ConvertibleTo">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) ConvertibleTo(u Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Copy" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge">function</span>
                  
                  <a href="#Copy" class="anchor" title="Link to Copy">#</a>
               </h3>
               
               <p>Copy copies the contents of src into dst until either
dst has been filled or src has been exhausted.
It returns the number of elements copied.
Dst and src each must have kind [Slice] or [Array], and
dst and src must have the same element type.
It dst is an [Array], it panics if [Value.CanSet] returns false.
As a special case, src can have kind [String] if the element type of dst is kind [Uint8].</p>
               
               <pre><code class="language-go">func Copy(dst Value, src Value) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DeepEqual" data-name="DeepEqual">
               <h3>
                  DeepEqual 
                  <span class="badge">function</span>
                  
                  <a href="#DeepEqual" class="anchor" title="Link to DeepEqual">#</a>
               </h3>
               
               <p>DeepEqual reports whether x and y are “deeply equal,” defined as follows.
Two values of identical type are deeply equal if one of the following cases applies.
Values of distinct types are never deeply equal.
Array values are deeply equal when their corresponding elements are deeply equal.
Struct values are deeply equal if their corresponding fields,
both exported and unexported, are deeply equal.
Func values are deeply equal if both are nil; otherwise they are not deeply equal.
Interface values are deeply equal if they hold deeply equal concrete values.
Map values are deeply equal when all of the following are true:
they are both nil or both non-nil, they have the same length,
and either they are the same map object or their corresponding keys
(matched using Go equality) map to deeply equal values.
Pointer values are deeply equal if they are equal using Go's == operator
or if they point to deeply equal values.
Slice values are deeply equal when all of the following are true:
they are both nil or both non-nil, they have the same length,
and either they point to the same initial entry of the same underlying array
(that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal.
Note that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))
are not deeply equal.
Other values - numbers, bools, strings, and channels - are deeply equal
if they are equal using Go's == operator.
In general DeepEqual is a recursive relaxation of Go's == operator.
However, this idea is impossible to implement without some inconsistency.
Specifically, it is possible for a value to be unequal to itself,
either because it is of func type (uncomparable in general)
or because it is a floating-point NaN value (not equal to itself in floating-point comparison),
or because it is an array, struct, or interface containing
such a value.
On the other hand, pointer values are always equal to themselves,
even if they point at or contain such problematic values,
because they compare equal using Go's == operator, and that
is a sufficient condition to be deeply equal, regardless of content.
DeepEqual has been defined so that the same short-cut applies
to slices and maps: if x and y are the same slice or the same map,
they are deeply equal regardless of content.
As DeepEqual traverses the data values it may find a cycle. The
second and subsequent times that DeepEqual compares two pointer
values that have been compared before, it treats the values as
equal rather than examining the values to which they point.
This ensures that DeepEqual terminates.</p>
               
               <pre><code class="language-go">func DeepEqual(x any, y any) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Elem" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Elem" class="anchor" title="Link to Elem">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Elem() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Elem" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Elem" class="anchor" title="Link to Elem">#</a>
               </h3>
               
               <p>Elem returns the value that the interface v contains
or that the pointer v points to.
It panics if v's Kind is not [Interface] or [Pointer].
It returns the zero Value if v is nil.</p>
               
               <pre><code class="language-go">func (v Value) Elem() Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Equal" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Equal" class="anchor" title="Link to Equal">#</a>
               </h3>
               
               <p>Equal reports true if v is equal to u.
For two invalid values, Equal will report true.
For an interface value, Equal will compare the value within the interface.
Otherwise, If the values have different types, Equal will report false.
Otherwise, for arrays and structs Equal will compare each element in order,
and report false if it finds non-equal elements.
During all comparisons, if values of the same type are compared,
and the type is not comparable, Equal will panic.</p>
               
               <pre><code class="language-go">func (v Value) Equal(u Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *ValueError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Field" data-name="Field">
               <h3>
                  Field 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Field" class="anchor" title="Link to Field">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Field(i int) StructField</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Field" data-name="Field">
               <h3>
                  Field 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Field" class="anchor" title="Link to Field">#</a>
               </h3>
               
               <p>Field returns the i'th field of the struct v.
It panics if v's Kind is not [Struct] or i is out of range.</p>
               
               <pre><code class="language-go">func (v Value) Field(i int) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Field" data-name="Field">
               <h3>
                  Field 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Field" class="anchor" title="Link to Field">#</a>
               </h3>
               
               <p>Field returns the i'th struct field.</p>
               
               <pre><code class="language-go">func (t *structType) Field(i int) (f StructField)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldAlign" data-name="FieldAlign">
               <h3>
                  FieldAlign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldAlign" class="anchor" title="Link to FieldAlign">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) FieldAlign() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldByIndex" data-name="FieldByIndex">
               <h3>
                  FieldByIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldByIndex" class="anchor" title="Link to FieldByIndex">#</a>
               </h3>
               
               <p>FieldByIndex returns the nested field corresponding to index.</p>
               
               <pre><code class="language-go">func (t *structType) FieldByIndex(index []int) (f StructField)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldByIndex" data-name="FieldByIndex">
               <h3>
                  FieldByIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldByIndex" class="anchor" title="Link to FieldByIndex">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) FieldByIndex(index []int) StructField</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldByIndex" data-name="FieldByIndex">
               <h3>
                  FieldByIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldByIndex" class="anchor" title="Link to FieldByIndex">#</a>
               </h3>
               
               <p>FieldByIndex returns the nested field corresponding to index.
It panics if evaluation requires stepping through a nil
pointer or a field that is not a struct.</p>
               
               <pre><code class="language-go">func (v Value) FieldByIndex(index []int) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldByIndexErr" data-name="FieldByIndexErr">
               <h3>
                  FieldByIndexErr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldByIndexErr" class="anchor" title="Link to FieldByIndexErr">#</a>
               </h3>
               
               <p>FieldByIndexErr returns the nested field corresponding to index.
It returns an error if evaluation requires stepping through a nil
pointer, but panics if it must step through a field that
is not a struct.</p>
               
               <pre><code class="language-go">func (v Value) FieldByIndexErr(index []int) (Value, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldByName" data-name="FieldByName">
               <h3>
                  FieldByName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldByName" class="anchor" title="Link to FieldByName">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) FieldByName(name string) (StructField, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldByName" data-name="FieldByName">
               <h3>
                  FieldByName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldByName" class="anchor" title="Link to FieldByName">#</a>
               </h3>
               
               <p>FieldByName returns the struct field with the given name
and a boolean to indicate if the field was found.</p>
               
               <pre><code class="language-go">func (t *structType) FieldByName(name string) (f StructField, present bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldByName" data-name="FieldByName">
               <h3>
                  FieldByName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldByName" class="anchor" title="Link to FieldByName">#</a>
               </h3>
               
               <p>FieldByName returns the struct field with the given name.
It returns the zero Value if no field was found.
It panics if v's Kind is not [Struct].</p>
               
               <pre><code class="language-go">func (v Value) FieldByName(name string) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldByNameFunc" data-name="FieldByNameFunc">
               <h3>
                  FieldByNameFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldByNameFunc" class="anchor" title="Link to FieldByNameFunc">#</a>
               </h3>
               
               <p>FieldByNameFunc returns the struct field with a name
that satisfies the match function.
It panics if v's Kind is not [Struct].
It returns the zero Value if no field was found.</p>
               
               <pre><code class="language-go">func (v Value) FieldByNameFunc(match func(string) bool) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldByNameFunc" data-name="FieldByNameFunc">
               <h3>
                  FieldByNameFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldByNameFunc" class="anchor" title="Link to FieldByNameFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) FieldByNameFunc(match func(string) bool) (StructField, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldByNameFunc" data-name="FieldByNameFunc">
               <h3>
                  FieldByNameFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldByNameFunc" class="anchor" title="Link to FieldByNameFunc">#</a>
               </h3>
               
               <p>FieldByNameFunc returns the struct field with a name that satisfies the
match function and a boolean to indicate if the field was found.</p>
               
               <pre><code class="language-go">func (t *structType) FieldByNameFunc(match func(string) bool) (result StructField, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Float" data-name="Float">
               <h3>
                  Float 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Float" class="anchor" title="Link to Float">#</a>
               </h3>
               
               <p>Float returns v's underlying value, as a float64.
It panics if v's Kind is not [Float32] or [Float64]</p>
               
               <pre><code class="language-go">func (v Value) Float() float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FuncOf" data-name="FuncOf">
               <h3>
                  FuncOf 
                  <span class="badge">function</span>
                  
                  <a href="#FuncOf" class="anchor" title="Link to FuncOf">#</a>
               </h3>
               
               <p>FuncOf returns the function type with the given argument and result types.
For example if k represents int and e represents string,
FuncOf([]Type{k}, []Type{e}, false) represents func(int) string.
The variadic argument controls whether the function is variadic. FuncOf
panics if the in[len(in)-1] does not represent a slice and variadic is
true.</p>
               
               <pre><code class="language-go">func FuncOf(in []Type, out []Type, variadic bool) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <p>Get returns the value associated with key in the tag string.
If there is no such key in the tag, Get returns the empty string.
If the tag does not have the conventional format, the value
returned by Get is unspecified. To determine whether a tag is
explicitly set to the empty string, use [StructTag.Lookup].</p>
               
               <pre><code class="language-go">func (tag StructTag) Get(key string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Grow" data-name="Grow">
               <h3>
                  Grow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Grow" class="anchor" title="Link to Grow">#</a>
               </h3>
               
               <p>Grow increases the slice's capacity, if necessary, to guarantee space for
another n elements. After Grow(n), at least n elements can be appended
to the slice without another allocation.
It panics if v's Kind is not a [Slice], or if n is negative or too large to
allocate the memory, or if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) Grow(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Implements" data-name="Implements">
               <h3>
                  Implements 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Implements" class="anchor" title="Link to Implements">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Implements(u Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="In" data-name="In">
               <h3>
                  In 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#In" class="anchor" title="Link to In">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) In(i int) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Index" data-name="Index">
               <h3>
                  Index 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Index" class="anchor" title="Link to Index">#</a>
               </h3>
               
               <p>Index returns v's i'th element.
It panics if v's Kind is not [Array], [Slice], or [String] or i is out of range.</p>
               
               <pre><code class="language-go">func (v Value) Index(i int) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Indirect" data-name="Indirect">
               <h3>
                  Indirect 
                  <span class="badge">function</span>
                  
                  <a href="#Indirect" class="anchor" title="Link to Indirect">#</a>
               </h3>
               
               <p>Indirect returns the value that v points to.
If v is a nil pointer, Indirect returns a zero Value.
If v is not a pointer, Indirect returns v.</p>
               
               <pre><code class="language-go">func Indirect(v Value) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Int" data-name="Int">
               <h3>
                  Int 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Int" class="anchor" title="Link to Int">#</a>
               </h3>
               
               <p>Int returns v's underlying value, as an int64.
It panics if v's Kind is not [Int], [Int8], [Int16], [Int32], or [Int64].</p>
               
               <pre><code class="language-go">func (v Value) Int() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Interface" data-name="Interface">
               <h3>
                  Interface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Interface" class="anchor" title="Link to Interface">#</a>
               </h3>
               
               <p>Interface returns v's current value as an interface{}.
It is equivalent to:
var i interface{} = (v's underlying value)
It panics if the Value was obtained by accessing
unexported struct fields.</p>
               
               <pre><code class="language-go">func (v Value) Interface() (i any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InterfaceData" data-name="InterfaceData">
               <h3>
                  InterfaceData 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InterfaceData" class="anchor" title="Link to InterfaceData">#</a>
               </h3>
               
               <p>InterfaceData returns a pair of unspecified uintptr values.
It panics if v's Kind is not Interface.
In earlier versions of Go, this function returned the interface's
value as a uintptr pair. As of Go 1.4, the implementation of
interface values precludes any defined use of InterfaceData.
Deprecated: The memory representation of interface values is not
compatible with InterfaceData.</p>
               
               <pre><code class="language-go">func (v Value) InterfaceData() [2]uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsExported" data-name="IsExported">
               <h3>
                  IsExported 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsExported" class="anchor" title="Link to IsExported">#</a>
               </h3>
               
               <p>IsExported reports whether the field is exported.</p>
               
               <pre><code class="language-go">func (f StructField) IsExported() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsExported" data-name="IsExported">
               <h3>
                  IsExported 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsExported" class="anchor" title="Link to IsExported">#</a>
               </h3>
               
               <p>IsExported reports whether the method is exported.</p>
               
               <pre><code class="language-go">func (m Method) IsExported() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsNil" data-name="IsNil">
               <h3>
                  IsNil 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsNil" class="anchor" title="Link to IsNil">#</a>
               </h3>
               
               <p>IsNil reports whether its argument v is nil. The argument must be
a chan, func, interface, map, pointer, or slice value; if it is
not, IsNil panics. Note that IsNil is not always equivalent to a
regular comparison with nil in Go. For example, if v was created
by calling [ValueOf] with an uninitialized interface variable i,
i==nil will be true but v.IsNil will panic as v will be the zero
Value.</p>
               
               <pre><code class="language-go">func (v Value) IsNil() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsValid" data-name="IsValid">
               <h3>
                  IsValid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsValid" class="anchor" title="Link to IsValid">#</a>
               </h3>
               
               <p>IsValid reports whether v represents a value.
It returns false if v is the zero Value.
If [Value.IsValid] returns false, all other methods except String panic.
Most functions and methods never return an invalid Value.
If one does, its documentation states the conditions explicitly.</p>
               
               <pre><code class="language-go">func (v Value) IsValid() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsVariadic" data-name="IsVariadic">
               <h3>
                  IsVariadic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsVariadic" class="anchor" title="Link to IsVariadic">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) IsVariadic() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsZero" data-name="IsZero">
               <h3>
                  IsZero 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsZero" class="anchor" title="Link to IsZero">#</a>
               </h3>
               
               <p>IsZero reports whether v is the zero value for its type.
It panics if the argument is invalid.</p>
               
               <pre><code class="language-go">func (v Value) IsZero() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Key" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Key" class="anchor" title="Link to Key">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Key() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Key" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Key" class="anchor" title="Link to Key">#</a>
               </h3>
               
               <p>Key returns the key of iter's current map entry.</p>
               
               <pre><code class="language-go">func (iter *MapIter) Key() Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Key" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Key" class="anchor" title="Link to Key">#</a>
               </h3>
               
               <p>Key returns the key of iter's current map entry.</p>
               
               <pre><code class="language-go">func (iter *MapIter) Key() Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Key" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Key" class="anchor" title="Link to Key">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Key() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Kind" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Kind" class="anchor" title="Link to Kind">#</a>
               </h3>
               
               <p>Kind returns v's Kind.
If v is the zero Value ([Value.IsValid] returns false), Kind returns Invalid.</p>
               
               <pre><code class="language-go">func (v Value) Kind() Kind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Kind" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Kind" class="anchor" title="Link to Kind">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Kind() Kind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Len returns v's length.
It panics if v's Kind is not [Array], [Chan], [Map], [Slice], [String], or pointer to [Array].</p>
               
               <pre><code class="language-go">func (v Value) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lookup" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lookup" class="anchor" title="Link to Lookup">#</a>
               </h3>
               
               <p>Lookup returns the value associated with key in the tag string.
If the key is present in the tag the value (which may be empty)
is returned. Otherwise the returned value will be the empty string.
The ok return value reports whether the value was explicitly set in
the tag string. If the tag does not have the conventional format,
the value returned by Lookup is unspecified.</p>
               
               <pre><code class="language-go">func (tag StructTag) Lookup(key string) (value string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeChan" data-name="MakeChan">
               <h3>
                  MakeChan 
                  <span class="badge">function</span>
                  
                  <a href="#MakeChan" class="anchor" title="Link to MakeChan">#</a>
               </h3>
               
               <p>MakeChan creates a new channel with the specified type and buffer size.</p>
               
               <pre><code class="language-go">func MakeChan(typ Type, buffer int) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeFunc" data-name="MakeFunc">
               <h3>
                  MakeFunc 
                  <span class="badge">function</span>
                  
                  <a href="#MakeFunc" class="anchor" title="Link to MakeFunc">#</a>
               </h3>
               
               <p>MakeFunc returns a new function of the given [Type]
that wraps the function fn. When called, that new function
does the following:
- converts its arguments to a slice of Values.
- runs results := fn(args).
- returns the results as a slice of Values, one per formal result.
The implementation fn can assume that the argument [Value] slice
has the number and type of arguments given by typ.
If typ describes a variadic function, the final Value is itself
a slice representing the variadic arguments, as in the
body of a variadic function. The result Value slice returned by fn
must have the number and type of results given by typ.
The [Value.Call] method allows the caller to invoke a typed function
in terms of Values; in contrast, MakeFunc allows the caller to implement
a typed function in terms of Values.
The Examples section of the documentation includes an illustration
of how to use MakeFunc to build a swap function for different types.</p>
               
               <pre><code class="language-go">func MakeFunc(typ Type, fn func(args []Value) results []Value) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeMap" data-name="MakeMap">
               <h3>
                  MakeMap 
                  <span class="badge">function</span>
                  
                  <a href="#MakeMap" class="anchor" title="Link to MakeMap">#</a>
               </h3>
               
               <p>MakeMap creates a new map with the specified type.</p>
               
               <pre><code class="language-go">func MakeMap(typ Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeMapWithSize" data-name="MakeMapWithSize">
               <h3>
                  MakeMapWithSize 
                  <span class="badge">function</span>
                  
                  <a href="#MakeMapWithSize" class="anchor" title="Link to MakeMapWithSize">#</a>
               </h3>
               
               <p>MakeMapWithSize creates a new map with the specified type
and initial space for approximately n elements.</p>
               
               <pre><code class="language-go">func MakeMapWithSize(typ Type, n int) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MakeSlice" data-name="MakeSlice">
               <h3>
                  MakeSlice 
                  <span class="badge">function</span>
                  
                  <a href="#MakeSlice" class="anchor" title="Link to MakeSlice">#</a>
               </h3>
               
               <p>MakeSlice creates a new zero-initialized slice value
for the specified slice type, length, and capacity.</p>
               
               <pre><code class="language-go">func MakeSlice(typ Type, len int, cap int) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MapIndex" data-name="MapIndex">
               <h3>
                  MapIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MapIndex" class="anchor" title="Link to MapIndex">#</a>
               </h3>
               
               <p>MapIndex returns the value associated with key in the map v.
It panics if v's Kind is not [Map].
It returns the zero Value if key is not found in the map or if v represents a nil map.
As in Go, the key's value must be assignable to the map's key type.</p>
               
               <pre><code class="language-go">func (v Value) MapIndex(key Value) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MapIndex" data-name="MapIndex">
               <h3>
                  MapIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MapIndex" class="anchor" title="Link to MapIndex">#</a>
               </h3>
               
               <p>MapIndex returns the value associated with key in the map v.
It panics if v's Kind is not [Map].
It returns the zero Value if key is not found in the map or if v represents a nil map.
As in Go, the key's value must be assignable to the map's key type.</p>
               
               <pre><code class="language-go">func (v Value) MapIndex(key Value) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MapKeys" data-name="MapKeys">
               <h3>
                  MapKeys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MapKeys" class="anchor" title="Link to MapKeys">#</a>
               </h3>
               
               <p>MapKeys returns a slice containing all the keys present in the map,
in unspecified order.
It panics if v's Kind is not [Map].
It returns an empty slice if v represents a nil map.</p>
               
               <pre><code class="language-go">func (v Value) MapKeys() []Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MapKeys" data-name="MapKeys">
               <h3>
                  MapKeys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MapKeys" class="anchor" title="Link to MapKeys">#</a>
               </h3>
               
               <p>MapKeys returns a slice containing all the keys present in the map,
in unspecified order.
It panics if v's Kind is not [Map].
It returns an empty slice if v represents a nil map.</p>
               
               <pre><code class="language-go">func (v Value) MapKeys() []Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MapOf" data-name="MapOf">
               <h3>
                  MapOf 
                  <span class="badge">function</span>
                  
                  <a href="#MapOf" class="anchor" title="Link to MapOf">#</a>
               </h3>
               
               <p>MapOf returns the map type with the given key and element types.
For example, if k represents int and e represents string,
MapOf(k, e) represents map[int]string.
If the key type is not a valid map key type (that is, if it does
not implement Go's == operator), MapOf panics.</p>
               
               <pre><code class="language-go">func MapOf(key Type, elem Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MapOf" data-name="MapOf">
               <h3>
                  MapOf 
                  <span class="badge">function</span>
                  
                  <a href="#MapOf" class="anchor" title="Link to MapOf">#</a>
               </h3>
               
               <p>MapOf returns the map type with the given key and element types.
For example, if k represents int and e represents string,
MapOf(k, e) represents map[int]string.
If the key type is not a valid map key type (that is, if it does
not implement Go's == operator), MapOf panics.</p>
               
               <pre><code class="language-go">func MapOf(key Type, elem Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MapRange" data-name="MapRange">
               <h3>
                  MapRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MapRange" class="anchor" title="Link to MapRange">#</a>
               </h3>
               
               <p>MapRange returns a range iterator for a map.
It panics if v's Kind is not [Map].
Call [MapIter.Next] to advance the iterator, and [MapIter.Key]/[MapIter.Value] to access each entry.
[MapIter.Next] returns false when the iterator is exhausted.
MapRange follows the same iteration semantics as a range statement.
Example:
iter := reflect.ValueOf(m).MapRange()
for iter.Next() {
k := iter.Key()
v := iter.Value()
...
}</p>
               
               <pre><code class="language-go">func (v Value) MapRange() *MapIter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MapRange" data-name="MapRange">
               <h3>
                  MapRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MapRange" class="anchor" title="Link to MapRange">#</a>
               </h3>
               
               <p>MapRange returns a range iterator for a map.
It panics if v's Kind is not [Map].
Call [MapIter.Next] to advance the iterator, and [MapIter.Key]/[MapIter.Value] to access each entry.
[MapIter.Next] returns false when the iterator is exhausted.
MapRange follows the same iteration semantics as a range statement.
Example:
iter := reflect.ValueOf(m).MapRange()
for iter.Next() {
k := iter.Key()
v := iter.Value()
...
}</p>
               
               <pre><code class="language-go">func (v Value) MapRange() *MapIter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Method" data-name="Method">
               <h3>
                  Method 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Method" class="anchor" title="Link to Method">#</a>
               </h3>
               
               <p>Method returns the i'th method in the type's method set.</p>
               
               <pre><code class="language-go">func (t *interfaceType) Method(i int) (m Method)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Method" data-name="Method">
               <h3>
                  Method 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Method" class="anchor" title="Link to Method">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Method(i int) (m Method)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Method" data-name="Method">
               <h3>
                  Method 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Method" class="anchor" title="Link to Method">#</a>
               </h3>
               
               <p>Method returns a function value corresponding to v's i'th method.
The arguments to a Call on the returned function should not include
a receiver; the returned function will always use v as the receiver.
Method panics if i is out of range or if v is a nil interface value.</p>
               
               <pre><code class="language-go">func (v Value) Method(i int) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MethodByName" data-name="MethodByName">
               <h3>
                  MethodByName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MethodByName" class="anchor" title="Link to MethodByName">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) MethodByName(name string) (m Method, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MethodByName" data-name="MethodByName">
               <h3>
                  MethodByName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MethodByName" class="anchor" title="Link to MethodByName">#</a>
               </h3>
               
               <p>MethodByName method with the given name in the type's method set.</p>
               
               <pre><code class="language-go">func (t *interfaceType) MethodByName(name string) (m Method, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MethodByName" data-name="MethodByName">
               <h3>
                  MethodByName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MethodByName" class="anchor" title="Link to MethodByName">#</a>
               </h3>
               
               <p>MethodByName returns a function value corresponding to the method
of v with the given name.
The arguments to a Call on the returned function should not include
a receiver; the returned function will always use v as the receiver.
It returns the zero Value if no method was found.</p>
               
               <pre><code class="language-go">func (v Value) MethodByName(name string) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="New" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
                  <a href="#New" class="anchor" title="Link to New">#</a>
               </h3>
               
               <p>New returns a Value representing a pointer to a new zero value
for the specified type. That is, the returned Value's Type is [PointerTo](typ).</p>
               
               <pre><code class="language-go">func New(typ Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewAt" data-name="NewAt">
               <h3>
                  NewAt 
                  <span class="badge">function</span>
                  
                  <a href="#NewAt" class="anchor" title="Link to NewAt">#</a>
               </h3>
               
               <p>NewAt returns a Value representing a pointer to a value of the
specified type, using p as that pointer.</p>
               
               <pre><code class="language-go">func NewAt(typ Type, p unsafe.Pointer) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <p>Next advances the map iterator and reports whether there is another
entry. It returns false when iter is exhausted; subsequent
calls to [MapIter.Key], [MapIter.Value], or [MapIter.Next] will panic.</p>
               
               <pre><code class="language-go">func (iter *MapIter) Next() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Next" data-name="Next">
               <h3>
                  Next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Next" class="anchor" title="Link to Next">#</a>
               </h3>
               
               <p>Next advances the map iterator and reports whether there is another
entry. It returns false when iter is exhausted; subsequent
calls to [MapIter.Key], [MapIter.Value], or [MapIter.Next] will panic.</p>
               
               <pre><code class="language-go">func (iter *MapIter) Next() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumField" data-name="NumField">
               <h3>
                  NumField 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumField" class="anchor" title="Link to NumField">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) NumField() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumField" data-name="NumField">
               <h3>
                  NumField 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumField" class="anchor" title="Link to NumField">#</a>
               </h3>
               
               <p>NumField returns the number of fields in the struct v.
It panics if v's Kind is not [Struct].</p>
               
               <pre><code class="language-go">func (v Value) NumField() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumIn" data-name="NumIn">
               <h3>
                  NumIn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumIn" class="anchor" title="Link to NumIn">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) NumIn() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumMethod" data-name="NumMethod">
               <h3>
                  NumMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumMethod" class="anchor" title="Link to NumMethod">#</a>
               </h3>
               
               <p>NumMethod returns the number of methods in the value's method set.
For a non-interface type, it returns the number of exported methods.
For an interface type, it returns the number of exported and unexported methods.</p>
               
               <pre><code class="language-go">func (v Value) NumMethod() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumMethod" data-name="NumMethod">
               <h3>
                  NumMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumMethod" class="anchor" title="Link to NumMethod">#</a>
               </h3>
               
               <p>NumMethod returns the number of interface methods in the type's method set.</p>
               
               <pre><code class="language-go">func (t *interfaceType) NumMethod() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumMethod" data-name="NumMethod">
               <h3>
                  NumMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumMethod" class="anchor" title="Link to NumMethod">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) NumMethod() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumOut" data-name="NumOut">
               <h3>
                  NumOut 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumOut" class="anchor" title="Link to NumOut">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) NumOut() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Out" data-name="Out">
               <h3>
                  Out 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Out" class="anchor" title="Link to Out">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Out(i int) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OverflowComplex" data-name="OverflowComplex">
               <h3>
                  OverflowComplex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OverflowComplex" class="anchor" title="Link to OverflowComplex">#</a>
               </h3>
               
               <p>OverflowComplex reports whether the complex128 x cannot be represented by v's type.
It panics if v's Kind is not [Complex64] or [Complex128].</p>
               
               <pre><code class="language-go">func (v Value) OverflowComplex(x complex128) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OverflowComplex" data-name="OverflowComplex">
               <h3>
                  OverflowComplex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OverflowComplex" class="anchor" title="Link to OverflowComplex">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) OverflowComplex(x complex128) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OverflowFloat" data-name="OverflowFloat">
               <h3>
                  OverflowFloat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OverflowFloat" class="anchor" title="Link to OverflowFloat">#</a>
               </h3>
               
               <p>OverflowFloat reports whether the float64 x cannot be represented by v's type.
It panics if v's Kind is not [Float32] or [Float64].</p>
               
               <pre><code class="language-go">func (v Value) OverflowFloat(x float64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OverflowFloat" data-name="OverflowFloat">
               <h3>
                  OverflowFloat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OverflowFloat" class="anchor" title="Link to OverflowFloat">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) OverflowFloat(x float64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OverflowInt" data-name="OverflowInt">
               <h3>
                  OverflowInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OverflowInt" class="anchor" title="Link to OverflowInt">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) OverflowInt(x int64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OverflowInt" data-name="OverflowInt">
               <h3>
                  OverflowInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OverflowInt" class="anchor" title="Link to OverflowInt">#</a>
               </h3>
               
               <p>OverflowInt reports whether the int64 x cannot be represented by v's type.
It panics if v's Kind is not [Int], [Int8], [Int16], [Int32], or [Int64].</p>
               
               <pre><code class="language-go">func (v Value) OverflowInt(x int64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OverflowUint" data-name="OverflowUint">
               <h3>
                  OverflowUint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OverflowUint" class="anchor" title="Link to OverflowUint">#</a>
               </h3>
               
               <p>OverflowUint reports whether the uint64 x cannot be represented by v's type.
It panics if v's Kind is not [Uint], [Uintptr], [Uint8], [Uint16], [Uint32], or [Uint64].</p>
               
               <pre><code class="language-go">func (v Value) OverflowUint(x uint64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OverflowUint" data-name="OverflowUint">
               <h3>
                  OverflowUint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OverflowUint" class="anchor" title="Link to OverflowUint">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) OverflowUint(x uint64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PkgPath" data-name="PkgPath">
               <h3>
                  PkgPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PkgPath" class="anchor" title="Link to PkgPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) PkgPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pointer" data-name="Pointer">
               <h3>
                  Pointer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pointer" class="anchor" title="Link to Pointer">#</a>
               </h3>
               
               <p>Pointer returns v's value as a uintptr.
It panics if v's Kind is not [Chan], [Func], [Map], [Pointer], [Slice], [String], or [UnsafePointer].
If v's Kind is [Func], the returned pointer is an underlying
code pointer, but not necessarily enough to identify a
single function uniquely. The only guarantee is that the
result is zero if and only if v is a nil func Value.
If v's Kind is [Slice], the returned pointer is to the first
element of the slice. If the slice is nil the returned value
is 0.  If the slice is empty but non-nil the return value is non-zero.
If v's Kind is [String], the returned pointer is to the first
element of the underlying bytes of string.
It's preferred to use uintptr(Value.UnsafePointer()) to get the equivalent result.</p>
               
               <pre><code class="language-go">func (v Value) Pointer() uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PointerTo" data-name="PointerTo">
               <h3>
                  PointerTo 
                  <span class="badge">function</span>
                  
                  <a href="#PointerTo" class="anchor" title="Link to PointerTo">#</a>
               </h3>
               
               <p>PointerTo returns the pointer type with element t.
For example, if t represents type Foo, PointerTo(t) represents *Foo.</p>
               
               <pre><code class="language-go">func PointerTo(t Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PtrTo" data-name="PtrTo">
               <h3>
                  PtrTo 
                  <span class="badge">function</span>
                  
                  <a href="#PtrTo" class="anchor" title="Link to PtrTo">#</a>
               </h3>
               
               <p>PtrTo returns the pointer type with element t.
For example, if t represents type Foo, PtrTo(t) represents *Foo.
PtrTo is the old spelling of [PointerTo].
The two functions behave identically.
Deprecated: Superseded by [PointerTo].</p>
               
               <pre><code class="language-go">func PtrTo(t Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Recv" data-name="Recv">
               <h3>
                  Recv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Recv" class="anchor" title="Link to Recv">#</a>
               </h3>
               
               <p>Recv receives and returns a value from the channel v.
It panics if v's Kind is not [Chan].
The receive blocks until a value is ready.
The boolean value ok is true if the value x corresponds to a send
on the channel, false if it is a zero value received because the channel is closed.</p>
               
               <pre><code class="language-go">func (v Value) Recv() (x Value, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset modifies iter to iterate over v.
It panics if v's Kind is not [Map] and v is not the zero Value.
Reset(Value{}) causes iter to not to refer to any map,
which may allow the previously iterated-over map to be garbage collected.</p>
               
               <pre><code class="language-go">func (iter *MapIter) Reset(v Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset modifies iter to iterate over v.
It panics if v's Kind is not [Map] and v is not the zero Value.
Reset(Value{}) causes iter to not to refer to any map,
which may allow the previously iterated-over map to be garbage collected.</p>
               
               <pre><code class="language-go">func (iter *MapIter) Reset(v Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Select" data-name="Select">
               <h3>
                  Select 
                  <span class="badge">function</span>
                  
                  <a href="#Select" class="anchor" title="Link to Select">#</a>
               </h3>
               
               <p>Select executes a select operation described by the list of cases.
Like the Go select statement, it blocks until at least one of the cases
can proceed, makes a uniform pseudo-random choice,
and then executes that case. It returns the index of the chosen case
and, if that case was a receive operation, the value received and a
boolean indicating whether the value corresponds to a send on the channel
(as opposed to a zero value received because the channel is closed).
Select supports a maximum of 65536 cases.</p>
               
               <pre><code class="language-go">func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Send" data-name="Send">
               <h3>
                  Send 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Send" class="anchor" title="Link to Send">#</a>
               </h3>
               
               <p>Send sends x on the channel v.
It panics if v's kind is not [Chan] or if x's type is not the same type as v's element type.
As in Go, x's value must be assignable to the channel's element type.</p>
               
               <pre><code class="language-go">func (v Value) Send(x Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Seq" data-name="Seq">
               <h3>
                  Seq 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Seq" class="anchor" title="Link to Seq">#</a>
               </h3>
               
               <p>Seq returns an iter.Seq[Value] that loops over the elements of v.
If v's kind is Func, it must be a function that has no results and
that takes a single argument of type func(T) bool for some type T.
If v's kind is Pointer, the pointer element type must have kind Array.
Otherwise v's kind must be Int, Int8, Int16, Int32, Int64,
Uint, Uint8, Uint16, Uint32, Uint64, Uintptr,
Array, Chan, Map, Slice, or String.</p>
               
               <pre><code class="language-go">func (v Value) Seq() *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Seq2" data-name="Seq2">
               <h3>
                  Seq2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Seq2" class="anchor" title="Link to Seq2">#</a>
               </h3>
               
               <p>Seq2 returns an iter.Seq2[Value, Value] that loops over the elements of v.
If v's kind is Func, it must be a function that has no results and
that takes a single argument of type func(K, V) bool for some type K, V.
If v's kind is Pointer, the pointer element type must have kind Array.
Otherwise v's kind must be Array, Map, Slice, or String.</p>
               
               <pre><code class="language-go">func (v Value) Seq2() *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set assigns x to the value v.
It panics if [Value.CanSet] returns false.
As in Go, x's value must be assignable to v's type and
must not be derived from an unexported field.</p>
               
               <pre><code class="language-go">func (v Value) Set(x Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBool" data-name="SetBool">
               <h3>
                  SetBool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBool" class="anchor" title="Link to SetBool">#</a>
               </h3>
               
               <p>SetBool sets v's underlying value.
It panics if v's Kind is not [Bool] or if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetBool(x bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBytes" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBytes" class="anchor" title="Link to SetBytes">#</a>
               </h3>
               
               <p>SetBytes sets v's underlying value.
It panics if v's underlying value is not a slice of bytes
or if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetBytes(x []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetCap" data-name="SetCap">
               <h3>
                  SetCap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetCap" class="anchor" title="Link to SetCap">#</a>
               </h3>
               
               <p>SetCap sets v's capacity to n.
It panics if v's Kind is not [Slice], or if n is smaller than the length or
greater than the capacity of the slice,
or if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetCap(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetComplex" data-name="SetComplex">
               <h3>
                  SetComplex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetComplex" class="anchor" title="Link to SetComplex">#</a>
               </h3>
               
               <p>SetComplex sets v's underlying value to x.
It panics if v's Kind is not [Complex64] or [Complex128],
or if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetComplex(x complex128)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetFloat" data-name="SetFloat">
               <h3>
                  SetFloat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetFloat" class="anchor" title="Link to SetFloat">#</a>
               </h3>
               
               <p>SetFloat sets v's underlying value to x.
It panics if v's Kind is not [Float32] or [Float64],
or if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetFloat(x float64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetInt" data-name="SetInt">
               <h3>
                  SetInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetInt" class="anchor" title="Link to SetInt">#</a>
               </h3>
               
               <p>SetInt sets v's underlying value to x.
It panics if v's Kind is not [Int], [Int8], [Int16], [Int32], or [Int64],
or if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetInt(x int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetIterKey" data-name="SetIterKey">
               <h3>
                  SetIterKey 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetIterKey" class="anchor" title="Link to SetIterKey">#</a>
               </h3>
               
               <p>SetIterKey assigns to v the key of iter's current map entry.
It is equivalent to v.Set(iter.Key()), but it avoids allocating a new Value.
As in Go, the key must be assignable to v's type and
must not be derived from an unexported field.
It panics if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetIterKey(iter *MapIter)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetIterKey" data-name="SetIterKey">
               <h3>
                  SetIterKey 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetIterKey" class="anchor" title="Link to SetIterKey">#</a>
               </h3>
               
               <p>SetIterKey assigns to v the key of iter's current map entry.
It is equivalent to v.Set(iter.Key()), but it avoids allocating a new Value.
As in Go, the key must be assignable to v's type and
must not be derived from an unexported field.
It panics if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetIterKey(iter *MapIter)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetIterValue" data-name="SetIterValue">
               <h3>
                  SetIterValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetIterValue" class="anchor" title="Link to SetIterValue">#</a>
               </h3>
               
               <p>SetIterValue assigns to v the value of iter's current map entry.
It is equivalent to v.Set(iter.Value()), but it avoids allocating a new Value.
As in Go, the value must be assignable to v's type and
must not be derived from an unexported field.
It panics if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetIterValue(iter *MapIter)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetIterValue" data-name="SetIterValue">
               <h3>
                  SetIterValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetIterValue" class="anchor" title="Link to SetIterValue">#</a>
               </h3>
               
               <p>SetIterValue assigns to v the value of iter's current map entry.
It is equivalent to v.Set(iter.Value()), but it avoids allocating a new Value.
As in Go, the value must be assignable to v's type and
must not be derived from an unexported field.
It panics if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetIterValue(iter *MapIter)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetLen" data-name="SetLen">
               <h3>
                  SetLen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetLen" class="anchor" title="Link to SetLen">#</a>
               </h3>
               
               <p>SetLen sets v's length to n.
It panics if v's Kind is not [Slice], or if n is negative or
greater than the capacity of the slice,
or if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetLen(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetMapIndex" data-name="SetMapIndex">
               <h3>
                  SetMapIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetMapIndex" class="anchor" title="Link to SetMapIndex">#</a>
               </h3>
               
               <p>SetMapIndex sets the element associated with key in the map v to elem.
It panics if v's Kind is not [Map].
If elem is the zero Value, SetMapIndex deletes the key from the map.
Otherwise if v holds a nil map, SetMapIndex will panic.
As in Go, key's elem must be assignable to the map's key type,
and elem's value must be assignable to the map's elem type.</p>
               
               <pre><code class="language-go">func (v Value) SetMapIndex(key Value, elem Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetMapIndex" data-name="SetMapIndex">
               <h3>
                  SetMapIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetMapIndex" class="anchor" title="Link to SetMapIndex">#</a>
               </h3>
               
               <p>SetMapIndex sets the element associated with key in the map v to elem.
It panics if v's Kind is not [Map].
If elem is the zero Value, SetMapIndex deletes the key from the map.
Otherwise if v holds a nil map, SetMapIndex will panic.
As in Go, key's elem must be assignable to the map's key type,
and elem's value must be assignable to the map's elem type.</p>
               
               <pre><code class="language-go">func (v Value) SetMapIndex(key Value, elem Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetPointer" data-name="SetPointer">
               <h3>
                  SetPointer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetPointer" class="anchor" title="Link to SetPointer">#</a>
               </h3>
               
               <p>SetPointer sets the [unsafe.Pointer] value v to x.
It panics if v's Kind is not [UnsafePointer]
or if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetPointer(x unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetString" data-name="SetString">
               <h3>
                  SetString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetString" class="anchor" title="Link to SetString">#</a>
               </h3>
               
               <p>SetString sets v's underlying value to x.
It panics if v's Kind is not [String] or if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetString(x string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetUint" data-name="SetUint">
               <h3>
                  SetUint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetUint" class="anchor" title="Link to SetUint">#</a>
               </h3>
               
               <p>SetUint sets v's underlying value to x.
It panics if v's Kind is not [Uint], [Uintptr], [Uint8], [Uint16], [Uint32], or [Uint64],
or if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetUint(x uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetZero" data-name="SetZero">
               <h3>
                  SetZero 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetZero" class="anchor" title="Link to SetZero">#</a>
               </h3>
               
               <p>SetZero sets v to be the zero value of v's type.
It panics if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) SetZero()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) Size() uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Slice" data-name="Slice">
               <h3>
                  Slice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Slice" class="anchor" title="Link to Slice">#</a>
               </h3>
               
               <p>Slice returns v[i:j].
It panics if v's Kind is not [Array], [Slice] or [String], or if v is an unaddressable array,
or if the indexes are out of bounds.</p>
               
               <pre><code class="language-go">func (v Value) Slice(i int, j int) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Slice3" data-name="Slice3">
               <h3>
                  Slice3 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Slice3" class="anchor" title="Link to Slice3">#</a>
               </h3>
               
               <p>Slice3 is the 3-index form of the slice operation: it returns v[i:j:k].
It panics if v's Kind is not [Array] or [Slice], or if v is an unaddressable array,
or if the indexes are out of bounds.</p>
               
               <pre><code class="language-go">func (v Value) Slice3(i int, j int, k int) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SliceAt" data-name="SliceAt">
               <h3>
                  SliceAt 
                  <span class="badge">function</span>
                  
                  <a href="#SliceAt" class="anchor" title="Link to SliceAt">#</a>
               </h3>
               
               <p>SliceAt returns a [Value] representing a slice whose underlying
data starts at p, with length and capacity equal to n.
This is like [unsafe.Slice].</p>
               
               <pre><code class="language-go">func SliceAt(typ Type, p unsafe.Pointer, n int) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SliceOf" data-name="SliceOf">
               <h3>
                  SliceOf 
                  <span class="badge">function</span>
                  
                  <a href="#SliceOf" class="anchor" title="Link to SliceOf">#</a>
               </h3>
               
               <p>SliceOf returns the slice type with element type t.
For example, if t represents int, SliceOf(t) represents []int.</p>
               
               <pre><code class="language-go">func SliceOf(t Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (d ChanDir) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the string v's underlying value, as a string.
String is a special case because of Go's String method convention.
Unlike the other getters, it does not panic if v's Kind is not [String].
Instead, it returns a string of the form "<T value>" where T is v's type.
The fmt package treats Values specially. It does not call their String
method implicitly but instead prints the concrete values they hold.</p>
               
               <pre><code class="language-go">func (v Value) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the name of k.</p>
               
               <pre><code class="language-go">func (k Kind) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StructOf" data-name="StructOf">
               <h3>
                  StructOf 
                  <span class="badge">function</span>
                  
                  <a href="#StructOf" class="anchor" title="Link to StructOf">#</a>
               </h3>
               
               <p>StructOf returns the struct type containing fields.
The Offset and Index fields are ignored and computed as they would be
by the compiler.
StructOf currently does not support promoted methods of embedded fields
and panics if passed unexported StructFields.</p>
               
               <pre><code class="language-go">func StructOf(fields []StructField) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swapper" data-name="Swapper">
               <h3>
                  Swapper 
                  <span class="badge">function</span>
                  
                  <a href="#Swapper" class="anchor" title="Link to Swapper">#</a>
               </h3>
               
               <p>Swapper returns a function that swaps the elements in the provided
slice.
Swapper panics if the provided interface is not a slice.</p>
               
               <pre><code class="language-go">func Swapper(slice any) (func(i int, j int))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TryRecv" data-name="TryRecv">
               <h3>
                  TryRecv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TryRecv" class="anchor" title="Link to TryRecv">#</a>
               </h3>
               
               <p>TryRecv attempts to receive a value from the channel v but will not block.
It panics if v's Kind is not [Chan].
If the receive delivers a value, x is the transferred value and ok is true.
If the receive cannot finish without blocking, x is the zero Value and ok is false.
If the channel is closed, x is the zero value for the channel's element type and ok is false.</p>
               
               <pre><code class="language-go">func (v Value) TryRecv() (x Value, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TrySend" data-name="TrySend">
               <h3>
                  TrySend 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#TrySend" class="anchor" title="Link to TrySend">#</a>
               </h3>
               
               <p>TrySend attempts to send x on the channel v but will not block.
It panics if v's Kind is not [Chan].
It reports whether the value was sent.
As in Go, x's value must be assignable to the channel's element type.</p>
               
               <pre><code class="language-go">func (v Value) TrySend(x Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>Type returns v's type.</p>
               
               <pre><code class="language-go">func (v Value) Type() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeFor" data-name="TypeFor">
               <h3>
                  TypeFor 
                  <span class="badge">function</span>
                  
                  <a href="#TypeFor" class="anchor" title="Link to TypeFor">#</a>
               </h3>
               
               <p>TypeFor returns the [Type] that represents the type argument T.</p>
               
               <pre><code class="language-go">func TypeFor() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeOf" data-name="TypeOf">
               <h3>
                  TypeOf 
                  <span class="badge">function</span>
                  
                  <a href="#TypeOf" class="anchor" title="Link to TypeOf">#</a>
               </h3>
               
               <p>TypeOf returns the reflection [Type] that represents the dynamic type of i.
If i is a nil interface value, TypeOf returns nil.</p>
               
               <pre><code class="language-go">func TypeOf(i any) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Uint" data-name="Uint">
               <h3>
                  Uint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Uint" class="anchor" title="Link to Uint">#</a>
               </h3>
               
               <p>Uint returns v's underlying value, as a uint64.
It panics if v's Kind is not [Uint], [Uintptr], [Uint8], [Uint16], [Uint32], or [Uint64].</p>
               
               <pre><code class="language-go">func (v Value) Uint() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnsafeAddr" data-name="UnsafeAddr">
               <h3>
                  UnsafeAddr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnsafeAddr" class="anchor" title="Link to UnsafeAddr">#</a>
               </h3>
               
               <p>UnsafeAddr returns a pointer to v's data, as a uintptr.
It panics if v is not addressable.
It's preferred to use uintptr(Value.Addr().UnsafePointer()) to get the equivalent result.</p>
               
               <pre><code class="language-go">func (v Value) UnsafeAddr() uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UnsafePointer" data-name="UnsafePointer">
               <h3>
                  UnsafePointer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UnsafePointer" class="anchor" title="Link to UnsafePointer">#</a>
               </h3>
               
               <p>UnsafePointer returns v's value as a [unsafe.Pointer].
It panics if v's Kind is not [Chan], [Func], [Map], [Pointer], [Slice], [String] or [UnsafePointer].
If v's Kind is [Func], the returned pointer is an underlying
code pointer, but not necessarily enough to identify a
single function uniquely. The only guarantee is that the
result is zero if and only if v is a nil func Value.
If v's Kind is [Slice], the returned pointer is to the first
element of the slice. If the slice is nil the returned value
is nil.  If the slice is empty but non-nil the return value is non-nil.
If v's Kind is [String], the returned pointer is to the first
element of the underlying bytes of string.</p>
               
               <pre><code class="language-go">func (v Value) UnsafePointer() unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <p>Value returns the value of iter's current map entry.</p>
               
               <pre><code class="language-go">func (iter *MapIter) Value() Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Value" data-name="Value">
               <h3>
                  Value 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Value" class="anchor" title="Link to Value">#</a>
               </h3>
               
               <p>Value returns the value of iter's current map entry.</p>
               
               <pre><code class="language-go">func (iter *MapIter) Value() Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ValueOf" data-name="ValueOf">
               <h3>
                  ValueOf 
                  <span class="badge">function</span>
                  
                  <a href="#ValueOf" class="anchor" title="Link to ValueOf">#</a>
               </h3>
               
               <p>ValueOf returns a new Value initialized to the concrete value
stored in the interface i. ValueOf(nil) returns the zero Value.</p>
               
               <pre><code class="language-go">func ValueOf(i any) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="VisibleFields" data-name="VisibleFields">
               <h3>
                  VisibleFields 
                  <span class="badge">function</span>
                  
                  <a href="#VisibleFields" class="anchor" title="Link to VisibleFields">#</a>
               </h3>
               
               <p>VisibleFields returns all the visible fields in t, which must be a
struct type. A field is defined as visible if it's accessible
directly with a FieldByName call. The returned fields include fields
inside anonymous struct members and unexported fields. They follow
the same order found in the struct, with anonymous fields followed
immediately by their promoted fields.
For each element e of the returned slice, the corresponding field
can be retrieved from a value v of type t by calling v.FieldByIndex(e.Index).</p>
               
               <pre><code class="language-go">func VisibleFields(t Type) []StructField</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Zero" data-name="Zero">
               <h3>
                  Zero 
                  <span class="badge">function</span>
                  
                  <a href="#Zero" class="anchor" title="Link to Zero">#</a>
               </h3>
               
               <p>Zero returns a Value representing the zero value for the specified type.
The result is different from the zero value of the Value struct,
which represents no value at all.
For example, Zero(TypeOf(42)) returns a Value with Kind [Int] and value 0.
The returned value is neither addressable nor settable.</p>
               
               <pre><code class="language-go">func Zero(typ Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abiType" data-name="abiType">
               <h3>
                  abiType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#abiType" class="anchor" title="Link to abiType">#</a>
               </h3>
               
               <pre><code class="language-go">func (v Value) abiType() *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abiTypeSlow" data-name="abiTypeSlow">
               <h3>
                  abiTypeSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#abiTypeSlow" class="anchor" title="Link to abiTypeSlow">#</a>
               </h3>
               
               <pre><code class="language-go">func (v Value) abiTypeSlow() *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge">function</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add returns p+x.
The whySafe string is ignored, so that the function still inlines
as efficiently as p+x, but all call sites should use the string to
record why the addition is safe, which is to say why the addition
does not cause x to advance to the very end of p's allocation
and therefore point incorrectly at the next block in memory.
add should be an internal detail (and is trivially copyable),
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/pinpoint-apm/pinpoint-go-agent
- github.com/vmware/govmomi
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname add</p>
               
               <pre><code class="language-go">func add(p unsafe.Pointer, x uintptr, whySafe string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addArg" data-name="addArg">
               <h3>
                  addArg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addArg" class="anchor" title="Link to addArg">#</a>
               </h3>
               
               <p>addArg extends the abiSeq with a new Go value of type t.
If the value was stack-assigned, returns the single
abiStep describing that translation, and nil otherwise.</p>
               
               <pre><code class="language-go">func (a *abiSeq) addArg(t *abi.Type) *abiStep</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addRcvr" data-name="addRcvr">
               <h3>
                  addRcvr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addRcvr" class="anchor" title="Link to addRcvr">#</a>
               </h3>
               
               <p>addRcvr extends the abiSeq with a new method call
receiver according to the interface calling convention.
If the receiver was stack-assigned, returns the single
abiStep describing that translation, and nil otherwise.
Returns true if the receiver is a pointer.</p>
               
               <pre><code class="language-go">func (a *abiSeq) addRcvr(rcvr *abi.Type) (*abiStep, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addReflectOff" data-name="addReflectOff">
               <h3>
                  addReflectOff 
                  <span class="badge">function</span>
                  
                  <a href="#addReflectOff" class="anchor" title="Link to addReflectOff">#</a>
               </h3>
               
               <p>addReflectOff adds a pointer to the reflection lookup map in the runtime.
It returns a new ID that can be used as a typeOff or textOff, and will
be resolved correctly. Implemented in the runtime package.
addReflectOff should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/goplus/reflectx
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname addReflectOff
go:noescape</p>
               
               <pre><code class="language-go">func addReflectOff(ptr unsafe.Pointer) int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addTypeBits" data-name="addTypeBits">
               <h3>
                  addTypeBits 
                  <span class="badge">function</span>
                  
                  <a href="#addTypeBits" class="anchor" title="Link to addTypeBits">#</a>
               </h3>
               
               <pre><code class="language-go">func addTypeBits(bv *bitVector, offset uintptr, t *abi.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="align" data-name="align">
               <h3>
                  align 
                  <span class="badge">function</span>
                  
                  <a href="#align" class="anchor" title="Link to align">#</a>
               </h3>
               
               <p>align returns the result of rounding x up to a multiple of n.
n must be a power of two.</p>
               
               <pre><code class="language-go">func align(x uintptr, n uintptr) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="append" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#append" class="anchor" title="Link to append">#</a>
               </h3>
               
               <p>append a bit to the bitmap.</p>
               
               <pre><code class="language-go">func (bv *bitVector) append(bit uint8)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendVarint" data-name="appendVarint">
               <h3>
                  appendVarint 
                  <span class="badge">function</span>
                  
                  <a href="#appendVarint" class="anchor" title="Link to appendVarint">#</a>
               </h3>
               
               <pre><code class="language-go">func appendVarint(x []byte, v uintptr) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="archFloat32FromReg" data-name="archFloat32FromReg">
               <h3>
                  archFloat32FromReg 
                  <span class="badge">function</span>
                  
                  <a href="#archFloat32FromReg" class="anchor" title="Link to archFloat32FromReg">#</a>
               </h3>
               
               <pre><code class="language-go">func archFloat32FromReg(reg uint64) float32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="archFloat32FromReg" data-name="archFloat32FromReg">
               <h3>
                  archFloat32FromReg 
                  <span class="badge">function</span>
                  
                  <a href="#archFloat32FromReg" class="anchor" title="Link to archFloat32FromReg">#</a>
               </h3>
               
               <pre><code class="language-go">func archFloat32FromReg(reg uint64) float32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="archFloat32FromReg" data-name="archFloat32FromReg">
               <h3>
                  archFloat32FromReg 
                  <span class="badge">function</span>
                  
                  <a href="#archFloat32FromReg" class="anchor" title="Link to archFloat32FromReg">#</a>
               </h3>
               
               <pre><code class="language-go">func archFloat32FromReg(reg uint64) float32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="archFloat32ToReg" data-name="archFloat32ToReg">
               <h3>
                  archFloat32ToReg 
                  <span class="badge">function</span>
                  
                  <a href="#archFloat32ToReg" class="anchor" title="Link to archFloat32ToReg">#</a>
               </h3>
               
               <pre><code class="language-go">func archFloat32ToReg(val float32) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="archFloat32ToReg" data-name="archFloat32ToReg">
               <h3>
                  archFloat32ToReg 
                  <span class="badge">function</span>
                  
                  <a href="#archFloat32ToReg" class="anchor" title="Link to archFloat32ToReg">#</a>
               </h3>
               
               <pre><code class="language-go">func archFloat32ToReg(val float32) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="archFloat32ToReg" data-name="archFloat32ToReg">
               <h3>
                  archFloat32ToReg 
                  <span class="badge">function</span>
                  
                  <a href="#archFloat32ToReg" class="anchor" title="Link to archFloat32ToReg">#</a>
               </h3>
               
               <pre><code class="language-go">func archFloat32ToReg(val float32) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="arena_New" data-name="arena_New">
               <h3>
                  arena_New 
                  <span class="badge">function</span>
                  
                  <a href="#arena_New" class="anchor" title="Link to arena_New">#</a>
               </h3>
               
               <pre><code class="language-go">func arena_New(a *arena.Arena, typ any) any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="arrayAt" data-name="arrayAt">
               <h3>
                  arrayAt 
                  <span class="badge">function</span>
                  
                  <a href="#arrayAt" class="anchor" title="Link to arrayAt">#</a>
               </h3>
               
               <p>arrayAt returns the i-th element of p,
an array whose elements are eltSize bytes wide.
The array pointed at by p must have at least i+1 elements:
it is invalid (but impossible to check here) to pass i >= len,
because then the result will point outside the array.
whySafe must explain why i < len. (Passing "i < len" is fine;
the benefit is to surface this assumption at the call site.)</p>
               
               <pre><code class="language-go">func arrayAt(p unsafe.Pointer, i int, eltSize uintptr, whySafe string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignFloatN" data-name="assignFloatN">
               <h3>
                  assignFloatN 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignFloatN" class="anchor" title="Link to assignFloatN">#</a>
               </h3>
               
               <p>assignFloatN assigns n values to registers, each "size" bytes large,
from the data at [offset, offset+n*size) in memory. Each value at
[offset+i*size, offset+(i+1)*size) for i < n is assigned to the
next n floating-point registers.
Returns whether assignment succeeded.</p>
               
               <pre><code class="language-go">func (a *abiSeq) assignFloatN(offset uintptr, size uintptr, n int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignIntN" data-name="assignIntN">
               <h3>
                  assignIntN 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignIntN" class="anchor" title="Link to assignIntN">#</a>
               </h3>
               
               <p>assignIntN assigns n values to registers, each "size" bytes large,
from the data at [offset, offset+n*size) in memory. Each value at
[offset+i*size, offset+(i+1)*size) for i < n is assigned to the
next n integer registers.
Bit i in ptrMap indicates whether the i'th value is a pointer.
n must be <= 8.
Returns whether assignment succeeded.</p>
               
               <pre><code class="language-go">func (a *abiSeq) assignIntN(offset uintptr, size uintptr, n int, ptrMap uint8) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignTo" data-name="assignTo">
               <h3>
                  assignTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignTo" class="anchor" title="Link to assignTo">#</a>
               </h3>
               
               <p>assignTo returns a value v that can be assigned directly to dst.
It panics if v is not assignable to dst.
For a conversion to an interface type, target, if not nil,
is a suggested scratch space to use.
target must be initialized memory (or nil).</p>
               
               <pre><code class="language-go">func (v Value) assignTo(context string, dst *abi.Type, target unsafe.Pointer) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_Value_pointer" data-name="badlinkname_Value_pointer">
               <h3>
                  badlinkname_Value_pointer 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_Value_pointer" class="anchor" title="Link to badlinkname_Value_pointer">#</a>
               </h3>
               
               <p>go:linkname badlinkname_Value_pointer reflect.(*Value).pointer</p>
               
               <pre><code class="language-go">func badlinkname_Value_pointer(Value) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Align" data-name="badlinkname_rtype_Align">
               <h3>
                  badlinkname_rtype_Align 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Align" class="anchor" title="Link to badlinkname_rtype_Align">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Align reflect.(*rtype).Align</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Align(*rtype) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_AssignableTo" data-name="badlinkname_rtype_AssignableTo">
               <h3>
                  badlinkname_rtype_AssignableTo 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_AssignableTo" class="anchor" title="Link to badlinkname_rtype_AssignableTo">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_AssignableTo reflect.(*rtype).AssignableTo</p>
               
               <pre><code class="language-go">func badlinkname_rtype_AssignableTo(*rtype, Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Bits" data-name="badlinkname_rtype_Bits">
               <h3>
                  badlinkname_rtype_Bits 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Bits" class="anchor" title="Link to badlinkname_rtype_Bits">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Bits reflect.(*rtype).Bits</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Bits(*rtype) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_ChanDir" data-name="badlinkname_rtype_ChanDir">
               <h3>
                  badlinkname_rtype_ChanDir 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_ChanDir" class="anchor" title="Link to badlinkname_rtype_ChanDir">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_ChanDir reflect.(*rtype).ChanDir</p>
               
               <pre><code class="language-go">func badlinkname_rtype_ChanDir(*rtype) ChanDir</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Comparable" data-name="badlinkname_rtype_Comparable">
               <h3>
                  badlinkname_rtype_Comparable 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Comparable" class="anchor" title="Link to badlinkname_rtype_Comparable">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Comparable reflect.(*rtype).Comparable</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Comparable(*rtype) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_ConvertibleTo" data-name="badlinkname_rtype_ConvertibleTo">
               <h3>
                  badlinkname_rtype_ConvertibleTo 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_ConvertibleTo" class="anchor" title="Link to badlinkname_rtype_ConvertibleTo">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_ConvertibleTo reflect.(*rtype).ConvertibleTo</p>
               
               <pre><code class="language-go">func badlinkname_rtype_ConvertibleTo(*rtype, Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Elem" data-name="badlinkname_rtype_Elem">
               <h3>
                  badlinkname_rtype_Elem 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Elem" class="anchor" title="Link to badlinkname_rtype_Elem">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Elem reflect.(*rtype).Elem</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Elem(*rtype) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Field" data-name="badlinkname_rtype_Field">
               <h3>
                  badlinkname_rtype_Field 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Field" class="anchor" title="Link to badlinkname_rtype_Field">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Field reflect.(*rtype).Field</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Field(*rtype, int) StructField</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_FieldAlign" data-name="badlinkname_rtype_FieldAlign">
               <h3>
                  badlinkname_rtype_FieldAlign 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_FieldAlign" class="anchor" title="Link to badlinkname_rtype_FieldAlign">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_FieldAlign reflect.(*rtype).FieldAlign</p>
               
               <pre><code class="language-go">func badlinkname_rtype_FieldAlign(*rtype) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_FieldByIndex" data-name="badlinkname_rtype_FieldByIndex">
               <h3>
                  badlinkname_rtype_FieldByIndex 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_FieldByIndex" class="anchor" title="Link to badlinkname_rtype_FieldByIndex">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_FieldByIndex reflect.(*rtype).FieldByIndex</p>
               
               <pre><code class="language-go">func badlinkname_rtype_FieldByIndex(*rtype, []int) StructField</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_FieldByName" data-name="badlinkname_rtype_FieldByName">
               <h3>
                  badlinkname_rtype_FieldByName 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_FieldByName" class="anchor" title="Link to badlinkname_rtype_FieldByName">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_FieldByName reflect.(*rtype).FieldByName</p>
               
               <pre><code class="language-go">func badlinkname_rtype_FieldByName(*rtype, string) (StructField, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_FieldByNameFunc" data-name="badlinkname_rtype_FieldByNameFunc">
               <h3>
                  badlinkname_rtype_FieldByNameFunc 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_FieldByNameFunc" class="anchor" title="Link to badlinkname_rtype_FieldByNameFunc">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_FieldByNameFunc reflect.(*rtype).FieldByNameFunc</p>
               
               <pre><code class="language-go">func badlinkname_rtype_FieldByNameFunc(*rtype, func(string) bool) (StructField, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Implements" data-name="badlinkname_rtype_Implements">
               <h3>
                  badlinkname_rtype_Implements 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Implements" class="anchor" title="Link to badlinkname_rtype_Implements">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Implements reflect.(*rtype).Implements</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Implements(*rtype, Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_In" data-name="badlinkname_rtype_In">
               <h3>
                  badlinkname_rtype_In 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_In" class="anchor" title="Link to badlinkname_rtype_In">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_In reflect.(*rtype).In</p>
               
               <pre><code class="language-go">func badlinkname_rtype_In(*rtype, int) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_IsVariadic" data-name="badlinkname_rtype_IsVariadic">
               <h3>
                  badlinkname_rtype_IsVariadic 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_IsVariadic" class="anchor" title="Link to badlinkname_rtype_IsVariadic">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_IsVariadic reflect.(*rtype).IsVariadic</p>
               
               <pre><code class="language-go">func badlinkname_rtype_IsVariadic(*rtype) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Key" data-name="badlinkname_rtype_Key">
               <h3>
                  badlinkname_rtype_Key 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Key" class="anchor" title="Link to badlinkname_rtype_Key">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Key reflect.(*rtype).Key</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Key(*rtype) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Kind" data-name="badlinkname_rtype_Kind">
               <h3>
                  badlinkname_rtype_Kind 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Kind" class="anchor" title="Link to badlinkname_rtype_Kind">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Kind reflect.(*rtype).Kind</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Kind(*rtype) Kind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Len" data-name="badlinkname_rtype_Len">
               <h3>
                  badlinkname_rtype_Len 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Len" class="anchor" title="Link to badlinkname_rtype_Len">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Len reflect.(*rtype).Len</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Len(*rtype) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Method" data-name="badlinkname_rtype_Method">
               <h3>
                  badlinkname_rtype_Method 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Method" class="anchor" title="Link to badlinkname_rtype_Method">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Method reflect.(*rtype).Method</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Method(*rtype, int) Method</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_MethodByName" data-name="badlinkname_rtype_MethodByName">
               <h3>
                  badlinkname_rtype_MethodByName 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_MethodByName" class="anchor" title="Link to badlinkname_rtype_MethodByName">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_MethodByName reflect.(*rtype).MethodByName</p>
               
               <pre><code class="language-go">func badlinkname_rtype_MethodByName(*rtype, string) (Method, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Name" data-name="badlinkname_rtype_Name">
               <h3>
                  badlinkname_rtype_Name 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Name" class="anchor" title="Link to badlinkname_rtype_Name">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Name reflect.(*rtype).Name</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Name(*rtype) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_NumField" data-name="badlinkname_rtype_NumField">
               <h3>
                  badlinkname_rtype_NumField 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_NumField" class="anchor" title="Link to badlinkname_rtype_NumField">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_NumField reflect.(*rtype).NumField</p>
               
               <pre><code class="language-go">func badlinkname_rtype_NumField(*rtype) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_NumIn" data-name="badlinkname_rtype_NumIn">
               <h3>
                  badlinkname_rtype_NumIn 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_NumIn" class="anchor" title="Link to badlinkname_rtype_NumIn">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_NumIn reflect.(*rtype).NumIn</p>
               
               <pre><code class="language-go">func badlinkname_rtype_NumIn(*rtype) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_NumMethod" data-name="badlinkname_rtype_NumMethod">
               <h3>
                  badlinkname_rtype_NumMethod 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_NumMethod" class="anchor" title="Link to badlinkname_rtype_NumMethod">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_NumMethod reflect.(*rtype).NumMethod</p>
               
               <pre><code class="language-go">func badlinkname_rtype_NumMethod(*rtype) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_NumOut" data-name="badlinkname_rtype_NumOut">
               <h3>
                  badlinkname_rtype_NumOut 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_NumOut" class="anchor" title="Link to badlinkname_rtype_NumOut">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_NumOut reflect.(*rtype).NumOut</p>
               
               <pre><code class="language-go">func badlinkname_rtype_NumOut(*rtype) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Out" data-name="badlinkname_rtype_Out">
               <h3>
                  badlinkname_rtype_Out 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Out" class="anchor" title="Link to badlinkname_rtype_Out">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Out reflect.(*rtype).Out</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Out(*rtype, int) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_PkgPath" data-name="badlinkname_rtype_PkgPath">
               <h3>
                  badlinkname_rtype_PkgPath 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_PkgPath" class="anchor" title="Link to badlinkname_rtype_PkgPath">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_PkgPath reflect.(*rtype).PkgPath</p>
               
               <pre><code class="language-go">func badlinkname_rtype_PkgPath(*rtype) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_Size" data-name="badlinkname_rtype_Size">
               <h3>
                  badlinkname_rtype_Size 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_Size" class="anchor" title="Link to badlinkname_rtype_Size">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_Size reflect.(*rtype).Size</p>
               
               <pre><code class="language-go">func badlinkname_rtype_Size(*rtype) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_String" data-name="badlinkname_rtype_String">
               <h3>
                  badlinkname_rtype_String 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_String" class="anchor" title="Link to badlinkname_rtype_String">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_String reflect.(*rtype).String</p>
               
               <pre><code class="language-go">func badlinkname_rtype_String(*rtype) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="badlinkname_rtype_ptrTo" data-name="badlinkname_rtype_ptrTo">
               <h3>
                  badlinkname_rtype_ptrTo 
                  <span class="badge">function</span>
                  
                  <a href="#badlinkname_rtype_ptrTo" class="anchor" title="Link to badlinkname_rtype_ptrTo">#</a>
               </h3>
               
               <p>go:linkname badlinkname_rtype_ptrTo reflect.(*rtype).ptrTo</p>
               
               <pre><code class="language-go">func badlinkname_rtype_ptrTo(*rtype) *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bucketOf" data-name="bucketOf">
               <h3>
                  bucketOf 
                  <span class="badge">function</span>
                  
                  <a href="#bucketOf" class="anchor" title="Link to bucketOf">#</a>
               </h3>
               
               <pre><code class="language-go">func bucketOf(ktyp *abi.Type, etyp *abi.Type) *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesSlow" data-name="bytesSlow">
               <h3>
                  bytesSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytesSlow" class="anchor" title="Link to bytesSlow">#</a>
               </h3>
               
               <pre><code class="language-go">func (v Value) bytesSlow() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="call" data-name="call">
               <h3>
                  call 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#call" class="anchor" title="Link to call">#</a>
               </h3>
               
               <pre><code class="language-go">func (v Value) call(op string, in []Value) []Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="call" data-name="call">
               <h3>
                  call 
                  <span class="badge">function</span>
                  
                  <a href="#call" class="anchor" title="Link to call">#</a>
               </h3>
               
               <p>call calls fn with "stackArgsSize" bytes of stack arguments laid out
at stackArgs and register arguments laid out in regArgs. frameSize is
the total amount of stack space that will be reserved by call, so this
should include enough space to spill register arguments to the stack in
case of preemption.
After fn returns, call copies stackArgsSize-stackRetOffset result bytes
back into stackArgs+stackRetOffset before returning, for any return
values passed on the stack. Register-based return values will be found
in the same regArgs structure.
regArgs must also be prepared with an appropriate ReturnIsPtr bitmap
indicating which registers will contain pointer-valued return values. The
purpose of this bitmap is to keep pointers visible to the GC between
returning from reflectcall and actually using them.
If copying result bytes back from the stack, the caller must pass the
argument frame type as stackArgsType, so that call can execute appropriate
write barriers during the copy.
Arguments passed through to call do not escape. The type is used only in a
very limited callee of call, the stackArgs are copied, and regArgs is only
used in the call frame.
go:noescape
go:linkname call runtime.reflectcall</p>
               
               <pre><code class="language-go">func call(stackArgsType *abi.Type, f unsafe.Pointer, stackArgs unsafe.Pointer, stackArgsSize uint32, stackRetOffset uint32, frameSize uint32, regArgs *abi.RegArgs)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callMethod" data-name="callMethod">
               <h3>
                  callMethod 
                  <span class="badge">function</span>
                  
                  <a href="#callMethod" class="anchor" title="Link to callMethod">#</a>
               </h3>
               
               <p>callMethod is the call implementation used by a function returned
by makeMethodValue (used by v.Method(i).Interface()).
It is a streamlined version of the usual reflect call: the caller has
already laid out the argument frame for us, so we don't have
to deal with individual Values for each argument.
It is in this file so that it can be next to the two similar functions above.
The remainder of the makeMethodValue implementation is in makefunc.go.
NOTE: This function must be marked as a "wrapper" in the generated code,
so that the linker can make it work correctly for panic and recover.
The gc compilers know to do that for the name "reflect.callMethod".
ctxt is the "closure" generated by makeMethodValue.
frame is a pointer to the arguments to that closure on the stack.
retValid points to a boolean which should be set when the results
section of frame is set.
regs contains the argument values passed in registers and will contain
the values returned from ctxt.fn in registers.</p>
               
               <pre><code class="language-go">func callMethod(ctxt *methodValue, frame unsafe.Pointer, retValid *bool, regs *abi.RegArgs)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="callReflect" data-name="callReflect">
               <h3>
                  callReflect 
                  <span class="badge">function</span>
                  
                  <a href="#callReflect" class="anchor" title="Link to callReflect">#</a>
               </h3>
               
               <p>callReflect is the call implementation used by a function
returned by MakeFunc. In many ways it is the opposite of the
method Value.call above. The method above converts a call using Values
into a call of a function with a concrete argument frame, while
callReflect converts a call of a function with a concrete argument
frame into a call using Values.
It is in this file so that it can be next to the call method above.
The remainder of the MakeFunc implementation is in makefunc.go.
NOTE: This function must be marked as a "wrapper" in the generated code,
so that the linker can make it work correctly for panic and recover.
The gc compilers know to do that for the name "reflect.callReflect".
ctxt is the "closure" generated by MakeFunc.
frame is a pointer to the arguments to that closure on the stack.
retValid points to a boolean which should be set when the results
section of frame is set.
regs contains the argument values passed in registers and will contain
the values returned from ctxt.fn in registers.</p>
               
               <pre><code class="language-go">func callReflect(ctxt *makeFuncImpl, frame unsafe.Pointer, retValid *bool, regs *abi.RegArgs)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canRangeFunc" data-name="canRangeFunc">
               <h3>
                  canRangeFunc 
                  <span class="badge">function</span>
                  
                  <a href="#canRangeFunc" class="anchor" title="Link to canRangeFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func canRangeFunc(t *abi.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canRangeFunc2" data-name="canRangeFunc2">
               <h3>
                  canRangeFunc2 
                  <span class="badge">function</span>
                  
                  <a href="#canRangeFunc2" class="anchor" title="Link to canRangeFunc2">#</a>
               </h3>
               
               <pre><code class="language-go">func canRangeFunc2(t *abi.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="capNonSlice" data-name="capNonSlice">
               <h3>
                  capNonSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#capNonSlice" class="anchor" title="Link to capNonSlice">#</a>
               </h3>
               
               <pre><code class="language-go">func (v Value) capNonSlice() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chancap" data-name="chancap">
               <h3>
                  chancap 
                  <span class="badge">function</span>
                  
                  <a href="#chancap" class="anchor" title="Link to chancap">#</a>
               </h3>
               
               <p>implemented in ../runtime
go:noescape</p>
               
               <pre><code class="language-go">func chancap(ch unsafe.Pointer) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chanclose" data-name="chanclose">
               <h3>
                  chanclose 
                  <span class="badge">function</span>
                  
                  <a href="#chanclose" class="anchor" title="Link to chanclose">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func chanclose(ch unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chanlen" data-name="chanlen">
               <h3>
                  chanlen 
                  <span class="badge">function</span>
                  
                  <a href="#chanlen" class="anchor" title="Link to chanlen">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func chanlen(ch unsafe.Pointer) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chanrecv" data-name="chanrecv">
               <h3>
                  chanrecv 
                  <span class="badge">function</span>
                  
                  <a href="#chanrecv" class="anchor" title="Link to chanrecv">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func chanrecv(ch unsafe.Pointer, nb bool, val unsafe.Pointer) (selected bool, received bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chansend" data-name="chansend">
               <h3>
                  chansend 
                  <span class="badge">function</span>
                  
                  <a href="#chansend" class="anchor" title="Link to chansend">#</a>
               </h3>
               
               <pre><code class="language-go">func chansend(ch unsafe.Pointer, val unsafe.Pointer, nb bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chansend0" data-name="chansend0">
               <h3>
                  chansend0 
                  <span class="badge">function</span>
                  
                  <a href="#chansend0" class="anchor" title="Link to chansend0">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func chansend0(ch unsafe.Pointer, val unsafe.Pointer, nb bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="common" data-name="common">
               <h3>
                  common 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#common" class="anchor" title="Link to common">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *interfaceType) common() *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="common" data-name="common">
               <h3>
                  common 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#common" class="anchor" title="Link to common">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) common() *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="contentEscapes" data-name="contentEscapes">
               <h3>
                  contentEscapes 
                  <span class="badge">function</span>
                  
                  <a href="#contentEscapes" class="anchor" title="Link to contentEscapes">#</a>
               </h3>
               
               <p>Dummy annotation marking that the content of value x
escapes (i.e. modeling roughly heap=*x),
for use in cases where the reflect code is so clever that
the compiler cannot follow.</p>
               
               <pre><code class="language-go">func contentEscapes(x unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convertOp" data-name="convertOp">
               <h3>
                  convertOp 
                  <span class="badge">function</span>
                  
                  <a href="#convertOp" class="anchor" title="Link to convertOp">#</a>
               </h3>
               
               <p>convertOp returns the function to convert a value of type src
to a value of type dst. If the conversion is illegal, convertOp returns nil.</p>
               
               <pre><code class="language-go">func convertOp(dst *abi.Type, src *abi.Type) (func(Value, Type) Value)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyVal" data-name="copyVal">
               <h3>
                  copyVal 
                  <span class="badge">function</span>
                  
                  <a href="#copyVal" class="anchor" title="Link to copyVal">#</a>
               </h3>
               
               <p>copyVal returns a Value containing the map key or value at ptr,
allocating a new variable as needed.</p>
               
               <pre><code class="language-go">func copyVal(typ *abi.Type, fl flag, ptr unsafe.Pointer) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtBytesString" data-name="cvtBytesString">
               <h3>
                  cvtBytesString 
                  <span class="badge">function</span>
                  
                  <a href="#cvtBytesString" class="anchor" title="Link to cvtBytesString">#</a>
               </h3>
               
               <p>convertOp: []byte -> string</p>
               
               <pre><code class="language-go">func cvtBytesString(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtComplex" data-name="cvtComplex">
               <h3>
                  cvtComplex 
                  <span class="badge">function</span>
                  
                  <a href="#cvtComplex" class="anchor" title="Link to cvtComplex">#</a>
               </h3>
               
               <p>convertOp: complexXX -> complexXX</p>
               
               <pre><code class="language-go">func cvtComplex(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtDirect" data-name="cvtDirect">
               <h3>
                  cvtDirect 
                  <span class="badge">function</span>
                  
                  <a href="#cvtDirect" class="anchor" title="Link to cvtDirect">#</a>
               </h3>
               
               <p>convertOp: direct copy</p>
               
               <pre><code class="language-go">func cvtDirect(v Value, typ Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtFloat" data-name="cvtFloat">
               <h3>
                  cvtFloat 
                  <span class="badge">function</span>
                  
                  <a href="#cvtFloat" class="anchor" title="Link to cvtFloat">#</a>
               </h3>
               
               <p>convertOp: floatXX -> floatXX</p>
               
               <pre><code class="language-go">func cvtFloat(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtFloatInt" data-name="cvtFloatInt">
               <h3>
                  cvtFloatInt 
                  <span class="badge">function</span>
                  
                  <a href="#cvtFloatInt" class="anchor" title="Link to cvtFloatInt">#</a>
               </h3>
               
               <p>convertOp: floatXX -> intXX</p>
               
               <pre><code class="language-go">func cvtFloatInt(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtFloatUint" data-name="cvtFloatUint">
               <h3>
                  cvtFloatUint 
                  <span class="badge">function</span>
                  
                  <a href="#cvtFloatUint" class="anchor" title="Link to cvtFloatUint">#</a>
               </h3>
               
               <p>convertOp: floatXX -> uintXX</p>
               
               <pre><code class="language-go">func cvtFloatUint(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtI2I" data-name="cvtI2I">
               <h3>
                  cvtI2I 
                  <span class="badge">function</span>
                  
                  <a href="#cvtI2I" class="anchor" title="Link to cvtI2I">#</a>
               </h3>
               
               <p>convertOp: interface -> interface</p>
               
               <pre><code class="language-go">func cvtI2I(v Value, typ Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtInt" data-name="cvtInt">
               <h3>
                  cvtInt 
                  <span class="badge">function</span>
                  
                  <a href="#cvtInt" class="anchor" title="Link to cvtInt">#</a>
               </h3>
               
               <p>convertOp: intXX -> [u]intXX</p>
               
               <pre><code class="language-go">func cvtInt(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtIntFloat" data-name="cvtIntFloat">
               <h3>
                  cvtIntFloat 
                  <span class="badge">function</span>
                  
                  <a href="#cvtIntFloat" class="anchor" title="Link to cvtIntFloat">#</a>
               </h3>
               
               <p>convertOp: intXX -> floatXX</p>
               
               <pre><code class="language-go">func cvtIntFloat(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtIntString" data-name="cvtIntString">
               <h3>
                  cvtIntString 
                  <span class="badge">function</span>
                  
                  <a href="#cvtIntString" class="anchor" title="Link to cvtIntString">#</a>
               </h3>
               
               <p>convertOp: intXX -> string</p>
               
               <pre><code class="language-go">func cvtIntString(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtRunesString" data-name="cvtRunesString">
               <h3>
                  cvtRunesString 
                  <span class="badge">function</span>
                  
                  <a href="#cvtRunesString" class="anchor" title="Link to cvtRunesString">#</a>
               </h3>
               
               <p>convertOp: []rune -> string</p>
               
               <pre><code class="language-go">func cvtRunesString(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtSliceArray" data-name="cvtSliceArray">
               <h3>
                  cvtSliceArray 
                  <span class="badge">function</span>
                  
                  <a href="#cvtSliceArray" class="anchor" title="Link to cvtSliceArray">#</a>
               </h3>
               
               <p>convertOp: []T -> [N]T</p>
               
               <pre><code class="language-go">func cvtSliceArray(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtSliceArrayPtr" data-name="cvtSliceArrayPtr">
               <h3>
                  cvtSliceArrayPtr 
                  <span class="badge">function</span>
                  
                  <a href="#cvtSliceArrayPtr" class="anchor" title="Link to cvtSliceArrayPtr">#</a>
               </h3>
               
               <p>convertOp: []T -> *[N]T</p>
               
               <pre><code class="language-go">func cvtSliceArrayPtr(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtStringBytes" data-name="cvtStringBytes">
               <h3>
                  cvtStringBytes 
                  <span class="badge">function</span>
                  
                  <a href="#cvtStringBytes" class="anchor" title="Link to cvtStringBytes">#</a>
               </h3>
               
               <p>convertOp: string -> []byte</p>
               
               <pre><code class="language-go">func cvtStringBytes(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtStringRunes" data-name="cvtStringRunes">
               <h3>
                  cvtStringRunes 
                  <span class="badge">function</span>
                  
                  <a href="#cvtStringRunes" class="anchor" title="Link to cvtStringRunes">#</a>
               </h3>
               
               <p>convertOp: string -> []rune</p>
               
               <pre><code class="language-go">func cvtStringRunes(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtT2I" data-name="cvtT2I">
               <h3>
                  cvtT2I 
                  <span class="badge">function</span>
                  
                  <a href="#cvtT2I" class="anchor" title="Link to cvtT2I">#</a>
               </h3>
               
               <p>convertOp: concrete -> interface</p>
               
               <pre><code class="language-go">func cvtT2I(v Value, typ Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtUint" data-name="cvtUint">
               <h3>
                  cvtUint 
                  <span class="badge">function</span>
                  
                  <a href="#cvtUint" class="anchor" title="Link to cvtUint">#</a>
               </h3>
               
               <p>convertOp: uintXX -> [u]intXX</p>
               
               <pre><code class="language-go">func cvtUint(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtUintFloat" data-name="cvtUintFloat">
               <h3>
                  cvtUintFloat 
                  <span class="badge">function</span>
                  
                  <a href="#cvtUintFloat" class="anchor" title="Link to cvtUintFloat">#</a>
               </h3>
               
               <p>convertOp: uintXX -> floatXX</p>
               
               <pre><code class="language-go">func cvtUintFloat(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cvtUintString" data-name="cvtUintString">
               <h3>
                  cvtUintString 
                  <span class="badge">function</span>
                  
                  <a href="#cvtUintString" class="anchor" title="Link to cvtUintString">#</a>
               </h3>
               
               <p>convertOp: uintXX -> string</p>
               
               <pre><code class="language-go">func cvtUintString(v Value, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deepValueEqual" data-name="deepValueEqual">
               <h3>
                  deepValueEqual 
                  <span class="badge">function</span>
                  
                  <a href="#deepValueEqual" class="anchor" title="Link to deepValueEqual">#</a>
               </h3>
               
               <p>Tests for deep equality using reflected types. The map argument tracks
comparisons that have already been seen, which allows short circuiting on
recursive types.</p>
               
               <pre><code class="language-go">func deepValueEqual(v1 Value, v2 Value, visited map[visit]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="directlyAssignable" data-name="directlyAssignable">
               <h3>
                  directlyAssignable 
                  <span class="badge">function</span>
                  
                  <a href="#directlyAssignable" class="anchor" title="Link to directlyAssignable">#</a>
               </h3>
               
               <p>directlyAssignable reports whether a value x of type V can be directly
assigned (using memmove) to a value of type T.
https://golang.org/doc/go_spec.html#Assignability
Ignoring the interface rules (implemented elsewhere)
and the ideal constant rules (no ideal constants at run time).</p>
               
               <pre><code class="language-go">func directlyAssignable(T *abi.Type, V *abi.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dump" data-name="dump">
               <h3>
                  dump 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dump" class="anchor" title="Link to dump">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *abiSeq) dump()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dump" data-name="dump">
               <h3>
                  dump 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#dump" class="anchor" title="Link to dump">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *abiDesc) dump()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dumpPtrBitMap" data-name="dumpPtrBitMap">
               <h3>
                  dumpPtrBitMap 
                  <span class="badge">function</span>
                  
                  <a href="#dumpPtrBitMap" class="anchor" title="Link to dumpPtrBitMap">#</a>
               </h3>
               
               <pre><code class="language-go">func dumpPtrBitMap(b abi.IntArgRegBitmap)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="elem" data-name="elem">
               <h3>
                  elem 
                  <span class="badge">function</span>
                  
                  <a href="#elem" class="anchor" title="Link to elem">#</a>
               </h3>
               
               <pre><code class="language-go">func elem(t *abi.Type) *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="embeddedIfaceMethStub" data-name="embeddedIfaceMethStub">
               <h3>
                  embeddedIfaceMethStub 
                  <span class="badge">function</span>
                  
                  <a href="#embeddedIfaceMethStub" class="anchor" title="Link to embeddedIfaceMethStub">#</a>
               </h3>
               
               <pre><code class="language-go">func embeddedIfaceMethStub()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitGCMask" data-name="emitGCMask">
               <h3>
                  emitGCMask 
                  <span class="badge">function</span>
                  
                  <a href="#emitGCMask" class="anchor" title="Link to emitGCMask">#</a>
               </h3>
               
               <p>emitGCMask writes the GC mask for [n]typ into out, starting at bit
offset base.</p>
               
               <pre><code class="language-go">func emitGCMask(out []byte, base uintptr, typ *abi.Type, n uintptr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="escapes" data-name="escapes">
               <h3>
                  escapes 
                  <span class="badge">function</span>
                  
                  <a href="#escapes" class="anchor" title="Link to escapes">#</a>
               </h3>
               
               <p>Dummy annotation marking that the value x escapes,
for use in cases where the reflect code is so clever that
the compiler cannot follow.</p>
               
               <pre><code class="language-go">func escapes(x any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exportedMethods" data-name="exportedMethods">
               <h3>
                  exportedMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exportedMethods" class="anchor" title="Link to exportedMethods">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) exportedMethods() []abi.Method</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="extendSlice" data-name="extendSlice">
               <h3>
                  extendSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#extendSlice" class="anchor" title="Link to extendSlice">#</a>
               </h3>
               
               <p>extendSlice extends a slice by n elements.
Unlike Value.grow, which modifies the slice in place and
does not change the length of the slice in place,
extendSlice returns a new slice value with the length
incremented by the number of specified elements.</p>
               
               <pre><code class="language-go">func (v Value) extendSlice(n int) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="floatFromReg" data-name="floatFromReg">
               <h3>
                  floatFromReg 
                  <span class="badge">function</span>
                  
                  <a href="#floatFromReg" class="anchor" title="Link to floatFromReg">#</a>
               </h3>
               
               <p>floatFromReg loads a float value from its register representation in r.
argSize must be 4 or 8.</p>
               
               <pre><code class="language-go">func floatFromReg(r *abi.RegArgs, reg int, argSize uintptr, to unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="floatToReg" data-name="floatToReg">
               <h3>
                  floatToReg 
                  <span class="badge">function</span>
                  
                  <a href="#floatToReg" class="anchor" title="Link to floatToReg">#</a>
               </h3>
               
               <p>floatToReg stores a float value in its register representation in r.
argSize must be either 4 or 8.</p>
               
               <pre><code class="language-go">func floatToReg(r *abi.RegArgs, reg int, argSize uintptr, from unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fnv1" data-name="fnv1">
               <h3>
                  fnv1 
                  <span class="badge">function</span>
                  
                  <a href="#fnv1" class="anchor" title="Link to fnv1">#</a>
               </h3>
               
               <p>fnv1 incorporates the list of bytes into the hash x using the FNV-1 hash function.</p>
               
               <pre><code class="language-go">func fnv1(x uint32, list ...byte) uint32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcLayout" data-name="funcLayout">
               <h3>
                  funcLayout 
                  <span class="badge">function</span>
                  
                  <a href="#funcLayout" class="anchor" title="Link to funcLayout">#</a>
               </h3>
               
               <p>funcLayout computes a struct type representing the layout of the
stack-assigned function arguments and return values for the function
type t.
If rcvr != nil, rcvr specifies the type of the receiver.
The returned type exists only for GC, so we only fill out GC relevant info.
Currently, that's just size and the GC program. We also fill in
the name for possible debugging use.</p>
               
               <pre><code class="language-go">func funcLayout(t *funcType, rcvr *abi.Type) (frametype *abi.Type, framePool *sync.Pool, abid abiDesc)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcName" data-name="funcName">
               <h3>
                  funcName 
                  <span class="badge">function</span>
                  
                  <a href="#funcName" class="anchor" title="Link to funcName">#</a>
               </h3>
               
               <p>funcName returns the name of f, for use in error messages.</p>
               
               <pre><code class="language-go">func funcName(f func([]Value) []Value) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcStr" data-name="funcStr">
               <h3>
                  funcStr 
                  <span class="badge">function</span>
                  
                  <a href="#funcStr" class="anchor" title="Link to funcStr">#</a>
               </h3>
               
               <p>funcStr builds a string representation of a funcType.</p>
               
               <pre><code class="language-go">func funcStr(ft *funcType) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getStaticuint64s" data-name="getStaticuint64s">
               <h3>
                  getStaticuint64s 
                  <span class="badge">function</span>
                  
                  <a href="#getStaticuint64s" class="anchor" title="Link to getStaticuint64s">#</a>
               </h3>
               
               <p>getStaticuint64s returns a pointer to an array of 256 uint64 values,
defined in the runtime package in read-only memory.
staticuint64s[0] == 0, staticuint64s[1] == 1, and so forth.
go:linkname getStaticuint64s runtime.getStaticuint64s</p>
               
               <pre><code class="language-go">func getStaticuint64s() *[256]uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="groupAndSlotOf" data-name="groupAndSlotOf">
               <h3>
                  groupAndSlotOf 
                  <span class="badge">function</span>
                  
                  <a href="#groupAndSlotOf" class="anchor" title="Link to groupAndSlotOf">#</a>
               </h3>
               
               <pre><code class="language-go">func groupAndSlotOf(ktyp Type, etyp Type) (Type, Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="grow" data-name="grow">
               <h3>
                  grow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#grow" class="anchor" title="Link to grow">#</a>
               </h3>
               
               <p>grow is identical to Grow but does not check for assignability.</p>
               
               <pre><code class="language-go">func (v Value) grow(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="growslice" data-name="growslice">
               <h3>
                  growslice 
                  <span class="badge">function</span>
                  
                  <a href="#growslice" class="anchor" title="Link to growslice">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func growslice(t *abi.Type, old unsafeheader.Slice, num int) unsafeheader.Slice</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hashMightPanic" data-name="hashMightPanic">
               <h3>
                  hashMightPanic 
                  <span class="badge">function</span>
                  
                  <a href="#hashMightPanic" class="anchor" title="Link to hashMightPanic">#</a>
               </h3>
               
               <p>hashMightPanic reports whether the hash of a map key of type t might panic.</p>
               
               <pre><code class="language-go">func hashMightPanic(t *abi.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="haveIdenticalType" data-name="haveIdenticalType">
               <h3>
                  haveIdenticalType 
                  <span class="badge">function</span>
                  
                  <a href="#haveIdenticalType" class="anchor" title="Link to haveIdenticalType">#</a>
               </h3>
               
               <pre><code class="language-go">func haveIdenticalType(T *abi.Type, V *abi.Type, cmpTags bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="haveIdenticalUnderlyingType" data-name="haveIdenticalUnderlyingType">
               <h3>
                  haveIdenticalUnderlyingType 
                  <span class="badge">function</span>
                  
                  <a href="#haveIdenticalUnderlyingType" class="anchor" title="Link to haveIdenticalUnderlyingType">#</a>
               </h3>
               
               <pre><code class="language-go">func haveIdenticalUnderlyingType(T *abi.Type, V *abi.Type, cmpTags bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ifaceE2I" data-name="ifaceE2I">
               <h3>
                  ifaceE2I 
                  <span class="badge">function</span>
                  
                  <a href="#ifaceE2I" class="anchor" title="Link to ifaceE2I">#</a>
               </h3>
               
               <pre><code class="language-go">func ifaceE2I(t *abi.Type, src any, dst unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="implements" data-name="implements">
               <h3>
                  implements 
                  <span class="badge">function</span>
                  
                  <a href="#implements" class="anchor" title="Link to implements">#</a>
               </h3>
               
               <p>implements reports whether the type V implements the interface type T.</p>
               
               <pre><code class="language-go">func implements(T *abi.Type, V *abi.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initFuncTypes" data-name="initFuncTypes">
               <h3>
                  initFuncTypes 
                  <span class="badge">function</span>
                  
                  <a href="#initFuncTypes" class="anchor" title="Link to initFuncTypes">#</a>
               </h3>
               
               <pre><code class="language-go">func initFuncTypes(n int) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initialized" data-name="initialized">
               <h3>
                  initialized 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initialized" class="anchor" title="Link to initialized">#</a>
               </h3>
               
               <pre><code class="language-go">func (h *hiter) initialized() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intFromReg" data-name="intFromReg">
               <h3>
                  intFromReg 
                  <span class="badge">function</span>
                  
                  <a href="#intFromReg" class="anchor" title="Link to intFromReg">#</a>
               </h3>
               
               <p>intFromReg loads an argSize sized integer from reg and places it at to.
argSize must be non-zero, fit in a register, and a power-of-two.</p>
               
               <pre><code class="language-go">func intFromReg(r *abi.RegArgs, reg int, argSize uintptr, to unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intToReg" data-name="intToReg">
               <h3>
                  intToReg 
                  <span class="badge">function</span>
                  
                  <a href="#intToReg" class="anchor" title="Link to intToReg">#</a>
               </h3>
               
               <p>intToReg loads an argSize sized integer and stores it into reg.
argSize must be non-zero, fit in a register, and a power-of-two.</p>
               
               <pre><code class="language-go">func intToReg(r *abi.RegArgs, reg int, argSize uintptr, from unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isLetter" data-name="isLetter">
               <h3>
                  isLetter 
                  <span class="badge">function</span>
                  
                  <a href="#isLetter" class="anchor" title="Link to isLetter">#</a>
               </h3>
               
               <p>isLetter reports whether a given 'rune' is classified as a Letter.</p>
               
               <pre><code class="language-go">func isLetter(ch rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isPaddedField" data-name="isPaddedField">
               <h3>
                  isPaddedField 
                  <span class="badge">function</span>
                  
                  <a href="#isPaddedField" class="anchor" title="Link to isPaddedField">#</a>
               </h3>
               
               <p>isPaddedField reports whether the i'th field of struct type t is followed
by padding.</p>
               
               <pre><code class="language-go">func isPaddedField(t Type, i int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isReflexive" data-name="isReflexive">
               <h3>
                  isReflexive 
                  <span class="badge">function</span>
                  
                  <a href="#isReflexive" class="anchor" title="Link to isReflexive">#</a>
               </h3>
               
               <p>isReflexive reports whether the == operation on the type is reflexive.
That is, x == x for all values x of type t.</p>
               
               <pre><code class="language-go">func isReflexive(t *abi.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isRegularMemory" data-name="isRegularMemory">
               <h3>
                  isRegularMemory 
                  <span class="badge">function</span>
                  
                  <a href="#isRegularMemory" class="anchor" title="Link to isRegularMemory">#</a>
               </h3>
               
               <p>This must match cmd/compile/internal/compare.IsRegularMemory</p>
               
               <pre><code class="language-go">func isRegularMemory(t Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValidFieldName" data-name="isValidFieldName">
               <h3>
                  isValidFieldName 
                  <span class="badge">function</span>
                  
                  <a href="#isValidFieldName" class="anchor" title="Link to isValidFieldName">#</a>
               </h3>
               
               <p>isValidFieldName checks if a string is a valid (struct) field name or not.
According to the language spec, a field name should be an identifier.
identifier = letter { letter | unicode_digit } .
letter = unicode_letter | "_" .</p>
               
               <pre><code class="language-go">func isValidFieldName(fieldName string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isZero" data-name="isZero">
               <h3>
                  isZero 
                  <span class="badge">function</span>
                  
                  <a href="#isZero" class="anchor" title="Link to isZero">#</a>
               </h3>
               
               <p>isZero For all zeros, performance is not as good as
return bytealg.Count(b, byte(0)) == len(b)</p>
               
               <pre><code class="language-go">func isZero(b []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="kind" data-name="kind">
               <h3>
                  kind 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#kind" class="anchor" title="Link to kind">#</a>
               </h3>
               
               <pre><code class="language-go">func (f flag) kind() Kind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lenNonSlice" data-name="lenNonSlice">
               <h3>
                  lenNonSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lenNonSlice" class="anchor" title="Link to lenNonSlice">#</a>
               </h3>
               
               <pre><code class="language-go">func (v Value) lenNonSlice() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeBytes" data-name="makeBytes">
               <h3>
                  makeBytes 
                  <span class="badge">function</span>
                  
                  <a href="#makeBytes" class="anchor" title="Link to makeBytes">#</a>
               </h3>
               
               <pre><code class="language-go">func makeBytes(f flag, v []byte, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeComplex" data-name="makeComplex">
               <h3>
                  makeComplex 
                  <span class="badge">function</span>
                  
                  <a href="#makeComplex" class="anchor" title="Link to makeComplex">#</a>
               </h3>
               
               <p>makeComplex returns a Value of type t equal to v (possibly truncated to complex64),
where t is a complex64 or complex128 type.</p>
               
               <pre><code class="language-go">func makeComplex(f flag, v complex128, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeFloat" data-name="makeFloat">
               <h3>
                  makeFloat 
                  <span class="badge">function</span>
                  
                  <a href="#makeFloat" class="anchor" title="Link to makeFloat">#</a>
               </h3>
               
               <p>makeFloat returns a Value of type t equal to v (possibly truncated to float32),
where t is a float32 or float64 type.</p>
               
               <pre><code class="language-go">func makeFloat(f flag, v float64, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeFloat32" data-name="makeFloat32">
               <h3>
                  makeFloat32 
                  <span class="badge">function</span>
                  
                  <a href="#makeFloat32" class="anchor" title="Link to makeFloat32">#</a>
               </h3>
               
               <p>makeFloat32 returns a Value of type t equal to v, where t is a float32 type.</p>
               
               <pre><code class="language-go">func makeFloat32(f flag, v float32, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeFuncStub" data-name="makeFuncStub">
               <h3>
                  makeFuncStub 
                  <span class="badge">function</span>
                  
                  <a href="#makeFuncStub" class="anchor" title="Link to makeFuncStub">#</a>
               </h3>
               
               <p>makeFuncStub is an assembly function that is the code half of
the function returned from MakeFunc. It expects a *callReflectFunc
as its context register, and its job is to invoke callReflect(ctxt, frame)
where ctxt is the context register and frame is a pointer to the first
word in the passed-in argument frame.</p>
               
               <pre><code class="language-go">func makeFuncStub()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeInt" data-name="makeInt">
               <h3>
                  makeInt 
                  <span class="badge">function</span>
                  
                  <a href="#makeInt" class="anchor" title="Link to makeInt">#</a>
               </h3>
               
               <p>makeInt returns a Value of type t equal to bits (possibly truncated),
where t is a signed or unsigned int type.</p>
               
               <pre><code class="language-go">func makeInt(f flag, bits uint64, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeMethodValue" data-name="makeMethodValue">
               <h3>
                  makeMethodValue 
                  <span class="badge">function</span>
                  
                  <a href="#makeMethodValue" class="anchor" title="Link to makeMethodValue">#</a>
               </h3>
               
               <p>makeMethodValue converts v from the rcvr+method index representation
of a method value to an actual method func value, which is
basically the receiver value with a special bit set, into a true
func value - a value holding an actual func. The output is
semantically equivalent to the input as far as the user of package
reflect can tell, but the true func representation can be handled
by code like Convert and Interface and Assign.</p>
               
               <pre><code class="language-go">func makeMethodValue(op string, v Value) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeRunes" data-name="makeRunes">
               <h3>
                  makeRunes 
                  <span class="badge">function</span>
                  
                  <a href="#makeRunes" class="anchor" title="Link to makeRunes">#</a>
               </h3>
               
               <pre><code class="language-go">func makeRunes(f flag, v []rune, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeString" data-name="makeString">
               <h3>
                  makeString 
                  <span class="badge">function</span>
                  
                  <a href="#makeString" class="anchor" title="Link to makeString">#</a>
               </h3>
               
               <pre><code class="language-go">func makeString(f flag, v string, t Type) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makechan" data-name="makechan">
               <h3>
                  makechan 
                  <span class="badge">function</span>
                  
                  <a href="#makechan" class="anchor" title="Link to makechan">#</a>
               </h3>
               
               <pre><code class="language-go">func makechan(typ *abi.Type, size int) (ch unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makemap" data-name="makemap">
               <h3>
                  makemap 
                  <span class="badge">function</span>
                  
                  <a href="#makemap" class="anchor" title="Link to makemap">#</a>
               </h3>
               
               <pre><code class="language-go">func makemap(t *abi.Type, cap int) (m unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapIterNext" data-name="mapIterNext">
               <h3>
                  mapIterNext 
                  <span class="badge">function</span>
                  
                  <a href="#mapIterNext" class="anchor" title="Link to mapIterNext">#</a>
               </h3>
               
               <p>Equivalent to runtime.mapIterNext.
go:noinline</p>
               
               <pre><code class="language-go">func mapIterNext(it *maps.Iter)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapIterStart" data-name="mapIterStart">
               <h3>
                  mapIterStart 
                  <span class="badge">function</span>
                  
                  <a href="#mapIterStart" class="anchor" title="Link to mapIterStart">#</a>
               </h3>
               
               <p>Equivalent to runtime.mapIterStart.
go:noinline</p>
               
               <pre><code class="language-go">func mapIterStart(t *abi.SwissMapType, m *maps.Map, it *maps.Iter)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapaccess" data-name="mapaccess">
               <h3>
                  mapaccess 
                  <span class="badge">function</span>
                  
                  <a href="#mapaccess" class="anchor" title="Link to mapaccess">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func mapaccess(t *abi.Type, m unsafe.Pointer, key unsafe.Pointer) (val unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapaccess_faststr" data-name="mapaccess_faststr">
               <h3>
                  mapaccess_faststr 
                  <span class="badge">function</span>
                  
                  <a href="#mapaccess_faststr" class="anchor" title="Link to mapaccess_faststr">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func mapaccess_faststr(t *abi.Type, m unsafe.Pointer, key string) (val unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapassign" data-name="mapassign">
               <h3>
                  mapassign 
                  <span class="badge">function</span>
                  
                  <a href="#mapassign" class="anchor" title="Link to mapassign">#</a>
               </h3>
               
               <p>mapassign should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/modern-go/reflect2
- github.com/goccy/go-json
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname mapassign</p>
               
               <pre><code class="language-go">func mapassign(t *abi.Type, m unsafe.Pointer, key unsafe.Pointer, val unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapassign0" data-name="mapassign0">
               <h3>
                  mapassign0 
                  <span class="badge">function</span>
                  
                  <a href="#mapassign0" class="anchor" title="Link to mapassign0">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func mapassign0(t *abi.Type, m unsafe.Pointer, key unsafe.Pointer, val unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapassign_faststr" data-name="mapassign_faststr">
               <h3>
                  mapassign_faststr 
                  <span class="badge">function</span>
                  
                  <a href="#mapassign_faststr" class="anchor" title="Link to mapassign_faststr">#</a>
               </h3>
               
               <pre><code class="language-go">func mapassign_faststr(t *abi.Type, m unsafe.Pointer, key string, val unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapassign_faststr0" data-name="mapassign_faststr0">
               <h3>
                  mapassign_faststr0 
                  <span class="badge">function</span>
                  
                  <a href="#mapassign_faststr0" class="anchor" title="Link to mapassign_faststr0">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func mapassign_faststr0(t *abi.Type, m unsafe.Pointer, key string, val unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapclear" data-name="mapclear">
               <h3>
                  mapclear 
                  <span class="badge">function</span>
                  
                  <a href="#mapclear" class="anchor" title="Link to mapclear">#</a>
               </h3>
               
               <pre><code class="language-go">func mapclear(t *abi.Type, m unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapdelete" data-name="mapdelete">
               <h3>
                  mapdelete 
                  <span class="badge">function</span>
                  
                  <a href="#mapdelete" class="anchor" title="Link to mapdelete">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func mapdelete(t *abi.Type, m unsafe.Pointer, key unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapdelete_faststr" data-name="mapdelete_faststr">
               <h3>
                  mapdelete_faststr 
                  <span class="badge">function</span>
                  
                  <a href="#mapdelete_faststr" class="anchor" title="Link to mapdelete_faststr">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func mapdelete_faststr(t *abi.Type, m unsafe.Pointer, key string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapiterinit" data-name="mapiterinit">
               <h3>
                  mapiterinit 
                  <span class="badge">function</span>
                  
                  <a href="#mapiterinit" class="anchor" title="Link to mapiterinit">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func mapiterinit(t *abi.Type, m unsafe.Pointer, it *hiter)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mapiternext" data-name="mapiternext">
               <h3>
                  mapiternext 
                  <span class="badge">function</span>
                  
                  <a href="#mapiternext" class="anchor" title="Link to mapiternext">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func mapiternext(it *hiter)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maplen" data-name="maplen">
               <h3>
                  maplen 
                  <span class="badge">function</span>
                  
                  <a href="#maplen" class="anchor" title="Link to maplen">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func maplen(m unsafe.Pointer) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="memmove" data-name="memmove">
               <h3>
                  memmove 
                  <span class="badge">function</span>
                  
                  <a href="#memmove" class="anchor" title="Link to memmove">#</a>
               </h3>
               
               <p>memmove copies size bytes to dst from src. No write barriers are used.
go:noescape</p>
               
               <pre><code class="language-go">func memmove(dst unsafe.Pointer, src unsafe.Pointer, size uintptr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methodReceiver" data-name="methodReceiver">
               <h3>
                  methodReceiver 
                  <span class="badge">function</span>
                  
                  <a href="#methodReceiver" class="anchor" title="Link to methodReceiver">#</a>
               </h3>
               
               <p>methodReceiver returns information about the receiver
described by v. The Value v may or may not have the
flagMethod bit set, so the kind cached in v.flag should
not be used.
The return value rcvrtype gives the method's actual receiver type.
The return value t gives the method type signature (without the receiver).
The return value fn is a pointer to the method code.</p>
               
               <pre><code class="language-go">func methodReceiver(op string, v Value, methodIndex int) (rcvrtype *abi.Type, t *funcType, fn unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methodValueCall" data-name="methodValueCall">
               <h3>
                  methodValueCall 
                  <span class="badge">function</span>
                  
                  <a href="#methodValueCall" class="anchor" title="Link to methodValueCall">#</a>
               </h3>
               
               <p>methodValueCall is an assembly function that is the code half of
the function returned from makeMethodValue. It expects a *methodValue
as its context register, and its job is to invoke callMethod(ctxt, frame)
where ctxt is the context register and frame is a pointer to the first
word in the passed-in argument frame.</p>
               
               <pre><code class="language-go">func methodValueCall()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="methodValueCallCodePtr" data-name="methodValueCallCodePtr">
               <h3>
                  methodValueCallCodePtr 
                  <span class="badge">function</span>
                  
                  <a href="#methodValueCallCodePtr" class="anchor" title="Link to methodValueCallCodePtr">#</a>
               </h3>
               
               <pre><code class="language-go">func methodValueCallCodePtr() uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="moveMakeFuncArgPtrs" data-name="moveMakeFuncArgPtrs">
               <h3>
                  moveMakeFuncArgPtrs 
                  <span class="badge">function</span>
                  
                  <a href="#moveMakeFuncArgPtrs" class="anchor" title="Link to moveMakeFuncArgPtrs">#</a>
               </h3>
               
               <p>moveMakeFuncArgPtrs uses ctxt.regPtrs to copy integer pointer arguments
in args.Ints to args.Ptrs where the GC can see them.
This is similar to what reflectcallmove does in the runtime, except
that happens on the return path, whereas this happens on the call path.
nosplit because pointers are being held in uintptr slots in args, so
having our stack scanned now could lead to accidentally freeing
memory.
go:nosplit</p>
               
               <pre><code class="language-go">func moveMakeFuncArgPtrs(ctxt *makeFuncCtxt, args *abi.RegArgs)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustBe" data-name="mustBe">
               <h3>
                  mustBe 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mustBe" class="anchor" title="Link to mustBe">#</a>
               </h3>
               
               <p>mustBe panics if f's kind is not expected.
Making this a method on flag instead of on Value
(and embedding flag in Value) means that we can write
the very clear v.mustBe(Bool) and have it compile into
v.flag.mustBe(Bool), which will only bother to copy the
single important word for the receiver.</p>
               
               <pre><code class="language-go">func (f flag) mustBe(expected Kind)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustBeAssignable" data-name="mustBeAssignable">
               <h3>
                  mustBeAssignable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mustBeAssignable" class="anchor" title="Link to mustBeAssignable">#</a>
               </h3>
               
               <p>mustBeAssignable panics if f records that the value is not assignable,
which is to say that either it was obtained using an unexported field
or it is not addressable.</p>
               
               <pre><code class="language-go">func (f flag) mustBeAssignable()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustBeAssignableSlow" data-name="mustBeAssignableSlow">
               <h3>
                  mustBeAssignableSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mustBeAssignableSlow" class="anchor" title="Link to mustBeAssignableSlow">#</a>
               </h3>
               
               <pre><code class="language-go">func (f flag) mustBeAssignableSlow()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustBeExported" data-name="mustBeExported">
               <h3>
                  mustBeExported 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mustBeExported" class="anchor" title="Link to mustBeExported">#</a>
               </h3>
               
               <p>mustBeExported panics if f records that the value was obtained using
an unexported field.</p>
               
               <pre><code class="language-go">func (f flag) mustBeExported()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustBeExportedSlow" data-name="mustBeExportedSlow">
               <h3>
                  mustBeExportedSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mustBeExportedSlow" class="anchor" title="Link to mustBeExportedSlow">#</a>
               </h3>
               
               <pre><code class="language-go">func (f flag) mustBeExportedSlow()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nameFor" data-name="nameFor">
               <h3>
                  nameFor 
                  <span class="badge">function</span>
                  
                  <a href="#nameFor" class="anchor" title="Link to nameFor">#</a>
               </h3>
               
               <pre><code class="language-go">func nameFor(t *abi.Type) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nameOff" data-name="nameOff">
               <h3>
                  nameOff 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nameOff" class="anchor" title="Link to nameOff">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *interfaceType) nameOff(off aNameOff) abi.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nameOff" data-name="nameOff">
               <h3>
                  nameOff 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nameOff" class="anchor" title="Link to nameOff">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) nameOff(off aNameOff) abi.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nameOffFor" data-name="nameOffFor">
               <h3>
                  nameOffFor 
                  <span class="badge">function</span>
                  
                  <a href="#nameOffFor" class="anchor" title="Link to nameOffFor">#</a>
               </h3>
               
               <pre><code class="language-go">func nameOffFor(t *abi.Type, off aNameOff) abi.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="needKeyUpdate" data-name="needKeyUpdate">
               <h3>
                  needKeyUpdate 
                  <span class="badge">function</span>
                  
                  <a href="#needKeyUpdate" class="anchor" title="Link to needKeyUpdate">#</a>
               </h3>
               
               <p>needKeyUpdate reports whether map overwrites require the key to be copied.</p>
               
               <pre><code class="language-go">func needKeyUpdate(t *abi.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newAbiDesc" data-name="newAbiDesc">
               <h3>
                  newAbiDesc 
                  <span class="badge">function</span>
                  
                  <a href="#newAbiDesc" class="anchor" title="Link to newAbiDesc">#</a>
               </h3>
               
               <pre><code class="language-go">func newAbiDesc(t *funcType, rcvr *abi.Type) abiDesc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newName" data-name="newName">
               <h3>
                  newName 
                  <span class="badge">function</span>
                  
                  <a href="#newName" class="anchor" title="Link to newName">#</a>
               </h3>
               
               <pre><code class="language-go">func newName(n string, tag string, exported bool, embedded bool) abi.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="overflowFloat32" data-name="overflowFloat32">
               <h3>
                  overflowFloat32 
                  <span class="badge">function</span>
                  
                  <a href="#overflowFloat32" class="anchor" title="Link to overflowFloat32">#</a>
               </h3>
               
               <pre><code class="language-go">func overflowFloat32(x float64) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="packEface" data-name="packEface">
               <h3>
                  packEface 
                  <span class="badge">function</span>
                  
                  <a href="#packEface" class="anchor" title="Link to packEface">#</a>
               </h3>
               
               <p>packEface converts v to the empty interface.</p>
               
               <pre><code class="language-go">func packEface(v Value) any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="panicNotBool" data-name="panicNotBool">
               <h3>
                  panicNotBool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#panicNotBool" class="anchor" title="Link to panicNotBool">#</a>
               </h3>
               
               <pre><code class="language-go">func (v Value) panicNotBool()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="panicNotMap" data-name="panicNotMap">
               <h3>
                  panicNotMap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#panicNotMap" class="anchor" title="Link to panicNotMap">#</a>
               </h3>
               
               <p>Force slow panicking path not inlined, so it won't add to the
inlining budget of the caller.
TODO: undo when the inliner is no longer bottom-up only.
go:noinline</p>
               
               <pre><code class="language-go">func (f flag) panicNotMap()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="panicNotMap" data-name="panicNotMap">
               <h3>
                  panicNotMap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#panicNotMap" class="anchor" title="Link to panicNotMap">#</a>
               </h3>
               
               <p>Force slow panicking path not inlined, so it won't add to the
inlining budget of the caller.
TODO: undo when the inliner is no longer bottom-up only.
go:noinline</p>
               
               <pre><code class="language-go">func (f flag) panicNotMap()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgPath" data-name="pkgPath">
               <h3>
                  pkgPath 
                  <span class="badge">function</span>
                  
                  <a href="#pkgPath" class="anchor" title="Link to pkgPath">#</a>
               </h3>
               
               <pre><code class="language-go">func pkgPath(n abi.Name) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgPathFor" data-name="pkgPathFor">
               <h3>
                  pkgPathFor 
                  <span class="badge">function</span>
                  
                  <a href="#pkgPathFor" class="anchor" title="Link to pkgPathFor">#</a>
               </h3>
               
               <pre><code class="language-go">func pkgPathFor(t *abi.Type) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pointer" data-name="pointer">
               <h3>
                  pointer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pointer" class="anchor" title="Link to pointer">#</a>
               </h3>
               
               <p>pointer returns the underlying pointer represented by v.
v.Kind() must be Pointer, Map, Chan, Func, or UnsafePointer
if v.Kind() == Pointer, the base type must not be not-in-heap.</p>
               
               <pre><code class="language-go">func (v Value) pointer() unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ptrTo" data-name="ptrTo">
               <h3>
                  ptrTo 
                  <span class="badge">function</span>
                  
                  <a href="#ptrTo" class="anchor" title="Link to ptrTo">#</a>
               </h3>
               
               <pre><code class="language-go">func ptrTo(t *abi.Type) *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ptrTo" data-name="ptrTo">
               <h3>
                  ptrTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ptrTo" class="anchor" title="Link to ptrTo">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) ptrTo() *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rangeNum" data-name="rangeNum">
               <h3>
                  rangeNum 
                  <span class="badge">function</span>
                  
                  <a href="#rangeNum" class="anchor" title="Link to rangeNum">#</a>
               </h3>
               
               <pre><code class="language-go">func rangeNum(num N, t Type) *ast.IndexExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recv" data-name="recv">
               <h3>
                  recv 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recv" class="anchor" title="Link to recv">#</a>
               </h3>
               
               <p>internal recv, possibly non-blocking (nb).
v is known to be a channel.</p>
               
               <pre><code class="language-go">func (v Value) recv(nb bool) (val Value, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="regAssign" data-name="regAssign">
               <h3>
                  regAssign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#regAssign" class="anchor" title="Link to regAssign">#</a>
               </h3>
               
               <p>regAssign attempts to reserve argument registers for a value of
type t, stored at some offset.
It returns whether or not the assignment succeeded, but
leaves any changes it made to a.steps behind, so the caller
must undo that work by adjusting a.steps if it fails.
This method along with the assign* methods represent the
complete register-assignment algorithm for the Go ABI.</p>
               
               <pre><code class="language-go">func (a *abiSeq) regAssign(t *abi.Type, offset uintptr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveNameOff" data-name="resolveNameOff">
               <h3>
                  resolveNameOff 
                  <span class="badge">function</span>
                  
                  <a href="#resolveNameOff" class="anchor" title="Link to resolveNameOff">#</a>
               </h3>
               
               <p>resolveNameOff resolves a name offset from a base pointer.
The (*rtype).nameOff method is a convenience wrapper for this function.
Implemented in the runtime package.
go:noescape</p>
               
               <pre><code class="language-go">func resolveNameOff(ptrInModule unsafe.Pointer, off int32) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveReflectName" data-name="resolveReflectName">
               <h3>
                  resolveReflectName 
                  <span class="badge">function</span>
                  
                  <a href="#resolveReflectName" class="anchor" title="Link to resolveReflectName">#</a>
               </h3>
               
               <p>resolveReflectName adds a name to the reflection lookup map in the runtime.
It returns a new nameOff that can be used to refer to the pointer.</p>
               
               <pre><code class="language-go">func resolveReflectName(n abi.Name) aNameOff</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveReflectText" data-name="resolveReflectText">
               <h3>
                  resolveReflectText 
                  <span class="badge">function</span>
                  
                  <a href="#resolveReflectText" class="anchor" title="Link to resolveReflectText">#</a>
               </h3>
               
               <p>resolveReflectText adds a function pointer to the reflection lookup map in
the runtime. It returns a new textOff that can be used to refer to the
pointer.</p>
               
               <pre><code class="language-go">func resolveReflectText(ptr unsafe.Pointer) aTextOff</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveReflectType" data-name="resolveReflectType">
               <h3>
                  resolveReflectType 
                  <span class="badge">function</span>
                  
                  <a href="#resolveReflectType" class="anchor" title="Link to resolveReflectType">#</a>
               </h3>
               
               <p>resolveReflectType adds a *rtype to the reflection lookup map in the runtime.
It returns a new typeOff that can be used to refer to the pointer.</p>
               
               <pre><code class="language-go">func resolveReflectType(t *abi.Type) aTypeOff</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveTextOff" data-name="resolveTextOff">
               <h3>
                  resolveTextOff 
                  <span class="badge">function</span>
                  
                  <a href="#resolveTextOff" class="anchor" title="Link to resolveTextOff">#</a>
               </h3>
               
               <p>resolveTextOff resolves a function pointer offset from a base type.
The (*rtype).textOff method is a convenience wrapper for this function.
Implemented in the runtime package.
go:noescape</p>
               
               <pre><code class="language-go">func resolveTextOff(rtype unsafe.Pointer, off int32) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveTypeOff" data-name="resolveTypeOff">
               <h3>
                  resolveTypeOff 
                  <span class="badge">function</span>
                  
                  <a href="#resolveTypeOff" class="anchor" title="Link to resolveTypeOff">#</a>
               </h3>
               
               <p>resolveTypeOff resolves an *rtype offset from a base type.
The (*rtype).typeOff method is a convenience wrapper for this function.
Implemented in the runtime package.
go:noescape</p>
               
               <pre><code class="language-go">func resolveTypeOff(rtype unsafe.Pointer, off int32) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ro" data-name="ro">
               <h3>
                  ro 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ro" class="anchor" title="Link to ro">#</a>
               </h3>
               
               <pre><code class="language-go">func (f flag) ro() flag</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rselect" data-name="rselect">
               <h3>
                  rselect 
                  <span class="badge">function</span>
                  
                  <a href="#rselect" class="anchor" title="Link to rselect">#</a>
               </h3>
               
               <p>rselect runs a select. It returns the index of the chosen case.
If the case was a receive, val is filled in with the received value.
The conventional OK bool indicates whether the receive corresponds
to a sent value.
rselect generally doesn't escape the runtimeSelect slice, except
that for the send case the value to send needs to escape. We don't
have a way to represent that in the function signature. So we handle
that with a forced escape in function Select.
go:noescape</p>
               
               <pre><code class="language-go">func rselect([]runtimeSelect) (chosen int, recvOK bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rtypeOf" data-name="rtypeOf">
               <h3>
                  rtypeOf 
                  <span class="badge">function</span>
                  
                  <a href="#rtypeOf" class="anchor" title="Link to rtypeOf">#</a>
               </h3>
               
               <p>rtypeOf directly extracts the *rtype of the provided value.</p>
               
               <pre><code class="language-go">func rtypeOf(i any) *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rtypeOff" data-name="rtypeOff">
               <h3>
                  rtypeOff 
                  <span class="badge">function</span>
                  
                  <a href="#rtypeOff" class="anchor" title="Link to rtypeOff">#</a>
               </h3>
               
               <p>rtypeOff should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/goccy/go-json
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname rtypeOff</p>
               
               <pre><code class="language-go">func rtypeOff(section unsafe.Pointer, off int32) *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runes" data-name="runes">
               <h3>
                  runes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#runes" class="anchor" title="Link to runes">#</a>
               </h3>
               
               <p>runes returns v's underlying value.
It panics if v's underlying value is not a slice of runes (int32s).</p>
               
               <pre><code class="language-go">func (v Value) runes() []rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtimeStructField" data-name="runtimeStructField">
               <h3>
                  runtimeStructField 
                  <span class="badge">function</span>
                  
                  <a href="#runtimeStructField" class="anchor" title="Link to runtimeStructField">#</a>
               </h3>
               
               <p>runtimeStructField takes a StructField value passed to StructOf and
returns both the corresponding internal representation, of type
structField, and the pkgpath value to use for this field.</p>
               
               <pre><code class="language-go">func runtimeStructField(field StructField) (structField, string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="send" data-name="send">
               <h3>
                  send 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#send" class="anchor" title="Link to send">#</a>
               </h3>
               
               <p>internal send, possibly non-blocking.
v is known to be a channel.</p>
               
               <pre><code class="language-go">func (v Value) send(x Value, nb bool) (selected bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setRunes" data-name="setRunes">
               <h3>
                  setRunes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setRunes" class="anchor" title="Link to setRunes">#</a>
               </h3>
               
               <p>setRunes sets v's underlying value.
It panics if v's underlying value is not a slice of runes (int32s)
or if [Value.CanSet] returns false.</p>
               
               <pre><code class="language-go">func (v Value) setRunes(x []rune)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="specialChannelAssignability" data-name="specialChannelAssignability">
               <h3>
                  specialChannelAssignability 
                  <span class="badge">function</span>
                  
                  <a href="#specialChannelAssignability" class="anchor" title="Link to specialChannelAssignability">#</a>
               </h3>
               
               <p>specialChannelAssignability reports whether a value x of channel type V
can be directly assigned (using memmove) to another channel type T.
https://golang.org/doc/go_spec.html#Assignability
T and V must be both of Chan kind.</p>
               
               <pre><code class="language-go">func specialChannelAssignability(T *abi.Type, V *abi.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stackAssign" data-name="stackAssign">
               <h3>
                  stackAssign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stackAssign" class="anchor" title="Link to stackAssign">#</a>
               </h3>
               
               <p>stackAssign reserves space for one value that is "size" bytes
large with alignment "alignment" to the stack.
Should not be called directly; use addArg instead.</p>
               
               <pre><code class="language-go">func (a *abiSeq) stackAssign(size uintptr, alignment uintptr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stepsForValue" data-name="stepsForValue">
               <h3>
                  stepsForValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stepsForValue" class="anchor" title="Link to stepsForValue">#</a>
               </h3>
               
               <p>stepsForValue returns the ABI instructions for translating
the i'th Go argument or return value represented by this
abiSeq to the Go ABI.</p>
               
               <pre><code class="language-go">func (a *abiSeq) stepsForValue(i int) []abiStep</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="storeRcvr" data-name="storeRcvr">
               <h3>
                  storeRcvr 
                  <span class="badge">function</span>
                  
                  <a href="#storeRcvr" class="anchor" title="Link to storeRcvr">#</a>
               </h3>
               
               <p>v is a method receiver. Store at p the word which is used to
encode that receiver at the start of the argument list.
Reflect uses the "interface" calling convention for
methods, which always uses one word to record the receiver.</p>
               
               <pre><code class="language-go">func storeRcvr(v Value, p unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stringFor" data-name="stringFor">
               <h3>
                  stringFor 
                  <span class="badge">function</span>
                  
                  <a href="#stringFor" class="anchor" title="Link to stringFor">#</a>
               </h3>
               
               <pre><code class="language-go">func stringFor(t *abi.Type) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stringNonString" data-name="stringNonString">
               <h3>
                  stringNonString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stringNonString" class="anchor" title="Link to stringNonString">#</a>
               </h3>
               
               <pre><code class="language-go">func (v Value) stringNonString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="textOff" data-name="textOff">
               <h3>
                  textOff 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#textOff" class="anchor" title="Link to textOff">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) textOff(off aTextOff) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="textOffFor" data-name="textOffFor">
               <h3>
                  textOffFor 
                  <span class="badge">function</span>
                  
                  <a href="#textOffFor" class="anchor" title="Link to textOffFor">#</a>
               </h3>
               
               <pre><code class="language-go">func textOffFor(t *abi.Type, off aTextOff) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toRType" data-name="toRType">
               <h3>
                  toRType 
                  <span class="badge">function</span>
                  
                  <a href="#toRType" class="anchor" title="Link to toRType">#</a>
               </h3>
               
               <pre><code class="language-go">func toRType(t *abi.Type) *rtype</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toType" data-name="toType">
               <h3>
                  toType 
                  <span class="badge">function</span>
                  
                  <a href="#toType" class="anchor" title="Link to toType">#</a>
               </h3>
               
               <p>toType converts from a *rtype to a Type that can be returned
to the client of package reflect. In gc, the only concern is that
a nil *rtype must be replaced by a nil Type, but in gccgo this
function takes care of ensuring that multiple *rtype for the same
type are coalesced into a single Type.
toType should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- fortio.org/log
- github.com/goccy/go-json
- github.com/goccy/go-reflect
- github.com/sohaha/zlsgo
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname toType</p>
               
               <pre><code class="language-go">func toType(t *abi.Type) Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typ" data-name="typ">
               <h3>
                  typ 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typ" class="anchor" title="Link to typ">#</a>
               </h3>
               
               <p>typ returns the *abi.Type stored in the Value. This method is fast,
but it doesn't always return the correct type for the Value.
See abiType and Type, which do return the correct type.</p>
               
               <pre><code class="language-go">func (v Value) typ() *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeOff" data-name="typeOff">
               <h3>
                  typeOff 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeOff" class="anchor" title="Link to typeOff">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *interfaceType) typeOff(off aTypeOff) *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeOff" data-name="typeOff">
               <h3>
                  typeOff 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeOff" class="anchor" title="Link to typeOff">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) typeOff(off aTypeOff) *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeOffFor" data-name="typeOffFor">
               <h3>
                  typeOffFor 
                  <span class="badge">function</span>
                  
                  <a href="#typeOffFor" class="anchor" title="Link to typeOffFor">#</a>
               </h3>
               
               <pre><code class="language-go">func typeOffFor(t *abi.Type, off aTypeOff) *abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeSlow" data-name="typeSlow">
               <h3>
                  typeSlow 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#typeSlow" class="anchor" title="Link to typeSlow">#</a>
               </h3>
               
               <p>go:noinline</p>
               
               <pre><code class="language-go">func (v Value) typeSlow() Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typedarrayclear" data-name="typedarrayclear">
               <h3>
                  typedarrayclear 
                  <span class="badge">function</span>
                  
                  <a href="#typedarrayclear" class="anchor" title="Link to typedarrayclear">#</a>
               </h3>
               
               <p>typedarrayclear zeroes the value at ptr of an array of elemType,
only clears len elem.
go:noescape</p>
               
               <pre><code class="language-go">func typedarrayclear(elemType *abi.Type, ptr unsafe.Pointer, len int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typedmemclr" data-name="typedmemclr">
               <h3>
                  typedmemclr 
                  <span class="badge">function</span>
                  
                  <a href="#typedmemclr" class="anchor" title="Link to typedmemclr">#</a>
               </h3>
               
               <p>typedmemclr zeros the value at ptr of type t.
go:noescape</p>
               
               <pre><code class="language-go">func typedmemclr(t *abi.Type, ptr unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typedmemclrpartial" data-name="typedmemclrpartial">
               <h3>
                  typedmemclrpartial 
                  <span class="badge">function</span>
                  
                  <a href="#typedmemclrpartial" class="anchor" title="Link to typedmemclrpartial">#</a>
               </h3>
               
               <p>typedmemclrpartial is like typedmemclr but assumes that
dst points off bytes into the value and only clears size bytes.
go:noescape</p>
               
               <pre><code class="language-go">func typedmemclrpartial(t *abi.Type, ptr unsafe.Pointer, off uintptr, size uintptr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typedmemmove" data-name="typedmemmove">
               <h3>
                  typedmemmove 
                  <span class="badge">function</span>
                  
                  <a href="#typedmemmove" class="anchor" title="Link to typedmemmove">#</a>
               </h3>
               
               <p>typedmemmove copies a value of type t to dst from src.
go:noescape</p>
               
               <pre><code class="language-go">func typedmemmove(t *abi.Type, dst unsafe.Pointer, src unsafe.Pointer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typedslicecopy" data-name="typedslicecopy">
               <h3>
                  typedslicecopy 
                  <span class="badge">function</span>
                  
                  <a href="#typedslicecopy" class="anchor" title="Link to typedslicecopy">#</a>
               </h3>
               
               <p>typedslicecopy copies a slice of elemType values from src to dst,
returning the number of elements copied.
go:noescape</p>
               
               <pre><code class="language-go">func typedslicecopy(t *abi.Type, dst unsafeheader.Slice, src unsafeheader.Slice) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typehash" data-name="typehash">
               <h3>
                  typehash 
                  <span class="badge">function</span>
                  
                  <a href="#typehash" class="anchor" title="Link to typehash">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func typehash(t *abi.Type, p unsafe.Pointer, h uintptr) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typelinks" data-name="typelinks">
               <h3>
                  typelinks 
                  <span class="badge">function</span>
                  
                  <a href="#typelinks" class="anchor" title="Link to typelinks">#</a>
               </h3>
               
               <p>typelinks is implemented in package runtime.
It returns a slice of the sections in each module,
and a slice of *rtype offsets in each module.
The types in each module are sorted by string. That is, the first
two linked types of the first module are:
d0 := sections[0]
t1 := (*rtype)(add(d0, offset[0][0]))
t2 := (*rtype)(add(d0, offset[0][1]))
and
t1.String() < t2.String()
Note that strings are not unique identifiers for types:
there can be more than one with a given string.
Only types we might want to look up are included:
pointers, channels, maps, slices, and arrays.</p>
               
               <pre><code class="language-go">func typelinks() (sections []unsafe.Pointer, offset [][]int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typeptrdata" data-name="typeptrdata">
               <h3>
                  typeptrdata 
                  <span class="badge">function</span>
                  
                  <a href="#typeptrdata" class="anchor" title="Link to typeptrdata">#</a>
               </h3>
               
               <p>typeptrdata returns the length in bytes of the prefix of t
containing pointer data. Anything after this offset is scalar data.
keep in sync with ../cmd/compile/internal/reflectdata/reflect.go</p>
               
               <pre><code class="language-go">func typeptrdata(t *abi.Type) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typesByString" data-name="typesByString">
               <h3>
                  typesByString 
                  <span class="badge">function</span>
                  
                  <a href="#typesByString" class="anchor" title="Link to typesByString">#</a>
               </h3>
               
               <p>typesByString returns the subslice of typelinks() whose elements have
the given string representation.
It may be empty (no known types with that string) or may have
multiple elements (multiple types with that string).
typesByString should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/aristanetworks/goarista
- fortio.org/log
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname typesByString</p>
               
               <pre><code class="language-go">func typesByString(s string) []*abi.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="typesMustMatch" data-name="typesMustMatch">
               <h3>
                  typesMustMatch 
                  <span class="badge">function</span>
                  
                  <a href="#typesMustMatch" class="anchor" title="Link to typesMustMatch">#</a>
               </h3>
               
               <pre><code class="language-go">func typesMustMatch(what string, t1 Type, t2 Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uncommon" data-name="uncommon">
               <h3>
                  uncommon 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uncommon" class="anchor" title="Link to uncommon">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *interfaceType) uncommon() *abi.UncommonType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uncommon" data-name="uncommon">
               <h3>
                  uncommon 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#uncommon" class="anchor" title="Link to uncommon">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *rtype) uncommon() *abi.UncommonType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unpackEface" data-name="unpackEface">
               <h3>
                  unpackEface 
                  <span class="badge">function</span>
                  
                  <a href="#unpackEface" class="anchor" title="Link to unpackEface">#</a>
               </h3>
               
               <p>unpackEface converts the empty interface i to a Value.</p>
               
               <pre><code class="language-go">func unpackEface(i any) Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unsafe_New" data-name="unsafe_New">
               <h3>
                  unsafe_New 
                  <span class="badge">function</span>
                  
                  <a href="#unsafe_New" class="anchor" title="Link to unsafe_New">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func unsafe_New(*abi.Type) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unsafe_NewArray" data-name="unsafe_NewArray">
               <h3>
                  unsafe_NewArray 
                  <span class="badge">function</span>
                  
                  <a href="#unsafe_NewArray" class="anchor" title="Link to unsafe_NewArray">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func unsafe_NewArray(*abi.Type, int) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unsafeslice" data-name="unsafeslice">
               <h3>
                  unsafeslice 
                  <span class="badge">function</span>
                  
                  <a href="#unsafeslice" class="anchor" title="Link to unsafeslice">#</a>
               </h3>
               
               <p>go:noescape</p>
               
               <pre><code class="language-go">func unsafeslice(t *abi.Type, ptr unsafe.Pointer, len int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unusedIfaceIndir" data-name="unusedIfaceIndir">
               <h3>
                  unusedIfaceIndir 
                  <span class="badge">function</span>
                  
                  <a href="#unusedIfaceIndir" class="anchor" title="Link to unusedIfaceIndir">#</a>
               </h3>
               
               <p>ifaceIndir reports whether t is stored indirectly in an interface value.
It is no longer used by this package and is here entirely for the
linkname uses.
go:linkname unusedIfaceIndir reflect.ifaceIndir</p>
               
               <pre><code class="language-go">func unusedIfaceIndir(t *abi.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="valueInterface" data-name="valueInterface">
               <h3>
                  valueInterface 
                  <span class="badge">function</span>
                  
                  <a href="#valueInterface" class="anchor" title="Link to valueInterface">#</a>
               </h3>
               
               <pre><code class="language-go">func valueInterface(v Value, safe bool) any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="valueMethodName" data-name="valueMethodName">
               <h3>
                  valueMethodName 
                  <span class="badge">function</span>
                  
                  <a href="#valueMethodName" class="anchor" title="Link to valueMethodName">#</a>
               </h3>
               
               <p>valueMethodName returns the name of the exported calling method on Value.</p>
               
               <pre><code class="language-go">func valueMethodName() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="verifyNotInHeapPtr" data-name="verifyNotInHeapPtr">
               <h3>
                  verifyNotInHeapPtr 
                  <span class="badge">function</span>
                  
                  <a href="#verifyNotInHeapPtr" class="anchor" title="Link to verifyNotInHeapPtr">#</a>
               </h3>
               
               <pre><code class="language-go">func verifyNotInHeapPtr(p uintptr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walk" data-name="walk">
               <h3>
                  walk 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#walk" class="anchor" title="Link to walk">#</a>
               </h3>
               
               <p>walk walks all the fields in the struct type t, visiting
fields in index preorder and appending them to w.fields
(this maintains the required ordering).
Fields that have been overridden have their
Name field cleared.</p>
               
               <pre><code class="language-go">func (w *visibleFieldsWalker) walk(t Type)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>