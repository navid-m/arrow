<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - abi</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>abi</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"unsafe"
"unsafe"
"internal/goarch"
"unsafe"
"unsafe"
"unsafe"
"unsafe"
"unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ArgsSizeUnknown" data-name="ArgsSizeUnknown">
               <h3>
                  ArgsSizeUnknown 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ArgsSizeUnknown" class="anchor" title="Link to ArgsSizeUnknown">#</a>
               </h3>
               
               <p>ArgsSizeUnknown is set in Func.argsize to mark all functions
whose argument size is unknown (C vararg functions, and
assembly code without an explicit specification).
This value is generated by the compiler, assembler, or linker.</p>
               
               <pre><code>const ArgsSizeUnknown = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Array" data-name="Array">
               <h3>
                  Array 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Array" class="anchor" title="Link to Array">#</a>
               </h3>
               
               <pre><code>const Array</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Bool" data-name="Bool">
               <h3>
                  Bool 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Bool" class="anchor" title="Link to Bool">#</a>
               </h3>
               
               <pre><code>const Bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BothDir" data-name="BothDir">
               <h3>
                  BothDir 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BothDir" class="anchor" title="Link to BothDir">#</a>
               </h3>
               
               <pre><code>const BothDir = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Chan" data-name="Chan">
               <h3>
                  Chan 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Chan" class="anchor" title="Link to Chan">#</a>
               </h3>
               
               <pre><code>const Chan</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Complex128" data-name="Complex128">
               <h3>
                  Complex128 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Complex128" class="anchor" title="Link to Complex128">#</a>
               </h3>
               
               <pre><code>const Complex128</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Complex64" data-name="Complex64">
               <h3>
                  Complex64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Complex64" class="anchor" title="Link to Complex64">#</a>
               </h3>
               
               <pre><code>const Complex64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EffectiveFloatRegSize" data-name="EffectiveFloatRegSize">
               <h3>
                  EffectiveFloatRegSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EffectiveFloatRegSize" class="anchor" title="Link to EffectiveFloatRegSize">#</a>
               </h3>
               
               <pre><code>const EffectiveFloatRegSize = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EffectiveFloatRegSize" data-name="EffectiveFloatRegSize">
               <h3>
                  EffectiveFloatRegSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EffectiveFloatRegSize" class="anchor" title="Link to EffectiveFloatRegSize">#</a>
               </h3>
               
               <p>We use SSE2 registers which support 64-bit float operations.</p>
               
               <pre><code>const EffectiveFloatRegSize = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EffectiveFloatRegSize" data-name="EffectiveFloatRegSize">
               <h3>
                  EffectiveFloatRegSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EffectiveFloatRegSize" class="anchor" title="Link to EffectiveFloatRegSize">#</a>
               </h3>
               
               <pre><code>const EffectiveFloatRegSize = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EffectiveFloatRegSize" data-name="EffectiveFloatRegSize">
               <h3>
                  EffectiveFloatRegSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EffectiveFloatRegSize" class="anchor" title="Link to EffectiveFloatRegSize">#</a>
               </h3>
               
               <pre><code>const EffectiveFloatRegSize = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EffectiveFloatRegSize" data-name="EffectiveFloatRegSize">
               <h3>
                  EffectiveFloatRegSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EffectiveFloatRegSize" class="anchor" title="Link to EffectiveFloatRegSize">#</a>
               </h3>
               
               <p>EffectiveFloatRegSize describes the width of floating point
registers on the current platform from the ABI's perspective.
Since Go only supports 32-bit and 64-bit floating point primitives,
this number should be either 0, 4, or 8. 0 indicates no floating
point registers for the ABI or that floating point values will be
passed via the softfloat ABI.
For platforms that support larger floating point register widths,
such as x87's 80-bit "registers" (not that we support x87 currently),
use 8.</p>
               
               <pre><code>const EffectiveFloatRegSize = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="EffectiveFloatRegSize" data-name="EffectiveFloatRegSize">
               <h3>
                  EffectiveFloatRegSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#EffectiveFloatRegSize" class="anchor" title="Link to EffectiveFloatRegSize">#</a>
               </h3>
               
               <pre><code>const EffectiveFloatRegSize = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FUNCDATA_ArgInfo" data-name="FUNCDATA_ArgInfo">
               <h3>
                  FUNCDATA_ArgInfo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FUNCDATA_ArgInfo" class="anchor" title="Link to FUNCDATA_ArgInfo">#</a>
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_ArgInfo = 5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FUNCDATA_ArgLiveInfo" data-name="FUNCDATA_ArgLiveInfo">
               <h3>
                  FUNCDATA_ArgLiveInfo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FUNCDATA_ArgLiveInfo" class="anchor" title="Link to FUNCDATA_ArgLiveInfo">#</a>
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_ArgLiveInfo = 6</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FUNCDATA_ArgsPointerMaps" data-name="FUNCDATA_ArgsPointerMaps">
               <h3>
                  FUNCDATA_ArgsPointerMaps 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FUNCDATA_ArgsPointerMaps" class="anchor" title="Link to FUNCDATA_ArgsPointerMaps">#</a>
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_ArgsPointerMaps = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FUNCDATA_InlTree" data-name="FUNCDATA_InlTree">
               <h3>
                  FUNCDATA_InlTree 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FUNCDATA_InlTree" class="anchor" title="Link to FUNCDATA_InlTree">#</a>
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_InlTree = 3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FUNCDATA_LocalsPointerMaps" data-name="FUNCDATA_LocalsPointerMaps">
               <h3>
                  FUNCDATA_LocalsPointerMaps 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FUNCDATA_LocalsPointerMaps" class="anchor" title="Link to FUNCDATA_LocalsPointerMaps">#</a>
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_LocalsPointerMaps = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FUNCDATA_OpenCodedDeferInfo" data-name="FUNCDATA_OpenCodedDeferInfo">
               <h3>
                  FUNCDATA_OpenCodedDeferInfo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FUNCDATA_OpenCodedDeferInfo" class="anchor" title="Link to FUNCDATA_OpenCodedDeferInfo">#</a>
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_OpenCodedDeferInfo = 4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FUNCDATA_StackObjects" data-name="FUNCDATA_StackObjects">
               <h3>
                  FUNCDATA_StackObjects 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FUNCDATA_StackObjects" class="anchor" title="Link to FUNCDATA_StackObjects">#</a>
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_StackObjects = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FUNCDATA_WrapInfo" data-name="FUNCDATA_WrapInfo">
               <h3>
                  FUNCDATA_WrapInfo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FUNCDATA_WrapInfo" class="anchor" title="Link to FUNCDATA_WrapInfo">#</a>
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_WrapInfo = 7</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Float32" data-name="Float32">
               <h3>
                  Float32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Float32" class="anchor" title="Link to Float32">#</a>
               </h3>
               
               <pre><code>const Float32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Float64" data-name="Float64">
               <h3>
                  Float64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Float64" class="anchor" title="Link to Float64">#</a>
               </h3>
               
               <pre><code>const Float64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FloatArgRegs" data-name="FloatArgRegs">
               <h3>
                  FloatArgRegs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FloatArgRegs" class="anchor" title="Link to FloatArgRegs">#</a>
               </h3>
               
               <p>X0 -> X14.</p>
               
               <pre><code>const FloatArgRegs = 15</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FloatArgRegs" data-name="FloatArgRegs">
               <h3>
                  FloatArgRegs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FloatArgRegs" class="anchor" title="Link to FloatArgRegs">#</a>
               </h3>
               
               <p>F8 - F23.</p>
               
               <pre><code>const FloatArgRegs = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FloatArgRegs" data-name="FloatArgRegs">
               <h3>
                  FloatArgRegs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FloatArgRegs" class="anchor" title="Link to FloatArgRegs">#</a>
               </h3>
               
               <p>FloatArgRegs is the number of registers dedicated
to passing floating-point argument values. Result registers are
identical to argument registers, so this number is used for
those too.</p>
               
               <pre><code>const FloatArgRegs = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FloatArgRegs" data-name="FloatArgRegs">
               <h3>
                  FloatArgRegs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FloatArgRegs" class="anchor" title="Link to FloatArgRegs">#</a>
               </h3>
               
               <p>F0 - F15.</p>
               
               <pre><code>const FloatArgRegs = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FloatArgRegs" data-name="FloatArgRegs">
               <h3>
                  FloatArgRegs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FloatArgRegs" class="anchor" title="Link to FloatArgRegs">#</a>
               </h3>
               
               <p>F1 - F12.</p>
               
               <pre><code>const FloatArgRegs = 12</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FloatArgRegs" data-name="FloatArgRegs">
               <h3>
                  FloatArgRegs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FloatArgRegs" class="anchor" title="Link to FloatArgRegs">#</a>
               </h3>
               
               <p>F0 - F15</p>
               
               <pre><code>const FloatArgRegs = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Func" data-name="Func">
               <h3>
                  Func 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Func" class="anchor" title="Link to Func">#</a>
               </h3>
               
               <pre><code>const Func</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncFlagAsm" data-name="FuncFlagAsm">
               <h3>
                  FuncFlagAsm 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncFlagAsm" class="anchor" title="Link to FuncFlagAsm">#</a>
               </h3>
               
               <p>FuncFlagAsm indicates that a function was implemented in assembly.</p>
               
               <pre><code>const FuncFlagAsm</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncFlagSPWrite" data-name="FuncFlagSPWrite">
               <h3>
                  FuncFlagSPWrite 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncFlagSPWrite" class="anchor" title="Link to FuncFlagSPWrite">#</a>
               </h3>
               
               <p>FuncFlagSPWrite indicates a function that writes an arbitrary value to SP
(any write other than adding or subtracting a constant amount).
The traceback routines cannot encode such changes into the
pcsp tables, so the function traceback cannot safely unwind past
SPWrite functions. Stopping at an SPWrite function is considered
to be an incomplete unwinding of the stack. In certain contexts
(in particular garbage collector stack scans) that is a fatal error.</p>
               
               <pre><code>const FuncFlagSPWrite</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncFlagTopFrame" data-name="FuncFlagTopFrame">
               <h3>
                  FuncFlagTopFrame 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncFlagTopFrame" class="anchor" title="Link to FuncFlagTopFrame">#</a>
               </h3>
               
               <p>FuncFlagTopFrame indicates a function that appears at the top of its stack.
The traceback routine stop at such a function and consider that a
successful, complete traversal of the stack.
Examples of TopFrame functions include goexit, which appears
at the top of a user goroutine stack, and mstart, which appears
at the top of a system goroutine stack.</p>
               
               <pre><code>const FuncFlagTopFrame FuncFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncIDNormal" data-name="FuncIDNormal">
               <h3>
                  FuncIDNormal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncIDNormal" class="anchor" title="Link to FuncIDNormal">#</a>
               </h3>
               
               <pre><code>const FuncIDNormal FuncID = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncIDWrapper" data-name="FuncIDWrapper">
               <h3>
                  FuncIDWrapper 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncIDWrapper" class="anchor" title="Link to FuncIDWrapper">#</a>
               </h3>
               
               <pre><code>const FuncIDWrapper</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_abort" data-name="FuncID_abort">
               <h3>
                  FuncID_abort 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_abort" class="anchor" title="Link to FuncID_abort">#</a>
               </h3>
               
               <pre><code>const FuncID_abort</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_asmcgocall" data-name="FuncID_asmcgocall">
               <h3>
                  FuncID_asmcgocall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_asmcgocall" class="anchor" title="Link to FuncID_asmcgocall">#</a>
               </h3>
               
               <pre><code>const FuncID_asmcgocall</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_asyncPreempt" data-name="FuncID_asyncPreempt">
               <h3>
                  FuncID_asyncPreempt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_asyncPreempt" class="anchor" title="Link to FuncID_asyncPreempt">#</a>
               </h3>
               
               <pre><code>const FuncID_asyncPreempt</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_cgocallback" data-name="FuncID_cgocallback">
               <h3>
                  FuncID_cgocallback 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_cgocallback" class="anchor" title="Link to FuncID_cgocallback">#</a>
               </h3>
               
               <pre><code>const FuncID_cgocallback</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_corostart" data-name="FuncID_corostart">
               <h3>
                  FuncID_corostart 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_corostart" class="anchor" title="Link to FuncID_corostart">#</a>
               </h3>
               
               <pre><code>const FuncID_corostart</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_debugCallV2" data-name="FuncID_debugCallV2">
               <h3>
                  FuncID_debugCallV2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_debugCallV2" class="anchor" title="Link to FuncID_debugCallV2">#</a>
               </h3>
               
               <pre><code>const FuncID_debugCallV2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_gcBgMarkWorker" data-name="FuncID_gcBgMarkWorker">
               <h3>
                  FuncID_gcBgMarkWorker 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_gcBgMarkWorker" class="anchor" title="Link to FuncID_gcBgMarkWorker">#</a>
               </h3>
               
               <pre><code>const FuncID_gcBgMarkWorker</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_goexit" data-name="FuncID_goexit">
               <h3>
                  FuncID_goexit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_goexit" class="anchor" title="Link to FuncID_goexit">#</a>
               </h3>
               
               <pre><code>const FuncID_goexit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_gogo" data-name="FuncID_gogo">
               <h3>
                  FuncID_gogo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_gogo" class="anchor" title="Link to FuncID_gogo">#</a>
               </h3>
               
               <pre><code>const FuncID_gogo</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_gopanic" data-name="FuncID_gopanic">
               <h3>
                  FuncID_gopanic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_gopanic" class="anchor" title="Link to FuncID_gopanic">#</a>
               </h3>
               
               <pre><code>const FuncID_gopanic</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_handleAsyncEvent" data-name="FuncID_handleAsyncEvent">
               <h3>
                  FuncID_handleAsyncEvent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_handleAsyncEvent" class="anchor" title="Link to FuncID_handleAsyncEvent">#</a>
               </h3>
               
               <pre><code>const FuncID_handleAsyncEvent</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_mcall" data-name="FuncID_mcall">
               <h3>
                  FuncID_mcall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_mcall" class="anchor" title="Link to FuncID_mcall">#</a>
               </h3>
               
               <pre><code>const FuncID_mcall</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_morestack" data-name="FuncID_morestack">
               <h3>
                  FuncID_morestack 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_morestack" class="anchor" title="Link to FuncID_morestack">#</a>
               </h3>
               
               <pre><code>const FuncID_morestack</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_mstart" data-name="FuncID_mstart">
               <h3>
                  FuncID_mstart 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_mstart" class="anchor" title="Link to FuncID_mstart">#</a>
               </h3>
               
               <pre><code>const FuncID_mstart</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_panicwrap" data-name="FuncID_panicwrap">
               <h3>
                  FuncID_panicwrap 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_panicwrap" class="anchor" title="Link to FuncID_panicwrap">#</a>
               </h3>
               
               <pre><code>const FuncID_panicwrap</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_rt0_go" data-name="FuncID_rt0_go">
               <h3>
                  FuncID_rt0_go 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_rt0_go" class="anchor" title="Link to FuncID_rt0_go">#</a>
               </h3>
               
               <pre><code>const FuncID_rt0_go</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_runfinq" data-name="FuncID_runfinq">
               <h3>
                  FuncID_runfinq 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_runfinq" class="anchor" title="Link to FuncID_runfinq">#</a>
               </h3>
               
               <pre><code>const FuncID_runfinq</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_runtime_main" data-name="FuncID_runtime_main">
               <h3>
                  FuncID_runtime_main 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_runtime_main" class="anchor" title="Link to FuncID_runtime_main">#</a>
               </h3>
               
               <pre><code>const FuncID_runtime_main</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_sigpanic" data-name="FuncID_sigpanic">
               <h3>
                  FuncID_sigpanic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_sigpanic" class="anchor" title="Link to FuncID_sigpanic">#</a>
               </h3>
               
               <pre><code>const FuncID_sigpanic</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_systemstack" data-name="FuncID_systemstack">
               <h3>
                  FuncID_systemstack 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_systemstack" class="anchor" title="Link to FuncID_systemstack">#</a>
               </h3>
               
               <pre><code>const FuncID_systemstack</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncID_systemstack_switch" data-name="FuncID_systemstack_switch">
               <h3>
                  FuncID_systemstack_switch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncID_systemstack_switch" class="anchor" title="Link to FuncID_systemstack_switch">#</a>
               </h3>
               
               <pre><code>const FuncID_systemstack_switch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="FuncTabBucketSize" data-name="FuncTabBucketSize">
               <h3>
                  FuncTabBucketSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#FuncTabBucketSize" class="anchor" title="Link to FuncTabBucketSize">#</a>
               </h3>
               
               <pre><code>const FuncTabBucketSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int" data-name="Int">
               <h3>
                  Int 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int" class="anchor" title="Link to Int">#</a>
               </h3>
               
               <pre><code>const Int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int16" data-name="Int16">
               <h3>
                  Int16 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int16" class="anchor" title="Link to Int16">#</a>
               </h3>
               
               <pre><code>const Int16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int32" data-name="Int32">
               <h3>
                  Int32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int32" class="anchor" title="Link to Int32">#</a>
               </h3>
               
               <pre><code>const Int32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int64" data-name="Int64">
               <h3>
                  Int64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int64" class="anchor" title="Link to Int64">#</a>
               </h3>
               
               <pre><code>const Int64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Int8" data-name="Int8">
               <h3>
                  Int8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Int8" class="anchor" title="Link to Int8">#</a>
               </h3>
               
               <pre><code>const Int8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IntArgRegs" data-name="IntArgRegs">
               <h3>
                  IntArgRegs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IntArgRegs" class="anchor" title="Link to IntArgRegs">#</a>
               </h3>
               
               <p>R0 - R15.</p>
               
               <pre><code>const IntArgRegs = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IntArgRegs" data-name="IntArgRegs">
               <h3>
                  IntArgRegs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IntArgRegs" class="anchor" title="Link to IntArgRegs">#</a>
               </h3>
               
               <p>IntArgRegs is the number of registers dedicated
to passing integer argument values. Result registers are identical
to argument registers, so this number is used for those too.</p>
               
               <pre><code>const IntArgRegs = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IntArgRegs" data-name="IntArgRegs">
               <h3>
                  IntArgRegs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IntArgRegs" class="anchor" title="Link to IntArgRegs">#</a>
               </h3>
               
               <p>RAX, RBX, RCX, RDI, RSI, R8, R9, R10, R11.</p>
               
               <pre><code>const IntArgRegs = 9</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IntArgRegs" data-name="IntArgRegs">
               <h3>
                  IntArgRegs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IntArgRegs" class="anchor" title="Link to IntArgRegs">#</a>
               </h3>
               
               <p>R3 - R10, R14 - R17.</p>
               
               <pre><code>const IntArgRegs = 12</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IntArgRegs" data-name="IntArgRegs">
               <h3>
                  IntArgRegs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IntArgRegs" class="anchor" title="Link to IntArgRegs">#</a>
               </h3>
               
               <p>X8 - X23</p>
               
               <pre><code>const IntArgRegs = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IntArgRegs" data-name="IntArgRegs">
               <h3>
                  IntArgRegs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IntArgRegs" class="anchor" title="Link to IntArgRegs">#</a>
               </h3>
               
               <p>R4 - R19</p>
               
               <pre><code>const IntArgRegs = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Interface" data-name="Interface">
               <h3>
                  Interface 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Interface" class="anchor" title="Link to Interface">#</a>
               </h3>
               
               <pre><code>const Interface</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Invalid" data-name="Invalid">
               <h3>
                  Invalid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Invalid" class="anchor" title="Link to Invalid">#</a>
               </h3>
               
               <pre><code>const Invalid Kind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidDir" data-name="InvalidDir">
               <h3>
                  InvalidDir 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidDir" class="anchor" title="Link to InvalidDir">#</a>
               </h3>
               
               <pre><code>const InvalidDir ChanDir = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindDirectIface" data-name="KindDirectIface">
               <h3>
                  KindDirectIface 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindDirectIface" class="anchor" title="Link to KindDirectIface">#</a>
               </h3>
               
               <p>TODO (khr, drchase) why aren't these in TFlag?  Investigate, fix if possible.</p>
               
               <pre><code>const KindDirectIface Kind = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindMask" data-name="KindMask">
               <h3>
                  KindMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindMask" class="anchor" title="Link to KindMask">#</a>
               </h3>
               
               <pre><code>const KindMask Kind = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MINFUNC" data-name="MINFUNC">
               <h3>
                  MINFUNC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MINFUNC" class="anchor" title="Link to MINFUNC">#</a>
               </h3>
               
               <pre><code>const MINFUNC = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Map" data-name="Map">
               <h3>
                  Map 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Map" class="anchor" title="Link to Map">#</a>
               </h3>
               
               <pre><code>const Map</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MaxPtrmaskBytes" data-name="MaxPtrmaskBytes">
               <h3>
                  MaxPtrmaskBytes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MaxPtrmaskBytes" class="anchor" title="Link to MaxPtrmaskBytes">#</a>
               </h3>
               
               <p>MaxPtrmaskBytes is the maximum length of a GC ptrmask bitmap,
which holds 1-bit entries describing where pointers are in a given type.
Above this length, the GC information is recorded as a GC program,
which can express repetition compactly. In either form, the
information is used by the runtime to initialize the heap bitmap,
and for large types (like 128 or more words), they are roughly the
same speed. GC programs are never much larger and often more
compact. (If large arrays are involved, they can be arbitrarily
more compact.)
The cutoff must be large enough that any allocation large enough to
use a GC program is large enough that it does not share heap bitmap
bytes with any other objects, allowing the GC program execution to
assume an aligned start and not use atomic operations. In the current
runtime, this means all malloc size classes larger than the cutoff must
be multiples of four words. On 32-bit systems that's 16 bytes, and
all size classes >= 16 bytes are 16-byte aligned, so no real constraint.
On 64-bit systems, that's 32 bytes, and 32-byte alignment is guaranteed
for size classes >= 256 bytes. On a 64-bit system, 256 bytes allocated
is 32 pointers, the bits for which fit in 4 bytes. So MaxPtrmaskBytes
must be >= 4.
We used to use 16 because the GC programs do have some constant overhead
to get started, and processing 128 pointers seems to be enough to
amortize that overhead well.
To make sure that the runtime's chansend can call typeBitsBulkBarrier,
we raised the limit to 2048, so that even 32-bit systems are guaranteed to
use bitmaps for objects up to 64 kB in size.</p>
               
               <pre><code>const MaxPtrmaskBytes = 2048</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OldMapBucketCount" data-name="OldMapBucketCount">
               <h3>
                  OldMapBucketCount 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OldMapBucketCount" class="anchor" title="Link to OldMapBucketCount">#</a>
               </h3>
               
               <p>Map constants common to several packages
runtime/runtime-gdb.py:MapTypePrinter contains its own copy</p>
               
               <pre><code>const OldMapBucketCount = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OldMapBucketCountBits" data-name="OldMapBucketCountBits">
               <h3>
                  OldMapBucketCountBits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OldMapBucketCountBits" class="anchor" title="Link to OldMapBucketCountBits">#</a>
               </h3>
               
               <p>Maximum number of key/elem pairs a bucket can hold.</p>
               
               <pre><code>const OldMapBucketCountBits = 3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OldMapMaxElemBytes" data-name="OldMapMaxElemBytes">
               <h3>
                  OldMapMaxElemBytes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OldMapMaxElemBytes" class="anchor" title="Link to OldMapMaxElemBytes">#</a>
               </h3>
               
               <p>Map constants common to several packages
runtime/runtime-gdb.py:MapTypePrinter contains its own copy</p>
               
               <pre><code>const OldMapMaxElemBytes = 128</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OldMapMaxKeyBytes" data-name="OldMapMaxKeyBytes">
               <h3>
                  OldMapMaxKeyBytes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OldMapMaxKeyBytes" class="anchor" title="Link to OldMapMaxKeyBytes">#</a>
               </h3>
               
               <p>Maximum key or elem size to keep inline (instead of mallocing per element).
Must fit in a uint8.
Note: fast map functions cannot handle big elems (bigger than MapMaxElemBytes).</p>
               
               <pre><code>const OldMapMaxKeyBytes = 128</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PCDATA_ArgLiveIndex" data-name="PCDATA_ArgLiveIndex">
               <h3>
                  PCDATA_ArgLiveIndex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PCDATA_ArgLiveIndex" class="anchor" title="Link to PCDATA_ArgLiveIndex">#</a>
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const PCDATA_ArgLiveIndex = 3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PCDATA_InlTreeIndex" data-name="PCDATA_InlTreeIndex">
               <h3>
                  PCDATA_InlTreeIndex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PCDATA_InlTreeIndex" class="anchor" title="Link to PCDATA_InlTreeIndex">#</a>
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const PCDATA_InlTreeIndex = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PCDATA_StackMapIndex" data-name="PCDATA_StackMapIndex">
               <h3>
                  PCDATA_StackMapIndex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PCDATA_StackMapIndex" class="anchor" title="Link to PCDATA_StackMapIndex">#</a>
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const PCDATA_StackMapIndex = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PCDATA_UnsafePoint" data-name="PCDATA_UnsafePoint">
               <h3>
                  PCDATA_UnsafePoint 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PCDATA_UnsafePoint" class="anchor" title="Link to PCDATA_UnsafePoint">#</a>
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const PCDATA_UnsafePoint = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Pointer" data-name="Pointer">
               <h3>
                  Pointer 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Pointer" class="anchor" title="Link to Pointer">#</a>
               </h3>
               
               <pre><code>const Pointer</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RF_DONE" data-name="RF_DONE">
               <h3>
                  RF_DONE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RF_DONE" class="anchor" title="Link to RF_DONE">#</a>
               </h3>
               
               <p>These constants are shared between the compiler, which uses them for state functions
and panic indicators, and the runtime, which turns them into more meaningful strings
For best code generation, RF_DONE and RF_READY should be 0 and 1.</p>
               
               <pre><code>const RF_DONE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RF_EXHAUSTED" data-name="RF_EXHAUSTED">
               <h3>
                  RF_EXHAUSTED 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RF_EXHAUSTED" class="anchor" title="Link to RF_EXHAUSTED">#</a>
               </h3>
               
               <p>These constants are shared between the compiler, which uses them for state functions
and panic indicators, and the runtime, which turns them into more meaningful strings
For best code generation, RF_DONE and RF_READY should be 0 and 1.</p>
               
               <pre><code>const RF_EXHAUSTED</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RF_MISSING_PANIC" data-name="RF_MISSING_PANIC">
               <h3>
                  RF_MISSING_PANIC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RF_MISSING_PANIC" class="anchor" title="Link to RF_MISSING_PANIC">#</a>
               </h3>
               
               <p>These constants are shared between the compiler, which uses them for state functions
and panic indicators, and the runtime, which turns them into more meaningful strings
For best code generation, RF_DONE and RF_READY should be 0 and 1.</p>
               
               <pre><code>const RF_MISSING_PANIC = 4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RF_PANIC" data-name="RF_PANIC">
               <h3>
                  RF_PANIC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RF_PANIC" class="anchor" title="Link to RF_PANIC">#</a>
               </h3>
               
               <p>These constants are shared between the compiler, which uses them for state functions
and panic indicators, and the runtime, which turns them into more meaningful strings
For best code generation, RF_DONE and RF_READY should be 0 and 1.</p>
               
               <pre><code>const RF_PANIC</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RF_READY" data-name="RF_READY">
               <h3>
                  RF_READY 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RF_READY" class="anchor" title="Link to RF_READY">#</a>
               </h3>
               
               <p>These constants are shared between the compiler, which uses them for state functions
and panic indicators, and the runtime, which turns them into more meaningful strings
For best code generation, RF_DONE and RF_READY should be 0 and 1.</p>
               
               <pre><code>const RF_READY</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RecvDir" data-name="RecvDir">
               <h3>
                  RecvDir 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RecvDir" class="anchor" title="Link to RecvDir">#</a>
               </h3>
               
               <pre><code>const RecvDir ChanDir = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SendDir" data-name="SendDir">
               <h3>
                  SendDir 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SendDir" class="anchor" title="Link to SendDir">#</a>
               </h3>
               
               <pre><code>const SendDir</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Slice" data-name="Slice">
               <h3>
                  Slice 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Slice" class="anchor" title="Link to Slice">#</a>
               </h3>
               
               <pre><code>const Slice</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StackBig" data-name="StackBig">
               <h3>
                  StackBig 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StackBig" class="anchor" title="Link to StackBig">#</a>
               </h3>
               
               <p>Functions that need frames <= StackBig can assume that neither
SP-framesize nor stackGuard-StackSmall will underflow, and thus use a
more efficient check. In order to ensure this, StackBig must be <= the
size of the unmapped space at zero.</p>
               
               <pre><code>const StackBig = 4096</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StackNosplitBase" data-name="StackNosplitBase">
               <h3>
                  StackNosplitBase 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StackNosplitBase" class="anchor" title="Link to StackNosplitBase">#</a>
               </h3>
               
               <p>StackNosplitBase is the base maximum number of bytes that a chain of
NOSPLIT functions can use.
This value must be multiplied by the stack guard multiplier, so do not
use it directly. See runtime/stack.go:stackNosplit and
cmd/internal/objabi/stack.go:StackNosplit.</p>
               
               <pre><code>const StackNosplitBase = 800</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StackSmall" data-name="StackSmall">
               <h3>
                  StackSmall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StackSmall" class="anchor" title="Link to StackSmall">#</a>
               </h3>
               
               <p>After a stack split check the SP is allowed to be StackSmall bytes below
the stack guard.
Functions that need frames <= StackSmall can perform the stack check
using a single comparison directly between the stack guard and the SP
because we ensure that StackSmall bytes of stack space are available
beyond the stack guard.</p>
               
               <pre><code>const StackSmall = 128</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>const String</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Struct" data-name="Struct">
               <h3>
                  Struct 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Struct" class="anchor" title="Link to Struct">#</a>
               </h3>
               
               <pre><code>const Struct</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SwissMapCtrlEmpty" data-name="SwissMapCtrlEmpty">
               <h3>
                  SwissMapCtrlEmpty 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SwissMapCtrlEmpty" class="anchor" title="Link to SwissMapCtrlEmpty">#</a>
               </h3>
               
               <p>Value of control word with all empty slots.</p>
               
               <pre><code>const SwissMapCtrlEmpty = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SwissMapGroupSlots" data-name="SwissMapGroupSlots">
               <h3>
                  SwissMapGroupSlots 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SwissMapGroupSlots" class="anchor" title="Link to SwissMapGroupSlots">#</a>
               </h3>
               
               <p>Number of slots in a group.</p>
               
               <pre><code>const SwissMapGroupSlots = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SwissMapGroupSlotsBits" data-name="SwissMapGroupSlotsBits">
               <h3>
                  SwissMapGroupSlotsBits 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SwissMapGroupSlotsBits" class="anchor" title="Link to SwissMapGroupSlotsBits">#</a>
               </h3>
               
               <p>Number of bits in the group.slot count.</p>
               
               <pre><code>const SwissMapGroupSlotsBits = 3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SwissMapHashMightPanic" data-name="SwissMapHashMightPanic">
               <h3>
                  SwissMapHashMightPanic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SwissMapHashMightPanic" class="anchor" title="Link to SwissMapHashMightPanic">#</a>
               </h3>
               
               <p>Flag values</p>
               
               <pre><code>const SwissMapHashMightPanic</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SwissMapIndirectElem" data-name="SwissMapIndirectElem">
               <h3>
                  SwissMapIndirectElem 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SwissMapIndirectElem" class="anchor" title="Link to SwissMapIndirectElem">#</a>
               </h3>
               
               <p>Flag values</p>
               
               <pre><code>const SwissMapIndirectElem</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SwissMapIndirectKey" data-name="SwissMapIndirectKey">
               <h3>
                  SwissMapIndirectKey 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SwissMapIndirectKey" class="anchor" title="Link to SwissMapIndirectKey">#</a>
               </h3>
               
               <p>Flag values</p>
               
               <pre><code>const SwissMapIndirectKey</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SwissMapMaxElemBytes" data-name="SwissMapMaxElemBytes">
               <h3>
                  SwissMapMaxElemBytes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SwissMapMaxElemBytes" class="anchor" title="Link to SwissMapMaxElemBytes">#</a>
               </h3>
               
               <p>Map constants common to several packages
runtime/runtime-gdb.py:MapTypePrinter contains its own copy</p>
               
               <pre><code>const SwissMapMaxElemBytes = 128</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SwissMapMaxKeyBytes" data-name="SwissMapMaxKeyBytes">
               <h3>
                  SwissMapMaxKeyBytes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SwissMapMaxKeyBytes" class="anchor" title="Link to SwissMapMaxKeyBytes">#</a>
               </h3>
               
               <p>Maximum key or elem size to keep inline (instead of mallocing per element).
Must fit in a uint8.</p>
               
               <pre><code>const SwissMapMaxKeyBytes = 128</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SwissMapNeedKeyUpdate" data-name="SwissMapNeedKeyUpdate">
               <h3>
                  SwissMapNeedKeyUpdate 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SwissMapNeedKeyUpdate" class="anchor" title="Link to SwissMapNeedKeyUpdate">#</a>
               </h3>
               
               <p>Flag values</p>
               
               <pre><code>const SwissMapNeedKeyUpdate = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TFlagExtraStar" data-name="TFlagExtraStar">
               <h3>
                  TFlagExtraStar 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TFlagExtraStar" class="anchor" title="Link to TFlagExtraStar">#</a>
               </h3>
               
               <p>TFlagExtraStar means the name in the str field has an
extraneous '*' prefix. This is because for most types T in
a program, the type *T also exists and reusing the str data
saves binary size.</p>
               
               <pre><code>const TFlagExtraStar TFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TFlagGCMaskOnDemand" data-name="TFlagGCMaskOnDemand">
               <h3>
                  TFlagGCMaskOnDemand 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TFlagGCMaskOnDemand" class="anchor" title="Link to TFlagGCMaskOnDemand">#</a>
               </h3>
               
               <p>TFlagGCMaskOnDemand means that the GC pointer bitmask will be
computed on demand at runtime instead of being precomputed at
compile time. If this flag is set, the GCData field effectively
has type **byte instead of *byte. The runtime will store a
pointer to the GC pointer bitmask in *GCData.</p>
               
               <pre><code>const TFlagGCMaskOnDemand TFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TFlagNamed" data-name="TFlagNamed">
               <h3>
                  TFlagNamed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TFlagNamed" class="anchor" title="Link to TFlagNamed">#</a>
               </h3>
               
               <p>TFlagNamed means the type has a name.</p>
               
               <pre><code>const TFlagNamed TFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TFlagRegularMemory" data-name="TFlagRegularMemory">
               <h3>
                  TFlagRegularMemory 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TFlagRegularMemory" class="anchor" title="Link to TFlagRegularMemory">#</a>
               </h3>
               
               <p>TFlagRegularMemory means that equal and hash functions can treat
this type as a single region of t.size bytes.</p>
               
               <pre><code>const TFlagRegularMemory TFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TFlagUncommon" data-name="TFlagUncommon">
               <h3>
                  TFlagUncommon 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TFlagUncommon" class="anchor" title="Link to TFlagUncommon">#</a>
               </h3>
               
               <p>TFlagUncommon means that there is a data with a type, UncommonType,
just beyond the shared-per-type common data.  That is, the data
for struct types will store their UncommonType at one offset, the
data for interface types will store their UncommonType at a different
offset.  UncommonType is always accessed via a pointer that is computed
using trust-us-we-are-the-implementors pointer arithmetic.
For example, if t.Kind() == Struct and t.tflag&TFlagUncommon != 0,
then t has UncommonType data and it can be accessed as:
type structTypeUncommon struct {
structType
u UncommonType
}
u := &(*structTypeUncommon)(unsafe.Pointer(t)).u</p>
               
               <pre><code>const TFlagUncommon TFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TraceArgsDotdotdot" data-name="TraceArgsDotdotdot">
               <h3>
                  TraceArgsDotdotdot 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TraceArgsDotdotdot" class="anchor" title="Link to TraceArgsDotdotdot">#</a>
               </h3>
               
               <p>Populate the data.
The data is a stream of bytes, which contains the offsets and sizes of the
non-aggregate arguments or non-aggregate fields/elements of aggregate-typed
arguments, along with special "operators". Specifically,
- for each non-aggregate arg/field/element, its offset from FP (1 byte) and
size (1 byte)
- special operators:
- 0xff - end of sequence
- 0xfe - print { (at the start of an aggregate-typed argument)
- 0xfd - print } (at the end of an aggregate-typed argument)
- 0xfc - print ... (more args/fields/elements)
- 0xfb - print _ (offset too large)</p>
               
               <pre><code>const TraceArgsDotdotdot = 0xfc</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TraceArgsEndAgg" data-name="TraceArgsEndAgg">
               <h3>
                  TraceArgsEndAgg 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TraceArgsEndAgg" class="anchor" title="Link to TraceArgsEndAgg">#</a>
               </h3>
               
               <p>Populate the data.
The data is a stream of bytes, which contains the offsets and sizes of the
non-aggregate arguments or non-aggregate fields/elements of aggregate-typed
arguments, along with special "operators". Specifically,
- for each non-aggregate arg/field/element, its offset from FP (1 byte) and
size (1 byte)
- special operators:
- 0xff - end of sequence
- 0xfe - print { (at the start of an aggregate-typed argument)
- 0xfd - print } (at the end of an aggregate-typed argument)
- 0xfc - print ... (more args/fields/elements)
- 0xfb - print _ (offset too large)</p>
               
               <pre><code>const TraceArgsEndAgg = 0xfd</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TraceArgsEndSeq" data-name="TraceArgsEndSeq">
               <h3>
                  TraceArgsEndSeq 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TraceArgsEndSeq" class="anchor" title="Link to TraceArgsEndSeq">#</a>
               </h3>
               
               <p>Populate the data.
The data is a stream of bytes, which contains the offsets and sizes of the
non-aggregate arguments or non-aggregate fields/elements of aggregate-typed
arguments, along with special "operators". Specifically,
- for each non-aggregate arg/field/element, its offset from FP (1 byte) and
size (1 byte)
- special operators:
- 0xff - end of sequence
- 0xfe - print { (at the start of an aggregate-typed argument)
- 0xfd - print } (at the end of an aggregate-typed argument)
- 0xfc - print ... (more args/fields/elements)
- 0xfb - print _ (offset too large)</p>
               
               <pre><code>const TraceArgsEndSeq = 0xff</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TraceArgsLimit" data-name="TraceArgsLimit">
               <h3>
                  TraceArgsLimit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TraceArgsLimit" class="anchor" title="Link to TraceArgsLimit">#</a>
               </h3>
               
               <pre><code>const TraceArgsLimit = 10</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TraceArgsMaxDepth" data-name="TraceArgsMaxDepth">
               <h3>
                  TraceArgsMaxDepth 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TraceArgsMaxDepth" class="anchor" title="Link to TraceArgsMaxDepth">#</a>
               </h3>
               
               <pre><code>const TraceArgsMaxDepth = 5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TraceArgsMaxLen" data-name="TraceArgsMaxLen">
               <h3>
                  TraceArgsMaxLen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TraceArgsMaxLen" class="anchor" title="Link to TraceArgsMaxLen">#</a>
               </h3>
               
               <p>maxLen is a (conservative) upper bound of the byte stream length. For
each arg/component, it has no more than 2 bytes of data (size, offset),
and no more than one {, }, ... at each level (it cannot have both the
data and ... unless it is the last one, just be conservative). Plus 1
for _endSeq.</p>
               
               <pre><code>const TraceArgsMaxLen = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TraceArgsOffsetTooLarge" data-name="TraceArgsOffsetTooLarge">
               <h3>
                  TraceArgsOffsetTooLarge 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TraceArgsOffsetTooLarge" class="anchor" title="Link to TraceArgsOffsetTooLarge">#</a>
               </h3>
               
               <p>Populate the data.
The data is a stream of bytes, which contains the offsets and sizes of the
non-aggregate arguments or non-aggregate fields/elements of aggregate-typed
arguments, along with special "operators". Specifically,
- for each non-aggregate arg/field/element, its offset from FP (1 byte) and
size (1 byte)
- special operators:
- 0xff - end of sequence
- 0xfe - print { (at the start of an aggregate-typed argument)
- 0xfd - print } (at the end of an aggregate-typed argument)
- 0xfc - print ... (more args/fields/elements)
- 0xfb - print _ (offset too large)</p>
               
               <pre><code>const TraceArgsOffsetTooLarge = 0xfb</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TraceArgsSpecial" data-name="TraceArgsSpecial">
               <h3>
                  TraceArgsSpecial 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TraceArgsSpecial" class="anchor" title="Link to TraceArgsSpecial">#</a>
               </h3>
               
               <p>Populate the data.
The data is a stream of bytes, which contains the offsets and sizes of the
non-aggregate arguments or non-aggregate fields/elements of aggregate-typed
arguments, along with special "operators". Specifically,
- for each non-aggregate arg/field/element, its offset from FP (1 byte) and
size (1 byte)
- special operators:
- 0xff - end of sequence
- 0xfe - print { (at the start of an aggregate-typed argument)
- 0xfd - print } (at the end of an aggregate-typed argument)
- 0xfc - print ... (more args/fields/elements)
- 0xfb - print _ (offset too large)</p>
               
               <pre><code>const TraceArgsSpecial = 0xf0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TraceArgsStartAgg" data-name="TraceArgsStartAgg">
               <h3>
                  TraceArgsStartAgg 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TraceArgsStartAgg" class="anchor" title="Link to TraceArgsStartAgg">#</a>
               </h3>
               
               <p>Populate the data.
The data is a stream of bytes, which contains the offsets and sizes of the
non-aggregate arguments or non-aggregate fields/elements of aggregate-typed
arguments, along with special "operators". Specifically,
- for each non-aggregate arg/field/element, its offset from FP (1 byte) and
size (1 byte)
- special operators:
- 0xff - end of sequence
- 0xfe - print { (at the start of an aggregate-typed argument)
- 0xfd - print } (at the end of an aggregate-typed argument)
- 0xfc - print ... (more args/fields/elements)
- 0xfb - print _ (offset too large)</p>
               
               <pre><code>const TraceArgsStartAgg = 0xfe</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint" data-name="Uint">
               <h3>
                  Uint 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint" class="anchor" title="Link to Uint">#</a>
               </h3>
               
               <pre><code>const Uint</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint16" data-name="Uint16">
               <h3>
                  Uint16 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint16" class="anchor" title="Link to Uint16">#</a>
               </h3>
               
               <pre><code>const Uint16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint32" data-name="Uint32">
               <h3>
                  Uint32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint32" class="anchor" title="Link to Uint32">#</a>
               </h3>
               
               <pre><code>const Uint32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint64" data-name="Uint64">
               <h3>
                  Uint64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint64" class="anchor" title="Link to Uint64">#</a>
               </h3>
               
               <pre><code>const Uint64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uint8" data-name="Uint8">
               <h3>
                  Uint8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uint8" class="anchor" title="Link to Uint8">#</a>
               </h3>
               
               <pre><code>const Uint8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Uintptr" data-name="Uintptr">
               <h3>
                  Uintptr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Uintptr" class="anchor" title="Link to Uintptr">#</a>
               </h3>
               
               <pre><code>const Uintptr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnsafePointRestart1" data-name="UnsafePointRestart1">
               <h3>
                  UnsafePointRestart1 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnsafePointRestart1" class="anchor" title="Link to UnsafePointRestart1">#</a>
               </h3>
               
               <p>UnsafePointRestart1(2) apply on a sequence of instructions, within
which if an async preemption happens, we should back off the PC
to the start of the sequence when resuming.
We need two so we can distinguish the start/end of the sequence
in case that two sequences are next to each other.</p>
               
               <pre><code>const UnsafePointRestart1 = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnsafePointRestart2" data-name="UnsafePointRestart2">
               <h3>
                  UnsafePointRestart2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnsafePointRestart2" class="anchor" title="Link to UnsafePointRestart2">#</a>
               </h3>
               
               <p>Special values for the PCDATA_UnsafePoint table.</p>
               
               <pre><code>const UnsafePointRestart2 = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnsafePointRestartAtEntry" data-name="UnsafePointRestartAtEntry">
               <h3>
                  UnsafePointRestartAtEntry 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnsafePointRestartAtEntry" class="anchor" title="Link to UnsafePointRestartAtEntry">#</a>
               </h3>
               
               <p>Like UnsafePointRestart1, but back to function entry if async preempted.</p>
               
               <pre><code>const UnsafePointRestartAtEntry = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnsafePointSafe" data-name="UnsafePointSafe">
               <h3>
                  UnsafePointSafe 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnsafePointSafe" class="anchor" title="Link to UnsafePointSafe">#</a>
               </h3>
               
               <p>Special values for the PCDATA_UnsafePoint table.</p>
               
               <pre><code>const UnsafePointSafe = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnsafePointUnsafe" data-name="UnsafePointUnsafe">
               <h3>
                  UnsafePointUnsafe 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnsafePointUnsafe" class="anchor" title="Link to UnsafePointUnsafe">#</a>
               </h3>
               
               <p>Special values for the PCDATA_UnsafePoint table.</p>
               
               <pre><code>const UnsafePointUnsafe = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnsafePointer" data-name="UnsafePointer">
               <h3>
                  UnsafePointer 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnsafePointer" class="anchor" title="Link to UnsafePointer">#</a>
               </h3>
               
               <pre><code>const UnsafePointer</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ZeroValSize" data-name="ZeroValSize">
               <h3>
                  ZeroValSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ZeroValSize" class="anchor" title="Link to ZeroValSize">#</a>
               </h3>
               
               <p>ZeroValSize is the size in bytes of runtime.zeroVal.</p>
               
               <pre><code>const ZeroValSize = 1024</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="alwaysFalse" data-name="alwaysFalse">
               <h3>
                  alwaysFalse 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#alwaysFalse" class="anchor" title="Link to alwaysFalse">#</a>
               </h3>
               
               <pre><code>var alwaysFalse bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bitsetLSB" data-name="bitsetLSB">
               <h3>
                  bitsetLSB 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bitsetLSB" class="anchor" title="Link to bitsetLSB">#</a>
               </h3>
               
               <p>Map constants common to several packages
runtime/runtime-gdb.py:MapTypePrinter contains its own copy</p>
               
               <pre><code>const bitsetLSB = 0x0101010101010101</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ctrlEmpty" data-name="ctrlEmpty">
               <h3>
                  ctrlEmpty 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ctrlEmpty" class="anchor" title="Link to ctrlEmpty">#</a>
               </h3>
               
               <p>Map constants common to several packages
runtime/runtime-gdb.py:MapTypePrinter contains its own copy</p>
               
               <pre><code>const ctrlEmpty = 0b10000000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escapeSink" data-name="escapeSink">
               <h3>
                  escapeSink 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#escapeSink" class="anchor" title="Link to escapeSink">#</a>
               </h3>
               
               <pre><code>var escapeSink any</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="go122InterfaceSwitchCache" data-name="go122InterfaceSwitchCache">
               <h3>
                  go122InterfaceSwitchCache 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#go122InterfaceSwitchCache" class="anchor" title="Link to go122InterfaceSwitchCache">#</a>
               </h3>
               
               <pre><code>const go122InterfaceSwitchCache = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="kindNames" data-name="kindNames">
               <h3>
                  kindNames 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#kindNames" class="anchor" title="Link to kindNames">#</a>
               </h3>
               
               <pre><code>var kindNames = []string{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ChanDir" data-name="ChanDir">
               <h3>
                  ChanDir
                  <span class="badge type-badge">type</span>
                  <a href="#ChanDir" class="anchor" title="Link to ChanDir">#</a>
               </h3>
               
               <pre><code>type ChanDir int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="FuncFlag" data-name="FuncFlag">
               <h3>
                  FuncFlag
                  <span class="badge type-badge">type</span>
                  <a href="#FuncFlag" class="anchor" title="Link to FuncFlag">#</a>
               </h3>
               
               <p>A FuncFlag records bits about a function, passed to the runtime.</p>
               
               <pre><code>type FuncFlag uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="FuncID" data-name="FuncID">
               <h3>
                  FuncID
                  <span class="badge type-badge">type</span>
                  <a href="#FuncID" class="anchor" title="Link to FuncID">#</a>
               </h3>
               
               <p>A FuncID identifies particular functions that need to be treated
specially by the runtime.
Note that in some situations involving plugins, there may be multiple
copies of a particular special runtime function.</p>
               
               <pre><code>type FuncID uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="IntArgRegBitmap" data-name="IntArgRegBitmap">
               <h3>
                  IntArgRegBitmap
                  <span class="badge type-badge">type</span>
                  <a href="#IntArgRegBitmap" class="anchor" title="Link to IntArgRegBitmap">#</a>
               </h3>
               
               <p>IntArgRegBitmap is a bitmap large enough to hold one bit per
integer argument/return register.</p>
               
               <pre><code>type IntArgRegBitmap [*ast.BinaryExpr]uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Kind" data-name="Kind">
               <h3>
                  Kind
                  <span class="badge type-badge">type</span>
                  <a href="#Kind" class="anchor" title="Link to Kind">#</a>
               </h3>
               
               <p>A Kind represents the specific kind of type that a Type represents.
The zero Kind is not a valid kind.</p>
               
               <pre><code>type Kind uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="NameOff" data-name="NameOff">
               <h3>
                  NameOff
                  <span class="badge type-badge">type</span>
                  <a href="#NameOff" class="anchor" title="Link to NameOff">#</a>
               </h3>
               
               <p>NameOff is the offset to a name from moduledata.types.  See resolveNameOff in runtime.</p>
               
               <pre><code>type NameOff int32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="RF_State" data-name="RF_State">
               <h3>
                  RF_State
                  <span class="badge type-badge">type</span>
                  <a href="#RF_State" class="anchor" title="Link to RF_State">#</a>
               </h3>
               
               <pre><code>type RF_State int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="TFlag" data-name="TFlag">
               <h3>
                  TFlag
                  <span class="badge type-badge">type</span>
                  <a href="#TFlag" class="anchor" title="Link to TFlag">#</a>
               </h3>
               
               <p>TFlag is used by a Type to signal what extra type information is
available in the memory directly following the Type value.</p>
               
               <pre><code>type TFlag uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="TextOff" data-name="TextOff">
               <h3>
                  TextOff
                  <span class="badge type-badge">type</span>
                  <a href="#TextOff" class="anchor" title="Link to TextOff">#</a>
               </h3>
               
               <p>TextOff is an offset from the top of a text section.  See (rtype).textOff in runtime.</p>
               
               <pre><code>type TextOff int32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="TypeOff" data-name="TypeOff">
               <h3>
                  TypeOff
                  <span class="badge type-badge">type</span>
                  <a href="#TypeOff" class="anchor" title="Link to TypeOff">#</a>
               </h3>
               
               <p>TypeOff is the offset to a type from moduledata.types.  See resolveTypeOff in runtime.</p>
               
               <pre><code>type TypeOff int32</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="mapType" data-name="mapType">
               <h3>
                  mapType
                  <span class="badge type-badge">type</span>
                  <a href="#mapType" class="anchor" title="Link to mapType">#</a>
               </h3>
               
               <p>Select the map type that this binary is built using. This is for common
lookup methods like Type.Key to know which type to use.
Note that mapType *must not be used by any functions called in the
compiler to build a target program* because the compiler must use the map
type determined by run-time GOEXPERIMENT, not the build tags used to build
the compiler.
TODO(prattmic): This package is rather confusing because it has many
functions that can't be used by the compiler (e.g., Type.Uncommon depends on
the layout of type + uncommon objects in the binary. It would be incorrect
for an ad-hoc local Type object). It may be best to move code that isn't
usable by the compiler out of the package.</p>
               
               <pre><code>type mapType SwissMapType</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="mapType" data-name="mapType">
               <h3>
                  mapType
                  <span class="badge type-badge">type</span>
                  <a href="#mapType" class="anchor" title="Link to mapType">#</a>
               </h3>
               
               <p>See comment in map_select_swiss.go.</p>
               
               <pre><code>type mapType OldMapType</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="ArrayType" data-name="ArrayType">
               <h3>
                  ArrayType
                  <span class="badge">struct</span>
                  <a href="#ArrayType" class="anchor" title="Link to ArrayType">#</a>
               </h3>
               
               <p>ArrayType represents a fixed array type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ArrayType struct {
Type
Elem *Type
Slice *Type
Len uintptr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ChanType" data-name="ChanType">
               <h3>
                  ChanType
                  <span class="badge">struct</span>
                  <a href="#ChanType" class="anchor" title="Link to ChanType">#</a>
               </h3>
               
               <p>ChanType represents a channel type</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ChanType struct {
Type
Elem *Type
Dir ChanDir
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="EmptyInterface" data-name="EmptyInterface">
               <h3>
                  EmptyInterface
                  <span class="badge">struct</span>
                  <a href="#EmptyInterface" class="anchor" title="Link to EmptyInterface">#</a>
               </h3>
               
               <p>EmptyInterface describes the layout of a "interface{}" or a "any."
These are represented differently than non-empty interface, as the first
word always points to an abi.Type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type EmptyInterface struct {
Type *Type
Data unsafe.Pointer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="FuncType" data-name="FuncType">
               <h3>
                  FuncType
                  <span class="badge">struct</span>
                  <a href="#FuncType" class="anchor" title="Link to FuncType">#</a>
               </h3>
               
               <p>funcType represents a function type.
A *Type for each in and out parameter is stored in an array that
directly follows the funcType (and possibly its uncommonType). So
a function type with one method, one input, and one output is:
struct {
funcType
uncommonType
[2]*rtype    // [0] is in, [1] is out
}</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FuncType struct {
Type
InCount uint16
OutCount uint16
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ITab" data-name="ITab">
               <h3>
                  ITab
                  <span class="badge">struct</span>
                  <a href="#ITab" class="anchor" title="Link to ITab">#</a>
               </h3>
               
               <p>The first word of every non-empty interface type contains an *ITab.
It records the underlying concrete type (Type), the interface type it
is implementing (Inter), and some ancillary information.
allocated in non-garbage-collected memory</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ITab struct {
Inter *InterfaceType
Type *Type
Hash uint32
Fun [1]uintptr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Imethod" data-name="Imethod">
               <h3>
                  Imethod
                  <span class="badge">struct</span>
                  <a href="#Imethod" class="anchor" title="Link to Imethod">#</a>
               </h3>
               
               <p>Imethod represents a method on an interface type</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Imethod struct {
Name NameOff
Typ TypeOff
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="InterfaceSwitch" data-name="InterfaceSwitch">
               <h3>
                  InterfaceSwitch
                  <span class="badge">struct</span>
                  <a href="#InterfaceSwitch" class="anchor" title="Link to InterfaceSwitch">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InterfaceSwitch struct {
Cache *InterfaceSwitchCache
NCases int
Cases [1]*InterfaceType
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="InterfaceSwitchCache" data-name="InterfaceSwitchCache">
               <h3>
                  InterfaceSwitchCache
                  <span class="badge">struct</span>
                  <a href="#InterfaceSwitchCache" class="anchor" title="Link to InterfaceSwitchCache">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InterfaceSwitchCache struct {
Mask uintptr
Entries [1]InterfaceSwitchCacheEntry
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="InterfaceSwitchCacheEntry" data-name="InterfaceSwitchCacheEntry">
               <h3>
                  InterfaceSwitchCacheEntry
                  <span class="badge">struct</span>
                  <a href="#InterfaceSwitchCacheEntry" class="anchor" title="Link to InterfaceSwitchCacheEntry">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InterfaceSwitchCacheEntry struct {
Typ uintptr
Case int
Itab uintptr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="InterfaceType" data-name="InterfaceType">
               <h3>
                  InterfaceType
                  <span class="badge">struct</span>
                  <a href="#InterfaceType" class="anchor" title="Link to InterfaceType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InterfaceType struct {
Type
PkgPath Name
Methods []Imethod
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Method" data-name="Method">
               <h3>
                  Method
                  <span class="badge">struct</span>
                  <a href="#Method" class="anchor" title="Link to Method">#</a>
               </h3>
               
               <p>Method on non-interface type</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Method struct {
Name NameOff
Mtyp TypeOff
Ifn TextOff
Tfn TextOff
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name
                  <span class="badge">struct</span>
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Name struct {
Bytes *byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="OldMapType" data-name="OldMapType">
               <h3>
                  OldMapType
                  <span class="badge">struct</span>
                  <a href="#OldMapType" class="anchor" title="Link to OldMapType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type OldMapType struct {
Type
Key *Type
Elem *Type
Bucket *Type
Hasher func(unsafe.Pointer, uintptr) uintptr
KeySize uint8
ValueSize uint8
BucketSize uint16
Flags uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PtrType" data-name="PtrType">
               <h3>
                  PtrType
                  <span class="badge">struct</span>
                  <a href="#PtrType" class="anchor" title="Link to PtrType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PtrType struct {
Type
Elem *Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="RegArgs" data-name="RegArgs">
               <h3>
                  RegArgs
                  <span class="badge">struct</span>
                  <a href="#RegArgs" class="anchor" title="Link to RegArgs">#</a>
               </h3>
               
               <p>RegArgs is a struct that has space for each argument
and return value register on the current architecture.
Assembly code knows the layout of the first two fields
of RegArgs.
RegArgs also contains additional space to hold pointers
when it may not be safe to keep them only in the integer
register space otherwise.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type RegArgs struct {
Ints [IntArgRegs]uintptr
Floats [FloatArgRegs]uint64
Ptrs [IntArgRegs]unsafe.Pointer
ReturnIsPtr IntArgRegBitmap
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="SliceType" data-name="SliceType">
               <h3>
                  SliceType
                  <span class="badge">struct</span>
                  <a href="#SliceType" class="anchor" title="Link to SliceType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SliceType struct {
Type
Elem *Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="StructField" data-name="StructField">
               <h3>
                  StructField
                  <span class="badge">struct</span>
                  <a href="#StructField" class="anchor" title="Link to StructField">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StructField struct {
Name Name
Typ *Type
Offset uintptr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="StructType" data-name="StructType">
               <h3>
                  StructType
                  <span class="badge">struct</span>
                  <a href="#StructType" class="anchor" title="Link to StructType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StructType struct {
Type
PkgPath Name
Fields []StructField
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="SwissMapType" data-name="SwissMapType">
               <h3>
                  SwissMapType
                  <span class="badge">struct</span>
                  <a href="#SwissMapType" class="anchor" title="Link to SwissMapType">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SwissMapType struct {
Type
Key *Type
Elem *Type
Group *Type
Hasher func(unsafe.Pointer, uintptr) uintptr
GroupSize uintptr
SlotSize uintptr
ElemOff uintptr
Flags uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type
                  <span class="badge">struct</span>
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <p>Type is the runtime representation of a Go type.
Be careful about accessing this type at build time, as the version
of this type in the compiler/linker may not have the same layout
as the version in the target binary, due to pointer width
differences and any experiments. Use cmd/compile/internal/rttype
or the functions in compiletype.go to access this type instead.
(TODO: this admonition applies to every type in this package.
Put it in some shared location?)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Type struct {
Size_ uintptr
PtrBytes uintptr
Hash uint32
TFlag TFlag
Align_ uint8
FieldAlign_ uint8
Kind_ Kind
Equal func(unsafe.Pointer, unsafe.Pointer) bool
GCData *byte
Str NameOff
PtrToThis TypeOff
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TypeAssert" data-name="TypeAssert">
               <h3>
                  TypeAssert
                  <span class="badge">struct</span>
                  <a href="#TypeAssert" class="anchor" title="Link to TypeAssert">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TypeAssert struct {
Cache *TypeAssertCache
Inter *InterfaceType
CanFail bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TypeAssertCache" data-name="TypeAssertCache">
               <h3>
                  TypeAssertCache
                  <span class="badge">struct</span>
                  <a href="#TypeAssertCache" class="anchor" title="Link to TypeAssertCache">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TypeAssertCache struct {
Mask uintptr
Entries [1]TypeAssertCacheEntry
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TypeAssertCacheEntry" data-name="TypeAssertCacheEntry">
               <h3>
                  TypeAssertCacheEntry
                  <span class="badge">struct</span>
                  <a href="#TypeAssertCacheEntry" class="anchor" title="Link to TypeAssertCacheEntry">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TypeAssertCacheEntry struct {
Typ uintptr
Itab uintptr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="UncommonType" data-name="UncommonType">
               <h3>
                  UncommonType
                  <span class="badge">struct</span>
                  <a href="#UncommonType" class="anchor" title="Link to UncommonType">#</a>
               </h3>
               
               <p>UncommonType is present only for defined types or types with methods
(if T is a defined type, the uncommonTypes for T and *T have methods).
Using a pointer to this struct reduces the overall size required
to describe a non-defined type with no methods.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UncommonType struct {
PkgPath NameOff
Mcount uint16
Xcount uint16
Moff uint32
_ uint32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="structTypeUncommon" data-name="structTypeUncommon">
               <h3>
                  structTypeUncommon
                  <span class="badge">struct</span>
                  <a href="#structTypeUncommon" class="anchor" title="Link to structTypeUncommon">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type structTypeUncommon struct {
StructType
u UncommonType
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Align" data-name="Align">
               <h3>
                  Align 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Align" class="anchor" title="Link to Align">#</a>
               </h3>
               
               <p>Align returns the alignment of data with type t.</p>
               
               <pre><code>func (t *Type) Align() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ArrayType" data-name="ArrayType">
               <h3>
                  ArrayType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ArrayType" class="anchor" title="Link to ArrayType">#</a>
               </h3>
               
               <p>ArrayType returns t cast to a *ArrayType, or nil if its tag does not match.</p>
               
               <pre><code>func (t *Type) ArrayType() *ArrayType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ChanDir" data-name="ChanDir">
               <h3>
                  ChanDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ChanDir" class="anchor" title="Link to ChanDir">#</a>
               </h3>
               
               <p>ChanDir returns the direction of t if t is a channel type, otherwise InvalidDir (0).</p>
               
               <pre><code>func (t *Type) ChanDir() ChanDir</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Common" data-name="Common">
               <h3>
                  Common 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Common" class="anchor" title="Link to Common">#</a>
               </h3>
               
               <pre><code>func (t *Type) Common() *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CommonSize" data-name="CommonSize">
               <h3>
                  CommonSize 
                  <span class="badge">function</span>
                  
                  <a href="#CommonSize" class="anchor" title="Link to CommonSize">#</a>
               </h3>
               
               <p>CommonSize returns sizeof(Type) for a compilation target with a given ptrSize</p>
               
               <pre><code>func CommonSize(ptrSize int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Data" data-name="Data">
               <h3>
                  Data 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Data" class="anchor" title="Link to Data">#</a>
               </h3>
               
               <p>Data does pointer arithmetic on n's Bytes, and that arithmetic is asserted to
be safe because the runtime made the call (other packages use DataChecked)</p>
               
               <pre><code>func (n Name) Data(off int) *byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DataChecked" data-name="DataChecked">
               <h3>
                  DataChecked 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DataChecked" class="anchor" title="Link to DataChecked">#</a>
               </h3>
               
               <p>DataChecked does pointer arithmetic on n's Bytes, and that arithmetic is asserted to
be safe for the reason in whySafe (which can appear in a backtrace, etc.)</p>
               
               <pre><code>func (n Name) DataChecked(off int, whySafe string) *byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Dump" data-name="Dump">
               <h3>
                  Dump 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Dump" class="anchor" title="Link to Dump">#</a>
               </h3>
               
               <pre><code>func (r *RegArgs) Dump()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Elem" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Elem" class="anchor" title="Link to Elem">#</a>
               </h3>
               
               <p>Elem returns the element type for t if t is an array, channel, map, pointer, or slice, otherwise nil.</p>
               
               <pre><code>func (t *Type) Elem() *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Embedded" data-name="Embedded">
               <h3>
                  Embedded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Embedded" class="anchor" title="Link to Embedded">#</a>
               </h3>
               
               <pre><code>func (f *StructField) Embedded() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Escape" data-name="Escape">
               <h3>
                  Escape 
                  <span class="badge">function</span>
                  
                  <a href="#Escape" class="anchor" title="Link to Escape">#</a>
               </h3>
               
               <p>Escape forces any pointers in x to escape to the heap.</p>
               
               <pre><code>func Escape(x T) T</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExportedMethods" data-name="ExportedMethods">
               <h3>
                  ExportedMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ExportedMethods" class="anchor" title="Link to ExportedMethods">#</a>
               </h3>
               
               <pre><code>func (t *Type) ExportedMethods() []Method</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExportedMethods" data-name="ExportedMethods">
               <h3>
                  ExportedMethods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ExportedMethods" class="anchor" title="Link to ExportedMethods">#</a>
               </h3>
               
               <pre><code>func (t *UncommonType) ExportedMethods() []Method</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FieldAlign" data-name="FieldAlign">
               <h3>
                  FieldAlign 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FieldAlign" class="anchor" title="Link to FieldAlign">#</a>
               </h3>
               
               <pre><code>func (t *Type) FieldAlign() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FuncPCABI0" data-name="FuncPCABI0">
               <h3>
                  FuncPCABI0 
                  <span class="badge">function</span>
                  
                  <a href="#FuncPCABI0" class="anchor" title="Link to FuncPCABI0">#</a>
               </h3>
               
               <p>FuncPCABI0 returns the entry PC of the function f, which must be a
direct reference of a function defined as ABI0. Otherwise it is a
compile-time error.
Implemented as a compile intrinsic.</p>
               
               <pre><code>func FuncPCABI0(f interface{}) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FuncPCABI0" data-name="FuncPCABI0">
               <h3>
                  FuncPCABI0 
                  <span class="badge">function</span>
                  
                  <a href="#FuncPCABI0" class="anchor" title="Link to FuncPCABI0">#</a>
               </h3>
               
               <pre><code>func FuncPCABI0(f interface{}) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FuncPCABIInternal" data-name="FuncPCABIInternal">
               <h3>
                  FuncPCABIInternal 
                  <span class="badge">function</span>
                  
                  <a href="#FuncPCABIInternal" class="anchor" title="Link to FuncPCABIInternal">#</a>
               </h3>
               
               <pre><code>func FuncPCABIInternal(f interface{}) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FuncPCABIInternal" data-name="FuncPCABIInternal">
               <h3>
                  FuncPCABIInternal 
                  <span class="badge">function</span>
                  
                  <a href="#FuncPCABIInternal" class="anchor" title="Link to FuncPCABIInternal">#</a>
               </h3>
               
               <p>FuncPCABIInternal returns the entry PC of the function f. If f is a
direct reference of a function, it must be defined as ABIInternal.
Otherwise it is a compile-time error. If f is not a direct reference
of a defined function, it assumes that f is a func value. Otherwise
the behavior is undefined.
Implemented as a compile intrinsic.</p>
               
               <pre><code>func FuncPCABIInternal(f interface{}) uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FuncType" data-name="FuncType">
               <h3>
                  FuncType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FuncType" class="anchor" title="Link to FuncType">#</a>
               </h3>
               
               <p>FuncType returns t cast to a *FuncType, or nil if its tag does not match.</p>
               
               <pre><code>func (t *Type) FuncType() *FuncType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GcSlice" data-name="GcSlice">
               <h3>
                  GcSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GcSlice" class="anchor" title="Link to GcSlice">#</a>
               </h3>
               
               <pre><code>func (t *Type) GcSlice(begin uintptr, end uintptr) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Get" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Get" class="anchor" title="Link to Get">#</a>
               </h3>
               
               <p>Get returns whether the i'th bit of the bitmap is set.
nosplit because it's called in extremely sensitive contexts, like
on the reflectcall return path.
go:nosplit</p>
               
               <pre><code>func (b *IntArgRegBitmap) Get(i int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasName" data-name="HasName">
               <h3>
                  HasName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HasName" class="anchor" title="Link to HasName">#</a>
               </h3>
               
               <pre><code>func (t *Type) HasName() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasTag" data-name="HasTag">
               <h3>
                  HasTag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HasTag" class="anchor" title="Link to HasTag">#</a>
               </h3>
               
               <p>HasTag returns true iff there is tag data following this name</p>
               
               <pre><code>func (n Name) HasTag() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HashMightPanic" data-name="HashMightPanic">
               <h3>
                  HashMightPanic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HashMightPanic" class="anchor" title="Link to HashMightPanic">#</a>
               </h3>
               
               <pre><code>func (mt *OldMapType) HashMightPanic() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HashMightPanic" data-name="HashMightPanic">
               <h3>
                  HashMightPanic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#HashMightPanic" class="anchor" title="Link to HashMightPanic">#</a>
               </h3>
               
               <pre><code>func (mt *SwissMapType) HashMightPanic() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ITabTypeOff" data-name="ITabTypeOff">
               <h3>
                  ITabTypeOff 
                  <span class="badge">function</span>
                  
                  <a href="#ITabTypeOff" class="anchor" title="Link to ITabTypeOff">#</a>
               </h3>
               
               <p>ITabTypeOff returns the offset of ITab.Type for a compilation target with a given ptrSize</p>
               
               <pre><code>func ITabTypeOff(ptrSize int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IfaceIndir" data-name="IfaceIndir">
               <h3>
                  IfaceIndir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IfaceIndir" class="anchor" title="Link to IfaceIndir">#</a>
               </h3>
               
               <p>IfaceIndir reports whether t is stored indirectly in an interface value.</p>
               
               <pre><code>func (t *Type) IfaceIndir() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="In" data-name="In">
               <h3>
                  In 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#In" class="anchor" title="Link to In">#</a>
               </h3>
               
               <pre><code>func (t *FuncType) In(i int) *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InSlice" data-name="InSlice">
               <h3>
                  InSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InSlice" class="anchor" title="Link to InSlice">#</a>
               </h3>
               
               <pre><code>func (t *FuncType) InSlice() []*Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IndirectElem" data-name="IndirectElem">
               <h3>
                  IndirectElem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IndirectElem" class="anchor" title="Link to IndirectElem">#</a>
               </h3>
               
               <pre><code>func (mt *OldMapType) IndirectElem() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IndirectElem" data-name="IndirectElem">
               <h3>
                  IndirectElem 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IndirectElem" class="anchor" title="Link to IndirectElem">#</a>
               </h3>
               
               <pre><code>func (mt *SwissMapType) IndirectElem() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IndirectKey" data-name="IndirectKey">
               <h3>
                  IndirectKey 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IndirectKey" class="anchor" title="Link to IndirectKey">#</a>
               </h3>
               
               <p>Note: flag values must match those used in the TMAP case
in ../cmd/compile/internal/reflectdata/reflect.go:writeType.</p>
               
               <pre><code>func (mt *OldMapType) IndirectKey() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IndirectKey" data-name="IndirectKey">
               <h3>
                  IndirectKey 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IndirectKey" class="anchor" title="Link to IndirectKey">#</a>
               </h3>
               
               <pre><code>func (mt *SwissMapType) IndirectKey() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IntRegArgAddr" data-name="IntRegArgAddr">
               <h3>
                  IntRegArgAddr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IntRegArgAddr" class="anchor" title="Link to IntRegArgAddr">#</a>
               </h3>
               
               <p>IntRegArgAddr returns a pointer inside of r.Ints[reg] that is appropriately
offset for an argument of size argSize.
argSize must be non-zero, fit in a register, and a power-of-two.
This method is a helper for dealing with the endianness of different CPU
architectures, since sub-word-sized arguments in big endian architectures
need to be "aligned" to the upper edge of the register to be interpreted
by the CPU correctly.</p>
               
               <pre><code>func (r *RegArgs) IntRegArgAddr(reg int, argSize uintptr) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InterfaceType" data-name="InterfaceType">
               <h3>
                  InterfaceType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InterfaceType" class="anchor" title="Link to InterfaceType">#</a>
               </h3>
               
               <p>InterfaceType returns t cast to a *InterfaceType, or nil if its tag does not match.</p>
               
               <pre><code>func (t *Type) InterfaceType() *InterfaceType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsBlank" data-name="IsBlank">
               <h3>
                  IsBlank 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsBlank" class="anchor" title="Link to IsBlank">#</a>
               </h3>
               
               <p>IsBlank indicates whether n is "_".</p>
               
               <pre><code>func (n Name) IsBlank() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDirectIface" data-name="IsDirectIface">
               <h3>
                  IsDirectIface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDirectIface" class="anchor" title="Link to IsDirectIface">#</a>
               </h3>
               
               <p>isDirectIface reports whether t is stored directly in an interface value.</p>
               
               <pre><code>func (t *Type) IsDirectIface() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsEmbedded" data-name="IsEmbedded">
               <h3>
                  IsEmbedded 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsEmbedded" class="anchor" title="Link to IsEmbedded">#</a>
               </h3>
               
               <p>IsEmbedded returns true iff n is embedded (an anonymous field).</p>
               
               <pre><code>func (n Name) IsEmbedded() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsExported" data-name="IsExported">
               <h3>
                  IsExported 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsExported" class="anchor" title="Link to IsExported">#</a>
               </h3>
               
               <p>IsExported returns "is n exported?"</p>
               
               <pre><code>func (n Name) IsExported() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsVariadic" data-name="IsVariadic">
               <h3>
                  IsVariadic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsVariadic" class="anchor" title="Link to IsVariadic">#</a>
               </h3>
               
               <pre><code>func (t *FuncType) IsVariadic() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Key" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Key" class="anchor" title="Link to Key">#</a>
               </h3>
               
               <pre><code>func (t *Type) Key() *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Kind" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Kind" class="anchor" title="Link to Kind">#</a>
               </h3>
               
               <pre><code>func (t *Type) Kind() Kind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>Len returns the length of t if t is an array type, otherwise 0</p>
               
               <pre><code>func (t *Type) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MapType" data-name="MapType">
               <h3>
                  MapType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MapType" class="anchor" title="Link to MapType">#</a>
               </h3>
               
               <p>MapType returns t cast to a *OldMapType or *SwissMapType, or nil if its tag does not match.</p>
               
               <pre><code>func (t *Type) MapType() *mapType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Methods" data-name="Methods">
               <h3>
                  Methods 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Methods" class="anchor" title="Link to Methods">#</a>
               </h3>
               
               <pre><code>func (t *UncommonType) Methods() []Method</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <p>Name returns the tag string for n, or empty if there is none.</p>
               
               <pre><code>func (n Name) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NeedKeyUpdate" data-name="NeedKeyUpdate">
               <h3>
                  NeedKeyUpdate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NeedKeyUpdate" class="anchor" title="Link to NeedKeyUpdate">#</a>
               </h3>
               
               <pre><code>func (mt *SwissMapType) NeedKeyUpdate() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NeedKeyUpdate" data-name="NeedKeyUpdate">
               <h3>
                  NeedKeyUpdate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NeedKeyUpdate" class="anchor" title="Link to NeedKeyUpdate">#</a>
               </h3>
               
               <pre><code>func (mt *OldMapType) NeedKeyUpdate() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewName" data-name="NewName">
               <h3>
                  NewName 
                  <span class="badge">function</span>
                  
                  <a href="#NewName" class="anchor" title="Link to NewName">#</a>
               </h3>
               
               <pre><code>func NewName(n string, tag string, exported bool, embedded bool) Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NoEscape" data-name="NoEscape">
               <h3>
                  NoEscape 
                  <span class="badge">function</span>
                  
                  <a href="#NoEscape" class="anchor" title="Link to NoEscape">#</a>
               </h3>
               
               <p>NoEscape hides the pointer p from escape analysis, preventing it
from escaping to the heap. It compiles down to nothing.
WARNING: This is very subtle to use correctly. The caller must
ensure that it's truly safe for p to not escape to the heap by
maintaining runtime pointer invariants (for example, that globals
and the heap may not generally point into a stack).
go:nosplit
go:nocheckptr</p>
               
               <pre><code>func NoEscape(p unsafe.Pointer) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumIn" data-name="NumIn">
               <h3>
                  NumIn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumIn" class="anchor" title="Link to NumIn">#</a>
               </h3>
               
               <pre><code>func (t *FuncType) NumIn() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumMethod" data-name="NumMethod">
               <h3>
                  NumMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumMethod" class="anchor" title="Link to NumMethod">#</a>
               </h3>
               
               <pre><code>func (t *Type) NumMethod() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumMethod" data-name="NumMethod">
               <h3>
                  NumMethod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumMethod" class="anchor" title="Link to NumMethod">#</a>
               </h3>
               
               <p>NumMethod returns the number of interface methods in the type's method set.</p>
               
               <pre><code>func (t *InterfaceType) NumMethod() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumOut" data-name="NumOut">
               <h3>
                  NumOut 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumOut" class="anchor" title="Link to NumOut">#</a>
               </h3>
               
               <pre><code>func (t *FuncType) NumOut() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Out" data-name="Out">
               <h3>
                  Out 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Out" class="anchor" title="Link to Out">#</a>
               </h3>
               
               <pre><code>func (t *FuncType) Out(i int) *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OutSlice" data-name="OutSlice">
               <h3>
                  OutSlice 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OutSlice" class="anchor" title="Link to OutSlice">#</a>
               </h3>
               
               <pre><code>func (t *FuncType) OutSlice() []*Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pointers" data-name="Pointers">
               <h3>
                  Pointers 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pointers" class="anchor" title="Link to Pointers">#</a>
               </h3>
               
               <p>Pointers reports whether t contains pointers.</p>
               
               <pre><code>func (t *Type) Pointers() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadVarint" data-name="ReadVarint">
               <h3>
                  ReadVarint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadVarint" class="anchor" title="Link to ReadVarint">#</a>
               </h3>
               
               <p>ReadVarint parses a varint as encoded by encoding/binary.
It returns the number of encoded bytes and the encoded value.</p>
               
               <pre><code>func (n Name) ReadVarint(off int) (int, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReflexiveKey" data-name="ReflexiveKey">
               <h3>
                  ReflexiveKey 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReflexiveKey" class="anchor" title="Link to ReflexiveKey">#</a>
               </h3>
               
               <pre><code>func (mt *OldMapType) ReflexiveKey() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set sets the i'th bit of the bitmap to 1.</p>
               
               <pre><code>func (b *IntArgRegBitmap) Set(i int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <p>Size returns the size of data with type t.</p>
               
               <pre><code>func (t *Type) Size() uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String returns the name of k.</p>
               
               <pre><code>func (k Kind) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StructFieldSize" data-name="StructFieldSize">
               <h3>
                  StructFieldSize 
                  <span class="badge">function</span>
                  
                  <a href="#StructFieldSize" class="anchor" title="Link to StructFieldSize">#</a>
               </h3>
               
               <p>StructFieldSize returns sizeof(StructField) for a compilation target with a given ptrSize</p>
               
               <pre><code>func StructFieldSize(ptrSize int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StructType" data-name="StructType">
               <h3>
                  StructType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StructType" class="anchor" title="Link to StructType">#</a>
               </h3>
               
               <p>StructType returns t cast to a *StructType, or nil if its tag does not match.</p>
               
               <pre><code>func (t *Type) StructType() *StructType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TFlagOff" data-name="TFlagOff">
               <h3>
                  TFlagOff 
                  <span class="badge">function</span>
                  
                  <a href="#TFlagOff" class="anchor" title="Link to TFlagOff">#</a>
               </h3>
               
               <p>TFlagOff returns the offset of Type.TFlag for a compilation target with a given ptrSize</p>
               
               <pre><code>func TFlagOff(ptrSize int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Tag" data-name="Tag">
               <h3>
                  Tag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Tag" class="anchor" title="Link to Tag">#</a>
               </h3>
               
               <p>Tag returns the tag string for n, or empty if there is none.</p>
               
               <pre><code>func (n Name) Tag() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeFor" data-name="TypeFor">
               <h3>
                  TypeFor 
                  <span class="badge">function</span>
                  
                  <a href="#TypeFor" class="anchor" title="Link to TypeFor">#</a>
               </h3>
               
               <p>TypeFor returns the abi.Type for a type parameter.</p>
               
               <pre><code>func TypeFor() *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeOf" data-name="TypeOf">
               <h3>
                  TypeOf 
                  <span class="badge">function</span>
                  
                  <a href="#TypeOf" class="anchor" title="Link to TypeOf">#</a>
               </h3>
               
               <p>TypeOf returns the abi.Type of some value.</p>
               
               <pre><code>func TypeOf(a any) *Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Uncommon" data-name="Uncommon">
               <h3>
                  Uncommon 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Uncommon" class="anchor" title="Link to Uncommon">#</a>
               </h3>
               
               <p>Uncommon returns a pointer to T's "uncommon" data if there is any, otherwise nil</p>
               
               <pre><code>func (t *Type) Uncommon() *UncommonType</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UncommonSize" data-name="UncommonSize">
               <h3>
                  UncommonSize 
                  <span class="badge">function</span>
                  
                  <a href="#UncommonSize" class="anchor" title="Link to UncommonSize">#</a>
               </h3>
               
               <p>UncommonSize returns sizeof(UncommonType).  This currently does not depend on ptrSize.
This exported function is in an internal package, so it may change to depend on ptrSize in the future.</p>
               
               <pre><code>func UncommonSize() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UseInterfaceSwitchCache" data-name="UseInterfaceSwitchCache">
               <h3>
                  UseInterfaceSwitchCache 
                  <span class="badge">function</span>
                  
                  <a href="#UseInterfaceSwitchCache" class="anchor" title="Link to UseInterfaceSwitchCache">#</a>
               </h3>
               
               <pre><code>func UseInterfaceSwitchCache(goarch string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addChecked" data-name="addChecked">
               <h3>
                  addChecked 
                  <span class="badge">function</span>
                  
                  <a href="#addChecked" class="anchor" title="Link to addChecked">#</a>
               </h3>
               
               <p>addChecked returns p+x.
The whySafe string is ignored, so that the function still inlines
as efficiently as p+x, but all call sites should use the string to
record why the addition is safe, which is to say why the addition
does not cause x to advance to the very end of p's allocation
and therefore point incorrectly at the next block in memory.</p>
               
               <pre><code>func addChecked(p unsafe.Pointer, x uintptr, whySafe string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeVarint" data-name="writeVarint">
               <h3>
                  writeVarint 
                  <span class="badge">function</span>
                  
                  <a href="#writeVarint" class="anchor" title="Link to writeVarint">#</a>
               </h3>
               
               <p>writeVarint writes n to buf in varint form. Returns the
number of bytes written. n must be nonnegative.
Writes at most 10 bytes.</p>
               
               <pre><code>func writeVarint(buf []byte, n int) int</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>