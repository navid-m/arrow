<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - abi</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>abi</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"unsafe"
"unsafe"
"unsafe"
"internal/goarch"
"unsafe"
"unsafe"
"unsafe"
"unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="ArgsSizeUnknown">
               <h3>
                  ArgsSizeUnknown 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ArgsSizeUnknown is set in Func.argsize to mark all functions
whose argument size is unknown (C vararg functions, and
assembly code without an explicit specification).
This value is generated by the compiler, assembler, or linker.</p>
               
               <pre><code>const ArgsSizeUnknown = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="Array">
               <h3>
                  Array 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Array</code></pre>
            </article>
            
            <article class="global" data-name="Bool">
               <h3>
                  Bool 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Bool</code></pre>
            </article>
            
            <article class="global" data-name="BothDir">
               <h3>
                  BothDir 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const BothDir = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="Chan">
               <h3>
                  Chan 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Chan</code></pre>
            </article>
            
            <article class="global" data-name="Complex128">
               <h3>
                  Complex128 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Complex128</code></pre>
            </article>
            
            <article class="global" data-name="Complex64">
               <h3>
                  Complex64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Complex64</code></pre>
            </article>
            
            <article class="global" data-name="EffectiveFloatRegSize">
               <h3>
                  EffectiveFloatRegSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>We use SSE2 registers which support 64-bit float operations.</p>
               
               <pre><code>const EffectiveFloatRegSize = 8</code></pre>
            </article>
            
            <article class="global" data-name="EffectiveFloatRegSize">
               <h3>
                  EffectiveFloatRegSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EffectiveFloatRegSize = 8</code></pre>
            </article>
            
            <article class="global" data-name="EffectiveFloatRegSize">
               <h3>
                  EffectiveFloatRegSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>EffectiveFloatRegSize describes the width of floating point
registers on the current platform from the ABI's perspective.
Since Go only supports 32-bit and 64-bit floating point primitives,
this number should be either 0, 4, or 8. 0 indicates no floating
point registers for the ABI or that floating point values will be
passed via the softfloat ABI.
For platforms that support larger floating point register widths,
such as x87's 80-bit "registers" (not that we support x87 currently),
use 8.</p>
               
               <pre><code>const EffectiveFloatRegSize = 0</code></pre>
            </article>
            
            <article class="global" data-name="EffectiveFloatRegSize">
               <h3>
                  EffectiveFloatRegSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EffectiveFloatRegSize = 8</code></pre>
            </article>
            
            <article class="global" data-name="EffectiveFloatRegSize">
               <h3>
                  EffectiveFloatRegSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EffectiveFloatRegSize = 8</code></pre>
            </article>
            
            <article class="global" data-name="EffectiveFloatRegSize">
               <h3>
                  EffectiveFloatRegSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const EffectiveFloatRegSize = 8</code></pre>
            </article>
            
            <article class="global" data-name="FUNCDATA_ArgInfo">
               <h3>
                  FUNCDATA_ArgInfo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_ArgInfo = 5</code></pre>
            </article>
            
            <article class="global" data-name="FUNCDATA_ArgLiveInfo">
               <h3>
                  FUNCDATA_ArgLiveInfo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_ArgLiveInfo = 6</code></pre>
            </article>
            
            <article class="global" data-name="FUNCDATA_ArgsPointerMaps">
               <h3>
                  FUNCDATA_ArgsPointerMaps 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_ArgsPointerMaps = 0</code></pre>
            </article>
            
            <article class="global" data-name="FUNCDATA_InlTree">
               <h3>
                  FUNCDATA_InlTree 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_InlTree = 3</code></pre>
            </article>
            
            <article class="global" data-name="FUNCDATA_LocalsPointerMaps">
               <h3>
                  FUNCDATA_LocalsPointerMaps 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_LocalsPointerMaps = 1</code></pre>
            </article>
            
            <article class="global" data-name="FUNCDATA_OpenCodedDeferInfo">
               <h3>
                  FUNCDATA_OpenCodedDeferInfo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_OpenCodedDeferInfo = 4</code></pre>
            </article>
            
            <article class="global" data-name="FUNCDATA_StackObjects">
               <h3>
                  FUNCDATA_StackObjects 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_StackObjects = 2</code></pre>
            </article>
            
            <article class="global" data-name="FUNCDATA_WrapInfo">
               <h3>
                  FUNCDATA_WrapInfo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const FUNCDATA_WrapInfo = 7</code></pre>
            </article>
            
            <article class="global" data-name="Float32">
               <h3>
                  Float32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Float32</code></pre>
            </article>
            
            <article class="global" data-name="Float64">
               <h3>
                  Float64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Float64</code></pre>
            </article>
            
            <article class="global" data-name="FloatArgRegs">
               <h3>
                  FloatArgRegs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>F0 - F15.</p>
               
               <pre><code>const FloatArgRegs = 16</code></pre>
            </article>
            
            <article class="global" data-name="FloatArgRegs">
               <h3>
                  FloatArgRegs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>F1 - F12.</p>
               
               <pre><code>const FloatArgRegs = 12</code></pre>
            </article>
            
            <article class="global" data-name="FloatArgRegs">
               <h3>
                  FloatArgRegs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FloatArgRegs is the number of registers dedicated
to passing floating-point argument values. Result registers are
identical to argument registers, so this number is used for
those too.</p>
               
               <pre><code>const FloatArgRegs = 0</code></pre>
            </article>
            
            <article class="global" data-name="FloatArgRegs">
               <h3>
                  FloatArgRegs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>F0 - F15</p>
               
               <pre><code>const FloatArgRegs = 16</code></pre>
            </article>
            
            <article class="global" data-name="FloatArgRegs">
               <h3>
                  FloatArgRegs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>F8 - F23.</p>
               
               <pre><code>const FloatArgRegs = 16</code></pre>
            </article>
            
            <article class="global" data-name="FloatArgRegs">
               <h3>
                  FloatArgRegs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>X0 -> X14.</p>
               
               <pre><code>const FloatArgRegs = 15</code></pre>
            </article>
            
            <article class="global" data-name="Func">
               <h3>
                  Func 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Func</code></pre>
            </article>
            
            <article class="global" data-name="FuncFlagAsm">
               <h3>
                  FuncFlagAsm 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FuncFlagAsm indicates that a function was implemented in assembly.</p>
               
               <pre><code>const FuncFlagAsm</code></pre>
            </article>
            
            <article class="global" data-name="FuncFlagSPWrite">
               <h3>
                  FuncFlagSPWrite 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FuncFlagSPWrite indicates a function that writes an arbitrary value to SP
(any write other than adding or subtracting a constant amount).
The traceback routines cannot encode such changes into the
pcsp tables, so the function traceback cannot safely unwind past
SPWrite functions. Stopping at an SPWrite function is considered
to be an incomplete unwinding of the stack. In certain contexts
(in particular garbage collector stack scans) that is a fatal error.</p>
               
               <pre><code>const FuncFlagSPWrite</code></pre>
            </article>
            
            <article class="global" data-name="FuncFlagTopFrame">
               <h3>
                  FuncFlagTopFrame 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>FuncFlagTopFrame indicates a function that appears at the top of its stack.
The traceback routine stop at such a function and consider that a
successful, complete traversal of the stack.
Examples of TopFrame functions include goexit, which appears
at the top of a user goroutine stack, and mstart, which appears
at the top of a system goroutine stack.</p>
               
               <pre><code>const FuncFlagTopFrame FuncFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="FuncIDNormal">
               <h3>
                  FuncIDNormal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncIDNormal FuncID = iota</code></pre>
            </article>
            
            <article class="global" data-name="FuncIDWrapper">
               <h3>
                  FuncIDWrapper 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncIDWrapper</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_abort">
               <h3>
                  FuncID_abort 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_abort</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_asmcgocall">
               <h3>
                  FuncID_asmcgocall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_asmcgocall</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_asyncPreempt">
               <h3>
                  FuncID_asyncPreempt 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_asyncPreempt</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_cgocallback">
               <h3>
                  FuncID_cgocallback 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_cgocallback</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_corostart">
               <h3>
                  FuncID_corostart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_corostart</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_debugCallV2">
               <h3>
                  FuncID_debugCallV2 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_debugCallV2</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_gcBgMarkWorker">
               <h3>
                  FuncID_gcBgMarkWorker 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_gcBgMarkWorker</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_goexit">
               <h3>
                  FuncID_goexit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_goexit</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_gogo">
               <h3>
                  FuncID_gogo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_gogo</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_gopanic">
               <h3>
                  FuncID_gopanic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_gopanic</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_handleAsyncEvent">
               <h3>
                  FuncID_handleAsyncEvent 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_handleAsyncEvent</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_mcall">
               <h3>
                  FuncID_mcall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_mcall</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_morestack">
               <h3>
                  FuncID_morestack 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_morestack</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_mstart">
               <h3>
                  FuncID_mstart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_mstart</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_panicwrap">
               <h3>
                  FuncID_panicwrap 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_panicwrap</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_rt0_go">
               <h3>
                  FuncID_rt0_go 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_rt0_go</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_runfinq">
               <h3>
                  FuncID_runfinq 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_runfinq</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_runtime_main">
               <h3>
                  FuncID_runtime_main 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_runtime_main</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_sigpanic">
               <h3>
                  FuncID_sigpanic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_sigpanic</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_systemstack">
               <h3>
                  FuncID_systemstack 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_systemstack</code></pre>
            </article>
            
            <article class="global" data-name="FuncID_systemstack_switch">
               <h3>
                  FuncID_systemstack_switch 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncID_systemstack_switch</code></pre>
            </article>
            
            <article class="global" data-name="FuncTabBucketSize">
               <h3>
                  FuncTabBucketSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const FuncTabBucketSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="Int">
               <h3>
                  Int 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Int</code></pre>
            </article>
            
            <article class="global" data-name="Int16">
               <h3>
                  Int16 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Int16</code></pre>
            </article>
            
            <article class="global" data-name="Int32">
               <h3>
                  Int32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Int32</code></pre>
            </article>
            
            <article class="global" data-name="Int64">
               <h3>
                  Int64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Int64</code></pre>
            </article>
            
            <article class="global" data-name="Int8">
               <h3>
                  Int8 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Int8</code></pre>
            </article>
            
            <article class="global" data-name="IntArgRegs">
               <h3>
                  IntArgRegs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>RAX, RBX, RCX, RDI, RSI, R8, R9, R10, R11.</p>
               
               <pre><code>const IntArgRegs = 9</code></pre>
            </article>
            
            <article class="global" data-name="IntArgRegs">
               <h3>
                  IntArgRegs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>R4 - R19</p>
               
               <pre><code>const IntArgRegs = 16</code></pre>
            </article>
            
            <article class="global" data-name="IntArgRegs">
               <h3>
                  IntArgRegs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>X8 - X23</p>
               
               <pre><code>const IntArgRegs = 16</code></pre>
            </article>
            
            <article class="global" data-name="IntArgRegs">
               <h3>
                  IntArgRegs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>R3 - R10, R14 - R17.</p>
               
               <pre><code>const IntArgRegs = 12</code></pre>
            </article>
            
            <article class="global" data-name="IntArgRegs">
               <h3>
                  IntArgRegs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IntArgRegs is the number of registers dedicated
to passing integer argument values. Result registers are identical
to argument registers, so this number is used for those too.</p>
               
               <pre><code>const IntArgRegs = 0</code></pre>
            </article>
            
            <article class="global" data-name="IntArgRegs">
               <h3>
                  IntArgRegs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>R0 - R15.</p>
               
               <pre><code>const IntArgRegs = 16</code></pre>
            </article>
            
            <article class="global" data-name="Interface">
               <h3>
                  Interface 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Interface</code></pre>
            </article>
            
            <article class="global" data-name="Invalid">
               <h3>
                  Invalid 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Invalid Kind = iota</code></pre>
            </article>
            
            <article class="global" data-name="InvalidDir">
               <h3>
                  InvalidDir 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const InvalidDir ChanDir = 0</code></pre>
            </article>
            
            <article class="global" data-name="KindDirectIface">
               <h3>
                  KindDirectIface 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>TODO (khr, drchase) why aren't these in TFlag?  Investigate, fix if possible.</p>
               
               <pre><code>const KindDirectIface Kind = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="KindMask">
               <h3>
                  KindMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const KindMask Kind = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="MINFUNC">
               <h3>
                  MINFUNC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const MINFUNC = 16</code></pre>
            </article>
            
            <article class="global" data-name="Map">
               <h3>
                  Map 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Map</code></pre>
            </article>
            
            <article class="global" data-name="MaxPtrmaskBytes">
               <h3>
                  MaxPtrmaskBytes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>MaxPtrmaskBytes is the maximum length of a GC ptrmask bitmap,
which holds 1-bit entries describing where pointers are in a given type.
Above this length, the GC information is recorded as a GC program,
which can express repetition compactly. In either form, the
information is used by the runtime to initialize the heap bitmap,
and for large types (like 128 or more words), they are roughly the
same speed. GC programs are never much larger and often more
compact. (If large arrays are involved, they can be arbitrarily
more compact.)
The cutoff must be large enough that any allocation large enough to
use a GC program is large enough that it does not share heap bitmap
bytes with any other objects, allowing the GC program execution to
assume an aligned start and not use atomic operations. In the current
runtime, this means all malloc size classes larger than the cutoff must
be multiples of four words. On 32-bit systems that's 16 bytes, and
all size classes >= 16 bytes are 16-byte aligned, so no real constraint.
On 64-bit systems, that's 32 bytes, and 32-byte alignment is guaranteed
for size classes >= 256 bytes. On a 64-bit system, 256 bytes allocated
is 32 pointers, the bits for which fit in 4 bytes. So MaxPtrmaskBytes
must be >= 4.
We used to use 16 because the GC programs do have some constant overhead
to get started, and processing 128 pointers seems to be enough to
amortize that overhead well.
To make sure that the runtime's chansend can call typeBitsBulkBarrier,
we raised the limit to 2048, so that even 32-bit systems are guaranteed to
use bitmaps for objects up to 64 kB in size.</p>
               
               <pre><code>const MaxPtrmaskBytes = 2048</code></pre>
            </article>
            
            <article class="global" data-name="OldMapBucketCount">
               <h3>
                  OldMapBucketCount 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Map constants common to several packages
runtime/runtime-gdb.py:MapTypePrinter contains its own copy</p>
               
               <pre><code>const OldMapBucketCount = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="OldMapBucketCountBits">
               <h3>
                  OldMapBucketCountBits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Maximum number of key/elem pairs a bucket can hold.</p>
               
               <pre><code>const OldMapBucketCountBits = 3</code></pre>
            </article>
            
            <article class="global" data-name="OldMapMaxElemBytes">
               <h3>
                  OldMapMaxElemBytes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Map constants common to several packages
runtime/runtime-gdb.py:MapTypePrinter contains its own copy</p>
               
               <pre><code>const OldMapMaxElemBytes = 128</code></pre>
            </article>
            
            <article class="global" data-name="OldMapMaxKeyBytes">
               <h3>
                  OldMapMaxKeyBytes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Maximum key or elem size to keep inline (instead of mallocing per element).
Must fit in a uint8.
Note: fast map functions cannot handle big elems (bigger than MapMaxElemBytes).</p>
               
               <pre><code>const OldMapMaxKeyBytes = 128</code></pre>
            </article>
            
            <article class="global" data-name="PCDATA_ArgLiveIndex">
               <h3>
                  PCDATA_ArgLiveIndex 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const PCDATA_ArgLiveIndex = 3</code></pre>
            </article>
            
            <article class="global" data-name="PCDATA_InlTreeIndex">
               <h3>
                  PCDATA_InlTreeIndex 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const PCDATA_InlTreeIndex = 2</code></pre>
            </article>
            
            <article class="global" data-name="PCDATA_StackMapIndex">
               <h3>
                  PCDATA_StackMapIndex 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const PCDATA_StackMapIndex = 1</code></pre>
            </article>
            
            <article class="global" data-name="PCDATA_UnsafePoint">
               <h3>
                  PCDATA_UnsafePoint 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>IDs for PCDATA and FUNCDATA tables in Go binaries.
These must agree with ../../../runtime/funcdata.h.</p>
               
               <pre><code>const PCDATA_UnsafePoint = 0</code></pre>
            </article>
            
            <article class="global" data-name="Pointer">
               <h3>
                  Pointer 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Pointer</code></pre>
            </article>
            
            <article class="global" data-name="RF_DONE">
               <h3>
                  RF_DONE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants are shared between the compiler, which uses them for state functions
and panic indicators, and the runtime, which turns them into more meaningful strings
For best code generation, RF_DONE and RF_READY should be 0 and 1.</p>
               
               <pre><code>const RF_DONE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="RF_EXHAUSTED">
               <h3>
                  RF_EXHAUSTED 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants are shared between the compiler, which uses them for state functions
and panic indicators, and the runtime, which turns them into more meaningful strings
For best code generation, RF_DONE and RF_READY should be 0 and 1.</p>
               
               <pre><code>const RF_EXHAUSTED</code></pre>
            </article>
            
            <article class="global" data-name="RF_MISSING_PANIC">
               <h3>
                  RF_MISSING_PANIC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants are shared between the compiler, which uses them for state functions
and panic indicators, and the runtime, which turns them into more meaningful strings
For best code generation, RF_DONE and RF_READY should be 0 and 1.</p>
               
               <pre><code>const RF_MISSING_PANIC = 4</code></pre>
            </article>
            
            <article class="global" data-name="RF_PANIC">
               <h3>
                  RF_PANIC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants are shared between the compiler, which uses them for state functions
and panic indicators, and the runtime, which turns them into more meaningful strings
For best code generation, RF_DONE and RF_READY should be 0 and 1.</p>
               
               <pre><code>const RF_PANIC</code></pre>
            </article>
            
            <article class="global" data-name="RF_READY">
               <h3>
                  RF_READY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These constants are shared between the compiler, which uses them for state functions
and panic indicators, and the runtime, which turns them into more meaningful strings
For best code generation, RF_DONE and RF_READY should be 0 and 1.</p>
               
               <pre><code>const RF_READY</code></pre>
            </article>
            
            <article class="global" data-name="RecvDir">
               <h3>
                  RecvDir 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const RecvDir ChanDir = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="SendDir">
               <h3>
                  SendDir 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SendDir</code></pre>
            </article>
            
            <article class="global" data-name="Slice">
               <h3>
                  Slice 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Slice</code></pre>
            </article>
            
            <article class="global" data-name="StackBig">
               <h3>
                  StackBig 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Functions that need frames <= StackBig can assume that neither
SP-framesize nor stackGuard-StackSmall will underflow, and thus use a
more efficient check. In order to ensure this, StackBig must be <= the
size of the unmapped space at zero.</p>
               
               <pre><code>const StackBig = 4096</code></pre>
            </article>
            
            <article class="global" data-name="StackNosplitBase">
               <h3>
                  StackNosplitBase 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>StackNosplitBase is the base maximum number of bytes that a chain of
NOSPLIT functions can use.
This value must be multiplied by the stack guard multiplier, so do not
use it directly. See runtime/stack.go:stackNosplit and
cmd/internal/objabi/stack.go:StackNosplit.</p>
               
               <pre><code>const StackNosplitBase = 800</code></pre>
            </article>
            
            <article class="global" data-name="StackSmall">
               <h3>
                  StackSmall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>After a stack split check the SP is allowed to be StackSmall bytes below
the stack guard.
Functions that need frames <= StackSmall can perform the stack check
using a single comparison directly between the stack guard and the SP
because we ensure that StackSmall bytes of stack space are available
beyond the stack guard.</p>
               
               <pre><code>const StackSmall = 128</code></pre>
            </article>
            
            <article class="global" data-name="String">
               <h3>
                  String 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const String</code></pre>
            </article>
            
            <article class="global" data-name="Struct">
               <h3>
                  Struct 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Struct</code></pre>
            </article>
            
            <article class="global" data-name="SwissMapCtrlEmpty">
               <h3>
                  SwissMapCtrlEmpty 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Value of control word with all empty slots.</p>
               
               <pre><code>const SwissMapCtrlEmpty = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="SwissMapGroupSlots">
               <h3>
                  SwissMapGroupSlots 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Number of slots in a group.</p>
               
               <pre><code>const SwissMapGroupSlots = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="SwissMapGroupSlotsBits">
               <h3>
                  SwissMapGroupSlotsBits 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Number of bits in the group.slot count.</p>
               
               <pre><code>const SwissMapGroupSlotsBits = 3</code></pre>
            </article>
            
            <article class="global" data-name="SwissMapHashMightPanic">
               <h3>
                  SwissMapHashMightPanic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flag values</p>
               
               <pre><code>const SwissMapHashMightPanic</code></pre>
            </article>
            
            <article class="global" data-name="SwissMapIndirectElem">
               <h3>
                  SwissMapIndirectElem 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flag values</p>
               
               <pre><code>const SwissMapIndirectElem</code></pre>
            </article>
            
            <article class="global" data-name="SwissMapIndirectKey">
               <h3>
                  SwissMapIndirectKey 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flag values</p>
               
               <pre><code>const SwissMapIndirectKey</code></pre>
            </article>
            
            <article class="global" data-name="SwissMapMaxElemBytes">
               <h3>
                  SwissMapMaxElemBytes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Map constants common to several packages
runtime/runtime-gdb.py:MapTypePrinter contains its own copy</p>
               
               <pre><code>const SwissMapMaxElemBytes = 128</code></pre>
            </article>
            
            <article class="global" data-name="SwissMapMaxKeyBytes">
               <h3>
                  SwissMapMaxKeyBytes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Maximum key or elem size to keep inline (instead of mallocing per element).
Must fit in a uint8.</p>
               
               <pre><code>const SwissMapMaxKeyBytes = 128</code></pre>
            </article>
            
            <article class="global" data-name="SwissMapNeedKeyUpdate">
               <h3>
                  SwissMapNeedKeyUpdate 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Flag values</p>
               
               <pre><code>const SwissMapNeedKeyUpdate = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="TFlagExtraStar">
               <h3>
                  TFlagExtraStar 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>TFlagExtraStar means the name in the str field has an
extraneous '*' prefix. This is because for most types T in
a program, the type *T also exists and reusing the str data
saves binary size.</p>
               
               <pre><code>const TFlagExtraStar TFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="TFlagGCMaskOnDemand">
               <h3>
                  TFlagGCMaskOnDemand 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>TFlagGCMaskOnDemand means that the GC pointer bitmask will be
computed on demand at runtime instead of being precomputed at
compile time. If this flag is set, the GCData field effectively
has type **byte instead of *byte. The runtime will store a
pointer to the GC pointer bitmask in *GCData.</p>
               
               <pre><code>const TFlagGCMaskOnDemand TFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="TFlagNamed">
               <h3>
                  TFlagNamed 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>TFlagNamed means the type has a name.</p>
               
               <pre><code>const TFlagNamed TFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="TFlagRegularMemory">
               <h3>
                  TFlagRegularMemory 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>TFlagRegularMemory means that equal and hash functions can treat
this type as a single region of t.size bytes.</p>
               
               <pre><code>const TFlagRegularMemory TFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="TFlagUncommon">
               <h3>
                  TFlagUncommon 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>TFlagUncommon means that there is a data with a type, UncommonType,
just beyond the shared-per-type common data.  That is, the data
for struct types will store their UncommonType at one offset, the
data for interface types will store their UncommonType at a different
offset.  UncommonType is always accessed via a pointer that is computed
using trust-us-we-are-the-implementors pointer arithmetic.
For example, if t.Kind() == Struct and t.tflag&TFlagUncommon != 0,
then t has UncommonType data and it can be accessed as:
type structTypeUncommon struct {
structType
u UncommonType
}
u := &(*structTypeUncommon)(unsafe.Pointer(t)).u</p>
               
               <pre><code>const TFlagUncommon TFlag = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="TraceArgsDotdotdot">
               <h3>
                  TraceArgsDotdotdot 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Populate the data.
The data is a stream of bytes, which contains the offsets and sizes of the
non-aggregate arguments or non-aggregate fields/elements of aggregate-typed
arguments, along with special "operators". Specifically,
- for each non-aggregate arg/field/element, its offset from FP (1 byte) and
size (1 byte)
- special operators:
- 0xff - end of sequence
- 0xfe - print { (at the start of an aggregate-typed argument)
- 0xfd - print } (at the end of an aggregate-typed argument)
- 0xfc - print ... (more args/fields/elements)
- 0xfb - print _ (offset too large)</p>
               
               <pre><code>const TraceArgsDotdotdot = 0xfc</code></pre>
            </article>
            
            <article class="global" data-name="TraceArgsEndAgg">
               <h3>
                  TraceArgsEndAgg 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Populate the data.
The data is a stream of bytes, which contains the offsets and sizes of the
non-aggregate arguments or non-aggregate fields/elements of aggregate-typed
arguments, along with special "operators". Specifically,
- for each non-aggregate arg/field/element, its offset from FP (1 byte) and
size (1 byte)
- special operators:
- 0xff - end of sequence
- 0xfe - print { (at the start of an aggregate-typed argument)
- 0xfd - print } (at the end of an aggregate-typed argument)
- 0xfc - print ... (more args/fields/elements)
- 0xfb - print _ (offset too large)</p>
               
               <pre><code>const TraceArgsEndAgg = 0xfd</code></pre>
            </article>
            
            <article class="global" data-name="TraceArgsEndSeq">
               <h3>
                  TraceArgsEndSeq 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Populate the data.
The data is a stream of bytes, which contains the offsets and sizes of the
non-aggregate arguments or non-aggregate fields/elements of aggregate-typed
arguments, along with special "operators". Specifically,
- for each non-aggregate arg/field/element, its offset from FP (1 byte) and
size (1 byte)
- special operators:
- 0xff - end of sequence
- 0xfe - print { (at the start of an aggregate-typed argument)
- 0xfd - print } (at the end of an aggregate-typed argument)
- 0xfc - print ... (more args/fields/elements)
- 0xfb - print _ (offset too large)</p>
               
               <pre><code>const TraceArgsEndSeq = 0xff</code></pre>
            </article>
            
            <article class="global" data-name="TraceArgsLimit">
               <h3>
                  TraceArgsLimit 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TraceArgsLimit = 10</code></pre>
            </article>
            
            <article class="global" data-name="TraceArgsMaxDepth">
               <h3>
                  TraceArgsMaxDepth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const TraceArgsMaxDepth = 5</code></pre>
            </article>
            
            <article class="global" data-name="TraceArgsMaxLen">
               <h3>
                  TraceArgsMaxLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxLen is a (conservative) upper bound of the byte stream length. For
each arg/component, it has no more than 2 bytes of data (size, offset),
and no more than one {, }, ... at each level (it cannot have both the
data and ... unless it is the last one, just be conservative). Plus 1
for _endSeq.</p>
               
               <pre><code>const TraceArgsMaxLen = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="TraceArgsOffsetTooLarge">
               <h3>
                  TraceArgsOffsetTooLarge 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Populate the data.
The data is a stream of bytes, which contains the offsets and sizes of the
non-aggregate arguments or non-aggregate fields/elements of aggregate-typed
arguments, along with special "operators". Specifically,
- for each non-aggregate arg/field/element, its offset from FP (1 byte) and
size (1 byte)
- special operators:
- 0xff - end of sequence
- 0xfe - print { (at the start of an aggregate-typed argument)
- 0xfd - print } (at the end of an aggregate-typed argument)
- 0xfc - print ... (more args/fields/elements)
- 0xfb - print _ (offset too large)</p>
               
               <pre><code>const TraceArgsOffsetTooLarge = 0xfb</code></pre>
            </article>
            
            <article class="global" data-name="TraceArgsSpecial">
               <h3>
                  TraceArgsSpecial 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Populate the data.
The data is a stream of bytes, which contains the offsets and sizes of the
non-aggregate arguments or non-aggregate fields/elements of aggregate-typed
arguments, along with special "operators". Specifically,
- for each non-aggregate arg/field/element, its offset from FP (1 byte) and
size (1 byte)
- special operators:
- 0xff - end of sequence
- 0xfe - print { (at the start of an aggregate-typed argument)
- 0xfd - print } (at the end of an aggregate-typed argument)
- 0xfc - print ... (more args/fields/elements)
- 0xfb - print _ (offset too large)</p>
               
               <pre><code>const TraceArgsSpecial = 0xf0</code></pre>
            </article>
            
            <article class="global" data-name="TraceArgsStartAgg">
               <h3>
                  TraceArgsStartAgg 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Populate the data.
The data is a stream of bytes, which contains the offsets and sizes of the
non-aggregate arguments or non-aggregate fields/elements of aggregate-typed
arguments, along with special "operators". Specifically,
- for each non-aggregate arg/field/element, its offset from FP (1 byte) and
size (1 byte)
- special operators:
- 0xff - end of sequence
- 0xfe - print { (at the start of an aggregate-typed argument)
- 0xfd - print } (at the end of an aggregate-typed argument)
- 0xfc - print ... (more args/fields/elements)
- 0xfb - print _ (offset too large)</p>
               
               <pre><code>const TraceArgsStartAgg = 0xfe</code></pre>
            </article>
            
            <article class="global" data-name="Uint">
               <h3>
                  Uint 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Uint</code></pre>
            </article>
            
            <article class="global" data-name="Uint16">
               <h3>
                  Uint16 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Uint16</code></pre>
            </article>
            
            <article class="global" data-name="Uint32">
               <h3>
                  Uint32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Uint32</code></pre>
            </article>
            
            <article class="global" data-name="Uint64">
               <h3>
                  Uint64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Uint64</code></pre>
            </article>
            
            <article class="global" data-name="Uint8">
               <h3>
                  Uint8 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Uint8</code></pre>
            </article>
            
            <article class="global" data-name="Uintptr">
               <h3>
                  Uintptr 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Uintptr</code></pre>
            </article>
            
            <article class="global" data-name="UnsafePointRestart1">
               <h3>
                  UnsafePointRestart1 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>UnsafePointRestart1(2) apply on a sequence of instructions, within
which if an async preemption happens, we should back off the PC
to the start of the sequence when resuming.
We need two so we can distinguish the start/end of the sequence
in case that two sequences are next to each other.</p>
               
               <pre><code>const UnsafePointRestart1 = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="UnsafePointRestart2">
               <h3>
                  UnsafePointRestart2 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Special values for the PCDATA_UnsafePoint table.</p>
               
               <pre><code>const UnsafePointRestart2 = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="UnsafePointRestartAtEntry">
               <h3>
                  UnsafePointRestartAtEntry 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Like UnsafePointRestart1, but back to function entry if async preempted.</p>
               
               <pre><code>const UnsafePointRestartAtEntry = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="UnsafePointSafe">
               <h3>
                  UnsafePointSafe 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Special values for the PCDATA_UnsafePoint table.</p>
               
               <pre><code>const UnsafePointSafe = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="UnsafePointUnsafe">
               <h3>
                  UnsafePointUnsafe 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Special values for the PCDATA_UnsafePoint table.</p>
               
               <pre><code>const UnsafePointUnsafe = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="UnsafePointer">
               <h3>
                  UnsafePointer 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const UnsafePointer</code></pre>
            </article>
            
            <article class="global" data-name="ZeroValSize">
               <h3>
                  ZeroValSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>ZeroValSize is the size in bytes of runtime.zeroVal.</p>
               
               <pre><code>const ZeroValSize = 1024</code></pre>
            </article>
            
            <article class="global" data-name="alwaysFalse">
               <h3>
                  alwaysFalse 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var alwaysFalse bool</code></pre>
            </article>
            
            <article class="global" data-name="bitsetLSB">
               <h3>
                  bitsetLSB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Map constants common to several packages
runtime/runtime-gdb.py:MapTypePrinter contains its own copy</p>
               
               <pre><code>const bitsetLSB = 0x0101010101010101</code></pre>
            </article>
            
            <article class="global" data-name="ctrlEmpty">
               <h3>
                  ctrlEmpty 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Map constants common to several packages
runtime/runtime-gdb.py:MapTypePrinter contains its own copy</p>
               
               <pre><code>const ctrlEmpty = 0b10000000</code></pre>
            </article>
            
            <article class="global" data-name="escapeSink">
               <h3>
                  escapeSink 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var escapeSink any</code></pre>
            </article>
            
            <article class="global" data-name="go122InterfaceSwitchCache">
               <h3>
                  go122InterfaceSwitchCache 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const go122InterfaceSwitchCache = true</code></pre>
            </article>
            
            <article class="global" data-name="kindNames">
               <h3>
                  kindNames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var kindNames = []string{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="ChanDir">
               <h3>
                  ChanDir
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type ChanDir int</code></pre>
            </article>
            
            <article class="type" data-name="FuncFlag">
               <h3>
                  FuncFlag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A FuncFlag records bits about a function, passed to the runtime.</p>
               
               <pre><code>type FuncFlag uint8</code></pre>
            </article>
            
            <article class="type" data-name="FuncID">
               <h3>
                  FuncID
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A FuncID identifies particular functions that need to be treated
specially by the runtime.
Note that in some situations involving plugins, there may be multiple
copies of a particular special runtime function.</p>
               
               <pre><code>type FuncID uint8</code></pre>
            </article>
            
            <article class="type" data-name="IntArgRegBitmap">
               <h3>
                  IntArgRegBitmap
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>IntArgRegBitmap is a bitmap large enough to hold one bit per
integer argument/return register.</p>
               
               <pre><code>type IntArgRegBitmap [*ast.BinaryExpr]uint8</code></pre>
            </article>
            
            <article class="type" data-name="Kind">
               <h3>
                  Kind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Kind represents the specific kind of type that a Type represents.
The zero Kind is not a valid kind.</p>
               
               <pre><code>type Kind uint8</code></pre>
            </article>
            
            <article class="type" data-name="NameOff">
               <h3>
                  NameOff
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>NameOff is the offset to a name from moduledata.types.  See resolveNameOff in runtime.</p>
               
               <pre><code>type NameOff int32</code></pre>
            </article>
            
            <article class="type" data-name="RF_State">
               <h3>
                  RF_State
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type RF_State int</code></pre>
            </article>
            
            <article class="type" data-name="TFlag">
               <h3>
                  TFlag
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>TFlag is used by a Type to signal what extra type information is
available in the memory directly following the Type value.</p>
               
               <pre><code>type TFlag uint8</code></pre>
            </article>
            
            <article class="type" data-name="TextOff">
               <h3>
                  TextOff
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>TextOff is an offset from the top of a text section.  See (rtype).textOff in runtime.</p>
               
               <pre><code>type TextOff int32</code></pre>
            </article>
            
            <article class="type" data-name="TypeOff">
               <h3>
                  TypeOff
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>TypeOff is the offset to a type from moduledata.types.  See resolveTypeOff in runtime.</p>
               
               <pre><code>type TypeOff int32</code></pre>
            </article>
            
            <article class="type" data-name="mapType">
               <h3>
                  mapType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Select the map type that this binary is built using. This is for common
lookup methods like Type.Key to know which type to use.
Note that mapType *must not be used by any functions called in the
compiler to build a target program* because the compiler must use the map
type determined by run-time GOEXPERIMENT, not the build tags used to build
the compiler.
TODO(prattmic): This package is rather confusing because it has many
functions that can't be used by the compiler (e.g., Type.Uncommon depends on
the layout of type + uncommon objects in the binary. It would be incorrect
for an ad-hoc local Type object). It may be best to move code that isn't
usable by the compiler out of the package.</p>
               
               <pre><code>type mapType SwissMapType</code></pre>
            </article>
            
            <article class="type" data-name="mapType">
               <h3>
                  mapType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>See comment in map_select_swiss.go.</p>
               
               <pre><code>type mapType OldMapType</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="ArrayType">
               <h3>
                  ArrayType
                  <span class="badge">struct</span>
               </h3>
               
               <p>ArrayType represents a fixed array type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ArrayType struct {
Type
Elem *Type
Slice *Type
Len uintptr
}</code></pre>
            </article>
            
            <article class="struct" data-name="ChanType">
               <h3>
                  ChanType
                  <span class="badge">struct</span>
               </h3>
               
               <p>ChanType represents a channel type</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ChanType struct {
Type
Elem *Type
Dir ChanDir
}</code></pre>
            </article>
            
            <article class="struct" data-name="EmptyInterface">
               <h3>
                  EmptyInterface
                  <span class="badge">struct</span>
               </h3>
               
               <p>EmptyInterface describes the layout of a "interface{}" or a "any."
These are represented differently than non-empty interface, as the first
word always points to an abi.Type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type EmptyInterface struct {
Type *Type
Data unsafe.Pointer
}</code></pre>
            </article>
            
            <article class="struct" data-name="FuncType">
               <h3>
                  FuncType
                  <span class="badge">struct</span>
               </h3>
               
               <p>funcType represents a function type.
A *Type for each in and out parameter is stored in an array that
directly follows the funcType (and possibly its uncommonType). So
a function type with one method, one input, and one output is:
struct {
funcType
uncommonType
[2]*rtype    // [0] is in, [1] is out
}</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FuncType struct {
Type
InCount uint16
OutCount uint16
}</code></pre>
            </article>
            
            <article class="struct" data-name="ITab">
               <h3>
                  ITab
                  <span class="badge">struct</span>
               </h3>
               
               <p>The first word of every non-empty interface type contains an *ITab.
It records the underlying concrete type (Type), the interface type it
is implementing (Inter), and some ancillary information.
allocated in non-garbage-collected memory</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ITab struct {
Inter *InterfaceType
Type *Type
Hash uint32
Fun [1]uintptr
}</code></pre>
            </article>
            
            <article class="struct" data-name="Imethod">
               <h3>
                  Imethod
                  <span class="badge">struct</span>
               </h3>
               
               <p>Imethod represents a method on an interface type</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Imethod struct {
Name NameOff
Typ TypeOff
}</code></pre>
            </article>
            
            <article class="struct" data-name="InterfaceSwitch">
               <h3>
                  InterfaceSwitch
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InterfaceSwitch struct {
Cache *InterfaceSwitchCache
NCases int
Cases [1]*InterfaceType
}</code></pre>
            </article>
            
            <article class="struct" data-name="InterfaceSwitchCache">
               <h3>
                  InterfaceSwitchCache
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InterfaceSwitchCache struct {
Mask uintptr
Entries [1]InterfaceSwitchCacheEntry
}</code></pre>
            </article>
            
            <article class="struct" data-name="InterfaceSwitchCacheEntry">
               <h3>
                  InterfaceSwitchCacheEntry
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InterfaceSwitchCacheEntry struct {
Typ uintptr
Case int
Itab uintptr
}</code></pre>
            </article>
            
            <article class="struct" data-name="InterfaceType">
               <h3>
                  InterfaceType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InterfaceType struct {
Type
PkgPath Name
Methods []Imethod
}</code></pre>
            </article>
            
            <article class="struct" data-name="Method">
               <h3>
                  Method
                  <span class="badge">struct</span>
               </h3>
               
               <p>Method on non-interface type</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Method struct {
Name NameOff
Mtyp TypeOff
Ifn TextOff
Tfn TextOff
}</code></pre>
            </article>
            
            <article class="struct" data-name="Name">
               <h3>
                  Name
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Name struct {
Bytes *byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="OldMapType">
               <h3>
                  OldMapType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type OldMapType struct {
Type
Key *Type
Elem *Type
Bucket *Type
Hasher func(unsafe.Pointer, uintptr) uintptr
KeySize uint8
ValueSize uint8
BucketSize uint16
Flags uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="PtrType">
               <h3>
                  PtrType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PtrType struct {
Type
Elem *Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="RegArgs">
               <h3>
                  RegArgs
                  <span class="badge">struct</span>
               </h3>
               
               <p>RegArgs is a struct that has space for each argument
and return value register on the current architecture.
Assembly code knows the layout of the first two fields
of RegArgs.
RegArgs also contains additional space to hold pointers
when it may not be safe to keep them only in the integer
register space otherwise.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type RegArgs struct {
Ints [IntArgRegs]uintptr
Floats [FloatArgRegs]uint64
Ptrs [IntArgRegs]unsafe.Pointer
ReturnIsPtr IntArgRegBitmap
}</code></pre>
            </article>
            
            <article class="struct" data-name="SliceType">
               <h3>
                  SliceType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SliceType struct {
Type
Elem *Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="StructField">
               <h3>
                  StructField
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StructField struct {
Name Name
Typ *Type
Offset uintptr
}</code></pre>
            </article>
            
            <article class="struct" data-name="StructType">
               <h3>
                  StructType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StructType struct {
Type
PkgPath Name
Fields []StructField
}</code></pre>
            </article>
            
            <article class="struct" data-name="SwissMapType">
               <h3>
                  SwissMapType
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SwissMapType struct {
Type
Key *Type
Elem *Type
Group *Type
Hasher func(unsafe.Pointer, uintptr) uintptr
GroupSize uintptr
SlotSize uintptr
ElemOff uintptr
Flags uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="Type">
               <h3>
                  Type
                  <span class="badge">struct</span>
               </h3>
               
               <p>Type is the runtime representation of a Go type.
Be careful about accessing this type at build time, as the version
of this type in the compiler/linker may not have the same layout
as the version in the target binary, due to pointer width
differences and any experiments. Use cmd/compile/internal/rttype
or the functions in compiletype.go to access this type instead.
(TODO: this admonition applies to every type in this package.
Put it in some shared location?)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Type struct {
Size_ uintptr
PtrBytes uintptr
Hash uint32
TFlag TFlag
Align_ uint8
FieldAlign_ uint8
Kind_ Kind
Equal func(unsafe.Pointer, unsafe.Pointer) bool
GCData *byte
Str NameOff
PtrToThis TypeOff
}</code></pre>
            </article>
            
            <article class="struct" data-name="TypeAssert">
               <h3>
                  TypeAssert
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TypeAssert struct {
Cache *TypeAssertCache
Inter *InterfaceType
CanFail bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="TypeAssertCache">
               <h3>
                  TypeAssertCache
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TypeAssertCache struct {
Mask uintptr
Entries [1]TypeAssertCacheEntry
}</code></pre>
            </article>
            
            <article class="struct" data-name="TypeAssertCacheEntry">
               <h3>
                  TypeAssertCacheEntry
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TypeAssertCacheEntry struct {
Typ uintptr
Itab uintptr
}</code></pre>
            </article>
            
            <article class="struct" data-name="UncommonType">
               <h3>
                  UncommonType
                  <span class="badge">struct</span>
               </h3>
               
               <p>UncommonType is present only for defined types or types with methods
(if T is a defined type, the uncommonTypes for T and *T have methods).
Using a pointer to this struct reduces the overall size required
to describe a non-defined type with no methods.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UncommonType struct {
PkgPath NameOff
Mcount uint16
Xcount uint16
Moff uint32
_ uint32
}</code></pre>
            </article>
            
            <article class="struct" data-name="structTypeUncommon">
               <h3>
                  structTypeUncommon
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type structTypeUncommon struct {
StructType
u UncommonType
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Align">
               <h3>
                  Align 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Align returns the alignment of data with type t.</p>
               
               <pre><code>func (t *Type) Align() int</code></pre>
            </article>
            
            <article class="function" data-name="ArrayType">
               <h3>
                  ArrayType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ArrayType returns t cast to a *ArrayType, or nil if its tag does not match.</p>
               
               <pre><code>func (t *Type) ArrayType() *ArrayType</code></pre>
            </article>
            
            <article class="function" data-name="ChanDir">
               <h3>
                  ChanDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ChanDir returns the direction of t if t is a channel type, otherwise InvalidDir (0).</p>
               
               <pre><code>func (t *Type) ChanDir() ChanDir</code></pre>
            </article>
            
            <article class="function" data-name="Common">
               <h3>
                  Common 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) Common() *Type</code></pre>
            </article>
            
            <article class="function" data-name="CommonSize">
               <h3>
                  CommonSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CommonSize returns sizeof(Type) for a compilation target with a given ptrSize</p>
               
               <pre><code>func CommonSize(ptrSize int) int</code></pre>
            </article>
            
            <article class="function" data-name="Data">
               <h3>
                  Data 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Data does pointer arithmetic on n's Bytes, and that arithmetic is asserted to
be safe because the runtime made the call (other packages use DataChecked)</p>
               
               <pre><code>func (n Name) Data(off int) *byte</code></pre>
            </article>
            
            <article class="function" data-name="DataChecked">
               <h3>
                  DataChecked 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DataChecked does pointer arithmetic on n's Bytes, and that arithmetic is asserted to
be safe for the reason in whySafe (which can appear in a backtrace, etc.)</p>
               
               <pre><code>func (n Name) DataChecked(off int, whySafe string) *byte</code></pre>
            </article>
            
            <article class="function" data-name="Dump">
               <h3>
                  Dump 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *RegArgs) Dump()</code></pre>
            </article>
            
            <article class="function" data-name="Elem">
               <h3>
                  Elem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Elem returns the element type for t if t is an array, channel, map, pointer, or slice, otherwise nil.</p>
               
               <pre><code>func (t *Type) Elem() *Type</code></pre>
            </article>
            
            <article class="function" data-name="Embedded">
               <h3>
                  Embedded 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *StructField) Embedded() bool</code></pre>
            </article>
            
            <article class="function" data-name="Escape">
               <h3>
                  Escape 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Escape forces any pointers in x to escape to the heap.</p>
               
               <pre><code>func Escape(x T) T</code></pre>
            </article>
            
            <article class="function" data-name="ExportedMethods">
               <h3>
                  ExportedMethods 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *UncommonType) ExportedMethods() []Method</code></pre>
            </article>
            
            <article class="function" data-name="ExportedMethods">
               <h3>
                  ExportedMethods 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) ExportedMethods() []Method</code></pre>
            </article>
            
            <article class="function" data-name="FieldAlign">
               <h3>
                  FieldAlign 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) FieldAlign() int</code></pre>
            </article>
            
            <article class="function" data-name="FuncPCABI0">
               <h3>
                  FuncPCABI0 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func FuncPCABI0(f interface{}) uintptr</code></pre>
            </article>
            
            <article class="function" data-name="FuncPCABI0">
               <h3>
                  FuncPCABI0 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FuncPCABI0 returns the entry PC of the function f, which must be a
direct reference of a function defined as ABI0. Otherwise it is a
compile-time error.
Implemented as a compile intrinsic.</p>
               
               <pre><code>func FuncPCABI0(f interface{}) uintptr</code></pre>
            </article>
            
            <article class="function" data-name="FuncPCABIInternal">
               <h3>
                  FuncPCABIInternal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FuncPCABIInternal returns the entry PC of the function f. If f is a
direct reference of a function, it must be defined as ABIInternal.
Otherwise it is a compile-time error. If f is not a direct reference
of a defined function, it assumes that f is a func value. Otherwise
the behavior is undefined.
Implemented as a compile intrinsic.</p>
               
               <pre><code>func FuncPCABIInternal(f interface{}) uintptr</code></pre>
            </article>
            
            <article class="function" data-name="FuncPCABIInternal">
               <h3>
                  FuncPCABIInternal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func FuncPCABIInternal(f interface{}) uintptr</code></pre>
            </article>
            
            <article class="function" data-name="FuncType">
               <h3>
                  FuncType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FuncType returns t cast to a *FuncType, or nil if its tag does not match.</p>
               
               <pre><code>func (t *Type) FuncType() *FuncType</code></pre>
            </article>
            
            <article class="function" data-name="GcSlice">
               <h3>
                  GcSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) GcSlice(begin uintptr, end uintptr) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Get">
               <h3>
                  Get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Get returns whether the i'th bit of the bitmap is set.
nosplit because it's called in extremely sensitive contexts, like
on the reflectcall return path.
go:nosplit</p>
               
               <pre><code>func (b *IntArgRegBitmap) Get(i int) bool</code></pre>
            </article>
            
            <article class="function" data-name="HasName">
               <h3>
                  HasName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) HasName() bool</code></pre>
            </article>
            
            <article class="function" data-name="HasTag">
               <h3>
                  HasTag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>HasTag returns true iff there is tag data following this name</p>
               
               <pre><code>func (n Name) HasTag() bool</code></pre>
            </article>
            
            <article class="function" data-name="HashMightPanic">
               <h3>
                  HashMightPanic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mt *SwissMapType) HashMightPanic() bool</code></pre>
            </article>
            
            <article class="function" data-name="HashMightPanic">
               <h3>
                  HashMightPanic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mt *OldMapType) HashMightPanic() bool</code></pre>
            </article>
            
            <article class="function" data-name="ITabTypeOff">
               <h3>
                  ITabTypeOff 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ITabTypeOff returns the offset of ITab.Type for a compilation target with a given ptrSize</p>
               
               <pre><code>func ITabTypeOff(ptrSize int) int</code></pre>
            </article>
            
            <article class="function" data-name="IfaceIndir">
               <h3>
                  IfaceIndir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IfaceIndir reports whether t is stored indirectly in an interface value.</p>
               
               <pre><code>func (t *Type) IfaceIndir() bool</code></pre>
            </article>
            
            <article class="function" data-name="In">
               <h3>
                  In 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *FuncType) In(i int) *Type</code></pre>
            </article>
            
            <article class="function" data-name="InSlice">
               <h3>
                  InSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *FuncType) InSlice() []*Type</code></pre>
            </article>
            
            <article class="function" data-name="IndirectElem">
               <h3>
                  IndirectElem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mt *OldMapType) IndirectElem() bool</code></pre>
            </article>
            
            <article class="function" data-name="IndirectElem">
               <h3>
                  IndirectElem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mt *SwissMapType) IndirectElem() bool</code></pre>
            </article>
            
            <article class="function" data-name="IndirectKey">
               <h3>
                  IndirectKey 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mt *SwissMapType) IndirectKey() bool</code></pre>
            </article>
            
            <article class="function" data-name="IndirectKey">
               <h3>
                  IndirectKey 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Note: flag values must match those used in the TMAP case
in ../cmd/compile/internal/reflectdata/reflect.go:writeType.</p>
               
               <pre><code>func (mt *OldMapType) IndirectKey() bool</code></pre>
            </article>
            
            <article class="function" data-name="IntRegArgAddr">
               <h3>
                  IntRegArgAddr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IntRegArgAddr returns a pointer inside of r.Ints[reg] that is appropriately
offset for an argument of size argSize.
argSize must be non-zero, fit in a register, and a power-of-two.
This method is a helper for dealing with the endianness of different CPU
architectures, since sub-word-sized arguments in big endian architectures
need to be "aligned" to the upper edge of the register to be interpreted
by the CPU correctly.</p>
               
               <pre><code>func (r *RegArgs) IntRegArgAddr(reg int, argSize uintptr) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="InterfaceType">
               <h3>
                  InterfaceType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>InterfaceType returns t cast to a *InterfaceType, or nil if its tag does not match.</p>
               
               <pre><code>func (t *Type) InterfaceType() *InterfaceType</code></pre>
            </article>
            
            <article class="function" data-name="IsBlank">
               <h3>
                  IsBlank 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsBlank indicates whether n is "_".</p>
               
               <pre><code>func (n Name) IsBlank() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsDirectIface">
               <h3>
                  IsDirectIface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isDirectIface reports whether t is stored directly in an interface value.</p>
               
               <pre><code>func (t *Type) IsDirectIface() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsEmbedded">
               <h3>
                  IsEmbedded 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsEmbedded returns true iff n is embedded (an anonymous field).</p>
               
               <pre><code>func (n Name) IsEmbedded() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsExported">
               <h3>
                  IsExported 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsExported returns "is n exported?"</p>
               
               <pre><code>func (n Name) IsExported() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsVariadic">
               <h3>
                  IsVariadic 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *FuncType) IsVariadic() bool</code></pre>
            </article>
            
            <article class="function" data-name="Key">
               <h3>
                  Key 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) Key() *Type</code></pre>
            </article>
            
            <article class="function" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) Kind() Kind</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Len returns the length of t if t is an array type, otherwise 0</p>
               
               <pre><code>func (t *Type) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="MapType">
               <h3>
                  MapType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MapType returns t cast to a *OldMapType or *SwissMapType, or nil if its tag does not match.</p>
               
               <pre><code>func (t *Type) MapType() *mapType</code></pre>
            </article>
            
            <article class="function" data-name="Methods">
               <h3>
                  Methods 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *UncommonType) Methods() []Method</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Name returns the tag string for n, or empty if there is none.</p>
               
               <pre><code>func (n Name) Name() string</code></pre>
            </article>
            
            <article class="function" data-name="NeedKeyUpdate">
               <h3>
                  NeedKeyUpdate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mt *SwissMapType) NeedKeyUpdate() bool</code></pre>
            </article>
            
            <article class="function" data-name="NeedKeyUpdate">
               <h3>
                  NeedKeyUpdate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mt *OldMapType) NeedKeyUpdate() bool</code></pre>
            </article>
            
            <article class="function" data-name="NewName">
               <h3>
                  NewName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func NewName(n string, tag string, exported bool, embedded bool) Name</code></pre>
            </article>
            
            <article class="function" data-name="NoEscape">
               <h3>
                  NoEscape 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NoEscape hides the pointer p from escape analysis, preventing it
from escaping to the heap. It compiles down to nothing.
WARNING: This is very subtle to use correctly. The caller must
ensure that it's truly safe for p to not escape to the heap by
maintaining runtime pointer invariants (for example, that globals
and the heap may not generally point into a stack).
go:nosplit
go:nocheckptr</p>
               
               <pre><code>func NoEscape(p unsafe.Pointer) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="NumIn">
               <h3>
                  NumIn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *FuncType) NumIn() int</code></pre>
            </article>
            
            <article class="function" data-name="NumMethod">
               <h3>
                  NumMethod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Type) NumMethod() int</code></pre>
            </article>
            
            <article class="function" data-name="NumMethod">
               <h3>
                  NumMethod 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NumMethod returns the number of interface methods in the type's method set.</p>
               
               <pre><code>func (t *InterfaceType) NumMethod() int</code></pre>
            </article>
            
            <article class="function" data-name="NumOut">
               <h3>
                  NumOut 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *FuncType) NumOut() int</code></pre>
            </article>
            
            <article class="function" data-name="Out">
               <h3>
                  Out 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *FuncType) Out(i int) *Type</code></pre>
            </article>
            
            <article class="function" data-name="OutSlice">
               <h3>
                  OutSlice 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *FuncType) OutSlice() []*Type</code></pre>
            </article>
            
            <article class="function" data-name="Pointers">
               <h3>
                  Pointers 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pointers reports whether t contains pointers.</p>
               
               <pre><code>func (t *Type) Pointers() bool</code></pre>
            </article>
            
            <article class="function" data-name="ReadVarint">
               <h3>
                  ReadVarint 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ReadVarint parses a varint as encoded by encoding/binary.
It returns the number of encoded bytes and the encoded value.</p>
               
               <pre><code>func (n Name) ReadVarint(off int) (int, int)</code></pre>
            </article>
            
            <article class="function" data-name="ReflexiveKey">
               <h3>
                  ReflexiveKey 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (mt *OldMapType) ReflexiveKey() bool</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set sets the i'th bit of the bitmap to 1.</p>
               
               <pre><code>func (b *IntArgRegBitmap) Set(i int)</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Size returns the size of data with type t.</p>
               
               <pre><code>func (t *Type) Size() uintptr</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the name of k.</p>
               
               <pre><code>func (k Kind) String() string</code></pre>
            </article>
            
            <article class="function" data-name="StructFieldSize">
               <h3>
                  StructFieldSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>StructFieldSize returns sizeof(StructField) for a compilation target with a given ptrSize</p>
               
               <pre><code>func StructFieldSize(ptrSize int) int</code></pre>
            </article>
            
            <article class="function" data-name="StructType">
               <h3>
                  StructType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>StructType returns t cast to a *StructType, or nil if its tag does not match.</p>
               
               <pre><code>func (t *Type) StructType() *StructType</code></pre>
            </article>
            
            <article class="function" data-name="TFlagOff">
               <h3>
                  TFlagOff 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TFlagOff returns the offset of Type.TFlag for a compilation target with a given ptrSize</p>
               
               <pre><code>func TFlagOff(ptrSize int) int</code></pre>
            </article>
            
            <article class="function" data-name="Tag">
               <h3>
                  Tag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Tag returns the tag string for n, or empty if there is none.</p>
               
               <pre><code>func (n Name) Tag() string</code></pre>
            </article>
            
            <article class="function" data-name="TypeFor">
               <h3>
                  TypeFor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TypeFor returns the abi.Type for a type parameter.</p>
               
               <pre><code>func TypeFor() *Type</code></pre>
            </article>
            
            <article class="function" data-name="TypeOf">
               <h3>
                  TypeOf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TypeOf returns the abi.Type of some value.</p>
               
               <pre><code>func TypeOf(a any) *Type</code></pre>
            </article>
            
            <article class="function" data-name="Uncommon">
               <h3>
                  Uncommon 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Uncommon returns a pointer to T's "uncommon" data if there is any, otherwise nil</p>
               
               <pre><code>func (t *Type) Uncommon() *UncommonType</code></pre>
            </article>
            
            <article class="function" data-name="UncommonSize">
               <h3>
                  UncommonSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>UncommonSize returns sizeof(UncommonType).  This currently does not depend on ptrSize.
This exported function is in an internal package, so it may change to depend on ptrSize in the future.</p>
               
               <pre><code>func UncommonSize() uint64</code></pre>
            </article>
            
            <article class="function" data-name="UseInterfaceSwitchCache">
               <h3>
                  UseInterfaceSwitchCache 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func UseInterfaceSwitchCache(goarch string) bool</code></pre>
            </article>
            
            <article class="function" data-name="addChecked">
               <h3>
                  addChecked 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addChecked returns p+x.
The whySafe string is ignored, so that the function still inlines
as efficiently as p+x, but all call sites should use the string to
record why the addition is safe, which is to say why the addition
does not cause x to advance to the very end of p's allocation
and therefore point incorrectly at the next block in memory.</p>
               
               <pre><code>func addChecked(p unsafe.Pointer, x uintptr, whySafe string) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="writeVarint">
               <h3>
                  writeVarint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>writeVarint writes n to buf in varint form. Returns the
number of bytes written. n must be nonnegative.
Writes at most 10 bytes.</p>
               
               <pre><code>func writeVarint(buf []byte, n int) int</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
