<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - png</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>png</code>
         </h1>
         <hr />
         
         <article class="global" data-name="intSize">
            <h2>intSize</h2>
            <hr />
            
            <p>intSize is either 32 or 64.</p>
            
            <pre><code>intSize</code></pre>
         </article>
         
         <article class="global" data-name="ctGrayscale">
            <h2>ctGrayscale</h2>
            <hr />
            
            <p>Color type, as per the PNG spec.</p>
            
            <pre><code>ctGrayscale</code></pre>
         </article>
         
         <article class="global" data-name="ctTrueColor">
            <h2>ctTrueColor</h2>
            <hr />
            
            <p>Color type, as per the PNG spec.</p>
            
            <pre><code>ctTrueColor</code></pre>
         </article>
         
         <article class="global" data-name="ctPaletted">
            <h2>ctPaletted</h2>
            <hr />
            
            <p>Color type, as per the PNG spec.</p>
            
            <pre><code>ctPaletted</code></pre>
         </article>
         
         <article class="global" data-name="ctGrayscaleAlpha">
            <h2>ctGrayscaleAlpha</h2>
            <hr />
            
            <p>Color type, as per the PNG spec.</p>
            
            <pre><code>ctGrayscaleAlpha</code></pre>
         </article>
         
         <article class="global" data-name="ctTrueColorAlpha">
            <h2>ctTrueColorAlpha</h2>
            <hr />
            
            <p>Color type, as per the PNG spec.</p>
            
            <pre><code>ctTrueColorAlpha</code></pre>
         </article>
         
         <article class="global" data-name="cbInvalid">
            <h2>cbInvalid</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbInvalid</code></pre>
         </article>
         
         <article class="global" data-name="cbG1">
            <h2>cbG1</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbG1</code></pre>
         </article>
         
         <article class="global" data-name="cbG2">
            <h2>cbG2</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbG2</code></pre>
         </article>
         
         <article class="global" data-name="cbG4">
            <h2>cbG4</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbG4</code></pre>
         </article>
         
         <article class="global" data-name="cbG8">
            <h2>cbG8</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbG8</code></pre>
         </article>
         
         <article class="global" data-name="cbGA8">
            <h2>cbGA8</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbGA8</code></pre>
         </article>
         
         <article class="global" data-name="cbTC8">
            <h2>cbTC8</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbTC8</code></pre>
         </article>
         
         <article class="global" data-name="cbP1">
            <h2>cbP1</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbP1</code></pre>
         </article>
         
         <article class="global" data-name="cbP2">
            <h2>cbP2</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbP2</code></pre>
         </article>
         
         <article class="global" data-name="cbP4">
            <h2>cbP4</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbP4</code></pre>
         </article>
         
         <article class="global" data-name="cbP8">
            <h2>cbP8</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbP8</code></pre>
         </article>
         
         <article class="global" data-name="cbTCA8">
            <h2>cbTCA8</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbTCA8</code></pre>
         </article>
         
         <article class="global" data-name="cbG16">
            <h2>cbG16</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbG16</code></pre>
         </article>
         
         <article class="global" data-name="cbGA16">
            <h2>cbGA16</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbGA16</code></pre>
         </article>
         
         <article class="global" data-name="cbTC16">
            <h2>cbTC16</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbTC16</code></pre>
         </article>
         
         <article class="global" data-name="cbTCA16">
            <h2>cbTCA16</h2>
            <hr />
            
            <p>A cb is a combination of color type and bit depth.</p>
            
            <pre><code>cbTCA16</code></pre>
         </article>
         
         <article class="global" data-name="ftNone">
            <h2>ftNone</h2>
            <hr />
            
            <p>Filter type, as per the PNG spec.</p>
            
            <pre><code>ftNone</code></pre>
         </article>
         
         <article class="global" data-name="ftSub">
            <h2>ftSub</h2>
            <hr />
            
            <p>Filter type, as per the PNG spec.</p>
            
            <pre><code>ftSub</code></pre>
         </article>
         
         <article class="global" data-name="ftUp">
            <h2>ftUp</h2>
            <hr />
            
            <p>Filter type, as per the PNG spec.</p>
            
            <pre><code>ftUp</code></pre>
         </article>
         
         <article class="global" data-name="ftAverage">
            <h2>ftAverage</h2>
            <hr />
            
            <p>Filter type, as per the PNG spec.</p>
            
            <pre><code>ftAverage</code></pre>
         </article>
         
         <article class="global" data-name="ftPaeth">
            <h2>ftPaeth</h2>
            <hr />
            
            <p>Filter type, as per the PNG spec.</p>
            
            <pre><code>ftPaeth</code></pre>
         </article>
         
         <article class="global" data-name="nFilter">
            <h2>nFilter</h2>
            <hr />
            
            <p>Filter type, as per the PNG spec.</p>
            
            <pre><code>nFilter</code></pre>
         </article>
         
         <article class="global" data-name="itNone">
            <h2>itNone</h2>
            <hr />
            
            <p>Interlace type.</p>
            
            <pre><code>itNone</code></pre>
         </article>
         
         <article class="global" data-name="itAdam7">
            <h2>itAdam7</h2>
            <hr />
            
            <p>Interlace type.</p>
            
            <pre><code>itAdam7</code></pre>
         </article>
         
         <article class="global" data-name="interlacing">
            <h2>interlacing</h2>
            <hr />
            
            <p>interlacing defines Adam7 interlacing, with 7 passes of reduced images.
See https://www.w3.org/TR/PNG/#8Interlace</p>
            
            <pre><code>interlacing</code></pre>
         </article>
         
         <article class="global" data-name="dsStart">
            <h2>dsStart</h2>
            <hr />
            
            <p>Decoding stage.
The PNG specification says that the IHDR, PLTE (if present), tRNS (if
present), IDAT and IEND chunks must appear in that order. There may be
multiple IDAT chunks, and IDAT chunks must be sequential (i.e. they may not
have any other chunks between them).
https://www.w3.org/TR/PNG/#5ChunkOrdering</p>
            
            <pre><code>dsStart</code></pre>
         </article>
         
         <article class="global" data-name="dsSeenIHDR">
            <h2>dsSeenIHDR</h2>
            <hr />
            
            <p>Decoding stage.
The PNG specification says that the IHDR, PLTE (if present), tRNS (if
present), IDAT and IEND chunks must appear in that order. There may be
multiple IDAT chunks, and IDAT chunks must be sequential (i.e. they may not
have any other chunks between them).
https://www.w3.org/TR/PNG/#5ChunkOrdering</p>
            
            <pre><code>dsSeenIHDR</code></pre>
         </article>
         
         <article class="global" data-name="dsSeenPLTE">
            <h2>dsSeenPLTE</h2>
            <hr />
            
            <p>Decoding stage.
The PNG specification says that the IHDR, PLTE (if present), tRNS (if
present), IDAT and IEND chunks must appear in that order. There may be
multiple IDAT chunks, and IDAT chunks must be sequential (i.e. they may not
have any other chunks between them).
https://www.w3.org/TR/PNG/#5ChunkOrdering</p>
            
            <pre><code>dsSeenPLTE</code></pre>
         </article>
         
         <article class="global" data-name="dsSeentRNS">
            <h2>dsSeentRNS</h2>
            <hr />
            
            <p>Decoding stage.
The PNG specification says that the IHDR, PLTE (if present), tRNS (if
present), IDAT and IEND chunks must appear in that order. There may be
multiple IDAT chunks, and IDAT chunks must be sequential (i.e. they may not
have any other chunks between them).
https://www.w3.org/TR/PNG/#5ChunkOrdering</p>
            
            <pre><code>dsSeentRNS</code></pre>
         </article>
         
         <article class="global" data-name="dsSeenIDAT">
            <h2>dsSeenIDAT</h2>
            <hr />
            
            <p>Decoding stage.
The PNG specification says that the IHDR, PLTE (if present), tRNS (if
present), IDAT and IEND chunks must appear in that order. There may be
multiple IDAT chunks, and IDAT chunks must be sequential (i.e. they may not
have any other chunks between them).
https://www.w3.org/TR/PNG/#5ChunkOrdering</p>
            
            <pre><code>dsSeenIDAT</code></pre>
         </article>
         
         <article class="global" data-name="dsSeenIEND">
            <h2>dsSeenIEND</h2>
            <hr />
            
            <p>Decoding stage.
The PNG specification says that the IHDR, PLTE (if present), tRNS (if
present), IDAT and IEND chunks must appear in that order. There may be
multiple IDAT chunks, and IDAT chunks must be sequential (i.e. they may not
have any other chunks between them).
https://www.w3.org/TR/PNG/#5ChunkOrdering</p>
            
            <pre><code>dsSeenIEND</code></pre>
         </article>
         
         <article class="global" data-name="pngHeader">
            <h2>pngHeader</h2>
            <hr />
            
            <pre><code>pngHeader</code></pre>
         </article>
         
         <article class="global" data-name="chunkOrderError">
            <h2>chunkOrderError</h2>
            <hr />
            
            <pre><code>chunkOrderError</code></pre>
         </article>
         
         <article class="global" data-name="filenames">
            <h2>filenames</h2>
            <hr />
            
            <pre><code>filenames</code></pre>
         </article>
         
         <article class="global" data-name="filenamesPaletted">
            <h2>filenamesPaletted</h2>
            <hr />
            
            <pre><code>filenamesPaletted</code></pre>
         </article>
         
         <article class="global" data-name="filenamesShort">
            <h2>filenamesShort</h2>
            <hr />
            
            <pre><code>filenamesShort</code></pre>
         </article>
         
         <article class="global" data-name="fakebKGDs">
            <h2>fakebKGDs</h2>
            <hr />
            
            <p>fakebKGDs maps from filenames to fake bKGD chunks for our approximation to
the sng command-line tool. Package png doesn't keep that metadata when
png.Decode returns an image.Image.</p>
            
            <pre><code>fakebKGDs</code></pre>
         </article>
         
         <article class="global" data-name="fakegAMAs">
            <h2>fakegAMAs</h2>
            <hr />
            
            <p>fakegAMAs maps from filenames to fake gAMA chunks for our approximation to
the sng command-line tool. Package png doesn't keep that metadata when
png.Decode returns an image.Image.</p>
            
            <pre><code>fakegAMAs</code></pre>
         </article>
         
         <article class="global" data-name="fakeIHDRUsings">
            <h2>fakeIHDRUsings</h2>
            <hr />
            
            <p>fakeIHDRUsings maps from filenames to fake IHDR "using" lines for our
approximation to the sng command-line tool. The PNG model is that
transparency (in the tRNS chunk) is separate to the color/grayscale/palette
color model (in the IHDR chunk). The Go model is that the concrete
image.Image type returned by png.Decode, such as image.RGBA (with all pixels
having 100% alpha) or image.NRGBA, encapsulates whether or not the image has
transparency. This map is a hack to work around the fact that the Go model
can't otherwise discriminate PNG's "IHDR says color (with no alpha) but tRNS
says alpha" and "IHDR says color with alpha".</p>
            
            <pre><code>fakeIHDRUsings</code></pre>
         </article>
         
         <article class="global" data-name="readerErrors">
            <h2>readerErrors</h2>
            <hr />
            
            <pre><code>readerErrors</code></pre>
         </article>
         
         <article class="global" data-name="DefaultCompression">
            <h2>DefaultCompression</h2>
            <hr />
            
            <pre><code>DefaultCompression CompressionLevel</code></pre>
         </article>
         
         <article class="global" data-name="NoCompression">
            <h2>NoCompression</h2>
            <hr />
            
            <pre><code>NoCompression CompressionLevel</code></pre>
         </article>
         
         <article class="global" data-name="BestSpeed">
            <h2>BestSpeed</h2>
            <hr />
            
            <pre><code>BestSpeed CompressionLevel</code></pre>
         </article>
         
         <article class="global" data-name="BestCompression">
            <h2>BestCompression</h2>
            <hr />
            
            <pre><code>BestCompression CompressionLevel</code></pre>
         </article>
          
         <article class="struct" data-name="interlaceScan">
            <h2>type interlaceScan struct</h2>
            <hr />
            
            <p>interlaceScan defines the placement and size of a pass for Adam7 interlacing.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">xFactor int
yFactor int
xOffset int
yOffset int</code></pre>
         </article>
         
         <article class="struct" data-name="decoder">
            <h2>type decoder struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">r io.Reader
img image.Image
crc hash.Hash32
width int
height int
depth int
palette color.Palette
cb int
stage int
idatLength uint32
tmp []byte
interlace int
useTransparent bool
transparent []byte</code></pre>
         </article>
         
         <article class="struct" data-name="Encoder">
            <h2>type Encoder struct</h2>
            <hr />
            
            <p>Encoder configures encoding PNG images.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">CompressionLevel CompressionLevel
BufferPool EncoderBufferPool</code></pre>
         </article>
         
         <article class="struct" data-name="encoder">
            <h2>type encoder struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">enc *Encoder
w io.Writer
m image.Image
cb int
err error
header []byte
footer []byte
tmp []byte
cr [][]uint8
pr []uint8
zw *zlib.Writer
zwLevel int
bw *bufio.Writer</code></pre>
         </article>
         
         <article class="struct" data-name="pool">
            <h2>type pool struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">b *EncoderBuffer</code></pre>
         </article>
          
         <article class="function" data-name="FuzzDecode">
            <h2>FuzzDecode</h2>
            <hr />
            
            <pre><code>func FuzzDecode(f *testing.F)</code></pre>
         </article>
         
         <article class="function" data-name="abs">
            <h2>abs</h2>
            <hr />
            
            <pre><code>func abs(x int) int</code></pre>
         </article>
         
         <article class="function" data-name="paeth">
            <h2>paeth</h2>
            <hr />
            
            <p>paeth implements the Paeth filter function, as per the PNG specification.</p>
            
            <pre><code>func paeth(a uint8, b uint8, c uint8) uint8</code></pre>
         </article>
         
         <article class="function" data-name="filterPaeth">
            <h2>filterPaeth</h2>
            <hr />
            
            <p>filterPaeth applies the Paeth filter to the cdat slice.
cdat is the current row's data, pdat is the previous row's data.</p>
            
            <pre><code>func filterPaeth(cdat []byte, pdat []byte, bytesPerPixel int)</code></pre>
         </article>
         
         <article class="function" data-name="slowAbs">
            <h2>slowAbs</h2>
            <hr />
            
            <pre><code>func slowAbs(x int) int</code></pre>
         </article>
         
         <article class="function" data-name="slowPaeth">
            <h2>slowPaeth</h2>
            <hr />
            
            <p>slowPaeth is a slow but simple implementation of the Paeth function.
It is a straight port of the sample code in the PNG spec, section 9.4.</p>
            
            <pre><code>func slowPaeth(a uint8, b uint8, c uint8) uint8</code></pre>
         </article>
         
         <article class="function" data-name="slowFilterPaeth">
            <h2>slowFilterPaeth</h2>
            <hr />
            
            <p>slowFilterPaeth is a slow but simple implementation of func filterPaeth.</p>
            
            <pre><code>func slowFilterPaeth(cdat []byte, pdat []byte, bytesPerPixel int)</code></pre>
         </article>
         
         <article class="function" data-name="TestPaeth">
            <h2>TestPaeth</h2>
            <hr />
            
            <pre><code>func TestPaeth(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkPaeth">
            <h2>BenchmarkPaeth</h2>
            <hr />
            
            <pre><code>func BenchmarkPaeth(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestPaethDecode">
            <h2>TestPaethDecode</h2>
            <hr />
            
            <pre><code>func TestPaethDecode(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="cbPaletted">
            <h2>cbPaletted</h2>
            <hr />
            
            <pre><code>func cbPaletted(cb int) bool</code></pre>
         </article>
         
         <article class="function" data-name="cbTrueColor">
            <h2>cbTrueColor</h2>
            <hr />
            
            <pre><code>func cbTrueColor(cb int) bool</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="parseIHDR">
            <h2>parseIHDR</h2>
            <hr />
            
            <pre><code>func parseIHDR(length uint32) error</code></pre>
         </article>
         
         <article class="function" data-name="parsePLTE">
            <h2>parsePLTE</h2>
            <hr />
            
            <pre><code>func parsePLTE(length uint32) error</code></pre>
         </article>
         
         <article class="function" data-name="parsetRNS">
            <h2>parsetRNS</h2>
            <hr />
            
            <pre><code>func parsetRNS(length uint32) error</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <p>Read presents one or more IDAT chunks as one continuous stream (minus the
intermediate chunk headers and footers). If the PNG data looked like:

	... len0 IDAT xxx crc0 len1 IDAT yy crc1 len2 IEND crc2

then this reader presents xxxyy. For well-formed PNG data, the decoder state
immediately before the first Read call is that d.r is positioned between the
first IDAT and xxx, and the decoder state immediately after the last Read
call is that d.r is positioned between yy and crc1.</p>
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="decode">
            <h2>decode</h2>
            <hr />
            
            <p>decode decodes the IDAT data into an image.</p>
            
            <pre><code>func decode() (image.Image, error)</code></pre>
         </article>
         
         <article class="function" data-name="readImagePass">
            <h2>readImagePass</h2>
            <hr />
            
            <p>readImagePass reads a single image pass, sized according to the pass number.</p>
            
            <pre><code>func readImagePass(r io.Reader, pass int, allocateOnly bool) (image.Image, error)</code></pre>
         </article>
         
         <article class="function" data-name="mergePassInto">
            <h2>mergePassInto</h2>
            <hr />
            
            <p>mergePassInto merges a single pass into a full sized image.</p>
            
            <pre><code>func mergePassInto(dst image.Image, src image.Image, pass int)</code></pre>
         </article>
         
         <article class="function" data-name="parseIDAT">
            <h2>parseIDAT</h2>
            <hr />
            
            <pre><code>func parseIDAT(length uint32) err error</code></pre>
         </article>
         
         <article class="function" data-name="parseIEND">
            <h2>parseIEND</h2>
            <hr />
            
            <pre><code>func parseIEND(length uint32) error</code></pre>
         </article>
         
         <article class="function" data-name="parseChunk">
            <h2>parseChunk</h2>
            <hr />
            
            <pre><code>func parseChunk(configOnly bool) error</code></pre>
         </article>
         
         <article class="function" data-name="verifyChecksum">
            <h2>verifyChecksum</h2>
            <hr />
            
            <pre><code>func verifyChecksum() error</code></pre>
         </article>
         
         <article class="function" data-name="checkHeader">
            <h2>checkHeader</h2>
            <hr />
            
            <pre><code>func checkHeader() error</code></pre>
         </article>
         
         <article class="function" data-name="Decode">
            <h2>Decode</h2>
            <hr />
            
            <p>Decode reads a PNG image from r and returns it as an [image.Image].
The type of Image returned depends on the PNG contents.</p>
            
            <pre><code>func Decode(r io.Reader) (image.Image, error)</code></pre>
         </article>
         
         <article class="function" data-name="DecodeConfig">
            <h2>DecodeConfig</h2>
            <hr />
            
            <p>DecodeConfig returns the color model and dimensions of a PNG image without
decoding the entire image.</p>
            
            <pre><code>func DecodeConfig(r io.Reader) (image.Config, error)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="readPNG">
            <h2>readPNG</h2>
            <hr />
            
            <pre><code>func readPNG(filename string) (image.Image, error)</code></pre>
         </article>
         
         <article class="function" data-name="sng">
            <h2>sng</h2>
            <hr />
            
            <p>An approximation of the sng command-line tool.</p>
            
            <pre><code>func sng(w io.WriteCloser, filename string, png image.Image)</code></pre>
         </article>
         
         <article class="function" data-name="TestReader">
            <h2>TestReader</h2>
            <hr />
            
            <pre><code>func TestReader(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReaderError">
            <h2>TestReaderError</h2>
            <hr />
            
            <pre><code>func TestReaderError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPalettedDecodeConfig">
            <h2>TestPalettedDecodeConfig</h2>
            <hr />
            
            <pre><code>func TestPalettedDecodeConfig(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInterlaced">
            <h2>TestInterlaced</h2>
            <hr />
            
            <pre><code>func TestInterlaced(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIncompleteIDATOnRowBoundary">
            <h2>TestIncompleteIDATOnRowBoundary</h2>
            <hr />
            
            <pre><code>func TestIncompleteIDATOnRowBoundary(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTrailingIDATChunks">
            <h2>TestTrailingIDATChunks</h2>
            <hr />
            
            <pre><code>func TestTrailingIDATChunks(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMultipletRNSChunks">
            <h2>TestMultipletRNSChunks</h2>
            <hr />
            
            <pre><code>func TestMultipletRNSChunks(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnknownChunkLengthUnderflow">
            <h2>TestUnknownChunkLengthUnderflow</h2>
            <hr />
            
            <pre><code>func TestUnknownChunkLengthUnderflow(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPaletted8OutOfRangePixel">
            <h2>TestPaletted8OutOfRangePixel</h2>
            <hr />
            
            <pre><code>func TestPaletted8OutOfRangePixel(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestGray8Transparent">
            <h2>TestGray8Transparent</h2>
            <hr />
            
            <pre><code>func TestGray8Transparent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDimensionOverflow">
            <h2>TestDimensionOverflow</h2>
            <hr />
            
            <pre><code>func TestDimensionOverflow(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecodePalettedWithTransparency">
            <h2>TestDecodePalettedWithTransparency</h2>
            <hr />
            
            <pre><code>func TestDecodePalettedWithTransparency(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="benchmarkDecode">
            <h2>benchmarkDecode</h2>
            <hr />
            
            <pre><code>func benchmarkDecode(b *testing.B, filename string, bytesPerPixel int)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecodeGray">
            <h2>BenchmarkDecodeGray</h2>
            <hr />
            
            <pre><code>func BenchmarkDecodeGray(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecodeNRGBAGradient">
            <h2>BenchmarkDecodeNRGBAGradient</h2>
            <hr />
            
            <pre><code>func BenchmarkDecodeNRGBAGradient(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecodeNRGBAOpaque">
            <h2>BenchmarkDecodeNRGBAOpaque</h2>
            <hr />
            
            <pre><code>func BenchmarkDecodeNRGBAOpaque(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecodePaletted">
            <h2>BenchmarkDecodePaletted</h2>
            <hr />
            
            <pre><code>func BenchmarkDecodePaletted(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecodeRGB">
            <h2>BenchmarkDecodeRGB</h2>
            <hr />
            
            <pre><code>func BenchmarkDecodeRGB(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecodeInterlacing">
            <h2>BenchmarkDecodeInterlacing</h2>
            <hr />
            
            <pre><code>func BenchmarkDecodeInterlacing(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="opaque">
            <h2>opaque</h2>
            <hr />
            
            <p>Returns whether or not the image is fully opaque.</p>
            
            <pre><code>func opaque(m image.Image) bool</code></pre>
         </article>
         
         <article class="function" data-name="abs8">
            <h2>abs8</h2>
            <hr />
            
            <p>The absolute value of a byte interpreted as a signed int8.</p>
            
            <pre><code>func abs8(d uint8) int</code></pre>
         </article>
         
         <article class="function" data-name="writeChunk">
            <h2>writeChunk</h2>
            <hr />
            
            <pre><code>func writeChunk(b []byte, name string)</code></pre>
         </article>
         
         <article class="function" data-name="writeIHDR">
            <h2>writeIHDR</h2>
            <hr />
            
            <pre><code>func writeIHDR()</code></pre>
         </article>
         
         <article class="function" data-name="writePLTEAndTRNS">
            <h2>writePLTEAndTRNS</h2>
            <hr />
            
            <pre><code>func writePLTEAndTRNS(p color.Palette)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>An encoder is an io.Writer that satisfies writes by writing PNG IDAT chunks,
including an 8-byte header and 4-byte CRC checksum per Write call. Such calls
should be relatively infrequent, since writeIDATs uses a [bufio.Writer].

This method should only be called from writeIDATs (via writeImage).
No other code should treat an encoder as an io.Writer.</p>
            
            <pre><code>func Write(b []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="filter">
            <h2>filter</h2>
            <hr />
            
            <p>Chooses the filter to use for encoding the current row, and applies it.
The return value is the index of the filter and also of the row in cr that has had it applied.</p>
            
            <pre><code>func filter(cr *[][]byte, pr []byte, bpp int) int</code></pre>
         </article>
         
         <article class="function" data-name="writeImage">
            <h2>writeImage</h2>
            <hr />
            
            <pre><code>func writeImage(w io.Writer, m image.Image, cb int, level int) error</code></pre>
         </article>
         
         <article class="function" data-name="writeIDATs">
            <h2>writeIDATs</h2>
            <hr />
            
            <p>Write the actual image data to one or more IDAT chunks.</p>
            
            <pre><code>func writeIDATs()</code></pre>
         </article>
         
         <article class="function" data-name="levelToZlib">
            <h2>levelToZlib</h2>
            <hr />
            
            <p>This function is required because we want the zero value of
Encoder.CompressionLevel to map to zlib.DefaultCompression.</p>
            
            <pre><code>func levelToZlib(l CompressionLevel) int</code></pre>
         </article>
         
         <article class="function" data-name="writeIEND">
            <h2>writeIEND</h2>
            <hr />
            
            <pre><code>func writeIEND()</code></pre>
         </article>
         
         <article class="function" data-name="Encode">
            <h2>Encode</h2>
            <hr />
            
            <p>Encode writes the Image m to w in PNG format. Any Image may be
encoded, but images that are not [image.NRGBA] might be encoded lossily.</p>
            
            <pre><code>func Encode(w io.Writer, m image.Image) error</code></pre>
         </article>
         
         <article class="function" data-name="Encode">
            <h2>Encode</h2>
            <hr />
            
            <p>Encode writes the Image m to w in PNG format.</p>
            
            <pre><code>func Encode(w io.Writer, m image.Image) error</code></pre>
         </article>
         
         <article class="function" data-name="diff">
            <h2>diff</h2>
            <hr />
            
            <pre><code>func diff(m0 image.Image, m1 image.Image) error</code></pre>
         </article>
         
         <article class="function" data-name="encodeDecode">
            <h2>encodeDecode</h2>
            <hr />
            
            <pre><code>func encodeDecode(m image.Image) (image.Image, error)</code></pre>
         </article>
         
         <article class="function" data-name="convertToNRGBA">
            <h2>convertToNRGBA</h2>
            <hr />
            
            <pre><code>func convertToNRGBA(m image.Image) *image.NRGBA</code></pre>
         </article>
         
         <article class="function" data-name="TestWriter">
            <h2>TestWriter</h2>
            <hr />
            
            <pre><code>func TestWriter(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterPaletted">
            <h2>TestWriterPaletted</h2>
            <hr />
            
            <pre><code>func TestWriterPaletted(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriterLevels">
            <h2>TestWriterLevels</h2>
            <hr />
            
            <pre><code>func TestWriterLevels(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSubImage">
            <h2>TestSubImage</h2>
            <hr />
            
            <pre><code>func TestSubImage(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriteRGBA">
            <h2>TestWriteRGBA</h2>
            <hr />
            
            <pre><code>func TestWriteRGBA(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEncodeGray">
            <h2>BenchmarkEncodeGray</h2>
            <hr />
            
            <pre><code>func BenchmarkEncodeGray(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="Get">
            <h2>Get</h2>
            <hr />
            
            <pre><code>func Get() *EncoderBuffer</code></pre>
         </article>
         
         <article class="function" data-name="Put">
            <h2>Put</h2>
            <hr />
            
            <pre><code>func Put(b *EncoderBuffer)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEncodeGrayWithBufferPool">
            <h2>BenchmarkEncodeGrayWithBufferPool</h2>
            <hr />
            
            <pre><code>func BenchmarkEncodeGrayWithBufferPool(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEncodeNRGBOpaque">
            <h2>BenchmarkEncodeNRGBOpaque</h2>
            <hr />
            
            <pre><code>func BenchmarkEncodeNRGBOpaque(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEncodeNRGBA">
            <h2>BenchmarkEncodeNRGBA</h2>
            <hr />
            
            <pre><code>func BenchmarkEncodeNRGBA(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEncodePaletted">
            <h2>BenchmarkEncodePaletted</h2>
            <hr />
            
            <pre><code>func BenchmarkEncodePaletted(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEncodeRGBOpaque">
            <h2>BenchmarkEncodeRGBOpaque</h2>
            <hr />
            
            <pre><code>func BenchmarkEncodeRGBOpaque(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEncodeRGBA">
            <h2>BenchmarkEncodeRGBA</h2>
            <hr />
            
            <pre><code>func BenchmarkEncodeRGBA(b *testing.B)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
