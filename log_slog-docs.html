<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - slog</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="log_slog_internal-docs.html">internal</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>slog</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"context"
"log"
loginternal "log/internal"
"log/slog/internal"
"runtime"
"sync/atomic"
"time"
"fmt"
"math"
"runtime"
"slices"
"strconv"
"strings"
"time"
"unsafe"
"context"
"fmt"
"io"
"log/slog/internal/buffer"
"reflect"
"slices"
"strconv"
"sync"
"time"
"bytes"
"context"
"encoding/json"
"errors"
"fmt"
"io"
"log/slog/internal/buffer"
"strconv"
"sync"
"time"
"unicode/utf8"
"runtime"
"slices"
"time"
"context"
"encoding"
"fmt"
"io"
"reflect"
"strconv"
"sync"
"unicode"
"unicode/utf8"
"time"
"errors"
"fmt"
"strconv"
"strings"
"sync/atomic"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="DiscardHandler">
               <h3>
                  DiscardHandler 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>DiscardHandler discards all log output.
DiscardHandler.Enabled returns false for all Levels.</p>
               
               <pre><code>var DiscardHandler Handler = discardHandler{...}</code></pre>
            </article>
            
            <article class="global" data-name="KindAny">
               <h3>
                  KindAny 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const KindAny Kind = iota</code></pre>
            </article>
            
            <article class="global" data-name="KindBool">
               <h3>
                  KindBool 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const KindBool</code></pre>
            </article>
            
            <article class="global" data-name="KindDuration">
               <h3>
                  KindDuration 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const KindDuration</code></pre>
            </article>
            
            <article class="global" data-name="KindFloat64">
               <h3>
                  KindFloat64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const KindFloat64</code></pre>
            </article>
            
            <article class="global" data-name="KindGroup">
               <h3>
                  KindGroup 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const KindGroup</code></pre>
            </article>
            
            <article class="global" data-name="KindInt64">
               <h3>
                  KindInt64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const KindInt64</code></pre>
            </article>
            
            <article class="global" data-name="KindLogValuer">
               <h3>
                  KindLogValuer 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const KindLogValuer</code></pre>
            </article>
            
            <article class="global" data-name="KindString">
               <h3>
                  KindString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const KindString</code></pre>
            </article>
            
            <article class="global" data-name="KindTime">
               <h3>
                  KindTime 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const KindTime</code></pre>
            </article>
            
            <article class="global" data-name="KindUint64">
               <h3>
                  KindUint64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const KindUint64</code></pre>
            </article>
            
            <article class="global" data-name="LevelDebug">
               <h3>
                  LevelDebug 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Names for common levels.
Level numbers are inherently arbitrary,
but we picked them to satisfy three constraints.
Any system can map them to another numbering scheme if it wishes.
First, we wanted the default level to be Info, Since Levels are ints, Info is
the default value for int, zero.
Second, we wanted to make it easy to use levels to specify logger verbosity.
Since a larger level means a more severe event, a logger that accepts events
with smaller (or more negative) level means a more verbose logger. Logger
verbosity is thus the negation of event severity, and the default verbosity
of 0 accepts all events at least as severe as INFO.
Third, we wanted some room between levels to accommodate schemes with named
levels between ours. For example, Google Cloud Logging defines a Notice level
between Info and Warn. Since there are only a few of these intermediate
levels, the gap between the numbers need not be large. Our gap of 4 matches
OpenTelemetry's mapping. Subtracting 9 from an OpenTelemetry level in the
DEBUG, INFO, WARN and ERROR ranges converts it to the corresponding slog
Level range. OpenTelemetry also has the names TRACE and FATAL, which slog
does not. But those OpenTelemetry levels can still be represented as slog
Levels by using the appropriate integers.</p>
               
               <pre><code>const LevelDebug Level = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="LevelError">
               <h3>
                  LevelError 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Names for common levels.
Level numbers are inherently arbitrary,
but we picked them to satisfy three constraints.
Any system can map them to another numbering scheme if it wishes.
First, we wanted the default level to be Info, Since Levels are ints, Info is
the default value for int, zero.
Second, we wanted to make it easy to use levels to specify logger verbosity.
Since a larger level means a more severe event, a logger that accepts events
with smaller (or more negative) level means a more verbose logger. Logger
verbosity is thus the negation of event severity, and the default verbosity
of 0 accepts all events at least as severe as INFO.
Third, we wanted some room between levels to accommodate schemes with named
levels between ours. For example, Google Cloud Logging defines a Notice level
between Info and Warn. Since there are only a few of these intermediate
levels, the gap between the numbers need not be large. Our gap of 4 matches
OpenTelemetry's mapping. Subtracting 9 from an OpenTelemetry level in the
DEBUG, INFO, WARN and ERROR ranges converts it to the corresponding slog
Level range. OpenTelemetry also has the names TRACE and FATAL, which slog
does not. But those OpenTelemetry levels can still be represented as slog
Levels by using the appropriate integers.</p>
               
               <pre><code>const LevelError Level = 8</code></pre>
            </article>
            
            <article class="global" data-name="LevelInfo">
               <h3>
                  LevelInfo 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Names for common levels.
Level numbers are inherently arbitrary,
but we picked them to satisfy three constraints.
Any system can map them to another numbering scheme if it wishes.
First, we wanted the default level to be Info, Since Levels are ints, Info is
the default value for int, zero.
Second, we wanted to make it easy to use levels to specify logger verbosity.
Since a larger level means a more severe event, a logger that accepts events
with smaller (or more negative) level means a more verbose logger. Logger
verbosity is thus the negation of event severity, and the default verbosity
of 0 accepts all events at least as severe as INFO.
Third, we wanted some room between levels to accommodate schemes with named
levels between ours. For example, Google Cloud Logging defines a Notice level
between Info and Warn. Since there are only a few of these intermediate
levels, the gap between the numbers need not be large. Our gap of 4 matches
OpenTelemetry's mapping. Subtracting 9 from an OpenTelemetry level in the
DEBUG, INFO, WARN and ERROR ranges converts it to the corresponding slog
Level range. OpenTelemetry also has the names TRACE and FATAL, which slog
does not. But those OpenTelemetry levels can still be represented as slog
Levels by using the appropriate integers.</p>
               
               <pre><code>const LevelInfo Level = 0</code></pre>
            </article>
            
            <article class="global" data-name="LevelKey">
               <h3>
                  LevelKey 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>LevelKey is the key used by the built-in handlers for the level
of the log call. The associated value is a [Level].</p>
               
               <pre><code>const LevelKey = "level"</code></pre>
            </article>
            
            <article class="global" data-name="LevelWarn">
               <h3>
                  LevelWarn 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Names for common levels.
Level numbers are inherently arbitrary,
but we picked them to satisfy three constraints.
Any system can map them to another numbering scheme if it wishes.
First, we wanted the default level to be Info, Since Levels are ints, Info is
the default value for int, zero.
Second, we wanted to make it easy to use levels to specify logger verbosity.
Since a larger level means a more severe event, a logger that accepts events
with smaller (or more negative) level means a more verbose logger. Logger
verbosity is thus the negation of event severity, and the default verbosity
of 0 accepts all events at least as severe as INFO.
Third, we wanted some room between levels to accommodate schemes with named
levels between ours. For example, Google Cloud Logging defines a Notice level
between Info and Warn. Since there are only a few of these intermediate
levels, the gap between the numbers need not be large. Our gap of 4 matches
OpenTelemetry's mapping. Subtracting 9 from an OpenTelemetry level in the
DEBUG, INFO, WARN and ERROR ranges converts it to the corresponding slog
Level range. OpenTelemetry also has the names TRACE and FATAL, which slog
does not. But those OpenTelemetry levels can still be represented as slog
Levels by using the appropriate integers.</p>
               
               <pre><code>const LevelWarn Level = 4</code></pre>
            </article>
            
            <article class="global" data-name="MessageKey">
               <h3>
                  MessageKey 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>MessageKey is the key used by the built-in handlers for the
message of the log call. The associated value is a string.</p>
               
               <pre><code>const MessageKey = "msg"</code></pre>
            </article>
            
            <article class="global" data-name="SourceKey">
               <h3>
                  SourceKey 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>SourceKey is the key used by the built-in handlers for the source file
and line of the log call. The associated value is a *[Source].</p>
               
               <pre><code>const SourceKey = "source"</code></pre>
            </article>
            
            <article class="global" data-name="TimeKey">
               <h3>
                  TimeKey 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>TimeKey is the key used by the built-in handlers for the time
when the log method is called. The associated Value is a [time.Time].</p>
               
               <pre><code>const TimeKey = "time"</code></pre>
            </article>
            
            <article class="global" data-name="badKey">
               <h3>
                  badKey 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const badKey = "!BADKEY"</code></pre>
            </article>
            
            <article class="global" data-name="defaultLogger">
               <h3>
                  defaultLogger 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var defaultLogger *ast.IndexExpr</code></pre>
            </article>
            
            <article class="global" data-name="groupPool">
               <h3>
                  groupPool 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var groupPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global" data-name="hex">
               <h3>
                  hex 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hex = "0123456789abcdef"</code></pre>
            </article>
            
            <article class="global" data-name="keyComponentSep">
               <h3>
                  keyComponentSep 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Separator for group names and keys.</p>
               
               <pre><code>const keyComponentSep = '.'</code></pre>
            </article>
            
            <article class="global" data-name="kindStrings">
               <h3>
                  kindStrings 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var kindStrings = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="logLoggerLevel">
               <h3>
                  logLoggerLevel 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var logLoggerLevel LevelVar</code></pre>
            </article>
            
            <article class="global" data-name="maxLogValues">
               <h3>
                  maxLogValues 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxLogValues = 100</code></pre>
            </article>
            
            <article class="global" data-name="nAttrsInline">
               <h3>
                  nAttrsInline 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nAttrsInline = 5</code></pre>
            </article>
            
            <article class="global" data-name="safeSet">
               <h3>
                  safeSet 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Copied from encoding/json/tables.go.
safeSet holds the value true if the ASCII character with the given array
position can be represented inside a JSON string without any further
escaping.
All values are true except for the ASCII control characters (0-31), the
double quote ("), and the backslash character ("\").</p>
               
               <pre><code>var safeSet = [utf8.RuneSelf]bool{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Kind">
               <h3>
                  Kind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Kind is the kind of a [Value].</p>
               
               <pre><code>type Kind int</code></pre>
            </article>
            
            <article class="type" data-name="Level">
               <h3>
                  Level
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Level is the importance or severity of a log event.
The higher the level, the more important or severe the event.</p>
               
               <pre><code>type Level int</code></pre>
            </article>
            
            <article class="type" data-name="groupptr">
               <h3>
                  groupptr
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type groupptr *Attr</code></pre>
            </article>
            
            <article class="type" data-name="kind">
               <h3>
                  kind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Unexported version of Kind, just so we can store Kinds in Values.
(No user-provided value has this type.)</p>
               
               <pre><code>type kind Kind</code></pre>
            </article>
            
            <article class="type" data-name="stringptr">
               <h3>
                  stringptr
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type stringptr *byte</code></pre>
            </article>
            
            <article class="type" data-name="timeLocation">
               <h3>
                  timeLocation
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Unexported version of *time.Location, just so we can store *time.Locations in
Values. (No user-provided value has this type.)</p>
               
               <pre><code>type timeLocation *time.Location</code></pre>
            </article>
            
            <article class="type" data-name="timeTime">
               <h3>
                  timeTime
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>timeTime is for times where UnixNano is undefined.</p>
               
               <pre><code>type timeTime time.Time</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Handler">
               <h3>
                  Handler
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A Handler handles log records produced by a Logger.
A typical handler may print log records to standard error,
or write them to a file or database, or perhaps augment them
with additional attributes and pass them on to another handler.
Any of the Handler's methods may be called concurrently with itself
or with other methods. It is the responsibility of the Handler to
manage this concurrency.
Users of the slog package should not invoke Handler methods directly.
They should use the methods of [Logger] instead.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Handler interface {
Enabled(context.Context, Level) bool
Handle(context.Context, Record) error
WithAttrs(attrs []Attr) Handler
WithGroup(name string) Handler
}</code></pre>
            </article>
            
            <article class="interface" data-name="Leveler">
               <h3>
                  Leveler
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A Leveler provides a [Level] value.
As Level itself implements Leveler, clients typically supply
a Level value wherever a Leveler is needed, such as in [HandlerOptions].
Clients who need to vary the level dynamically can provide a more complex
Leveler implementation such as *[LevelVar].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Leveler interface {
Level() Level
}</code></pre>
            </article>
            
            <article class="interface" data-name="LogValuer">
               <h3>
                  LogValuer
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A LogValuer is any Go value that can convert itself into a Value for logging.
This mechanism may be used to defer expensive operations until they are
needed, or to expand a single value into a sequence of components.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type LogValuer interface {
LogValue() Value
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Attr">
               <h3>
                  Attr
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Attr is a key-value pair.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Attr struct {
Key string
Value Value
}</code></pre>
            </article>
            
            <article class="struct" data-name="HandlerOptions">
               <h3>
                  HandlerOptions
                  <span class="badge">struct</span>
               </h3>
               
               <p>HandlerOptions are options for a [TextHandler] or [JSONHandler].
A zero HandlerOptions consists entirely of default values.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type HandlerOptions struct {
AddSource bool
Level Leveler
ReplaceAttr func(groups []string, a Attr) Attr
}</code></pre>
            </article>
            
            <article class="struct" data-name="JSONHandler">
               <h3>
                  JSONHandler
                  <span class="badge">struct</span>
               </h3>
               
               <p>JSONHandler is a [Handler] that writes Records to an [io.Writer] as
line-delimited JSON objects.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type JSONHandler struct {
*commonHandler
}</code></pre>
            </article>
            
            <article class="struct" data-name="LevelVar">
               <h3>
                  LevelVar
                  <span class="badge">struct</span>
               </h3>
               
               <p>A LevelVar is a [Level] variable, to allow a [Handler] level to change
dynamically.
It implements [Leveler] as well as a Set method,
and it is safe for use by multiple goroutines.
The zero LevelVar corresponds to [LevelInfo].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type LevelVar struct {
val atomic.Int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Logger">
               <h3>
                  Logger
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Logger records structured information about each call to its
Log, Debug, Info, Warn, and Error methods.
For each call, it creates a [Record] and passes it to a [Handler].
To create a new Logger, call [New] or a Logger method
that begins "With".</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Logger struct {
handler Handler
}</code></pre>
            </article>
            
            <article class="struct" data-name="Record">
               <h3>
                  Record
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Record holds information about a log event.
Copies of a Record share state.
Do not modify a Record after handing out a copy to it.
Call [NewRecord] to create a new Record.
Use [Record.Clone] to create a copy with no shared state.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Record struct {
Time time.Time
Message string
Level Level
PC uintptr
front [nAttrsInline]Attr
nFront int
back []Attr
}</code></pre>
            </article>
            
            <article class="struct" data-name="Source">
               <h3>
                  Source
                  <span class="badge">struct</span>
               </h3>
               
               <p>Source describes the location of a line of source code.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Source struct {
Function string `json:"function"`
File string `json:"file"`
Line int `json:"line"`
}</code></pre>
            </article>
            
            <article class="struct" data-name="TextHandler">
               <h3>
                  TextHandler
                  <span class="badge">struct</span>
               </h3>
               
               <p>TextHandler is a [Handler] that writes Records to an [io.Writer] as a
sequence of key=value pairs separated by spaces and followed by a newline.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TextHandler struct {
*commonHandler
}</code></pre>
            </article>
            
            <article class="struct" data-name="Value">
               <h3>
                  Value
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Value can represent any Go value, but unlike type any,
it can represent most small values without an allocation.
The zero Value corresponds to nil.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Value struct {
_ [0]func()
num uint64
any any
}</code></pre>
            </article>
            
            <article class="struct" data-name="commonHandler">
               <h3>
                  commonHandler
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type commonHandler struct {
json bool
opts HandlerOptions
preformattedAttrs []byte
groupPrefix string
groups []string
nOpenGroups int
mu *sync.Mutex
w io.Writer
}</code></pre>
            </article>
            
            <article class="struct" data-name="defaultHandler">
               <h3>
                  defaultHandler
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type defaultHandler struct {
ch *commonHandler
output func(pc uintptr, data []byte) error
}</code></pre>
            </article>
            
            <article class="struct" data-name="discardHandler">
               <h3>
                  discardHandler
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type discardHandler struct {

}</code></pre>
            </article>
            
            <article class="struct" data-name="handleState">
               <h3>
                  handleState
                  <span class="badge">struct</span>
               </h3>
               
               <p>handleState holds state for a single call to commonHandler.handle.
The initial value of sep determines whether to emit a separator
before the next key, after which it stays true.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type handleState struct {
h *commonHandler
buf *buffer.Buffer
freeBuf bool
sep string
prefix *buffer.Buffer
groups *[]string
}</code></pre>
            </article>
            
            <article class="struct" data-name="handlerWriter">
               <h3>
                  handlerWriter
                  <span class="badge">struct</span>
               </h3>
               
               <p>handlerWriter is an io.Writer that calls a Handler.
It is used to link the default log.Logger to the default slog.Logger.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type handlerWriter struct {
h Handler
level Leveler
capturePC bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add converts the args to Attrs as described in [Logger.Log],
then appends the Attrs to the [Record]'s list of Attrs.
It omits empty groups.</p>
               
               <pre><code>func (r *Record) Add(args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="AddAttrs">
               <h3>
                  AddAttrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddAttrs appends the given Attrs to the [Record]'s list of Attrs.
It omits empty groups.</p>
               
               <pre><code>func (r *Record) AddAttrs(attrs ...Attr)</code></pre>
            </article>
            
            <article class="function" data-name="Any">
               <h3>
                  Any 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Any returns an Attr for the supplied value.
See [AnyValue] for how values are treated.</p>
               
               <pre><code>func Any(key string, value any) Attr</code></pre>
            </article>
            
            <article class="function" data-name="Any">
               <h3>
                  Any 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Any returns v's value as an any.</p>
               
               <pre><code>func (v Value) Any() any</code></pre>
            </article>
            
            <article class="function" data-name="AnyValue">
               <h3>
                  AnyValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AnyValue returns a [Value] for the supplied value.
If the supplied value is of type Value, it is returned
unmodified.
Given a value of one of Go's predeclared string, bool, or
(non-complex) numeric types, AnyValue returns a Value of kind
[KindString], [KindBool], [KindUint64], [KindInt64], or [KindFloat64].
The width of the original numeric type is not preserved.
Given a [time.Time] or [time.Duration] value, AnyValue returns a Value of kind
[KindTime] or [KindDuration]. The monotonic time is not preserved.
For nil, or values of all other types, including named types whose
underlying type is numeric, AnyValue returns a value of kind [KindAny].</p>
               
               <pre><code>func AnyValue(v any) Value</code></pre>
            </article>
            
            <article class="function" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendText implements [encoding.TextAppender]
by calling [Level.AppendText].</p>
               
               <pre><code>func (v *LevelVar) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendText implements [encoding.TextAppender]
by calling [Level.String].</p>
               
               <pre><code>func (l Level) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Attrs">
               <h3>
                  Attrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Attrs calls f on each Attr in the [Record].
Iteration stops if f returns false.</p>
               
               <pre><code>func (r Record) Attrs(f func(Attr) bool)</code></pre>
            </article>
            
            <article class="function" data-name="Bool">
               <h3>
                  Bool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bool returns v's value as a bool. It panics
if v is not a bool.</p>
               
               <pre><code>func (v Value) Bool() bool</code></pre>
            </article>
            
            <article class="function" data-name="Bool">
               <h3>
                  Bool 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Bool returns an Attr for a bool.</p>
               
               <pre><code>func Bool(key string, v bool) Attr</code></pre>
            </article>
            
            <article class="function" data-name="BoolValue">
               <h3>
                  BoolValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>BoolValue returns a [Value] for a bool.</p>
               
               <pre><code>func BoolValue(v bool) Value</code></pre>
            </article>
            
            <article class="function" data-name="Clone">
               <h3>
                  Clone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Clone returns a copy of the record with no shared state.
The original record and the clone can both be modified
without interfering with each other.</p>
               
               <pre><code>func (r Record) Clone() Record</code></pre>
            </article>
            
            <article class="function" data-name="Debug">
               <h3>
                  Debug 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Debug calls [Logger.Debug] on the default logger.</p>
               
               <pre><code>func Debug(msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Debug">
               <h3>
                  Debug 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Debug logs at [LevelDebug].</p>
               
               <pre><code>func (l *Logger) Debug(msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="DebugContext">
               <h3>
                  DebugContext 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DebugContext calls [Logger.DebugContext] on the default logger.</p>
               
               <pre><code>func DebugContext(ctx context.Context, msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="DebugContext">
               <h3>
                  DebugContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DebugContext logs at [LevelDebug] with the given context.</p>
               
               <pre><code>func (l *Logger) DebugContext(ctx context.Context, msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Default">
               <h3>
                  Default 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Default returns the default [Logger].</p>
               
               <pre><code>func Default() *Logger</code></pre>
            </article>
            
            <article class="function" data-name="Duration">
               <h3>
                  Duration 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Duration returns an Attr for a [time.Duration].</p>
               
               <pre><code>func Duration(key string, v time.Duration) Attr</code></pre>
            </article>
            
            <article class="function" data-name="Duration">
               <h3>
                  Duration 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Duration returns v's value as a [time.Duration]. It panics
if v is not a time.Duration.</p>
               
               <pre><code>func (v Value) Duration() time.Duration</code></pre>
            </article>
            
            <article class="function" data-name="DurationValue">
               <h3>
                  DurationValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>DurationValue returns a [Value] for a [time.Duration].</p>
               
               <pre><code>func DurationValue(v time.Duration) Value</code></pre>
            </article>
            
            <article class="function" data-name="Enabled">
               <h3>
                  Enabled 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Enabled reports whether the handler handles records at the given level.
The handler ignores records whose level is lower.</p>
               
               <pre><code>func (h *TextHandler) Enabled(_ context.Context, level Level) bool</code></pre>
            </article>
            
            <article class="function" data-name="Enabled">
               <h3>
                  Enabled 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Enabled reports whether the handler handles records at the given level.
The handler ignores records whose level is lower.</p>
               
               <pre><code>func (h *JSONHandler) Enabled(_ context.Context, level Level) bool</code></pre>
            </article>
            
            <article class="function" data-name="Enabled">
               <h3>
                  Enabled 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (*defaultHandler) Enabled(_ context.Context, l Level) bool</code></pre>
            </article>
            
            <article class="function" data-name="Enabled">
               <h3>
                  Enabled 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dh discardHandler) Enabled(context.Context, Level) bool</code></pre>
            </article>
            
            <article class="function" data-name="Enabled">
               <h3>
                  Enabled 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Enabled reports whether l emits log records at the given context and level.</p>
               
               <pre><code>func (l *Logger) Enabled(ctx context.Context, level Level) bool</code></pre>
            </article>
            
            <article class="function" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Equal reports whether v and w represent the same Go value.</p>
               
               <pre><code>func (v Value) Equal(w Value) bool</code></pre>
            </article>
            
            <article class="function" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Equal reports whether a and b have equal keys and values.</p>
               
               <pre><code>func (a Attr) Equal(b Attr) bool</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Error logs at [LevelError].</p>
               
               <pre><code>func (l *Logger) Error(msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Error calls [Logger.Error] on the default logger.</p>
               
               <pre><code>func Error(msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="ErrorContext">
               <h3>
                  ErrorContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ErrorContext logs at [LevelError] with the given context.</p>
               
               <pre><code>func (l *Logger) ErrorContext(ctx context.Context, msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="ErrorContext">
               <h3>
                  ErrorContext 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ErrorContext calls [Logger.ErrorContext] on the default logger.</p>
               
               <pre><code>func ErrorContext(ctx context.Context, msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Float64">
               <h3>
                  Float64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Float64 returns an Attr for a floating-point number.</p>
               
               <pre><code>func Float64(key string, v float64) Attr</code></pre>
            </article>
            
            <article class="function" data-name="Float64">
               <h3>
                  Float64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Float64 returns v's value as a float64. It panics
if v is not a float64.</p>
               
               <pre><code>func (v Value) Float64() float64</code></pre>
            </article>
            
            <article class="function" data-name="Float64Value">
               <h3>
                  Float64Value 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Float64Value returns a [Value] for a floating-point number.</p>
               
               <pre><code>func Float64Value(v float64) Value</code></pre>
            </article>
            
            <article class="function" data-name="Group">
               <h3>
                  Group 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Group returns v's value as a []Attr.
It panics if v's [Kind] is not [KindGroup].</p>
               
               <pre><code>func (v Value) Group() []Attr</code></pre>
            </article>
            
            <article class="function" data-name="Group">
               <h3>
                  Group 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Group returns an Attr for a Group [Value].
The first argument is the key; the remaining arguments
are converted to Attrs as in [Logger.Log].
Use Group to collect several key-value pairs under a single
key on a log line, or as the result of LogValue
in order to log a single value as multiple Attrs.</p>
               
               <pre><code>func Group(key string, args ...any) Attr</code></pre>
            </article>
            
            <article class="function" data-name="GroupValue">
               <h3>
                  GroupValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>GroupValue returns a new [Value] for a list of Attrs.
The caller must not subsequently mutate the argument slice.</p>
               
               <pre><code>func GroupValue(as ...Attr) Value</code></pre>
            </article>
            
            <article class="function" data-name="Handle">
               <h3>
                  Handle 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Handle formats its argument [Record] as a single line of space-separated
key=value items.
If the Record's time is zero, the time is omitted.
Otherwise, the key is "time"
and the value is output in RFC3339 format with millisecond precision.
If the Record's level is zero, the level is omitted.
Otherwise, the key is "level"
and the value of [Level.String] is output.
If the AddSource option is set and source information is available,
the key is "source" and the value is output as FILE:LINE.
The message's key is "msg".
To modify these or other attributes, or remove them from the output, use
[HandlerOptions.ReplaceAttr].
If a value implements [encoding.TextMarshaler], the result of MarshalText is
written. Otherwise, the result of [fmt.Sprint] is written.
Keys and values are quoted with [strconv.Quote] if they contain Unicode space
characters, non-printing characters, '"' or '='.
Keys inside groups consist of components (keys or group names) separated by
dots. No further escaping is performed.
Thus there is no way to determine from the key "a.b.c" whether there
are two groups "a" and "b" and a key "c", or a single group "a.b" and a key "c",
or single group "a" and a key "b.c".
If it is necessary to reconstruct the group structure of a key
even in the presence of dots inside components, use
[HandlerOptions.ReplaceAttr] to encode that information in the key.
Each call to Handle results in a single serialized call to
io.Writer.Write.</p>
               
               <pre><code>func (h *TextHandler) Handle(_ context.Context, r Record) error</code></pre>
            </article>
            
            <article class="function" data-name="Handle">
               <h3>
                  Handle 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Collect the level, attributes and message in a string and
write it with the default log.Logger.
Let the log.Logger handle time and file/line.</p>
               
               <pre><code>func (h *defaultHandler) Handle(ctx context.Context, r Record) error</code></pre>
            </article>
            
            <article class="function" data-name="Handle">
               <h3>
                  Handle 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dh discardHandler) Handle(context.Context, Record) error</code></pre>
            </article>
            
            <article class="function" data-name="Handle">
               <h3>
                  Handle 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Handle formats its argument [Record] as a JSON object on a single line.
If the Record's time is zero, the time is omitted.
Otherwise, the key is "time"
and the value is output as with json.Marshal.
If the Record's level is zero, the level is omitted.
Otherwise, the key is "level"
and the value of [Level.String] is output.
If the AddSource option is set and source information is available,
the key is "source", and the value is a record of type [Source].
The message's key is "msg".
To modify these or other attributes, or remove them from the output, use
[HandlerOptions.ReplaceAttr].
Values are formatted as with an [encoding/json.Encoder] with SetEscapeHTML(false),
with two exceptions.
First, an Attr whose Value is of type error is formatted as a string, by
calling its Error method. Only errors in Attrs receive this special treatment,
not errors embedded in structs, slices, maps or other data structures that
are processed by the [encoding/json] package.
Second, an encoding failure does not cause Handle to return an error.
Instead, the error message is formatted as a string.
Each call to Handle results in a single serialized call to io.Writer.Write.</p>
               
               <pre><code>func (h *JSONHandler) Handle(_ context.Context, r Record) error</code></pre>
            </article>
            
            <article class="function" data-name="Handler">
               <h3>
                  Handler 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Handler returns l's Handler.</p>
               
               <pre><code>func (l *Logger) Handler() Handler</code></pre>
            </article>
            
            <article class="function" data-name="Info">
               <h3>
                  Info 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Info calls [Logger.Info] on the default logger.</p>
               
               <pre><code>func Info(msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Info">
               <h3>
                  Info 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Info logs at [LevelInfo].</p>
               
               <pre><code>func (l *Logger) Info(msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="InfoContext">
               <h3>
                  InfoContext 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>InfoContext calls [Logger.InfoContext] on the default logger.</p>
               
               <pre><code>func InfoContext(ctx context.Context, msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="InfoContext">
               <h3>
                  InfoContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>InfoContext logs at [LevelInfo] with the given context.</p>
               
               <pre><code>func (l *Logger) InfoContext(ctx context.Context, msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Int">
               <h3>
                  Int 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Int converts an int to an int64 and returns
an Attr with that value.</p>
               
               <pre><code>func Int(key string, value int) Attr</code></pre>
            </article>
            
            <article class="function" data-name="Int64">
               <h3>
                  Int64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Int64 returns an Attr for an int64.</p>
               
               <pre><code>func Int64(key string, value int64) Attr</code></pre>
            </article>
            
            <article class="function" data-name="Int64">
               <h3>
                  Int64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Int64 returns v's value as an int64. It panics
if v is not a signed integer.</p>
               
               <pre><code>func (v Value) Int64() int64</code></pre>
            </article>
            
            <article class="function" data-name="Int64Value">
               <h3>
                  Int64Value 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Int64Value returns a [Value] for an int64.</p>
               
               <pre><code>func Int64Value(v int64) Value</code></pre>
            </article>
            
            <article class="function" data-name="IntValue">
               <h3>
                  IntValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IntValue returns a [Value] for an int.</p>
               
               <pre><code>func IntValue(v int) Value</code></pre>
            </article>
            
            <article class="function" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Kind returns v's Kind.</p>
               
               <pre><code>func (v Value) Kind() Kind</code></pre>
            </article>
            
            <article class="function" data-name="Level">
               <h3>
                  Level 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Level returns the receiver.
It implements [Leveler].</p>
               
               <pre><code>func (l Level) Level() Level</code></pre>
            </article>
            
            <article class="function" data-name="Level">
               <h3>
                  Level 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Level returns v's level.</p>
               
               <pre><code>func (v *LevelVar) Level() Level</code></pre>
            </article>
            
            <article class="function" data-name="Log">
               <h3>
                  Log 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Log calls [Logger.Log] on the default logger.</p>
               
               <pre><code>func Log(ctx context.Context, level Level, msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Log">
               <h3>
                  Log 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Log emits a log record with the current time and the given level and message.
The Record's Attrs consist of the Logger's attributes followed by
the Attrs specified by args.
The attribute arguments are processed as follows:
- If an argument is an Attr, it is used as is.
- If an argument is a string and this is not the last argument,
the following argument is treated as the value and the two are combined
into an Attr.
- Otherwise, the argument is treated as a value with key "!BADKEY".</p>
               
               <pre><code>func (l *Logger) Log(ctx context.Context, level Level, msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="LogAttrs">
               <h3>
                  LogAttrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LogAttrs is a more efficient version of [Logger.Log] that accepts only Attrs.</p>
               
               <pre><code>func (l *Logger) LogAttrs(ctx context.Context, level Level, msg string, attrs ...Attr)</code></pre>
            </article>
            
            <article class="function" data-name="LogAttrs">
               <h3>
                  LogAttrs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LogAttrs calls [Logger.LogAttrs] on the default logger.</p>
               
               <pre><code>func LogAttrs(ctx context.Context, level Level, msg string, attrs ...Attr)</code></pre>
            </article>
            
            <article class="function" data-name="LogValuer">
               <h3>
                  LogValuer 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LogValuer returns v's value as a LogValuer. It panics
if v is not a LogValuer.</p>
               
               <pre><code>func (v Value) LogValuer() LogValuer</code></pre>
            </article>
            
            <article class="function" data-name="MarshalJSON">
               <h3>
                  MarshalJSON 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalJSON implements [encoding/json.Marshaler]
by quoting the output of [Level.String].</p>
               
               <pre><code>func (l Level) MarshalJSON() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalText implements [encoding.TextMarshaler]
by calling [LevelVar.AppendText].</p>
               
               <pre><code>func (v *LevelVar) MarshalText() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalText implements [encoding.TextMarshaler]
by calling [Level.AppendText].</p>
               
               <pre><code>func (l Level) MarshalText() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>New creates a new Logger with the given non-nil Handler.</p>
               
               <pre><code>func New(h Handler) *Logger</code></pre>
            </article>
            
            <article class="function" data-name="NewJSONHandler">
               <h3>
                  NewJSONHandler 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewJSONHandler creates a [JSONHandler] that writes to w,
using the given options.
If opts is nil, the default options are used.</p>
               
               <pre><code>func NewJSONHandler(w io.Writer, opts *HandlerOptions) *JSONHandler</code></pre>
            </article>
            
            <article class="function" data-name="NewLogLogger">
               <h3>
                  NewLogLogger 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewLogLogger returns a new [log.Logger] such that each call to its Output method
dispatches a Record to the specified handler. The logger acts as a bridge from
the older log API to newer structured logging handlers.</p>
               
               <pre><code>func NewLogLogger(h Handler, level Level) *log.Logger</code></pre>
            </article>
            
            <article class="function" data-name="NewRecord">
               <h3>
                  NewRecord 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewRecord creates a [Record] from the given arguments.
Use [Record.AddAttrs] to add attributes to the Record.
NewRecord is intended for logging APIs that want to support a [Handler] as
a backend.</p>
               
               <pre><code>func NewRecord(t time.Time, level Level, msg string, pc uintptr) Record</code></pre>
            </article>
            
            <article class="function" data-name="NewTextHandler">
               <h3>
                  NewTextHandler 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewTextHandler creates a [TextHandler] that writes to w,
using the given options.
If opts is nil, the default options are used.</p>
               
               <pre><code>func NewTextHandler(w io.Writer, opts *HandlerOptions) *TextHandler</code></pre>
            </article>
            
            <article class="function" data-name="NumAttrs">
               <h3>
                  NumAttrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NumAttrs returns the number of attributes in the [Record].</p>
               
               <pre><code>func (r Record) NumAttrs() int</code></pre>
            </article>
            
            <article class="function" data-name="Resolve">
               <h3>
                  Resolve 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Resolve repeatedly calls LogValue on v while it implements [LogValuer],
and returns the result.
If v resolves to a group, the group's attributes' values are not recursively
resolved.
If the number of LogValue calls exceeds a threshold, a Value containing an
error is returned.
Resolve's return value is guaranteed not to be of Kind [KindLogValuer].</p>
               
               <pre><code>func (v Value) Resolve() (rv Value)</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set sets v's level to l.</p>
               
               <pre><code>func (v *LevelVar) Set(l Level)</code></pre>
            </article>
            
            <article class="function" data-name="SetDefault">
               <h3>
                  SetDefault 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SetDefault makes l the default [Logger], which is used by
the top-level functions [Info], [Debug] and so on.
After this call, output from the log package's default Logger
(as with [log.Print], etc.) will be logged using l's Handler,
at a level controlled by [SetLogLoggerLevel].</p>
               
               <pre><code>func SetDefault(l *Logger)</code></pre>
            </article>
            
            <article class="function" data-name="SetLogLoggerLevel">
               <h3>
                  SetLogLoggerLevel 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>SetLogLoggerLevel controls the level for the bridge to the [log] package.
Before [SetDefault] is called, slog top-level logging functions call the default [log.Logger].
In that mode, SetLogLoggerLevel sets the minimum level for those calls.
By default, the minimum level is Info, so calls to [Debug]
(as well as top-level logging calls at lower levels)
will not be passed to the log.Logger. After calling
slog.SetLogLoggerLevel(slog.LevelDebug)
calls to [Debug] will be passed to the log.Logger.
After [SetDefault] is called, calls to the default [log.Logger] are passed to the
slog default handler. In that mode,
SetLogLoggerLevel sets the level at which those calls are logged.
That is, after calling
slog.SetLogLoggerLevel(slog.LevelDebug)
A call to [log.Printf] will result in output at level [LevelDebug].
SetLogLoggerLevel returns the previous value.</p>
               
               <pre><code>func SetLogLoggerLevel(level Level) (oldLevel Level)</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a Attr) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a name for the level.
If the level has a name, then that name
in uppercase is returned.
If the level is between named values, then
an integer is appended to the uppercased name.
Examples:
LevelWarn.String() => "WARN"
(LevelInfo+2).String() => "INFO+2"</p>
               
               <pre><code>func (l Level) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *LevelVar) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>String returns an Attr for a string value.</p>
               
               <pre><code>func String(key string, value string) Attr</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns Value's value as a string, formatted like [fmt.Sprint]. Unlike
the methods Int64, Float64, and so on, which panic if v is of the
wrong kind, String never panics.</p>
               
               <pre><code>func (v Value) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (k Kind) String() string</code></pre>
            </article>
            
            <article class="function" data-name="StringValue">
               <h3>
                  StringValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>StringValue returns a new [Value] for a string.</p>
               
               <pre><code>func StringValue(value string) Value</code></pre>
            </article>
            
            <article class="function" data-name="Time">
               <h3>
                  Time 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Time returns an Attr for a [time.Time].
It discards the monotonic portion.</p>
               
               <pre><code>func Time(key string, v time.Time) Attr</code></pre>
            </article>
            
            <article class="function" data-name="Time">
               <h3>
                  Time 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Time returns v's value as a [time.Time]. It panics
if v is not a time.Time.</p>
               
               <pre><code>func (v Value) Time() time.Time</code></pre>
            </article>
            
            <article class="function" data-name="TimeValue">
               <h3>
                  TimeValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TimeValue returns a [Value] for a [time.Time].
It discards the monotonic portion.</p>
               
               <pre><code>func TimeValue(v time.Time) Value</code></pre>
            </article>
            
            <article class="function" data-name="Uint64">
               <h3>
                  Uint64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Uint64 returns an Attr for a uint64.</p>
               
               <pre><code>func Uint64(key string, v uint64) Attr</code></pre>
            </article>
            
            <article class="function" data-name="Uint64">
               <h3>
                  Uint64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Uint64 returns v's value as a uint64. It panics
if v is not an unsigned integer.</p>
               
               <pre><code>func (v Value) Uint64() uint64</code></pre>
            </article>
            
            <article class="function" data-name="Uint64Value">
               <h3>
                  Uint64Value 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Uint64Value returns a [Value] for a uint64.</p>
               
               <pre><code>func Uint64Value(v uint64) Value</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalJSON">
               <h3>
                  UnmarshalJSON 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalJSON implements [encoding/json.Unmarshaler]
It accepts any string produced by [Level.MarshalJSON],
ignoring case.
It also accepts numeric offsets that would result in a different string on
output. For example, "Error-8" would marshal as "INFO".</p>
               
               <pre><code>func (l *Level) UnmarshalJSON(data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalText implements [encoding.TextUnmarshaler].
It accepts any string produced by [Level.MarshalText],
ignoring case.
It also accepts numeric offsets that would result in a different string on
output. For example, "Error-8" would marshal as "INFO".</p>
               
               <pre><code>func (l *Level) UnmarshalText(data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalText implements [encoding.TextUnmarshaler]
by calling [Level.UnmarshalText].</p>
               
               <pre><code>func (v *LevelVar) UnmarshalText(data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="Warn">
               <h3>
                  Warn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Warn calls [Logger.Warn] on the default logger.</p>
               
               <pre><code>func Warn(msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="Warn">
               <h3>
                  Warn 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Warn logs at [LevelWarn].</p>
               
               <pre><code>func (l *Logger) Warn(msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="WarnContext">
               <h3>
                  WarnContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WarnContext logs at [LevelWarn] with the given context.</p>
               
               <pre><code>func (l *Logger) WarnContext(ctx context.Context, msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="WarnContext">
               <h3>
                  WarnContext 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>WarnContext calls [Logger.WarnContext] on the default logger.</p>
               
               <pre><code>func WarnContext(ctx context.Context, msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="With">
               <h3>
                  With 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>With calls [Logger.With] on the default logger.</p>
               
               <pre><code>func With(args ...any) *Logger</code></pre>
            </article>
            
            <article class="function" data-name="With">
               <h3>
                  With 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>With returns a Logger that includes the given attributes
in each output operation. Arguments are converted to
attributes as if by [Logger.Log].</p>
               
               <pre><code>func (l *Logger) With(args ...any) *Logger</code></pre>
            </article>
            
            <article class="function" data-name="WithAttrs">
               <h3>
                  WithAttrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WithAttrs returns a new [TextHandler] whose attributes consists
of h's attributes followed by attrs.</p>
               
               <pre><code>func (h *TextHandler) WithAttrs(attrs []Attr) Handler</code></pre>
            </article>
            
            <article class="function" data-name="WithAttrs">
               <h3>
                  WithAttrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *defaultHandler) WithAttrs(as []Attr) Handler</code></pre>
            </article>
            
            <article class="function" data-name="WithAttrs">
               <h3>
                  WithAttrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dh discardHandler) WithAttrs(attrs []Attr) Handler</code></pre>
            </article>
            
            <article class="function" data-name="WithAttrs">
               <h3>
                  WithAttrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WithAttrs returns a new [JSONHandler] whose attributes consists
of h's attributes followed by attrs.</p>
               
               <pre><code>func (h *JSONHandler) WithAttrs(attrs []Attr) Handler</code></pre>
            </article>
            
            <article class="function" data-name="WithGroup">
               <h3>
                  WithGroup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *TextHandler) WithGroup(name string) Handler</code></pre>
            </article>
            
            <article class="function" data-name="WithGroup">
               <h3>
                  WithGroup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (dh discardHandler) WithGroup(name string) Handler</code></pre>
            </article>
            
            <article class="function" data-name="WithGroup">
               <h3>
                  WithGroup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *defaultHandler) WithGroup(name string) Handler</code></pre>
            </article>
            
            <article class="function" data-name="WithGroup">
               <h3>
                  WithGroup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *JSONHandler) WithGroup(name string) Handler</code></pre>
            </article>
            
            <article class="function" data-name="WithGroup">
               <h3>
                  WithGroup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WithGroup returns a Logger that starts a group, if name is non-empty.
The keys of all attributes added to the Logger will be qualified by the given
name. (How that qualification happens depends on the [Handler.WithGroup]
method of the Logger's Handler.)
If name is empty, WithGroup returns the receiver.</p>
               
               <pre><code>func (l *Logger) WithGroup(name string) *Logger</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *handlerWriter) Write(buf []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>append appends a text representation of v to dst.
v is formatted as with fmt.Sprint.</p>
               
               <pre><code>func (v Value) append(dst []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendAttr">
               <h3>
                  appendAttr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>appendAttr appends the Attr's key and value.
It handles replacement and checking for an empty key.
It reports whether something was appended.</p>
               
               <pre><code>func (s *handleState) appendAttr(a Attr) bool</code></pre>
            </article>
            
            <article class="function" data-name="appendAttrs">
               <h3>
                  appendAttrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>appendAttrs appends the slice of Attrs.
It reports whether something was appended.</p>
               
               <pre><code>func (s *handleState) appendAttrs(as []Attr) bool</code></pre>
            </article>
            
            <article class="function" data-name="appendError">
               <h3>
                  appendError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *handleState) appendError(err error)</code></pre>
            </article>
            
            <article class="function" data-name="appendEscapedJSONString">
               <h3>
                  appendEscapedJSONString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendEscapedJSONString escapes s for JSON and appends it to buf.
It does not surround the string in quotation marks.
Modified from encoding/json/encode.go:encodeState.string,
with escapeHTML set to false.</p>
               
               <pre><code>func appendEscapedJSONString(buf []byte, s string) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendJSONMarshal">
               <h3>
                  appendJSONMarshal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendJSONMarshal(buf *buffer.Buffer, v any) error</code></pre>
            </article>
            
            <article class="function" data-name="appendJSONTime">
               <h3>
                  appendJSONTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Adapted from time.Time.MarshalJSON to avoid allocation.</p>
               
               <pre><code>func appendJSONTime(s *handleState, t time.Time)</code></pre>
            </article>
            
            <article class="function" data-name="appendJSONValue">
               <h3>
                  appendJSONValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendJSONValue(s *handleState, v Value) error</code></pre>
            </article>
            
            <article class="function" data-name="appendKey">
               <h3>
                  appendKey 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *handleState) appendKey(key string)</code></pre>
            </article>
            
            <article class="function" data-name="appendNonBuiltIns">
               <h3>
                  appendNonBuiltIns 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *handleState) appendNonBuiltIns(r Record)</code></pre>
            </article>
            
            <article class="function" data-name="appendRFC3339Millis">
               <h3>
                  appendRFC3339Millis 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendRFC3339Millis(b []byte, t time.Time) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendString">
               <h3>
                  appendString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *handleState) appendString(str string)</code></pre>
            </article>
            
            <article class="function" data-name="appendTextValue">
               <h3>
                  appendTextValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func appendTextValue(s *handleState, v Value) error</code></pre>
            </article>
            
            <article class="function" data-name="appendTime">
               <h3>
                  appendTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *handleState) appendTime(t time.Time)</code></pre>
            </article>
            
            <article class="function" data-name="appendValue">
               <h3>
                  appendValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *handleState) appendValue(v Value)</code></pre>
            </article>
            
            <article class="function" data-name="argsToAttr">
               <h3>
                  argsToAttr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>argsToAttr turns a prefix of the nonempty args slice into an Attr
and returns the unconsumed portion of the slice.
If args[0] is an Attr, it returns it.
If args[0] is a string, it treats the first two elements as
a key-value pair.
Otherwise, it treats args[0] as a value with a missing key.</p>
               
               <pre><code>func argsToAttr(args []any) (Attr, []any)</code></pre>
            </article>
            
            <article class="function" data-name="argsToAttrSlice">
               <h3>
                  argsToAttrSlice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func argsToAttrSlice(args []any) []Attr</code></pre>
            </article>
            
            <article class="function" data-name="attrSep">
               <h3>
                  attrSep 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>attrSep returns the separator between attributes.</p>
               
               <pre><code>func (h *commonHandler) attrSep() string</code></pre>
            </article>
            
            <article class="function" data-name="bool">
               <h3>
                  bool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) bool() bool</code></pre>
            </article>
            
            <article class="function" data-name="byteSlice">
               <h3>
                  byteSlice 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>byteSlice returns its argument as a []byte if the argument's
underlying type is []byte, along with a second return value of true.
Otherwise it returns nil, false.</p>
               
               <pre><code>func byteSlice(a any) ([]byte, bool)</code></pre>
            </article>
            
            <article class="function" data-name="clone">
               <h3>
                  clone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Logger) clone() *Logger</code></pre>
            </article>
            
            <article class="function" data-name="clone">
               <h3>
                  clone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *commonHandler) clone() *commonHandler</code></pre>
            </article>
            
            <article class="function" data-name="closeGroup">
               <h3>
                  closeGroup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>closeGroup ends the group with the given name.</p>
               
               <pre><code>func (s *handleState) closeGroup(name string)</code></pre>
            </article>
            
            <article class="function" data-name="countAttrs">
               <h3>
                  countAttrs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>countAttrs returns the number of Attrs that would be created from args.</p>
               
               <pre><code>func countAttrs(args []any) int</code></pre>
            </article>
            
            <article class="function" data-name="countEmptyGroups">
               <h3>
                  countEmptyGroups 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>countEmptyGroups returns the number of empty group values in its argument.</p>
               
               <pre><code>func countEmptyGroups(as []Attr) int</code></pre>
            </article>
            
            <article class="function" data-name="duration">
               <h3>
                  duration 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) duration() time.Duration</code></pre>
            </article>
            
            <article class="function" data-name="enabled">
               <h3>
                  enabled 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>enabled reports whether l is greater than or equal to the
minimum level.</p>
               
               <pre><code>func (h *commonHandler) enabled(l Level) bool</code></pre>
            </article>
            
            <article class="function" data-name="float">
               <h3>
                  float 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) float() float64</code></pre>
            </article>
            
            <article class="function" data-name="free">
               <h3>
                  free 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *handleState) free()</code></pre>
            </article>
            
            <article class="function" data-name="group">
               <h3>
                  group 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>group returns the non-zero fields of s as a slice of attrs.
It is similar to a LogValue method, but we don't want Source
to implement LogValuer because it would be resolved before
the ReplaceAttr function was called.</p>
               
               <pre><code>func (s *Source) group() Value</code></pre>
            </article>
            
            <article class="function" data-name="group">
               <h3>
                  group 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) group() []Attr</code></pre>
            </article>
            
            <article class="function" data-name="handle">
               <h3>
                  handle 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>handle is the internal implementation of Handler.Handle
used by TextHandler and JSONHandler.</p>
               
               <pre><code>func (h *commonHandler) handle(r Record) error</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="isEmpty">
               <h3>
                  isEmpty 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isEmpty reports whether a has an empty key and a nil value.
That can be written as Attr{} or Any("", nil).</p>
               
               <pre><code>func (a Attr) isEmpty() bool</code></pre>
            </article>
            
            <article class="function" data-name="isEmptyGroup">
               <h3>
                  isEmptyGroup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isEmptyGroup reports whether v is a group that has no attributes.</p>
               
               <pre><code>func (v Value) isEmptyGroup() bool</code></pre>
            </article>
            
            <article class="function" data-name="log">
               <h3>
                  log 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>log is the low-level logging method for methods that take ...any.
It must always be called directly by an exported logging method
or function, because it uses a fixed call depth to obtain the pc.</p>
               
               <pre><code>func (l *Logger) log(ctx context.Context, level Level, msg string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="logAttrs">
               <h3>
                  logAttrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>logAttrs is like [Logger.log], but for methods that take ...Attr.</p>
               
               <pre><code>func (l *Logger) logAttrs(ctx context.Context, level Level, msg string, attrs ...Attr)</code></pre>
            </article>
            
            <article class="function" data-name="needsQuoting">
               <h3>
                  needsQuoting 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func needsQuoting(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="newDefaultHandler">
               <h3>
                  newDefaultHandler 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newDefaultHandler(output func(uintptr, []byte) error) *defaultHandler</code></pre>
            </article>
            
            <article class="function" data-name="newHandleState">
               <h3>
                  newHandleState 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *commonHandler) newHandleState(buf *buffer.Buffer, freeBuf bool, sep string) handleState</code></pre>
            </article>
            
            <article class="function" data-name="openGroup">
               <h3>
                  openGroup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>openGroup starts a new group of attributes
with the given name.</p>
               
               <pre><code>func (s *handleState) openGroup(name string)</code></pre>
            </article>
            
            <article class="function" data-name="openGroups">
               <h3>
                  openGroups 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *handleState) openGroups()</code></pre>
            </article>
            
            <article class="function" data-name="parse">
               <h3>
                  parse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Level) parse(s string) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="source">
               <h3>
                  source 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>source returns a Source for the log event.
If the Record was created without the necessary information,
or if the location is unavailable, it returns a non-nil *Source
with zero fields.</p>
               
               <pre><code>func (r Record) source() *Source</code></pre>
            </article>
            
            <article class="function" data-name="stack">
               <h3>
                  stack 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func stack(skip int, nFrames int) string</code></pre>
            </article>
            
            <article class="function" data-name="str">
               <h3>
                  str 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v Value) str() string</code></pre>
            </article>
            
            <article class="function" data-name="time">
               <h3>
                  time 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>See TimeValue to understand how times are represented.</p>
               
               <pre><code>func (v Value) time() time.Time</code></pre>
            </article>
            
            <article class="function" data-name="withAttrs">
               <h3>
                  withAttrs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *commonHandler) withAttrs(as []Attr) *commonHandler</code></pre>
            </article>
            
            <article class="function" data-name="withGroup">
               <h3>
                  withGroup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (h *commonHandler) withGroup(name string) *commonHandler</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
