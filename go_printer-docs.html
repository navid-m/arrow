<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>printer - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>printer</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"go/ast"
"go/doc/comment"
"strings"
"go/build/constraint"
"slices"
"text/tabwriter"
"go/ast"
"go/token"
"math"
"strconv"
"strings"
"unicode"
"unicode/utf8"
"fmt"
"go/ast"
"go/build/constraint"
"go/token"
"io"
"os"
"strings"
"sync"
"text/tabwriter"
"unicode"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="RawFormat" data-name="RawFormat">
               <h3>
                  RawFormat 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RawFormat" class="anchor" title="Link to RawFormat">#</a>
               </h3>
               
               <pre><code class="language-go">const RawFormat Mode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SourcePos" data-name="SourcePos">
               <h3>
                  SourcePos 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SourcePos" class="anchor" title="Link to SourcePos">#</a>
               </h3>
               
               <pre><code class="language-go">const SourcePos</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TabIndent" data-name="TabIndent">
               <h3>
                  TabIndent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TabIndent" class="anchor" title="Link to TabIndent">#</a>
               </h3>
               
               <pre><code class="language-go">const TabIndent</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UseSpaces" data-name="UseSpaces">
               <h3>
                  UseSpaces 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UseSpaces" class="anchor" title="Link to UseSpaces">#</a>
               </h3>
               
               <pre><code class="language-go">const UseSpaces</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="aNewline" data-name="aNewline">
               <h3>
                  aNewline 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#aNewline" class="anchor" title="Link to aNewline">#</a>
               </h3>
               
               <pre><code class="language-go">var aNewline = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="blank" data-name="blank">
               <h3>
                  blank 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#blank" class="anchor" title="Link to blank">#</a>
               </h3>
               
               <pre><code class="language-go">const blank = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="commaTerm" data-name="commaTerm">
               <h3>
                  commaTerm 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#commaTerm" class="anchor" title="Link to commaTerm">#</a>
               </h3>
               
               <pre><code class="language-go">const commaTerm exprListMode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debug" data-name="debug">
               <h3>
                  debug 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debug" class="anchor" title="Link to debug">#</a>
               </h3>
               
               <pre><code class="language-go">const debug = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="filteredMsg" data-name="filteredMsg">
               <h3>
                  filteredMsg 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#filteredMsg" class="anchor" title="Link to filteredMsg">#</a>
               </h3>
               
               <pre><code class="language-go">const filteredMsg = "contains filtered or unexported fields"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="formfeed" data-name="formfeed">
               <h3>
                  formfeed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#formfeed" class="anchor" title="Link to formfeed">#</a>
               </h3>
               
               <pre><code class="language-go">const formfeed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="funcParam" data-name="funcParam">
               <h3>
                  funcParam 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#funcParam" class="anchor" title="Link to funcParam">#</a>
               </h3>
               
               <pre><code class="language-go">const funcParam paramMode = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="funcTParam" data-name="funcTParam">
               <h3>
                  funcTParam 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#funcTParam" class="anchor" title="Link to funcTParam">#</a>
               </h3>
               
               <pre><code class="language-go">const funcTParam</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ignore" data-name="ignore">
               <h3>
                  ignore 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ignore" class="anchor" title="Link to ignore">#</a>
               </h3>
               
               <pre><code class="language-go">const ignore = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inEscape" data-name="inEscape">
               <h3>
                  inEscape 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inEscape" class="anchor" title="Link to inEscape">#</a>
               </h3>
               
                  <p class="doc-comment">trimmer is implemented as a state machine.
It can be in one of the following states:</p>
               
               <pre><code class="language-go">const inEscape</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inSpace" data-name="inSpace">
               <h3>
                  inSpace 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inSpace" class="anchor" title="Link to inSpace">#</a>
               </h3>
               
                  <p class="doc-comment">trimmer is implemented as a state machine.
It can be in one of the following states:</p>
               
               <pre><code class="language-go">const inSpace = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inText" data-name="inText">
               <h3>
                  inText 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inText" class="anchor" title="Link to inText">#</a>
               </h3>
               
                  <p class="doc-comment">trimmer is implemented as a state machine.
It can be in one of the following states:</p>
               
               <pre><code class="language-go">const inText</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="indent" data-name="indent">
               <h3>
                  indent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#indent" class="anchor" title="Link to indent">#</a>
               </h3>
               
               <pre><code class="language-go">const indent = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="infinity" data-name="infinity">
               <h3>
                  infinity 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#infinity" class="anchor" title="Link to infinity">#</a>
               </h3>
               
               <pre><code class="language-go">const infinity = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxNewlines" data-name="maxNewlines">
               <h3>
                  maxNewlines 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxNewlines" class="anchor" title="Link to maxNewlines">#</a>
               </h3>
               
               <pre><code class="language-go">const maxNewlines = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="newline" data-name="newline">
               <h3>
                  newline 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#newline" class="anchor" title="Link to newline">#</a>
               </h3>
               
               <pre><code class="language-go">const newline = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noExtraBlank" data-name="noExtraBlank">
               <h3>
                  noExtraBlank 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#noExtraBlank" class="anchor" title="Link to noExtraBlank">#</a>
               </h3>
               
               <pre><code class="language-go">const noExtraBlank pmode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noExtraLinebreak" data-name="noExtraLinebreak">
               <h3>
                  noExtraLinebreak 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#noExtraLinebreak" class="anchor" title="Link to noExtraLinebreak">#</a>
               </h3>
               
               <pre><code class="language-go">const noExtraLinebreak</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noIndent" data-name="noIndent">
               <h3>
                  noIndent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#noIndent" class="anchor" title="Link to noIndent">#</a>
               </h3>
               
               <pre><code class="language-go">const noIndent</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="normalizeNumbers" data-name="normalizeNumbers">
               <h3>
                  normalizeNumbers 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#normalizeNumbers" class="anchor" title="Link to normalizeNumbers">#</a>
               </h3>
               
                  <p class="doc-comment">normalizeNumbers means to canonicalize number
literal prefixes and exponents while printing.
This value is known in and used by go/format and cmd/gofmt.
It is currently more convenient and performant for those
packages to apply number normalization during printing,
rather than by modifying the AST in advance.</p>
               
               <pre><code class="language-go">const normalizeNumbers Mode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="printerPool" data-name="printerPool">
               <h3>
                  printerPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#printerPool" class="anchor" title="Link to printerPool">#</a>
               </h3>
               
               <pre><code class="language-go">var printerPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="typeTParam" data-name="typeTParam">
               <h3>
                  typeTParam 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#typeTParam" class="anchor" title="Link to typeTParam">#</a>
               </h3>
               
               <pre><code class="language-go">const typeTParam</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unindent" data-name="unindent">
               <h3>
                  unindent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#unindent" class="anchor" title="Link to unindent">#</a>
               </h3>
               
               <pre><code class="language-go">const unindent = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vtab" data-name="vtab">
               <h3>
                  vtab 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#vtab" class="anchor" title="Link to vtab">#</a>
               </h3>
               
               <pre><code class="language-go">const vtab = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Mode" data-name="Mode">
               <h3>
                  Mode
                  <span class="badge type-badge">type</span>
                  <a href="#Mode" class="anchor" title="Link to Mode">#</a>
               </h3>
               
               <p>A Mode value is a set of flags (or 0). They control printing.</p>
               
               <pre><code class="language-go">type Mode uint</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="exprListMode" data-name="exprListMode">
               <h3>
                  exprListMode
                  <span class="badge type-badge">type</span>
                  <a href="#exprListMode" class="anchor" title="Link to exprListMode">#</a>
               </h3>
               
               <pre><code class="language-go">type exprListMode uint</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="paramMode" data-name="paramMode">
               <h3>
                  paramMode
                  <span class="badge type-badge">type</span>
                  <a href="#paramMode" class="anchor" title="Link to paramMode">#</a>
               </h3>
               
               <pre><code class="language-go">type paramMode int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="pmode" data-name="pmode">
               <h3>
                  pmode
                  <span class="badge type-badge">type</span>
                  <a href="#pmode" class="anchor" title="Link to pmode">#</a>
               </h3>
               
               <p>A pmode value represents the current printer mode.</p>
               
               <pre><code class="language-go">type pmode int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="whiteSpace" data-name="whiteSpace">
               <h3>
                  whiteSpace
                  <span class="badge type-badge">type</span>
                  <a href="#whiteSpace" class="anchor" title="Link to whiteSpace">#</a>
               </h3>
               
               <pre><code class="language-go">type whiteSpace byte</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="CommentedNode" data-name="CommentedNode">
               <h3>
                  CommentedNode
                  <span class="badge">struct</span>
                  <a href="#CommentedNode" class="anchor" title="Link to CommentedNode">#</a>
               </h3>
               
               <p>A CommentedNode bundles an AST node and corresponding comments.
It may be provided as argument to any of the [Fprint] functions.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type CommentedNode struct {
Node any
Comments []*ast.CommentGroup
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Config" data-name="Config">
               <h3>
                  Config
                  <span class="badge">struct</span>
                  <a href="#Config" class="anchor" title="Link to Config">#</a>
               </h3>
               
               <p>A Config node controls the output of Fprint.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Config struct {
Mode Mode
Tabwidth int
Indent int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="commentInfo" data-name="commentInfo">
               <h3>
                  commentInfo
                  <span class="badge">struct</span>
                  <a href="#commentInfo" class="anchor" title="Link to commentInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type commentInfo struct {
cindex int
comment *ast.CommentGroup
commentOffset int
commentNewline bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="printer" data-name="printer">
               <h3>
                  printer
                  <span class="badge">struct</span>
                  <a href="#printer" class="anchor" title="Link to printer">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type printer struct {
Config
fset *token.FileSet
output []byte
indent int
level int
mode pmode
endAlignment bool
impliedSemi bool
lastTok token.Token
prevOpen token.Token
wsbuf []whiteSpace
goBuild []int
plusBuild []int
pos token.Position
out token.Position
last token.Position
linePtr *int
sourcePosErr error
comments []*ast.CommentGroup
useNodeComments bool
commentInfo
nodeSizes map[ast.Node]int
cachedPos token.Pos
cachedLine int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sizeCounter" data-name="sizeCounter">
               <h3>
                  sizeCounter
                  <span class="badge">struct</span>
                  <a href="#sizeCounter" class="anchor" title="Link to sizeCounter">#</a>
               </h3>
               
               <p>sizeCounter is an io.Writer which counts the number of bytes written,
as well as whether a newline character was seen.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type sizeCounter struct {
hasNewline bool
size int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="trimmer" data-name="trimmer">
               <h3>
                  trimmer
                  <span class="badge">struct</span>
                  <a href="#trimmer" class="anchor" title="Link to trimmer">#</a>
               </h3>
               
               <p>A trimmer is an io.Writer filter for stripping tabwriter.Escape
characters, trailing blanks and tabs, and for converting formfeed
and vtab characters into newlines and htabs (in case no tabwriter
is used). Text bracketed by tabwriter.Escape characters is passed
through unchanged.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type trimmer struct {
output io.Writer
state int
space []byte
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Fprint" data-name="Fprint">
               <h3>
                  Fprint 
                  <span class="badge">function</span>
                  
                  <a href="#Fprint" class="anchor" title="Link to Fprint">#</a>
               </h3>
               
               <p>Fprint "pretty-prints" an AST node to output.
It calls [Config.Fprint] with default settings.
Note that gofmt uses tabs for indentation but spaces for alignment;
use format.Node (package go/format) for output that matches gofmt.</p>
               
               <pre><code class="language-go">func Fprint(output io.Writer, fset *token.FileSet, node any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fprint" data-name="Fprint">
               <h3>
                  Fprint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fprint" class="anchor" title="Link to Fprint">#</a>
               </h3>
               
               <p>Fprint "pretty-prints" an AST node to output for a given configuration cfg.
Position information is interpreted relative to the file set fset.
The node type must be *[ast.File], *[CommentedNode], [][ast.Decl], [][ast.Stmt],
or assignment-compatible to [ast.Expr], [ast.Decl], [ast.Spec], or [ast.Stmt].</p>
               
               <pre><code class="language-go">func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *trimmer) Write(data []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code class="language-go">func (c *sizeCounter) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allStars" data-name="allStars">
               <h3>
                  allStars 
                  <span class="badge">function</span>
                  
                  <a href="#allStars" class="anchor" title="Link to allStars">#</a>
               </h3>
               
               <p>allStars reports whether text is the interior of an
old-style /* */ comment with a star at the start of each line.</p>
               
               <pre><code class="language-go">func allStars(text string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendLines" data-name="appendLines">
               <h3>
                  appendLines 
                  <span class="badge">function</span>
                  
                  <a href="#appendLines" class="anchor" title="Link to appendLines">#</a>
               </h3>
               
               <p>appendLines is like append(x, y...)
but it avoids creating doubled blank lines,
which would not be gofmt-standard output.
It assumes that only whole blocks of lines are being appended,
not line fragments.</p>
               
               <pre><code class="language-go">func appendLines(x []byte, y []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="binaryExpr" data-name="binaryExpr">
               <h3>
                  binaryExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#binaryExpr" class="anchor" title="Link to binaryExpr">#</a>
               </h3>
               
               <p>Format the binary expression: decide the cutoff and then format.
Let's call depth == 1 Normal mode, and depth > 1 Compact mode.
(Algorithm suggestion by Russ Cox.)
The precedences are:
5             *  /  %  <<  >>  &  &^
4             +  -  |  ^
3             ==  !=  <  <=  >  >=
2             &&
1             ||
The only decision is whether there will be spaces around levels 4 and 5.
There are never spaces at level 6 (unary), and always spaces at levels 3 and below.
To choose the cutoff, look at the whole expression but excluding primary
expressions (function calls, parenthesized exprs), and apply these rules:
1. If there is a binary operator with a right side unary operand
that would clash without a space, the cutoff must be (in order):
/*	6
&&	6
&^	6
++	5
--	5
(Comparison operators always have spaces around them.)
2. If there is a mix of level 5 and level 4 operators, then the cutoff
is 5 (use spaces to distinguish precedence) in Normal mode
and 4 (never use spaces) in Compact mode.
3. If there are no level 4 operators or no level 5 operators, then the
cutoff is 6 (always use spaces) in Normal mode
and 4 (never use spaces) in Compact mode.</p>
               
               <pre><code class="language-go">func (p *printer) binaryExpr(x *ast.BinaryExpr, prec1 int, cutoff int, depth int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="block" data-name="block">
               <h3>
                  block 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <p>block prints an *ast.BlockStmt; it always spans at least two lines.</p>
               
               <pre><code class="language-go">func (p *printer) block(b *ast.BlockStmt, nindent int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bodySize" data-name="bodySize">
               <h3>
                  bodySize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bodySize" class="anchor" title="Link to bodySize">#</a>
               </h3>
               
               <p>bodySize is like nodeSize but it is specialized for *ast.BlockStmt's.</p>
               
               <pre><code class="language-go">func (p *printer) bodySize(b *ast.BlockStmt, maxSize int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="combinesWithName" data-name="combinesWithName">
               <h3>
                  combinesWithName 
                  <span class="badge">function</span>
                  
                  <a href="#combinesWithName" class="anchor" title="Link to combinesWithName">#</a>
               </h3>
               
               <p>combinesWithName reports whether a name followed by the expression x
syntactically combines to another valid (value) expression. For instance
using *T for x, "name *T" syntactically appears as the expression x*T.
On the other hand, using  P|Q or *P|~Q for x, "name P|Q" or "name *P|~Q"
cannot be combined into a valid (value) expression.</p>
               
               <pre><code class="language-go">func combinesWithName(x ast.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commentBefore" data-name="commentBefore">
               <h3>
                  commentBefore 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#commentBefore" class="anchor" title="Link to commentBefore">#</a>
               </h3>
               
               <p>commentBefore reports whether the current comment group occurs
before the next position in the source code and printing it does
not introduce implicit semicolons.</p>
               
               <pre><code class="language-go">func (p *printer) commentBefore(next token.Position) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commentSizeBefore" data-name="commentSizeBefore">
               <h3>
                  commentSizeBefore 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#commentSizeBefore" class="anchor" title="Link to commentSizeBefore">#</a>
               </h3>
               
               <p>commentSizeBefore returns the estimated size of the
comments on the same line before the next position.</p>
               
               <pre><code class="language-go">func (p *printer) commentSizeBefore(next token.Position) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commentTextAt" data-name="commentTextAt">
               <h3>
                  commentTextAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#commentTextAt" class="anchor" title="Link to commentTextAt">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) commentTextAt(start int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commentsHaveNewline" data-name="commentsHaveNewline">
               <h3>
                  commentsHaveNewline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#commentsHaveNewline" class="anchor" title="Link to commentsHaveNewline">#</a>
               </h3>
               
               <p>commentsHaveNewline reports whether a list of comments belonging to
an *ast.CommentGroup contains newlines. Because the position information
may only be partially correct, we also have to read the comment text.</p>
               
               <pre><code class="language-go">func (p *printer) commentsHaveNewline(list []*ast.Comment) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commonPrefix" data-name="commonPrefix">
               <h3>
                  commonPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#commonPrefix" class="anchor" title="Link to commonPrefix">#</a>
               </h3>
               
               <p>commonPrefix returns the common prefix of a and b.</p>
               
               <pre><code class="language-go">func commonPrefix(a string, b string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="containsLinebreak" data-name="containsLinebreak">
               <h3>
                  containsLinebreak 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#containsLinebreak" class="anchor" title="Link to containsLinebreak">#</a>
               </h3>
               
               <p>containsLinebreak reports whether the whitespace buffer contains any line breaks.</p>
               
               <pre><code class="language-go">func (p *printer) containsLinebreak() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="controlClause" data-name="controlClause">
               <h3>
                  controlClause 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#controlClause" class="anchor" title="Link to controlClause">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) controlClause(isForStmt bool, init ast.Stmt, expr ast.Expr, post ast.Stmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cutoff" data-name="cutoff">
               <h3>
                  cutoff 
                  <span class="badge">function</span>
                  
                  <a href="#cutoff" class="anchor" title="Link to cutoff">#</a>
               </h3>
               
               <pre><code class="language-go">func cutoff(e *ast.BinaryExpr, depth int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decl" data-name="decl">
               <h3>
                  decl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#decl" class="anchor" title="Link to decl">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) decl(decl ast.Decl)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declList" data-name="declList">
               <h3>
                  declList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#declList" class="anchor" title="Link to declList">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) declList(list []ast.Decl)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="declToken" data-name="declToken">
               <h3>
                  declToken 
                  <span class="badge">function</span>
                  
                  <a href="#declToken" class="anchor" title="Link to declToken">#</a>
               </h3>
               
               <pre><code class="language-go">func declToken(decl ast.Decl) (tok token.Token)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="diffPrec" data-name="diffPrec">
               <h3>
                  diffPrec 
                  <span class="badge">function</span>
                  
                  <a href="#diffPrec" class="anchor" title="Link to diffPrec">#</a>
               </h3>
               
               <pre><code class="language-go">func diffPrec(expr ast.Expr, prec int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="distanceFrom" data-name="distanceFrom">
               <h3>
                  distanceFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#distanceFrom" class="anchor" title="Link to distanceFrom">#</a>
               </h3>
               
               <p>distanceFrom returns the column difference between p.out (the current output
position) and startOutCol. If the start position is on a different line from
the current position (or either is unknown), the result is infinity.</p>
               
               <pre><code class="language-go">func (p *printer) distanceFrom(startPos token.Pos, startOutCol int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expr" data-name="expr">
               <h3>
                  expr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expr" class="anchor" title="Link to expr">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) expr(x ast.Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expr0" data-name="expr0">
               <h3>
                  expr0 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expr0" class="anchor" title="Link to expr0">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) expr0(x ast.Expr, depth int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expr1" data-name="expr1">
               <h3>
                  expr1 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expr1" class="anchor" title="Link to expr1">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) expr1(expr ast.Expr, prec1 int, depth int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exprList" data-name="exprList">
               <h3>
                  exprList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exprList" class="anchor" title="Link to exprList">#</a>
               </h3>
               
               <p>Print a list of expressions. If the list spans multiple
source lines, the original line breaks are respected between
expressions.
TODO(gri) Consider rewriting this to be independent of []ast.Expr
so that we can use the algorithm for any kind of list
(e.g., pass list via a channel over which to range).</p>
               
               <pre><code class="language-go">func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exprListMode, next0 token.Pos, isIncomplete bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fieldList" data-name="fieldList">
               <h3>
                  fieldList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fieldList" class="anchor" title="Link to fieldList">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) fieldList(fields *ast.FieldList, isStruct bool, isIncomplete bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="file" data-name="file">
               <h3>
                  file 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#file" class="anchor" title="Link to file">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) file(src *ast.File)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixGoBuildLines" data-name="fixGoBuildLines">
               <h3>
                  fixGoBuildLines 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fixGoBuildLines" class="anchor" title="Link to fixGoBuildLines">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) fixGoBuildLines()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flush" data-name="flush">
               <h3>
                  flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flush" class="anchor" title="Link to flush">#</a>
               </h3>
               
               <p>flush prints any pending comments and whitespace occurring textually
before the position of the next token tok. The flush result indicates
if a newline was written or if a formfeed was dropped from the whitespace
buffer.</p>
               
               <pre><code class="language-go">func (p *printer) flush(next token.Position, tok token.Token) (wroteNewline bool, droppedFF bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatDocComment" data-name="formatDocComment">
               <h3>
                  formatDocComment 
                  <span class="badge">function</span>
                  
                  <a href="#formatDocComment" class="anchor" title="Link to formatDocComment">#</a>
               </h3>
               
               <p>formatDocComment reformats the doc comment list,
returning the canonical formatting.</p>
               
               <pre><code class="language-go">func formatDocComment(list []*ast.Comment) []*ast.Comment</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fprint" data-name="fprint">
               <h3>
                  fprint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fprint" class="anchor" title="Link to fprint">#</a>
               </h3>
               
               <p>fprint implements Fprint and takes a nodesSizes map for setting up the printer state.</p>
               
               <pre><code class="language-go">func (cfg *Config) fprint(output io.Writer, fset *token.FileSet, node any, nodeSizes map[ast.Node]int) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="free" data-name="free">
               <h3>
                  free 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#free" class="anchor" title="Link to free">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) free()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcBody" data-name="funcBody">
               <h3>
                  funcBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcBody" class="anchor" title="Link to funcBody">#</a>
               </h3>
               
               <p>funcBody prints a function body following a function header of given headerSize.
If the header's and block's size are "small enough" and the block is "simple enough",
the block is printed on the current line, without line breaks, spaced from the header
by sep. Otherwise the block's opening "{" is printed on the current line, followed by
lines for the block's statements and its closing "}".</p>
               
               <pre><code class="language-go">func (p *printer) funcBody(headerSize int, sep whiteSpace, b *ast.BlockStmt)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="funcDecl" data-name="funcDecl">
               <h3>
                  funcDecl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#funcDecl" class="anchor" title="Link to funcDecl">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) funcDecl(d *ast.FuncDecl)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="genDecl" data-name="genDecl">
               <h3>
                  genDecl 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#genDecl" class="anchor" title="Link to genDecl">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) genDecl(d *ast.GenDecl)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getDoc" data-name="getDoc">
               <h3>
                  getDoc 
                  <span class="badge">function</span>
                  
                  <a href="#getDoc" class="anchor" title="Link to getDoc">#</a>
               </h3>
               
               <p>getDoc returns the ast.CommentGroup associated with n, if any.</p>
               
               <pre><code class="language-go">func getDoc(n ast.Node) *ast.CommentGroup</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getLastComment" data-name="getLastComment">
               <h3>
                  getLastComment 
                  <span class="badge">function</span>
                  
                  <a href="#getLastComment" class="anchor" title="Link to getLastComment">#</a>
               </h3>
               
               <pre><code class="language-go">func getLastComment(n ast.Node) *ast.CommentGroup</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="identList" data-name="identList">
               <h3>
                  identList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#identList" class="anchor" title="Link to identList">#</a>
               </h3>
               
               <p>If indent is set, a multi-line identifier list is indented after the
first linebreak encountered.</p>
               
               <pre><code class="language-go">func (p *printer) identList(list []*ast.Ident, indent bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="identListSize" data-name="identListSize">
               <h3>
                  identListSize 
                  <span class="badge">function</span>
                  
                  <a href="#identListSize" class="anchor" title="Link to identListSize">#</a>
               </h3>
               
               <pre><code class="language-go">func identListSize(list []*ast.Ident, maxSize int) (size int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indentList" data-name="indentList">
               <h3>
                  indentList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#indentList" class="anchor" title="Link to indentList">#</a>
               </h3>
               
               <p>indentList reports whether an expression list would look better if it
were indented wholesale (starting with the very first element, rather
than starting at the first line break).</p>
               
               <pre><code class="language-go">func (p *printer) indentList(list []ast.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="internalError" data-name="internalError">
               <h3>
                  internalError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#internalError" class="anchor" title="Link to internalError">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) internalError(msg ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intersperseComments" data-name="intersperseComments">
               <h3>
                  intersperseComments 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#intersperseComments" class="anchor" title="Link to intersperseComments">#</a>
               </h3>
               
               <p>intersperseComments consumes all comments that appear before the next token
tok and prints it together with the buffered whitespace (i.e., the whitespace
that needs to be written before the next token). A heuristic is used to mix
the comments and whitespace. The intersperseComments result indicates if a
newline was written or if a formfeed was dropped from the whitespace buffer.</p>
               
               <pre><code class="language-go">func (p *printer) intersperseComments(next token.Position, tok token.Token) (wroteNewline bool, droppedFF bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isBinary" data-name="isBinary">
               <h3>
                  isBinary 
                  <span class="badge">function</span>
                  
                  <a href="#isBinary" class="anchor" title="Link to isBinary">#</a>
               </h3>
               
               <pre><code class="language-go">func isBinary(expr ast.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isBlank" data-name="isBlank">
               <h3>
                  isBlank 
                  <span class="badge">function</span>
                  
                  <a href="#isBlank" class="anchor" title="Link to isBlank">#</a>
               </h3>
               
               <p>Returns true if s contains only white space
(only tabs and blanks can appear in the printer's context).</p>
               
               <pre><code class="language-go">func isBlank(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDirective" data-name="isDirective">
               <h3>
                  isDirective 
                  <span class="badge">function</span>
                  
                  <a href="#isDirective" class="anchor" title="Link to isDirective">#</a>
               </h3>
               
               <p>isDirective reports whether c is a comment directive.
See go.dev/issue/37974.
This code is also in go/ast.</p>
               
               <pre><code class="language-go">func isDirective(c string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNL" data-name="isNL">
               <h3>
                  isNL 
                  <span class="badge">function</span>
                  
                  <a href="#isNL" class="anchor" title="Link to isNL">#</a>
               </h3>
               
               <pre><code class="language-go">func isNL(b byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isOneLineFieldList" data-name="isOneLineFieldList">
               <h3>
                  isOneLineFieldList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isOneLineFieldList" class="anchor" title="Link to isOneLineFieldList">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) isOneLineFieldList(list []*ast.Field) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTypeElem" data-name="isTypeElem">
               <h3>
                  isTypeElem 
                  <span class="badge">function</span>
                  
                  <a href="#isTypeElem" class="anchor" title="Link to isTypeElem">#</a>
               </h3>
               
               <p>isTypeElem reports whether x is a (possibly parenthesized) type element expression.
The result is false if x could be a type element OR an ordinary (value) expression.</p>
               
               <pre><code class="language-go">func isTypeElem(x ast.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTypeName" data-name="isTypeName">
               <h3>
                  isTypeName 
                  <span class="badge">function</span>
                  
                  <a href="#isTypeName" class="anchor" title="Link to isTypeName">#</a>
               </h3>
               
               <pre><code class="language-go">func isTypeName(x ast.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="keepTypeColumn" data-name="keepTypeColumn">
               <h3>
                  keepTypeColumn 
                  <span class="badge">function</span>
                  
                  <a href="#keepTypeColumn" class="anchor" title="Link to keepTypeColumn">#</a>
               </h3>
               
               <p>The keepTypeColumn function determines if the type column of a series of
consecutive const or var declarations must be kept, or if initialization
values (V) can be placed in the type column (T) instead. The i'th entry
in the result slice is true if the type column in spec[i] must be kept.
For example, the declaration:
const (
foobar int = 42 // comment
x          = 7  // comment
foo
bar = 991
)
leads to the type/values matrix below. A run of value columns (V) can
be moved into the type column if there is no type for any of the values
in that column (we only move entire columns so that they align properly).
matrix        formatted     result
matrix
T  V    ->    T  V     ->   true      there is a T and so the type
-  V          -  V          true      column must be kept
-  -          -  -          false
-  V          V  -          false     V is moved into T column</p>
               
               <pre><code class="language-go">func keepTypeColumn(specs []ast.Spec) []bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lineAt" data-name="lineAt">
               <h3>
                  lineAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lineAt" class="anchor" title="Link to lineAt">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) lineAt(start int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lineFor" data-name="lineFor">
               <h3>
                  lineFor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lineFor" class="anchor" title="Link to lineFor">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) lineFor(pos token.Pos) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linebreak" data-name="linebreak">
               <h3>
                  linebreak 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linebreak" class="anchor" title="Link to linebreak">#</a>
               </h3>
               
               <p>Print as many newlines as necessary (but at least min newlines) to get to
the current line. ws is printed before the first line break. If newSection
is set, the first line break is printed as formfeed. Returns 0 if no line
breaks were printed, returns 1 if there was exactly one newline printed,
and returns a value > 1 if there was a formfeed or more than one newline
printed.
TODO(gri): linebreak may add too many lines if the next statement at "line"
is preceded by comments because the computation of n assumes
the current position before the comment and the target position
after the comment. Thus, after interspersing such comments, the
space taken up by them is not considered to reduce the number of
linebreaks. At the moment there is no easy way to know about
future (not yet interspersed) comments in this function.</p>
               
               <pre><code class="language-go">func (p *printer) linebreak(line int, min int, ws whiteSpace, newSection bool) (nbreaks int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="linesFrom" data-name="linesFrom">
               <h3>
                  linesFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#linesFrom" class="anchor" title="Link to linesFrom">#</a>
               </h3>
               
               <p>linesFrom returns the number of output lines between the current
output line and the line argument, ignoring any pending (not yet
emitted) whitespace or comments. It is used to compute an accurate
size (in number of lines) for a formatted construct.</p>
               
               <pre><code class="language-go">func (p *printer) linesFrom(line int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mayCombine" data-name="mayCombine">
               <h3>
                  mayCombine 
                  <span class="badge">function</span>
                  
                  <a href="#mayCombine" class="anchor" title="Link to mayCombine">#</a>
               </h3>
               
               <pre><code class="language-go">func mayCombine(prev token.Token, next byte) (b bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newPrinter" data-name="newPrinter">
               <h3>
                  newPrinter 
                  <span class="badge">function</span>
                  
                  <a href="#newPrinter" class="anchor" title="Link to newPrinter">#</a>
               </h3>
               
               <pre><code class="language-go">func newPrinter(cfg *Config, fset *token.FileSet, nodeSizes map[ast.Node]int) *printer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextComment" data-name="nextComment">
               <h3>
                  nextComment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nextComment" class="anchor" title="Link to nextComment">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) nextComment()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nlimit" data-name="nlimit">
               <h3>
                  nlimit 
                  <span class="badge">function</span>
                  
                  <a href="#nlimit" class="anchor" title="Link to nlimit">#</a>
               </h3>
               
               <p>nlimit limits n to maxNewlines.</p>
               
               <pre><code class="language-go">func nlimit(n int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nodeSize" data-name="nodeSize">
               <h3>
                  nodeSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nodeSize" class="anchor" title="Link to nodeSize">#</a>
               </h3>
               
               <p>nodeSize determines the size of n in chars after formatting.
The result is <= maxSize if the node fits on one line with at
most maxSize chars and the formatted output doesn't contain
any control chars. Otherwise, the result is > maxSize.</p>
               
               <pre><code class="language-go">func (p *printer) nodeSize(n ast.Node, maxSize int) (size int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="normalizedNumber" data-name="normalizedNumber">
               <h3>
                  normalizedNumber 
                  <span class="badge">function</span>
                  
                  <a href="#normalizedNumber" class="anchor" title="Link to normalizedNumber">#</a>
               </h3>
               
               <p>normalizedNumber rewrites base prefixes and exponents
of numbers to use lower-case letters (0X123 to 0x123 and 1.2E3 to 1.2e3),
and removes leading 0's from integer imaginary literals (0765i to 765i).
It leaves hexadecimal digits alone.
normalizedNumber doesn't modify the ast.BasicLit value lit points to.
If lit is not a number or a number in canonical format already,
lit is returned as is. Otherwise a new ast.BasicLit is created.</p>
               
               <pre><code class="language-go">func normalizedNumber(lit *ast.BasicLit) *ast.BasicLit</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="numLines" data-name="numLines">
               <h3>
                  numLines 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#numLines" class="anchor" title="Link to numLines">#</a>
               </h3>
               
               <p>numLines returns the number of lines spanned by node n in the original source.</p>
               
               <pre><code class="language-go">func (p *printer) numLines(n ast.Node) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parameters" data-name="parameters">
               <h3>
                  parameters 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parameters" class="anchor" title="Link to parameters">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) parameters(fields *ast.FieldList, mode paramMode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="posFor" data-name="posFor">
               <h3>
                  posFor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#posFor" class="anchor" title="Link to posFor">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) posFor(pos token.Pos) token.Position</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="possibleSelectorExpr" data-name="possibleSelectorExpr">
               <h3>
                  possibleSelectorExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#possibleSelectorExpr" class="anchor" title="Link to possibleSelectorExpr">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) possibleSelectorExpr(expr ast.Expr, prec1 int, depth int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="print" data-name="print">
               <h3>
                  print 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#print" class="anchor" title="Link to print">#</a>
               </h3>
               
               <p>print prints a list of "items" (roughly corresponding to syntactic
tokens, but also including whitespace and formatting information).
It is the only print function that should be called directly from
any of the AST printing functions in nodes.go.
Whitespace is accumulated until a non-whitespace token appears. Any
comments that need to appear before that token are printed first,
taking into account the amount and structure of any pending white-
space for best comment placement. Then, any leftover whitespace is
printed, followed by the actual token.</p>
               
               <pre><code class="language-go">func (p *printer) print(args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printNode" data-name="printNode">
               <h3>
                  printNode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printNode" class="anchor" title="Link to printNode">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) printNode(node any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recordLine" data-name="recordLine">
               <h3>
                  recordLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#recordLine" class="anchor" title="Link to recordLine">#</a>
               </h3>
               
               <p>recordLine records the output line number for the next non-whitespace
token in *linePtr. It is used to compute an accurate line number for a
formatted construct, independent of pending (not yet emitted) whitespace
or comments.</p>
               
               <pre><code class="language-go">func (p *printer) recordLine(linePtr *int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reduceDepth" data-name="reduceDepth">
               <h3>
                  reduceDepth 
                  <span class="badge">function</span>
                  
                  <a href="#reduceDepth" class="anchor" title="Link to reduceDepth">#</a>
               </h3>
               
               <pre><code class="language-go">func reduceDepth(depth int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resetSpace" data-name="resetSpace">
               <h3>
                  resetSpace 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#resetSpace" class="anchor" title="Link to resetSpace">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *trimmer) resetSpace()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sanitizeImportPath" data-name="sanitizeImportPath">
               <h3>
                  sanitizeImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#sanitizeImportPath" class="anchor" title="Link to sanitizeImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func sanitizeImportPath(lit *ast.BasicLit) *ast.BasicLit</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="selectorExpr" data-name="selectorExpr">
               <h3>
                  selectorExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#selectorExpr" class="anchor" title="Link to selectorExpr">#</a>
               </h3>
               
               <p>selectorExpr handles an *ast.SelectorExpr node and reports whether x spans
multiple lines.</p>
               
               <pre><code class="language-go">func (p *printer) selectorExpr(x *ast.SelectorExpr, depth int, isMethod bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setComment" data-name="setComment">
               <h3>
                  setComment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setComment" class="anchor" title="Link to setComment">#</a>
               </h3>
               
               <p>setComment sets g as the next comment if g != nil and if node comments
are enabled - this mode is used when printing source code fragments such
as exports only. It assumes that there is no pending comment in p.comments
and at most one pending comment in the p.comment cache.</p>
               
               <pre><code class="language-go">func (p *printer) setComment(g *ast.CommentGroup)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setLineComment" data-name="setLineComment">
               <h3>
                  setLineComment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setLineComment" class="anchor" title="Link to setLineComment">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) setLineComment(text string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setPos" data-name="setPos">
               <h3>
                  setPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setPos" class="anchor" title="Link to setPos">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) setPos(pos token.Pos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="signature" data-name="signature">
               <h3>
                  signature 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#signature" class="anchor" title="Link to signature">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) signature(sig *ast.FuncType)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="spec" data-name="spec">
               <h3>
                  spec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#spec" class="anchor" title="Link to spec">#</a>
               </h3>
               
               <p>The parameter n is the number of specs in the group. If doIndent is set,
multi-line identifier lists in the spec are indented when the first
linebreak is encountered.</p>
               
               <pre><code class="language-go">func (p *printer) spec(spec ast.Spec, n int, doIndent bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmt" data-name="stmt">
               <h3>
                  stmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmt" class="anchor" title="Link to stmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stmtList" data-name="stmtList">
               <h3>
                  stmtList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stmtList" class="anchor" title="Link to stmtList">#</a>
               </h3>
               
               <p>Print the statement list indented, but without a newline after the last statement.
Extra line breaks between statements in the source are respected but at most one
empty line is printed between statements.</p>
               
               <pre><code class="language-go">func (p *printer) stmtList(list []ast.Stmt, nindent int, nextIsRBrace bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stripCommonPrefix" data-name="stripCommonPrefix">
               <h3>
                  stripCommonPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#stripCommonPrefix" class="anchor" title="Link to stripCommonPrefix">#</a>
               </h3>
               
               <p>stripCommonPrefix removes a common prefix from /*-style comment lines (unless no
comment line is indented, all but the first line have some form of space prefix).
The prefix is computed using heuristics such that is likely that the comment
contents are nicely laid out after re-printing each line using the printer's
current indentation.</p>
               
               <pre><code class="language-go">func stripCommonPrefix(lines []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stripParens" data-name="stripParens">
               <h3>
                  stripParens 
                  <span class="badge">function</span>
                  
                  <a href="#stripParens" class="anchor" title="Link to stripParens">#</a>
               </h3>
               
               <pre><code class="language-go">func stripParens(x ast.Expr) ast.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stripParensAlways" data-name="stripParensAlways">
               <h3>
                  stripParensAlways 
                  <span class="badge">function</span>
                  
                  <a href="#stripParensAlways" class="anchor" title="Link to stripParensAlways">#</a>
               </h3>
               
               <pre><code class="language-go">func stripParensAlways(x ast.Expr) ast.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trimRight" data-name="trimRight">
               <h3>
                  trimRight 
                  <span class="badge">function</span>
                  
                  <a href="#trimRight" class="anchor" title="Link to trimRight">#</a>
               </h3>
               
               <p>trimRight returns s with trailing whitespace removed.</p>
               
               <pre><code class="language-go">func trimRight(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="valueSpec" data-name="valueSpec">
               <h3>
                  valueSpec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#valueSpec" class="anchor" title="Link to valueSpec">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) valueSpec(s *ast.ValueSpec, keepType bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkBinary" data-name="walkBinary">
               <h3>
                  walkBinary 
                  <span class="badge">function</span>
                  
                  <a href="#walkBinary" class="anchor" title="Link to walkBinary">#</a>
               </h3>
               
               <pre><code class="language-go">func walkBinary(e *ast.BinaryExpr) (has4 bool, has5 bool, maxProblem int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeByte" data-name="writeByte">
               <h3>
                  writeByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeByte" class="anchor" title="Link to writeByte">#</a>
               </h3>
               
               <p>writeByte writes ch n times to p.output and updates p.pos.
Only used to write formatting (white space) characters.</p>
               
               <pre><code class="language-go">func (p *printer) writeByte(ch byte, n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeComment" data-name="writeComment">
               <h3>
                  writeComment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeComment" class="anchor" title="Link to writeComment">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) writeComment(comment *ast.Comment)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeCommentPrefix" data-name="writeCommentPrefix">
               <h3>
                  writeCommentPrefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeCommentPrefix" class="anchor" title="Link to writeCommentPrefix">#</a>
               </h3>
               
               <p>writeCommentPrefix writes the whitespace before a comment.
If there is any pending whitespace, it consumes as much of
it as is likely to help position the comment nicely.
pos is the comment position, next the position of the item
after all pending comments, prev is the previous comment in
a group of comments (or nil), and tok is the next token.</p>
               
               <pre><code class="language-go">func (p *printer) writeCommentPrefix(pos token.Position, next token.Position, prev *ast.Comment, tok token.Token)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeCommentSuffix" data-name="writeCommentSuffix">
               <h3>
                  writeCommentSuffix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeCommentSuffix" class="anchor" title="Link to writeCommentSuffix">#</a>
               </h3>
               
               <p>writeCommentSuffix writes a line break after a comment if indicated
and processes any leftover indentation information. If a line break
is needed, the kind of break (newline vs formfeed) depends on the
pending whitespace. The writeCommentSuffix result indicates if a
newline was written or if a formfeed was dropped from the whitespace
buffer.</p>
               
               <pre><code class="language-go">func (p *printer) writeCommentSuffix(needsLinebreak bool) (wroteNewline bool, droppedFF bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeIndent" data-name="writeIndent">
               <h3>
                  writeIndent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeIndent" class="anchor" title="Link to writeIndent">#</a>
               </h3>
               
               <p>writeIndent writes indentation.</p>
               
               <pre><code class="language-go">func (p *printer) writeIndent()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeLineDirective" data-name="writeLineDirective">
               <h3>
                  writeLineDirective 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeLineDirective" class="anchor" title="Link to writeLineDirective">#</a>
               </h3>
               
               <p>writeLineDirective writes a //line directive if necessary.</p>
               
               <pre><code class="language-go">func (p *printer) writeLineDirective(pos token.Position)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeString" data-name="writeString">
               <h3>
                  writeString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeString" class="anchor" title="Link to writeString">#</a>
               </h3>
               
               <p>writeString writes the string s to p.output and updates p.pos, p.out,
and p.last. If isLit is set, s is escaped w/ tabwriter.Escape characters
to protect s from being interpreted by the tabwriter.
Note: writeString is only used to write Go tokens, literals, and
comments, all of which must be written literally. Thus, it is correct
to always set isLit = true. However, setting it explicitly only when
needed (i.e., when we don't know that s contains no tabs or line breaks)
avoids processing extra escape characters and reduces run time of the
printer benchmark by up to 10%.</p>
               
               <pre><code class="language-go">func (p *printer) writeString(pos token.Position, s string, isLit bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeWhitespace" data-name="writeWhitespace">
               <h3>
                  writeWhitespace 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeWhitespace" class="anchor" title="Link to writeWhitespace">#</a>
               </h3>
               
               <p>writeWhitespace writes the first n whitespace entries.</p>
               
               <pre><code class="language-go">func (p *printer) writeWhitespace(n int)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>