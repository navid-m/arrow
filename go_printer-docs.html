<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - printer</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="go_printer_testdata-docs.html">testdata</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>printer</code>
         </h1>
         <hr />
         
         <article class="global" data-name="commaTerm">
            <h2>commaTerm</h2>
            <hr />
            
            <pre><code>commaTerm exprListMode</code></pre>
         </article>
         
         <article class="global" data-name="noIndent">
            <h2>noIndent</h2>
            <hr />
            
            <pre><code>noIndent</code></pre>
         </article>
         
         <article class="global" data-name="filteredMsg">
            <h2>filteredMsg</h2>
            <hr />
            
            <pre><code>filteredMsg</code></pre>
         </article>
         
         <article class="global" data-name="funcParam">
            <h2>funcParam</h2>
            <hr />
            
            <pre><code>funcParam paramMode</code></pre>
         </article>
         
         <article class="global" data-name="funcTParam">
            <h2>funcTParam</h2>
            <hr />
            
            <pre><code>funcTParam</code></pre>
         </article>
         
         <article class="global" data-name="typeTParam">
            <h2>typeTParam</h2>
            <hr />
            
            <pre><code>typeTParam</code></pre>
         </article>
         
         <article class="global" data-name="fileNode">
            <h2>fileNode</h2>
            <hr />
            
            <pre><code>fileNode *ast.File</code></pre>
         </article>
         
         <article class="global" data-name="fileSize">
            <h2>fileSize</h2>
            <hr />
            
            <pre><code>fileSize int64</code></pre>
         </article>
         
         <article class="global" data-name="declNode">
            <h2>declNode</h2>
            <hr />
            
            <pre><code>declNode ast.Decl</code></pre>
         </article>
         
         <article class="global" data-name="declSize">
            <h2>declSize</h2>
            <hr />
            
            <pre><code>declSize int64</code></pre>
         </article>
         
         <article class="global" data-name="maxNewlines">
            <h2>maxNewlines</h2>
            <hr />
            
            <pre><code>maxNewlines</code></pre>
         </article>
         
         <article class="global" data-name="debug">
            <h2>debug</h2>
            <hr />
            
            <pre><code>debug</code></pre>
         </article>
         
         <article class="global" data-name="infinity">
            <h2>infinity</h2>
            <hr />
            
            <pre><code>infinity</code></pre>
         </article>
         
         <article class="global" data-name="ignore">
            <h2>ignore</h2>
            <hr />
            
            <pre><code>ignore</code></pre>
         </article>
         
         <article class="global" data-name="blank">
            <h2>blank</h2>
            <hr />
            
            <pre><code>blank</code></pre>
         </article>
         
         <article class="global" data-name="vtab">
            <h2>vtab</h2>
            <hr />
            
            <pre><code>vtab</code></pre>
         </article>
         
         <article class="global" data-name="newline">
            <h2>newline</h2>
            <hr />
            
            <pre><code>newline</code></pre>
         </article>
         
         <article class="global" data-name="formfeed">
            <h2>formfeed</h2>
            <hr />
            
            <pre><code>formfeed</code></pre>
         </article>
         
         <article class="global" data-name="indent">
            <h2>indent</h2>
            <hr />
            
            <pre><code>indent</code></pre>
         </article>
         
         <article class="global" data-name="unindent">
            <h2>unindent</h2>
            <hr />
            
            <pre><code>unindent</code></pre>
         </article>
         
         <article class="global" data-name="noExtraBlank">
            <h2>noExtraBlank</h2>
            <hr />
            
            <pre><code>noExtraBlank pmode</code></pre>
         </article>
         
         <article class="global" data-name="noExtraLinebreak">
            <h2>noExtraLinebreak</h2>
            <hr />
            
            <pre><code>noExtraLinebreak</code></pre>
         </article>
         
         <article class="global" data-name="inSpace">
            <h2>inSpace</h2>
            <hr />
            
            <p>trimmer is implemented as a state machine.
It can be in one of the following states:</p>
            
            <pre><code>inSpace</code></pre>
         </article>
         
         <article class="global" data-name="inEscape">
            <h2>inEscape</h2>
            <hr />
            
            <p>trimmer is implemented as a state machine.
It can be in one of the following states:</p>
            
            <pre><code>inEscape</code></pre>
         </article>
         
         <article class="global" data-name="inText">
            <h2>inText</h2>
            <hr />
            
            <p>trimmer is implemented as a state machine.
It can be in one of the following states:</p>
            
            <pre><code>inText</code></pre>
         </article>
         
         <article class="global" data-name="aNewline">
            <h2>aNewline</h2>
            <hr />
            
            <pre><code>aNewline</code></pre>
         </article>
         
         <article class="global" data-name="RawFormat">
            <h2>RawFormat</h2>
            <hr />
            
            <pre><code>RawFormat Mode</code></pre>
         </article>
         
         <article class="global" data-name="TabIndent">
            <h2>TabIndent</h2>
            <hr />
            
            <pre><code>TabIndent</code></pre>
         </article>
         
         <article class="global" data-name="UseSpaces">
            <h2>UseSpaces</h2>
            <hr />
            
            <pre><code>UseSpaces</code></pre>
         </article>
         
         <article class="global" data-name="SourcePos">
            <h2>SourcePos</h2>
            <hr />
            
            <pre><code>SourcePos</code></pre>
         </article>
         
         <article class="global" data-name="normalizeNumbers">
            <h2>normalizeNumbers</h2>
            <hr />
            
            <p>normalizeNumbers means to canonicalize number
literal prefixes and exponents while printing.

This value is known in and used by go/format and cmd/gofmt.
It is currently more convenient and performant for those
packages to apply number normalization during printing,
rather than by modifying the AST in advance.</p>
            
            <pre><code>normalizeNumbers Mode</code></pre>
         </article>
         
         <article class="global" data-name="printerPool">
            <h2>printerPool</h2>
            <hr />
            
            <pre><code>printerPool</code></pre>
         </article>
         
         <article class="global" data-name="dataDir">
            <h2>dataDir</h2>
            <hr />
            
            <pre><code>dataDir</code></pre>
         </article>
         
         <article class="global" data-name="tabwidth">
            <h2>tabwidth</h2>
            <hr />
            
            <pre><code>tabwidth</code></pre>
         </article>
         
         <article class="global" data-name="update">
            <h2>update</h2>
            <hr />
            
            <pre><code>update</code></pre>
         </article>
         
         <article class="global" data-name="fset">
            <h2>fset</h2>
            <hr />
            
            <pre><code>fset</code></pre>
         </article>
         
         <article class="global" data-name="export">
            <h2>export</h2>
            <hr />
            
            <pre><code>export checkMode</code></pre>
         </article>
         
         <article class="global" data-name="rawFormat">
            <h2>rawFormat</h2>
            <hr />
            
            <pre><code>rawFormat</code></pre>
         </article>
         
         <article class="global" data-name="normNumber">
            <h2>normNumber</h2>
            <hr />
            
            <pre><code>normNumber</code></pre>
         </article>
         
         <article class="global" data-name="idempotent">
            <h2>idempotent</h2>
            <hr />
            
            <pre><code>idempotent</code></pre>
         </article>
         
         <article class="global" data-name="allowTypeParams">
            <h2>allowTypeParams</h2>
            <hr />
            
            <pre><code>allowTypeParams</code></pre>
         </article>
         
         <article class="global" data-name="data">
            <h2>data</h2>
            <hr />
            
            <p>Use go test -update to create/update the respective golden files.</p>
            
            <pre><code>data</code></pre>
         </article>
         
         <article class="global" data-name="decls">
            <h2>decls</h2>
            <hr />
            
            <pre><code>decls</code></pre>
         </article>
         
         <article class="global" data-name="stmts">
            <h2>stmts</h2>
            <hr />
            
            <pre><code>stmts</code></pre>
         </article>
          
         <article class="struct" data-name="sizeCounter">
            <h2>type sizeCounter struct</h2>
            <hr />
            
            <p>sizeCounter is an io.Writer which counts the number of bytes written,
as well as whether a newline character was seen.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">hasNewline bool
size int</code></pre>
         </article>
         
         <article class="struct" data-name="commentInfo">
            <h2>type commentInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">cindex int
comment *ast.CommentGroup
commentOffset int
commentNewline bool</code></pre>
         </article>
         
         <article class="struct" data-name="printer">
            <h2>type printer struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Config
fset *token.FileSet
output []byte
indent int
level int
mode pmode
endAlignment bool
impliedSemi bool
lastTok token.Token
prevOpen token.Token
wsbuf []whiteSpace
goBuild []int
plusBuild []int
pos token.Position
out token.Position
last token.Position
linePtr *int
sourcePosErr error
comments []*ast.CommentGroup
useNodeComments bool
commentInfo
nodeSizes *ast.MapType
cachedPos token.Pos
cachedLine int</code></pre>
         </article>
         
         <article class="struct" data-name="trimmer">
            <h2>type trimmer struct</h2>
            <hr />
            
            <p>A trimmer is an io.Writer filter for stripping tabwriter.Escape
characters, trailing blanks and tabs, and for converting formfeed
and vtab characters into newlines and htabs (in case no tabwriter
is used). Text bracketed by tabwriter.Escape characters is passed
through unchanged.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">output io.Writer
state int
space []byte</code></pre>
         </article>
         
         <article class="struct" data-name="Config">
            <h2>type Config struct</h2>
            <hr />
            
            <p>A Config node controls the output of Fprint.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Mode Mode
Tabwidth int
Indent int</code></pre>
         </article>
         
         <article class="struct" data-name="CommentedNode">
            <h2>type CommentedNode struct</h2>
            <hr />
            
            <p>A CommentedNode bundles an AST node and corresponding comments.
It may be provided as argument to any of the [Fprint] functions.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Node any
Comments []*ast.CommentGroup</code></pre>
         </article>
         
         <article class="struct" data-name="entry">
            <h2>type entry struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">source string
golden string
mode checkMode</code></pre>
         </article>
         
         <article class="struct" data-name="limitWriter">
            <h2>type limitWriter struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">remaining int
errCount int</code></pre>
         </article>
          
         <article class="function" data-name="formatDocComment">
            <h2>formatDocComment</h2>
            <hr />
            
            <p>formatDocComment reformats the doc comment list,
returning the canonical formatting.</p>
            
            <pre><code>func formatDocComment(list []*ast.Comment) []*ast.Comment</code></pre>
         </article>
         
         <article class="function" data-name="isDirective">
            <h2>isDirective</h2>
            <hr />
            
            <p>isDirective reports whether c is a comment directive.
See go.dev/issue/37974.
This code is also in go/ast.</p>
            
            <pre><code>func isDirective(c string) bool</code></pre>
         </article>
         
         <article class="function" data-name="allStars">
            <h2>allStars</h2>
            <hr />
            
            <p>allStars reports whether text is the interior of an
old-style /* */ comment with a star at the start of each line.</p>
            
            <pre><code>func allStars(text string) bool</code></pre>
         </article>
         
         <article class="function" data-name="fixGoBuildLines">
            <h2>fixGoBuildLines</h2>
            <hr />
            
            <pre><code>func fixGoBuildLines()</code></pre>
         </article>
         
         <article class="function" data-name="appendLines">
            <h2>appendLines</h2>
            <hr />
            
            <p>appendLines is like append(x, y...)
but it avoids creating doubled blank lines,
which would not be gofmt-standard output.
It assumes that only whole blocks of lines are being appended,
not line fragments.</p>
            
            <pre><code>func appendLines(x []byte, y []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="lineAt">
            <h2>lineAt</h2>
            <hr />
            
            <pre><code>func lineAt(start int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="commentTextAt">
            <h2>commentTextAt</h2>
            <hr />
            
            <pre><code>func commentTextAt(start int) string</code></pre>
         </article>
         
         <article class="function" data-name="isNL">
            <h2>isNL</h2>
            <hr />
            
            <pre><code>func isNL(b byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="linebreak">
            <h2>linebreak</h2>
            <hr />
            
            <p>Print as many newlines as necessary (but at least min newlines) to get to
the current line. ws is printed before the first line break. If newSection
is set, the first line break is printed as formfeed. Returns 0 if no line
breaks were printed, returns 1 if there was exactly one newline printed,
and returns a value > 1 if there was a formfeed or more than one newline
printed.

TODO(gri): linebreak may add too many lines if the next statement at "line"
is preceded by comments because the computation of n assumes
the current position before the comment and the target position
after the comment. Thus, after interspersing such comments, the
space taken up by them is not considered to reduce the number of
linebreaks. At the moment there is no easy way to know about
future (not yet interspersed) comments in this function.</p>
            
            <pre><code>func linebreak(line int, min int, ws whiteSpace, newSection bool) nbreaks int</code></pre>
         </article>
         
         <article class="function" data-name="setComment">
            <h2>setComment</h2>
            <hr />
            
            <p>setComment sets g as the next comment if g != nil and if node comments
are enabled - this mode is used when printing source code fragments such
as exports only. It assumes that there is no pending comment in p.comments
and at most one pending comment in the p.comment cache.</p>
            
            <pre><code>func setComment(g *ast.CommentGroup)</code></pre>
         </article>
         
         <article class="function" data-name="identList">
            <h2>identList</h2>
            <hr />
            
            <p>If indent is set, a multi-line identifier list is indented after the
first linebreak encountered.</p>
            
            <pre><code>func identList(list []*ast.Ident, indent bool)</code></pre>
         </article>
         
         <article class="function" data-name="exprList">
            <h2>exprList</h2>
            <hr />
            
            <p>Print a list of expressions. If the list spans multiple
source lines, the original line breaks are respected between
expressions.

TODO(gri) Consider rewriting this to be independent of []ast.Expr
so that we can use the algorithm for any kind of list

	(e.g., pass list via a channel over which to range).</p>
            
            <pre><code>func exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exprListMode, next0 token.Pos, isIncomplete bool)</code></pre>
         </article>
         
         <article class="function" data-name="parameters">
            <h2>parameters</h2>
            <hr />
            
            <pre><code>func parameters(fields *ast.FieldList, mode paramMode)</code></pre>
         </article>
         
         <article class="function" data-name="combinesWithName">
            <h2>combinesWithName</h2>
            <hr />
            
            <p>combinesWithName reports whether a name followed by the expression x
syntactically combines to another valid (value) expression. For instance
using *T for x, "name *T" syntactically appears as the expression x*T.
On the other hand, using  P|Q or *P|~Q for x, "name P|Q" or "name *P|~Q"
cannot be combined into a valid (value) expression.</p>
            
            <pre><code>func combinesWithName(x ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="isTypeElem">
            <h2>isTypeElem</h2>
            <hr />
            
            <p>isTypeElem reports whether x is a (possibly parenthesized) type element expression.
The result is false if x could be a type element OR an ordinary (value) expression.</p>
            
            <pre><code>func isTypeElem(x ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="signature">
            <h2>signature</h2>
            <hr />
            
            <pre><code>func signature(sig *ast.FuncType)</code></pre>
         </article>
         
         <article class="function" data-name="identListSize">
            <h2>identListSize</h2>
            <hr />
            
            <pre><code>func identListSize(list []*ast.Ident, maxSize int) size int</code></pre>
         </article>
         
         <article class="function" data-name="isOneLineFieldList">
            <h2>isOneLineFieldList</h2>
            <hr />
            
            <pre><code>func isOneLineFieldList(list []*ast.Field) bool</code></pre>
         </article>
         
         <article class="function" data-name="setLineComment">
            <h2>setLineComment</h2>
            <hr />
            
            <pre><code>func setLineComment(text string)</code></pre>
         </article>
         
         <article class="function" data-name="fieldList">
            <h2>fieldList</h2>
            <hr />
            
            <pre><code>func fieldList(fields *ast.FieldList, isStruct bool, isIncomplete bool)</code></pre>
         </article>
         
         <article class="function" data-name="walkBinary">
            <h2>walkBinary</h2>
            <hr />
            
            <pre><code>func walkBinary(e *ast.BinaryExpr) (has4 bool, has5 bool, maxProblem int)</code></pre>
         </article>
         
         <article class="function" data-name="cutoff">
            <h2>cutoff</h2>
            <hr />
            
            <pre><code>func cutoff(e *ast.BinaryExpr, depth int) int</code></pre>
         </article>
         
         <article class="function" data-name="diffPrec">
            <h2>diffPrec</h2>
            <hr />
            
            <pre><code>func diffPrec(expr ast.Expr, prec int) int</code></pre>
         </article>
         
         <article class="function" data-name="reduceDepth">
            <h2>reduceDepth</h2>
            <hr />
            
            <pre><code>func reduceDepth(depth int) int</code></pre>
         </article>
         
         <article class="function" data-name="binaryExpr">
            <h2>binaryExpr</h2>
            <hr />
            
            <p>Format the binary expression: decide the cutoff and then format.
Let's call depth == 1 Normal mode, and depth > 1 Compact mode.
(Algorithm suggestion by Russ Cox.)

The precedences are:

	5             *  /  %  <<  >>  &  &^
	4             +  -  |  ^
	3             ==  !=  <  <=  >  >=
	2             &&
	1             ||

The only decision is whether there will be spaces around levels 4 and 5.
There are never spaces at level 6 (unary), and always spaces at levels 3 and below.

To choose the cutoff, look at the whole expression but excluding primary
expressions (function calls, parenthesized exprs), and apply these rules:

 1. If there is a binary operator with a right side unary operand
    that would clash without a space, the cutoff must be (in order):

    /*	6
    &&	6
    &^	6
    ++	5
    --	5

    (Comparison operators always have spaces around them.)

 2. If there is a mix of level 5 and level 4 operators, then the cutoff
    is 5 (use spaces to distinguish precedence) in Normal mode
    and 4 (never use spaces) in Compact mode.

 3. If there are no level 4 operators or no level 5 operators, then the
    cutoff is 6 (always use spaces) in Normal mode
    and 4 (never use spaces) in Compact mode.</p>
            
            <pre><code>func binaryExpr(x *ast.BinaryExpr, prec1 int, cutoff int, depth int)</code></pre>
         </article>
         
         <article class="function" data-name="isBinary">
            <h2>isBinary</h2>
            <hr />
            
            <pre><code>func isBinary(expr ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="expr1">
            <h2>expr1</h2>
            <hr />
            
            <pre><code>func expr1(expr ast.Expr, prec1 int, depth int)</code></pre>
         </article>
         
         <article class="function" data-name="normalizedNumber">
            <h2>normalizedNumber</h2>
            <hr />
            
            <p>normalizedNumber rewrites base prefixes and exponents
of numbers to use lower-case letters (0X123 to 0x123 and 1.2E3 to 1.2e3),
and removes leading 0's from integer imaginary literals (0765i to 765i).
It leaves hexadecimal digits alone.

normalizedNumber doesn't modify the ast.BasicLit value lit points to.
If lit is not a number or a number in canonical format already,
lit is returned as is. Otherwise a new ast.BasicLit is created.</p>
            
            <pre><code>func normalizedNumber(lit *ast.BasicLit) *ast.BasicLit</code></pre>
         </article>
         
         <article class="function" data-name="possibleSelectorExpr">
            <h2>possibleSelectorExpr</h2>
            <hr />
            
            <pre><code>func possibleSelectorExpr(expr ast.Expr, prec1 int, depth int) bool</code></pre>
         </article>
         
         <article class="function" data-name="selectorExpr">
            <h2>selectorExpr</h2>
            <hr />
            
            <p>selectorExpr handles an *ast.SelectorExpr node and reports whether x spans
multiple lines.</p>
            
            <pre><code>func selectorExpr(x *ast.SelectorExpr, depth int, isMethod bool) bool</code></pre>
         </article>
         
         <article class="function" data-name="expr0">
            <h2>expr0</h2>
            <hr />
            
            <pre><code>func expr0(x ast.Expr, depth int)</code></pre>
         </article>
         
         <article class="function" data-name="expr">
            <h2>expr</h2>
            <hr />
            
            <pre><code>func expr(x ast.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="stmtList">
            <h2>stmtList</h2>
            <hr />
            
            <p>Print the statement list indented, but without a newline after the last statement.
Extra line breaks between statements in the source are respected but at most one
empty line is printed between statements.</p>
            
            <pre><code>func stmtList(list []ast.Stmt, nindent int, nextIsRBrace bool)</code></pre>
         </article>
         
         <article class="function" data-name="block">
            <h2>block</h2>
            <hr />
            
            <p>block prints an *ast.BlockStmt; it always spans at least two lines.</p>
            
            <pre><code>func block(b *ast.BlockStmt, nindent int)</code></pre>
         </article>
         
         <article class="function" data-name="isTypeName">
            <h2>isTypeName</h2>
            <hr />
            
            <pre><code>func isTypeName(x ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="stripParens">
            <h2>stripParens</h2>
            <hr />
            
            <pre><code>func stripParens(x ast.Expr) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="stripParensAlways">
            <h2>stripParensAlways</h2>
            <hr />
            
            <pre><code>func stripParensAlways(x ast.Expr) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="controlClause">
            <h2>controlClause</h2>
            <hr />
            
            <pre><code>func controlClause(isForStmt bool, init ast.Stmt, expr ast.Expr, post ast.Stmt)</code></pre>
         </article>
         
         <article class="function" data-name="indentList">
            <h2>indentList</h2>
            <hr />
            
            <p>indentList reports whether an expression list would look better if it
were indented wholesale (starting with the very first element, rather
than starting at the first line break).</p>
            
            <pre><code>func indentList(list []ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="stmt">
            <h2>stmt</h2>
            <hr />
            
            <pre><code>func stmt(stmt ast.Stmt, nextIsRBrace bool)</code></pre>
         </article>
         
         <article class="function" data-name="keepTypeColumn">
            <h2>keepTypeColumn</h2>
            <hr />
            
            <p>The keepTypeColumn function determines if the type column of a series of
consecutive const or var declarations must be kept, or if initialization
values (V) can be placed in the type column (T) instead. The i'th entry
in the result slice is true if the type column in spec[i] must be kept.

For example, the declaration:

		const (
			foobar int = 42 // comment
			x          = 7  // comment
			foo
	             bar = 991
		)

leads to the type/values matrix below. A run of value columns (V) can
be moved into the type column if there is no type for any of the values
in that column (we only move entire columns so that they align properly).

		matrix        formatted     result
	                   matrix
		T  V    ->    T  V     ->   true      there is a T and so the type
		-  V          -  V          true      column must be kept
		-  -          -  -          false
		-  V          V  -          false     V is moved into T column</p>
            
            <pre><code>func keepTypeColumn(specs []ast.Spec) []bool</code></pre>
         </article>
         
         <article class="function" data-name="valueSpec">
            <h2>valueSpec</h2>
            <hr />
            
            <pre><code>func valueSpec(s *ast.ValueSpec, keepType bool)</code></pre>
         </article>
         
         <article class="function" data-name="sanitizeImportPath">
            <h2>sanitizeImportPath</h2>
            <hr />
            
            <pre><code>func sanitizeImportPath(lit *ast.BasicLit) *ast.BasicLit</code></pre>
         </article>
         
         <article class="function" data-name="spec">
            <h2>spec</h2>
            <hr />
            
            <p>The parameter n is the number of specs in the group. If doIndent is set,
multi-line identifier lists in the spec are indented when the first
linebreak is encountered.</p>
            
            <pre><code>func spec(spec ast.Spec, n int, doIndent bool)</code></pre>
         </article>
         
         <article class="function" data-name="genDecl">
            <h2>genDecl</h2>
            <hr />
            
            <pre><code>func genDecl(d *ast.GenDecl)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="nodeSize">
            <h2>nodeSize</h2>
            <hr />
            
            <p>nodeSize determines the size of n in chars after formatting.
The result is <= maxSize if the node fits on one line with at
most maxSize chars and the formatted output doesn't contain
any control chars. Otherwise, the result is > maxSize.</p>
            
            <pre><code>func nodeSize(n ast.Node, maxSize int) size int</code></pre>
         </article>
         
         <article class="function" data-name="numLines">
            <h2>numLines</h2>
            <hr />
            
            <p>numLines returns the number of lines spanned by node n in the original source.</p>
            
            <pre><code>func numLines(n ast.Node) int</code></pre>
         </article>
         
         <article class="function" data-name="bodySize">
            <h2>bodySize</h2>
            <hr />
            
            <p>bodySize is like nodeSize but it is specialized for *ast.BlockStmt's.</p>
            
            <pre><code>func bodySize(b *ast.BlockStmt, maxSize int) int</code></pre>
         </article>
         
         <article class="function" data-name="funcBody">
            <h2>funcBody</h2>
            <hr />
            
            <p>funcBody prints a function body following a function header of given headerSize.
If the header's and block's size are "small enough" and the block is "simple enough",
the block is printed on the current line, without line breaks, spaced from the header
by sep. Otherwise the block's opening "{" is printed on the current line, followed by
lines for the block's statements and its closing "}".</p>
            
            <pre><code>func funcBody(headerSize int, sep whiteSpace, b *ast.BlockStmt)</code></pre>
         </article>
         
         <article class="function" data-name="distanceFrom">
            <h2>distanceFrom</h2>
            <hr />
            
            <p>distanceFrom returns the column difference between p.out (the current output
position) and startOutCol. If the start position is on a different line from
the current position (or either is unknown), the result is infinity.</p>
            
            <pre><code>func distanceFrom(startPos token.Pos, startOutCol int) int</code></pre>
         </article>
         
         <article class="function" data-name="funcDecl">
            <h2>funcDecl</h2>
            <hr />
            
            <pre><code>func funcDecl(d *ast.FuncDecl)</code></pre>
         </article>
         
         <article class="function" data-name="decl">
            <h2>decl</h2>
            <hr />
            
            <pre><code>func decl(decl ast.Decl)</code></pre>
         </article>
         
         <article class="function" data-name="declToken">
            <h2>declToken</h2>
            <hr />
            
            <pre><code>func declToken(decl ast.Decl) tok token.Token</code></pre>
         </article>
         
         <article class="function" data-name="declList">
            <h2>declList</h2>
            <hr />
            
            <pre><code>func declList(list []ast.Decl)</code></pre>
         </article>
         
         <article class="function" data-name="file">
            <h2>file</h2>
            <hr />
            
            <pre><code>func file(src *ast.File)</code></pre>
         </article>
         
         <article class="function" data-name="testprint">
            <h2>testprint</h2>
            <hr />
            
            <pre><code>func testprint(out io.Writer, node ast.Node)</code></pre>
         </article>
         
         <article class="function" data-name="initialize">
            <h2>initialize</h2>
            <hr />
            
            <p>cannot initialize in init because (printer) Fprint launches goroutines.</p>
            
            <pre><code>func initialize()</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkPrintFile">
            <h2>BenchmarkPrintFile</h2>
            <hr />
            
            <pre><code>func BenchmarkPrintFile(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkPrintDecl">
            <h2>BenchmarkPrintDecl</h2>
            <hr />
            
            <pre><code>func BenchmarkPrintDecl(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="internalError">
            <h2>internalError</h2>
            <hr />
            
            <pre><code>func internalError(msg ...any)</code></pre>
         </article>
         
         <article class="function" data-name="commentsHaveNewline">
            <h2>commentsHaveNewline</h2>
            <hr />
            
            <p>commentsHaveNewline reports whether a list of comments belonging to
an *ast.CommentGroup contains newlines. Because the position information
may only be partially correct, we also have to read the comment text.</p>
            
            <pre><code>func commentsHaveNewline(list []*ast.Comment) bool</code></pre>
         </article>
         
         <article class="function" data-name="nextComment">
            <h2>nextComment</h2>
            <hr />
            
            <pre><code>func nextComment()</code></pre>
         </article>
         
         <article class="function" data-name="commentBefore">
            <h2>commentBefore</h2>
            <hr />
            
            <p>commentBefore reports whether the current comment group occurs
before the next position in the source code and printing it does
not introduce implicit semicolons.</p>
            
            <pre><code>func commentBefore(next token.Position) bool</code></pre>
         </article>
         
         <article class="function" data-name="commentSizeBefore">
            <h2>commentSizeBefore</h2>
            <hr />
            
            <p>commentSizeBefore returns the estimated size of the
comments on the same line before the next position.</p>
            
            <pre><code>func commentSizeBefore(next token.Position) int</code></pre>
         </article>
         
         <article class="function" data-name="recordLine">
            <h2>recordLine</h2>
            <hr />
            
            <p>recordLine records the output line number for the next non-whitespace
token in *linePtr. It is used to compute an accurate line number for a
formatted construct, independent of pending (not yet emitted) whitespace
or comments.</p>
            
            <pre><code>func recordLine(linePtr *int)</code></pre>
         </article>
         
         <article class="function" data-name="linesFrom">
            <h2>linesFrom</h2>
            <hr />
            
            <p>linesFrom returns the number of output lines between the current
output line and the line argument, ignoring any pending (not yet
emitted) whitespace or comments. It is used to compute an accurate
size (in number of lines) for a formatted construct.</p>
            
            <pre><code>func linesFrom(line int) int</code></pre>
         </article>
         
         <article class="function" data-name="posFor">
            <h2>posFor</h2>
            <hr />
            
            <pre><code>func posFor(pos token.Pos) token.Position</code></pre>
         </article>
         
         <article class="function" data-name="lineFor">
            <h2>lineFor</h2>
            <hr />
            
            <pre><code>func lineFor(pos token.Pos) int</code></pre>
         </article>
         
         <article class="function" data-name="writeLineDirective">
            <h2>writeLineDirective</h2>
            <hr />
            
            <p>writeLineDirective writes a //line directive if necessary.</p>
            
            <pre><code>func writeLineDirective(pos token.Position)</code></pre>
         </article>
         
         <article class="function" data-name="writeIndent">
            <h2>writeIndent</h2>
            <hr />
            
            <p>writeIndent writes indentation.</p>
            
            <pre><code>func writeIndent()</code></pre>
         </article>
         
         <article class="function" data-name="writeByte">
            <h2>writeByte</h2>
            <hr />
            
            <p>writeByte writes ch n times to p.output and updates p.pos.
Only used to write formatting (white space) characters.</p>
            
            <pre><code>func writeByte(ch byte, n int)</code></pre>
         </article>
         
         <article class="function" data-name="writeString">
            <h2>writeString</h2>
            <hr />
            
            <p>writeString writes the string s to p.output and updates p.pos, p.out,
and p.last. If isLit is set, s is escaped w/ tabwriter.Escape characters
to protect s from being interpreted by the tabwriter.

Note: writeString is only used to write Go tokens, literals, and
comments, all of which must be written literally. Thus, it is correct
to always set isLit = true. However, setting it explicitly only when
needed (i.e., when we don't know that s contains no tabs or line breaks)
avoids processing extra escape characters and reduces run time of the
printer benchmark by up to 10%.</p>
            
            <pre><code>func writeString(pos token.Position, s string, isLit bool)</code></pre>
         </article>
         
         <article class="function" data-name="writeCommentPrefix">
            <h2>writeCommentPrefix</h2>
            <hr />
            
            <p>writeCommentPrefix writes the whitespace before a comment.
If there is any pending whitespace, it consumes as much of
it as is likely to help position the comment nicely.
pos is the comment position, next the position of the item
after all pending comments, prev is the previous comment in
a group of comments (or nil), and tok is the next token.</p>
            
            <pre><code>func writeCommentPrefix(pos token.Position, next token.Position, prev *ast.Comment, tok token.Token)</code></pre>
         </article>
         
         <article class="function" data-name="isBlank">
            <h2>isBlank</h2>
            <hr />
            
            <p>Returns true if s contains only white space
(only tabs and blanks can appear in the printer's context).</p>
            
            <pre><code>func isBlank(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="commonPrefix">
            <h2>commonPrefix</h2>
            <hr />
            
            <p>commonPrefix returns the common prefix of a and b.</p>
            
            <pre><code>func commonPrefix(a string, b string) string</code></pre>
         </article>
         
         <article class="function" data-name="trimRight">
            <h2>trimRight</h2>
            <hr />
            
            <p>trimRight returns s with trailing whitespace removed.</p>
            
            <pre><code>func trimRight(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="stripCommonPrefix">
            <h2>stripCommonPrefix</h2>
            <hr />
            
            <p>stripCommonPrefix removes a common prefix from /*-style comment lines (unless no
comment line is indented, all but the first line have some form of space prefix).
The prefix is computed using heuristics such that is likely that the comment
contents are nicely laid out after re-printing each line using the printer's
current indentation.</p>
            
            <pre><code>func stripCommonPrefix(lines []string)</code></pre>
         </article>
         
         <article class="function" data-name="writeComment">
            <h2>writeComment</h2>
            <hr />
            
            <pre><code>func writeComment(comment *ast.Comment)</code></pre>
         </article>
         
         <article class="function" data-name="writeCommentSuffix">
            <h2>writeCommentSuffix</h2>
            <hr />
            
            <p>writeCommentSuffix writes a line break after a comment if indicated
and processes any leftover indentation information. If a line break
is needed, the kind of break (newline vs formfeed) depends on the
pending whitespace. The writeCommentSuffix result indicates if a
newline was written or if a formfeed was dropped from the whitespace
buffer.</p>
            
            <pre><code>func writeCommentSuffix(needsLinebreak bool) (wroteNewline bool, droppedFF bool)</code></pre>
         </article>
         
         <article class="function" data-name="containsLinebreak">
            <h2>containsLinebreak</h2>
            <hr />
            
            <p>containsLinebreak reports whether the whitespace buffer contains any line breaks.</p>
            
            <pre><code>func containsLinebreak() bool</code></pre>
         </article>
         
         <article class="function" data-name="intersperseComments">
            <h2>intersperseComments</h2>
            <hr />
            
            <p>intersperseComments consumes all comments that appear before the next token
tok and prints it together with the buffered whitespace (i.e., the whitespace
that needs to be written before the next token). A heuristic is used to mix
the comments and whitespace. The intersperseComments result indicates if a
newline was written or if a formfeed was dropped from the whitespace buffer.</p>
            
            <pre><code>func intersperseComments(next token.Position, tok token.Token) (wroteNewline bool, droppedFF bool)</code></pre>
         </article>
         
         <article class="function" data-name="writeWhitespace">
            <h2>writeWhitespace</h2>
            <hr />
            
            <p>writeWhitespace writes the first n whitespace entries.</p>
            
            <pre><code>func writeWhitespace(n int)</code></pre>
         </article>
         
         <article class="function" data-name="nlimit">
            <h2>nlimit</h2>
            <hr />
            
            <p>nlimit limits n to maxNewlines.</p>
            
            <pre><code>func nlimit(n int) int</code></pre>
         </article>
         
         <article class="function" data-name="mayCombine">
            <h2>mayCombine</h2>
            <hr />
            
            <pre><code>func mayCombine(prev token.Token, next byte) b bool</code></pre>
         </article>
         
         <article class="function" data-name="setPos">
            <h2>setPos</h2>
            <hr />
            
            <pre><code>func setPos(pos token.Pos)</code></pre>
         </article>
         
         <article class="function" data-name="print">
            <h2>print</h2>
            <hr />
            
            <p>print prints a list of "items" (roughly corresponding to syntactic
tokens, but also including whitespace and formatting information).
It is the only print function that should be called directly from
any of the AST printing functions in nodes.go.

Whitespace is accumulated until a non-whitespace token appears. Any
comments that need to appear before that token are printed first,
taking into account the amount and structure of any pending white-
space for best comment placement. Then, any leftover whitespace is
printed, followed by the actual token.</p>
            
            <pre><code>func print(args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="flush">
            <h2>flush</h2>
            <hr />
            
            <p>flush prints any pending comments and whitespace occurring textually
before the position of the next token tok. The flush result indicates
if a newline was written or if a formfeed was dropped from the whitespace
buffer.</p>
            
            <pre><code>func flush(next token.Position, tok token.Token) (wroteNewline bool, droppedFF bool)</code></pre>
         </article>
         
         <article class="function" data-name="getDoc">
            <h2>getDoc</h2>
            <hr />
            
            <p>getDoc returns the ast.CommentGroup associated with n, if any.</p>
            
            <pre><code>func getDoc(n ast.Node) *ast.CommentGroup</code></pre>
         </article>
         
         <article class="function" data-name="getLastComment">
            <h2>getLastComment</h2>
            <hr />
            
            <pre><code>func getLastComment(n ast.Node) *ast.CommentGroup</code></pre>
         </article>
         
         <article class="function" data-name="printNode">
            <h2>printNode</h2>
            <hr />
            
            <pre><code>func printNode(node any) error</code></pre>
         </article>
         
         <article class="function" data-name="resetSpace">
            <h2>resetSpace</h2>
            <hr />
            
            <pre><code>func resetSpace()</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(data []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="newPrinter">
            <h2>newPrinter</h2>
            <hr />
            
            <pre><code>func newPrinter(cfg *Config, fset *token.FileSet, nodeSizes *ast.MapType) *printer</code></pre>
         </article>
         
         <article class="function" data-name="free">
            <h2>free</h2>
            <hr />
            
            <pre><code>func free()</code></pre>
         </article>
         
         <article class="function" data-name="fprint">
            <h2>fprint</h2>
            <hr />
            
            <p>fprint implements Fprint and takes a nodesSizes map for setting up the printer state.</p>
            
            <pre><code>func fprint(output io.Writer, fset *token.FileSet, node any, nodeSizes *ast.MapType) err error</code></pre>
         </article>
         
         <article class="function" data-name="Fprint">
            <h2>Fprint</h2>
            <hr />
            
            <p>Fprint "pretty-prints" an AST node to output for a given configuration cfg.
Position information is interpreted relative to the file set fset.
The node type must be *[ast.File], *[CommentedNode], [][ast.Decl], [][ast.Stmt],
or assignment-compatible to [ast.Expr], [ast.Decl], [ast.Spec], or [ast.Stmt].</p>
            
            <pre><code>func Fprint(output io.Writer, fset *token.FileSet, node any) error</code></pre>
         </article>
         
         <article class="function" data-name="Fprint">
            <h2>Fprint</h2>
            <hr />
            
            <p>Fprint "pretty-prints" an AST node to output.
It calls [Config.Fprint] with default settings.
Note that gofmt uses tabs for indentation but spaces for alignment;
use format.Node (package go/format) for output that matches gofmt.</p>
            
            <pre><code>func Fprint(output io.Writer, fset *token.FileSet, node any) error</code></pre>
         </article>
         
         <article class="function" data-name="format">
            <h2>format</h2>
            <hr />
            
            <p>format parses src, prints the corresponding AST, verifies the resulting
src is syntactically correct, and returns the resulting src or an error
if any.</p>
            
            <pre><code>func format(src []byte, mode checkMode) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="lineAt">
            <h2>lineAt</h2>
            <hr />
            
            <p>lineAt returns the line in text starting at offset offs.</p>
            
            <pre><code>func lineAt(text []byte, offs int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="checkEqual">
            <h2>checkEqual</h2>
            <hr />
            
            <p>checkEqual compares a and b.</p>
            
            <pre><code>func checkEqual(aname string, bname string, a []byte, b []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="runcheck">
            <h2>runcheck</h2>
            <hr />
            
            <pre><code>func runcheck(t *testing.T, source string, golden string, mode checkMode)</code></pre>
         </article>
         
         <article class="function" data-name="check">
            <h2>check</h2>
            <hr />
            
            <pre><code>func check(t *testing.T, source string, golden string, mode checkMode)</code></pre>
         </article>
         
         <article class="function" data-name="TestFiles">
            <h2>TestFiles</h2>
            <hr />
            
            <pre><code>func TestFiles(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLineComments">
            <h2>TestLineComments</h2>
            <hr />
            
            <p>TestLineComments, using a simple test case, checks that consecutive line
comments are properly terminated with a newline even if the AST position
information is incorrect.</p>
            
            <pre><code>func TestLineComments(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <p>Verify that the printer can be invoked during initialization.</p>
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="TestBadNodes">
            <h2>TestBadNodes</h2>
            <hr />
            
            <p>Verify that the printer doesn't crash if the AST contains BadXXX nodes.</p>
            
            <pre><code>func TestBadNodes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testComment">
            <h2>testComment</h2>
            <hr />
            
            <p>testComment verifies that f can be parsed again after printing it
with its first comment set to comment at any possible source offset.</p>
            
            <pre><code>func testComment(t *testing.T, f *ast.File, srclen int, comment *ast.Comment)</code></pre>
         </article>
         
         <article class="function" data-name="TestBadComments">
            <h2>TestBadComments</h2>
            <hr />
            
            <p>Verify that the printer produces a correct program
even if the position information of comments introducing newlines
is incorrect.</p>
            
            <pre><code>func TestBadComments(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Visit">
            <h2>Visit</h2>
            <hr />
            
            <pre><code>func Visit(n ast.Node) w ast.Visitor</code></pre>
         </article>
         
         <article class="function" data-name="idents">
            <h2>idents</h2>
            <hr />
            
            <p>idents is an iterator that returns all idents in f via the result channel.</p>
            
            <pre><code>func idents(f *ast.File) *ast.ChanType</code></pre>
         </article>
         
         <article class="function" data-name="identCount">
            <h2>identCount</h2>
            <hr />
            
            <p>identCount returns the number of identifiers found in f.</p>
            
            <pre><code>func identCount(f *ast.File) int</code></pre>
         </article>
         
         <article class="function" data-name="TestSourcePos">
            <h2>TestSourcePos</h2>
            <hr />
            
            <p>Verify that the SourcePos mode emits correct //line directives
by testing that position information for matching identifiers
is maintained.</p>
            
            <pre><code>func TestSourcePos(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue5945">
            <h2>TestIssue5945</h2>
            <hr />
            
            <p>Verify that the SourcePos mode doesn't emit unnecessary //line directives
before empty lines.</p>
            
            <pre><code>func TestIssue5945(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDeclLists">
            <h2>TestDeclLists</h2>
            <hr />
            
            <pre><code>func TestDeclLists(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestStmtLists">
            <h2>TestStmtLists</h2>
            <hr />
            
            <pre><code>func TestStmtLists(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBaseIndent">
            <h2>TestBaseIndent</h2>
            <hr />
            
            <pre><code>func TestBaseIndent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestFuncType">
            <h2>TestFuncType</h2>
            <hr />
            
            <p>TestFuncType tests that an ast.FuncType with a nil Params field
can be printed (per go/ast specification). Test case for issue 3870.</p>
            
            <pre><code>func TestFuncType(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestChanType">
            <h2>TestChanType</h2>
            <hr />
            
            <p>TestChanType tests that the tree for <-(<-chan int), without
ParenExpr, is correctly formatted with parens.
Test case for issue #63362.</p>
            
            <pre><code>func TestChanType(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(buf []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriteErrors">
            <h2>TestWriteErrors</h2>
            <hr />
            
            <p>Test whether the printer stops writing after the first error</p>
            
            <pre><code>func TestWriteErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestX">
            <h2>TestX</h2>
            <hr />
            
            <p>TestX is a skeleton test that can be filled in for debugging one-off cases.
Do not remove.</p>
            
            <pre><code>func TestX(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCommentedNode">
            <h2>TestCommentedNode</h2>
            <hr />
            
            <pre><code>func TestCommentedNode(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue11151">
            <h2>TestIssue11151</h2>
            <hr />
            
            <pre><code>func TestIssue11151(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParenthesizedDecl">
            <h2>TestParenthesizedDecl</h2>
            <hr />
            
            <p>If a declaration has multiple specifications, a parenthesized
declaration must be printed even if Lparen is token.NoPos.</p>
            
            <pre><code>func TestParenthesizedDecl(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue32854">
            <h2>TestIssue32854</h2>
            <hr />
            
            <p>Verify that we don't print a newline between "return" and its results, as
that would incorrectly cause a naked return.</p>
            
            <pre><code>func TestIssue32854(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSourcePosNewline">
            <h2>TestSourcePosNewline</h2>
            <hr />
            
            <pre><code>func TestSourcePosNewline(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEmptyDecl">
            <h2>TestEmptyDecl</h2>
            <hr />
            
            <p>TestEmptyDecl tests that empty decls for const, var, import are printed with
valid syntax e.g "var ()" instead of just "var", which is invalid and cannot
be parsed.</p>
            
            <pre><code>func TestEmptyDecl(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
