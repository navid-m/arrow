<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - log</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="log_internal-docs.html">internal</a></li>
               
               <li><a href="log_slog-docs.html">slog</a></li>
               
               <li><a href="log_syslog-docs.html">syslog</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>log</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"fmt"
"io"
"log/internal"
"os"
"runtime"
"sync"
"sync/atomic"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="LUTC" data-name="LUTC">
               <h3>
                  LUTC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#LUTC" class="anchor" title="Link to LUTC">#</a>
               </h3>
               
               <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,
2009/01/23 01:23:23 message
while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
               
               <pre><code>const LUTC</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Ldate" data-name="Ldate">
               <h3>
                  Ldate 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Ldate" class="anchor" title="Link to Ldate">#</a>
               </h3>
               
               <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,
2009/01/23 01:23:23 message
while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
               
               <pre><code>const Ldate = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Llongfile" data-name="Llongfile">
               <h3>
                  Llongfile 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Llongfile" class="anchor" title="Link to Llongfile">#</a>
               </h3>
               
               <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,
2009/01/23 01:23:23 message
while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
               
               <pre><code>const Llongfile</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Lmicroseconds" data-name="Lmicroseconds">
               <h3>
                  Lmicroseconds 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Lmicroseconds" class="anchor" title="Link to Lmicroseconds">#</a>
               </h3>
               
               <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,
2009/01/23 01:23:23 message
while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
               
               <pre><code>const Lmicroseconds</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Lmsgprefix" data-name="Lmsgprefix">
               <h3>
                  Lmsgprefix 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Lmsgprefix" class="anchor" title="Link to Lmsgprefix">#</a>
               </h3>
               
               <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,
2009/01/23 01:23:23 message
while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
               
               <pre><code>const Lmsgprefix</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Lshortfile" data-name="Lshortfile">
               <h3>
                  Lshortfile 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Lshortfile" class="anchor" title="Link to Lshortfile">#</a>
               </h3>
               
               <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,
2009/01/23 01:23:23 message
while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
               
               <pre><code>const Lshortfile</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="LstdFlags" data-name="LstdFlags">
               <h3>
                  LstdFlags 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#LstdFlags" class="anchor" title="Link to LstdFlags">#</a>
               </h3>
               
               <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,
2009/01/23 01:23:23 message
while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
               
               <pre><code>const LstdFlags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Ltime" data-name="Ltime">
               <h3>
                  Ltime 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Ltime" class="anchor" title="Link to Ltime">#</a>
               </h3>
               
               <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,
2009/01/23 01:23:23 message
while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
               
               <pre><code>const Ltime</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bufferPool" data-name="bufferPool">
               <h3>
                  bufferPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bufferPool" class="anchor" title="Link to bufferPool">#</a>
               </h3>
               
               <pre><code>var bufferPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="std" data-name="std">
               <h3>
                  std 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#std" class="anchor" title="Link to std">#</a>
               </h3>
               
               <pre><code>var std = *ast.CallExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Logger" data-name="Logger">
               <h3>
                  Logger
                  <span class="badge">struct</span>
                  <a href="#Logger" class="anchor" title="Link to Logger">#</a>
               </h3>
               
               <p>A Logger represents an active logging object that generates lines of
output to an [io.Writer]. Each logging operation makes a single call to
the Writer's Write method. A Logger can be used simultaneously from
multiple goroutines; it guarantees to serialize access to the Writer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Logger struct {
outMu sync.Mutex
out io.Writer
prefix *ast.IndexExpr
flag atomic.Int32
isDiscard atomic.Bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Default" data-name="Default">
               <h3>
                  Default 
                  <span class="badge">function</span>
                  
                  <a href="#Default" class="anchor" title="Link to Default">#</a>
               </h3>
               
               <p>Default returns the standard logger used by the package-level output functions.</p>
               
               <pre><code>func Default() *Logger</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fatal" data-name="Fatal">
               <h3>
                  Fatal 
                  <span class="badge">function</span>
                  
                  <a href="#Fatal" class="anchor" title="Link to Fatal">#</a>
               </h3>
               
               <p>Fatal is equivalent to [Print] followed by a call to [os.Exit](1).</p>
               
               <pre><code>func Fatal(v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fatal" data-name="Fatal">
               <h3>
                  Fatal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fatal" class="anchor" title="Link to Fatal">#</a>
               </h3>
               
               <p>Fatal is equivalent to l.Print() followed by a call to [os.Exit](1).</p>
               
               <pre><code>func (l *Logger) Fatal(v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fatalf" data-name="Fatalf">
               <h3>
                  Fatalf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fatalf" class="anchor" title="Link to Fatalf">#</a>
               </h3>
               
               <p>Fatalf is equivalent to l.Printf() followed by a call to [os.Exit](1).</p>
               
               <pre><code>func (l *Logger) Fatalf(format string, v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fatalf" data-name="Fatalf">
               <h3>
                  Fatalf 
                  <span class="badge">function</span>
                  
                  <a href="#Fatalf" class="anchor" title="Link to Fatalf">#</a>
               </h3>
               
               <p>Fatalf is equivalent to [Printf] followed by a call to [os.Exit](1).</p>
               
               <pre><code>func Fatalf(format string, v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fatalln" data-name="Fatalln">
               <h3>
                  Fatalln 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fatalln" class="anchor" title="Link to Fatalln">#</a>
               </h3>
               
               <p>Fatalln is equivalent to l.Println() followed by a call to [os.Exit](1).</p>
               
               <pre><code>func (l *Logger) Fatalln(v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fatalln" data-name="Fatalln">
               <h3>
                  Fatalln 
                  <span class="badge">function</span>
                  
                  <a href="#Fatalln" class="anchor" title="Link to Fatalln">#</a>
               </h3>
               
               <p>Fatalln is equivalent to [Println] followed by a call to [os.Exit](1).</p>
               
               <pre><code>func Fatalln(v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flags" data-name="Flags">
               <h3>
                  Flags 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flags" class="anchor" title="Link to Flags">#</a>
               </h3>
               
               <p>Flags returns the output flags for the logger.
The flag bits are [Ldate], [Ltime], and so on.</p>
               
               <pre><code>func (l *Logger) Flags() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flags" data-name="Flags">
               <h3>
                  Flags 
                  <span class="badge">function</span>
                  
                  <a href="#Flags" class="anchor" title="Link to Flags">#</a>
               </h3>
               
               <p>Flags returns the output flags for the standard logger.
The flag bits are [Ldate], [Ltime], and so on.</p>
               
               <pre><code>func Flags() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="New" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
                  <a href="#New" class="anchor" title="Link to New">#</a>
               </h3>
               
               <p>New creates a new [Logger]. The out variable sets the
destination to which log data will be written.
The prefix appears at the beginning of each generated log line, or
after the log header if the [Lmsgprefix] flag is provided.
The flag argument defines the logging properties.</p>
               
               <pre><code>func New(out io.Writer, prefix string, flag int) *Logger</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Output" data-name="Output">
               <h3>
                  Output 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Output" class="anchor" title="Link to Output">#</a>
               </h3>
               
               <p>Output writes the output for a logging event. The string s contains
the text to print after the prefix specified by the flags of the
Logger. A newline is appended if the last character of s is not
already a newline. Calldepth is used to recover the PC and is
provided for generality, although at the moment on all pre-defined
paths it will be 2.</p>
               
               <pre><code>func (l *Logger) Output(calldepth int, s string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Output" data-name="Output">
               <h3>
                  Output 
                  <span class="badge">function</span>
                  
                  <a href="#Output" class="anchor" title="Link to Output">#</a>
               </h3>
               
               <p>Output writes the output for a logging event. The string s contains
the text to print after the prefix specified by the flags of the
Logger. A newline is appended if the last character of s is not
already a newline. Calldepth is the count of the number of
frames to skip when computing the file name and line number
if [Llongfile] or [Lshortfile] is set; a value of 1 will print the details
for the caller of Output.</p>
               
               <pre><code>func Output(calldepth int, s string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Panic" data-name="Panic">
               <h3>
                  Panic 
                  <span class="badge">function</span>
                  
                  <a href="#Panic" class="anchor" title="Link to Panic">#</a>
               </h3>
               
               <p>Panic is equivalent to [Print] followed by a call to panic().</p>
               
               <pre><code>func Panic(v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Panic" data-name="Panic">
               <h3>
                  Panic 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Panic" class="anchor" title="Link to Panic">#</a>
               </h3>
               
               <p>Panic is equivalent to l.Print() followed by a call to panic().</p>
               
               <pre><code>func (l *Logger) Panic(v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Panicf" data-name="Panicf">
               <h3>
                  Panicf 
                  <span class="badge">function</span>
                  
                  <a href="#Panicf" class="anchor" title="Link to Panicf">#</a>
               </h3>
               
               <p>Panicf is equivalent to [Printf] followed by a call to panic().</p>
               
               <pre><code>func Panicf(format string, v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Panicf" data-name="Panicf">
               <h3>
                  Panicf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Panicf" class="anchor" title="Link to Panicf">#</a>
               </h3>
               
               <p>Panicf is equivalent to l.Printf() followed by a call to panic().</p>
               
               <pre><code>func (l *Logger) Panicf(format string, v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Panicln" data-name="Panicln">
               <h3>
                  Panicln 
                  <span class="badge">function</span>
                  
                  <a href="#Panicln" class="anchor" title="Link to Panicln">#</a>
               </h3>
               
               <p>Panicln is equivalent to [Println] followed by a call to panic().</p>
               
               <pre><code>func Panicln(v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Panicln" data-name="Panicln">
               <h3>
                  Panicln 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Panicln" class="anchor" title="Link to Panicln">#</a>
               </h3>
               
               <p>Panicln is equivalent to l.Println() followed by a call to panic().</p>
               
               <pre><code>func (l *Logger) Panicln(v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Prefix" data-name="Prefix">
               <h3>
                  Prefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Prefix" class="anchor" title="Link to Prefix">#</a>
               </h3>
               
               <p>Prefix returns the output prefix for the logger.</p>
               
               <pre><code>func (l *Logger) Prefix() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Prefix" data-name="Prefix">
               <h3>
                  Prefix 
                  <span class="badge">function</span>
                  
                  <a href="#Prefix" class="anchor" title="Link to Prefix">#</a>
               </h3>
               
               <p>Prefix returns the output prefix for the standard logger.</p>
               
               <pre><code>func Prefix() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Print" data-name="Print">
               <h3>
                  Print 
                  <span class="badge">function</span>
                  
                  <a href="#Print" class="anchor" title="Link to Print">#</a>
               </h3>
               
               <p>Print calls Output to print to the standard logger.
Arguments are handled in the manner of [fmt.Print].</p>
               
               <pre><code>func Print(v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Print" data-name="Print">
               <h3>
                  Print 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Print" class="anchor" title="Link to Print">#</a>
               </h3>
               
               <p>Print calls l.Output to print to the logger.
Arguments are handled in the manner of [fmt.Print].</p>
               
               <pre><code>func (l *Logger) Print(v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Printf" data-name="Printf">
               <h3>
                  Printf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Printf" class="anchor" title="Link to Printf">#</a>
               </h3>
               
               <p>Printf calls l.Output to print to the logger.
Arguments are handled in the manner of [fmt.Printf].</p>
               
               <pre><code>func (l *Logger) Printf(format string, v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Printf" data-name="Printf">
               <h3>
                  Printf 
                  <span class="badge">function</span>
                  
                  <a href="#Printf" class="anchor" title="Link to Printf">#</a>
               </h3>
               
               <p>Printf calls Output to print to the standard logger.
Arguments are handled in the manner of [fmt.Printf].</p>
               
               <pre><code>func Printf(format string, v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Println" data-name="Println">
               <h3>
                  Println 
                  <span class="badge">function</span>
                  
                  <a href="#Println" class="anchor" title="Link to Println">#</a>
               </h3>
               
               <p>Println calls Output to print to the standard logger.
Arguments are handled in the manner of [fmt.Println].</p>
               
               <pre><code>func Println(v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Println" data-name="Println">
               <h3>
                  Println 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Println" class="anchor" title="Link to Println">#</a>
               </h3>
               
               <p>Println calls l.Output to print to the logger.
Arguments are handled in the manner of [fmt.Println].</p>
               
               <pre><code>func (l *Logger) Println(v ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetFlags" data-name="SetFlags">
               <h3>
                  SetFlags 
                  <span class="badge">function</span>
                  
                  <a href="#SetFlags" class="anchor" title="Link to SetFlags">#</a>
               </h3>
               
               <p>SetFlags sets the output flags for the standard logger.
The flag bits are [Ldate], [Ltime], and so on.</p>
               
               <pre><code>func SetFlags(flag int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetFlags" data-name="SetFlags">
               <h3>
                  SetFlags 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetFlags" class="anchor" title="Link to SetFlags">#</a>
               </h3>
               
               <p>SetFlags sets the output flags for the logger.
The flag bits are [Ldate], [Ltime], and so on.</p>
               
               <pre><code>func (l *Logger) SetFlags(flag int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetOutput" data-name="SetOutput">
               <h3>
                  SetOutput 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetOutput" class="anchor" title="Link to SetOutput">#</a>
               </h3>
               
               <p>SetOutput sets the output destination for the logger.</p>
               
               <pre><code>func (l *Logger) SetOutput(w io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetOutput" data-name="SetOutput">
               <h3>
                  SetOutput 
                  <span class="badge">function</span>
                  
                  <a href="#SetOutput" class="anchor" title="Link to SetOutput">#</a>
               </h3>
               
               <p>SetOutput sets the output destination for the standard logger.</p>
               
               <pre><code>func SetOutput(w io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetPrefix" data-name="SetPrefix">
               <h3>
                  SetPrefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetPrefix" class="anchor" title="Link to SetPrefix">#</a>
               </h3>
               
               <p>SetPrefix sets the output prefix for the logger.</p>
               
               <pre><code>func (l *Logger) SetPrefix(prefix string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetPrefix" data-name="SetPrefix">
               <h3>
                  SetPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#SetPrefix" class="anchor" title="Link to SetPrefix">#</a>
               </h3>
               
               <p>SetPrefix sets the output prefix for the standard logger.</p>
               
               <pre><code>func SetPrefix(prefix string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Writer" data-name="Writer">
               <h3>
                  Writer 
                  <span class="badge">function</span>
                  
                  <a href="#Writer" class="anchor" title="Link to Writer">#</a>
               </h3>
               
               <p>Writer returns the output destination for the standard logger.</p>
               
               <pre><code>func Writer() io.Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Writer" data-name="Writer">
               <h3>
                  Writer 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Writer" class="anchor" title="Link to Writer">#</a>
               </h3>
               
               <p>Writer returns the output destination for the logger.</p>
               
               <pre><code>func (l *Logger) Writer() io.Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatHeader" data-name="formatHeader">
               <h3>
                  formatHeader 
                  <span class="badge">function</span>
                  
                  <a href="#formatHeader" class="anchor" title="Link to formatHeader">#</a>
               </h3>
               
               <p>formatHeader writes log header to buf in following order:
- l.prefix (if it's not blank and Lmsgprefix is unset),
- date and/or time (if corresponding flags are provided),
- file and line number (if corresponding flags are provided),
- l.prefix (if it's not blank and Lmsgprefix is set).</p>
               
               <pre><code>func formatHeader(buf *[]byte, t time.Time, prefix string, flag int, file string, line int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getBuffer" data-name="getBuffer">
               <h3>
                  getBuffer 
                  <span class="badge">function</span>
                  
                  <a href="#getBuffer" class="anchor" title="Link to getBuffer">#</a>
               </h3>
               
               <pre><code>func getBuffer() *[]byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="itoa" data-name="itoa">
               <h3>
                  itoa 
                  <span class="badge">function</span>
                  
                  <a href="#itoa" class="anchor" title="Link to itoa">#</a>
               </h3>
               
               <p>Cheap integer to fixed-width decimal ASCII. Give a negative width to avoid zero-padding.</p>
               
               <pre><code>func itoa(buf *[]byte, i int, wid int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="output" data-name="output">
               <h3>
                  output 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#output" class="anchor" title="Link to output">#</a>
               </h3>
               
               <p>output can take either a calldepth or a pc to get source line information.
It uses the pc if it is non-zero.</p>
               
               <pre><code>func (l *Logger) output(pc uintptr, calldepth int, appendOutput func([]byte) []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="putBuffer" data-name="putBuffer">
               <h3>
                  putBuffer 
                  <span class="badge">function</span>
                  
                  <a href="#putBuffer" class="anchor" title="Link to putBuffer">#</a>
               </h3>
               
               <pre><code>func putBuffer(p *[]byte)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>