<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - log</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="log_internal-docs.html">internal</a>
         <br />
         
         <a href="log_slog-docs.html">slog</a>
         <br />
         
         <a href="log_syslog-docs.html">syslog</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>log</code>
         </h1>
         <hr />
         
         <article class="global" data-name="Ldate">
            <h2>Ldate</h2>
            <hr />
            
            <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,

	2009/01/23 01:23:23 message

while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,

	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
            
            <pre><code>Ldate</code></pre>
         </article>
         
         <article class="global" data-name="Ltime">
            <h2>Ltime</h2>
            <hr />
            
            <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,

	2009/01/23 01:23:23 message

while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,

	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
            
            <pre><code>Ltime</code></pre>
         </article>
         
         <article class="global" data-name="Lmicroseconds">
            <h2>Lmicroseconds</h2>
            <hr />
            
            <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,

	2009/01/23 01:23:23 message

while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,

	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
            
            <pre><code>Lmicroseconds</code></pre>
         </article>
         
         <article class="global" data-name="Llongfile">
            <h2>Llongfile</h2>
            <hr />
            
            <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,

	2009/01/23 01:23:23 message

while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,

	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
            
            <pre><code>Llongfile</code></pre>
         </article>
         
         <article class="global" data-name="Lshortfile">
            <h2>Lshortfile</h2>
            <hr />
            
            <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,

	2009/01/23 01:23:23 message

while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,

	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
            
            <pre><code>Lshortfile</code></pre>
         </article>
         
         <article class="global" data-name="LUTC">
            <h2>LUTC</h2>
            <hr />
            
            <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,

	2009/01/23 01:23:23 message

while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,

	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
            
            <pre><code>LUTC</code></pre>
         </article>
         
         <article class="global" data-name="Lmsgprefix">
            <h2>Lmsgprefix</h2>
            <hr />
            
            <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,

	2009/01/23 01:23:23 message

while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,

	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
            
            <pre><code>Lmsgprefix</code></pre>
         </article>
         
         <article class="global" data-name="LstdFlags">
            <h2>LstdFlags</h2>
            <hr />
            
            <p>These flags define which text to prefix to each log entry generated by the [Logger].
Bits are or'ed together to control what's printed.
With the exception of the Lmsgprefix flag, there is no
control over the order they appear (the order listed here)
or the format they present (as described in the comments).
The prefix is followed by a colon only when Llongfile or Lshortfile
is specified.
For example, flags Ldate | Ltime (or LstdFlags) produce,

	2009/01/23 01:23:23 message

while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,

	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message</p>
            
            <pre><code>LstdFlags</code></pre>
         </article>
         
         <article class="global" data-name="std">
            <h2>std</h2>
            <hr />
            
            <pre><code>std</code></pre>
         </article>
         
         <article class="global" data-name="bufferPool">
            <h2>bufferPool</h2>
            <hr />
            
            <pre><code>bufferPool</code></pre>
         </article>
         
         <article class="global" data-name="Rdate">
            <h2>Rdate</h2>
            <hr />
            
            <pre><code>Rdate</code></pre>
         </article>
         
         <article class="global" data-name="Rtime">
            <h2>Rtime</h2>
            <hr />
            
            <pre><code>Rtime</code></pre>
         </article>
         
         <article class="global" data-name="Rmicroseconds">
            <h2>Rmicroseconds</h2>
            <hr />
            
            <pre><code>Rmicroseconds</code></pre>
         </article>
         
         <article class="global" data-name="Rline">
            <h2>Rline</h2>
            <hr />
            
            <pre><code>Rline</code></pre>
         </article>
         
         <article class="global" data-name="Rlongfile">
            <h2>Rlongfile</h2>
            <hr />
            
            <pre><code>Rlongfile</code></pre>
         </article>
         
         <article class="global" data-name="Rshortfile">
            <h2>Rshortfile</h2>
            <hr />
            
            <pre><code>Rshortfile</code></pre>
         </article>
         
         <article class="global" data-name="tests">
            <h2>tests</h2>
            <hr />
            
            <pre><code>tests</code></pre>
         </article>
          
         <article class="struct" data-name="Logger">
            <h2>type Logger struct</h2>
            <hr />
            
            <p>A Logger represents an active logging object that generates lines of
output to an [io.Writer]. Each logging operation makes a single call to
the Writer's Write method. A Logger can be used simultaneously from
multiple goroutines; it guarantees to serialize access to the Writer.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">outMu sync.Mutex
out io.Writer
prefix *ast.IndexExpr
flag atomic.Int32
isDiscard atomic.Bool</code></pre>
         </article>
         
         <article class="struct" data-name="tester">
            <h2>type tester struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">flag int
prefix string
pattern string</code></pre>
         </article>
         
         <article class="struct" data-name="discard">
            <h2>type discard struct</h2>
            <hr />
            
            <p>discard is identical to io.Discard,
but copied here to avoid the io.Discard optimization in Logger.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
          
         <article class="function" data-name="New">
            <h2>New</h2>
            <hr />
            
            <p>New creates a new [Logger]. The out variable sets the
destination to which log data will be written.
The prefix appears at the beginning of each generated log line, or
after the log header if the [Lmsgprefix] flag is provided.
The flag argument defines the logging properties.</p>
            
            <pre><code>func New(out io.Writer, prefix string, flag int) *Logger</code></pre>
         </article>
         
         <article class="function" data-name="SetOutput">
            <h2>SetOutput</h2>
            <hr />
            
            <p>SetOutput sets the output destination for the logger.</p>
            
            <pre><code>func SetOutput(w io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="Default">
            <h2>Default</h2>
            <hr />
            
            <p>Default returns the standard logger used by the package-level output functions.</p>
            
            <pre><code>func Default() *Logger</code></pre>
         </article>
         
         <article class="function" data-name="itoa">
            <h2>itoa</h2>
            <hr />
            
            <p>Cheap integer to fixed-width decimal ASCII. Give a negative width to avoid zero-padding.</p>
            
            <pre><code>func itoa(buf *[]byte, i int, wid int)</code></pre>
         </article>
         
         <article class="function" data-name="formatHeader">
            <h2>formatHeader</h2>
            <hr />
            
            <p>formatHeader writes log header to buf in following order:
  - l.prefix (if it's not blank and Lmsgprefix is unset),
  - date and/or time (if corresponding flags are provided),
  - file and line number (if corresponding flags are provided),
  - l.prefix (if it's not blank and Lmsgprefix is set).</p>
            
            <pre><code>func formatHeader(buf *[]byte, t time.Time, prefix string, flag int, file string, line int)</code></pre>
         </article>
         
         <article class="function" data-name="getBuffer">
            <h2>getBuffer</h2>
            <hr />
            
            <pre><code>func getBuffer() *[]byte</code></pre>
         </article>
         
         <article class="function" data-name="putBuffer">
            <h2>putBuffer</h2>
            <hr />
            
            <pre><code>func putBuffer(p *[]byte)</code></pre>
         </article>
         
         <article class="function" data-name="Output">
            <h2>Output</h2>
            <hr />
            
            <p>Output writes the output for a logging event. The string s contains
the text to print after the prefix specified by the flags of the
Logger. A newline is appended if the last character of s is not
already a newline. Calldepth is used to recover the PC and is
provided for generality, although at the moment on all pre-defined
paths it will be 2.</p>
            
            <pre><code>func Output(calldepth int, s string) error</code></pre>
         </article>
         
         <article class="function" data-name="output">
            <h2>output</h2>
            <hr />
            
            <p>output can take either a calldepth or a pc to get source line information.
It uses the pc if it is non-zero.</p>
            
            <pre><code>func output(pc uintptr, calldepth int, appendOutput func) error</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="Print">
            <h2>Print</h2>
            <hr />
            
            <p>Print calls l.Output to print to the logger.
Arguments are handled in the manner of [fmt.Print].</p>
            
            <pre><code>func Print(v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Printf">
            <h2>Printf</h2>
            <hr />
            
            <p>Printf calls l.Output to print to the logger.
Arguments are handled in the manner of [fmt.Printf].</p>
            
            <pre><code>func Printf(format string, v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Println">
            <h2>Println</h2>
            <hr />
            
            <p>Println calls l.Output to print to the logger.
Arguments are handled in the manner of [fmt.Println].</p>
            
            <pre><code>func Println(v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Fatal">
            <h2>Fatal</h2>
            <hr />
            
            <p>Fatal is equivalent to l.Print() followed by a call to [os.Exit](1).</p>
            
            <pre><code>func Fatal(v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Fatalf">
            <h2>Fatalf</h2>
            <hr />
            
            <p>Fatalf is equivalent to l.Printf() followed by a call to [os.Exit](1).</p>
            
            <pre><code>func Fatalf(format string, v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Fatalln">
            <h2>Fatalln</h2>
            <hr />
            
            <p>Fatalln is equivalent to l.Println() followed by a call to [os.Exit](1).</p>
            
            <pre><code>func Fatalln(v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Panic">
            <h2>Panic</h2>
            <hr />
            
            <p>Panic is equivalent to l.Print() followed by a call to panic().</p>
            
            <pre><code>func Panic(v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Panicf">
            <h2>Panicf</h2>
            <hr />
            
            <p>Panicf is equivalent to l.Printf() followed by a call to panic().</p>
            
            <pre><code>func Panicf(format string, v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Panicln">
            <h2>Panicln</h2>
            <hr />
            
            <p>Panicln is equivalent to l.Println() followed by a call to panic().</p>
            
            <pre><code>func Panicln(v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Flags">
            <h2>Flags</h2>
            <hr />
            
            <p>Flags returns the output flags for the logger.
The flag bits are [Ldate], [Ltime], and so on.</p>
            
            <pre><code>func Flags() int</code></pre>
         </article>
         
         <article class="function" data-name="SetFlags">
            <h2>SetFlags</h2>
            <hr />
            
            <p>SetFlags sets the output flags for the logger.
The flag bits are [Ldate], [Ltime], and so on.</p>
            
            <pre><code>func SetFlags(flag int)</code></pre>
         </article>
         
         <article class="function" data-name="Prefix">
            <h2>Prefix</h2>
            <hr />
            
            <p>Prefix returns the output prefix for the logger.</p>
            
            <pre><code>func Prefix() string</code></pre>
         </article>
         
         <article class="function" data-name="SetPrefix">
            <h2>SetPrefix</h2>
            <hr />
            
            <p>SetPrefix sets the output prefix for the logger.</p>
            
            <pre><code>func SetPrefix(prefix string)</code></pre>
         </article>
         
         <article class="function" data-name="Writer">
            <h2>Writer</h2>
            <hr />
            
            <p>Writer returns the output destination for the logger.</p>
            
            <pre><code>func Writer() io.Writer</code></pre>
         </article>
         
         <article class="function" data-name="SetOutput">
            <h2>SetOutput</h2>
            <hr />
            
            <p>SetOutput sets the output destination for the standard logger.</p>
            
            <pre><code>func SetOutput(w io.Writer)</code></pre>
         </article>
         
         <article class="function" data-name="Flags">
            <h2>Flags</h2>
            <hr />
            
            <p>Flags returns the output flags for the standard logger.
The flag bits are [Ldate], [Ltime], and so on.</p>
            
            <pre><code>func Flags() int</code></pre>
         </article>
         
         <article class="function" data-name="SetFlags">
            <h2>SetFlags</h2>
            <hr />
            
            <p>SetFlags sets the output flags for the standard logger.
The flag bits are [Ldate], [Ltime], and so on.</p>
            
            <pre><code>func SetFlags(flag int)</code></pre>
         </article>
         
         <article class="function" data-name="Prefix">
            <h2>Prefix</h2>
            <hr />
            
            <p>Prefix returns the output prefix for the standard logger.</p>
            
            <pre><code>func Prefix() string</code></pre>
         </article>
         
         <article class="function" data-name="SetPrefix">
            <h2>SetPrefix</h2>
            <hr />
            
            <p>SetPrefix sets the output prefix for the standard logger.</p>
            
            <pre><code>func SetPrefix(prefix string)</code></pre>
         </article>
         
         <article class="function" data-name="Writer">
            <h2>Writer</h2>
            <hr />
            
            <p>Writer returns the output destination for the standard logger.</p>
            
            <pre><code>func Writer() io.Writer</code></pre>
         </article>
         
         <article class="function" data-name="Print">
            <h2>Print</h2>
            <hr />
            
            <p>Print calls Output to print to the standard logger.
Arguments are handled in the manner of [fmt.Print].</p>
            
            <pre><code>func Print(v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Printf">
            <h2>Printf</h2>
            <hr />
            
            <p>Printf calls Output to print to the standard logger.
Arguments are handled in the manner of [fmt.Printf].</p>
            
            <pre><code>func Printf(format string, v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Println">
            <h2>Println</h2>
            <hr />
            
            <p>Println calls Output to print to the standard logger.
Arguments are handled in the manner of [fmt.Println].</p>
            
            <pre><code>func Println(v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Fatal">
            <h2>Fatal</h2>
            <hr />
            
            <p>Fatal is equivalent to [Print] followed by a call to [os.Exit](1).</p>
            
            <pre><code>func Fatal(v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Fatalf">
            <h2>Fatalf</h2>
            <hr />
            
            <p>Fatalf is equivalent to [Printf] followed by a call to [os.Exit](1).</p>
            
            <pre><code>func Fatalf(format string, v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Fatalln">
            <h2>Fatalln</h2>
            <hr />
            
            <p>Fatalln is equivalent to [Println] followed by a call to [os.Exit](1).</p>
            
            <pre><code>func Fatalln(v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Panic">
            <h2>Panic</h2>
            <hr />
            
            <p>Panic is equivalent to [Print] followed by a call to panic().</p>
            
            <pre><code>func Panic(v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Panicf">
            <h2>Panicf</h2>
            <hr />
            
            <p>Panicf is equivalent to [Printf] followed by a call to panic().</p>
            
            <pre><code>func Panicf(format string, v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Panicln">
            <h2>Panicln</h2>
            <hr />
            
            <p>Panicln is equivalent to [Println] followed by a call to panic().</p>
            
            <pre><code>func Panicln(v ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Output">
            <h2>Output</h2>
            <hr />
            
            <p>Output writes the output for a logging event. The string s contains
the text to print after the prefix specified by the flags of the
Logger. A newline is appended if the last character of s is not
already a newline. Calldepth is the count of the number of
frames to skip when computing the file name and line number
if [Llongfile] or [Lshortfile] is set; a value of 1 will print the details
for the caller of Output.</p>
            
            <pre><code>func Output(calldepth int, s string) error</code></pre>
         </article>
         
         <article class="function" data-name="testPrint">
            <h2>testPrint</h2>
            <hr />
            
            <p>Test using Println("hello", 23, "world") or using Printf("hello %d world", 23)</p>
            
            <pre><code>func testPrint(t *testing.T, flag int, prefix string, pattern string, useFormat bool)</code></pre>
         </article>
         
         <article class="function" data-name="TestDefault">
            <h2>TestDefault</h2>
            <hr />
            
            <pre><code>func TestDefault(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAll">
            <h2>TestAll</h2>
            <hr />
            
            <pre><code>func TestAll(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestOutput">
            <h2>TestOutput</h2>
            <hr />
            
            <pre><code>func TestOutput(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNonNewLogger">
            <h2>TestNonNewLogger</h2>
            <hr />
            
            <pre><code>func TestNonNewLogger(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestOutputRace">
            <h2>TestOutputRace</h2>
            <hr />
            
            <pre><code>func TestOutputRace(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestFlagAndPrefixSetting">
            <h2>TestFlagAndPrefixSetting</h2>
            <hr />
            
            <pre><code>func TestFlagAndPrefixSetting(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUTCFlag">
            <h2>TestUTCFlag</h2>
            <hr />
            
            <pre><code>func TestUTCFlag(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEmptyPrintCreatesLine">
            <h2>TestEmptyPrintCreatesLine</h2>
            <hr />
            
            <pre><code>func TestEmptyPrintCreatesLine(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDiscard">
            <h2>TestDiscard</h2>
            <hr />
            
            <pre><code>func TestDiscard(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkItoa">
            <h2>BenchmarkItoa</h2>
            <hr />
            
            <pre><code>func BenchmarkItoa(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkPrintln">
            <h2>BenchmarkPrintln</h2>
            <hr />
            
            <pre><code>func BenchmarkPrintln(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkPrintlnNoFlags">
            <h2>BenchmarkPrintlnNoFlags</h2>
            <hr />
            
            <pre><code>func BenchmarkPrintlnNoFlags(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkConcurrent">
            <h2>BenchmarkConcurrent</h2>
            <hr />
            
            <pre><code>func BenchmarkConcurrent(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDiscard">
            <h2>BenchmarkDiscard</h2>
            <hr />
            
            <pre><code>func BenchmarkDiscard(b *testing.B)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
