<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - profile</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>profile</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"fmt"
"sort"
"strings"
"fmt"
"sort"
"strconv"
"strings"
"bytes"
"compress/gzip"
"fmt"
"io"
"strings"
"time"
"errors"
"fmt"
"fmt"
"regexp"
"errors"
"fmt"
"sort"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="ErrNoData">
               <h3>
                  ErrNoData 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ErrNoData = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errMalformed">
               <h3>
                  errMalformed 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errMalformed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="functionDecoder">
               <h3>
                  functionDecoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var functionDecoder = []decoder{...}</code></pre>
            </article>
            
            <article class="global" data-name="labelDecoder">
               <h3>
                  labelDecoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var labelDecoder = []decoder{...}</code></pre>
            </article>
            
            <article class="global" data-name="lineDecoder">
               <h3>
                  lineDecoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var lineDecoder = []decoder{...}</code></pre>
            </article>
            
            <article class="global" data-name="locationDecoder">
               <h3>
                  locationDecoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var locationDecoder = []decoder{...}</code></pre>
            </article>
            
            <article class="global" data-name="mappingDecoder">
               <h3>
                  mappingDecoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var mappingDecoder = []decoder{...}</code></pre>
            </article>
            
            <article class="global" data-name="profileDecoder">
               <h3>
                  profileDecoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var profileDecoder = []decoder{...}</code></pre>
            </article>
            
            <article class="global" data-name="sampleDecoder">
               <h3>
                  sampleDecoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var sampleDecoder = []decoder{...}</code></pre>
            </article>
            
            <article class="global" data-name="valueTypeDecoder">
               <h3>
                  valueTypeDecoder 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var valueTypeDecoder = []decoder{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Demangler">
               <h3>
                  Demangler
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Demangler maps symbol names to a human-readable form. This may
include C++ demangling and additional simplification. Names that
are not demangled may be missing from the resulting map.</p>
               
               <pre><code>type Demangler func(name []string) (map[string]string, error)</code></pre>
            </article>
            
            <article class="type" data-name="EdgeMap">
               <h3>
                  EdgeMap
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>EdgeMap is used to represent the incoming/outgoing edges from a node.</p>
               
               <pre><code>type EdgeMap []*Edge</code></pre>
            </article>
            
            <article class="type" data-name="NodeMap">
               <h3>
                  NodeMap
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>NodeMap maps from a node info struct to a node. It is used to merge
report entries with the same info.</p>
               
               <pre><code>type NodeMap map[NodeInfo]*Node</code></pre>
            </article>
            
            <article class="type" data-name="NodePtrSet">
               <h3>
                  NodePtrSet
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>NodePtrSet is a collection of nodes. Trimming a graph or tree requires a set
of objects which uniquely identify the nodes to keep. In a graph, NodeInfo
works as a unique identifier; however, in a tree multiple nodes may share
identical NodeInfos. A *Node does uniquely identify a node so we can use that
instead. Though a *Node also uniquely identifies a node in a graph,
currently, during trimming, graphs are rebuilt from scratch using only the
NodeSet, so there would not be the required context of the initial graph to
allow for the use of *Node.</p>
               
               <pre><code>type NodePtrSet map[*Node]bool</code></pre>
            </article>
            
            <article class="type" data-name="NodeSet">
               <h3>
                  NodeSet
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>NodeSet is a collection of node info structs.</p>
               
               <pre><code>type NodeSet map[NodeInfo]bool</code></pre>
            </article>
            
            <article class="type" data-name="Nodes">
               <h3>
                  Nodes
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Nodes is an ordered collection of graph nodes.</p>
               
               <pre><code>type Nodes []*Node</code></pre>
            </article>
            
            <article class="type" data-name="TagMatch">
               <h3>
                  TagMatch
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>TagMatch selects tags for filtering</p>
               
               <pre><code>type TagMatch func(key string, val string, nval int64) bool</code></pre>
            </article>
            
            <article class="type" data-name="decoder">
               <h3>
                  decoder
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type decoder func(*buffer, message) error</code></pre>
            </article>
            
            <article class="type" data-name="edgeList">
               <h3>
                  edgeList
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type edgeList []*Edge</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="message">
               <h3>
                  message
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type message interface {
decoder() []decoder
encode(*buffer)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Edge">
               <h3>
                  Edge
                  <span class="badge">struct</span>
               </h3>
               
               <p>Edge contains any attributes to be represented about edges in a graph.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Edge struct {
Src *Node
Dest *Node
Weight int64
WeightDiv int64
Residual bool
Inline bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Function">
               <h3>
                  Function
                  <span class="badge">struct</span>
               </h3>
               
               <p>Function corresponds to Profile.Function</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Function struct {
ID uint64
Name string
SystemName string
Filename string
StartLine int64
nameX int64
systemNameX int64
filenameX int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Graph">
               <h3>
                  Graph
                  <span class="badge">struct</span>
               </h3>
               
               <p>Graph summarizes a performance profile into a format that is
suitable for visualization.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Graph struct {
Nodes Nodes
}</code></pre>
            </article>
            
            <article class="struct" data-name="Label">
               <h3>
                  Label
                  <span class="badge">struct</span>
               </h3>
               
               <p>Label corresponds to Profile.Label</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Label struct {
keyX int64
strX int64
numX int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Line">
               <h3>
                  Line
                  <span class="badge">struct</span>
               </h3>
               
               <p>Line corresponds to Profile.Line</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Line struct {
Function *Function
Line int64
functionIDX uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Location">
               <h3>
                  Location
                  <span class="badge">struct</span>
               </h3>
               
               <p>Location corresponds to Profile.Location</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Location struct {
ID uint64
Mapping *Mapping
Address uint64
Line []Line
IsFolded bool
mappingIDX uint64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Mapping">
               <h3>
                  Mapping
                  <span class="badge">struct</span>
               </h3>
               
               <p>Mapping corresponds to Profile.Mapping</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Mapping struct {
ID uint64
Start uint64
Limit uint64
Offset uint64
File string
BuildID string
HasFunctions bool
HasFilenames bool
HasLineNumbers bool
HasInlineFrames bool
fileX int64
buildIDX int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Node">
               <h3>
                  Node
                  <span class="badge">struct</span>
               </h3>
               
               <p>Node is an entry on a profiling report. It represents a unique
program location.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Node struct {
Info NodeInfo
Function *Node
Flat int64
FlatDiv int64
Cum int64
CumDiv int64
In EdgeMap
Out EdgeMap
}</code></pre>
            </article>
            
            <article class="struct" data-name="NodeInfo">
               <h3>
                  NodeInfo
                  <span class="badge">struct</span>
               </h3>
               
               <p>NodeInfo contains the attributes for a node.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NodeInfo struct {
Name string
Address uint64
StartLine int
Lineno int
}</code></pre>
            </article>
            
            <article class="struct" data-name="Options">
               <h3>
                  Options
                  <span class="badge">struct</span>
               </h3>
               
               <p>Options encodes the options for constructing a graph</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Options struct {
SampleValue func(s []int64) int64
SampleMeanDivisor func(s []int64) int64
DropNegative bool
KeptNodes NodeSet
}</code></pre>
            </article>
            
            <article class="struct" data-name="Profile">
               <h3>
                  Profile
                  <span class="badge">struct</span>
               </h3>
               
               <p>Profile is an in-memory representation of profile.proto.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Profile struct {
SampleType []*ValueType
DefaultSampleType string
Sample []*Sample
Mapping []*Mapping
Location []*Location
Function []*Function
Comments []string
DropFrames string
KeepFrames string
TimeNanos int64
DurationNanos int64
PeriodType *ValueType
Period int64
commentX []int64
dropFramesX int64
keepFramesX int64
stringTable []string
defaultSampleTypeX int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="Sample">
               <h3>
                  Sample
                  <span class="badge">struct</span>
               </h3>
               
               <p>Sample corresponds to Profile.Sample</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Sample struct {
Location []*Location
Value []int64
Label map[string][]string
NumLabel map[string][]int64
NumUnit map[string][]string
locationIDX []uint64
labelX []Label
}</code></pre>
            </article>
            
            <article class="struct" data-name="ValueType">
               <h3>
                  ValueType
                  <span class="badge">struct</span>
               </h3>
               
               <p>ValueType corresponds to Profile.ValueType</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ValueType struct {
Type string
Unit string
typeX int64
unitX int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="buffer">
               <h3>
                  buffer
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type buffer struct {
field int
typ int
u64 uint64
data []byte
tmp [16]byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="functionKey">
               <h3>
                  functionKey
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type functionKey struct {
startLine int64
name string
systemName string
fileName string
}</code></pre>
            </article>
            
            <article class="struct" data-name="locationKey">
               <h3>
                  locationKey
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type locationKey struct {
addr uint64
mappingID uint64
lines string
isFolded bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="locationMap">
               <h3>
                  locationMap
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type locationMap struct {
s []Nodes
m map[uint64]Nodes
}</code></pre>
            </article>
            
            <article class="struct" data-name="mapInfo">
               <h3>
                  mapInfo
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mapInfo struct {
m *Mapping
offset int64
}</code></pre>
            </article>
            
            <article class="struct" data-name="mappingKey">
               <h3>
                  mappingKey
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type mappingKey struct {
size uint64
offset uint64
buildIDOrFile string
}</code></pre>
            </article>
            
            <article class="struct" data-name="nodePair">
               <h3>
                  nodePair
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nodePair struct {
src *Node
dest *Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="profileMerger">
               <h3>
                  profileMerger
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type profileMerger struct {
p *Profile
locationsByID map[uint64]*Location
functionsByID map[uint64]*Function
mappingsByID map[uint64]mapInfo
samples map[sampleKey]*Sample
locations map[locationKey]*Location
functions map[functionKey]*Function
mappings map[mappingKey]*Mapping
}</code></pre>
            </article>
            
            <article class="struct" data-name="sampleKey">
               <h3>
                  sampleKey
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sampleKey struct {
locations string
labels string
numlabels string
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (em *EdgeMap) Add(e *Edge)</code></pre>
            </article>
            
            <article class="function" data-name="AddToEdge">
               <h3>
                  AddToEdge 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddToEdge increases the weight of an edge between two nodes. If
there isn't such an edge one is created.</p>
               
               <pre><code>func (n *Node) AddToEdge(to *Node, v int64, residual bool, inline bool)</code></pre>
            </article>
            
            <article class="function" data-name="AddToEdgeDiv">
               <h3>
                  AddToEdgeDiv 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddToEdgeDiv increases the weight of an edge between two nodes. If
there isn't such an edge one is created.</p>
               
               <pre><code>func (n *Node) AddToEdgeDiv(to *Node, dv int64, v int64, residual bool, inline bool)</code></pre>
            </article>
            
            <article class="function" data-name="Aggregate">
               <h3>
                  Aggregate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Aggregate merges the locations in the profile into equivalence
classes preserving the request attributes. It also updates the
samples to point to the merged locations.</p>
               
               <pre><code>func (p *Profile) Aggregate(inlineFrame bool, function bool, filename bool, linenumber bool, address bool) error</code></pre>
            </article>
            
            <article class="function" data-name="CheckValid">
               <h3>
                  CheckValid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CheckValid tests whether the profile is valid. Checks include, but are
not limited to:
- len(Profile.Sample[n].value) == len(Profile.value_unit)
- Sample.id has a corresponding Profile.Location</p>
               
               <pre><code>func (p *Profile) CheckValid() error</code></pre>
            </article>
            
            <article class="function" data-name="Compatible">
               <h3>
                  Compatible 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Compatible determines if two profiles can be compared/merged.
returns nil if the profiles are compatible; otherwise an error with
details on the incompatibility.</p>
               
               <pre><code>func (p *Profile) Compatible(pb *Profile) error</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copy makes a fully independent copy of a profile.</p>
               
               <pre><code>func (p *Profile) Copy() *Profile</code></pre>
            </article>
            
            <article class="function" data-name="CreateNodes">
               <h3>
                  CreateNodes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CreateNodes creates graph nodes for all locations in a profile. It
returns set of all nodes, plus a mapping of each location to the
set of corresponding nodes (one per location.Line).</p>
               
               <pre><code>func CreateNodes(prof *Profile, o *Options) (Nodes, locationMap)</code></pre>
            </article>
            
            <article class="function" data-name="CumValue">
               <h3>
                  CumValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CumValue returns the inclusive value for this node, computing the
mean if a divisor is available.</p>
               
               <pre><code>func (n *Node) CumValue() int64</code></pre>
            </article>
            
            <article class="function" data-name="Delete">
               <h3>
                  Delete 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (em *EdgeMap) Delete(e *Edge)</code></pre>
            </article>
            
            <article class="function" data-name="Demangle">
               <h3>
                  Demangle 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Demangle attempts to demangle and optionally simplify any function
names referenced in the profile. It works on a best-effort basis:
it will silently preserve the original names in case of any errors.</p>
               
               <pre><code>func (p *Profile) Demangle(d Demangler) error</code></pre>
            </article>
            
            <article class="function" data-name="Empty">
               <h3>
                  Empty 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Empty reports whether the profile contains no samples.</p>
               
               <pre><code>func (p *Profile) Empty() bool</code></pre>
            </article>
            
            <article class="function" data-name="FilterSamplesByTag">
               <h3>
                  FilterSamplesByTag 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FilterSamplesByTag removes all samples from the profile, except
those that match focus and do not match the ignore regular
expression.</p>
               
               <pre><code>func (p *Profile) FilterSamplesByTag(focus TagMatch, ignore TagMatch) (fm bool, im bool)</code></pre>
            </article>
            
            <article class="function" data-name="FindOrInsertNode">
               <h3>
                  FindOrInsertNode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FindOrInsertNode takes the info for a node and either returns a matching node
from the node map if one exists, or adds one to the map if one does not.
If kept is non-nil, nodes are only added if they can be located on it.</p>
               
               <pre><code>func (nm NodeMap) FindOrInsertNode(info NodeInfo, kept NodeSet) *Node</code></pre>
            </article>
            
            <article class="function" data-name="FindTo">
               <h3>
                  FindTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (em EdgeMap) FindTo(n *Node) *Edge</code></pre>
            </article>
            
            <article class="function" data-name="FlatValue">
               <h3>
                  FlatValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FlatValue returns the exclusive value for this node, computing the
mean if a divisor is available.</p>
               
               <pre><code>func (n *Node) FlatValue() int64</code></pre>
            </article>
            
            <article class="function" data-name="HasFileLines">
               <h3>
                  HasFileLines 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>HasFileLines determines if all locations in this profile have
symbolized file and line number information.</p>
               
               <pre><code>func (p *Profile) HasFileLines() bool</code></pre>
            </article>
            
            <article class="function" data-name="HasFunctions">
               <h3>
                  HasFunctions 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>HasFunctions determines if all locations in this profile have
symbolized function information.</p>
               
               <pre><code>func (p *Profile) HasFunctions() bool</code></pre>
            </article>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (el edgeList) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (el edgeList) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Merge">
               <h3>
                  Merge 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Merge adds profile p adjusted by ratio r into profile p. Profiles
must be compatible (same Type and SampleType).
TODO(rsilvera): consider normalizing the profiles based on the
total samples collected.</p>
               
               <pre><code>func (p *Profile) Merge(pb *Profile, r float64) error</code></pre>
            </article>
            
            <article class="function" data-name="Merge">
               <h3>
                  Merge 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Merge merges all the profiles in profs into a single Profile.
Returns a new profile independent of the input profiles. The merged
profile is compacted to eliminate unused samples, locations,
functions and mappings. Profiles must have identical profile sample
and period types or the merge will fail. profile.Period of the
resulting profile will be the maximum of all profiles, and
profile.TimeNanos will be the earliest nonzero one.</p>
               
               <pre><code>func Merge(srcs []*Profile) (*Profile, error)</code></pre>
            </article>
            
            <article class="function" data-name="NameComponents">
               <h3>
                  NameComponents 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NameComponents returns the components of the printable name to be used for a node.</p>
               
               <pre><code>func (i *NodeInfo) NameComponents() []string</code></pre>
            </article>
            
            <article class="function" data-name="NewGraph">
               <h3>
                  NewGraph 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewGraph computes a graph from a profile.</p>
               
               <pre><code>func NewGraph(prof *Profile, o *Options) *Graph</code></pre>
            </article>
            
            <article class="function" data-name="Normalize">
               <h3>
                  Normalize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Normalize normalizes the source profile by multiplying each value in profile by the
ratio of the sum of the base profile's values of that sample type to the sum of the
source profile's value of that sample type.</p>
               
               <pre><code>func (p *Profile) Normalize(pb *Profile) error</code></pre>
            </article>
            
            <article class="function" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Parse parses a profile and checks for its validity. The input must be an
encoded pprof protobuf, which may optionally be gzip-compressed.</p>
               
               <pre><code>func Parse(r io.Reader) (*Profile, error)</code></pre>
            </article>
            
            <article class="function" data-name="PrintableName">
               <h3>
                  PrintableName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PrintableName calls the Node's Formatter function with a single space separator.</p>
               
               <pre><code>func (i *NodeInfo) PrintableName() string</code></pre>
            </article>
            
            <article class="function" data-name="Prune">
               <h3>
                  Prune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Prune removes all nodes beneath a node matching dropRx, and not
matching keepRx. If the root node of a Sample matches, the sample
will have an empty stack.</p>
               
               <pre><code>func (p *Profile) Prune(dropRx *regexp.Regexp, keepRx *regexp.Regexp)</code></pre>
            </article>
            
            <article class="function" data-name="RemoveUninteresting">
               <h3>
                  RemoveUninteresting 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RemoveUninteresting prunes and elides profiles using built-in
tables of uninteresting function names.</p>
               
               <pre><code>func (p *Profile) RemoveUninteresting() error</code></pre>
            </article>
            
            <article class="function" data-name="Scale">
               <h3>
                  Scale 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Scale multiplies all sample values in a profile by a constant.</p>
               
               <pre><code>func (p *Profile) Scale(ratio float64)</code></pre>
            </article>
            
            <article class="function" data-name="ScaleN">
               <h3>
                  ScaleN 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScaleN multiplies each sample values in a sample by a different amount.</p>
               
               <pre><code>func (p *Profile) ScaleN(ratios []float64) error</code></pre>
            </article>
            
            <article class="function" data-name="Sort">
               <h3>
                  Sort 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Sort returns a slice of the edges in the map, in a consistent
order. The sort order is first based on the edge weight
(higher-to-lower) and then by the node names to avoid flakiness.</p>
               
               <pre><code>func (em EdgeMap) Sort() []*Edge</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Print dumps a text representation of a profile. Intended mainly
for debugging purposes.</p>
               
               <pre><code>func (p *Profile) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a text representation of a graph, for debugging purposes.</p>
               
               <pre><code>func (g *Graph) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Sum returns the total weight for a set of nodes.</p>
               
               <pre><code>func (em EdgeMap) Sum() int64</code></pre>
            </article>
            
            <article class="function" data-name="Sum">
               <h3>
                  Sum 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Sum adds the flat and cum values of a set of nodes.</p>
               
               <pre><code>func (ns Nodes) Sum() (flat int64, cum int64)</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (el edgeList) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="WeightValue">
               <h3>
                  WeightValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WeightValue returns the weight value for this edge, normalizing if a
divisor is available.</p>
               
               <pre><code>func (e *Edge) WeightValue() int64</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write writes the profile as a gzip-compressed marshaled protobuf.</p>
               
               <pre><code>func (p *Profile) Write(w io.Writer) error</code></pre>
            </article>
            
            <article class="function" data-name="abs64">
               <h3>
                  abs64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func abs64(i int64) int64</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *locationMap) add(id uint64, n Nodes)</code></pre>
            </article>
            
            <article class="function" data-name="addSample">
               <h3>
                  addSample 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *Node) addSample(dw int64, w int64, flat bool)</code></pre>
            </article>
            
            <article class="function" data-name="addString">
               <h3>
                  addString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addString(strings map[string]int, s string) int64</code></pre>
            </article>
            
            <article class="function" data-name="checkType">
               <h3>
                  checkType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkType(b *buffer, typ int) error</code></pre>
            </article>
            
            <article class="function" data-name="combineHeaders">
               <h3>
                  combineHeaders 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>combineHeaders checks that all profiles can be merged and returns
their combined profile.</p>
               
               <pre><code>func combineHeaders(srcs []*Profile) (*Profile, error)</code></pre>
            </article>
            
            <article class="function" data-name="compatible">
               <h3>
                  compatible 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>compatible determines if two profiles can be compared/merged.
returns nil if the profiles are compatible; otherwise an error with
details on the incompatibility.</p>
               
               <pre><code>func (p *Profile) compatible(pb *Profile) error</code></pre>
            </article>
            
            <article class="function" data-name="compatibleValueTypes">
               <h3>
                  compatibleValueTypes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func compatibleValueTypes(v1 *ValueType, v2 *ValueType) bool</code></pre>
            </article>
            
            <article class="function" data-name="decodeBool">
               <h3>
                  decodeBool 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeBool(b *buffer, x *bool) error</code></pre>
            </article>
            
            <article class="function" data-name="decodeField">
               <h3>
                  decodeField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeField(b *buffer, data []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="decodeInt64">
               <h3>
                  decodeInt64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeInt64(b *buffer, x *int64) error</code></pre>
            </article>
            
            <article class="function" data-name="decodeInt64s">
               <h3>
                  decodeInt64s 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeInt64s(b *buffer, x *[]int64) error</code></pre>
            </article>
            
            <article class="function" data-name="decodeMessage">
               <h3>
                  decodeMessage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeMessage(b *buffer, m message) error</code></pre>
            </article>
            
            <article class="function" data-name="decodeString">
               <h3>
                  decodeString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeString(b *buffer, x *string) error</code></pre>
            </article>
            
            <article class="function" data-name="decodeStrings">
               <h3>
                  decodeStrings 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeStrings(b *buffer, x *[]string) error</code></pre>
            </article>
            
            <article class="function" data-name="decodeUint64">
               <h3>
                  decodeUint64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeUint64(b *buffer, x *uint64) error</code></pre>
            </article>
            
            <article class="function" data-name="decodeUint64s">
               <h3>
                  decodeUint64s 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeUint64s(b *buffer, x *[]uint64) error</code></pre>
            </article>
            
            <article class="function" data-name="decodeVarint">
               <h3>
                  decodeVarint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func decodeVarint(data []byte) (uint64, []byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="decoder">
               <h3>
                  decoder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Mapping) decoder() []decoder</code></pre>
            </article>
            
            <article class="function" data-name="decoder">
               <h3>
                  decoder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Profile) decoder() []decoder</code></pre>
            </article>
            
            <article class="function" data-name="decoder">
               <h3>
                  decoder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *ValueType) decoder() []decoder</code></pre>
            </article>
            
            <article class="function" data-name="decoder">
               <h3>
                  decoder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Sample) decoder() []decoder</code></pre>
            </article>
            
            <article class="function" data-name="decoder">
               <h3>
                  decoder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Label) decoder() []decoder</code></pre>
            </article>
            
            <article class="function" data-name="decoder">
               <h3>
                  decoder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Location) decoder() []decoder</code></pre>
            </article>
            
            <article class="function" data-name="decoder">
               <h3>
                  decoder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Line) decoder() []decoder</code></pre>
            </article>
            
            <article class="function" data-name="decoder">
               <h3>
                  decoder 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Function) decoder() []decoder</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *ValueType) encode(b *buffer)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Label) encode(b *buffer)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Location) encode(b *buffer)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Line) encode(b *buffer)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Mapping) encode(b *buffer)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Profile) encode(b *buffer)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Function) encode(b *buffer)</code></pre>
            </article>
            
            <article class="function" data-name="encode">
               <h3>
                  encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *Sample) encode(b *buffer)</code></pre>
            </article>
            
            <article class="function" data-name="encodeBool">
               <h3>
                  encodeBool 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeBool(b *buffer, tag int, x bool)</code></pre>
            </article>
            
            <article class="function" data-name="encodeBoolOpt">
               <h3>
                  encodeBoolOpt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeBoolOpt(b *buffer, tag int, x bool)</code></pre>
            </article>
            
            <article class="function" data-name="encodeInt64">
               <h3>
                  encodeInt64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeInt64(b *buffer, tag int, x int64)</code></pre>
            </article>
            
            <article class="function" data-name="encodeInt64Opt">
               <h3>
                  encodeInt64Opt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeInt64Opt(b *buffer, tag int, x int64)</code></pre>
            </article>
            
            <article class="function" data-name="encodeInt64s">
               <h3>
                  encodeInt64s 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeInt64s(b *buffer, tag int, x []int64)</code></pre>
            </article>
            
            <article class="function" data-name="encodeLength">
               <h3>
                  encodeLength 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeLength(b *buffer, tag int, len int)</code></pre>
            </article>
            
            <article class="function" data-name="encodeMessage">
               <h3>
                  encodeMessage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeMessage(b *buffer, tag int, m message)</code></pre>
            </article>
            
            <article class="function" data-name="encodeString">
               <h3>
                  encodeString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeString(b *buffer, tag int, x string)</code></pre>
            </article>
            
            <article class="function" data-name="encodeStrings">
               <h3>
                  encodeStrings 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeStrings(b *buffer, tag int, x []string)</code></pre>
            </article>
            
            <article class="function" data-name="encodeUint64">
               <h3>
                  encodeUint64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeUint64(b *buffer, tag int, x uint64)</code></pre>
            </article>
            
            <article class="function" data-name="encodeUint64Opt">
               <h3>
                  encodeUint64Opt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeUint64Opt(b *buffer, tag int, x uint64)</code></pre>
            </article>
            
            <article class="function" data-name="encodeUint64s">
               <h3>
                  encodeUint64s 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeUint64s(b *buffer, tag int, x []uint64)</code></pre>
            </article>
            
            <article class="function" data-name="encodeVarint">
               <h3>
                  encodeVarint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func encodeVarint(b *buffer, x uint64)</code></pre>
            </article>
            
            <article class="function" data-name="equalValueType">
               <h3>
                  equalValueType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>equalValueType returns true if the two value types are semantically
equal. It ignores the internal fields used during encode/decode.</p>
               
               <pre><code>func equalValueType(st1 *ValueType, st2 *ValueType) bool</code></pre>
            </article>
            
            <article class="function" data-name="findOrInsertLine">
               <h3>
                  findOrInsertLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (nm NodeMap) findOrInsertLine(l *Location, li Line, o *Options) *Node</code></pre>
            </article>
            
            <article class="function" data-name="focusedSample">
               <h3>
                  focusedSample 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>focusedSample checks a sample against focus and ignore regexps.
Returns whether the focus/ignore regexps match any tags.</p>
               
               <pre><code>func focusedSample(s *Sample, focus TagMatch, ignore TagMatch) (fm bool, im bool)</code></pre>
            </article>
            
            <article class="function" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l locationMap) get(id uint64) Nodes</code></pre>
            </article>
            
            <article class="function" data-name="getString">
               <h3>
                  getString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func getString(strings []string, strng *int64, err error) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="isNegative">
               <h3>
                  isNegative 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isNegative returns true if the node is considered as "negative" for the
purposes of drop_negative.</p>
               
               <pre><code>func isNegative(n *Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="isZeroSample">
               <h3>
                  isZeroSample 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isZeroSample(s *Sample) bool</code></pre>
            </article>
            
            <article class="function" data-name="key">
               <h3>
                  key 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>key generates locationKey to be used as a key for maps.</p>
               
               <pre><code>func (l *Location) key() locationKey</code></pre>
            </article>
            
            <article class="function" data-name="key">
               <h3>
                  key 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>key generates encoded strings of Mapping to be used as a key for
maps.</p>
               
               <pre><code>func (m *Mapping) key() mappingKey</code></pre>
            </article>
            
            <article class="function" data-name="key">
               <h3>
                  key 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>key generates sampleKey to be used as a key for maps.</p>
               
               <pre><code>func (sample *Sample) key() sampleKey</code></pre>
            </article>
            
            <article class="function" data-name="key">
               <h3>
                  key 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>key generates a struct to be used as a key for maps.</p>
               
               <pre><code>func (f *Function) key() functionKey</code></pre>
            </article>
            
            <article class="function" data-name="le32">
               <h3>
                  le32 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func le32(p []byte) uint32</code></pre>
            </article>
            
            <article class="function" data-name="le64">
               <h3>
                  le64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func le64(p []byte) uint64</code></pre>
            </article>
            
            <article class="function" data-name="mapFunction">
               <h3>
                  mapFunction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pm *profileMerger) mapFunction(src *Function) *Function</code></pre>
            </article>
            
            <article class="function" data-name="mapLine">
               <h3>
                  mapLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pm *profileMerger) mapLine(src Line) Line</code></pre>
            </article>
            
            <article class="function" data-name="mapLocation">
               <h3>
                  mapLocation 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pm *profileMerger) mapLocation(src *Location) *Location</code></pre>
            </article>
            
            <article class="function" data-name="mapMapping">
               <h3>
                  mapMapping 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pm *profileMerger) mapMapping(src *Mapping) mapInfo</code></pre>
            </article>
            
            <article class="function" data-name="mapSample">
               <h3>
                  mapSample 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (pm *profileMerger) mapSample(src *Sample) *Sample</code></pre>
            </article>
            
            <article class="function" data-name="marshal">
               <h3>
                  marshal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func marshal(m message) []byte</code></pre>
            </article>
            
            <article class="function" data-name="nodeInfo">
               <h3>
                  nodeInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func nodeInfo(l *Location, line Line, objfile string, o *Options) *NodeInfo</code></pre>
            </article>
            
            <article class="function" data-name="nodes">
               <h3>
                  nodes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (nm NodeMap) nodes() Nodes</code></pre>
            </article>
            
            <article class="function" data-name="parseUncompressed">
               <h3>
                  parseUncompressed 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseUncompressed(data []byte) (*Profile, error)</code></pre>
            </article>
            
            <article class="function" data-name="postDecode">
               <h3>
                  postDecode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>postDecode takes the unexported fields populated by decode (with
suffix X) and populates the corresponding exported fields.
The unexported fields are cleared up to facilitate testing.</p>
               
               <pre><code>func (p *Profile) postDecode() error</code></pre>
            </article>
            
            <article class="function" data-name="preEncode">
               <h3>
                  preEncode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>preEncode populates the unexported fields to be used by encode
(with suffix X) from the corresponding exported fields. The
exported fields are cleared up to facilitate testing.</p>
               
               <pre><code>func (p *Profile) preEncode()</code></pre>
            </article>
            
            <article class="function" data-name="selectNodesForGraph">
               <h3>
                  selectNodesForGraph 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func selectNodesForGraph(nodes Nodes, dropNegative bool) *Graph</code></pre>
            </article>
            
            <article class="function" data-name="unmarshal">
               <h3>
                  unmarshal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func unmarshal(data []byte, m message) (err error)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
