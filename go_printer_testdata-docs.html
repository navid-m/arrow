<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - parser</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>parser</code>
         </h1>
         <hr />
         
         <article class="global" data-name="PackageClauseOnly">
            <h2>PackageClauseOnly</h2>
            <hr />
            
            <p>The mode parameter to the Parse* functions is a set of flags (or 0).
They control the amount of source code parsed and other optional
parser functionality.</p>
            
            <pre><code>PackageClauseOnly uint</code></pre>
         </article>
         
         <article class="global" data-name="ImportsOnly">
            <h2>ImportsOnly</h2>
            <hr />
            
            <p>The mode parameter to the Parse* functions is a set of flags (or 0).
They control the amount of source code parsed and other optional
parser functionality.</p>
            
            <pre><code>ImportsOnly</code></pre>
         </article>
         
         <article class="global" data-name="ParseComments">
            <h2>ParseComments</h2>
            <hr />
            
            <p>The mode parameter to the Parse* functions is a set of flags (or 0).
They control the amount of source code parsed and other optional
parser functionality.</p>
            
            <pre><code>ParseComments</code></pre>
         </article>
         
         <article class="global" data-name="Trace">
            <h2>Trace</h2>
            <hr />
            
            <p>The mode parameter to the Parse* functions is a set of flags (or 0).
They control the amount of source code parsed and other optional
parser functionality.</p>
            
            <pre><code>Trace</code></pre>
         </article>
         
         <article class="global" data-name="DeclarationErrors">
            <h2>DeclarationErrors</h2>
            <hr />
            
            <p>The mode parameter to the Parse* functions is a set of flags (or 0).
They control the amount of source code parsed and other optional
parser functionality.</p>
            
            <pre><code>DeclarationErrors</code></pre>
         </article>
         
         <article class="global" data-name="unresolved">
            <h2>unresolved</h2>
            <hr />
            
            <p>The unresolved object is a sentinel to mark identifiers that have been added
to the list of unresolved identifiers. The sentinel is only used for verifying
internal consistency.</p>
            
            <pre><code>unresolved</code></pre>
         </article>
          
         <article class="struct" data-name="parser">
            <h2>type parser struct</h2>
            <hr />
            
            <p>The parser structure holds the parser's internal state.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">file *token.File
scanner.ErrorVector
scanner scanner.Scanner
mode uint
trace bool
indent uint
comments []*ast.CommentGroup
leadComment *ast.CommentGroup
lineComment *ast.CommentGroup
pos token.Pos
tok token.Token
lit string
exprLev int
pkgScope *ast.Scope
topScope *ast.Scope
unresolved []*ast.Ident
imports []*ast.ImportSpec
labelScope *ast.Scope
targetStack [][]*ast.Ident</code></pre>
         </article>
          
         <article class="function" data-name="scannerMode">
            <h2>scannerMode</h2>
            <hr />
            
            <p>scannerMode returns the scanner mode bits given the parser's mode bits.</p>
            
            <pre><code>func scannerMode(mode uint) uint</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init(fset *token.FileSet, filename string, src []byte, mode uint)</code></pre>
         </article>
         
         <article class="function" data-name="openScope">
            <h2>openScope</h2>
            <hr />
            
            <pre><code>func openScope()</code></pre>
         </article>
         
         <article class="function" data-name="closeScope">
            <h2>closeScope</h2>
            <hr />
            
            <pre><code>func closeScope()</code></pre>
         </article>
         
         <article class="function" data-name="openLabelScope">
            <h2>openLabelScope</h2>
            <hr />
            
            <pre><code>func openLabelScope()</code></pre>
         </article>
         
         <article class="function" data-name="closeLabelScope">
            <h2>closeLabelScope</h2>
            <hr />
            
            <pre><code>func closeLabelScope()</code></pre>
         </article>
         
         <article class="function" data-name="declare">
            <h2>declare</h2>
            <hr />
            
            <pre><code>func declare(decl any, scope *ast.Scope, kind ast.ObjKind, idents ...*ast.Ident)</code></pre>
         </article>
         
         <article class="function" data-name="shortVarDecl">
            <h2>shortVarDecl</h2>
            <hr />
            
            <pre><code>func shortVarDecl(idents []*ast.Ident)</code></pre>
         </article>
         
         <article class="function" data-name="resolve">
            <h2>resolve</h2>
            <hr />
            
            <pre><code>func resolve(x ast.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="printTrace">
            <h2>printTrace</h2>
            <hr />
            
            <pre><code>func printTrace(a ...any)</code></pre>
         </article>
         
         <article class="function" data-name="trace">
            <h2>trace</h2>
            <hr />
            
            <pre><code>func trace(p *parser, msg string) *parser</code></pre>
         </article>
         
         <article class="function" data-name="un">
            <h2>un</h2>
            <hr />
            
            <p>Usage pattern: defer un(trace(p, "..."));</p>
            
            <pre><code>func un(p *parser)</code></pre>
         </article>
         
         <article class="function" data-name="next0">
            <h2>next0</h2>
            <hr />
            
            <p>Advance to the next token.</p>
            
            <pre><code>func next0()</code></pre>
         </article>
         
         <article class="function" data-name="consumeComment">
            <h2>consumeComment</h2>
            <hr />
            
            <p>Consume a comment and return it and the line on which it ends.</p>
            
            <pre><code>func consumeComment() (comment *ast.Comment, endline int)</code></pre>
         </article>
         
         <article class="function" data-name="consumeCommentGroup">
            <h2>consumeCommentGroup</h2>
            <hr />
            
            <p>Consume a group of adjacent comments, add it to the parser's
comments list, and return it together with the line at which
the last comment in the group ends. An empty line or non-comment
token terminates a comment group.</p>
            
            <pre><code>func consumeCommentGroup() (comments *ast.CommentGroup, endline int)</code></pre>
         </article>
         
         <article class="function" data-name="next">
            <h2>next</h2>
            <hr />
            
            <p>Advance to the next non-comment token. In the process, collect
any comment groups encountered, and remember the last lead and
line comments.

A lead comment is a comment group that starts and ends in a
line without any other tokens and that is followed by a non-comment
token on the line immediately after the comment group.

A line comment is a comment group that follows a non-comment
token on the same line, and that has no tokens after it on the line
where it ends.

Lead and line comments may be considered documentation that is
stored in the AST.</p>
            
            <pre><code>func next()</code></pre>
         </article>
         
         <article class="function" data-name="error">
            <h2>error</h2>
            <hr />
            
            <pre><code>func error(pos token.Pos, msg string)</code></pre>
         </article>
         
         <article class="function" data-name="errorExpected">
            <h2>errorExpected</h2>
            <hr />
            
            <pre><code>func errorExpected(pos token.Pos, msg string)</code></pre>
         </article>
         
         <article class="function" data-name="expect">
            <h2>expect</h2>
            <hr />
            
            <pre><code>func expect(tok token.Token) token.Pos</code></pre>
         </article>
         
         <article class="function" data-name="expectSemi">
            <h2>expectSemi</h2>
            <hr />
            
            <pre><code>func expectSemi()</code></pre>
         </article>
         
         <article class="function" data-name="assert">
            <h2>assert</h2>
            <hr />
            
            <pre><code>func assert(cond bool, msg string)</code></pre>
         </article>
         
         <article class="function" data-name="parseIdent">
            <h2>parseIdent</h2>
            <hr />
            
            <pre><code>func parseIdent() *ast.Ident</code></pre>
         </article>
         
         <article class="function" data-name="parseIdentList">
            <h2>parseIdentList</h2>
            <hr />
            
            <pre><code>func parseIdentList() list []*ast.Ident</code></pre>
         </article>
         
         <article class="function" data-name="parseExprList">
            <h2>parseExprList</h2>
            <hr />
            
            <p>If lhs is set, result list elements which are identifiers are not resolved.</p>
            
            <pre><code>func parseExprList(lhs bool) list []ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseLhsList">
            <h2>parseLhsList</h2>
            <hr />
            
            <pre><code>func parseLhsList() []ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseRhsList">
            <h2>parseRhsList</h2>
            <hr />
            
            <pre><code>func parseRhsList() []ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseType">
            <h2>parseType</h2>
            <hr />
            
            <pre><code>func parseType() ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseTypeName">
            <h2>parseTypeName</h2>
            <hr />
            
            <p>If the result is an identifier, it is not resolved.</p>
            
            <pre><code>func parseTypeName() ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseArrayType">
            <h2>parseArrayType</h2>
            <hr />
            
            <pre><code>func parseArrayType(ellipsisOk bool) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="makeIdentList">
            <h2>makeIdentList</h2>
            <hr />
            
            <pre><code>func makeIdentList(list []ast.Expr) []*ast.Ident</code></pre>
         </article>
         
         <article class="function" data-name="parseFieldDecl">
            <h2>parseFieldDecl</h2>
            <hr />
            
            <pre><code>func parseFieldDecl(scope *ast.Scope) *ast.Field</code></pre>
         </article>
         
         <article class="function" data-name="parseStructType">
            <h2>parseStructType</h2>
            <hr />
            
            <pre><code>func parseStructType() *ast.StructType</code></pre>
         </article>
         
         <article class="function" data-name="parsePointerType">
            <h2>parsePointerType</h2>
            <hr />
            
            <pre><code>func parsePointerType() *ast.StarExpr</code></pre>
         </article>
         
         <article class="function" data-name="tryVarType">
            <h2>tryVarType</h2>
            <hr />
            
            <pre><code>func tryVarType(isParam bool) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseVarType">
            <h2>parseVarType</h2>
            <hr />
            
            <pre><code>func parseVarType(isParam bool) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseVarList">
            <h2>parseVarList</h2>
            <hr />
            
            <pre><code>func parseVarList(isParam bool) (list []ast.Expr, typ ast.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="parseParameterList">
            <h2>parseParameterList</h2>
            <hr />
            
            <pre><code>func parseParameterList(scope *ast.Scope, ellipsisOk bool) params []*ast.Field</code></pre>
         </article>
         
         <article class="function" data-name="parseParameters">
            <h2>parseParameters</h2>
            <hr />
            
            <pre><code>func parseParameters(scope *ast.Scope, ellipsisOk bool) *ast.FieldList</code></pre>
         </article>
         
         <article class="function" data-name="parseResult">
            <h2>parseResult</h2>
            <hr />
            
            <pre><code>func parseResult(scope *ast.Scope) *ast.FieldList</code></pre>
         </article>
         
         <article class="function" data-name="parseSignature">
            <h2>parseSignature</h2>
            <hr />
            
            <pre><code>func parseSignature(scope *ast.Scope) (params *ast.FieldList, results *ast.FieldList)</code></pre>
         </article>
         
         <article class="function" data-name="parseFuncType">
            <h2>parseFuncType</h2>
            <hr />
            
            <pre><code>func parseFuncType() (*ast.FuncType, *ast.Scope)</code></pre>
         </article>
         
         <article class="function" data-name="parseMethodSpec">
            <h2>parseMethodSpec</h2>
            <hr />
            
            <pre><code>func parseMethodSpec(scope *ast.Scope) *ast.Field</code></pre>
         </article>
         
         <article class="function" data-name="parseInterfaceType">
            <h2>parseInterfaceType</h2>
            <hr />
            
            <pre><code>func parseInterfaceType() *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="parseMapType">
            <h2>parseMapType</h2>
            <hr />
            
            <pre><code>func parseMapType() *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="parseChanType">
            <h2>parseChanType</h2>
            <hr />
            
            <pre><code>func parseChanType() *ast.ChanType</code></pre>
         </article>
         
         <article class="function" data-name="tryIdentOrType">
            <h2>tryIdentOrType</h2>
            <hr />
            
            <p>If the result is an identifier, it is not resolved.</p>
            
            <pre><code>func tryIdentOrType(ellipsisOk bool) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="tryType">
            <h2>tryType</h2>
            <hr />
            
            <pre><code>func tryType() ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseStmtList">
            <h2>parseStmtList</h2>
            <hr />
            
            <pre><code>func parseStmtList() list []ast.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="parseBody">
            <h2>parseBody</h2>
            <hr />
            
            <pre><code>func parseBody(scope *ast.Scope) *ast.BlockStmt</code></pre>
         </article>
         
         <article class="function" data-name="parseBlockStmt">
            <h2>parseBlockStmt</h2>
            <hr />
            
            <pre><code>func parseBlockStmt() *ast.BlockStmt</code></pre>
         </article>
         
         <article class="function" data-name="parseFuncTypeOrLit">
            <h2>parseFuncTypeOrLit</h2>
            <hr />
            
            <pre><code>func parseFuncTypeOrLit() ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseOperand">
            <h2>parseOperand</h2>
            <hr />
            
            <p>parseOperand may return an expression or a raw type (incl. array
types of the form [...]T. Callers must verify the result.
If lhs is set and the result is an identifier, it is not resolved.</p>
            
            <pre><code>func parseOperand(lhs bool) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseSelector">
            <h2>parseSelector</h2>
            <hr />
            
            <pre><code>func parseSelector(x ast.Expr) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseTypeAssertion">
            <h2>parseTypeAssertion</h2>
            <hr />
            
            <pre><code>func parseTypeAssertion(x ast.Expr) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseIndexOrSlice">
            <h2>parseIndexOrSlice</h2>
            <hr />
            
            <pre><code>func parseIndexOrSlice(x ast.Expr) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseCallOrConversion">
            <h2>parseCallOrConversion</h2>
            <hr />
            
            <pre><code>func parseCallOrConversion(fun ast.Expr) *ast.CallExpr</code></pre>
         </article>
         
         <article class="function" data-name="parseElement">
            <h2>parseElement</h2>
            <hr />
            
            <pre><code>func parseElement(keyOk bool) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseElementList">
            <h2>parseElementList</h2>
            <hr />
            
            <pre><code>func parseElementList() list []ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseLiteralValue">
            <h2>parseLiteralValue</h2>
            <hr />
            
            <pre><code>func parseLiteralValue(typ ast.Expr) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="checkExpr">
            <h2>checkExpr</h2>
            <hr />
            
            <p>checkExpr checks that x is an expression (and not a type).</p>
            
            <pre><code>func checkExpr(x ast.Expr) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="isTypeName">
            <h2>isTypeName</h2>
            <hr />
            
            <p>isTypeName reports whether x is a (qualified) TypeName.</p>
            
            <pre><code>func isTypeName(x ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="isLiteralType">
            <h2>isLiteralType</h2>
            <hr />
            
            <p>isLiteralType reports whether x is a legal composite literal type.</p>
            
            <pre><code>func isLiteralType(x ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="deref">
            <h2>deref</h2>
            <hr />
            
            <p>If x is of the form *T, deref returns T, otherwise it returns x.</p>
            
            <pre><code>func deref(x ast.Expr) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="checkExprOrType">
            <h2>checkExprOrType</h2>
            <hr />
            
            <p>checkExprOrType checks that x is an expression or a type
(and not a raw type such as [...]T).</p>
            
            <pre><code>func checkExprOrType(x ast.Expr) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parsePrimaryExpr">
            <h2>parsePrimaryExpr</h2>
            <hr />
            
            <p>If lhs is set and the result is an identifier, it is not resolved.</p>
            
            <pre><code>func parsePrimaryExpr(lhs bool) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseUnaryExpr">
            <h2>parseUnaryExpr</h2>
            <hr />
            
            <p>If lhs is set and the result is an identifier, it is not resolved.</p>
            
            <pre><code>func parseUnaryExpr(lhs bool) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseBinaryExpr">
            <h2>parseBinaryExpr</h2>
            <hr />
            
            <p>If lhs is set and the result is an identifier, it is not resolved.</p>
            
            <pre><code>func parseBinaryExpr(lhs bool, prec1 int) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseExpr">
            <h2>parseExpr</h2>
            <hr />
            
            <p>If lhs is set and the result is an identifier, it is not resolved.
TODO(gri): parseExpr may return a type or even a raw type ([..]int) -
should reject when a type/raw type is obviously not allowed</p>
            
            <pre><code>func parseExpr(lhs bool) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseRhs">
            <h2>parseRhs</h2>
            <hr />
            
            <pre><code>func parseRhs() ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseSimpleStmt">
            <h2>parseSimpleStmt</h2>
            <hr />
            
            <pre><code>func parseSimpleStmt(labelOk bool) ast.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="parseCallExpr">
            <h2>parseCallExpr</h2>
            <hr />
            
            <pre><code>func parseCallExpr() *ast.CallExpr</code></pre>
         </article>
         
         <article class="function" data-name="parseGoStmt">
            <h2>parseGoStmt</h2>
            <hr />
            
            <pre><code>func parseGoStmt() ast.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="parseDeferStmt">
            <h2>parseDeferStmt</h2>
            <hr />
            
            <pre><code>func parseDeferStmt() ast.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="parseReturnStmt">
            <h2>parseReturnStmt</h2>
            <hr />
            
            <pre><code>func parseReturnStmt() *ast.ReturnStmt</code></pre>
         </article>
         
         <article class="function" data-name="parseBranchStmt">
            <h2>parseBranchStmt</h2>
            <hr />
            
            <pre><code>func parseBranchStmt(tok token.Token) *ast.BranchStmt</code></pre>
         </article>
         
         <article class="function" data-name="makeExpr">
            <h2>makeExpr</h2>
            <hr />
            
            <pre><code>func makeExpr(s ast.Stmt) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseIfStmt">
            <h2>parseIfStmt</h2>
            <hr />
            
            <pre><code>func parseIfStmt() *ast.IfStmt</code></pre>
         </article>
         
         <article class="function" data-name="parseTypeList">
            <h2>parseTypeList</h2>
            <hr />
            
            <pre><code>func parseTypeList() list []ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="parseCaseClause">
            <h2>parseCaseClause</h2>
            <hr />
            
            <pre><code>func parseCaseClause(exprSwitch bool) *ast.CaseClause</code></pre>
         </article>
         
         <article class="function" data-name="isExprSwitch">
            <h2>isExprSwitch</h2>
            <hr />
            
            <pre><code>func isExprSwitch(s ast.Stmt) bool</code></pre>
         </article>
         
         <article class="function" data-name="parseSwitchStmt">
            <h2>parseSwitchStmt</h2>
            <hr />
            
            <pre><code>func parseSwitchStmt() ast.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="parseCommClause">
            <h2>parseCommClause</h2>
            <hr />
            
            <pre><code>func parseCommClause() *ast.CommClause</code></pre>
         </article>
         
         <article class="function" data-name="parseSelectStmt">
            <h2>parseSelectStmt</h2>
            <hr />
            
            <pre><code>func parseSelectStmt() *ast.SelectStmt</code></pre>
         </article>
         
         <article class="function" data-name="parseForStmt">
            <h2>parseForStmt</h2>
            <hr />
            
            <pre><code>func parseForStmt() ast.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="parseStmt">
            <h2>parseStmt</h2>
            <hr />
            
            <pre><code>func parseStmt() s ast.Stmt</code></pre>
         </article>
         
         <article class="function" data-name="parseImportSpec">
            <h2>parseImportSpec</h2>
            <hr />
            
            <pre><code>func parseImportSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec</code></pre>
         </article>
         
         <article class="function" data-name="parseConstSpec">
            <h2>parseConstSpec</h2>
            <hr />
            
            <pre><code>func parseConstSpec(p *parser, doc *ast.CommentGroup, iota int) ast.Spec</code></pre>
         </article>
         
         <article class="function" data-name="parseTypeSpec">
            <h2>parseTypeSpec</h2>
            <hr />
            
            <pre><code>func parseTypeSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec</code></pre>
         </article>
         
         <article class="function" data-name="parseVarSpec">
            <h2>parseVarSpec</h2>
            <hr />
            
            <pre><code>func parseVarSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec</code></pre>
         </article>
         
         <article class="function" data-name="parseGenDecl">
            <h2>parseGenDecl</h2>
            <hr />
            
            <pre><code>func parseGenDecl(keyword token.Token, f parseSpecFunction) *ast.GenDecl</code></pre>
         </article>
         
         <article class="function" data-name="parseReceiver">
            <h2>parseReceiver</h2>
            <hr />
            
            <pre><code>func parseReceiver(scope *ast.Scope) *ast.FieldList</code></pre>
         </article>
         
         <article class="function" data-name="parseFuncDecl">
            <h2>parseFuncDecl</h2>
            <hr />
            
            <pre><code>func parseFuncDecl() *ast.FuncDecl</code></pre>
         </article>
         
         <article class="function" data-name="parseDecl">
            <h2>parseDecl</h2>
            <hr />
            
            <pre><code>func parseDecl() ast.Decl</code></pre>
         </article>
         
         <article class="function" data-name="parseDeclList">
            <h2>parseDeclList</h2>
            <hr />
            
            <pre><code>func parseDeclList() list []ast.Decl</code></pre>
         </article>
         
         <article class="function" data-name="parseFile">
            <h2>parseFile</h2>
            <hr />
            
            <pre><code>func parseFile() *ast.File</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
