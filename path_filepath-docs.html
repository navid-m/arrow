<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - filepath</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>filepath</code>
         </h1>
         <hr />
         
         <article class="global" data-name="LstatP">
            <h2>LstatP</h2>
            <hr />
            
            <pre><code>LstatP</code></pre>
         </article>
         
         <article class="global" data-name="ToNorm">
            <h2>ToNorm</h2>
            <hr />
            
            <pre><code>ToNorm</code></pre>
         </article>
         
         <article class="global" data-name="NormBase">
            <h2>NormBase</h2>
            <hr />
            
            <pre><code>NormBase</code></pre>
         </article>
         
         <article class="global" data-name="ErrBadPattern">
            <h2>ErrBadPattern</h2>
            <hr />
            
            <p>ErrBadPattern indicates a pattern was malformed.</p>
            
            <pre><code>ErrBadPattern</code></pre>
         </article>
         
         <article class="global" data-name="Separator">
            <h2>Separator</h2>
            <hr />
            
            <pre><code>Separator</code></pre>
         </article>
         
         <article class="global" data-name="ListSeparator">
            <h2>ListSeparator</h2>
            <hr />
            
            <pre><code>ListSeparator</code></pre>
         </article>
         
         <article class="global" data-name="SkipDir">
            <h2>SkipDir</h2>
            <hr />
            
            <p>SkipDir is used as a return value from [WalkFunc] to indicate that
the directory named in the call is to be skipped. It is not returned
as an error by any function.</p>
            
            <pre><code>SkipDir error</code></pre>
         </article>
         
         <article class="global" data-name="SkipAll">
            <h2>SkipAll</h2>
            <hr />
            
            <p>SkipAll is used as a return value from [WalkFunc] to indicate that
all remaining files and directories are to be skipped. It is not returned
as an error by any function.</p>
            
            <pre><code>SkipAll error</code></pre>
         </article>
         
         <article class="global" data-name="lstat">
            <h2>lstat</h2>
            <hr />
            
            <pre><code>lstat</code></pre>
         </article>
           
         <article class="function" data-name="HasPrefix">
            <h2>HasPrefix</h2>
            <hr />
            
            <p>HasPrefix exists for historical compatibility and should not be used.

Deprecated: HasPrefix does not respect path boundaries and
does not ignore case when required.</p>
            
            <pre><code>func HasPrefix(p string, prefix string) bool</code></pre>
         </article>
         
         <article class="function" data-name="splitList">
            <h2>splitList</h2>
            <hr />
            
            <pre><code>func splitList(path string) []string</code></pre>
         </article>
         
         <article class="function" data-name="abs">
            <h2>abs</h2>
            <hr />
            
            <pre><code>func abs(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="join">
            <h2>join</h2>
            <hr />
            
            <pre><code>func join(elem []string) string</code></pre>
         </article>
         
         <article class="function" data-name="sameWord">
            <h2>sameWord</h2>
            <hr />
            
            <pre><code>func sameWord(a string, b string) bool</code></pre>
         </article>
         
         <article class="function" data-name="evalSymlinks">
            <h2>evalSymlinks</h2>
            <hr />
            
            <pre><code>func evalSymlinks(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="normVolumeName">
            <h2>normVolumeName</h2>
            <hr />
            
            <p>normVolumeName is like VolumeName, but makes drive letter upper case.
result of EvalSymlinks must be unique, so we have
EvalSymlinks(`c:\a`) == EvalSymlinks(`C:\a`).</p>
            
            <pre><code>func normVolumeName(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="normBase">
            <h2>normBase</h2>
            <hr />
            
            <p>normBase returns the last element of path with correct case.</p>
            
            <pre><code>func normBase(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="baseIsDotDot">
            <h2>baseIsDotDot</h2>
            <hr />
            
            <p>baseIsDotDot reports whether the last element of path is "..".
The given path should be 'Clean'-ed in advance.</p>
            
            <pre><code>func baseIsDotDot(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="toNorm">
            <h2>toNorm</h2>
            <hr />
            
            <p>toNorm returns the normalized path that is guaranteed to be unique.
It should accept the following formats:
  - UNC paths                              (e.g \\server\share\foo\bar)
  - absolute paths                         (e.g C:\foo\bar)
  - relative paths begin with drive letter (e.g C:foo\bar, C:..\foo\bar, C:.., C:.)
  - relative paths begin with '\'          (e.g \foo\bar)
  - relative paths begin without '\'       (e.g foo\bar, ..\foo\bar, .., .)

The returned normalized path will be in the same form (of 5 listed above) as the input path.
If two paths A and B are indicating the same file with the same format, toNorm(A) should be equal to toNorm(B).
The normBase parameter should be equal to the normBase func, except for in tests.  See docs on the normBase func.</p>
            
            <pre><code>func toNorm(path string, normBase func) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="evalSymlinks">
            <h2>evalSymlinks</h2>
            <hr />
            
            <pre><code>func evalSymlinks(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Match">
            <h2>Match</h2>
            <hr />
            
            <p>Match reports whether name matches the shell file name pattern.
The pattern syntax is:

	pattern:
		{ term }
	term:
		'*'         matches any sequence of non-Separator characters
		'?'         matches any single non-Separator character
		'[' [ '^' ] { character-range } ']'
		            character class (must be non-empty)
		c           matches character c (c != '*', '?', '\\', '[')
		'\\' c      matches character c

	character-range:
		c           matches character c (c != '\\', '-', ']')
		'\\' c      matches character c
		lo '-' hi   matches character c for lo <= c <= hi

Match requires pattern to match all of name, not just a substring.
The only possible returned error is [ErrBadPattern], when pattern
is malformed.

On Windows, escaping is disabled. Instead, '\\' is treated as
path separator.</p>
            
            <pre><code>func Match(pattern string, name string) (matched bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="scanChunk">
            <h2>scanChunk</h2>
            <hr />
            
            <p>scanChunk gets the next segment of pattern, which is a non-star string
possibly preceded by a star.</p>
            
            <pre><code>func scanChunk(pattern string) (star bool, chunk string, rest string)</code></pre>
         </article>
         
         <article class="function" data-name="matchChunk">
            <h2>matchChunk</h2>
            <hr />
            
            <p>matchChunk checks whether chunk matches the beginning of s.
If so, it returns the remainder of s (after the match).
Chunk is all single-character operators: literals, char classes, and ?.</p>
            
            <pre><code>func matchChunk(chunk string, s string) (rest string, ok bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="getEsc">
            <h2>getEsc</h2>
            <hr />
            
            <p>getEsc gets a possibly-escaped character from chunk, for a character class.</p>
            
            <pre><code>func getEsc(chunk string) (r rune, nchunk string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Glob">
            <h2>Glob</h2>
            <hr />
            
            <p>Glob returns the names of all files matching pattern or nil
if there is no matching file. The syntax of patterns is the same
as in [Match]. The pattern may describe hierarchical names such as
/usr/*/bin/ed (assuming the [Separator] is '/').

Glob ignores file system errors such as I/O errors reading directories.
The only possible returned error is [ErrBadPattern], when pattern
is malformed.</p>
            
            <pre><code>func Glob(pattern string) (matches []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="globWithLimit">
            <h2>globWithLimit</h2>
            <hr />
            
            <pre><code>func globWithLimit(pattern string, depth int) (matches []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="cleanGlobPath">
            <h2>cleanGlobPath</h2>
            <hr />
            
            <p>cleanGlobPath prepares path for glob matching.</p>
            
            <pre><code>func cleanGlobPath(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="cleanGlobPathWindows">
            <h2>cleanGlobPathWindows</h2>
            <hr />
            
            <p>cleanGlobPathWindows is windows version of cleanGlobPath.</p>
            
            <pre><code>func cleanGlobPathWindows(path string) (prefixLen int, cleaned string)</code></pre>
         </article>
         
         <article class="function" data-name="glob">
            <h2>glob</h2>
            <hr />
            
            <p>glob searches for files matching pattern in the directory dir
and appends them to matches. If the directory cannot be
opened, it returns the existing matches. New matches are
added in lexicographical order.</p>
            
            <pre><code>func glob(dir string, pattern string, matches []string) (m []string, e error)</code></pre>
         </article>
         
         <article class="function" data-name="hasMeta">
            <h2>hasMeta</h2>
            <hr />
            
            <p>hasMeta reports whether path contains any of the magic characters
recognized by Match.</p>
            
            <pre><code>func hasMeta(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="Clean">
            <h2>Clean</h2>
            <hr />
            
            <p>Clean returns the shortest path name equivalent to path
by purely lexical processing. It applies the following rules
iteratively until no further processing can be done:

 1. Replace multiple [Separator] elements with a single one.
 2. Eliminate each . path name element (the current directory).
 3. Eliminate each inner .. path name element (the parent directory)
    along with the non-.. element that precedes it.
 4. Eliminate .. elements that begin a rooted path:
    that is, replace "/.." by "/" at the beginning of a path,
    assuming Separator is '/'.

The returned path ends in a slash only if it represents a root directory,
such as "/" on Unix or `C:\` on Windows.

Finally, any occurrences of slash are replaced by Separator.

If the result of this process is an empty string, Clean
returns the string ".".

On Windows, Clean does not modify the volume name other than to replace
occurrences of "/" with `\`.
For example, Clean("//host/share/../x") returns `\\host\share\x`.

See also Rob Pike, “Lexical File Names in Plan 9 or
Getting Dot-Dot Right,”
https://9p.io/sys/doc/lexnames.html</p>
            
            <pre><code>func Clean(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="IsLocal">
            <h2>IsLocal</h2>
            <hr />
            
            <p>IsLocal reports whether path, using lexical analysis only, has all of these properties:

  - is within the subtree rooted at the directory in which path is evaluated
  - is not an absolute path
  - is not empty
  - on Windows, is not a reserved name such as "NUL"

If IsLocal(path) returns true, then
Join(base, path) will always produce a path contained within base and
Clean(path) will always produce an unrooted path with no ".." path elements.

IsLocal is a purely lexical operation.
In particular, it does not account for the effect of any symbolic links
that may exist in the filesystem.</p>
            
            <pre><code>func IsLocal(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="Localize">
            <h2>Localize</h2>
            <hr />
            
            <p>Localize converts a slash-separated path into an operating system path.
The input path must be a valid path as reported by [io/fs.ValidPath].

Localize returns an error if the path cannot be represented by the operating system.
For example, the path a\b is rejected on Windows, on which \ is a separator
character and cannot be part of a filename.

The path returned by Localize will always be local, as reported by IsLocal.</p>
            
            <pre><code>func Localize(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="ToSlash">
            <h2>ToSlash</h2>
            <hr />
            
            <p>ToSlash returns the result of replacing each separator character
in path with a slash ('/') character. Multiple separators are
replaced by multiple slashes.</p>
            
            <pre><code>func ToSlash(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="FromSlash">
            <h2>FromSlash</h2>
            <hr />
            
            <p>FromSlash returns the result of replacing each slash ('/') character
in path with a separator character. Multiple slashes are replaced
by multiple separators.

See also the Localize function, which converts a slash-separated path
as used by the io/fs package to an operating system path.</p>
            
            <pre><code>func FromSlash(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="SplitList">
            <h2>SplitList</h2>
            <hr />
            
            <p>SplitList splits a list of paths joined by the OS-specific [ListSeparator],
usually found in PATH or GOPATH environment variables.
Unlike strings.Split, SplitList returns an empty slice when passed an empty
string.</p>
            
            <pre><code>func SplitList(path string) []string</code></pre>
         </article>
         
         <article class="function" data-name="Split">
            <h2>Split</h2>
            <hr />
            
            <p>Split splits path immediately following the final [Separator],
separating it into a directory and file name component.
If there is no Separator in path, Split returns an empty dir
and file set to path.
The returned values have the property that path = dir+file.</p>
            
            <pre><code>func Split(path string) (dir string, file string)</code></pre>
         </article>
         
         <article class="function" data-name="Join">
            <h2>Join</h2>
            <hr />
            
            <p>Join joins any number of path elements into a single path,
separating them with an OS specific [Separator]. Empty elements
are ignored. The result is Cleaned. However, if the argument
list is empty or all its elements are empty, Join returns
an empty string.
On Windows, the result will only be a UNC path if the first
non-empty element is a UNC path.</p>
            
            <pre><code>func Join(elem ...string) string</code></pre>
         </article>
         
         <article class="function" data-name="Ext">
            <h2>Ext</h2>
            <hr />
            
            <p>Ext returns the file name extension used by path.
The extension is the suffix beginning at the final dot
in the final element of path; it is empty if there is
no dot.</p>
            
            <pre><code>func Ext(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="EvalSymlinks">
            <h2>EvalSymlinks</h2>
            <hr />
            
            <p>EvalSymlinks returns the path name after the evaluation of any symbolic
links.
If path is relative the result will be relative to the current directory,
unless one of the components is an absolute symbolic link.
EvalSymlinks calls [Clean] on the result.</p>
            
            <pre><code>func EvalSymlinks(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="IsAbs">
            <h2>IsAbs</h2>
            <hr />
            
            <p>IsAbs reports whether the path is absolute.</p>
            
            <pre><code>func IsAbs(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="Abs">
            <h2>Abs</h2>
            <hr />
            
            <p>Abs returns an absolute representation of path.
If the path is not absolute it will be joined with the current
working directory to turn it into an absolute path. The absolute
path name for a given file is not guaranteed to be unique.
Abs calls [Clean] on the result.</p>
            
            <pre><code>func Abs(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="unixAbs">
            <h2>unixAbs</h2>
            <hr />
            
            <pre><code>func unixAbs(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Rel">
            <h2>Rel</h2>
            <hr />
            
            <p>Rel returns a relative path that is lexically equivalent to targpath when
joined to basepath with an intervening separator. That is,
[Join](basepath, Rel(basepath, targpath)) is equivalent to targpath itself.
On success, the returned path will always be relative to basepath,
even if basepath and targpath share no elements.
An error is returned if targpath can't be made relative to basepath or if
knowing the current working directory would be necessary to compute it.
Rel calls [Clean] on the result.</p>
            
            <pre><code>func Rel(basepath string, targpath string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="walkDir">
            <h2>walkDir</h2>
            <hr />
            
            <p>walkDir recursively descends path, calling walkDirFn.</p>
            
            <pre><code>func walkDir(path string, d fs.DirEntry, walkDirFn fs.WalkDirFunc) error</code></pre>
         </article>
         
         <article class="function" data-name="walk">
            <h2>walk</h2>
            <hr />
            
            <p>walk recursively descends path, calling walkFn.</p>
            
            <pre><code>func walk(path string, info fs.FileInfo, walkFn WalkFunc) error</code></pre>
         </article>
         
         <article class="function" data-name="WalkDir">
            <h2>WalkDir</h2>
            <hr />
            
            <p>WalkDir walks the file tree rooted at root, calling fn for each file or
directory in the tree, including root.

All errors that arise visiting files and directories are filtered by fn:
see the [fs.WalkDirFunc] documentation for details.

The files are walked in lexical order, which makes the output deterministic
but requires WalkDir to read an entire directory into memory before proceeding
to walk that directory.

WalkDir does not follow symbolic links.

WalkDir calls fn with paths that use the separator character appropriate
for the operating system. This is unlike [io/fs.WalkDir], which always
uses slash separated paths.</p>
            
            <pre><code>func WalkDir(root string, fn fs.WalkDirFunc) error</code></pre>
         </article>
         
         <article class="function" data-name="Walk">
            <h2>Walk</h2>
            <hr />
            
            <p>Walk walks the file tree rooted at root, calling fn for each file or
directory in the tree, including root.

All errors that arise visiting files and directories are filtered by fn:
see the [WalkFunc] documentation for details.

The files are walked in lexical order, which makes the output deterministic
but requires Walk to read an entire directory into memory before proceeding
to walk that directory.

Walk does not follow symbolic links.

Walk is less efficient than [WalkDir], introduced in Go 1.16,
which avoids calling os.Lstat on every visited file or directory.</p>
            
            <pre><code>func Walk(root string, fn WalkFunc) error</code></pre>
         </article>
         
         <article class="function" data-name="readDirNames">
            <h2>readDirNames</h2>
            <hr />
            
            <p>readDirNames reads the directory named by dirname and returns
a sorted list of directory entry names.</p>
            
            <pre><code>func readDirNames(dirname string) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Base">
            <h2>Base</h2>
            <hr />
            
            <p>Base returns the last element of path.
Trailing path separators are removed before extracting the last element.
If the path is empty, Base returns ".".
If the path consists entirely of separators, Base returns a single separator.</p>
            
            <pre><code>func Base(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="Dir">
            <h2>Dir</h2>
            <hr />
            
            <p>Dir returns all but the last element of path, typically the path's directory.
After dropping the final element, Dir calls [Clean] on the path and trailing
slashes are removed.
If the path is empty, Dir returns ".".
If the path consists entirely of separators, Dir returns a single separator.
The returned path does not end in a separator unless it is the root directory.</p>
            
            <pre><code>func Dir(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="VolumeName">
            <h2>VolumeName</h2>
            <hr />
            
            <p>VolumeName returns leading volume name.
Given "C:\foo\bar" it returns "C:" on Windows.
Given "\\host\share\foo" it returns "\\host\share".
On other platforms it returns "".</p>
            
            <pre><code>func VolumeName(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="HasPrefix">
            <h2>HasPrefix</h2>
            <hr />
            
            <p>HasPrefix exists for historical compatibility and should not be used.

Deprecated: HasPrefix does not respect path boundaries and
does not ignore case when required.</p>
            
            <pre><code>func HasPrefix(p string, prefix string) bool</code></pre>
         </article>
         
         <article class="function" data-name="splitList">
            <h2>splitList</h2>
            <hr />
            
            <pre><code>func splitList(path string) []string</code></pre>
         </article>
         
         <article class="function" data-name="abs">
            <h2>abs</h2>
            <hr />
            
            <pre><code>func abs(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="join">
            <h2>join</h2>
            <hr />
            
            <pre><code>func join(elem []string) string</code></pre>
         </article>
         
         <article class="function" data-name="sameWord">
            <h2>sameWord</h2>
            <hr />
            
            <pre><code>func sameWord(a string, b string) bool</code></pre>
         </article>
         
         <article class="function" data-name="HasPrefix">
            <h2>HasPrefix</h2>
            <hr />
            
            <p>HasPrefix exists for historical compatibility and should not be used.

Deprecated: HasPrefix does not respect path boundaries and
does not ignore case when required.</p>
            
            <pre><code>func HasPrefix(p string, prefix string) bool</code></pre>
         </article>
         
         <article class="function" data-name="splitList">
            <h2>splitList</h2>
            <hr />
            
            <pre><code>func splitList(path string) []string</code></pre>
         </article>
         
         <article class="function" data-name="abs">
            <h2>abs</h2>
            <hr />
            
            <pre><code>func abs(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="join">
            <h2>join</h2>
            <hr />
            
            <pre><code>func join(elem []string) string</code></pre>
         </article>
         
         <article class="function" data-name="sameWord">
            <h2>sameWord</h2>
            <hr />
            
            <pre><code>func sameWord(a string, b string) bool</code></pre>
         </article>
         
         <article class="function" data-name="walkSymlinks">
            <h2>walkSymlinks</h2>
            <hr />
            
            <pre><code>func walkSymlinks(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="evalSymlinks">
            <h2>evalSymlinks</h2>
            <hr />
            
            <pre><code>func evalSymlinks(path string) (string, error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
