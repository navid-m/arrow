<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>filepath - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                  
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>filepath</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"os"
"strings"
"syscall"
"strings"
"syscall"
"strings"
"os"
"strings"
"syscall"
"errors"
"internal/filepathlite"
"io/fs"
"os"
"runtime"
"syscall"
"errors"
"internal/filepathlite"
"os"
"runtime"
"slices"
"strings"
"unicode/utf8"
"errors"
"internal/bytealg"
"internal/filepathlite"
"io/fs"
"os"
"slices"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrBadPattern" data-name="ErrBadPattern">
               <h3>
                  ErrBadPattern 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrBadPattern" class="anchor" title="Link to ErrBadPattern">#</a>
               </h3>
               
                  <p class="doc-comment">ErrBadPattern indicates a pattern was malformed.</p>
               
               <pre><code class="language-go">var ErrBadPattern = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ListSeparator" data-name="ListSeparator">
               <h3>
                  ListSeparator 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ListSeparator" class="anchor" title="Link to ListSeparator">#</a>
               </h3>
               
               <pre><code class="language-go">const ListSeparator = os.PathListSeparator</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Separator" data-name="Separator">
               <h3>
                  Separator 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Separator" class="anchor" title="Link to Separator">#</a>
               </h3>
               
               <pre><code class="language-go">const Separator = os.PathSeparator</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SkipAll" data-name="SkipAll">
               <h3>
                  SkipAll 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#SkipAll" class="anchor" title="Link to SkipAll">#</a>
               </h3>
               
                  <p class="doc-comment">SkipAll is used as a return value from [WalkFunc] to indicate that
all remaining files and directories are to be skipped. It is not returned
as an error by any function.</p>
               
               <pre><code class="language-go">var SkipAll error = fs.SkipAll</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SkipDir" data-name="SkipDir">
               <h3>
                  SkipDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#SkipDir" class="anchor" title="Link to SkipDir">#</a>
               </h3>
               
                  <p class="doc-comment">SkipDir is used as a return value from [WalkFunc] to indicate that
the directory named in the call is to be skipped. It is not returned
as an error by any function.</p>
               
               <pre><code class="language-go">var SkipDir error = fs.SkipDir</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lstat" data-name="lstat">
               <h3>
                  lstat 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#lstat" class="anchor" title="Link to lstat">#</a>
               </h3>
               
               <pre><code class="language-go">var lstat = os.Lstat</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="WalkFunc" data-name="WalkFunc">
               <h3>
                  WalkFunc
                  <span class="badge type-badge">type</span>
                  <a href="#WalkFunc" class="anchor" title="Link to WalkFunc">#</a>
               </h3>
               
               <p>WalkFunc is the type of the function called by [Walk] to visit each
file or directory.
The path argument contains the argument to Walk as a prefix.
That is, if Walk is called with root argument "dir" and finds a file
named "a" in that directory, the walk function will be called with
argument "dir/a".
The directory and file are joined with Join, which may clean the
directory name: if Walk is called with the root argument "x/../dir"
and finds a file named "a" in that directory, the walk function will
be called with argument "dir/a", not "x/../dir/a".
The info argument is the fs.FileInfo for the named path.
The error result returned by the function controls how Walk continues.
If the function returns the special value [SkipDir], Walk skips the
current directory (path if info.IsDir() is true, otherwise path's
parent directory). If the function returns the special value [SkipAll],
Walk skips all remaining files and directories. Otherwise, if the function
returns a non-nil error, Walk stops entirely and returns that error.
The err argument reports an error related to path, signaling that Walk
will not walk into that directory. The function can decide how to
handle that error; as described earlier, returning the error will
cause Walk to stop walking the entire tree.
Walk calls the function with a non-nil err argument in two cases.
First, if an [os.Lstat] on the root directory or any directory or file
in the tree fails, Walk calls the function with path set to that
directory or file's path, info set to nil, and err set to the error
from os.Lstat.
Second, if a directory's Readdirnames method fails, Walk calls the
function with path set to the directory's path, info, set to an
[fs.FileInfo] describing the directory, and err set to the error from
Readdirnames.</p>
               
               <pre><code class="language-go">type WalkFunc func(path string, info fs.FileInfo, err error) error</code></pre>
            </article>
            
         </section>
            
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Abs" data-name="Abs">
               <h3>
                  Abs 
                  <span class="badge">function</span>
                  
                  <a href="#Abs" class="anchor" title="Link to Abs">#</a>
               </h3>
               
               <p>Abs returns an absolute representation of path.
If the path is not absolute it will be joined with the current
working directory to turn it into an absolute path. The absolute
path name for a given file is not guaranteed to be unique.
Abs calls [Clean] on the result.</p>
               
               <pre><code class="language-go">func Abs(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Base" data-name="Base">
               <h3>
                  Base 
                  <span class="badge">function</span>
                  
                  <a href="#Base" class="anchor" title="Link to Base">#</a>
               </h3>
               
               <p>Base returns the last element of path.
Trailing path separators are removed before extracting the last element.
If the path is empty, Base returns ".".
If the path consists entirely of separators, Base returns a single separator.</p>
               
               <pre><code class="language-go">func Base(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clean" data-name="Clean">
               <h3>
                  Clean 
                  <span class="badge">function</span>
                  
                  <a href="#Clean" class="anchor" title="Link to Clean">#</a>
               </h3>
               
               <p>Clean returns the shortest path name equivalent to path
by purely lexical processing. It applies the following rules
iteratively until no further processing can be done:
1. Replace multiple [Separator] elements with a single one.
2. Eliminate each . path name element (the current directory).
3. Eliminate each inner .. path name element (the parent directory)
along with the non-.. element that precedes it.
4. Eliminate .. elements that begin a rooted path:
that is, replace "/.." by "/" at the beginning of a path,
assuming Separator is '/'.
The returned path ends in a slash only if it represents a root directory,
such as "/" on Unix or `C:\` on Windows.
Finally, any occurrences of slash are replaced by Separator.
If the result of this process is an empty string, Clean
returns the string ".".
On Windows, Clean does not modify the volume name other than to replace
occurrences of "/" with `\`.
For example, Clean("//host/share/../x") returns `\\host\share\x`.
See also Rob Pike, “Lexical File Names in Plan 9 or
Getting Dot-Dot Right,”
https://9p.io/sys/doc/lexnames.html</p>
               
               <pre><code class="language-go">func Clean(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Dir" data-name="Dir">
               <h3>
                  Dir 
                  <span class="badge">function</span>
                  
                  <a href="#Dir" class="anchor" title="Link to Dir">#</a>
               </h3>
               
               <p>Dir returns all but the last element of path, typically the path's directory.
After dropping the final element, Dir calls [Clean] on the path and trailing
slashes are removed.
If the path is empty, Dir returns ".".
If the path consists entirely of separators, Dir returns a single separator.
The returned path does not end in a separator unless it is the root directory.</p>
               
               <pre><code class="language-go">func Dir(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EvalSymlinks" data-name="EvalSymlinks">
               <h3>
                  EvalSymlinks 
                  <span class="badge">function</span>
                  
                  <a href="#EvalSymlinks" class="anchor" title="Link to EvalSymlinks">#</a>
               </h3>
               
               <p>EvalSymlinks returns the path name after the evaluation of any symbolic
links.
If path is relative the result will be relative to the current directory,
unless one of the components is an absolute symbolic link.
EvalSymlinks calls [Clean] on the result.</p>
               
               <pre><code class="language-go">func EvalSymlinks(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Ext" data-name="Ext">
               <h3>
                  Ext 
                  <span class="badge">function</span>
                  
                  <a href="#Ext" class="anchor" title="Link to Ext">#</a>
               </h3>
               
               <p>Ext returns the file name extension used by path.
The extension is the suffix beginning at the final dot
in the final element of path; it is empty if there is
no dot.</p>
               
               <pre><code class="language-go">func Ext(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FromSlash" data-name="FromSlash">
               <h3>
                  FromSlash 
                  <span class="badge">function</span>
                  
                  <a href="#FromSlash" class="anchor" title="Link to FromSlash">#</a>
               </h3>
               
               <p>FromSlash returns the result of replacing each slash ('/') character
in path with a separator character. Multiple slashes are replaced
by multiple separators.
See also the Localize function, which converts a slash-separated path
as used by the io/fs package to an operating system path.</p>
               
               <pre><code class="language-go">func FromSlash(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Glob" data-name="Glob">
               <h3>
                  Glob 
                  <span class="badge">function</span>
                  
                  <a href="#Glob" class="anchor" title="Link to Glob">#</a>
               </h3>
               
               <p>Glob returns the names of all files matching pattern or nil
if there is no matching file. The syntax of patterns is the same
as in [Match]. The pattern may describe hierarchical names such as
/usr/*/bin/ed (assuming the [Separator] is '/').
Glob ignores file system errors such as I/O errors reading directories.
The only possible returned error is [ErrBadPattern], when pattern
is malformed.</p>
               
               <pre><code class="language-go">func Glob(pattern string) (matches []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasPrefix" data-name="HasPrefix">
               <h3>
                  HasPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#HasPrefix" class="anchor" title="Link to HasPrefix">#</a>
               </h3>
               
               <p>HasPrefix exists for historical compatibility and should not be used.
Deprecated: HasPrefix does not respect path boundaries and
does not ignore case when required.</p>
               
               <pre><code class="language-go">func HasPrefix(p string, prefix string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasPrefix" data-name="HasPrefix">
               <h3>
                  HasPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#HasPrefix" class="anchor" title="Link to HasPrefix">#</a>
               </h3>
               
               <p>HasPrefix exists for historical compatibility and should not be used.
Deprecated: HasPrefix does not respect path boundaries and
does not ignore case when required.</p>
               
               <pre><code class="language-go">func HasPrefix(p string, prefix string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasPrefix" data-name="HasPrefix">
               <h3>
                  HasPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#HasPrefix" class="anchor" title="Link to HasPrefix">#</a>
               </h3>
               
               <p>HasPrefix exists for historical compatibility and should not be used.
Deprecated: HasPrefix does not respect path boundaries and
does not ignore case when required.</p>
               
               <pre><code class="language-go">func HasPrefix(p string, prefix string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsAbs" data-name="IsAbs">
               <h3>
                  IsAbs 
                  <span class="badge">function</span>
                  
                  <a href="#IsAbs" class="anchor" title="Link to IsAbs">#</a>
               </h3>
               
               <p>IsAbs reports whether the path is absolute.</p>
               
               <pre><code class="language-go">func IsAbs(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsLocal" data-name="IsLocal">
               <h3>
                  IsLocal 
                  <span class="badge">function</span>
                  
                  <a href="#IsLocal" class="anchor" title="Link to IsLocal">#</a>
               </h3>
               
               <p>IsLocal reports whether path, using lexical analysis only, has all of these properties:
- is within the subtree rooted at the directory in which path is evaluated
- is not an absolute path
- is not empty
- on Windows, is not a reserved name such as "NUL"
If IsLocal(path) returns true, then
Join(base, path) will always produce a path contained within base and
Clean(path) will always produce an unrooted path with no ".." path elements.
IsLocal is a purely lexical operation.
In particular, it does not account for the effect of any symbolic links
that may exist in the filesystem.</p>
               
               <pre><code class="language-go">func IsLocal(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Join" data-name="Join">
               <h3>
                  Join 
                  <span class="badge">function</span>
                  
                  <a href="#Join" class="anchor" title="Link to Join">#</a>
               </h3>
               
               <p>Join joins any number of path elements into a single path,
separating them with an OS specific [Separator]. Empty elements
are ignored. The result is Cleaned. However, if the argument
list is empty or all its elements are empty, Join returns
an empty string.
On Windows, the result will only be a UNC path if the first
non-empty element is a UNC path.</p>
               
               <pre><code class="language-go">func Join(elem ...string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Localize" data-name="Localize">
               <h3>
                  Localize 
                  <span class="badge">function</span>
                  
                  <a href="#Localize" class="anchor" title="Link to Localize">#</a>
               </h3>
               
               <p>Localize converts a slash-separated path into an operating system path.
The input path must be a valid path as reported by [io/fs.ValidPath].
Localize returns an error if the path cannot be represented by the operating system.
For example, the path a\b is rejected on Windows, on which \ is a separator
character and cannot be part of a filename.
The path returned by Localize will always be local, as reported by IsLocal.</p>
               
               <pre><code class="language-go">func Localize(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Match" data-name="Match">
               <h3>
                  Match 
                  <span class="badge">function</span>
                  
                  <a href="#Match" class="anchor" title="Link to Match">#</a>
               </h3>
               
               <p>Match reports whether name matches the shell file name pattern.
The pattern syntax is:
pattern:
{ term }
term:
'*'         matches any sequence of non-Separator characters
'?'         matches any single non-Separator character
'[' [ '^' ] { character-range } ']'
character class (must be non-empty)
c           matches character c (c != '*', '?', '\\', '[')
'\\' c      matches character c
character-range:
c           matches character c (c != '\\', '-', ']')
'\\' c      matches character c
lo '-' hi   matches character c for lo <= c <= hi
Match requires pattern to match all of name, not just a substring.
The only possible returned error is [ErrBadPattern], when pattern
is malformed.
On Windows, escaping is disabled. Instead, '\\' is treated as
path separator.</p>
               
               <pre><code class="language-go">func Match(pattern string, name string) (matched bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Rel" data-name="Rel">
               <h3>
                  Rel 
                  <span class="badge">function</span>
                  
                  <a href="#Rel" class="anchor" title="Link to Rel">#</a>
               </h3>
               
               <p>Rel returns a relative path that is lexically equivalent to targpath when
joined to basepath with an intervening separator. That is,
[Join](basepath, Rel(basepath, targpath)) is equivalent to targpath itself.
On success, the returned path will always be relative to basepath,
even if basepath and targpath share no elements.
An error is returned if targpath can't be made relative to basepath or if
knowing the current working directory would be necessary to compute it.
Rel calls [Clean] on the result.</p>
               
               <pre><code class="language-go">func Rel(basepath string, targpath string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Split" data-name="Split">
               <h3>
                  Split 
                  <span class="badge">function</span>
                  
                  <a href="#Split" class="anchor" title="Link to Split">#</a>
               </h3>
               
               <p>Split splits path immediately following the final [Separator],
separating it into a directory and file name component.
If there is no Separator in path, Split returns an empty dir
and file set to path.
The returned values have the property that path = dir+file.</p>
               
               <pre><code class="language-go">func Split(path string) (dir string, file string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SplitList" data-name="SplitList">
               <h3>
                  SplitList 
                  <span class="badge">function</span>
                  
                  <a href="#SplitList" class="anchor" title="Link to SplitList">#</a>
               </h3>
               
               <p>SplitList splits a list of paths joined by the OS-specific [ListSeparator],
usually found in PATH or GOPATH environment variables.
Unlike strings.Split, SplitList returns an empty slice when passed an empty
string.</p>
               
               <pre><code class="language-go">func SplitList(path string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToSlash" data-name="ToSlash">
               <h3>
                  ToSlash 
                  <span class="badge">function</span>
                  
                  <a href="#ToSlash" class="anchor" title="Link to ToSlash">#</a>
               </h3>
               
               <p>ToSlash returns the result of replacing each separator character
in path with a slash ('/') character. Multiple separators are
replaced by multiple slashes.</p>
               
               <pre><code class="language-go">func ToSlash(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="VolumeName" data-name="VolumeName">
               <h3>
                  VolumeName 
                  <span class="badge">function</span>
                  
                  <a href="#VolumeName" class="anchor" title="Link to VolumeName">#</a>
               </h3>
               
               <p>VolumeName returns leading volume name.
Given "C:\foo\bar" it returns "C:" on Windows.
Given "\\host\share\foo" it returns "\\host\share".
On other platforms it returns "".</p>
               
               <pre><code class="language-go">func VolumeName(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Walk" data-name="Walk">
               <h3>
                  Walk 
                  <span class="badge">function</span>
                  
                  <a href="#Walk" class="anchor" title="Link to Walk">#</a>
               </h3>
               
               <p>Walk walks the file tree rooted at root, calling fn for each file or
directory in the tree, including root.
All errors that arise visiting files and directories are filtered by fn:
see the [WalkFunc] documentation for details.
The files are walked in lexical order, which makes the output deterministic
but requires Walk to read an entire directory into memory before proceeding
to walk that directory.
Walk does not follow symbolic links.
Walk is less efficient than [WalkDir], introduced in Go 1.16,
which avoids calling os.Lstat on every visited file or directory.</p>
               
               <pre><code class="language-go">func Walk(root string, fn WalkFunc) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WalkDir" data-name="WalkDir">
               <h3>
                  WalkDir 
                  <span class="badge">function</span>
                  
                  <a href="#WalkDir" class="anchor" title="Link to WalkDir">#</a>
               </h3>
               
               <p>WalkDir walks the file tree rooted at root, calling fn for each file or
directory in the tree, including root.
All errors that arise visiting files and directories are filtered by fn:
see the [fs.WalkDirFunc] documentation for details.
The files are walked in lexical order, which makes the output deterministic
but requires WalkDir to read an entire directory into memory before proceeding
to walk that directory.
WalkDir does not follow symbolic links.
WalkDir calls fn with paths that use the separator character appropriate
for the operating system. This is unlike [io/fs.WalkDir], which always
uses slash separated paths.</p>
               
               <pre><code class="language-go">func WalkDir(root string, fn fs.WalkDirFunc) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abs" data-name="abs">
               <h3>
                  abs 
                  <span class="badge">function</span>
                  
                  <a href="#abs" class="anchor" title="Link to abs">#</a>
               </h3>
               
               <pre><code class="language-go">func abs(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abs" data-name="abs">
               <h3>
                  abs 
                  <span class="badge">function</span>
                  
                  <a href="#abs" class="anchor" title="Link to abs">#</a>
               </h3>
               
               <pre><code class="language-go">func abs(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="abs" data-name="abs">
               <h3>
                  abs 
                  <span class="badge">function</span>
                  
                  <a href="#abs" class="anchor" title="Link to abs">#</a>
               </h3>
               
               <pre><code class="language-go">func abs(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="baseIsDotDot" data-name="baseIsDotDot">
               <h3>
                  baseIsDotDot 
                  <span class="badge">function</span>
                  
                  <a href="#baseIsDotDot" class="anchor" title="Link to baseIsDotDot">#</a>
               </h3>
               
               <p>baseIsDotDot reports whether the last element of path is "..".
The given path should be 'Clean'-ed in advance.</p>
               
               <pre><code class="language-go">func baseIsDotDot(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanGlobPath" data-name="cleanGlobPath">
               <h3>
                  cleanGlobPath 
                  <span class="badge">function</span>
                  
                  <a href="#cleanGlobPath" class="anchor" title="Link to cleanGlobPath">#</a>
               </h3>
               
               <p>cleanGlobPath prepares path for glob matching.</p>
               
               <pre><code class="language-go">func cleanGlobPath(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanGlobPathWindows" data-name="cleanGlobPathWindows">
               <h3>
                  cleanGlobPathWindows 
                  <span class="badge">function</span>
                  
                  <a href="#cleanGlobPathWindows" class="anchor" title="Link to cleanGlobPathWindows">#</a>
               </h3>
               
               <p>cleanGlobPathWindows is windows version of cleanGlobPath.</p>
               
               <pre><code class="language-go">func cleanGlobPathWindows(path string) (prefixLen int, cleaned string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalSymlinks" data-name="evalSymlinks">
               <h3>
                  evalSymlinks 
                  <span class="badge">function</span>
                  
                  <a href="#evalSymlinks" class="anchor" title="Link to evalSymlinks">#</a>
               </h3>
               
               <pre><code class="language-go">func evalSymlinks(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalSymlinks" data-name="evalSymlinks">
               <h3>
                  evalSymlinks 
                  <span class="badge">function</span>
                  
                  <a href="#evalSymlinks" class="anchor" title="Link to evalSymlinks">#</a>
               </h3>
               
               <pre><code class="language-go">func evalSymlinks(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="evalSymlinks" data-name="evalSymlinks">
               <h3>
                  evalSymlinks 
                  <span class="badge">function</span>
                  
                  <a href="#evalSymlinks" class="anchor" title="Link to evalSymlinks">#</a>
               </h3>
               
               <pre><code class="language-go">func evalSymlinks(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getEsc" data-name="getEsc">
               <h3>
                  getEsc 
                  <span class="badge">function</span>
                  
                  <a href="#getEsc" class="anchor" title="Link to getEsc">#</a>
               </h3>
               
               <p>getEsc gets a possibly-escaped character from chunk, for a character class.</p>
               
               <pre><code class="language-go">func getEsc(chunk string) (r rune, nchunk string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="glob" data-name="glob">
               <h3>
                  glob 
                  <span class="badge">function</span>
                  
                  <a href="#glob" class="anchor" title="Link to glob">#</a>
               </h3>
               
               <p>glob searches for files matching pattern in the directory dir
and appends them to matches. If the directory cannot be
opened, it returns the existing matches. New matches are
added in lexicographical order.</p>
               
               <pre><code class="language-go">func glob(dir string, pattern string, matches []string) (m []string, e error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="globWithLimit" data-name="globWithLimit">
               <h3>
                  globWithLimit 
                  <span class="badge">function</span>
                  
                  <a href="#globWithLimit" class="anchor" title="Link to globWithLimit">#</a>
               </h3>
               
               <pre><code class="language-go">func globWithLimit(pattern string, depth int) (matches []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasMeta" data-name="hasMeta">
               <h3>
                  hasMeta 
                  <span class="badge">function</span>
                  
                  <a href="#hasMeta" class="anchor" title="Link to hasMeta">#</a>
               </h3>
               
               <p>hasMeta reports whether path contains any of the magic characters
recognized by Match.</p>
               
               <pre><code class="language-go">func hasMeta(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="join" data-name="join">
               <h3>
                  join 
                  <span class="badge">function</span>
                  
                  <a href="#join" class="anchor" title="Link to join">#</a>
               </h3>
               
               <pre><code class="language-go">func join(elem []string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="join" data-name="join">
               <h3>
                  join 
                  <span class="badge">function</span>
                  
                  <a href="#join" class="anchor" title="Link to join">#</a>
               </h3>
               
               <pre><code class="language-go">func join(elem []string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="join" data-name="join">
               <h3>
                  join 
                  <span class="badge">function</span>
                  
                  <a href="#join" class="anchor" title="Link to join">#</a>
               </h3>
               
               <pre><code class="language-go">func join(elem []string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchChunk" data-name="matchChunk">
               <h3>
                  matchChunk 
                  <span class="badge">function</span>
                  
                  <a href="#matchChunk" class="anchor" title="Link to matchChunk">#</a>
               </h3>
               
               <p>matchChunk checks whether chunk matches the beginning of s.
If so, it returns the remainder of s (after the match).
Chunk is all single-character operators: literals, char classes, and ?.</p>
               
               <pre><code class="language-go">func matchChunk(chunk string, s string) (rest string, ok bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="normBase" data-name="normBase">
               <h3>
                  normBase 
                  <span class="badge">function</span>
                  
                  <a href="#normBase" class="anchor" title="Link to normBase">#</a>
               </h3>
               
               <p>normBase returns the last element of path with correct case.</p>
               
               <pre><code class="language-go">func normBase(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="normVolumeName" data-name="normVolumeName">
               <h3>
                  normVolumeName 
                  <span class="badge">function</span>
                  
                  <a href="#normVolumeName" class="anchor" title="Link to normVolumeName">#</a>
               </h3>
               
               <p>normVolumeName is like VolumeName, but makes drive letter upper case.
result of EvalSymlinks must be unique, so we have
EvalSymlinks(`c:\a`) == EvalSymlinks(`C:\a`).</p>
               
               <pre><code class="language-go">func normVolumeName(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readDirNames" data-name="readDirNames">
               <h3>
                  readDirNames 
                  <span class="badge">function</span>
                  
                  <a href="#readDirNames" class="anchor" title="Link to readDirNames">#</a>
               </h3>
               
               <p>readDirNames reads the directory named by dirname and returns
a sorted list of directory entry names.</p>
               
               <pre><code class="language-go">func readDirNames(dirname string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sameWord" data-name="sameWord">
               <h3>
                  sameWord 
                  <span class="badge">function</span>
                  
                  <a href="#sameWord" class="anchor" title="Link to sameWord">#</a>
               </h3>
               
               <pre><code class="language-go">func sameWord(a string, b string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sameWord" data-name="sameWord">
               <h3>
                  sameWord 
                  <span class="badge">function</span>
                  
                  <a href="#sameWord" class="anchor" title="Link to sameWord">#</a>
               </h3>
               
               <pre><code class="language-go">func sameWord(a string, b string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sameWord" data-name="sameWord">
               <h3>
                  sameWord 
                  <span class="badge">function</span>
                  
                  <a href="#sameWord" class="anchor" title="Link to sameWord">#</a>
               </h3>
               
               <pre><code class="language-go">func sameWord(a string, b string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanChunk" data-name="scanChunk">
               <h3>
                  scanChunk 
                  <span class="badge">function</span>
                  
                  <a href="#scanChunk" class="anchor" title="Link to scanChunk">#</a>
               </h3>
               
               <p>scanChunk gets the next segment of pattern, which is a non-star string
possibly preceded by a star.</p>
               
               <pre><code class="language-go">func scanChunk(pattern string) (star bool, chunk string, rest string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitList" data-name="splitList">
               <h3>
                  splitList 
                  <span class="badge">function</span>
                  
                  <a href="#splitList" class="anchor" title="Link to splitList">#</a>
               </h3>
               
               <pre><code class="language-go">func splitList(path string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitList" data-name="splitList">
               <h3>
                  splitList 
                  <span class="badge">function</span>
                  
                  <a href="#splitList" class="anchor" title="Link to splitList">#</a>
               </h3>
               
               <pre><code class="language-go">func splitList(path string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitList" data-name="splitList">
               <h3>
                  splitList 
                  <span class="badge">function</span>
                  
                  <a href="#splitList" class="anchor" title="Link to splitList">#</a>
               </h3>
               
               <pre><code class="language-go">func splitList(path string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="toNorm" data-name="toNorm">
               <h3>
                  toNorm 
                  <span class="badge">function</span>
                  
                  <a href="#toNorm" class="anchor" title="Link to toNorm">#</a>
               </h3>
               
               <p>toNorm returns the normalized path that is guaranteed to be unique.
It should accept the following formats:
- UNC paths                              (e.g \\server\share\foo\bar)
- absolute paths                         (e.g C:\foo\bar)
- relative paths begin with drive letter (e.g C:foo\bar, C:..\foo\bar, C:.., C:.)
- relative paths begin with '\'          (e.g \foo\bar)
- relative paths begin without '\'       (e.g foo\bar, ..\foo\bar, .., .)
The returned normalized path will be in the same form (of 5 listed above) as the input path.
If two paths A and B are indicating the same file with the same format, toNorm(A) should be equal to toNorm(B).
The normBase parameter should be equal to the normBase func, except for in tests.  See docs on the normBase func.</p>
               
               <pre><code class="language-go">func toNorm(path string, normBase func(string) (string, error)) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unixAbs" data-name="unixAbs">
               <h3>
                  unixAbs 
                  <span class="badge">function</span>
                  
                  <a href="#unixAbs" class="anchor" title="Link to unixAbs">#</a>
               </h3>
               
               <pre><code class="language-go">func unixAbs(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walk" data-name="walk">
               <h3>
                  walk 
                  <span class="badge">function</span>
                  
                  <a href="#walk" class="anchor" title="Link to walk">#</a>
               </h3>
               
               <p>walk recursively descends path, calling walkFn.</p>
               
               <pre><code class="language-go">func walk(path string, info fs.FileInfo, walkFn WalkFunc) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkDir" data-name="walkDir">
               <h3>
                  walkDir 
                  <span class="badge">function</span>
                  
                  <a href="#walkDir" class="anchor" title="Link to walkDir">#</a>
               </h3>
               
               <p>walkDir recursively descends path, calling walkDirFn.</p>
               
               <pre><code class="language-go">func walkDir(path string, d fs.DirEntry, walkDirFn fs.WalkDirFunc) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="walkSymlinks" data-name="walkSymlinks">
               <h3>
                  walkSymlinks 
                  <span class="badge">function</span>
                  
                  <a href="#walkSymlinks" class="anchor" title="Link to walkSymlinks">#</a>
               </h3>
               
               <pre><code class="language-go">func walkSymlinks(path string) (string, error)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>