<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>constraint - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                 
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>constraint</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"errors"
"strings"
"unicode"
"unicode/utf8"
"strconv"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="errComplex" data-name="errComplex">
               <h3>
                  errComplex 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errComplex" class="anchor" title="Link to errComplex">#</a>
               </h3>
               
               <pre><code class="language-go">var errComplex = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNotConstraint" data-name="errNotConstraint">
               <h3>
                  errNotConstraint 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNotConstraint" class="anchor" title="Link to errNotConstraint">#</a>
               </h3>
               
               <pre><code class="language-go">var errNotConstraint = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxSize" data-name="maxSize">
               <h3>
                  maxSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxSize" class="anchor" title="Link to maxSize">#</a>
               </h3>
               
                  <p class="doc-comment">maxSize is a limit used to control the complexity of expressions, in order
to prevent stack exhaustion issues due to recursion.</p>
               
               <pre><code class="language-go">const maxSize = 1000</code></pre>
            </article>
            
         </section>
           
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Expr" data-name="Expr">
               <h3>
                  Expr
                  <span class="badge interface-badge">interface</span>
                  <a href="#Expr" class="anchor" title="Link to Expr">#</a>
               </h3>
               
               <p>An Expr is a build tag constraint expression.
The underlying concrete type is *[AndExpr], *[OrExpr], *[NotExpr], or *[TagExpr].</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Expr interface {
String() string
Eval(ok func(tag string) bool) bool
isExpr()
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="AndExpr" data-name="AndExpr">
               <h3>
                  AndExpr
                  <span class="badge">struct</span>
                  <a href="#AndExpr" class="anchor" title="Link to AndExpr">#</a>
               </h3>
               
               <p>An AndExpr represents the expression X && Y.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type AndExpr struct {
X Expr
Y Expr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="NotExpr" data-name="NotExpr">
               <h3>
                  NotExpr
                  <span class="badge">struct</span>
                  <a href="#NotExpr" class="anchor" title="Link to NotExpr">#</a>
               </h3>
               
               <p>A NotExpr represents the expression !X (the negation of X).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type NotExpr struct {
X Expr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="OrExpr" data-name="OrExpr">
               <h3>
                  OrExpr
                  <span class="badge">struct</span>
                  <a href="#OrExpr" class="anchor" title="Link to OrExpr">#</a>
               </h3>
               
               <p>An OrExpr represents the expression X || Y.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type OrExpr struct {
X Expr
Y Expr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="SyntaxError" data-name="SyntaxError">
               <h3>
                  SyntaxError
                  <span class="badge">struct</span>
                  <a href="#SyntaxError" class="anchor" title="Link to SyntaxError">#</a>
               </h3>
               
               <p>A SyntaxError reports a syntax error in a parsed build expression.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type SyntaxError struct {
Offset int
Err string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TagExpr" data-name="TagExpr">
               <h3>
                  TagExpr
                  <span class="badge">struct</span>
                  <a href="#TagExpr" class="anchor" title="Link to TagExpr">#</a>
               </h3>
               
               <p>A TagExpr is an [Expr] for the single tag Tag.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type TagExpr struct {
Tag string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="exprParser" data-name="exprParser">
               <h3>
                  exprParser
                  <span class="badge">struct</span>
                  <a href="#exprParser" class="anchor" title="Link to exprParser">#</a>
               </h3>
               
               <p>An exprParser holds state for parsing a build expression.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type exprParser struct {
s string
i int
tok string
isTag bool
pos int
size int
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *SyntaxError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Eval" data-name="Eval">
               <h3>
                  Eval 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Eval" class="anchor" title="Link to Eval">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *OrExpr) Eval(ok func(tag string) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Eval" data-name="Eval">
               <h3>
                  Eval 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Eval" class="anchor" title="Link to Eval">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *TagExpr) Eval(ok func(tag string) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Eval" data-name="Eval">
               <h3>
                  Eval 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Eval" class="anchor" title="Link to Eval">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *NotExpr) Eval(ok func(tag string) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Eval" data-name="Eval">
               <h3>
                  Eval 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Eval" class="anchor" title="Link to Eval">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *AndExpr) Eval(ok func(tag string) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoVersion" data-name="GoVersion">
               <h3>
                  GoVersion 
                  <span class="badge">function</span>
                  
                  <a href="#GoVersion" class="anchor" title="Link to GoVersion">#</a>
               </h3>
               
               <p>GoVersion returns the minimum Go version implied by a given build expression.
If the expression can be satisfied without any Go version tags, GoVersion returns an empty string.
For example:
GoVersion(linux && go1.22) = "go1.22"
GoVersion((linux && go1.22) || (windows && go1.20)) = "go1.20" => go1.20
GoVersion(linux) = ""
GoVersion(linux || (windows && go1.22)) = ""
GoVersion(!go1.22) = ""
GoVersion assumes that any tag or negated tag may independently be true,
so that its analysis can be purely structural, without SAT solving.
“Impossible” subexpressions may therefore affect the result.
For example:
GoVersion((linux && !linux && go1.20) || go1.21) = "go1.20"</p>
               
               <pre><code class="language-go">func GoVersion(x Expr) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsGoBuild" data-name="IsGoBuild">
               <h3>
                  IsGoBuild 
                  <span class="badge">function</span>
                  
                  <a href="#IsGoBuild" class="anchor" title="Link to IsGoBuild">#</a>
               </h3>
               
               <p>IsGoBuild reports whether the line of text is a “//go:build” constraint.
It only checks the prefix of the text, not that the expression itself parses.</p>
               
               <pre><code class="language-go">func IsGoBuild(line string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsPlusBuild" data-name="IsPlusBuild">
               <h3>
                  IsPlusBuild 
                  <span class="badge">function</span>
                  
                  <a href="#IsPlusBuild" class="anchor" title="Link to IsPlusBuild">#</a>
               </h3>
               
               <p>IsPlusBuild reports whether the line of text is a “// +build” constraint.
It only checks the prefix of the text, not that the expression itself parses.</p>
               
               <pre><code class="language-go">func IsPlusBuild(line string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parse" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge">function</span>
                  
                  <a href="#Parse" class="anchor" title="Link to Parse">#</a>
               </h3>
               
               <p>Parse parses a single build constraint line of the form “//go:build ...” or “// +build ...”
and returns the corresponding boolean expression.</p>
               
               <pre><code class="language-go">func Parse(line string) (Expr, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PlusBuildLines" data-name="PlusBuildLines">
               <h3>
                  PlusBuildLines 
                  <span class="badge">function</span>
                  
                  <a href="#PlusBuildLines" class="anchor" title="Link to PlusBuildLines">#</a>
               </h3>
               
               <p>PlusBuildLines returns a sequence of “// +build” lines that evaluate to the build expression x.
If the expression is too complex to convert directly to “// +build” lines, PlusBuildLines returns an error.</p>
               
               <pre><code class="language-go">func PlusBuildLines(x Expr) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *AndExpr) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *TagExpr) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *NotExpr) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *OrExpr) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="and" data-name="and">
               <h3>
                  and 
                  <span class="badge">function</span>
                  
                  <a href="#and" class="anchor" title="Link to and">#</a>
               </h3>
               
               <pre><code class="language-go">func and(x Expr, y Expr) Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="and" data-name="and">
               <h3>
                  and 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#and" class="anchor" title="Link to and">#</a>
               </h3>
               
               <p>and parses a sequence of && expressions.
On entry, the next input token has not yet been lexed.
On exit, the next input token has been lexed and is in p.tok.</p>
               
               <pre><code class="language-go">func (p *exprParser) and() Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="andArg" data-name="andArg">
               <h3>
                  andArg 
                  <span class="badge">function</span>
                  
                  <a href="#andArg" class="anchor" title="Link to andArg">#</a>
               </h3>
               
               <pre><code class="language-go">func andArg(x Expr) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="andVersion" data-name="andVersion">
               <h3>
                  andVersion 
                  <span class="badge">function</span>
                  
                  <a href="#andVersion" class="anchor" title="Link to andVersion">#</a>
               </h3>
               
               <p>andVersion returns the minimum Go version
implied by the AND of two minimum Go versions,
which is the max of the versions.</p>
               
               <pre><code class="language-go">func andVersion(x int, y int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendSplitAnd" data-name="appendSplitAnd">
               <h3>
                  appendSplitAnd 
                  <span class="badge">function</span>
                  
                  <a href="#appendSplitAnd" class="anchor" title="Link to appendSplitAnd">#</a>
               </h3>
               
               <p>appendSplitAnd appends x to list while splitting apart any top-level && expressions.
For example, appendSplitAnd({W}, X && Y && Z) = {W, X, Y, Z}.</p>
               
               <pre><code class="language-go">func appendSplitAnd(list []Expr, x Expr) []Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendSplitOr" data-name="appendSplitOr">
               <h3>
                  appendSplitOr 
                  <span class="badge">function</span>
                  
                  <a href="#appendSplitOr" class="anchor" title="Link to appendSplitOr">#</a>
               </h3>
               
               <p>appendSplitOr appends x to list while splitting apart any top-level || expressions.
For example, appendSplitOr({W}, X || Y || Z) = {W, X, Y, Z}.</p>
               
               <pre><code class="language-go">func appendSplitOr(list []Expr, x Expr) []Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atom" data-name="atom">
               <h3>
                  atom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#atom" class="anchor" title="Link to atom">#</a>
               </h3>
               
               <p>atom parses a tag or a parenthesized expression.
On entry, the next input token HAS been lexed.
On exit, the next input token has been lexed and is in p.tok.</p>
               
               <pre><code class="language-go">func (p *exprParser) atom() Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isExpr" data-name="isExpr">
               <h3>
                  isExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isExpr" class="anchor" title="Link to isExpr">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *OrExpr) isExpr()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isExpr" data-name="isExpr">
               <h3>
                  isExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isExpr" class="anchor" title="Link to isExpr">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *AndExpr) isExpr()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isExpr" data-name="isExpr">
               <h3>
                  isExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isExpr" class="anchor" title="Link to isExpr">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *NotExpr) isExpr()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isExpr" data-name="isExpr">
               <h3>
                  isExpr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isExpr" class="anchor" title="Link to isExpr">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *TagExpr) isExpr()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValidTag" data-name="isValidTag">
               <h3>
                  isValidTag 
                  <span class="badge">function</span>
                  
                  <a href="#isValidTag" class="anchor" title="Link to isValidTag">#</a>
               </h3>
               
               <p>isValidTag reports whether the word is a valid build tag.
Tags must be letters, digits, underscores or dots.
Unlike in Go identifiers, all digits are fine (e.g., "386").</p>
               
               <pre><code class="language-go">func isValidTag(word string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lex" data-name="lex">
               <h3>
                  lex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lex" class="anchor" title="Link to lex">#</a>
               </h3>
               
               <p>lex finds and consumes the next token in the input stream.
On return, p.tok is set to the token text,
p.isTag reports whether the token was a tag,
and p.pos records the byte offset of the start of the token in the input stream.
If lex reaches the end of the input, p.tok is set to the empty string.
For any other syntax error, lex panics with a SyntaxError.</p>
               
               <pre><code class="language-go">func (p *exprParser) lex()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="minVersion" data-name="minVersion">
               <h3>
                  minVersion 
                  <span class="badge">function</span>
                  
                  <a href="#minVersion" class="anchor" title="Link to minVersion">#</a>
               </h3>
               
               <p>minVersion returns the minimum Go major version (9 for go1.9)
implied by expression z, or if sign < 0, by expression !z.</p>
               
               <pre><code class="language-go">func minVersion(z Expr, sign int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="not" data-name="not">
               <h3>
                  not 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#not" class="anchor" title="Link to not">#</a>
               </h3>
               
               <p>not parses a ! expression.
On entry, the next input token has not yet been lexed.
On exit, the next input token has been lexed and is in p.tok.</p>
               
               <pre><code class="language-go">func (p *exprParser) not() Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="not" data-name="not">
               <h3>
                  not 
                  <span class="badge">function</span>
                  
                  <a href="#not" class="anchor" title="Link to not">#</a>
               </h3>
               
               <pre><code class="language-go">func not(x Expr) Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="or" data-name="or">
               <h3>
                  or 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#or" class="anchor" title="Link to or">#</a>
               </h3>
               
               <p>or parses a sequence of || expressions.
On entry, the next input token has not yet been lexed.
On exit, the next input token has been lexed and is in p.tok.</p>
               
               <pre><code class="language-go">func (p *exprParser) or() Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="or" data-name="or">
               <h3>
                  or 
                  <span class="badge">function</span>
                  
                  <a href="#or" class="anchor" title="Link to or">#</a>
               </h3>
               
               <pre><code class="language-go">func or(x Expr, y Expr) Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="orArg" data-name="orArg">
               <h3>
                  orArg 
                  <span class="badge">function</span>
                  
                  <a href="#orArg" class="anchor" title="Link to orArg">#</a>
               </h3>
               
               <pre><code class="language-go">func orArg(x Expr) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="orVersion" data-name="orVersion">
               <h3>
                  orVersion 
                  <span class="badge">function</span>
                  
                  <a href="#orVersion" class="anchor" title="Link to orVersion">#</a>
               </h3>
               
               <p>orVersion returns the minimum Go version
implied by the OR of two minimum Go versions,
which is the min of the versions.</p>
               
               <pre><code class="language-go">func orVersion(x int, y int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseExpr" data-name="parseExpr">
               <h3>
                  parseExpr 
                  <span class="badge">function</span>
                  
                  <a href="#parseExpr" class="anchor" title="Link to parseExpr">#</a>
               </h3>
               
               <p>parseExpr parses a boolean build tag expression.</p>
               
               <pre><code class="language-go">func parseExpr(text string) (x Expr, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePlusBuildExpr" data-name="parsePlusBuildExpr">
               <h3>
                  parsePlusBuildExpr 
                  <span class="badge">function</span>
                  
                  <a href="#parsePlusBuildExpr" class="anchor" title="Link to parsePlusBuildExpr">#</a>
               </h3>
               
               <p>parsePlusBuildExpr parses a legacy build tag expression (as used with “// +build”).</p>
               
               <pre><code class="language-go">func parsePlusBuildExpr(text string) (Expr, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pushNot" data-name="pushNot">
               <h3>
                  pushNot 
                  <span class="badge">function</span>
                  
                  <a href="#pushNot" class="anchor" title="Link to pushNot">#</a>
               </h3>
               
               <p>pushNot applies DeMorgan's law to push negations down the expression,
so that only tags are negated in the result.
(It applies the rewrites !(X && Y) => (!X || !Y) and !(X || Y) => (!X && !Y).)</p>
               
               <pre><code class="language-go">func pushNot(x Expr, not bool) Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitGoBuild" data-name="splitGoBuild">
               <h3>
                  splitGoBuild 
                  <span class="badge">function</span>
                  
                  <a href="#splitGoBuild" class="anchor" title="Link to splitGoBuild">#</a>
               </h3>
               
               <p>splitGoBuild splits apart the leading //go:build prefix in line from the build expression itself.
It returns "", false if the input is not a //go:build line or if the input contains multiple lines.</p>
               
               <pre><code class="language-go">func splitGoBuild(line string) (expr string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitPlusBuild" data-name="splitPlusBuild">
               <h3>
                  splitPlusBuild 
                  <span class="badge">function</span>
                  
                  <a href="#splitPlusBuild" class="anchor" title="Link to splitPlusBuild">#</a>
               </h3>
               
               <p>splitPlusBuild splits apart the leading // +build prefix in line from the build expression itself.
It returns "", false if the input is not a // +build line or if the input contains multiple lines.</p>
               
               <pre><code class="language-go">func splitPlusBuild(line string) (expr string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tag" data-name="tag">
               <h3>
                  tag 
                  <span class="badge">function</span>
                  
                  <a href="#tag" class="anchor" title="Link to tag">#</a>
               </h3>
               
               <pre><code class="language-go">func tag(tag string) Expr</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>