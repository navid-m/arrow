<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - constraint</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>constraint</code>
         </h1>
         <hr />
         
         <article class="global" data-name="exprStringTests">
            <h2>exprStringTests</h2>
            <hr />
            
            <pre><code>exprStringTests</code></pre>
         </article>
         
         <article class="global" data-name="lexTests">
            <h2>lexTests</h2>
            <hr />
            
            <pre><code>lexTests</code></pre>
         </article>
         
         <article class="global" data-name="parseExprTests">
            <h2>parseExprTests</h2>
            <hr />
            
            <pre><code>parseExprTests</code></pre>
         </article>
         
         <article class="global" data-name="parseExprErrorTests">
            <h2>parseExprErrorTests</h2>
            <hr />
            
            <pre><code>parseExprErrorTests</code></pre>
         </article>
         
         <article class="global" data-name="exprEvalTests">
            <h2>exprEvalTests</h2>
            <hr />
            
            <pre><code>exprEvalTests</code></pre>
         </article>
         
         <article class="global" data-name="parsePlusBuildExprTests">
            <h2>parsePlusBuildExprTests</h2>
            <hr />
            
            <pre><code>parsePlusBuildExprTests</code></pre>
         </article>
         
         <article class="global" data-name="constraintTests">
            <h2>constraintTests</h2>
            <hr />
            
            <pre><code>constraintTests</code></pre>
         </article>
         
         <article class="global" data-name="plusBuildLinesTests">
            <h2>plusBuildLinesTests</h2>
            <hr />
            
            <pre><code>plusBuildLinesTests</code></pre>
         </article>
         
         <article class="global" data-name="tests">
            <h2>tests</h2>
            <hr />
            
            <pre><code>tests</code></pre>
         </article>
         
         <article class="global" data-name="maxSize">
            <h2>maxSize</h2>
            <hr />
            
            <p>maxSize is a limit used to control the complexity of expressions, in order
to prevent stack exhaustion issues due to recursion.</p>
            
            <pre><code>maxSize</code></pre>
         </article>
         
         <article class="global" data-name="errNotConstraint">
            <h2>errNotConstraint</h2>
            <hr />
            
            <pre><code>errNotConstraint</code></pre>
         </article>
         
         <article class="global" data-name="errComplex">
            <h2>errComplex</h2>
            <hr />
            
            <pre><code>errComplex</code></pre>
         </article>
          
         <article class="struct" data-name="TagExpr">
            <h2>type TagExpr struct</h2>
            <hr />
            
            <p>A TagExpr is an [Expr] for the single tag Tag.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Tag string</code></pre>
         </article>
         
         <article class="struct" data-name="NotExpr">
            <h2>type NotExpr struct</h2>
            <hr />
            
            <p>A NotExpr represents the expression !X (the negation of X).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">X Expr</code></pre>
         </article>
         
         <article class="struct" data-name="AndExpr">
            <h2>type AndExpr struct</h2>
            <hr />
            
            <p>An AndExpr represents the expression X && Y.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">X Expr
Y Expr</code></pre>
         </article>
         
         <article class="struct" data-name="OrExpr">
            <h2>type OrExpr struct</h2>
            <hr />
            
            <p>An OrExpr represents the expression X || Y.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">X Expr
Y Expr</code></pre>
         </article>
         
         <article class="struct" data-name="SyntaxError">
            <h2>type SyntaxError struct</h2>
            <hr />
            
            <p>A SyntaxError reports a syntax error in a parsed build expression.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Offset int
Err string</code></pre>
         </article>
         
         <article class="struct" data-name="exprParser">
            <h2>type exprParser struct</h2>
            <hr />
            
            <p>An exprParser holds state for parsing a build expression.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">s string
i int
tok string
isTag bool
pos int
size int</code></pre>
         </article>
          
         <article class="function" data-name="TestExprString">
            <h2>TestExprString</h2>
            <hr />
            
            <pre><code>func TestExprString(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLex">
            <h2>TestLex</h2>
            <hr />
            
            <pre><code>func TestLex(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="lexHelp">
            <h2>lexHelp</h2>
            <hr />
            
            <pre><code>func lexHelp(p *exprParser) (tok string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseExpr">
            <h2>TestParseExpr</h2>
            <hr />
            
            <pre><code>func TestParseExpr(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseError">
            <h2>TestParseError</h2>
            <hr />
            
            <pre><code>func TestParseError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestExprEval">
            <h2>TestExprEval</h2>
            <hr />
            
            <pre><code>func TestExprEval(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParsePlusBuildExpr">
            <h2>TestParsePlusBuildExpr</h2>
            <hr />
            
            <pre><code>func TestParsePlusBuildExpr(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParse">
            <h2>TestParse</h2>
            <hr />
            
            <pre><code>func TestParse(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPlusBuildLines">
            <h2>TestPlusBuildLines</h2>
            <hr />
            
            <pre><code>func TestPlusBuildLines(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSizeLimits">
            <h2>TestSizeLimits</h2>
            <hr />
            
            <pre><code>func TestSizeLimits(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPlusSizeLimits">
            <h2>TestPlusSizeLimits</h2>
            <hr />
            
            <pre><code>func TestPlusSizeLimits(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="GoVersion">
            <h2>GoVersion</h2>
            <hr />
            
            <p>GoVersion returns the minimum Go version implied by a given build expression.
If the expression can be satisfied without any Go version tags, GoVersion returns an empty string.

For example:

	GoVersion(linux && go1.22) = "go1.22"
	GoVersion((linux && go1.22) || (windows && go1.20)) = "go1.20" => go1.20
	GoVersion(linux) = ""
	GoVersion(linux || (windows && go1.22)) = ""
	GoVersion(!go1.22) = ""

GoVersion assumes that any tag or negated tag may independently be true,
so that its analysis can be purely structural, without SAT solving.
“Impossible” subexpressions may therefore affect the result.

For example:

	GoVersion((linux && !linux && go1.20) || go1.21) = "go1.20"</p>
            
            <pre><code>func GoVersion(x Expr) string</code></pre>
         </article>
         
         <article class="function" data-name="minVersion">
            <h2>minVersion</h2>
            <hr />
            
            <p>minVersion returns the minimum Go major version (9 for go1.9)
implied by expression z, or if sign < 0, by expression !z.</p>
            
            <pre><code>func minVersion(z Expr, sign int) int</code></pre>
         </article>
         
         <article class="function" data-name="andVersion">
            <h2>andVersion</h2>
            <hr />
            
            <p>andVersion returns the minimum Go version
implied by the AND of two minimum Go versions,
which is the max of the versions.</p>
            
            <pre><code>func andVersion(x int, y int) int</code></pre>
         </article>
         
         <article class="function" data-name="orVersion">
            <h2>orVersion</h2>
            <hr />
            
            <p>orVersion returns the minimum Go version
implied by the OR of two minimum Go versions,
which is the min of the versions.</p>
            
            <pre><code>func orVersion(x int, y int) int</code></pre>
         </article>
         
         <article class="function" data-name="TestGoVersion">
            <h2>TestGoVersion</h2>
            <hr />
            
            <pre><code>func TestGoVersion(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="isExpr">
            <h2>isExpr</h2>
            <hr />
            
            <pre><code>func isExpr()</code></pre>
         </article>
         
         <article class="function" data-name="Eval">
            <h2>Eval</h2>
            <hr />
            
            <pre><code>func Eval(ok func) bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="tag">
            <h2>tag</h2>
            <hr />
            
            <pre><code>func tag(tag string) Expr</code></pre>
         </article>
         
         <article class="function" data-name="isExpr">
            <h2>isExpr</h2>
            <hr />
            
            <pre><code>func isExpr()</code></pre>
         </article>
         
         <article class="function" data-name="Eval">
            <h2>Eval</h2>
            <hr />
            
            <pre><code>func Eval(ok func) bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="not">
            <h2>not</h2>
            <hr />
            
            <pre><code>func not(x Expr) Expr</code></pre>
         </article>
         
         <article class="function" data-name="isExpr">
            <h2>isExpr</h2>
            <hr />
            
            <pre><code>func isExpr()</code></pre>
         </article>
         
         <article class="function" data-name="Eval">
            <h2>Eval</h2>
            <hr />
            
            <pre><code>func Eval(ok func) bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="andArg">
            <h2>andArg</h2>
            <hr />
            
            <pre><code>func andArg(x Expr) string</code></pre>
         </article>
         
         <article class="function" data-name="and">
            <h2>and</h2>
            <hr />
            
            <pre><code>func and(x Expr, y Expr) Expr</code></pre>
         </article>
         
         <article class="function" data-name="isExpr">
            <h2>isExpr</h2>
            <hr />
            
            <pre><code>func isExpr()</code></pre>
         </article>
         
         <article class="function" data-name="Eval">
            <h2>Eval</h2>
            <hr />
            
            <pre><code>func Eval(ok func) bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="orArg">
            <h2>orArg</h2>
            <hr />
            
            <pre><code>func orArg(x Expr) string</code></pre>
         </article>
         
         <article class="function" data-name="or">
            <h2>or</h2>
            <hr />
            
            <pre><code>func or(x Expr, y Expr) Expr</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <p>Parse parses a single build constraint line of the form “//go:build ...” or “// +build ...”
and returns the corresponding boolean expression.</p>
            
            <pre><code>func Parse(line string) (Expr, error)</code></pre>
         </article>
         
         <article class="function" data-name="IsGoBuild">
            <h2>IsGoBuild</h2>
            <hr />
            
            <p>IsGoBuild reports whether the line of text is a “//go:build” constraint.
It only checks the prefix of the text, not that the expression itself parses.</p>
            
            <pre><code>func IsGoBuild(line string) bool</code></pre>
         </article>
         
         <article class="function" data-name="splitGoBuild">
            <h2>splitGoBuild</h2>
            <hr />
            
            <p>splitGoBuild splits apart the leading //go:build prefix in line from the build expression itself.
It returns "", false if the input is not a //go:build line or if the input contains multiple lines.</p>
            
            <pre><code>func splitGoBuild(line string) (expr string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="parseExpr">
            <h2>parseExpr</h2>
            <hr />
            
            <p>parseExpr parses a boolean build tag expression.</p>
            
            <pre><code>func parseExpr(text string) (x Expr, err error)</code></pre>
         </article>
         
         <article class="function" data-name="or">
            <h2>or</h2>
            <hr />
            
            <p>or parses a sequence of || expressions.
On entry, the next input token has not yet been lexed.
On exit, the next input token has been lexed and is in p.tok.</p>
            
            <pre><code>func or() Expr</code></pre>
         </article>
         
         <article class="function" data-name="and">
            <h2>and</h2>
            <hr />
            
            <p>and parses a sequence of && expressions.
On entry, the next input token has not yet been lexed.
On exit, the next input token has been lexed and is in p.tok.</p>
            
            <pre><code>func and() Expr</code></pre>
         </article>
         
         <article class="function" data-name="not">
            <h2>not</h2>
            <hr />
            
            <p>not parses a ! expression.
On entry, the next input token has not yet been lexed.
On exit, the next input token has been lexed and is in p.tok.</p>
            
            <pre><code>func not() Expr</code></pre>
         </article>
         
         <article class="function" data-name="atom">
            <h2>atom</h2>
            <hr />
            
            <p>atom parses a tag or a parenthesized expression.
On entry, the next input token HAS been lexed.
On exit, the next input token has been lexed and is in p.tok.</p>
            
            <pre><code>func atom() Expr</code></pre>
         </article>
         
         <article class="function" data-name="lex">
            <h2>lex</h2>
            <hr />
            
            <p>lex finds and consumes the next token in the input stream.
On return, p.tok is set to the token text,
p.isTag reports whether the token was a tag,
and p.pos records the byte offset of the start of the token in the input stream.
If lex reaches the end of the input, p.tok is set to the empty string.
For any other syntax error, lex panics with a SyntaxError.</p>
            
            <pre><code>func lex()</code></pre>
         </article>
         
         <article class="function" data-name="IsPlusBuild">
            <h2>IsPlusBuild</h2>
            <hr />
            
            <p>IsPlusBuild reports whether the line of text is a “// +build” constraint.
It only checks the prefix of the text, not that the expression itself parses.</p>
            
            <pre><code>func IsPlusBuild(line string) bool</code></pre>
         </article>
         
         <article class="function" data-name="splitPlusBuild">
            <h2>splitPlusBuild</h2>
            <hr />
            
            <p>splitPlusBuild splits apart the leading // +build prefix in line from the build expression itself.
It returns "", false if the input is not a // +build line or if the input contains multiple lines.</p>
            
            <pre><code>func splitPlusBuild(line string) (expr string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="parsePlusBuildExpr">
            <h2>parsePlusBuildExpr</h2>
            <hr />
            
            <p>parsePlusBuildExpr parses a legacy build tag expression (as used with “// +build”).</p>
            
            <pre><code>func parsePlusBuildExpr(text string) (Expr, error)</code></pre>
         </article>
         
         <article class="function" data-name="isValidTag">
            <h2>isValidTag</h2>
            <hr />
            
            <p>isValidTag reports whether the word is a valid build tag.
Tags must be letters, digits, underscores or dots.
Unlike in Go identifiers, all digits are fine (e.g., "386").</p>
            
            <pre><code>func isValidTag(word string) bool</code></pre>
         </article>
         
         <article class="function" data-name="PlusBuildLines">
            <h2>PlusBuildLines</h2>
            <hr />
            
            <p>PlusBuildLines returns a sequence of “// +build” lines that evaluate to the build expression x.
If the expression is too complex to convert directly to “// +build” lines, PlusBuildLines returns an error.</p>
            
            <pre><code>func PlusBuildLines(x Expr) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="pushNot">
            <h2>pushNot</h2>
            <hr />
            
            <p>pushNot applies DeMorgan's law to push negations down the expression,
so that only tags are negated in the result.
(It applies the rewrites !(X && Y) => (!X || !Y) and !(X || Y) => (!X && !Y).)</p>
            
            <pre><code>func pushNot(x Expr, not bool) Expr</code></pre>
         </article>
         
         <article class="function" data-name="appendSplitAnd">
            <h2>appendSplitAnd</h2>
            <hr />
            
            <p>appendSplitAnd appends x to list while splitting apart any top-level && expressions.
For example, appendSplitAnd({W}, X && Y && Z) = {W, X, Y, Z}.</p>
            
            <pre><code>func appendSplitAnd(list []Expr, x Expr) []Expr</code></pre>
         </article>
         
         <article class="function" data-name="appendSplitOr">
            <h2>appendSplitOr</h2>
            <hr />
            
            <p>appendSplitOr appends x to list while splitting apart any top-level || expressions.
For example, appendSplitOr({W}, X || Y || Z) = {W, X, Y, Z}.</p>
            
            <pre><code>func appendSplitOr(list []Expr, x Expr) []Expr</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
