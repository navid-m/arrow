<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - xml</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>xml</code>
         </h1>
         <hr />
         
         <article class="global" data-name="fElement">
            <h2>fElement</h2>
            <hr />
            
            <pre><code>fElement fieldFlags</code></pre>
         </article>
         
         <article class="global" data-name="fAttr">
            <h2>fAttr</h2>
            <hr />
            
            <pre><code>fAttr</code></pre>
         </article>
         
         <article class="global" data-name="fCDATA">
            <h2>fCDATA</h2>
            <hr />
            
            <pre><code>fCDATA</code></pre>
         </article>
         
         <article class="global" data-name="fCharData">
            <h2>fCharData</h2>
            <hr />
            
            <pre><code>fCharData</code></pre>
         </article>
         
         <article class="global" data-name="fInnerXML">
            <h2>fInnerXML</h2>
            <hr />
            
            <pre><code>fInnerXML</code></pre>
         </article>
         
         <article class="global" data-name="fComment">
            <h2>fComment</h2>
            <hr />
            
            <pre><code>fComment</code></pre>
         </article>
         
         <article class="global" data-name="fAny">
            <h2>fAny</h2>
            <hr />
            
            <pre><code>fAny</code></pre>
         </article>
         
         <article class="global" data-name="fOmitEmpty">
            <h2>fOmitEmpty</h2>
            <hr />
            
            <pre><code>fOmitEmpty</code></pre>
         </article>
         
         <article class="global" data-name="fMode">
            <h2>fMode</h2>
            <hr />
            
            <pre><code>fMode</code></pre>
         </article>
         
         <article class="global" data-name="xmlName">
            <h2>xmlName</h2>
            <hr />
            
            <pre><code>xmlName</code></pre>
         </article>
         
         <article class="global" data-name="tinfoMap">
            <h2>tinfoMap</h2>
            <hr />
            
            <pre><code>tinfoMap sync.Map</code></pre>
         </article>
         
         <article class="global" data-name="nameType">
            <h2>nameType</h2>
            <hr />
            
            <pre><code>nameType</code></pre>
         </article>
         
         <article class="global" data-name="initNilPointers">
            <h2>initNilPointers</h2>
            <hr />
            
            <pre><code>initNilPointers</code></pre>
         </article>
         
         <article class="global" data-name="dontInitNilPointers">
            <h2>dontInitNilPointers</h2>
            <hr />
            
            <pre><code>dontInitNilPointers</code></pre>
         </article>
         
         <article class="global" data-name="xmlURL">
            <h2>xmlURL</h2>
            <hr />
            
            <pre><code>xmlURL</code></pre>
         </article>
         
         <article class="global" data-name="xmlnsPrefix">
            <h2>xmlnsPrefix</h2>
            <hr />
            
            <pre><code>xmlnsPrefix</code></pre>
         </article>
         
         <article class="global" data-name="xmlPrefix">
            <h2>xmlPrefix</h2>
            <hr />
            
            <pre><code>xmlPrefix</code></pre>
         </article>
         
         <article class="global" data-name="stkStart">
            <h2>stkStart</h2>
            <hr />
            
            <pre><code>stkStart</code></pre>
         </article>
         
         <article class="global" data-name="stkNs">
            <h2>stkNs</h2>
            <hr />
            
            <pre><code>stkNs</code></pre>
         </article>
         
         <article class="global" data-name="stkEOF">
            <h2>stkEOF</h2>
            <hr />
            
            <pre><code>stkEOF</code></pre>
         </article>
         
         <article class="global" data-name="errRawToken">
            <h2>errRawToken</h2>
            <hr />
            
            <pre><code>errRawToken</code></pre>
         </article>
         
         <article class="global" data-name="entity">
            <h2>entity</h2>
            <hr />
            
            <pre><code>entity</code></pre>
         </article>
         
         <article class="global" data-name="first">
            <h2>first</h2>
            <hr />
            
            <pre><code>first</code></pre>
         </article>
         
         <article class="global" data-name="second">
            <h2>second</h2>
            <hr />
            
            <pre><code>second</code></pre>
         </article>
         
         <article class="global" data-name="HTMLEntity">
            <h2>HTMLEntity</h2>
            <hr />
            
            <p>HTMLEntity is an entity map containing translations for the
standard HTML entity characters.

See the [Decoder.Strict] and [Decoder.Entity] fields' documentation.</p>
            
            <pre><code>HTMLEntity *ast.MapType</code></pre>
         </article>
         
         <article class="global" data-name="htmlEntity">
            <h2>htmlEntity</h2>
            <hr />
            
            <pre><code>htmlEntity</code></pre>
         </article>
         
         <article class="global" data-name="HTMLAutoClose">
            <h2>HTMLAutoClose</h2>
            <hr />
            
            <p>HTMLAutoClose is the set of HTML elements that
should be considered to close automatically.

See the [Decoder.Strict] and [Decoder.Entity] fields' documentation.</p>
            
            <pre><code>HTMLAutoClose []string</code></pre>
         </article>
         
         <article class="global" data-name="htmlAutoClose">
            <h2>htmlAutoClose</h2>
            <hr />
            
            <pre><code>htmlAutoClose</code></pre>
         </article>
         
         <article class="global" data-name="escQuot">
            <h2>escQuot</h2>
            <hr />
            
            <pre><code>escQuot</code></pre>
         </article>
         
         <article class="global" data-name="escApos">
            <h2>escApos</h2>
            <hr />
            
            <pre><code>escApos</code></pre>
         </article>
         
         <article class="global" data-name="escAmp">
            <h2>escAmp</h2>
            <hr />
            
            <pre><code>escAmp</code></pre>
         </article>
         
         <article class="global" data-name="escLT">
            <h2>escLT</h2>
            <hr />
            
            <pre><code>escLT</code></pre>
         </article>
         
         <article class="global" data-name="escGT">
            <h2>escGT</h2>
            <hr />
            
            <pre><code>escGT</code></pre>
         </article>
         
         <article class="global" data-name="escTab">
            <h2>escTab</h2>
            <hr />
            
            <pre><code>escTab</code></pre>
         </article>
         
         <article class="global" data-name="escNL">
            <h2>escNL</h2>
            <hr />
            
            <pre><code>escNL</code></pre>
         </article>
         
         <article class="global" data-name="escCR">
            <h2>escCR</h2>
            <hr />
            
            <pre><code>escCR</code></pre>
         </article>
         
         <article class="global" data-name="escFFFD">
            <h2>escFFFD</h2>
            <hr />
            
            <pre><code>escFFFD</code></pre>
         </article>
         
         <article class="global" data-name="cdataStart">
            <h2>cdataStart</h2>
            <hr />
            
            <pre><code>cdataStart</code></pre>
         </article>
         
         <article class="global" data-name="cdataEnd">
            <h2>cdataEnd</h2>
            <hr />
            
            <pre><code>cdataEnd</code></pre>
         </article>
         
         <article class="global" data-name="cdataEscape">
            <h2>cdataEscape</h2>
            <hr />
            
            <pre><code>cdataEscape</code></pre>
         </article>
         
         <article class="global" data-name="testInput">
            <h2>testInput</h2>
            <hr />
            
            <pre><code>testInput</code></pre>
         </article>
         
         <article class="global" data-name="testEntity">
            <h2>testEntity</h2>
            <hr />
            
            <pre><code>testEntity</code></pre>
         </article>
         
         <article class="global" data-name="rawTokens">
            <h2>rawTokens</h2>
            <hr />
            
            <pre><code>rawTokens</code></pre>
         </article>
         
         <article class="global" data-name="cookedTokens">
            <h2>cookedTokens</h2>
            <hr />
            
            <pre><code>cookedTokens</code></pre>
         </article>
         
         <article class="global" data-name="testInputAltEncoding">
            <h2>testInputAltEncoding</h2>
            <hr />
            
            <pre><code>testInputAltEncoding</code></pre>
         </article>
         
         <article class="global" data-name="rawTokensAltEncoding">
            <h2>rawTokensAltEncoding</h2>
            <hr />
            
            <pre><code>rawTokensAltEncoding</code></pre>
         </article>
         
         <article class="global" data-name="xmlInput">
            <h2>xmlInput</h2>
            <hr />
            
            <pre><code>xmlInput</code></pre>
         </article>
         
         <article class="global" data-name="nonStrictInput">
            <h2>nonStrictInput</h2>
            <hr />
            
            <pre><code>nonStrictInput</code></pre>
         </article>
         
         <article class="global" data-name="nonStrictTokens">
            <h2>nonStrictTokens</h2>
            <hr />
            
            <pre><code>nonStrictTokens</code></pre>
         </article>
         
         <article class="global" data-name="nestedDirectivesInput">
            <h2>nestedDirectivesInput</h2>
            <hr />
            
            <pre><code>nestedDirectivesInput</code></pre>
         </article>
         
         <article class="global" data-name="nestedDirectivesTokens">
            <h2>nestedDirectivesTokens</h2>
            <hr />
            
            <pre><code>nestedDirectivesTokens</code></pre>
         </article>
         
         <article class="global" data-name="all">
            <h2>all</h2>
            <hr />
            
            <pre><code>all</code></pre>
         </article>
         
         <article class="global" data-name="sixteen">
            <h2>sixteen</h2>
            <hr />
            
            <pre><code>sixteen</code></pre>
         </article>
         
         <article class="global" data-name="testScalarsInput">
            <h2>testScalarsInput</h2>
            <hr />
            
            <pre><code>testScalarsInput</code></pre>
         </article>
         
         <article class="global" data-name="characterTests">
            <h2>characterTests</h2>
            <hr />
            
            <pre><code>characterTests</code></pre>
         </article>
         
         <article class="global" data-name="procInstTests">
            <h2>procInstTests</h2>
            <hr />
            
            <pre><code>procInstTests</code></pre>
         </article>
         
         <article class="global" data-name="directivesWithCommentsInput">
            <h2>directivesWithCommentsInput</h2>
            <hr />
            
            <pre><code>directivesWithCommentsInput</code></pre>
         </article>
         
         <article class="global" data-name="directivesWithCommentsTokens">
            <h2>directivesWithCommentsTokens</h2>
            <hr />
            
            <pre><code>directivesWithCommentsTokens</code></pre>
         </article>
         
         <article class="global" data-name="testInputHTMLAutoClose">
            <h2>testInputHTMLAutoClose</h2>
            <hr />
            
            <pre><code>testInputHTMLAutoClose</code></pre>
         </article>
         
         <article class="global" data-name="atomValue">
            <h2>atomValue</h2>
            <hr />
            
            <pre><code>atomValue</code></pre>
         </article>
         
         <article class="global" data-name="atomXML">
            <h2>atomXML</h2>
            <hr />
            
            <pre><code>atomXML</code></pre>
         </article>
         
         <article class="global" data-name="Header">
            <h2>Header</h2>
            <hr />
            
            <p>Header is a generic XML header suitable for use with the output of [Marshal].
This is not automatically added to any output of this package,
it is provided as a convenience.</p>
            
            <pre><code>Header</code></pre>
         </article>
         
         <article class="global" data-name="begComment">
            <h2>begComment</h2>
            <hr />
            
            <pre><code>begComment</code></pre>
         </article>
         
         <article class="global" data-name="endComment">
            <h2>endComment</h2>
            <hr />
            
            <pre><code>endComment</code></pre>
         </article>
         
         <article class="global" data-name="endProcInst">
            <h2>endProcInst</h2>
            <hr />
            
            <pre><code>endProcInst</code></pre>
         </article>
         
         <article class="global" data-name="marshalerType">
            <h2>marshalerType</h2>
            <hr />
            
            <pre><code>marshalerType</code></pre>
         </article>
         
         <article class="global" data-name="marshalerAttrType">
            <h2>marshalerAttrType</h2>
            <hr />
            
            <pre><code>marshalerAttrType</code></pre>
         </article>
         
         <article class="global" data-name="textMarshalerType">
            <h2>textMarshalerType</h2>
            <hr />
            
            <pre><code>textMarshalerType</code></pre>
         </article>
         
         <article class="global" data-name="ddBytes">
            <h2>ddBytes</h2>
            <hr />
            
            <pre><code>ddBytes</code></pre>
         </article>
         
         <article class="global" data-name="HyperDrive">
            <h2>HyperDrive</h2>
            <hr />
            
            <pre><code>HyperDrive DriveType</code></pre>
         </article>
         
         <article class="global" data-name="ImprobabilityDrive">
            <h2>ImprobabilityDrive</h2>
            <hr />
            
            <pre><code>ImprobabilityDrive</code></pre>
         </article>
         
         <article class="global" data-name="nilStruct">
            <h2>nilStruct</h2>
            <hr />
            
            <pre><code>nilStruct *Ship</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ Marshaler</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ MarshalerAttr</code></pre>
         </article>
         
         <article class="global" data-name="nameAttr">
            <h2>nameAttr</h2>
            <hr />
            
            <pre><code>nameAttr</code></pre>
         </article>
         
         <article class="global" data-name="ageAttr">
            <h2>ageAttr</h2>
            <hr />
            
            <pre><code>ageAttr</code></pre>
         </article>
         
         <article class="global" data-name="contentsAttr">
            <h2>contentsAttr</h2>
            <hr />
            
            <pre><code>contentsAttr</code></pre>
         </article>
         
         <article class="global" data-name="empty">
            <h2>empty</h2>
            <hr />
            
            <pre><code>empty</code></pre>
         </article>
         
         <article class="global" data-name="marshalTests">
            <h2>marshalTests</h2>
            <hr />
            
            <p>Unless explicitly stated as such (or *Plain), all of the
tests below are two-way tests. When introducing new tests,
please try to make them two-way as well to ensure that
marshaling and unmarshaling are as symmetrical as feasible.</p>
            
            <pre><code>marshalTests</code></pre>
         </article>
         
         <article class="global" data-name="marshalErrorTests">
            <h2>marshalErrorTests</h2>
            <hr />
            
            <pre><code>marshalErrorTests</code></pre>
         </article>
         
         <article class="global" data-name="marshalIndentTests">
            <h2>marshalIndentTests</h2>
            <hr />
            
            <pre><code>marshalIndentTests</code></pre>
         </article>
         
         <article class="global" data-name="encodeTokenTests">
            <h2>encodeTokenTests</h2>
            <hr />
            
            <pre><code>encodeTokenTests</code></pre>
         </article>
         
         <article class="global" data-name="closeTests">
            <h2>closeTests</h2>
            <hr />
            
            <pre><code>closeTests</code></pre>
         </article>
         
         <article class="global" data-name="attrType">
            <h2>attrType</h2>
            <hr />
            
            <pre><code>attrType</code></pre>
         </article>
         
         <article class="global" data-name="unmarshalerType">
            <h2>unmarshalerType</h2>
            <hr />
            
            <pre><code>unmarshalerType</code></pre>
         </article>
         
         <article class="global" data-name="unmarshalerAttrType">
            <h2>unmarshalerAttrType</h2>
            <hr />
            
            <pre><code>unmarshalerAttrType</code></pre>
         </article>
         
         <article class="global" data-name="textUnmarshalerType">
            <h2>textUnmarshalerType</h2>
            <hr />
            
            <pre><code>textUnmarshalerType</code></pre>
         </article>
         
         <article class="global" data-name="maxUnmarshalDepth">
            <h2>maxUnmarshalDepth</h2>
            <hr />
            
            <pre><code>maxUnmarshalDepth</code></pre>
         </article>
         
         <article class="global" data-name="maxUnmarshalDepthWasm">
            <h2>maxUnmarshalDepthWasm</h2>
            <hr />
            
            <pre><code>maxUnmarshalDepthWasm</code></pre>
         </article>
         
         <article class="global" data-name="errUnmarshalDepth">
            <h2>errUnmarshalDepth</h2>
            <hr />
            
            <pre><code>errUnmarshalDepth</code></pre>
         </article>
         
         <article class="global" data-name="atomFeedString">
            <h2>atomFeedString</h2>
            <hr />
            
            <p>hget http://codereview.appspot.com/rss/mine/rsc</p>
            
            <pre><code>atomFeedString</code></pre>
         </article>
         
         <article class="global" data-name="atomFeed">
            <h2>atomFeed</h2>
            <hr />
            
            <pre><code>atomFeed</code></pre>
         </article>
         
         <article class="global" data-name="pathTestString">
            <h2>pathTestString</h2>
            <hr />
            
            <pre><code>pathTestString</code></pre>
         </article>
         
         <article class="global" data-name="pathTests">
            <h2>pathTests</h2>
            <hr />
            
            <pre><code>pathTests</code></pre>
         </article>
         
         <article class="global" data-name="badPathTests">
            <h2>badPathTests</h2>
            <hr />
            
            <pre><code>badPathTests</code></pre>
         </article>
         
         <article class="global" data-name="OK">
            <h2>OK</h2>
            <hr />
            
            <pre><code>OK</code></pre>
         </article>
         
         <article class="global" data-name="withoutNameTypeData">
            <h2>withoutNameTypeData</h2>
            <hr />
            
            <pre><code>withoutNameTypeData</code></pre>
         </article>
         
         <article class="global" data-name="tables">
            <h2>tables</h2>
            <hr />
            
            <pre><code>tables</code></pre>
         </article>
         
         <article class="global" data-name="tableAttrs">
            <h2>tableAttrs</h2>
            <hr />
            
            <pre><code>tableAttrs</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ Unmarshaler</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ UnmarshalerAttr</code></pre>
         </article>
         
         <article class="global" data-name="emptyXML">
            <h2>emptyXML</h2>
            <hr />
            
            <pre><code>emptyXML</code></pre>
         </article>
         
         <article class="global" data-name="whitespaceValuesXML">
            <h2>whitespaceValuesXML</h2>
            <hr />
            
            <pre><code>whitespaceValuesXML</code></pre>
         </article>
         
         <article class="global" data-name="whitespaceAttrsXML">
            <h2>whitespaceAttrsXML</h2>
            <hr />
            
            <pre><code>whitespaceAttrsXML</code></pre>
         </article>
          
         <article class="struct" data-name="typeInfo">
            <h2>type typeInfo struct</h2>
            <hr />
            
            <p>typeInfo holds details for the xml representation of a type.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">xmlname *fieldInfo
fields []fieldInfo</code></pre>
         </article>
         
         <article class="struct" data-name="fieldInfo">
            <h2>type fieldInfo struct</h2>
            <hr />
            
            <p>fieldInfo holds details for the xml representation of a single field.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">idx []int
name string
xmlns string
flags fieldFlags
parents []string</code></pre>
         </article>
         
         <article class="struct" data-name="TagPathError">
            <h2>type TagPathError struct</h2>
            <hr />
            
            <p>A TagPathError represents an error in the unmarshaling process
caused by the use of field tags with conflicting paths.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Struct reflect.Type
Field1 string
Tag1 string
Field2 string
Tag2 string</code></pre>
         </article>
         
         <article class="struct" data-name="SyntaxError">
            <h2>type SyntaxError struct</h2>
            <hr />
            
            <p>A SyntaxError represents a syntax error in the XML input stream.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Msg string
Line int</code></pre>
         </article>
         
         <article class="struct" data-name="Name">
            <h2>type Name struct</h2>
            <hr />
            
            <p>A Name represents an XML name (Local) annotated
with a name space identifier (Space).
In tokens returned by [Decoder.Token], the Space identifier
is given as a canonical URL, not the short prefix used
in the document being parsed.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Space string
Local string</code></pre>
         </article>
         
         <article class="struct" data-name="Attr">
            <h2>type Attr struct</h2>
            <hr />
            
            <p>An Attr represents an attribute in an XML element (Name=Value).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name Name
Value string</code></pre>
         </article>
         
         <article class="struct" data-name="StartElement">
            <h2>type StartElement struct</h2>
            <hr />
            
            <p>A StartElement represents an XML start element.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name Name
Attr []Attr</code></pre>
         </article>
         
         <article class="struct" data-name="EndElement">
            <h2>type EndElement struct</h2>
            <hr />
            
            <p>An EndElement represents an XML end element.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name Name</code></pre>
         </article>
         
         <article class="struct" data-name="ProcInst">
            <h2>type ProcInst struct</h2>
            <hr />
            
            <p>A ProcInst represents an XML processing instruction of the form <?target inst?></p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Target string
Inst []byte</code></pre>
         </article>
         
         <article class="struct" data-name="Decoder">
            <h2>type Decoder struct</h2>
            <hr />
            
            <p>A Decoder represents an XML parser reading a particular input stream.
The parser assumes that its input is encoded in UTF-8.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Strict bool
AutoClose []string
Entity *ast.MapType
CharsetReader func
DefaultSpace string
r io.ByteReader
t TokenReader
buf bytes.Buffer
saved *bytes.Buffer
stk *stack
free *stack
needClose bool
toClose Name
nextToken Token
nextByte int
ns *ast.MapType
err error
line int
linestart int64
offset int64
unmarshalDepth int</code></pre>
         </article>
         
         <article class="struct" data-name="stack">
            <h2>type stack struct</h2>
            <hr />
            
            <p>Parsing state - stack holds old name space translations
and the current set of open elements. The translations to pop when
ending a given tag are *below* it on the stack, which is
more work but forced on us by XML.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">next *stack
kind int
name Name
ok bool</code></pre>
         </article>
         
         <article class="struct" data-name="toks">
            <h2>type toks struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">earlyEOF bool
t []Token</code></pre>
         </article>
         
         <article class="struct" data-name="toksNil">
            <h2>type toksNil struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">returnEOF bool
t []Token</code></pre>
         </article>
         
         <article class="struct" data-name="downCaser">
            <h2>type downCaser struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">t *testing.T
r io.ByteReader</code></pre>
         </article>
         
         <article class="struct" data-name="allScalars">
            <h2>type allScalars struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">True1 bool
True2 bool
False1 bool
False2 bool
Int int
Int8 int8
Int16 int16
Int32 int32
Int64 int64
Uint int
Uint8 uint8
Uint16 uint16
Uint32 uint32
Uint64 uint64
Uintptr uintptr
Float32 float32
Float64 float64
String string
PtrString *string</code></pre>
         </article>
         
         <article class="struct" data-name="item">
            <h2>type item struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">FieldA string</code></pre>
         </article>
         
         <article class="struct" data-name="errWriter">
            <h2>type errWriter struct</h2>
            <hr />
            
            <p>Writer whose Write method always returns an error.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="mapper">
            <h2>type mapper struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">t TokenReader
f func</code></pre>
         </article>
         
         <article class="struct" data-name="tokReader">
            <h2>type tokReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="Failure">
            <h2>type Failure struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="Encoder">
            <h2>type Encoder struct</h2>
            <hr />
            
            <p>An Encoder writes XML data to an output stream.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">p printer</code></pre>
         </article>
         
         <article class="struct" data-name="printer">
            <h2>type printer struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">w *bufio.Writer
encoder *Encoder
seq int
indent string
prefix string
depth int
indentedIn bool
putNewline bool
attrNS *ast.MapType
attrPrefix *ast.MapType
prefixes []string
tags []Name
closed bool
err error</code></pre>
         </article>
         
         <article class="struct" data-name="parentStack">
            <h2>type parentStack struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">p *printer
stack []string</code></pre>
         </article>
         
         <article class="struct" data-name="UnsupportedTypeError">
            <h2>type UnsupportedTypeError struct</h2>
            <hr />
            
            <p>UnsupportedTypeError is returned when [Marshal] encounters a type
that cannot be converted into XML.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Type reflect.Type</code></pre>
         </article>
         
         <article class="struct" data-name="Passenger">
            <h2>type Passenger struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name []string
Weight float32</code></pre>
         </article>
         
         <article class="struct" data-name="Ship">
            <h2>type Ship struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Name string
Pilot string
Drive DriveType
Age uint
Passenger []*Passenger
secret string</code></pre>
         </article>
         
         <article class="struct" data-name="Port">
            <h2>type Port struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Type string
Comment string
Number string</code></pre>
         </article>
         
         <article class="struct" data-name="Domain">
            <h2>type Domain struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Country string
Name []byte
Comment []byte</code></pre>
         </article>
         
         <article class="struct" data-name="Book">
            <h2>type Book struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Title string</code></pre>
         </article>
         
         <article class="struct" data-name="Event">
            <h2>type Event struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Year int</code></pre>
         </article>
         
         <article class="struct" data-name="Movie">
            <h2>type Movie struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Length uint</code></pre>
         </article>
         
         <article class="struct" data-name="Pi">
            <h2>type Pi struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Approximation float32</code></pre>
         </article>
         
         <article class="struct" data-name="Universe">
            <h2>type Universe struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Visible float64</code></pre>
         </article>
         
         <article class="struct" data-name="Particle">
            <h2>type Particle struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
HasMass bool</code></pre>
         </article>
         
         <article class="struct" data-name="Departure">
            <h2>type Departure struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
When time.Time</code></pre>
         </article>
         
         <article class="struct" data-name="SecretAgent">
            <h2>type SecretAgent struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Handle string
Identity string
Obfuscate string</code></pre>
         </article>
         
         <article class="struct" data-name="NestedItems">
            <h2>type NestedItems struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Items []string
Item1 []string</code></pre>
         </article>
         
         <article class="struct" data-name="NestedOrder">
            <h2>type NestedOrder struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Field1 string
Field2 string
Field3 string</code></pre>
         </article>
         
         <article class="struct" data-name="MixedNested">
            <h2>type MixedNested struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
A string
B string
C string
D string</code></pre>
         </article>
         
         <article class="struct" data-name="NilTest">
            <h2>type NilTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">A any
B any
C any</code></pre>
         </article>
         
         <article class="struct" data-name="Service">
            <h2>type Service struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Domain *Domain
Port *Port
Extra1 any
Extra2 any</code></pre>
         </article>
         
         <article class="struct" data-name="EmbedA">
            <h2>type EmbedA struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">EmbedC
EmbedB EmbedB
FieldA string
embedD</code></pre>
         </article>
         
         <article class="struct" data-name="EmbedB">
            <h2>type EmbedB struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">FieldB string
*EmbedC</code></pre>
         </article>
         
         <article class="struct" data-name="EmbedC">
            <h2>type EmbedC struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">FieldA1 string
FieldA2 string
FieldB string
FieldC string</code></pre>
         </article>
         
         <article class="struct" data-name="embedD">
            <h2>type embedD struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">fieldD string
FieldE string</code></pre>
         </article>
         
         <article class="struct" data-name="NameCasing">
            <h2>type NameCasing struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Xy string
XY string
XyA string
XYA string</code></pre>
         </article>
         
         <article class="struct" data-name="NamePrecedence">
            <h2>type NamePrecedence struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName Name
FromTag XMLNameWithoutTag
FromNameVal XMLNameWithoutTag
FromNameTag XMLNameWithTag
InFieldName string</code></pre>
         </article>
         
         <article class="struct" data-name="XMLNameWithTag">
            <h2>type XMLNameWithTag struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName Name
Value string</code></pre>
         </article>
         
         <article class="struct" data-name="XMLNameWithoutTag">
            <h2>type XMLNameWithoutTag struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName Name
Value string</code></pre>
         </article>
         
         <article class="struct" data-name="NameInField">
            <h2>type NameInField struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Foo Name</code></pre>
         </article>
         
         <article class="struct" data-name="AttrTest">
            <h2>type AttrTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Int int
Named int
Float float64
Uint8 uint8
Bool bool
Str string
Bytes []byte</code></pre>
         </article>
         
         <article class="struct" data-name="AttrsTest">
            <h2>type AttrsTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Attrs []Attr
Int int
Named int
Float float64
Uint8 uint8
Bool bool
Str string
Bytes []byte</code></pre>
         </article>
         
         <article class="struct" data-name="OmitAttrTest">
            <h2>type OmitAttrTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Int int
Named int
Float float64
Uint8 uint8
Bool bool
Str string
Bytes []byte
PStr *string</code></pre>
         </article>
         
         <article class="struct" data-name="OmitFieldTest">
            <h2>type OmitFieldTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Int int
Named int
Float float64
Uint8 uint8
Bool bool
Str string
Bytes []byte
PStr *string
Ptr *PresenceTest</code></pre>
         </article>
         
         <article class="struct" data-name="AnyTest">
            <h2>type AnyTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Nested string
AnyField AnyHolder</code></pre>
         </article>
         
         <article class="struct" data-name="AnyOmitTest">
            <h2>type AnyOmitTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Nested string
AnyField *AnyHolder</code></pre>
         </article>
         
         <article class="struct" data-name="AnySliceTest">
            <h2>type AnySliceTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName *ast.StructType
Nested string
AnyField []AnyHolder</code></pre>
         </article>
         
         <article class="struct" data-name="AnyHolder">
            <h2>type AnyHolder struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName Name
XML string</code></pre>
         </article>
         
         <article class="struct" data-name="RecurseA">
            <h2>type RecurseA struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">A string
B *RecurseB</code></pre>
         </article>
         
         <article class="struct" data-name="RecurseB">
            <h2>type RecurseB struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">A *RecurseA
B string</code></pre>
         </article>
         
         <article class="struct" data-name="PresenceTest">
            <h2>type PresenceTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Exists **ast.StructType</code></pre>
         </article>
         
         <article class="struct" data-name="IgnoreTest">
            <h2>type IgnoreTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">PublicSecret string</code></pre>
         </article>
         
         <article class="struct" data-name="Data">
            <h2>type Data struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Bytes []byte
Attr []byte
Custom MyBytes</code></pre>
         </article>
         
         <article class="struct" data-name="Plain">
            <h2>type Plain struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">V any</code></pre>
         </article>
         
         <article class="struct" data-name="EmbedInt">
            <h2>type EmbedInt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">MyInt</code></pre>
         </article>
         
         <article class="struct" data-name="Strings">
            <h2>type Strings struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">X []string</code></pre>
         </article>
         
         <article class="struct" data-name="PointerFieldsTest">
            <h2>type PointerFieldsTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName Name
Name *string
Age *uint
Empty *string
Contents *string</code></pre>
         </article>
         
         <article class="struct" data-name="ChardataEmptyTest">
            <h2>type ChardataEmptyTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName Name
Contents *string</code></pre>
         </article>
         
         <article class="struct" data-name="PointerAnonFields">
            <h2>type PointerAnonFields struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">*MyInt
*NamedType</code></pre>
         </article>
         
         <article class="struct" data-name="MyMarshalerTest">
            <h2>type MyMarshalerTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="MyMarshalerAttrTest">
            <h2>type MyMarshalerAttrTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="MarshalerStruct">
            <h2>type MarshalerStruct struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Foo MyMarshalerAttrTest</code></pre>
         </article>
         
         <article class="struct" data-name="InnerStruct">
            <h2>type InnerStruct struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName Name</code></pre>
         </article>
         
         <article class="struct" data-name="OuterStruct">
            <h2>type OuterStruct struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">InnerStruct
IntAttr int</code></pre>
         </article>
         
         <article class="struct" data-name="OuterNamedStruct">
            <h2>type OuterNamedStruct struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">InnerStruct
XMLName Name
IntAttr int</code></pre>
         </article>
         
         <article class="struct" data-name="OuterNamedOrderedStruct">
            <h2>type OuterNamedOrderedStruct struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName Name
InnerStruct
IntAttr int</code></pre>
         </article>
         
         <article class="struct" data-name="OuterOuterStruct">
            <h2>type OuterOuterStruct struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">OuterStruct</code></pre>
         </article>
         
         <article class="struct" data-name="NestedAndChardata">
            <h2>type NestedAndChardata struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">AB []string
Chardata string</code></pre>
         </article>
         
         <article class="struct" data-name="NestedAndComment">
            <h2>type NestedAndComment struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">AB []string
Comment string</code></pre>
         </article>
         
         <article class="struct" data-name="CDataTest">
            <h2>type CDataTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Chardata string</code></pre>
         </article>
         
         <article class="struct" data-name="NestedAndCData">
            <h2>type NestedAndCData struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">AB []string
CDATA string</code></pre>
         </article>
         
         <article class="struct" data-name="T1">
            <h2>type T1 struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="T2">
            <h2>type T2 struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="IndirComment">
            <h2>type IndirComment struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
Comment *string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="DirectComment">
            <h2>type DirectComment struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
Comment string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IfaceComment">
            <h2>type IfaceComment struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
Comment any
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IndirChardata">
            <h2>type IndirChardata struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
Chardata *string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="DirectChardata">
            <h2>type DirectChardata struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
Chardata string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IfaceChardata">
            <h2>type IfaceChardata struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
Chardata any
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IndirCDATA">
            <h2>type IndirCDATA struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
CDATA *string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="DirectCDATA">
            <h2>type DirectCDATA struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
CDATA string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IfaceCDATA">
            <h2>type IfaceCDATA struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
CDATA any
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IndirInnerXML">
            <h2>type IndirInnerXML struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
InnerXML *string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="DirectInnerXML">
            <h2>type DirectInnerXML struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
InnerXML string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IfaceInnerXML">
            <h2>type IfaceInnerXML struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
InnerXML any
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IndirElement">
            <h2>type IndirElement struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
Element *string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="DirectElement">
            <h2>type DirectElement struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
Element string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IfaceElement">
            <h2>type IfaceElement struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
Element any
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IndirOmitEmpty">
            <h2>type IndirOmitEmpty struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
OmitEmpty *string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="DirectOmitEmpty">
            <h2>type DirectOmitEmpty struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
OmitEmpty string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IfaceOmitEmpty">
            <h2>type IfaceOmitEmpty struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
OmitEmpty any
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IndirAny">
            <h2>type IndirAny struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
Any *string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="DirectAny">
            <h2>type DirectAny struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
Any string
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="IfaceAny">
            <h2>type IfaceAny struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">T1 T1
Any any
T2 T2</code></pre>
         </article>
         
         <article class="struct" data-name="Generic">
            <h2>type Generic struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">X T</code></pre>
         </article>
         
         <article class="struct" data-name="AttrParent">
            <h2>type AttrParent struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">X string</code></pre>
         </article>
         
         <article class="struct" data-name="BadAttr">
            <h2>type BadAttr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="limitedBytesWriter">
            <h2>type limitedBytesWriter struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">w io.Writer
remain int</code></pre>
         </article>
         
         <article class="struct" data-name="InvalidXMLName">
            <h2>type InvalidXMLName struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName Name
Type *ast.StructType</code></pre>
         </article>
         
         <article class="struct" data-name="LayerOne">
            <h2>type LayerOne struct</h2>
            <hr />
            
            <p>Issue 50164. Crash on zero value XML attribute.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName Name
Value *float64
*LayerTwo</code></pre>
         </article>
         
         <article class="struct" data-name="LayerTwo">
            <h2>type LayerTwo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ValueTwo *int</code></pre>
         </article>
         
         <article class="struct" data-name="Feed">
            <h2>type Feed struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName Name
Title string
ID string
Link []Link
Updated time.Time
Author Person
Entry []Entry</code></pre>
         </article>
         
         <article class="struct" data-name="Entry">
            <h2>type Entry struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Title string
ID string
Link []Link
Updated time.Time
Author Person
Summary Text</code></pre>
         </article>
         
         <article class="struct" data-name="Link">
            <h2>type Link struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Rel string
Href string</code></pre>
         </article>
         
         <article class="struct" data-name="Person">
            <h2>type Person struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name string
URI string
Email string
InnerXML string</code></pre>
         </article>
         
         <article class="struct" data-name="Text">
            <h2>type Text struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Type string
Body string</code></pre>
         </article>
         
         <article class="struct" data-name="PathTestItem">
            <h2>type PathTestItem struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Value string</code></pre>
         </article>
         
         <article class="struct" data-name="PathTestA">
            <h2>type PathTestA struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Items []PathTestItem
Before string
After string</code></pre>
         </article>
         
         <article class="struct" data-name="PathTestB">
            <h2>type PathTestB struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Other []PathTestItem
Before string
After string</code></pre>
         </article>
         
         <article class="struct" data-name="PathTestC">
            <h2>type PathTestC struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Values1 []string
Values2 []string
Before string
After string</code></pre>
         </article>
         
         <article class="struct" data-name="PathTestSet">
            <h2>type PathTestSet struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Item1 []PathTestItem</code></pre>
         </article>
         
         <article class="struct" data-name="PathTestD">
            <h2>type PathTestD struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Other PathTestSet
Before string
After string</code></pre>
         </article>
         
         <article class="struct" data-name="PathTestE">
            <h2>type PathTestE struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Underline string
Before string
After string</code></pre>
         </article>
         
         <article class="struct" data-name="BadPathTestA">
            <h2>type BadPathTestA struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">First string
Other string
Second string</code></pre>
         </article>
         
         <article class="struct" data-name="BadPathTestB">
            <h2>type BadPathTestB struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Other string
First string
Second string</code></pre>
         </article>
         
         <article class="struct" data-name="BadPathTestC">
            <h2>type BadPathTestC struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">First string
Second string</code></pre>
         </article>
         
         <article class="struct" data-name="BadPathTestD">
            <h2>type BadPathTestD struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">BadPathEmbeddedA
BadPathEmbeddedB</code></pre>
         </article>
         
         <article class="struct" data-name="BadPathEmbeddedA">
            <h2>type BadPathEmbeddedA struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">First string</code></pre>
         </article>
         
         <article class="struct" data-name="BadPathEmbeddedB">
            <h2>type BadPathEmbeddedB struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Second string</code></pre>
         </article>
         
         <article class="struct" data-name="TestThree">
            <h2>type TestThree struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">XMLName Name
Attr string</code></pre>
         </article>
         
         <article class="struct" data-name="Tables">
            <h2>type Tables struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">HTable string
FTable string</code></pre>
         </article>
         
         <article class="struct" data-name="TableAttrs">
            <h2>type TableAttrs struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">TAttr TAttr</code></pre>
         </article>
         
         <article class="struct" data-name="TAttr">
            <h2>type TAttr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">HTable string
FTable string
Lang string
Other1 string
Other2 string
Other3 string
Other4 string</code></pre>
         </article>
         
         <article class="struct" data-name="MyCharData">
            <h2>type MyCharData struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">body string</code></pre>
         </article>
         
         <article class="struct" data-name="MyAttr">
            <h2>type MyAttr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">attr string</code></pre>
         </article>
         
         <article class="struct" data-name="MyStruct">
            <h2>type MyStruct struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Data *MyCharData
Attr *MyAttr
Data2 MyCharData
Attr2 MyAttr</code></pre>
         </article>
         
         <article class="struct" data-name="Pea">
            <h2>type Pea struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Cotelydon string</code></pre>
         </article>
         
         <article class="struct" data-name="Pod">
            <h2>type Pod struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Pea any</code></pre>
         </article>
         
         <article class="struct" data-name="X">
            <h2>type X struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">D string</code></pre>
         </article>
         
         <article class="struct" data-name="IXField">
            <h2>type IXField struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Five int
NotInnerXML []string</code></pre>
         </article>
         
         <article class="struct" data-name="Child">
            <h2>type Child struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">G *ast.StructType</code></pre>
         </article>
         
         <article class="struct" data-name="ChildToEmbed">
            <h2>type ChildToEmbed struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">X bool</code></pre>
         </article>
         
         <article class="struct" data-name="Parent">
            <h2>type Parent struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">I int
IPtr *int
Is []int
IPtrs []*int
F float32
FPtr *float32
Fs []float32
FPtrs []*float32
B bool
BPtr *bool
Bs []bool
BPtrs []*bool
Bytes []byte
BytesPtr *[]byte
S string
SPtr *string
Ss []string
SPtrs []*string
MyI MyInt
Child Child
Children []Child
ChildPtr *Child
ChildToEmbed</code></pre>
         </article>
         
         <article class="struct" data-name="WhitespaceValuesParent">
            <h2>type WhitespaceValuesParent struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">BFalse bool
BTrue bool
I int
INeg int
I8 int8
I8Neg int8
I16 int16
I16Neg int16
I32 int32
I32Neg int32
I64 int64
I64Neg int64
UI uint
UI8 uint8
UI16 uint16
UI32 uint32
UI64 uint64
F32 float32
F32Neg float32
F64 float64
F64Neg float64</code></pre>
         </article>
         
         <article class="struct" data-name="WhitespaceAttrsParent">
            <h2>type WhitespaceAttrsParent struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">BFalse bool
BTrue bool
I int
INeg int
I8 int8
I8Neg int8
I16 int16
I16Neg int16
I32 int32
I32Neg int32
I64 int64
I64Neg int64
UI uint
UI8 uint8
UI16 uint16
UI32 uint32
UI64 uint64
F32 float32
F32Neg float32
F64 float64
F64Neg float64</code></pre>
         </article>
          
         <article class="function" data-name="getTypeInfo">
            <h2>getTypeInfo</h2>
            <hr />
            
            <p>getTypeInfo returns the typeInfo structure with details necessary
for marshaling and unmarshaling typ.</p>
            
            <pre><code>func getTypeInfo(typ reflect.Type) (*typeInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="structFieldInfo">
            <h2>structFieldInfo</h2>
            <hr />
            
            <p>structFieldInfo builds and returns a fieldInfo for f.</p>
            
            <pre><code>func structFieldInfo(typ reflect.Type, f *reflect.StructField) (*fieldInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="lookupXMLName">
            <h2>lookupXMLName</h2>
            <hr />
            
            <p>lookupXMLName returns the fieldInfo for typ's XMLName field
in case it exists and has a valid xml field tag, otherwise
it returns nil.</p>
            
            <pre><code>func lookupXMLName(typ reflect.Type) xmlname *fieldInfo</code></pre>
         </article>
         
         <article class="function" data-name="addFieldInfo">
            <h2>addFieldInfo</h2>
            <hr />
            
            <p>addFieldInfo adds finfo to tinfo.fields if there are no
conflicts, or if conflicts arise from previous fields that were
obtained from deeper embedded structures than finfo. In the latter
case, the conflicting entries are dropped.
A conflict occurs when the path (parent + name) to a field is
itself a prefix of another path, or when two paths match exactly.
It is okay for field paths to share a common, shorter prefix.</p>
            
            <pre><code>func addFieldInfo(typ reflect.Type, tinfo *typeInfo, newf *fieldInfo) error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="value">
            <h2>value</h2>
            <hr />
            
            <p>value returns v's field value corresponding to finfo.
It's equivalent to v.FieldByIndex(finfo.idx), but when passed
initNilPointers, it initializes and dereferences pointers as necessary.
When passed dontInitNilPointers and a nil pointer is reached, the function
returns a zero reflect.Value.</p>
            
            <pre><code>func value(v reflect.Value, shouldInitNilPointers bool) reflect.Value</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <p>Copy creates a new copy of StartElement.</p>
            
            <pre><code>func Copy() StartElement</code></pre>
         </article>
         
         <article class="function" data-name="End">
            <h2>End</h2>
            <hr />
            
            <p>End returns the corresponding XML end element.</p>
            
            <pre><code>func End() EndElement</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <p>Copy creates a new copy of CharData.</p>
            
            <pre><code>func Copy() CharData</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <p>Copy creates a new copy of Comment.</p>
            
            <pre><code>func Copy() Comment</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <p>Copy creates a new copy of ProcInst.</p>
            
            <pre><code>func Copy() ProcInst</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <p>Copy creates a new copy of Directive.</p>
            
            <pre><code>func Copy() Directive</code></pre>
         </article>
         
         <article class="function" data-name="CopyToken">
            <h2>CopyToken</h2>
            <hr />
            
            <p>CopyToken returns a copy of a Token.</p>
            
            <pre><code>func CopyToken(t Token) Token</code></pre>
         </article>
         
         <article class="function" data-name="NewDecoder">
            <h2>NewDecoder</h2>
            <hr />
            
            <p>NewDecoder creates a new XML parser reading from r.
If r does not implement [io.ByteReader], NewDecoder will
do its own buffering.</p>
            
            <pre><code>func NewDecoder(r io.Reader) *Decoder</code></pre>
         </article>
         
         <article class="function" data-name="NewTokenDecoder">
            <h2>NewTokenDecoder</h2>
            <hr />
            
            <p>NewTokenDecoder creates a new XML parser using an underlying token stream.</p>
            
            <pre><code>func NewTokenDecoder(t TokenReader) *Decoder</code></pre>
         </article>
         
         <article class="function" data-name="Token">
            <h2>Token</h2>
            <hr />
            
            <p>Token returns the next XML token in the input stream.
At the end of the input stream, Token returns nil, [io.EOF].

Slices of bytes in the returned token data refer to the
parser's internal buffer and remain valid only until the next
call to Token. To acquire a copy of the bytes, call [CopyToken]
or the token's Copy method.

Token expands self-closing elements such as <br>
into separate start and end elements returned by successive calls.

Token guarantees that the [StartElement] and [EndElement]
tokens it returns are properly nested and matched:
if Token encounters an unexpected end element
or EOF before all expected end elements,
it will return an error.

If [Decoder.CharsetReader] is called and returns an error,
the error is wrapped and returned.

Token implements XML name spaces as described by
https://www.w3.org/TR/REC-xml-names/. Each of the
[Name] structures contained in the Token has the Space
set to the URL identifying its name space when known.
If Token encounters an unrecognized name space prefix,
it uses the prefix as the Space rather than report an error.</p>
            
            <pre><code>func Token() (Token, error)</code></pre>
         </article>
         
         <article class="function" data-name="translate">
            <h2>translate</h2>
            <hr />
            
            <p>Apply name space translation to name n.
The default name space (for Space=="")
applies only to element names, not to attribute names.</p>
            
            <pre><code>func translate(n *Name, isElementName bool)</code></pre>
         </article>
         
         <article class="function" data-name="switchToReader">
            <h2>switchToReader</h2>
            <hr />
            
            <pre><code>func switchToReader(r io.Reader)</code></pre>
         </article>
         
         <article class="function" data-name="push">
            <h2>push</h2>
            <hr />
            
            <pre><code>func push(kind int) *stack</code></pre>
         </article>
         
         <article class="function" data-name="pop">
            <h2>pop</h2>
            <hr />
            
            <pre><code>func pop() *stack</code></pre>
         </article>
         
         <article class="function" data-name="pushEOF">
            <h2>pushEOF</h2>
            <hr />
            
            <p>Record that after the current element is finished
(that element is already pushed on the stack)
Token should return EOF until popEOF is called.</p>
            
            <pre><code>func pushEOF()</code></pre>
         </article>
         
         <article class="function" data-name="popEOF">
            <h2>popEOF</h2>
            <hr />
            
            <p>Undo a pushEOF.
The element must have been finished, so the EOF should be at the top of the stack.</p>
            
            <pre><code>func popEOF() bool</code></pre>
         </article>
         
         <article class="function" data-name="pushElement">
            <h2>pushElement</h2>
            <hr />
            
            <p>Record that we are starting an element with the given name.</p>
            
            <pre><code>func pushElement(name Name)</code></pre>
         </article>
         
         <article class="function" data-name="pushNs">
            <h2>pushNs</h2>
            <hr />
            
            <p>Record that we are changing the value of ns[local].
The old value is url, ok.</p>
            
            <pre><code>func pushNs(local string, url string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="syntaxError">
            <h2>syntaxError</h2>
            <hr />
            
            <p>Creates a SyntaxError with the current line number.</p>
            
            <pre><code>func syntaxError(msg string) error</code></pre>
         </article>
         
         <article class="function" data-name="popElement">
            <h2>popElement</h2>
            <hr />
            
            <p>Record that we are ending an element with the given name.
The name must match the record at the top of the stack,
which must be a pushElement record.
After popping the element, apply any undo records from
the stack to restore the name translations that existed
before we saw this element.</p>
            
            <pre><code>func popElement(t *EndElement) bool</code></pre>
         </article>
         
         <article class="function" data-name="autoClose">
            <h2>autoClose</h2>
            <hr />
            
            <p>If the top element on the stack is autoclosing and
t is not the end tag, invent the end tag.</p>
            
            <pre><code>func autoClose(t Token) (Token, bool)</code></pre>
         </article>
         
         <article class="function" data-name="RawToken">
            <h2>RawToken</h2>
            <hr />
            
            <p>RawToken is like [Decoder.Token] but does not verify that
start and end elements match and does not translate
name space prefixes to their corresponding URLs.</p>
            
            <pre><code>func RawToken() (Token, error)</code></pre>
         </article>
         
         <article class="function" data-name="rawToken">
            <h2>rawToken</h2>
            <hr />
            
            <pre><code>func rawToken() (Token, error)</code></pre>
         </article>
         
         <article class="function" data-name="attrval">
            <h2>attrval</h2>
            <hr />
            
            <pre><code>func attrval() []byte</code></pre>
         </article>
         
         <article class="function" data-name="space">
            <h2>space</h2>
            <hr />
            
            <p>Skip spaces if any</p>
            
            <pre><code>func space()</code></pre>
         </article>
         
         <article class="function" data-name="getc">
            <h2>getc</h2>
            <hr />
            
            <p>Read a single byte.
If there is no byte to read, return ok==false
and leave the error in d.err.
Maintain line number.</p>
            
            <pre><code>func getc() (b byte, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="InputOffset">
            <h2>InputOffset</h2>
            <hr />
            
            <p>InputOffset returns the input stream byte offset of the current decoder position.
The offset gives the location of the end of the most recently returned token
and the beginning of the next token.</p>
            
            <pre><code>func InputOffset() int64</code></pre>
         </article>
         
         <article class="function" data-name="InputPos">
            <h2>InputPos</h2>
            <hr />
            
            <p>InputPos returns the line of the current decoder position and the 1 based
input position of the line. The position gives the location of the end of the
most recently returned token.</p>
            
            <pre><code>func InputPos() (line int, column int)</code></pre>
         </article>
         
         <article class="function" data-name="savedOffset">
            <h2>savedOffset</h2>
            <hr />
            
            <p>Return saved offset.
If we did ungetc (nextByte >= 0), have to back up one.</p>
            
            <pre><code>func savedOffset() int</code></pre>
         </article>
         
         <article class="function" data-name="mustgetc">
            <h2>mustgetc</h2>
            <hr />
            
            <p>Must read a single byte.
If there is no byte to read,
set d.err to SyntaxError("unexpected EOF")
and return ok==false</p>
            
            <pre><code>func mustgetc() (b byte, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="ungetc">
            <h2>ungetc</h2>
            <hr />
            
            <p>Unread a single byte.</p>
            
            <pre><code>func ungetc(b byte)</code></pre>
         </article>
         
         <article class="function" data-name="text">
            <h2>text</h2>
            <hr />
            
            <p>Read plain text section (XML calls it character data).
If quote >= 0, we are in a quoted string and need to find the matching quote.
If cdata == true, we are in a <![CDATA[ section and need to find ]]>.
On failure return nil and leave the error in d.err.</p>
            
            <pre><code>func text(quote int, cdata bool) []byte</code></pre>
         </article>
         
         <article class="function" data-name="isInCharacterRange">
            <h2>isInCharacterRange</h2>
            <hr />
            
            <p>Decide whether the given rune is in the XML Character Range, per
the Char production of https://www.xml.com/axml/testaxml.htm,
Section 2.2 Characters.</p>
            
            <pre><code>func isInCharacterRange(r rune) inrange bool</code></pre>
         </article>
         
         <article class="function" data-name="nsname">
            <h2>nsname</h2>
            <hr />
            
            <p>Get name space name: name with a : stuck in the middle.
The part before the : is the name space identifier.</p>
            
            <pre><code>func nsname() (name Name, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="name">
            <h2>name</h2>
            <hr />
            
            <p>Get name: /first(first|second)*/
Do not set d.err if the name is missing (unless unexpected EOF is received):
let the caller provide better context.</p>
            
            <pre><code>func name() (s string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="readName">
            <h2>readName</h2>
            <hr />
            
            <p>Read a name and append its bytes to d.buf.
The name is delimited by any single-byte character not valid in names.
All multi-byte characters are accepted; the caller must check their validity.</p>
            
            <pre><code>func readName() ok bool</code></pre>
         </article>
         
         <article class="function" data-name="isNameByte">
            <h2>isNameByte</h2>
            <hr />
            
            <pre><code>func isNameByte(c byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="isName">
            <h2>isName</h2>
            <hr />
            
            <pre><code>func isName(s []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="isNameString">
            <h2>isNameString</h2>
            <hr />
            
            <pre><code>func isNameString(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="EscapeText">
            <h2>EscapeText</h2>
            <hr />
            
            <p>EscapeText writes to w the properly escaped XML equivalent
of the plain text data s.</p>
            
            <pre><code>func EscapeText(w io.Writer, s []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="escapeText">
            <h2>escapeText</h2>
            <hr />
            
            <p>escapeText writes to w the properly escaped XML equivalent
of the plain text data s. If escapeNewline is true, newline
characters will be escaped.</p>
            
            <pre><code>func escapeText(w io.Writer, s []byte, escapeNewline bool) error</code></pre>
         </article>
         
         <article class="function" data-name="EscapeString">
            <h2>EscapeString</h2>
            <hr />
            
            <p>EscapeString writes to p the properly escaped XML equivalent
of the plain text data s.</p>
            
            <pre><code>func EscapeString(s string)</code></pre>
         </article>
         
         <article class="function" data-name="Escape">
            <h2>Escape</h2>
            <hr />
            
            <p>Escape is like [EscapeText] but omits the error return value.
It is provided for backwards compatibility with Go 1.0.
Code targeting Go 1.1 or later should use [EscapeText].</p>
            
            <pre><code>func Escape(w io.Writer, s []byte)</code></pre>
         </article>
         
         <article class="function" data-name="emitCDATA">
            <h2>emitCDATA</h2>
            <hr />
            
            <p>emitCDATA writes to w the CDATA-wrapped plain text data s.
It escapes CDATA directives nested in s.</p>
            
            <pre><code>func emitCDATA(w io.Writer, s []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="procInst">
            <h2>procInst</h2>
            <hr />
            
            <p>procInst parses the `param="..."` or `param='...'`
value out of the provided string, returning "" if not found.</p>
            
            <pre><code>func procInst(param string, s string) string</code></pre>
         </article>
         
         <article class="function" data-name="Token">
            <h2>Token</h2>
            <hr />
            
            <pre><code>func Token() (Token, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecodeEOF">
            <h2>TestDecodeEOF</h2>
            <hr />
            
            <pre><code>func TestDecodeEOF(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Token">
            <h2>Token</h2>
            <hr />
            
            <pre><code>func Token() (Token, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecodeNilToken">
            <h2>TestDecodeNilToken</h2>
            <hr />
            
            <pre><code>func TestDecodeNilToken(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestRawToken">
            <h2>TestRawToken</h2>
            <hr />
            
            <pre><code>func TestRawToken(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNonStrictRawToken">
            <h2>TestNonStrictRawToken</h2>
            <hr />
            
            <pre><code>func TestNonStrictRawToken(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="ReadByte">
            <h2>ReadByte</h2>
            <hr />
            
            <pre><code>func ReadByte() (c byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestRawTokenAltEncoding">
            <h2>TestRawTokenAltEncoding</h2>
            <hr />
            
            <pre><code>func TestRawTokenAltEncoding(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestRawTokenAltEncodingNoConverter">
            <h2>TestRawTokenAltEncodingNoConverter</h2>
            <hr />
            
            <pre><code>func TestRawTokenAltEncodingNoConverter(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testRawToken">
            <h2>testRawToken</h2>
            <hr />
            
            <pre><code>func testRawToken(t *testing.T, d *Decoder, raw string, rawTokens []Token)</code></pre>
         </article>
         
         <article class="function" data-name="TestNestedDirectives">
            <h2>TestNestedDirectives</h2>
            <hr />
            
            <pre><code>func TestNestedDirectives(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestToken">
            <h2>TestToken</h2>
            <hr />
            
            <pre><code>func TestToken(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSyntax">
            <h2>TestSyntax</h2>
            <hr />
            
            <pre><code>func TestSyntax(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInputLinePos">
            <h2>TestInputLinePos</h2>
            <hr />
            
            <pre><code>func TestInputLinePos(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAllScalars">
            <h2>TestAllScalars</h2>
            <hr />
            
            <pre><code>func TestAllScalars(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue68387">
            <h2>TestIssue68387</h2>
            <hr />
            
            <pre><code>func TestIssue68387(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue569">
            <h2>TestIssue569</h2>
            <hr />
            
            <pre><code>func TestIssue569(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnquotedAttrs">
            <h2>TestUnquotedAttrs</h2>
            <hr />
            
            <pre><code>func TestUnquotedAttrs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestValuelessAttrs">
            <h2>TestValuelessAttrs</h2>
            <hr />
            
            <pre><code>func TestValuelessAttrs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCopyTokenCharData">
            <h2>TestCopyTokenCharData</h2>
            <hr />
            
            <pre><code>func TestCopyTokenCharData(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCopyTokenStartElement">
            <h2>TestCopyTokenStartElement</h2>
            <hr />
            
            <pre><code>func TestCopyTokenStartElement(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCopyTokenComment">
            <h2>TestCopyTokenComment</h2>
            <hr />
            
            <pre><code>func TestCopyTokenComment(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSyntaxErrorLineNum">
            <h2>TestSyntaxErrorLineNum</h2>
            <hr />
            
            <pre><code>func TestSyntaxErrorLineNum(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTrailingRawToken">
            <h2>TestTrailingRawToken</h2>
            <hr />
            
            <pre><code>func TestTrailingRawToken(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestTrailingToken">
            <h2>TestTrailingToken</h2>
            <hr />
            
            <pre><code>func TestTrailingToken(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEntityInsideCDATA">
            <h2>TestEntityInsideCDATA</h2>
            <hr />
            
            <pre><code>func TestEntityInsideCDATA(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDisallowedCharacters">
            <h2>TestDisallowedCharacters</h2>
            <hr />
            
            <pre><code>func TestDisallowedCharacters(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIsInCharacterRange">
            <h2>TestIsInCharacterRange</h2>
            <hr />
            
            <pre><code>func TestIsInCharacterRange(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestProcInstEncoding">
            <h2>TestProcInstEncoding</h2>
            <hr />
            
            <pre><code>func TestProcInstEncoding(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDirectivesWithComments">
            <h2>TestDirectivesWithComments</h2>
            <hr />
            
            <pre><code>func TestDirectivesWithComments(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestEscapeTextIOErrors">
            <h2>TestEscapeTextIOErrors</h2>
            <hr />
            
            <pre><code>func TestEscapeTextIOErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEscapeTextInvalidChar">
            <h2>TestEscapeTextInvalidChar</h2>
            <hr />
            
            <pre><code>func TestEscapeTextInvalidChar(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue5880">
            <h2>TestIssue5880</h2>
            <hr />
            
            <pre><code>func TestIssue5880(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue8535">
            <h2>TestIssue8535</h2>
            <hr />
            
            <pre><code>func TestIssue8535(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEncodeXMLNS">
            <h2>TestEncodeXMLNS</h2>
            <hr />
            
            <pre><code>func TestEncodeXMLNS(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="encodeXMLNS1">
            <h2>encodeXMLNS1</h2>
            <hr />
            
            <pre><code>func encodeXMLNS1() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="encodeXMLNS2">
            <h2>encodeXMLNS2</h2>
            <hr />
            
            <pre><code>func encodeXMLNS2() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="encodeXMLNS3">
            <h2>encodeXMLNS3</h2>
            <hr />
            
            <pre><code>func encodeXMLNS3() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="encodeXMLNS4">
            <h2>encodeXMLNS4</h2>
            <hr />
            
            <pre><code>func encodeXMLNS4() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue11405">
            <h2>TestIssue11405</h2>
            <hr />
            
            <pre><code>func TestIssue11405(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue12417">
            <h2>TestIssue12417</h2>
            <hr />
            
            <pre><code>func TestIssue12417(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue7113">
            <h2>TestIssue7113</h2>
            <hr />
            
            <pre><code>func TestIssue7113(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue20396">
            <h2>TestIssue20396</h2>
            <hr />
            
            <pre><code>func TestIssue20396(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue20685">
            <h2>TestIssue20685</h2>
            <hr />
            
            <pre><code>func TestIssue20685(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="tokenMap">
            <h2>tokenMap</h2>
            <hr />
            
            <pre><code>func tokenMap(mapping func) func</code></pre>
         </article>
         
         <article class="function" data-name="Token">
            <h2>Token</h2>
            <hr />
            
            <pre><code>func Token() (Token, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestNewTokenDecoderIdempotent">
            <h2>TestNewTokenDecoderIdempotent</h2>
            <hr />
            
            <pre><code>func TestNewTokenDecoderIdempotent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWrapDecoder">
            <h2>TestWrapDecoder</h2>
            <hr />
            
            <pre><code>func TestWrapDecoder(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Token">
            <h2>Token</h2>
            <hr />
            
            <pre><code>func Token() (Token, error)</code></pre>
         </article>
         
         <article class="function" data-name="UnmarshalXML">
            <h2>UnmarshalXML</h2>
            <hr />
            
            <pre><code>func UnmarshalXML(*Decoder, StartElement) error</code></pre>
         </article>
         
         <article class="function" data-name="TestTokenUnmarshaler">
            <h2>TestTokenUnmarshaler</h2>
            <hr />
            
            <pre><code>func TestTokenUnmarshaler(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testRoundTrip">
            <h2>testRoundTrip</h2>
            <hr />
            
            <pre><code>func testRoundTrip(t *testing.T, input string)</code></pre>
         </article>
         
         <article class="function" data-name="TestRoundTrip">
            <h2>TestRoundTrip</h2>
            <hr />
            
            <pre><code>func TestRoundTrip(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseErrors">
            <h2>TestParseErrors</h2>
            <hr />
            
            <pre><code>func TestParseErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkHTMLAutoClose">
            <h2>BenchmarkHTMLAutoClose</h2>
            <hr />
            
            <pre><code>func BenchmarkHTMLAutoClose(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestHTMLAutoClose">
            <h2>TestHTMLAutoClose</h2>
            <hr />
            
            <pre><code>func TestHTMLAutoClose(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="ParseTime">
            <h2>ParseTime</h2>
            <hr />
            
            <pre><code>func ParseTime(str string) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="NewText">
            <h2>NewText</h2>
            <hr />
            
            <pre><code>func NewText(text string) Text</code></pre>
         </article>
         
         <article class="function" data-name="Marshal">
            <h2>Marshal</h2>
            <hr />
            
            <p>Marshal returns the XML encoding of v.

Marshal handles an array or slice by marshaling each of the elements.
Marshal handles a pointer by marshaling the value it points at or, if the
pointer is nil, by writing nothing. Marshal handles an interface value by
marshaling the value it contains or, if the interface value is nil, by
writing nothing. Marshal handles all other data by writing one or more XML
elements containing the data.

The name for the XML elements is taken from, in order of preference:
  - the tag on the XMLName field, if the data is a struct
  - the value of the XMLName field of type [Name]
  - the tag of the struct field used to obtain the data
  - the name of the struct field used to obtain the data
  - the name of the marshaled type

The XML element for a struct contains marshaled elements for each of the
exported fields of the struct, with these exceptions:
  - the XMLName field, described above, is omitted.
  - a field with tag "-" is omitted.
  - a field with tag "name,attr" becomes an attribute with
    the given name in the XML element.
  - a field with tag ",attr" becomes an attribute with the
    field name in the XML element.
  - a field with tag ",chardata" is written as character data,
    not as an XML element.
  - a field with tag ",cdata" is written as character data
    wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.
  - a field with tag ",innerxml" is written verbatim, not subject
    to the usual marshaling procedure.
  - a field with tag ",comment" is written as an XML comment, not
    subject to the usual marshaling procedure. It must not contain
    the "--" string within it.
  - a field with a tag including the "omitempty" option is omitted
    if the field value is empty. The empty values are false, 0, any
    nil pointer or interface value, and any array, slice, map, or
    string of length zero.
  - an anonymous struct field is handled as if the fields of its
    value were part of the outer struct.
  - an anonymous struct field of interface type is treated the same as having
    that type as its name, rather than being anonymous.
  - a field implementing [Marshaler] is written by calling its MarshalXML
    method.
  - a field implementing [encoding.TextMarshaler] is written by encoding the
    result of its MarshalText method as text.

If a field uses a tag "a>b>c", then the element c will be nested inside
parent elements a and b. Fields that appear next to each other that name
the same parent will be enclosed in one XML element.

If the XML name for a struct field is defined by both the field tag and the
struct's XMLName field, the names must match.

See [MarshalIndent] for an example.

Marshal will return an error if asked to marshal a channel, function, or map.</p>
            
            <pre><code>func Marshal(v any) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="MarshalIndent">
            <h2>MarshalIndent</h2>
            <hr />
            
            <p>MarshalIndent works like [Marshal], but each XML element begins on a new
indented line that starts with prefix and is followed by one or more
copies of indent according to the nesting depth.</p>
            
            <pre><code>func MarshalIndent(v any, prefix string, indent string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewEncoder">
            <h2>NewEncoder</h2>
            <hr />
            
            <p>NewEncoder returns a new encoder that writes to w.</p>
            
            <pre><code>func NewEncoder(w io.Writer) *Encoder</code></pre>
         </article>
         
         <article class="function" data-name="Indent">
            <h2>Indent</h2>
            <hr />
            
            <p>Indent sets the encoder to generate XML in which each element
begins on a new indented line that starts with prefix and is followed by
one or more copies of indent according to the nesting depth.</p>
            
            <pre><code>func Indent(prefix string, indent string)</code></pre>
         </article>
         
         <article class="function" data-name="Encode">
            <h2>Encode</h2>
            <hr />
            
            <p>Encode writes the XML encoding of v to the stream.

See the documentation for [Marshal] for details about the conversion
of Go values to XML.

Encode calls [Encoder.Flush] before returning.</p>
            
            <pre><code>func Encode(v any) error</code></pre>
         </article>
         
         <article class="function" data-name="EncodeElement">
            <h2>EncodeElement</h2>
            <hr />
            
            <p>EncodeElement writes the XML encoding of v to the stream,
using start as the outermost tag in the encoding.

See the documentation for [Marshal] for details about the conversion
of Go values to XML.

EncodeElement calls [Encoder.Flush] before returning.</p>
            
            <pre><code>func EncodeElement(v any, start StartElement) error</code></pre>
         </article>
         
         <article class="function" data-name="EncodeToken">
            <h2>EncodeToken</h2>
            <hr />
            
            <p>EncodeToken writes the given XML token to the stream.
It returns an error if [StartElement] and [EndElement] tokens are not properly matched.

EncodeToken does not call [Encoder.Flush], because usually it is part of a larger operation
such as [Encoder.Encode] or [Encoder.EncodeElement] (or a custom [Marshaler]'s MarshalXML invoked
during those), and those will call Flush when finished.
Callers that create an Encoder and then invoke EncodeToken directly, without
using Encode or EncodeElement, need to call Flush when finished to ensure
that the XML is written to the underlying writer.

EncodeToken allows writing a [ProcInst] with Target set to "xml" only as the first token
in the stream.</p>
            
            <pre><code>func EncodeToken(t Token) error</code></pre>
         </article>
         
         <article class="function" data-name="isValidDirective">
            <h2>isValidDirective</h2>
            <hr />
            
            <p>isValidDirective reports whether dir is a valid directive text,
meaning angle brackets are matched, ignoring comments and strings.</p>
            
            <pre><code>func isValidDirective(dir Directive) bool</code></pre>
         </article>
         
         <article class="function" data-name="Flush">
            <h2>Flush</h2>
            <hr />
            
            <p>Flush flushes any buffered XML to the underlying writer.
See the [Encoder.EncodeToken] documentation for details about when it is necessary.</p>
            
            <pre><code>func Flush() error</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close the Encoder, indicating that no more data will be written. It flushes
any buffered XML to the underlying writer and returns an error if the
written XML is invalid (e.g. by containing unclosed elements).</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="createAttrPrefix">
            <h2>createAttrPrefix</h2>
            <hr />
            
            <p>createAttrPrefix finds the name space prefix attribute to use for the given name space,
defining a new prefix if necessary. It returns the prefix.</p>
            
            <pre><code>func createAttrPrefix(url string) string</code></pre>
         </article>
         
         <article class="function" data-name="deleteAttrPrefix">
            <h2>deleteAttrPrefix</h2>
            <hr />
            
            <p>deleteAttrPrefix removes an attribute name space prefix.</p>
            
            <pre><code>func deleteAttrPrefix(prefix string)</code></pre>
         </article>
         
         <article class="function" data-name="markPrefix">
            <h2>markPrefix</h2>
            <hr />
            
            <pre><code>func markPrefix()</code></pre>
         </article>
         
         <article class="function" data-name="popPrefix">
            <h2>popPrefix</h2>
            <hr />
            
            <pre><code>func popPrefix()</code></pre>
         </article>
         
         <article class="function" data-name="marshalValue">
            <h2>marshalValue</h2>
            <hr />
            
            <p>marshalValue writes one or more XML elements representing val.
If val was obtained from a struct field, finfo must have its details.</p>
            
            <pre><code>func marshalValue(val reflect.Value, finfo *fieldInfo, startTemplate *StartElement) error</code></pre>
         </article>
         
         <article class="function" data-name="marshalAttr">
            <h2>marshalAttr</h2>
            <hr />
            
            <p>marshalAttr marshals an attribute with the given name and value, adding to start.Attr.</p>
            
            <pre><code>func marshalAttr(start *StartElement, name Name, val reflect.Value) error</code></pre>
         </article>
         
         <article class="function" data-name="defaultStart">
            <h2>defaultStart</h2>
            <hr />
            
            <p>defaultStart returns the default start element to use,
given the reflect type, field info, and start template.</p>
            
            <pre><code>func defaultStart(typ reflect.Type, finfo *fieldInfo, startTemplate *StartElement) StartElement</code></pre>
         </article>
         
         <article class="function" data-name="marshalInterface">
            <h2>marshalInterface</h2>
            <hr />
            
            <p>marshalInterface marshals a Marshaler interface value.</p>
            
            <pre><code>func marshalInterface(val Marshaler, start StartElement) error</code></pre>
         </article>
         
         <article class="function" data-name="marshalTextInterface">
            <h2>marshalTextInterface</h2>
            <hr />
            
            <p>marshalTextInterface marshals a TextMarshaler interface value.</p>
            
            <pre><code>func marshalTextInterface(val encoding.TextMarshaler, start StartElement) error</code></pre>
         </article>
         
         <article class="function" data-name="writeStart">
            <h2>writeStart</h2>
            <hr />
            
            <p>writeStart writes the given start element.</p>
            
            <pre><code>func writeStart(start *StartElement) error</code></pre>
         </article>
         
         <article class="function" data-name="writeEnd">
            <h2>writeEnd</h2>
            <hr />
            
            <pre><code>func writeEnd(name Name) error</code></pre>
         </article>
         
         <article class="function" data-name="marshalSimple">
            <h2>marshalSimple</h2>
            <hr />
            
            <pre><code>func marshalSimple(typ reflect.Type, val reflect.Value) (string, []byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="indirect">
            <h2>indirect</h2>
            <hr />
            
            <p>indirect drills into interfaces and pointers, returning the pointed-at value.
If it encounters a nil interface or pointer, indirect returns that nil value.
This can turn into an infinite loop given a cyclic chain,
but it matches the Go 1 behavior.</p>
            
            <pre><code>func indirect(vf reflect.Value) reflect.Value</code></pre>
         </article>
         
         <article class="function" data-name="marshalStruct">
            <h2>marshalStruct</h2>
            <hr />
            
            <pre><code>func marshalStruct(tinfo *typeInfo, val reflect.Value) error</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write implements io.Writer</p>
            
            <pre><code>func Write(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteString">
            <h2>WriteString</h2>
            <hr />
            
            <p>WriteString implements io.StringWriter</p>
            
            <pre><code>func WriteString(s string) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteByte">
            <h2>WriteByte</h2>
            <hr />
            
            <p>WriteByte implements io.ByteWriter</p>
            
            <pre><code>func WriteByte(c byte) error</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close the Encoder, indicating that no more data will be written. It flushes
any buffered XML to the underlying writer and returns an error if the
written XML is invalid (e.g. by containing unclosed elements).</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="cachedWriteError">
            <h2>cachedWriteError</h2>
            <hr />
            
            <p>return the bufio Writer's cached write error</p>
            
            <pre><code>func cachedWriteError() error</code></pre>
         </article>
         
         <article class="function" data-name="writeIndent">
            <h2>writeIndent</h2>
            <hr />
            
            <pre><code>func writeIndent(depthDelta int)</code></pre>
         </article>
         
         <article class="function" data-name="trim">
            <h2>trim</h2>
            <hr />
            
            <p>trim updates the XML context to match the longest common prefix of the stack
and the given parents. A closing tag will be written for every parent
popped. Passing a zero slice or nil will close all the elements.</p>
            
            <pre><code>func trim(parents []string) error</code></pre>
         </article>
         
         <article class="function" data-name="push">
            <h2>push</h2>
            <hr />
            
            <p>push adds parent elements to the stack and writes open tags.</p>
            
            <pre><code>func push(parents []string) error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="isEmptyValue">
            <h2>isEmptyValue</h2>
            <hr />
            
            <pre><code>func isEmptyValue(v reflect.Value) bool</code></pre>
         </article>
         
         <article class="function" data-name="MarshalXML">
            <h2>MarshalXML</h2>
            <hr />
            
            <pre><code>func MarshalXML(e *Encoder, start StartElement) error</code></pre>
         </article>
         
         <article class="function" data-name="MarshalXMLAttr">
            <h2>MarshalXMLAttr</h2>
            <hr />
            
            <pre><code>func MarshalXMLAttr(name Name) (Attr, error)</code></pre>
         </article>
         
         <article class="function" data-name="UnmarshalXMLAttr">
            <h2>UnmarshalXMLAttr</h2>
            <hr />
            
            <pre><code>func UnmarshalXMLAttr(attr Attr) error</code></pre>
         </article>
         
         <article class="function" data-name="ifaceptr">
            <h2>ifaceptr</h2>
            <hr />
            
            <pre><code>func ifaceptr(x any) any</code></pre>
         </article>
         
         <article class="function" data-name="stringptr">
            <h2>stringptr</h2>
            <hr />
            
            <pre><code>func stringptr(x string) *string</code></pre>
         </article>
         
         <article class="function" data-name="TestMarshal">
            <h2>TestMarshal</h2>
            <hr />
            
            <pre><code>func TestMarshal(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMarshalErrors">
            <h2>TestMarshalErrors</h2>
            <hr />
            
            <pre><code>func TestMarshalErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshal">
            <h2>TestUnmarshal</h2>
            <hr />
            
            <p>Do invertibility testing on the various structures that we test</p>
            
            <pre><code>func TestUnmarshal(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMarshalIndent">
            <h2>TestMarshalIndent</h2>
            <hr />
            
            <pre><code>func TestMarshalIndent(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestMarshalWriteErrors">
            <h2>TestMarshalWriteErrors</h2>
            <hr />
            
            <pre><code>func TestMarshalWriteErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMarshalWriteIOErrors">
            <h2>TestMarshalWriteIOErrors</h2>
            <hr />
            
            <pre><code>func TestMarshalWriteIOErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMarshalFlush">
            <h2>TestMarshalFlush</h2>
            <hr />
            
            <pre><code>func TestMarshalFlush(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkMarshal">
            <h2>BenchmarkMarshal</h2>
            <hr />
            
            <pre><code>func BenchmarkMarshal(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkUnmarshal">
            <h2>BenchmarkUnmarshal</h2>
            <hr />
            
            <pre><code>func BenchmarkUnmarshal(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestStructPointerMarshal">
            <h2>TestStructPointerMarshal</h2>
            <hr />
            
            <p>golang.org/issue/6556</p>
            
            <pre><code>func TestStructPointerMarshal(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEncodeToken">
            <h2>TestEncodeToken</h2>
            <hr />
            
            <pre><code>func TestEncodeToken(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestProcInstEncodeToken">
            <h2>TestProcInstEncodeToken</h2>
            <hr />
            
            <pre><code>func TestProcInstEncodeToken(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecodeEncode">
            <h2>TestDecodeEncode</h2>
            <hr />
            
            <pre><code>func TestDecodeEncode(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestRace9796">
            <h2>TestRace9796</h2>
            <hr />
            
            <p>Issue 9796. Used to fail with GORACE="halt_on_error=1" -race.</p>
            
            <pre><code>func TestRace9796(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIsValidDirective">
            <h2>TestIsValidDirective</h2>
            <hr />
            
            <pre><code>func TestIsValidDirective(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSimpleUseOfEncodeToken">
            <h2>TestSimpleUseOfEncodeToken</h2>
            <hr />
            
            <p>Issue 11719. EncodeToken used to silently eat tokens with an invalid type.</p>
            
            <pre><code>func TestSimpleUseOfEncodeToken(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue16158">
            <h2>TestIssue16158</h2>
            <hr />
            
            <p>Issue 16158. Decoder.unmarshalAttr ignores the return value of copyValue.</p>
            
            <pre><code>func TestIssue16158(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInvalidXMLName">
            <h2>TestInvalidXMLName</h2>
            <hr />
            
            <pre><code>func TestInvalidXMLName(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMarshalZeroValue">
            <h2>TestMarshalZeroValue</h2>
            <hr />
            
            <pre><code>func TestMarshalZeroValue(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestClose">
            <h2>TestClose</h2>
            <hr />
            
            <pre><code>func TestClose(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Unmarshal">
            <h2>Unmarshal</h2>
            <hr />
            
            <p>Unmarshal parses the XML-encoded data and stores the result in
the value pointed to by v, which must be an arbitrary struct,
slice, or string. Well-formed data that does not fit into v is
discarded.

Because Unmarshal uses the reflect package, it can only assign
to exported (upper case) fields. Unmarshal uses a case-sensitive
comparison to match XML element names to tag values and struct
field names.

Unmarshal maps an XML element to a struct using the following rules.
In the rules, the tag of a field refers to the value associated with the
key 'xml' in the struct field's tag (see the example above).

  - If the struct has a field of type []byte or string with tag
    ",innerxml", Unmarshal accumulates the raw XML nested inside the
    element in that field. The rest of the rules still apply.

  - If the struct has a field named XMLName of type Name,
    Unmarshal records the element name in that field.

  - If the XMLName field has an associated tag of the form
    "name" or "namespace-URL name", the XML element must have
    the given name (and, optionally, name space) or else Unmarshal
    returns an error.

  - If the XML element has an attribute whose name matches a
    struct field name with an associated tag containing ",attr" or
    the explicit name in a struct field tag of the form "name,attr",
    Unmarshal records the attribute value in that field.

  - If the XML element has an attribute not handled by the previous
    rule and the struct has a field with an associated tag containing
    ",any,attr", Unmarshal records the attribute value in the first
    such field.

  - If the XML element contains character data, that data is
    accumulated in the first struct field that has tag ",chardata".
    The struct field may have type []byte or string.
    If there is no such field, the character data is discarded.

  - If the XML element contains comments, they are accumulated in
    the first struct field that has tag ",comment".  The struct
    field may have type []byte or string. If there is no such
    field, the comments are discarded.

  - If the XML element contains a sub-element whose name matches
    the prefix of a tag formatted as "a" or "a>b>c", unmarshal
    will descend into the XML structure looking for elements with the
    given names, and will map the innermost elements to that struct
    field. A tag starting with ">" is equivalent to one starting
    with the field name followed by ">".

  - If the XML element contains a sub-element whose name matches
    a struct field's XMLName tag and the struct field has no
    explicit name tag as per the previous rule, unmarshal maps
    the sub-element to that struct field.

  - If the XML element contains a sub-element whose name matches a
    field without any mode flags (",attr", ",chardata", etc), Unmarshal
    maps the sub-element to that struct field.

  - If the XML element contains a sub-element that hasn't matched any
    of the above rules and the struct has a field with tag ",any",
    unmarshal maps the sub-element to that struct field.

  - An anonymous struct field is handled as if the fields of its
    value were part of the outer struct.

  - A struct field with tag "-" is never unmarshaled into.

If Unmarshal encounters a field type that implements the Unmarshaler
interface, Unmarshal calls its UnmarshalXML method to produce the value from
the XML element.  Otherwise, if the value implements
[encoding.TextUnmarshaler], Unmarshal calls that value's UnmarshalText method.

Unmarshal maps an XML element to a string or []byte by saving the
concatenation of that element's character data in the string or
[]byte. The saved []byte is never nil.

Unmarshal maps an attribute value to a string or []byte by saving
the value in the string or slice.

Unmarshal maps an attribute value to an [Attr] by saving the attribute,
including its name, in the Attr.

Unmarshal maps an XML element or attribute value to a slice by
extending the length of the slice and mapping the element or attribute
to the newly created value.

Unmarshal maps an XML element or attribute value to a bool by
setting it to the boolean value represented by the string. Whitespace
is trimmed and ignored.

Unmarshal maps an XML element or attribute value to an integer or
floating-point field by setting the field to the result of
interpreting the string value in decimal. There is no check for
overflow. Whitespace is trimmed and ignored.

Unmarshal maps an XML element to a Name by recording the element
name.

Unmarshal maps an XML element to a pointer by setting the pointer
to a freshly allocated value and then mapping the element to that value.

A missing element or empty attribute value will be unmarshaled as a zero value.
If the field is a slice, a zero value will be appended to the field. Otherwise, the
field will be set to its zero value.</p>
            
            <pre><code>func Unmarshal(data []byte, v any) error</code></pre>
         </article>
         
         <article class="function" data-name="Decode">
            <h2>Decode</h2>
            <hr />
            
            <p>Decode works like [Unmarshal], except it reads the decoder
stream to find the start element.</p>
            
            <pre><code>func Decode(v any) error</code></pre>
         </article>
         
         <article class="function" data-name="DecodeElement">
            <h2>DecodeElement</h2>
            <hr />
            
            <p>DecodeElement works like [Unmarshal] except that it takes
a pointer to the start XML element to decode into v.
It is useful when a client reads some raw XML tokens itself
but also wants to defer to [Unmarshal] for some elements.</p>
            
            <pre><code>func DecodeElement(v any, start *StartElement) error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="receiverType">
            <h2>receiverType</h2>
            <hr />
            
            <p>receiverType returns the receiver type to use in an expression like "%s.MethodName".</p>
            
            <pre><code>func receiverType(val any) string</code></pre>
         </article>
         
         <article class="function" data-name="unmarshalInterface">
            <h2>unmarshalInterface</h2>
            <hr />
            
            <p>unmarshalInterface unmarshals a single XML element into val.
start is the opening tag of the element.</p>
            
            <pre><code>func unmarshalInterface(val Unmarshaler, start *StartElement) error</code></pre>
         </article>
         
         <article class="function" data-name="unmarshalTextInterface">
            <h2>unmarshalTextInterface</h2>
            <hr />
            
            <p>unmarshalTextInterface unmarshals a single XML element into val.
The chardata contained in the element (but not its children)
is passed to the text unmarshaler.</p>
            
            <pre><code>func unmarshalTextInterface(val encoding.TextUnmarshaler) error</code></pre>
         </article>
         
         <article class="function" data-name="unmarshalAttr">
            <h2>unmarshalAttr</h2>
            <hr />
            
            <p>unmarshalAttr unmarshals a single XML attribute into val.</p>
            
            <pre><code>func unmarshalAttr(val reflect.Value, attr Attr) error</code></pre>
         </article>
         
         <article class="function" data-name="unmarshal">
            <h2>unmarshal</h2>
            <hr />
            
            <p>Unmarshal a single XML element into val.</p>
            
            <pre><code>func unmarshal(val reflect.Value, start *StartElement, depth int) error</code></pre>
         </article>
         
         <article class="function" data-name="copyValue">
            <h2>copyValue</h2>
            <hr />
            
            <pre><code>func copyValue(dst reflect.Value, src []byte) err error</code></pre>
         </article>
         
         <article class="function" data-name="unmarshalPath">
            <h2>unmarshalPath</h2>
            <hr />
            
            <p>unmarshalPath walks down an XML structure looking for wanted
paths, and calls unmarshal on them.
The consumed result tells whether XML elements have been consumed
from the Decoder until start's matching end element, or if it's
still untouched because start is uninteresting for sv's fields.</p>
            
            <pre><code>func unmarshalPath(tinfo *typeInfo, sv reflect.Value, parents []string, start *StartElement, depth int) (consumed bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Skip">
            <h2>Skip</h2>
            <hr />
            
            <p>Skip reads tokens until it has consumed the end element
matching the most recent start element already consumed,
skipping nested structures.
It returns nil if it finds an end element matching the start
element; otherwise it returns an error describing the problem.</p>
            
            <pre><code>func Skip() error</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalFeed">
            <h2>TestUnmarshalFeed</h2>
            <hr />
            
            <pre><code>func TestUnmarshalFeed(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalPaths">
            <h2>TestUnmarshalPaths</h2>
            <hr />
            
            <pre><code>func TestUnmarshalPaths(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalBadPaths">
            <h2>TestUnmarshalBadPaths</h2>
            <hr />
            
            <pre><code>func TestUnmarshalBadPaths(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalWithoutNameType">
            <h2>TestUnmarshalWithoutNameType</h2>
            <hr />
            
            <pre><code>func TestUnmarshalWithoutNameType(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalAttr">
            <h2>TestUnmarshalAttr</h2>
            <hr />
            
            <pre><code>func TestUnmarshalAttr(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalNS">
            <h2>TestUnmarshalNS</h2>
            <hr />
            
            <pre><code>func TestUnmarshalNS(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMarshalNS">
            <h2>TestMarshalNS</h2>
            <hr />
            
            <pre><code>func TestMarshalNS(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalNSAttr">
            <h2>TestUnmarshalNSAttr</h2>
            <hr />
            
            <pre><code>func TestUnmarshalNSAttr(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMarshalNSAttr">
            <h2>TestMarshalNSAttr</h2>
            <hr />
            
            <pre><code>func TestMarshalNSAttr(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="UnmarshalXML">
            <h2>UnmarshalXML</h2>
            <hr />
            
            <pre><code>func UnmarshalXML(d *Decoder, start StartElement) error</code></pre>
         </article>
         
         <article class="function" data-name="UnmarshalXMLAttr">
            <h2>UnmarshalXMLAttr</h2>
            <hr />
            
            <pre><code>func UnmarshalXMLAttr(attr Attr) error</code></pre>
         </article>
         
         <article class="function" data-name="UnmarshalXMLAttr">
            <h2>UnmarshalXMLAttr</h2>
            <hr />
            
            <pre><code>func UnmarshalXMLAttr(attr Attr) error</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshaler">
            <h2>TestUnmarshaler</h2>
            <hr />
            
            <pre><code>func TestUnmarshaler(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalIntoInterface">
            <h2>TestUnmarshalIntoInterface</h2>
            <hr />
            
            <p>https://golang.org/issue/6836</p>
            
            <pre><code>func TestUnmarshalIntoInterface(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestMalformedComment">
            <h2>TestMalformedComment</h2>
            <hr />
            
            <p>Issue 11112. Unmarshal must reject invalid comments.</p>
            
            <pre><code>func TestMalformedComment(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInvalidInnerXMLType">
            <h2>TestInvalidInnerXMLType</h2>
            <hr />
            
            <p>Issue 15600. ",innerxml" on a field that can't hold it.</p>
            
            <pre><code>func TestInvalidInnerXMLType(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalEmptyValues">
            <h2>TestUnmarshalEmptyValues</h2>
            <hr />
            
            <p>golang.org/issues/13417</p>
            
            <pre><code>func TestUnmarshalEmptyValues(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalWhitespaceValues">
            <h2>TestUnmarshalWhitespaceValues</h2>
            <hr />
            
            <p>golang.org/issues/22146</p>
            
            <pre><code>func TestUnmarshalWhitespaceValues(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalWhitespaceAttrs">
            <h2>TestUnmarshalWhitespaceAttrs</h2>
            <hr />
            
            <p>golang.org/issues/22146</p>
            
            <pre><code>func TestUnmarshalWhitespaceAttrs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnmarshalIntoNil">
            <h2>TestUnmarshalIntoNil</h2>
            <hr />
            
            <p>golang.org/issues/53350</p>
            
            <pre><code>func TestUnmarshalIntoNil(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCVE202228131">
            <h2>TestCVE202228131</h2>
            <hr />
            
            <pre><code>func TestCVE202228131(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestCVE202230633">
            <h2>TestCVE202230633</h2>
            <hr />
            
            <pre><code>func TestCVE202230633(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
