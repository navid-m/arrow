<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>xml - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>xml</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"bufio"
"bytes"
"encoding"
"errors"
"fmt"
"io"
"reflect"
"strconv"
"strings"
"bytes"
"encoding"
"errors"
"fmt"
"reflect"
"runtime"
"strconv"
"strings"
"fmt"
"reflect"
"strings"
"sync"
"bufio"
"bytes"
"errors"
"fmt"
"io"
"strconv"
"strings"
"unicode"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="HTMLAutoClose" data-name="HTMLAutoClose">
               <h3>
                  HTMLAutoClose 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#HTMLAutoClose" class="anchor" title="Link to HTMLAutoClose">#</a>
               </h3>
               
                  <p class="doc-comment">HTMLAutoClose is the set of HTML elements that
should be considered to close automatically.
See the [Decoder.Strict] and [Decoder.Entity] fields' documentation.</p>
               
               <pre><code class="language-go">var HTMLAutoClose []string = htmlAutoClose</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="HTMLEntity" data-name="HTMLEntity">
               <h3>
                  HTMLEntity 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#HTMLEntity" class="anchor" title="Link to HTMLEntity">#</a>
               </h3>
               
                  <p class="doc-comment">HTMLEntity is an entity map containing translations for the
standard HTML entity characters.
See the [Decoder.Strict] and [Decoder.Entity] fields' documentation.</p>
               
               <pre><code class="language-go">var HTMLEntity map[string]string = htmlEntity</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Header" data-name="Header">
               <h3>
                  Header 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Header" class="anchor" title="Link to Header">#</a>
               </h3>
               
                  <p class="doc-comment">Header is a generic XML header suitable for use with the output of [Marshal].
This is not automatically added to any output of this package,
it is provided as a convenience.</p>
               
               <pre><code class="language-go">const Header = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="attrType" data-name="attrType">
               <h3>
                  attrType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#attrType" class="anchor" title="Link to attrType">#</a>
               </h3>
               
               <pre><code class="language-go">var attrType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="begComment" data-name="begComment">
               <h3>
                  begComment 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#begComment" class="anchor" title="Link to begComment">#</a>
               </h3>
               
               <pre><code class="language-go">var begComment = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cdataEnd" data-name="cdataEnd">
               <h3>
                  cdataEnd 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cdataEnd" class="anchor" title="Link to cdataEnd">#</a>
               </h3>
               
               <pre><code class="language-go">var cdataEnd = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cdataEscape" data-name="cdataEscape">
               <h3>
                  cdataEscape 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cdataEscape" class="anchor" title="Link to cdataEscape">#</a>
               </h3>
               
               <pre><code class="language-go">var cdataEscape = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cdataStart" data-name="cdataStart">
               <h3>
                  cdataStart 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cdataStart" class="anchor" title="Link to cdataStart">#</a>
               </h3>
               
               <pre><code class="language-go">var cdataStart = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ddBytes" data-name="ddBytes">
               <h3>
                  ddBytes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ddBytes" class="anchor" title="Link to ddBytes">#</a>
               </h3>
               
               <pre><code class="language-go">var ddBytes = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dontInitNilPointers" data-name="dontInitNilPointers">
               <h3>
                  dontInitNilPointers 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#dontInitNilPointers" class="anchor" title="Link to dontInitNilPointers">#</a>
               </h3>
               
               <pre><code class="language-go">const dontInitNilPointers = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="endComment" data-name="endComment">
               <h3>
                  endComment 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#endComment" class="anchor" title="Link to endComment">#</a>
               </h3>
               
               <pre><code class="language-go">var endComment = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="endProcInst" data-name="endProcInst">
               <h3>
                  endProcInst 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#endProcInst" class="anchor" title="Link to endProcInst">#</a>
               </h3>
               
               <pre><code class="language-go">var endProcInst = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="entity" data-name="entity">
               <h3>
                  entity 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#entity" class="anchor" title="Link to entity">#</a>
               </h3>
               
               <pre><code class="language-go">var entity = map[string]rune{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errRawToken" data-name="errRawToken">
               <h3>
                  errRawToken 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errRawToken" class="anchor" title="Link to errRawToken">#</a>
               </h3>
               
               <pre><code class="language-go">var errRawToken = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errUnmarshalDepth" data-name="errUnmarshalDepth">
               <h3>
                  errUnmarshalDepth 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errUnmarshalDepth" class="anchor" title="Link to errUnmarshalDepth">#</a>
               </h3>
               
               <pre><code class="language-go">var errUnmarshalDepth = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escAmp" data-name="escAmp">
               <h3>
                  escAmp 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#escAmp" class="anchor" title="Link to escAmp">#</a>
               </h3>
               
               <pre><code class="language-go">var escAmp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escApos" data-name="escApos">
               <h3>
                  escApos 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#escApos" class="anchor" title="Link to escApos">#</a>
               </h3>
               
               <pre><code class="language-go">var escApos = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escCR" data-name="escCR">
               <h3>
                  escCR 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#escCR" class="anchor" title="Link to escCR">#</a>
               </h3>
               
               <pre><code class="language-go">var escCR = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escFFFD" data-name="escFFFD">
               <h3>
                  escFFFD 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#escFFFD" class="anchor" title="Link to escFFFD">#</a>
               </h3>
               
               <pre><code class="language-go">var escFFFD = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escGT" data-name="escGT">
               <h3>
                  escGT 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#escGT" class="anchor" title="Link to escGT">#</a>
               </h3>
               
               <pre><code class="language-go">var escGT = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escLT" data-name="escLT">
               <h3>
                  escLT 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#escLT" class="anchor" title="Link to escLT">#</a>
               </h3>
               
               <pre><code class="language-go">var escLT = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escNL" data-name="escNL">
               <h3>
                  escNL 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#escNL" class="anchor" title="Link to escNL">#</a>
               </h3>
               
               <pre><code class="language-go">var escNL = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escQuot" data-name="escQuot">
               <h3>
                  escQuot 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#escQuot" class="anchor" title="Link to escQuot">#</a>
               </h3>
               
               <pre><code class="language-go">var escQuot = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="escTab" data-name="escTab">
               <h3>
                  escTab 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#escTab" class="anchor" title="Link to escTab">#</a>
               </h3>
               
               <pre><code class="language-go">var escTab = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fAny" data-name="fAny">
               <h3>
                  fAny 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fAny" class="anchor" title="Link to fAny">#</a>
               </h3>
               
               <pre><code class="language-go">const fAny</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fAttr" data-name="fAttr">
               <h3>
                  fAttr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fAttr" class="anchor" title="Link to fAttr">#</a>
               </h3>
               
               <pre><code class="language-go">const fAttr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fCDATA" data-name="fCDATA">
               <h3>
                  fCDATA 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fCDATA" class="anchor" title="Link to fCDATA">#</a>
               </h3>
               
               <pre><code class="language-go">const fCDATA</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fCharData" data-name="fCharData">
               <h3>
                  fCharData 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fCharData" class="anchor" title="Link to fCharData">#</a>
               </h3>
               
               <pre><code class="language-go">const fCharData</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fComment" data-name="fComment">
               <h3>
                  fComment 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fComment" class="anchor" title="Link to fComment">#</a>
               </h3>
               
               <pre><code class="language-go">const fComment</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fElement" data-name="fElement">
               <h3>
                  fElement 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fElement" class="anchor" title="Link to fElement">#</a>
               </h3>
               
               <pre><code class="language-go">const fElement fieldFlags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fInnerXML" data-name="fInnerXML">
               <h3>
                  fInnerXML 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fInnerXML" class="anchor" title="Link to fInnerXML">#</a>
               </h3>
               
               <pre><code class="language-go">const fInnerXML</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fMode" data-name="fMode">
               <h3>
                  fMode 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fMode" class="anchor" title="Link to fMode">#</a>
               </h3>
               
               <pre><code class="language-go">const fMode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="fOmitEmpty" data-name="fOmitEmpty">
               <h3>
                  fOmitEmpty 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#fOmitEmpty" class="anchor" title="Link to fOmitEmpty">#</a>
               </h3>
               
               <pre><code class="language-go">const fOmitEmpty</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="first" data-name="first">
               <h3>
                  first 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#first" class="anchor" title="Link to first">#</a>
               </h3>
               
               <pre><code class="language-go">var first = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="htmlAutoClose" data-name="htmlAutoClose">
               <h3>
                  htmlAutoClose 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#htmlAutoClose" class="anchor" title="Link to htmlAutoClose">#</a>
               </h3>
               
               <pre><code class="language-go">var htmlAutoClose = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="htmlEntity" data-name="htmlEntity">
               <h3>
                  htmlEntity 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#htmlEntity" class="anchor" title="Link to htmlEntity">#</a>
               </h3>
               
               <pre><code class="language-go">var htmlEntity = map[string]string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initNilPointers" data-name="initNilPointers">
               <h3>
                  initNilPointers 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#initNilPointers" class="anchor" title="Link to initNilPointers">#</a>
               </h3>
               
               <pre><code class="language-go">const initNilPointers = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="marshalerAttrType" data-name="marshalerAttrType">
               <h3>
                  marshalerAttrType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#marshalerAttrType" class="anchor" title="Link to marshalerAttrType">#</a>
               </h3>
               
               <pre><code class="language-go">var marshalerAttrType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="marshalerType" data-name="marshalerType">
               <h3>
                  marshalerType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#marshalerType" class="anchor" title="Link to marshalerType">#</a>
               </h3>
               
               <pre><code class="language-go">var marshalerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxUnmarshalDepth" data-name="maxUnmarshalDepth">
               <h3>
                  maxUnmarshalDepth 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxUnmarshalDepth" class="anchor" title="Link to maxUnmarshalDepth">#</a>
               </h3>
               
               <pre><code class="language-go">const maxUnmarshalDepth = 10000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="maxUnmarshalDepthWasm" data-name="maxUnmarshalDepthWasm">
               <h3>
                  maxUnmarshalDepthWasm 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#maxUnmarshalDepthWasm" class="anchor" title="Link to maxUnmarshalDepthWasm">#</a>
               </h3>
               
               <pre><code class="language-go">const maxUnmarshalDepthWasm = 5000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="nameType" data-name="nameType">
               <h3>
                  nameType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#nameType" class="anchor" title="Link to nameType">#</a>
               </h3>
               
               <pre><code class="language-go">var nameType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="second" data-name="second">
               <h3>
                  second 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#second" class="anchor" title="Link to second">#</a>
               </h3>
               
               <pre><code class="language-go">var second = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stkEOF" data-name="stkEOF">
               <h3>
                  stkEOF 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stkEOF" class="anchor" title="Link to stkEOF">#</a>
               </h3>
               
               <pre><code class="language-go">const stkEOF</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stkNs" data-name="stkNs">
               <h3>
                  stkNs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stkNs" class="anchor" title="Link to stkNs">#</a>
               </h3>
               
               <pre><code class="language-go">const stkNs</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="stkStart" data-name="stkStart">
               <h3>
                  stkStart 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#stkStart" class="anchor" title="Link to stkStart">#</a>
               </h3>
               
               <pre><code class="language-go">const stkStart = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="textMarshalerType" data-name="textMarshalerType">
               <h3>
                  textMarshalerType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#textMarshalerType" class="anchor" title="Link to textMarshalerType">#</a>
               </h3>
               
               <pre><code class="language-go">var textMarshalerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="textUnmarshalerType" data-name="textUnmarshalerType">
               <h3>
                  textUnmarshalerType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#textUnmarshalerType" class="anchor" title="Link to textUnmarshalerType">#</a>
               </h3>
               
               <pre><code class="language-go">var textUnmarshalerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="tinfoMap" data-name="tinfoMap">
               <h3>
                  tinfoMap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#tinfoMap" class="anchor" title="Link to tinfoMap">#</a>
               </h3>
               
               <pre><code class="language-go">var tinfoMap sync.Map</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unmarshalerAttrType" data-name="unmarshalerAttrType">
               <h3>
                  unmarshalerAttrType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#unmarshalerAttrType" class="anchor" title="Link to unmarshalerAttrType">#</a>
               </h3>
               
               <pre><code class="language-go">var unmarshalerAttrType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="unmarshalerType" data-name="unmarshalerType">
               <h3>
                  unmarshalerType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#unmarshalerType" class="anchor" title="Link to unmarshalerType">#</a>
               </h3>
               
               <pre><code class="language-go">var unmarshalerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xmlName" data-name="xmlName">
               <h3>
                  xmlName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xmlName" class="anchor" title="Link to xmlName">#</a>
               </h3>
               
               <pre><code class="language-go">const xmlName = "XMLName"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xmlPrefix" data-name="xmlPrefix">
               <h3>
                  xmlPrefix 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xmlPrefix" class="anchor" title="Link to xmlPrefix">#</a>
               </h3>
               
               <pre><code class="language-go">const xmlPrefix = "xml"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xmlURL" data-name="xmlURL">
               <h3>
                  xmlURL 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xmlURL" class="anchor" title="Link to xmlURL">#</a>
               </h3>
               
               <pre><code class="language-go">const xmlURL = "http://www.w3.org/XML/1998/namespace"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="xmlnsPrefix" data-name="xmlnsPrefix">
               <h3>
                  xmlnsPrefix 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#xmlnsPrefix" class="anchor" title="Link to xmlnsPrefix">#</a>
               </h3>
               
               <pre><code class="language-go">const xmlnsPrefix = "xmlns"</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="CharData" data-name="CharData">
               <h3>
                  CharData
                  <span class="badge type-badge">type</span>
                  <a href="#CharData" class="anchor" title="Link to CharData">#</a>
               </h3>
               
               <p>A CharData represents XML character data (raw text),
in which XML escape sequences have been replaced by
the characters they represent.</p>
               
               <pre><code class="language-go">type CharData []byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Comment" data-name="Comment">
               <h3>
                  Comment
                  <span class="badge type-badge">type</span>
                  <a href="#Comment" class="anchor" title="Link to Comment">#</a>
               </h3>
               
               <p>A Comment represents an XML comment of the form <!--comment-->.
The bytes do not include the <!-- and --> comment markers.</p>
               
               <pre><code class="language-go">type Comment []byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Directive" data-name="Directive">
               <h3>
                  Directive
                  <span class="badge type-badge">type</span>
                  <a href="#Directive" class="anchor" title="Link to Directive">#</a>
               </h3>
               
               <p>A Directive represents an XML directive of the form <!text>.
The bytes do not include the <! and > markers.</p>
               
               <pre><code class="language-go">type Directive []byte</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Token" data-name="Token">
               <h3>
                  Token
                  <span class="badge type-badge">type</span>
                  <a href="#Token" class="anchor" title="Link to Token">#</a>
               </h3>
               
               <p>A Token is an interface holding one of the token types:
[StartElement], [EndElement], [CharData], [Comment], [ProcInst], or [Directive].</p>
               
               <pre><code class="language-go">type Token any</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="UnmarshalError" data-name="UnmarshalError">
               <h3>
                  UnmarshalError
                  <span class="badge type-badge">type</span>
                  <a href="#UnmarshalError" class="anchor" title="Link to UnmarshalError">#</a>
               </h3>
               
               <p>An UnmarshalError represents an error in the unmarshaling process.</p>
               
               <pre><code class="language-go">type UnmarshalError string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="fieldFlags" data-name="fieldFlags">
               <h3>
                  fieldFlags
                  <span class="badge type-badge">type</span>
                  <a href="#fieldFlags" class="anchor" title="Link to fieldFlags">#</a>
               </h3>
               
               <pre><code class="language-go">type fieldFlags int</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Marshaler" data-name="Marshaler">
               <h3>
                  Marshaler
                  <span class="badge interface-badge">interface</span>
                  <a href="#Marshaler" class="anchor" title="Link to Marshaler">#</a>
               </h3>
               
               <p>Marshaler is the interface implemented by objects that can marshal
themselves into valid XML elements.
MarshalXML encodes the receiver as zero or more XML elements.
By convention, arrays or slices are typically encoded as a sequence
of elements, one per entry.
Using start as the element tag is not required, but doing so
will enable [Unmarshal] to match the XML elements to the correct
struct field.
One common implementation strategy is to construct a separate
value with a layout corresponding to the desired XML and then
to encode it using e.EncodeElement.
Another common strategy is to use repeated calls to e.EncodeToken
to generate the XML output one token at a time.
The sequence of encoded tokens must make up zero or more valid
XML elements.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Marshaler interface {
MarshalXML(e *Encoder, start StartElement) error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="MarshalerAttr" data-name="MarshalerAttr">
               <h3>
                  MarshalerAttr
                  <span class="badge interface-badge">interface</span>
                  <a href="#MarshalerAttr" class="anchor" title="Link to MarshalerAttr">#</a>
               </h3>
               
               <p>MarshalerAttr is the interface implemented by objects that can marshal
themselves into valid XML attributes.
MarshalXMLAttr returns an XML attribute with the encoded value of the receiver.
Using name as the attribute name is not required, but doing so
will enable [Unmarshal] to match the attribute to the correct
struct field.
If MarshalXMLAttr returns the zero attribute [Attr]{}, no attribute
will be generated in the output.
MarshalXMLAttr is used only for struct fields with the
"attr" option in the field tag.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type MarshalerAttr interface {
MarshalXMLAttr(name Name) (Attr, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="TokenReader" data-name="TokenReader">
               <h3>
                  TokenReader
                  <span class="badge interface-badge">interface</span>
                  <a href="#TokenReader" class="anchor" title="Link to TokenReader">#</a>
               </h3>
               
               <p>A TokenReader is anything that can decode a stream of XML tokens, including a
[Decoder].
When Token encounters an error or end-of-file condition after successfully
reading a token, it returns the token. It may return the (non-nil) error from
the same call or return the error (and a nil token) from a subsequent call.
An instance of this general case is that a TokenReader returning a non-nil
token at the end of the token stream may return either io.EOF or a nil error.
The next Read should return nil, [io.EOF].
Implementations of Token are discouraged from returning a nil token with a
nil error. Callers should treat a return of nil, nil as indicating that
nothing happened; in particular it does not indicate EOF.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type TokenReader interface {
Token() (Token, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Unmarshaler" data-name="Unmarshaler">
               <h3>
                  Unmarshaler
                  <span class="badge interface-badge">interface</span>
                  <a href="#Unmarshaler" class="anchor" title="Link to Unmarshaler">#</a>
               </h3>
               
               <p>Unmarshaler is the interface implemented by objects that can unmarshal
an XML element description of themselves.
UnmarshalXML decodes a single XML element
beginning with the given start element.
If it returns an error, the outer call to Unmarshal stops and
returns that error.
UnmarshalXML must consume exactly one XML element.
One common implementation strategy is to unmarshal into
a separate value with a layout matching the expected XML
using d.DecodeElement, and then to copy the data from
that value into the receiver.
Another common strategy is to use d.Token to process the
XML object one token at a time.
UnmarshalXML may not use d.RawToken.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Unmarshaler interface {
UnmarshalXML(d *Decoder, start StartElement) error
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="UnmarshalerAttr" data-name="UnmarshalerAttr">
               <h3>
                  UnmarshalerAttr
                  <span class="badge interface-badge">interface</span>
                  <a href="#UnmarshalerAttr" class="anchor" title="Link to UnmarshalerAttr">#</a>
               </h3>
               
               <p>UnmarshalerAttr is the interface implemented by objects that can unmarshal
an XML attribute description of themselves.
UnmarshalXMLAttr decodes a single XML attribute.
If it returns an error, the outer call to [Unmarshal] stops and
returns that error.
UnmarshalXMLAttr is used only for struct fields with the
"attr" option in the field tag.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type UnmarshalerAttr interface {
UnmarshalXMLAttr(attr Attr) error
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Attr" data-name="Attr">
               <h3>
                  Attr
                  <span class="badge">struct</span>
                  <a href="#Attr" class="anchor" title="Link to Attr">#</a>
               </h3>
               
               <p>An Attr represents an attribute in an XML element (Name=Value).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Attr struct {
Name Name
Value string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Decoder" data-name="Decoder">
               <h3>
                  Decoder
                  <span class="badge">struct</span>
                  <a href="#Decoder" class="anchor" title="Link to Decoder">#</a>
               </h3>
               
               <p>A Decoder represents an XML parser reading a particular input stream.
The parser assumes that its input is encoded in UTF-8.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Decoder struct {
Strict bool
AutoClose []string
Entity map[string]string
CharsetReader func(charset string, input io.Reader) (io.Reader, error)
DefaultSpace string
r io.ByteReader
t TokenReader
buf bytes.Buffer
saved *bytes.Buffer
stk *stack
free *stack
needClose bool
toClose Name
nextToken Token
nextByte int
ns map[string]string
err error
line int
linestart int64
offset int64
unmarshalDepth int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Encoder" data-name="Encoder">
               <h3>
                  Encoder
                  <span class="badge">struct</span>
                  <a href="#Encoder" class="anchor" title="Link to Encoder">#</a>
               </h3>
               
               <p>An Encoder writes XML data to an output stream.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Encoder struct {
p printer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="EndElement" data-name="EndElement">
               <h3>
                  EndElement
                  <span class="badge">struct</span>
                  <a href="#EndElement" class="anchor" title="Link to EndElement">#</a>
               </h3>
               
               <p>An EndElement represents an XML end element.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type EndElement struct {
Name Name
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name
                  <span class="badge">struct</span>
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <p>A Name represents an XML name (Local) annotated
with a name space identifier (Space).
In tokens returned by [Decoder.Token], the Space identifier
is given as a canonical URL, not the short prefix used
in the document being parsed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Name struct {
Space string
Local string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ProcInst" data-name="ProcInst">
               <h3>
                  ProcInst
                  <span class="badge">struct</span>
                  <a href="#ProcInst" class="anchor" title="Link to ProcInst">#</a>
               </h3>
               
               <p>A ProcInst represents an XML processing instruction of the form <?target inst?></p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ProcInst struct {
Target string
Inst []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="StartElement" data-name="StartElement">
               <h3>
                  StartElement
                  <span class="badge">struct</span>
                  <a href="#StartElement" class="anchor" title="Link to StartElement">#</a>
               </h3>
               
               <p>A StartElement represents an XML start element.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type StartElement struct {
Name Name
Attr []Attr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="SyntaxError" data-name="SyntaxError">
               <h3>
                  SyntaxError
                  <span class="badge">struct</span>
                  <a href="#SyntaxError" class="anchor" title="Link to SyntaxError">#</a>
               </h3>
               
               <p>A SyntaxError represents a syntax error in the XML input stream.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type SyntaxError struct {
Msg string
Line int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TagPathError" data-name="TagPathError">
               <h3>
                  TagPathError
                  <span class="badge">struct</span>
                  <a href="#TagPathError" class="anchor" title="Link to TagPathError">#</a>
               </h3>
               
               <p>A TagPathError represents an error in the unmarshaling process
caused by the use of field tags with conflicting paths.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type TagPathError struct {
Struct reflect.Type
Field1 string
Tag1 string
Field2 string
Tag2 string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="UnsupportedTypeError" data-name="UnsupportedTypeError">
               <h3>
                  UnsupportedTypeError
                  <span class="badge">struct</span>
                  <a href="#UnsupportedTypeError" class="anchor" title="Link to UnsupportedTypeError">#</a>
               </h3>
               
               <p>UnsupportedTypeError is returned when [Marshal] encounters a type
that cannot be converted into XML.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type UnsupportedTypeError struct {
Type reflect.Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fieldInfo" data-name="fieldInfo">
               <h3>
                  fieldInfo
                  <span class="badge">struct</span>
                  <a href="#fieldInfo" class="anchor" title="Link to fieldInfo">#</a>
               </h3>
               
               <p>fieldInfo holds details for the xml representation of a single field.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fieldInfo struct {
idx []int
name string
xmlns string
flags fieldFlags
parents []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="parentStack" data-name="parentStack">
               <h3>
                  parentStack
                  <span class="badge">struct</span>
                  <a href="#parentStack" class="anchor" title="Link to parentStack">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type parentStack struct {
p *printer
stack []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="printer" data-name="printer">
               <h3>
                  printer
                  <span class="badge">struct</span>
                  <a href="#printer" class="anchor" title="Link to printer">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type printer struct {
w *bufio.Writer
encoder *Encoder
seq int
indent string
prefix string
depth int
indentedIn bool
putNewline bool
attrNS map[string]string
attrPrefix map[string]string
prefixes []string
tags []Name
closed bool
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="stack" data-name="stack">
               <h3>
                  stack
                  <span class="badge">struct</span>
                  <a href="#stack" class="anchor" title="Link to stack">#</a>
               </h3>
               
               <p>Parsing state - stack holds old name space translations
and the current set of open elements. The translations to pop when
ending a given tag are *below* it on the stack, which is
more work but forced on us by XML.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type stack struct {
next *stack
kind int
name Name
ok bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="typeInfo" data-name="typeInfo">
               <h3>
                  typeInfo
                  <span class="badge">struct</span>
                  <a href="#typeInfo" class="anchor" title="Link to typeInfo">#</a>
               </h3>
               
               <p>typeInfo holds details for the xml representation of a type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type typeInfo struct {
xmlname *fieldInfo
fields []fieldInfo
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close the Encoder, indicating that no more data will be written. It flushes
any buffered XML to the underlying writer and returns an error if the
written XML is invalid (e.g. by containing unclosed elements).</p>
               
               <pre><code class="language-go">func (p *printer) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close the Encoder, indicating that no more data will be written. It flushes
any buffered XML to the underlying writer and returns an error if the
written XML is invalid (e.g. by containing unclosed elements).</p>
               
               <pre><code class="language-go">func (enc *Encoder) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Copy" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Copy" class="anchor" title="Link to Copy">#</a>
               </h3>
               
               <p>Copy creates a new copy of ProcInst.</p>
               
               <pre><code class="language-go">func (p ProcInst) Copy() ProcInst</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Copy" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Copy" class="anchor" title="Link to Copy">#</a>
               </h3>
               
               <p>Copy creates a new copy of CharData.</p>
               
               <pre><code class="language-go">func (c CharData) Copy() CharData</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Copy" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Copy" class="anchor" title="Link to Copy">#</a>
               </h3>
               
               <p>Copy creates a new copy of Comment.</p>
               
               <pre><code class="language-go">func (c Comment) Copy() Comment</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Copy" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Copy" class="anchor" title="Link to Copy">#</a>
               </h3>
               
               <p>Copy creates a new copy of StartElement.</p>
               
               <pre><code class="language-go">func (e StartElement) Copy() StartElement</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Copy" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Copy" class="anchor" title="Link to Copy">#</a>
               </h3>
               
               <p>Copy creates a new copy of Directive.</p>
               
               <pre><code class="language-go">func (d Directive) Copy() Directive</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CopyToken" data-name="CopyToken">
               <h3>
                  CopyToken 
                  <span class="badge">function</span>
                  
                  <a href="#CopyToken" class="anchor" title="Link to CopyToken">#</a>
               </h3>
               
               <p>CopyToken returns a copy of a Token.</p>
               
               <pre><code class="language-go">func CopyToken(t Token) Token</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Decode" data-name="Decode">
               <h3>
                  Decode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Decode" class="anchor" title="Link to Decode">#</a>
               </h3>
               
               <p>Decode works like [Unmarshal], except it reads the decoder
stream to find the start element.</p>
               
               <pre><code class="language-go">func (d *Decoder) Decode(v any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DecodeElement" data-name="DecodeElement">
               <h3>
                  DecodeElement 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DecodeElement" class="anchor" title="Link to DecodeElement">#</a>
               </h3>
               
               <p>DecodeElement works like [Unmarshal] except that it takes
a pointer to the start XML element to decode into v.
It is useful when a client reads some raw XML tokens itself
but also wants to defer to [Unmarshal] for some elements.</p>
               
               <pre><code class="language-go">func (d *Decoder) DecodeElement(v any, start *StartElement) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Encode" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Encode" class="anchor" title="Link to Encode">#</a>
               </h3>
               
               <p>Encode writes the XML encoding of v to the stream.
See the documentation for [Marshal] for details about the conversion
of Go values to XML.
Encode calls [Encoder.Flush] before returning.</p>
               
               <pre><code class="language-go">func (enc *Encoder) Encode(v any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EncodeElement" data-name="EncodeElement">
               <h3>
                  EncodeElement 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EncodeElement" class="anchor" title="Link to EncodeElement">#</a>
               </h3>
               
               <p>EncodeElement writes the XML encoding of v to the stream,
using start as the outermost tag in the encoding.
See the documentation for [Marshal] for details about the conversion
of Go values to XML.
EncodeElement calls [Encoder.Flush] before returning.</p>
               
               <pre><code class="language-go">func (enc *Encoder) EncodeElement(v any, start StartElement) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EncodeToken" data-name="EncodeToken">
               <h3>
                  EncodeToken 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EncodeToken" class="anchor" title="Link to EncodeToken">#</a>
               </h3>
               
               <p>EncodeToken writes the given XML token to the stream.
It returns an error if [StartElement] and [EndElement] tokens are not properly matched.
EncodeToken does not call [Encoder.Flush], because usually it is part of a larger operation
such as [Encoder.Encode] or [Encoder.EncodeElement] (or a custom [Marshaler]'s MarshalXML invoked
during those), and those will call Flush when finished.
Callers that create an Encoder and then invoke EncodeToken directly, without
using Encode or EncodeElement, need to call Flush when finished to ensure
that the XML is written to the underlying writer.
EncodeToken allows writing a [ProcInst] with Target set to "xml" only as the first token
in the stream.</p>
               
               <pre><code class="language-go">func (enc *Encoder) EncodeToken(t Token) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="End" data-name="End">
               <h3>
                  End 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#End" class="anchor" title="Link to End">#</a>
               </h3>
               
               <p>End returns the corresponding XML end element.</p>
               
               <pre><code class="language-go">func (e StartElement) End() EndElement</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *TagPathError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *SyntaxError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e UnmarshalError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *UnsupportedTypeError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Escape" data-name="Escape">
               <h3>
                  Escape 
                  <span class="badge">function</span>
                  
                  <a href="#Escape" class="anchor" title="Link to Escape">#</a>
               </h3>
               
               <p>Escape is like [EscapeText] but omits the error return value.
It is provided for backwards compatibility with Go 1.0.
Code targeting Go 1.1 or later should use [EscapeText].</p>
               
               <pre><code class="language-go">func Escape(w io.Writer, s []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EscapeString" data-name="EscapeString">
               <h3>
                  EscapeString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EscapeString" class="anchor" title="Link to EscapeString">#</a>
               </h3>
               
               <p>EscapeString writes to p the properly escaped XML equivalent
of the plain text data s.</p>
               
               <pre><code class="language-go">func (p *printer) EscapeString(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EscapeText" data-name="EscapeText">
               <h3>
                  EscapeText 
                  <span class="badge">function</span>
                  
                  <a href="#EscapeText" class="anchor" title="Link to EscapeText">#</a>
               </h3>
               
               <p>EscapeText writes to w the properly escaped XML equivalent
of the plain text data s.</p>
               
               <pre><code class="language-go">func EscapeText(w io.Writer, s []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flush" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flush" class="anchor" title="Link to Flush">#</a>
               </h3>
               
               <p>Flush flushes any buffered XML to the underlying writer.
See the [Encoder.EncodeToken] documentation for details about when it is necessary.</p>
               
               <pre><code class="language-go">func (enc *Encoder) Flush() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Indent" data-name="Indent">
               <h3>
                  Indent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Indent" class="anchor" title="Link to Indent">#</a>
               </h3>
               
               <p>Indent sets the encoder to generate XML in which each element
begins on a new indented line that starts with prefix and is followed by
one or more copies of indent according to the nesting depth.</p>
               
               <pre><code class="language-go">func (enc *Encoder) Indent(prefix string, indent string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InputOffset" data-name="InputOffset">
               <h3>
                  InputOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InputOffset" class="anchor" title="Link to InputOffset">#</a>
               </h3>
               
               <p>InputOffset returns the input stream byte offset of the current decoder position.
The offset gives the location of the end of the most recently returned token
and the beginning of the next token.</p>
               
               <pre><code class="language-go">func (d *Decoder) InputOffset() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InputPos" data-name="InputPos">
               <h3>
                  InputPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InputPos" class="anchor" title="Link to InputPos">#</a>
               </h3>
               
               <p>InputPos returns the line of the current decoder position and the 1 based
input position of the line. The position gives the location of the end of the
most recently returned token.</p>
               
               <pre><code class="language-go">func (d *Decoder) InputPos() (line int, column int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Marshal" data-name="Marshal">
               <h3>
                  Marshal 
                  <span class="badge">function</span>
                  
                  <a href="#Marshal" class="anchor" title="Link to Marshal">#</a>
               </h3>
               
               <p>Marshal returns the XML encoding of v.
Marshal handles an array or slice by marshaling each of the elements.
Marshal handles a pointer by marshaling the value it points at or, if the
pointer is nil, by writing nothing. Marshal handles an interface value by
marshaling the value it contains or, if the interface value is nil, by
writing nothing. Marshal handles all other data by writing one or more XML
elements containing the data.
The name for the XML elements is taken from, in order of preference:
- the tag on the XMLName field, if the data is a struct
- the value of the XMLName field of type [Name]
- the tag of the struct field used to obtain the data
- the name of the struct field used to obtain the data
- the name of the marshaled type
The XML element for a struct contains marshaled elements for each of the
exported fields of the struct, with these exceptions:
- the XMLName field, described above, is omitted.
- a field with tag "-" is omitted.
- a field with tag "name,attr" becomes an attribute with
the given name in the XML element.
- a field with tag ",attr" becomes an attribute with the
field name in the XML element.
- a field with tag ",chardata" is written as character data,
not as an XML element.
- a field with tag ",cdata" is written as character data
wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.
- a field with tag ",innerxml" is written verbatim, not subject
to the usual marshaling procedure.
- a field with tag ",comment" is written as an XML comment, not
subject to the usual marshaling procedure. It must not contain
the "--" string within it.
- a field with a tag including the "omitempty" option is omitted
if the field value is empty. The empty values are false, 0, any
nil pointer or interface value, and any array, slice, map, or
string of length zero.
- an anonymous struct field is handled as if the fields of its
value were part of the outer struct.
- an anonymous struct field of interface type is treated the same as having
that type as its name, rather than being anonymous.
- a field implementing [Marshaler] is written by calling its MarshalXML
method.
- a field implementing [encoding.TextMarshaler] is written by encoding the
result of its MarshalText method as text.
If a field uses a tag "a>b>c", then the element c will be nested inside
parent elements a and b. Fields that appear next to each other that name
the same parent will be enclosed in one XML element.
If the XML name for a struct field is defined by both the field tag and the
struct's XMLName field, the names must match.
See [MarshalIndent] for an example.
Marshal will return an error if asked to marshal a channel, function, or map.</p>
               
               <pre><code class="language-go">func Marshal(v any) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalIndent" data-name="MarshalIndent">
               <h3>
                  MarshalIndent 
                  <span class="badge">function</span>
                  
                  <a href="#MarshalIndent" class="anchor" title="Link to MarshalIndent">#</a>
               </h3>
               
               <p>MarshalIndent works like [Marshal], but each XML element begins on a new
indented line that starts with prefix and is followed by one or more
copies of indent according to the nesting depth.</p>
               
               <pre><code class="language-go">func MarshalIndent(v any, prefix string, indent string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewDecoder" data-name="NewDecoder">
               <h3>
                  NewDecoder 
                  <span class="badge">function</span>
                  
                  <a href="#NewDecoder" class="anchor" title="Link to NewDecoder">#</a>
               </h3>
               
               <p>NewDecoder creates a new XML parser reading from r.
If r does not implement [io.ByteReader], NewDecoder will
do its own buffering.</p>
               
               <pre><code class="language-go">func NewDecoder(r io.Reader) *Decoder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewEncoder" data-name="NewEncoder">
               <h3>
                  NewEncoder 
                  <span class="badge">function</span>
                  
                  <a href="#NewEncoder" class="anchor" title="Link to NewEncoder">#</a>
               </h3>
               
               <p>NewEncoder returns a new encoder that writes to w.</p>
               
               <pre><code class="language-go">func NewEncoder(w io.Writer) *Encoder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewTokenDecoder" data-name="NewTokenDecoder">
               <h3>
                  NewTokenDecoder 
                  <span class="badge">function</span>
                  
                  <a href="#NewTokenDecoder" class="anchor" title="Link to NewTokenDecoder">#</a>
               </h3>
               
               <p>NewTokenDecoder creates a new XML parser using an underlying token stream.</p>
               
               <pre><code class="language-go">func NewTokenDecoder(t TokenReader) *Decoder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RawToken" data-name="RawToken">
               <h3>
                  RawToken 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RawToken" class="anchor" title="Link to RawToken">#</a>
               </h3>
               
               <p>RawToken is like [Decoder.Token] but does not verify that
start and end elements match and does not translate
name space prefixes to their corresponding URLs.</p>
               
               <pre><code class="language-go">func (d *Decoder) RawToken() (Token, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Skip" data-name="Skip">
               <h3>
                  Skip 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Skip" class="anchor" title="Link to Skip">#</a>
               </h3>
               
               <p>Skip reads tokens until it has consumed the end element
matching the most recent start element already consumed,
skipping nested structures.
It returns nil if it finds an end element matching the start
element; otherwise it returns an error describing the problem.</p>
               
               <pre><code class="language-go">func (d *Decoder) Skip() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Token" data-name="Token">
               <h3>
                  Token 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Token" class="anchor" title="Link to Token">#</a>
               </h3>
               
               <p>Token returns the next XML token in the input stream.
At the end of the input stream, Token returns nil, [io.EOF].
Slices of bytes in the returned token data refer to the
parser's internal buffer and remain valid only until the next
call to Token. To acquire a copy of the bytes, call [CopyToken]
or the token's Copy method.
Token expands self-closing elements such as <br>
into separate start and end elements returned by successive calls.
Token guarantees that the [StartElement] and [EndElement]
tokens it returns are properly nested and matched:
if Token encounters an unexpected end element
or EOF before all expected end elements,
it will return an error.
If [Decoder.CharsetReader] is called and returns an error,
the error is wrapped and returned.
Token implements XML name spaces as described by
https://www.w3.org/TR/REC-xml-names/. Each of the
[Name] structures contained in the Token has the Space
set to the URL identifying its name space when known.
If Token encounters an unrecognized name space prefix,
it uses the prefix as the Space rather than report an error.</p>
               
               <pre><code class="language-go">func (d *Decoder) Token() (Token, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unmarshal" data-name="Unmarshal">
               <h3>
                  Unmarshal 
                  <span class="badge">function</span>
                  
                  <a href="#Unmarshal" class="anchor" title="Link to Unmarshal">#</a>
               </h3>
               
               <p>Unmarshal parses the XML-encoded data and stores the result in
the value pointed to by v, which must be an arbitrary struct,
slice, or string. Well-formed data that does not fit into v is
discarded.
Because Unmarshal uses the reflect package, it can only assign
to exported (upper case) fields. Unmarshal uses a case-sensitive
comparison to match XML element names to tag values and struct
field names.
Unmarshal maps an XML element to a struct using the following rules.
In the rules, the tag of a field refers to the value associated with the
key 'xml' in the struct field's tag (see the example above).
- If the struct has a field of type []byte or string with tag
",innerxml", Unmarshal accumulates the raw XML nested inside the
element in that field. The rest of the rules still apply.
- If the struct has a field named XMLName of type Name,
Unmarshal records the element name in that field.
- If the XMLName field has an associated tag of the form
"name" or "namespace-URL name", the XML element must have
the given name (and, optionally, name space) or else Unmarshal
returns an error.
- If the XML element has an attribute whose name matches a
struct field name with an associated tag containing ",attr" or
the explicit name in a struct field tag of the form "name,attr",
Unmarshal records the attribute value in that field.
- If the XML element has an attribute not handled by the previous
rule and the struct has a field with an associated tag containing
",any,attr", Unmarshal records the attribute value in the first
such field.
- If the XML element contains character data, that data is
accumulated in the first struct field that has tag ",chardata".
The struct field may have type []byte or string.
If there is no such field, the character data is discarded.
- If the XML element contains comments, they are accumulated in
the first struct field that has tag ",comment".  The struct
field may have type []byte or string. If there is no such
field, the comments are discarded.
- If the XML element contains a sub-element whose name matches
the prefix of a tag formatted as "a" or "a>b>c", unmarshal
will descend into the XML structure looking for elements with the
given names, and will map the innermost elements to that struct
field. A tag starting with ">" is equivalent to one starting
with the field name followed by ">".
- If the XML element contains a sub-element whose name matches
a struct field's XMLName tag and the struct field has no
explicit name tag as per the previous rule, unmarshal maps
the sub-element to that struct field.
- If the XML element contains a sub-element whose name matches a
field without any mode flags (",attr", ",chardata", etc), Unmarshal
maps the sub-element to that struct field.
- If the XML element contains a sub-element that hasn't matched any
of the above rules and the struct has a field with tag ",any",
unmarshal maps the sub-element to that struct field.
- An anonymous struct field is handled as if the fields of its
value were part of the outer struct.
- A struct field with tag "-" is never unmarshaled into.
If Unmarshal encounters a field type that implements the Unmarshaler
interface, Unmarshal calls its UnmarshalXML method to produce the value from
the XML element.  Otherwise, if the value implements
[encoding.TextUnmarshaler], Unmarshal calls that value's UnmarshalText method.
Unmarshal maps an XML element to a string or []byte by saving the
concatenation of that element's character data in the string or
[]byte. The saved []byte is never nil.
Unmarshal maps an attribute value to a string or []byte by saving
the value in the string or slice.
Unmarshal maps an attribute value to an [Attr] by saving the attribute,
including its name, in the Attr.
Unmarshal maps an XML element or attribute value to a slice by
extending the length of the slice and mapping the element or attribute
to the newly created value.
Unmarshal maps an XML element or attribute value to a bool by
setting it to the boolean value represented by the string. Whitespace
is trimmed and ignored.
Unmarshal maps an XML element or attribute value to an integer or
floating-point field by setting the field to the result of
interpreting the string value in decimal. There is no check for
overflow. Whitespace is trimmed and ignored.
Unmarshal maps an XML element to a Name by recording the element
name.
Unmarshal maps an XML element to a pointer by setting the pointer
to a freshly allocated value and then mapping the element to that value.
A missing element or empty attribute value will be unmarshaled as a zero value.
If the field is a slice, a zero value will be appended to the field. Otherwise, the
field will be set to its zero value.</p>
               
               <pre><code class="language-go">func Unmarshal(data []byte, v any) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write implements io.Writer</p>
               
               <pre><code class="language-go">func (p *printer) Write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteByte" data-name="WriteByte">
               <h3>
                  WriteByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteByte" class="anchor" title="Link to WriteByte">#</a>
               </h3>
               
               <p>WriteByte implements io.ByteWriter</p>
               
               <pre><code class="language-go">func (p *printer) WriteByte(c byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteString" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteString" class="anchor" title="Link to WriteString">#</a>
               </h3>
               
               <p>WriteString implements io.StringWriter</p>
               
               <pre><code class="language-go">func (p *printer) WriteString(s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addFieldInfo" data-name="addFieldInfo">
               <h3>
                  addFieldInfo 
                  <span class="badge">function</span>
                  
                  <a href="#addFieldInfo" class="anchor" title="Link to addFieldInfo">#</a>
               </h3>
               
               <p>addFieldInfo adds finfo to tinfo.fields if there are no
conflicts, or if conflicts arise from previous fields that were
obtained from deeper embedded structures than finfo. In the latter
case, the conflicting entries are dropped.
A conflict occurs when the path (parent + name) to a field is
itself a prefix of another path, or when two paths match exactly.
It is okay for field paths to share a common, shorter prefix.</p>
               
               <pre><code class="language-go">func addFieldInfo(typ reflect.Type, tinfo *typeInfo, newf *fieldInfo) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="attrval" data-name="attrval">
               <h3>
                  attrval 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#attrval" class="anchor" title="Link to attrval">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *Decoder) attrval() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="autoClose" data-name="autoClose">
               <h3>
                  autoClose 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#autoClose" class="anchor" title="Link to autoClose">#</a>
               </h3>
               
               <p>If the top element on the stack is autoclosing and
t is not the end tag, invent the end tag.</p>
               
               <pre><code class="language-go">func (d *Decoder) autoClose(t Token) (Token, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cachedWriteError" data-name="cachedWriteError">
               <h3>
                  cachedWriteError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cachedWriteError" class="anchor" title="Link to cachedWriteError">#</a>
               </h3>
               
               <p>return the bufio Writer's cached write error</p>
               
               <pre><code class="language-go">func (p *printer) cachedWriteError() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyValue" data-name="copyValue">
               <h3>
                  copyValue 
                  <span class="badge">function</span>
                  
                  <a href="#copyValue" class="anchor" title="Link to copyValue">#</a>
               </h3>
               
               <pre><code class="language-go">func copyValue(dst reflect.Value, src []byte) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="createAttrPrefix" data-name="createAttrPrefix">
               <h3>
                  createAttrPrefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#createAttrPrefix" class="anchor" title="Link to createAttrPrefix">#</a>
               </h3>
               
               <p>createAttrPrefix finds the name space prefix attribute to use for the given name space,
defining a new prefix if necessary. It returns the prefix.</p>
               
               <pre><code class="language-go">func (p *printer) createAttrPrefix(url string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultStart" data-name="defaultStart">
               <h3>
                  defaultStart 
                  <span class="badge">function</span>
                  
                  <a href="#defaultStart" class="anchor" title="Link to defaultStart">#</a>
               </h3>
               
               <p>defaultStart returns the default start element to use,
given the reflect type, field info, and start template.</p>
               
               <pre><code class="language-go">func defaultStart(typ reflect.Type, finfo *fieldInfo, startTemplate *StartElement) StartElement</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deleteAttrPrefix" data-name="deleteAttrPrefix">
               <h3>
                  deleteAttrPrefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#deleteAttrPrefix" class="anchor" title="Link to deleteAttrPrefix">#</a>
               </h3>
               
               <p>deleteAttrPrefix removes an attribute name space prefix.</p>
               
               <pre><code class="language-go">func (p *printer) deleteAttrPrefix(prefix string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitCDATA" data-name="emitCDATA">
               <h3>
                  emitCDATA 
                  <span class="badge">function</span>
                  
                  <a href="#emitCDATA" class="anchor" title="Link to emitCDATA">#</a>
               </h3>
               
               <p>emitCDATA writes to w the CDATA-wrapped plain text data s.
It escapes CDATA directives nested in s.</p>
               
               <pre><code class="language-go">func emitCDATA(w io.Writer, s []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="escapeText" data-name="escapeText">
               <h3>
                  escapeText 
                  <span class="badge">function</span>
                  
                  <a href="#escapeText" class="anchor" title="Link to escapeText">#</a>
               </h3>
               
               <p>escapeText writes to w the properly escaped XML equivalent
of the plain text data s. If escapeNewline is true, newline
characters will be escaped.</p>
               
               <pre><code class="language-go">func escapeText(w io.Writer, s []byte, escapeNewline bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getTypeInfo" data-name="getTypeInfo">
               <h3>
                  getTypeInfo 
                  <span class="badge">function</span>
                  
                  <a href="#getTypeInfo" class="anchor" title="Link to getTypeInfo">#</a>
               </h3>
               
               <p>getTypeInfo returns the typeInfo structure with details necessary
for marshaling and unmarshaling typ.</p>
               
               <pre><code class="language-go">func getTypeInfo(typ reflect.Type) (*typeInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getc" data-name="getc">
               <h3>
                  getc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getc" class="anchor" title="Link to getc">#</a>
               </h3>
               
               <p>Read a single byte.
If there is no byte to read, return ok==false
and leave the error in d.err.
Maintain line number.</p>
               
               <pre><code class="language-go">func (d *Decoder) getc() (b byte, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indirect" data-name="indirect">
               <h3>
                  indirect 
                  <span class="badge">function</span>
                  
                  <a href="#indirect" class="anchor" title="Link to indirect">#</a>
               </h3>
               
               <p>indirect drills into interfaces and pointers, returning the pointed-at value.
If it encounters a nil interface or pointer, indirect returns that nil value.
This can turn into an infinite loop given a cyclic chain,
but it matches the Go 1 behavior.</p>
               
               <pre><code class="language-go">func indirect(vf reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isEmptyValue" data-name="isEmptyValue">
               <h3>
                  isEmptyValue 
                  <span class="badge">function</span>
                  
                  <a href="#isEmptyValue" class="anchor" title="Link to isEmptyValue">#</a>
               </h3>
               
               <pre><code class="language-go">func isEmptyValue(v reflect.Value) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isInCharacterRange" data-name="isInCharacterRange">
               <h3>
                  isInCharacterRange 
                  <span class="badge">function</span>
                  
                  <a href="#isInCharacterRange" class="anchor" title="Link to isInCharacterRange">#</a>
               </h3>
               
               <p>Decide whether the given rune is in the XML Character Range, per
the Char production of https://www.xml.com/axml/testaxml.htm,
Section 2.2 Characters.</p>
               
               <pre><code class="language-go">func isInCharacterRange(r rune) (inrange bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isName" data-name="isName">
               <h3>
                  isName 
                  <span class="badge">function</span>
                  
                  <a href="#isName" class="anchor" title="Link to isName">#</a>
               </h3>
               
               <pre><code class="language-go">func isName(s []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNameByte" data-name="isNameByte">
               <h3>
                  isNameByte 
                  <span class="badge">function</span>
                  
                  <a href="#isNameByte" class="anchor" title="Link to isNameByte">#</a>
               </h3>
               
               <pre><code class="language-go">func isNameByte(c byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNameString" data-name="isNameString">
               <h3>
                  isNameString 
                  <span class="badge">function</span>
                  
                  <a href="#isNameString" class="anchor" title="Link to isNameString">#</a>
               </h3>
               
               <pre><code class="language-go">func isNameString(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValidDirective" data-name="isValidDirective">
               <h3>
                  isValidDirective 
                  <span class="badge">function</span>
                  
                  <a href="#isValidDirective" class="anchor" title="Link to isValidDirective">#</a>
               </h3>
               
               <p>isValidDirective reports whether dir is a valid directive text,
meaning angle brackets are matched, ignoring comments and strings.</p>
               
               <pre><code class="language-go">func isValidDirective(dir Directive) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupXMLName" data-name="lookupXMLName">
               <h3>
                  lookupXMLName 
                  <span class="badge">function</span>
                  
                  <a href="#lookupXMLName" class="anchor" title="Link to lookupXMLName">#</a>
               </h3>
               
               <p>lookupXMLName returns the fieldInfo for typ's XMLName field
in case it exists and has a valid xml field tag, otherwise
it returns nil.</p>
               
               <pre><code class="language-go">func lookupXMLName(typ reflect.Type) (xmlname *fieldInfo)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="markPrefix" data-name="markPrefix">
               <h3>
                  markPrefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#markPrefix" class="anchor" title="Link to markPrefix">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) markPrefix()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="marshalAttr" data-name="marshalAttr">
               <h3>
                  marshalAttr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#marshalAttr" class="anchor" title="Link to marshalAttr">#</a>
               </h3>
               
               <p>marshalAttr marshals an attribute with the given name and value, adding to start.Attr.</p>
               
               <pre><code class="language-go">func (p *printer) marshalAttr(start *StartElement, name Name, val reflect.Value) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="marshalInterface" data-name="marshalInterface">
               <h3>
                  marshalInterface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#marshalInterface" class="anchor" title="Link to marshalInterface">#</a>
               </h3>
               
               <p>marshalInterface marshals a Marshaler interface value.</p>
               
               <pre><code class="language-go">func (p *printer) marshalInterface(val Marshaler, start StartElement) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="marshalSimple" data-name="marshalSimple">
               <h3>
                  marshalSimple 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#marshalSimple" class="anchor" title="Link to marshalSimple">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) marshalSimple(typ reflect.Type, val reflect.Value) (string, []byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="marshalStruct" data-name="marshalStruct">
               <h3>
                  marshalStruct 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#marshalStruct" class="anchor" title="Link to marshalStruct">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="marshalTextInterface" data-name="marshalTextInterface">
               <h3>
                  marshalTextInterface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#marshalTextInterface" class="anchor" title="Link to marshalTextInterface">#</a>
               </h3>
               
               <p>marshalTextInterface marshals a TextMarshaler interface value.</p>
               
               <pre><code class="language-go">func (p *printer) marshalTextInterface(val encoding.TextMarshaler, start StartElement) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="marshalValue" data-name="marshalValue">
               <h3>
                  marshalValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#marshalValue" class="anchor" title="Link to marshalValue">#</a>
               </h3>
               
               <p>marshalValue writes one or more XML elements representing val.
If val was obtained from a struct field, finfo must have its details.</p>
               
               <pre><code class="language-go">func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo, startTemplate *StartElement) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mustgetc" data-name="mustgetc">
               <h3>
                  mustgetc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mustgetc" class="anchor" title="Link to mustgetc">#</a>
               </h3>
               
               <p>Must read a single byte.
If there is no byte to read,
set d.err to SyntaxError("unexpected EOF")
and return ok==false</p>
               
               <pre><code class="language-go">func (d *Decoder) mustgetc() (b byte, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="name" data-name="name">
               <h3>
                  name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#name" class="anchor" title="Link to name">#</a>
               </h3>
               
               <p>Get name: /first(first|second)
Do not set d.err if the name is missing (unless unexpected EOF is received):
let the caller provide better context.</p>
               
               <pre><code class="language-go">func (d *Decoder) name() (s string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nsname" data-name="nsname">
               <h3>
                  nsname 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nsname" class="anchor" title="Link to nsname">#</a>
               </h3>
               
               <p>Get name space name: name with a : stuck in the middle.
The part before the : is the name space identifier.</p>
               
               <pre><code class="language-go">func (d *Decoder) nsname() (name Name, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pop" data-name="pop">
               <h3>
                  pop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pop" class="anchor" title="Link to pop">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *Decoder) pop() *stack</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="popEOF" data-name="popEOF">
               <h3>
                  popEOF 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#popEOF" class="anchor" title="Link to popEOF">#</a>
               </h3>
               
               <p>Undo a pushEOF.
The element must have been finished, so the EOF should be at the top of the stack.</p>
               
               <pre><code class="language-go">func (d *Decoder) popEOF() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="popElement" data-name="popElement">
               <h3>
                  popElement 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#popElement" class="anchor" title="Link to popElement">#</a>
               </h3>
               
               <p>Record that we are ending an element with the given name.
The name must match the record at the top of the stack,
which must be a pushElement record.
After popping the element, apply any undo records from
the stack to restore the name translations that existed
before we saw this element.</p>
               
               <pre><code class="language-go">func (d *Decoder) popElement(t *EndElement) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="popPrefix" data-name="popPrefix">
               <h3>
                  popPrefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#popPrefix" class="anchor" title="Link to popPrefix">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) popPrefix()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="procInst" data-name="procInst">
               <h3>
                  procInst 
                  <span class="badge">function</span>
                  
                  <a href="#procInst" class="anchor" title="Link to procInst">#</a>
               </h3>
               
               <p>procInst parses the `param="..."` or `param='...'`
value out of the provided string, returning "" if not found.</p>
               
               <pre><code class="language-go">func procInst(param string, s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="push" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#push" class="anchor" title="Link to push">#</a>
               </h3>
               
               <p>push adds parent elements to the stack and writes open tags.</p>
               
               <pre><code class="language-go">func (s *parentStack) push(parents []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="push" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#push" class="anchor" title="Link to push">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *Decoder) push(kind int) *stack</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pushEOF" data-name="pushEOF">
               <h3>
                  pushEOF 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pushEOF" class="anchor" title="Link to pushEOF">#</a>
               </h3>
               
               <p>Record that after the current element is finished
(that element is already pushed on the stack)
Token should return EOF until popEOF is called.</p>
               
               <pre><code class="language-go">func (d *Decoder) pushEOF()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pushElement" data-name="pushElement">
               <h3>
                  pushElement 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pushElement" class="anchor" title="Link to pushElement">#</a>
               </h3>
               
               <p>Record that we are starting an element with the given name.</p>
               
               <pre><code class="language-go">func (d *Decoder) pushElement(name Name)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pushNs" data-name="pushNs">
               <h3>
                  pushNs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pushNs" class="anchor" title="Link to pushNs">#</a>
               </h3>
               
               <p>Record that we are changing the value of ns[local].
The old value is url, ok.</p>
               
               <pre><code class="language-go">func (d *Decoder) pushNs(local string, url string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rawToken" data-name="rawToken">
               <h3>
                  rawToken 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rawToken" class="anchor" title="Link to rawToken">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *Decoder) rawToken() (Token, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readName" data-name="readName">
               <h3>
                  readName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readName" class="anchor" title="Link to readName">#</a>
               </h3>
               
               <p>Read a name and append its bytes to d.buf.
The name is delimited by any single-byte character not valid in names.
All multi-byte characters are accepted; the caller must check their validity.</p>
               
               <pre><code class="language-go">func (d *Decoder) readName() (ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="receiverType" data-name="receiverType">
               <h3>
                  receiverType 
                  <span class="badge">function</span>
                  
                  <a href="#receiverType" class="anchor" title="Link to receiverType">#</a>
               </h3>
               
               <p>receiverType returns the receiver type to use in an expression like "%s.MethodName".</p>
               
               <pre><code class="language-go">func receiverType(val any) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="savedOffset" data-name="savedOffset">
               <h3>
                  savedOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#savedOffset" class="anchor" title="Link to savedOffset">#</a>
               </h3>
               
               <p>Return saved offset.
If we did ungetc (nextByte >= 0), have to back up one.</p>
               
               <pre><code class="language-go">func (d *Decoder) savedOffset() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="space" data-name="space">
               <h3>
                  space 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#space" class="anchor" title="Link to space">#</a>
               </h3>
               
               <p>Skip spaces if any</p>
               
               <pre><code class="language-go">func (d *Decoder) space()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="structFieldInfo" data-name="structFieldInfo">
               <h3>
                  structFieldInfo 
                  <span class="badge">function</span>
                  
                  <a href="#structFieldInfo" class="anchor" title="Link to structFieldInfo">#</a>
               </h3>
               
               <p>structFieldInfo builds and returns a fieldInfo for f.</p>
               
               <pre><code class="language-go">func structFieldInfo(typ reflect.Type, f *reflect.StructField) (*fieldInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="switchToReader" data-name="switchToReader">
               <h3>
                  switchToReader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#switchToReader" class="anchor" title="Link to switchToReader">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *Decoder) switchToReader(r io.Reader)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syntaxError" data-name="syntaxError">
               <h3>
                  syntaxError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#syntaxError" class="anchor" title="Link to syntaxError">#</a>
               </h3>
               
               <p>Creates a SyntaxError with the current line number.</p>
               
               <pre><code class="language-go">func (d *Decoder) syntaxError(msg string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="text" data-name="text">
               <h3>
                  text 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#text" class="anchor" title="Link to text">#</a>
               </h3>
               
               <p>Read plain text section (XML calls it character data).
If quote >= 0, we are in a quoted string and need to find the matching quote.
If cdata == true, we are in a <![CDATA[ section and need to find ]]>.
On failure return nil and leave the error in d.err.</p>
               
               <pre><code class="language-go">func (d *Decoder) text(quote int, cdata bool) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="translate" data-name="translate">
               <h3>
                  translate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#translate" class="anchor" title="Link to translate">#</a>
               </h3>
               
               <p>Apply name space translation to name n.
The default name space (for Space=="")
applies only to element names, not to attribute names.</p>
               
               <pre><code class="language-go">func (d *Decoder) translate(n *Name, isElementName bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trim" data-name="trim">
               <h3>
                  trim 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trim" class="anchor" title="Link to trim">#</a>
               </h3>
               
               <p>trim updates the XML context to match the longest common prefix of the stack
and the given parents. A closing tag will be written for every parent
popped. Passing a zero slice or nil will close all the elements.</p>
               
               <pre><code class="language-go">func (s *parentStack) trim(parents []string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ungetc" data-name="ungetc">
               <h3>
                  ungetc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ungetc" class="anchor" title="Link to ungetc">#</a>
               </h3>
               
               <p>Unread a single byte.</p>
               
               <pre><code class="language-go">func (d *Decoder) ungetc(b byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unmarshal" data-name="unmarshal">
               <h3>
                  unmarshal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unmarshal" class="anchor" title="Link to unmarshal">#</a>
               </h3>
               
               <p>Unmarshal a single XML element into val.</p>
               
               <pre><code class="language-go">func (d *Decoder) unmarshal(val reflect.Value, start *StartElement, depth int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unmarshalAttr" data-name="unmarshalAttr">
               <h3>
                  unmarshalAttr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unmarshalAttr" class="anchor" title="Link to unmarshalAttr">#</a>
               </h3>
               
               <p>unmarshalAttr unmarshals a single XML attribute into val.</p>
               
               <pre><code class="language-go">func (d *Decoder) unmarshalAttr(val reflect.Value, attr Attr) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unmarshalInterface" data-name="unmarshalInterface">
               <h3>
                  unmarshalInterface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unmarshalInterface" class="anchor" title="Link to unmarshalInterface">#</a>
               </h3>
               
               <p>unmarshalInterface unmarshals a single XML element into val.
start is the opening tag of the element.</p>
               
               <pre><code class="language-go">func (d *Decoder) unmarshalInterface(val Unmarshaler, start *StartElement) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unmarshalPath" data-name="unmarshalPath">
               <h3>
                  unmarshalPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unmarshalPath" class="anchor" title="Link to unmarshalPath">#</a>
               </h3>
               
               <p>unmarshalPath walks down an XML structure looking for wanted
paths, and calls unmarshal on them.
The consumed result tells whether XML elements have been consumed
from the Decoder until start's matching end element, or if it's
still untouched because start is uninteresting for sv's fields.</p>
               
               <pre><code class="language-go">func (d *Decoder) unmarshalPath(tinfo *typeInfo, sv reflect.Value, parents []string, start *StartElement, depth int) (consumed bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unmarshalTextInterface" data-name="unmarshalTextInterface">
               <h3>
                  unmarshalTextInterface 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unmarshalTextInterface" class="anchor" title="Link to unmarshalTextInterface">#</a>
               </h3>
               
               <p>unmarshalTextInterface unmarshals a single XML element into val.
The chardata contained in the element (but not its children)
is passed to the text unmarshaler.</p>
               
               <pre><code class="language-go">func (d *Decoder) unmarshalTextInterface(val encoding.TextUnmarshaler) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="value" data-name="value">
               <h3>
                  value 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#value" class="anchor" title="Link to value">#</a>
               </h3>
               
               <p>value returns v's field value corresponding to finfo.
It's equivalent to v.FieldByIndex(finfo.idx), but when passed
initNilPointers, it initializes and dereferences pointers as necessary.
When passed dontInitNilPointers and a nil pointer is reached, the function
returns a zero reflect.Value.</p>
               
               <pre><code class="language-go">func (finfo *fieldInfo) value(v reflect.Value, shouldInitNilPointers bool) reflect.Value</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeEnd" data-name="writeEnd">
               <h3>
                  writeEnd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeEnd" class="anchor" title="Link to writeEnd">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) writeEnd(name Name) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeIndent" data-name="writeIndent">
               <h3>
                  writeIndent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeIndent" class="anchor" title="Link to writeIndent">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) writeIndent(depthDelta int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeStart" data-name="writeStart">
               <h3>
                  writeStart 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeStart" class="anchor" title="Link to writeStart">#</a>
               </h3>
               
               <p>writeStart writes the given start element.</p>
               
               <pre><code class="language-go">func (p *printer) writeStart(start *StartElement) error</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>