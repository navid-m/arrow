<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - xml</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>xml</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"encoding"
"errors"
"fmt"
"reflect"
"runtime"
"strconv"
"strings"
"fmt"
"reflect"
"strings"
"sync"
"bufio"
"bytes"
"errors"
"fmt"
"io"
"strconv"
"strings"
"unicode"
"unicode/utf8"
"bufio"
"bytes"
"encoding"
"errors"
"fmt"
"io"
"reflect"
"strconv"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="HTMLAutoClose">
               <h3>
                  HTMLAutoClose 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>HTMLAutoClose is the set of HTML elements that
should be considered to close automatically.
See the [Decoder.Strict] and [Decoder.Entity] fields' documentation.</p>
               
               <pre><code>var HTMLAutoClose []string = htmlAutoClose</code></pre>
            </article>
            
            <article class="global" data-name="HTMLEntity">
               <h3>
                  HTMLEntity 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>HTMLEntity is an entity map containing translations for the
standard HTML entity characters.
See the [Decoder.Strict] and [Decoder.Entity] fields' documentation.</p>
               
               <pre><code>var HTMLEntity map[string]string = htmlEntity</code></pre>
            </article>
            
            <article class="global" data-name="Header">
               <h3>
                  Header 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Header is a generic XML header suitable for use with the output of [Marshal].
This is not automatically added to any output of this package,
it is provided as a convenience.</p>
               
               <pre><code>const Header = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="attrType">
               <h3>
                  attrType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var attrType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="begComment">
               <h3>
                  begComment 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var begComment = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="cdataEnd">
               <h3>
                  cdataEnd 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cdataEnd = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="cdataEscape">
               <h3>
                  cdataEscape 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cdataEscape = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="cdataStart">
               <h3>
                  cdataStart 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cdataStart = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ddBytes">
               <h3>
                  ddBytes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var ddBytes = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="dontInitNilPointers">
               <h3>
                  dontInitNilPointers 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const dontInitNilPointers = false</code></pre>
            </article>
            
            <article class="global" data-name="endComment">
               <h3>
                  endComment 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var endComment = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="endProcInst">
               <h3>
                  endProcInst 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var endProcInst = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="entity">
               <h3>
                  entity 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var entity = map[string]rune{...}</code></pre>
            </article>
            
            <article class="global" data-name="errRawToken">
               <h3>
                  errRawToken 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errRawToken = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errUnmarshalDepth">
               <h3>
                  errUnmarshalDepth 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errUnmarshalDepth = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="escAmp">
               <h3>
                  escAmp 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var escAmp = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="escApos">
               <h3>
                  escApos 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var escApos = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="escCR">
               <h3>
                  escCR 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var escCR = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="escFFFD">
               <h3>
                  escFFFD 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var escFFFD = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="escGT">
               <h3>
                  escGT 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var escGT = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="escLT">
               <h3>
                  escLT 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var escLT = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="escNL">
               <h3>
                  escNL 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var escNL = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="escQuot">
               <h3>
                  escQuot 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var escQuot = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="escTab">
               <h3>
                  escTab 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var escTab = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="fAny">
               <h3>
                  fAny 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fAny</code></pre>
            </article>
            
            <article class="global" data-name="fAttr">
               <h3>
                  fAttr 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fAttr</code></pre>
            </article>
            
            <article class="global" data-name="fCDATA">
               <h3>
                  fCDATA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fCDATA</code></pre>
            </article>
            
            <article class="global" data-name="fCharData">
               <h3>
                  fCharData 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fCharData</code></pre>
            </article>
            
            <article class="global" data-name="fComment">
               <h3>
                  fComment 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fComment</code></pre>
            </article>
            
            <article class="global" data-name="fElement">
               <h3>
                  fElement 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fElement fieldFlags = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="fInnerXML">
               <h3>
                  fInnerXML 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fInnerXML</code></pre>
            </article>
            
            <article class="global" data-name="fMode">
               <h3>
                  fMode 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fMode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="fOmitEmpty">
               <h3>
                  fOmitEmpty 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const fOmitEmpty</code></pre>
            </article>
            
            <article class="global" data-name="first">
               <h3>
                  first 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var first = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="htmlAutoClose">
               <h3>
                  htmlAutoClose 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var htmlAutoClose = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="htmlEntity">
               <h3>
                  htmlEntity 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var htmlEntity = map[string]string{...}</code></pre>
            </article>
            
            <article class="global" data-name="initNilPointers">
               <h3>
                  initNilPointers 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const initNilPointers = true</code></pre>
            </article>
            
            <article class="global" data-name="marshalerAttrType">
               <h3>
                  marshalerAttrType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var marshalerAttrType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="marshalerType">
               <h3>
                  marshalerType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var marshalerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxUnmarshalDepth">
               <h3>
                  maxUnmarshalDepth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxUnmarshalDepth = 10000</code></pre>
            </article>
            
            <article class="global" data-name="maxUnmarshalDepthWasm">
               <h3>
                  maxUnmarshalDepthWasm 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxUnmarshalDepthWasm = 5000</code></pre>
            </article>
            
            <article class="global" data-name="nameType">
               <h3>
                  nameType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var nameType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="second">
               <h3>
                  second 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var second = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="stkEOF">
               <h3>
                  stkEOF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stkEOF</code></pre>
            </article>
            
            <article class="global" data-name="stkNs">
               <h3>
                  stkNs 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stkNs</code></pre>
            </article>
            
            <article class="global" data-name="stkStart">
               <h3>
                  stkStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stkStart = iota</code></pre>
            </article>
            
            <article class="global" data-name="textMarshalerType">
               <h3>
                  textMarshalerType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var textMarshalerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="textUnmarshalerType">
               <h3>
                  textUnmarshalerType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var textUnmarshalerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="tinfoMap">
               <h3>
                  tinfoMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var tinfoMap sync.Map</code></pre>
            </article>
            
            <article class="global" data-name="unmarshalerAttrType">
               <h3>
                  unmarshalerAttrType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var unmarshalerAttrType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="unmarshalerType">
               <h3>
                  unmarshalerType 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var unmarshalerType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="xmlName">
               <h3>
                  xmlName 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const xmlName = "XMLName"</code></pre>
            </article>
            
            <article class="global" data-name="xmlPrefix">
               <h3>
                  xmlPrefix 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const xmlPrefix = "xml"</code></pre>
            </article>
            
            <article class="global" data-name="xmlURL">
               <h3>
                  xmlURL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const xmlURL = "http://www.w3.org/XML/1998/namespace"</code></pre>
            </article>
            
            <article class="global" data-name="xmlnsPrefix">
               <h3>
                  xmlnsPrefix 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const xmlnsPrefix = "xmlns"</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="CharData">
               <h3>
                  CharData
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A CharData represents XML character data (raw text),
in which XML escape sequences have been replaced by
the characters they represent.</p>
               
               <pre><code>type CharData []byte</code></pre>
            </article>
            
            <article class="type" data-name="Comment">
               <h3>
                  Comment
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Comment represents an XML comment of the form <!--comment-->.
The bytes do not include the <!-- and --> comment markers.</p>
               
               <pre><code>type Comment []byte</code></pre>
            </article>
            
            <article class="type" data-name="Directive">
               <h3>
                  Directive
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Directive represents an XML directive of the form <!text>.
The bytes do not include the <! and > markers.</p>
               
               <pre><code>type Directive []byte</code></pre>
            </article>
            
            <article class="type" data-name="Token">
               <h3>
                  Token
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Token is an interface holding one of the token types:
[StartElement], [EndElement], [CharData], [Comment], [ProcInst], or [Directive].</p>
               
               <pre><code>type Token any</code></pre>
            </article>
            
            <article class="type" data-name="UnmarshalError">
               <h3>
                  UnmarshalError
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An UnmarshalError represents an error in the unmarshaling process.</p>
               
               <pre><code>type UnmarshalError string</code></pre>
            </article>
            
            <article class="type" data-name="fieldFlags">
               <h3>
                  fieldFlags
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type fieldFlags int</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Marshaler">
               <h3>
                  Marshaler
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Marshaler is the interface implemented by objects that can marshal
themselves into valid XML elements.
MarshalXML encodes the receiver as zero or more XML elements.
By convention, arrays or slices are typically encoded as a sequence
of elements, one per entry.
Using start as the element tag is not required, but doing so
will enable [Unmarshal] to match the XML elements to the correct
struct field.
One common implementation strategy is to construct a separate
value with a layout corresponding to the desired XML and then
to encode it using e.EncodeElement.
Another common strategy is to use repeated calls to e.EncodeToken
to generate the XML output one token at a time.
The sequence of encoded tokens must make up zero or more valid
XML elements.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Marshaler interface {
MarshalXML(e *Encoder, start StartElement) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="MarshalerAttr">
               <h3>
                  MarshalerAttr
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>MarshalerAttr is the interface implemented by objects that can marshal
themselves into valid XML attributes.
MarshalXMLAttr returns an XML attribute with the encoded value of the receiver.
Using name as the attribute name is not required, but doing so
will enable [Unmarshal] to match the attribute to the correct
struct field.
If MarshalXMLAttr returns the zero attribute [Attr]{}, no attribute
will be generated in the output.
MarshalXMLAttr is used only for struct fields with the
"attr" option in the field tag.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type MarshalerAttr interface {
MarshalXMLAttr(name Name) (Attr, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="TokenReader">
               <h3>
                  TokenReader
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A TokenReader is anything that can decode a stream of XML tokens, including a
[Decoder].
When Token encounters an error or end-of-file condition after successfully
reading a token, it returns the token. It may return the (non-nil) error from
the same call or return the error (and a nil token) from a subsequent call.
An instance of this general case is that a TokenReader returning a non-nil
token at the end of the token stream may return either io.EOF or a nil error.
The next Read should return nil, [io.EOF].
Implementations of Token are discouraged from returning a nil token with a
nil error. Callers should treat a return of nil, nil as indicating that
nothing happened; in particular it does not indicate EOF.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type TokenReader interface {
Token() (Token, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Unmarshaler">
               <h3>
                  Unmarshaler
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Unmarshaler is the interface implemented by objects that can unmarshal
an XML element description of themselves.
UnmarshalXML decodes a single XML element
beginning with the given start element.
If it returns an error, the outer call to Unmarshal stops and
returns that error.
UnmarshalXML must consume exactly one XML element.
One common implementation strategy is to unmarshal into
a separate value with a layout matching the expected XML
using d.DecodeElement, and then to copy the data from
that value into the receiver.
Another common strategy is to use d.Token to process the
XML object one token at a time.
UnmarshalXML may not use d.RawToken.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Unmarshaler interface {
UnmarshalXML(d *Decoder, start StartElement) error
}</code></pre>
            </article>
            
            <article class="interface" data-name="UnmarshalerAttr">
               <h3>
                  UnmarshalerAttr
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>UnmarshalerAttr is the interface implemented by objects that can unmarshal
an XML attribute description of themselves.
UnmarshalXMLAttr decodes a single XML attribute.
If it returns an error, the outer call to [Unmarshal] stops and
returns that error.
UnmarshalXMLAttr is used only for struct fields with the
"attr" option in the field tag.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type UnmarshalerAttr interface {
UnmarshalXMLAttr(attr Attr) error
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Attr">
               <h3>
                  Attr
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Attr represents an attribute in an XML element (Name=Value).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Attr struct {
Name Name
Value string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Decoder">
               <h3>
                  Decoder
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Decoder represents an XML parser reading a particular input stream.
The parser assumes that its input is encoded in UTF-8.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Decoder struct {
Strict bool
AutoClose []string
Entity map[string]string
CharsetReader func(charset string, input io.Reader) (io.Reader, error)
DefaultSpace string
r io.ByteReader
t TokenReader
buf bytes.Buffer
saved *bytes.Buffer
stk *stack
free *stack
needClose bool
toClose Name
nextToken Token
nextByte int
ns map[string]string
err error
line int
linestart int64
offset int64
unmarshalDepth int
}</code></pre>
            </article>
            
            <article class="struct" data-name="Encoder">
               <h3>
                  Encoder
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Encoder writes XML data to an output stream.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Encoder struct {
p printer
}</code></pre>
            </article>
            
            <article class="struct" data-name="EndElement">
               <h3>
                  EndElement
                  <span class="badge">struct</span>
               </h3>
               
               <p>An EndElement represents an XML end element.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type EndElement struct {
Name Name
}</code></pre>
            </article>
            
            <article class="struct" data-name="Name">
               <h3>
                  Name
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Name represents an XML name (Local) annotated
with a name space identifier (Space).
In tokens returned by [Decoder.Token], the Space identifier
is given as a canonical URL, not the short prefix used
in the document being parsed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Name struct {
Space string
Local string
}</code></pre>
            </article>
            
            <article class="struct" data-name="ProcInst">
               <h3>
                  ProcInst
                  <span class="badge">struct</span>
               </h3>
               
               <p>A ProcInst represents an XML processing instruction of the form <?target inst?></p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ProcInst struct {
Target string
Inst []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="StartElement">
               <h3>
                  StartElement
                  <span class="badge">struct</span>
               </h3>
               
               <p>A StartElement represents an XML start element.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StartElement struct {
Name Name
Attr []Attr
}</code></pre>
            </article>
            
            <article class="struct" data-name="SyntaxError">
               <h3>
                  SyntaxError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A SyntaxError represents a syntax error in the XML input stream.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SyntaxError struct {
Msg string
Line int
}</code></pre>
            </article>
            
            <article class="struct" data-name="TagPathError">
               <h3>
                  TagPathError
                  <span class="badge">struct</span>
               </h3>
               
               <p>A TagPathError represents an error in the unmarshaling process
caused by the use of field tags with conflicting paths.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TagPathError struct {
Struct reflect.Type
Field1 string
Tag1 string
Field2 string
Tag2 string
}</code></pre>
            </article>
            
            <article class="struct" data-name="UnsupportedTypeError">
               <h3>
                  UnsupportedTypeError
                  <span class="badge">struct</span>
               </h3>
               
               <p>UnsupportedTypeError is returned when [Marshal] encounters a type
that cannot be converted into XML.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UnsupportedTypeError struct {
Type reflect.Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="fieldInfo">
               <h3>
                  fieldInfo
                  <span class="badge">struct</span>
               </h3>
               
               <p>fieldInfo holds details for the xml representation of a single field.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fieldInfo struct {
idx []int
name string
xmlns string
flags fieldFlags
parents []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="parentStack">
               <h3>
                  parentStack
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type parentStack struct {
p *printer
stack []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="printer">
               <h3>
                  printer
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type printer struct {
w *bufio.Writer
encoder *Encoder
seq int
indent string
prefix string
depth int
indentedIn bool
putNewline bool
attrNS map[string]string
attrPrefix map[string]string
prefixes []string
tags []Name
closed bool
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="stack">
               <h3>
                  stack
                  <span class="badge">struct</span>
               </h3>
               
               <p>Parsing state - stack holds old name space translations
and the current set of open elements. The translations to pop when
ending a given tag are *below* it on the stack, which is
more work but forced on us by XML.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stack struct {
next *stack
kind int
name Name
ok bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="typeInfo">
               <h3>
                  typeInfo
                  <span class="badge">struct</span>
               </h3>
               
               <p>typeInfo holds details for the xml representation of a type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type typeInfo struct {
xmlname *fieldInfo
fields []fieldInfo
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close the Encoder, indicating that no more data will be written. It flushes
any buffered XML to the underlying writer and returns an error if the
written XML is invalid (e.g. by containing unclosed elements).</p>
               
               <pre><code>func (p *printer) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close the Encoder, indicating that no more data will be written. It flushes
any buffered XML to the underlying writer and returns an error if the
written XML is invalid (e.g. by containing unclosed elements).</p>
               
               <pre><code>func (enc *Encoder) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copy creates a new copy of ProcInst.</p>
               
               <pre><code>func (p ProcInst) Copy() ProcInst</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copy creates a new copy of StartElement.</p>
               
               <pre><code>func (e StartElement) Copy() StartElement</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copy creates a new copy of Comment.</p>
               
               <pre><code>func (c Comment) Copy() Comment</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copy creates a new copy of CharData.</p>
               
               <pre><code>func (c CharData) Copy() CharData</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copy creates a new copy of Directive.</p>
               
               <pre><code>func (d Directive) Copy() Directive</code></pre>
            </article>
            
            <article class="function" data-name="CopyToken">
               <h3>
                  CopyToken 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CopyToken returns a copy of a Token.</p>
               
               <pre><code>func CopyToken(t Token) Token</code></pre>
            </article>
            
            <article class="function" data-name="Decode">
               <h3>
                  Decode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Decode works like [Unmarshal], except it reads the decoder
stream to find the start element.</p>
               
               <pre><code>func (d *Decoder) Decode(v any) error</code></pre>
            </article>
            
            <article class="function" data-name="DecodeElement">
               <h3>
                  DecodeElement 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DecodeElement works like [Unmarshal] except that it takes
a pointer to the start XML element to decode into v.
It is useful when a client reads some raw XML tokens itself
but also wants to defer to [Unmarshal] for some elements.</p>
               
               <pre><code>func (d *Decoder) DecodeElement(v any, start *StartElement) error</code></pre>
            </article>
            
            <article class="function" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Encode writes the XML encoding of v to the stream.
See the documentation for [Marshal] for details about the conversion
of Go values to XML.
Encode calls [Encoder.Flush] before returning.</p>
               
               <pre><code>func (enc *Encoder) Encode(v any) error</code></pre>
            </article>
            
            <article class="function" data-name="EncodeElement">
               <h3>
                  EncodeElement 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>EncodeElement writes the XML encoding of v to the stream,
using start as the outermost tag in the encoding.
See the documentation for [Marshal] for details about the conversion
of Go values to XML.
EncodeElement calls [Encoder.Flush] before returning.</p>
               
               <pre><code>func (enc *Encoder) EncodeElement(v any, start StartElement) error</code></pre>
            </article>
            
            <article class="function" data-name="EncodeToken">
               <h3>
                  EncodeToken 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>EncodeToken writes the given XML token to the stream.
It returns an error if [StartElement] and [EndElement] tokens are not properly matched.
EncodeToken does not call [Encoder.Flush], because usually it is part of a larger operation
such as [Encoder.Encode] or [Encoder.EncodeElement] (or a custom [Marshaler]'s MarshalXML invoked
during those), and those will call Flush when finished.
Callers that create an Encoder and then invoke EncodeToken directly, without
using Encode or EncodeElement, need to call Flush when finished to ensure
that the XML is written to the underlying writer.
EncodeToken allows writing a [ProcInst] with Target set to "xml" only as the first token
in the stream.</p>
               
               <pre><code>func (enc *Encoder) EncodeToken(t Token) error</code></pre>
            </article>
            
            <article class="function" data-name="End">
               <h3>
                  End 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>End returns the corresponding XML end element.</p>
               
               <pre><code>func (e StartElement) End() EndElement</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *TagPathError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e UnmarshalError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *SyntaxError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *UnsupportedTypeError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Escape">
               <h3>
                  Escape 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Escape is like [EscapeText] but omits the error return value.
It is provided for backwards compatibility with Go 1.0.
Code targeting Go 1.1 or later should use [EscapeText].</p>
               
               <pre><code>func Escape(w io.Writer, s []byte)</code></pre>
            </article>
            
            <article class="function" data-name="EscapeString">
               <h3>
                  EscapeString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>EscapeString writes to p the properly escaped XML equivalent
of the plain text data s.</p>
               
               <pre><code>func (p *printer) EscapeString(s string)</code></pre>
            </article>
            
            <article class="function" data-name="EscapeText">
               <h3>
                  EscapeText 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>EscapeText writes to w the properly escaped XML equivalent
of the plain text data s.</p>
               
               <pre><code>func EscapeText(w io.Writer, s []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Flush flushes any buffered XML to the underlying writer.
See the [Encoder.EncodeToken] documentation for details about when it is necessary.</p>
               
               <pre><code>func (enc *Encoder) Flush() error</code></pre>
            </article>
            
            <article class="function" data-name="Indent">
               <h3>
                  Indent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Indent sets the encoder to generate XML in which each element
begins on a new indented line that starts with prefix and is followed by
one or more copies of indent according to the nesting depth.</p>
               
               <pre><code>func (enc *Encoder) Indent(prefix string, indent string)</code></pre>
            </article>
            
            <article class="function" data-name="InputOffset">
               <h3>
                  InputOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>InputOffset returns the input stream byte offset of the current decoder position.
The offset gives the location of the end of the most recently returned token
and the beginning of the next token.</p>
               
               <pre><code>func (d *Decoder) InputOffset() int64</code></pre>
            </article>
            
            <article class="function" data-name="InputPos">
               <h3>
                  InputPos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>InputPos returns the line of the current decoder position and the 1 based
input position of the line. The position gives the location of the end of the
most recently returned token.</p>
               
               <pre><code>func (d *Decoder) InputPos() (line int, column int)</code></pre>
            </article>
            
            <article class="function" data-name="Marshal">
               <h3>
                  Marshal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Marshal returns the XML encoding of v.
Marshal handles an array or slice by marshaling each of the elements.
Marshal handles a pointer by marshaling the value it points at or, if the
pointer is nil, by writing nothing. Marshal handles an interface value by
marshaling the value it contains or, if the interface value is nil, by
writing nothing. Marshal handles all other data by writing one or more XML
elements containing the data.
The name for the XML elements is taken from, in order of preference:
- the tag on the XMLName field, if the data is a struct
- the value of the XMLName field of type [Name]
- the tag of the struct field used to obtain the data
- the name of the struct field used to obtain the data
- the name of the marshaled type
The XML element for a struct contains marshaled elements for each of the
exported fields of the struct, with these exceptions:
- the XMLName field, described above, is omitted.
- a field with tag "-" is omitted.
- a field with tag "name,attr" becomes an attribute with
the given name in the XML element.
- a field with tag ",attr" becomes an attribute with the
field name in the XML element.
- a field with tag ",chardata" is written as character data,
not as an XML element.
- a field with tag ",cdata" is written as character data
wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.
- a field with tag ",innerxml" is written verbatim, not subject
to the usual marshaling procedure.
- a field with tag ",comment" is written as an XML comment, not
subject to the usual marshaling procedure. It must not contain
the "--" string within it.
- a field with a tag including the "omitempty" option is omitted
if the field value is empty. The empty values are false, 0, any
nil pointer or interface value, and any array, slice, map, or
string of length zero.
- an anonymous struct field is handled as if the fields of its
value were part of the outer struct.
- an anonymous struct field of interface type is treated the same as having
that type as its name, rather than being anonymous.
- a field implementing [Marshaler] is written by calling its MarshalXML
method.
- a field implementing [encoding.TextMarshaler] is written by encoding the
result of its MarshalText method as text.
If a field uses a tag "a>b>c", then the element c will be nested inside
parent elements a and b. Fields that appear next to each other that name
the same parent will be enclosed in one XML element.
If the XML name for a struct field is defined by both the field tag and the
struct's XMLName field, the names must match.
See [MarshalIndent] for an example.
Marshal will return an error if asked to marshal a channel, function, or map.</p>
               
               <pre><code>func Marshal(v any) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalIndent">
               <h3>
                  MarshalIndent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MarshalIndent works like [Marshal], but each XML element begins on a new
indented line that starts with prefix and is followed by one or more
copies of indent according to the nesting depth.</p>
               
               <pre><code>func MarshalIndent(v any, prefix string, indent string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewDecoder">
               <h3>
                  NewDecoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewDecoder creates a new XML parser reading from r.
If r does not implement [io.ByteReader], NewDecoder will
do its own buffering.</p>
               
               <pre><code>func NewDecoder(r io.Reader) *Decoder</code></pre>
            </article>
            
            <article class="function" data-name="NewEncoder">
               <h3>
                  NewEncoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewEncoder returns a new encoder that writes to w.</p>
               
               <pre><code>func NewEncoder(w io.Writer) *Encoder</code></pre>
            </article>
            
            <article class="function" data-name="NewTokenDecoder">
               <h3>
                  NewTokenDecoder 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewTokenDecoder creates a new XML parser using an underlying token stream.</p>
               
               <pre><code>func NewTokenDecoder(t TokenReader) *Decoder</code></pre>
            </article>
            
            <article class="function" data-name="RawToken">
               <h3>
                  RawToken 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RawToken is like [Decoder.Token] but does not verify that
start and end elements match and does not translate
name space prefixes to their corresponding URLs.</p>
               
               <pre><code>func (d *Decoder) RawToken() (Token, error)</code></pre>
            </article>
            
            <article class="function" data-name="Skip">
               <h3>
                  Skip 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Skip reads tokens until it has consumed the end element
matching the most recent start element already consumed,
skipping nested structures.
It returns nil if it finds an end element matching the start
element; otherwise it returns an error describing the problem.</p>
               
               <pre><code>func (d *Decoder) Skip() error</code></pre>
            </article>
            
            <article class="function" data-name="Token">
               <h3>
                  Token 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Token returns the next XML token in the input stream.
At the end of the input stream, Token returns nil, [io.EOF].
Slices of bytes in the returned token data refer to the
parser's internal buffer and remain valid only until the next
call to Token. To acquire a copy of the bytes, call [CopyToken]
or the token's Copy method.
Token expands self-closing elements such as <br>
into separate start and end elements returned by successive calls.
Token guarantees that the [StartElement] and [EndElement]
tokens it returns are properly nested and matched:
if Token encounters an unexpected end element
or EOF before all expected end elements,
it will return an error.
If [Decoder.CharsetReader] is called and returns an error,
the error is wrapped and returned.
Token implements XML name spaces as described by
https://www.w3.org/TR/REC-xml-names/. Each of the
[Name] structures contained in the Token has the Space
set to the URL identifying its name space when known.
If Token encounters an unrecognized name space prefix,
it uses the prefix as the Space rather than report an error.</p>
               
               <pre><code>func (d *Decoder) Token() (Token, error)</code></pre>
            </article>
            
            <article class="function" data-name="Unmarshal">
               <h3>
                  Unmarshal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Unmarshal parses the XML-encoded data and stores the result in
the value pointed to by v, which must be an arbitrary struct,
slice, or string. Well-formed data that does not fit into v is
discarded.
Because Unmarshal uses the reflect package, it can only assign
to exported (upper case) fields. Unmarshal uses a case-sensitive
comparison to match XML element names to tag values and struct
field names.
Unmarshal maps an XML element to a struct using the following rules.
In the rules, the tag of a field refers to the value associated with the
key 'xml' in the struct field's tag (see the example above).
- If the struct has a field of type []byte or string with tag
",innerxml", Unmarshal accumulates the raw XML nested inside the
element in that field. The rest of the rules still apply.
- If the struct has a field named XMLName of type Name,
Unmarshal records the element name in that field.
- If the XMLName field has an associated tag of the form
"name" or "namespace-URL name", the XML element must have
the given name (and, optionally, name space) or else Unmarshal
returns an error.
- If the XML element has an attribute whose name matches a
struct field name with an associated tag containing ",attr" or
the explicit name in a struct field tag of the form "name,attr",
Unmarshal records the attribute value in that field.
- If the XML element has an attribute not handled by the previous
rule and the struct has a field with an associated tag containing
",any,attr", Unmarshal records the attribute value in the first
such field.
- If the XML element contains character data, that data is
accumulated in the first struct field that has tag ",chardata".
The struct field may have type []byte or string.
If there is no such field, the character data is discarded.
- If the XML element contains comments, they are accumulated in
the first struct field that has tag ",comment".  The struct
field may have type []byte or string. If there is no such
field, the comments are discarded.
- If the XML element contains a sub-element whose name matches
the prefix of a tag formatted as "a" or "a>b>c", unmarshal
will descend into the XML structure looking for elements with the
given names, and will map the innermost elements to that struct
field. A tag starting with ">" is equivalent to one starting
with the field name followed by ">".
- If the XML element contains a sub-element whose name matches
a struct field's XMLName tag and the struct field has no
explicit name tag as per the previous rule, unmarshal maps
the sub-element to that struct field.
- If the XML element contains a sub-element whose name matches a
field without any mode flags (",attr", ",chardata", etc), Unmarshal
maps the sub-element to that struct field.
- If the XML element contains a sub-element that hasn't matched any
of the above rules and the struct has a field with tag ",any",
unmarshal maps the sub-element to that struct field.
- An anonymous struct field is handled as if the fields of its
value were part of the outer struct.
- A struct field with tag "-" is never unmarshaled into.
If Unmarshal encounters a field type that implements the Unmarshaler
interface, Unmarshal calls its UnmarshalXML method to produce the value from
the XML element.  Otherwise, if the value implements
[encoding.TextUnmarshaler], Unmarshal calls that value's UnmarshalText method.
Unmarshal maps an XML element to a string or []byte by saving the
concatenation of that element's character data in the string or
[]byte. The saved []byte is never nil.
Unmarshal maps an attribute value to a string or []byte by saving
the value in the string or slice.
Unmarshal maps an attribute value to an [Attr] by saving the attribute,
including its name, in the Attr.
Unmarshal maps an XML element or attribute value to a slice by
extending the length of the slice and mapping the element or attribute
to the newly created value.
Unmarshal maps an XML element or attribute value to a bool by
setting it to the boolean value represented by the string. Whitespace
is trimmed and ignored.
Unmarshal maps an XML element or attribute value to an integer or
floating-point field by setting the field to the result of
interpreting the string value in decimal. There is no check for
overflow. Whitespace is trimmed and ignored.
Unmarshal maps an XML element to a Name by recording the element
name.
Unmarshal maps an XML element to a pointer by setting the pointer
to a freshly allocated value and then mapping the element to that value.
A missing element or empty attribute value will be unmarshaled as a zero value.
If the field is a slice, a zero value will be appended to the field. Otherwise, the
field will be set to its zero value.</p>
               
               <pre><code>func Unmarshal(data []byte, v any) error</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write implements io.Writer</p>
               
               <pre><code>func (p *printer) Write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="WriteByte">
               <h3>
                  WriteByte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteByte implements io.ByteWriter</p>
               
               <pre><code>func (p *printer) WriteByte(c byte) error</code></pre>
            </article>
            
            <article class="function" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>WriteString implements io.StringWriter</p>
               
               <pre><code>func (p *printer) WriteString(s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="addFieldInfo">
               <h3>
                  addFieldInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>addFieldInfo adds finfo to tinfo.fields if there are no
conflicts, or if conflicts arise from previous fields that were
obtained from deeper embedded structures than finfo. In the latter
case, the conflicting entries are dropped.
A conflict occurs when the path (parent + name) to a field is
itself a prefix of another path, or when two paths match exactly.
It is okay for field paths to share a common, shorter prefix.</p>
               
               <pre><code>func addFieldInfo(typ reflect.Type, tinfo *typeInfo, newf *fieldInfo) error</code></pre>
            </article>
            
            <article class="function" data-name="attrval">
               <h3>
                  attrval 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *Decoder) attrval() []byte</code></pre>
            </article>
            
            <article class="function" data-name="autoClose">
               <h3>
                  autoClose 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>If the top element on the stack is autoclosing and
t is not the end tag, invent the end tag.</p>
               
               <pre><code>func (d *Decoder) autoClose(t Token) (Token, bool)</code></pre>
            </article>
            
            <article class="function" data-name="cachedWriteError">
               <h3>
                  cachedWriteError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>return the bufio Writer's cached write error</p>
               
               <pre><code>func (p *printer) cachedWriteError() error</code></pre>
            </article>
            
            <article class="function" data-name="copyValue">
               <h3>
                  copyValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func copyValue(dst reflect.Value, src []byte) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="createAttrPrefix">
               <h3>
                  createAttrPrefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>createAttrPrefix finds the name space prefix attribute to use for the given name space,
defining a new prefix if necessary. It returns the prefix.</p>
               
               <pre><code>func (p *printer) createAttrPrefix(url string) string</code></pre>
            </article>
            
            <article class="function" data-name="defaultStart">
               <h3>
                  defaultStart 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>defaultStart returns the default start element to use,
given the reflect type, field info, and start template.</p>
               
               <pre><code>func defaultStart(typ reflect.Type, finfo *fieldInfo, startTemplate *StartElement) StartElement</code></pre>
            </article>
            
            <article class="function" data-name="deleteAttrPrefix">
               <h3>
                  deleteAttrPrefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>deleteAttrPrefix removes an attribute name space prefix.</p>
               
               <pre><code>func (p *printer) deleteAttrPrefix(prefix string)</code></pre>
            </article>
            
            <article class="function" data-name="emitCDATA">
               <h3>
                  emitCDATA 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>emitCDATA writes to w the CDATA-wrapped plain text data s.
It escapes CDATA directives nested in s.</p>
               
               <pre><code>func emitCDATA(w io.Writer, s []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="escapeText">
               <h3>
                  escapeText 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>escapeText writes to w the properly escaped XML equivalent
of the plain text data s. If escapeNewline is true, newline
characters will be escaped.</p>
               
               <pre><code>func escapeText(w io.Writer, s []byte, escapeNewline bool) error</code></pre>
            </article>
            
            <article class="function" data-name="getTypeInfo">
               <h3>
                  getTypeInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>getTypeInfo returns the typeInfo structure with details necessary
for marshaling and unmarshaling typ.</p>
               
               <pre><code>func getTypeInfo(typ reflect.Type) (*typeInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="getc">
               <h3>
                  getc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read a single byte.
If there is no byte to read, return ok==false
and leave the error in d.err.
Maintain line number.</p>
               
               <pre><code>func (d *Decoder) getc() (b byte, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="indirect">
               <h3>
                  indirect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>indirect drills into interfaces and pointers, returning the pointed-at value.
If it encounters a nil interface or pointer, indirect returns that nil value.
This can turn into an infinite loop given a cyclic chain,
but it matches the Go 1 behavior.</p>
               
               <pre><code>func indirect(vf reflect.Value) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="isEmptyValue">
               <h3>
                  isEmptyValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isEmptyValue(v reflect.Value) bool</code></pre>
            </article>
            
            <article class="function" data-name="isInCharacterRange">
               <h3>
                  isInCharacterRange 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Decide whether the given rune is in the XML Character Range, per
the Char production of https://www.xml.com/axml/testaxml.htm,
Section 2.2 Characters.</p>
               
               <pre><code>func isInCharacterRange(r rune) (inrange bool)</code></pre>
            </article>
            
            <article class="function" data-name="isName">
               <h3>
                  isName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isName(s []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="isNameByte">
               <h3>
                  isNameByte 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isNameByte(c byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="isNameString">
               <h3>
                  isNameString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isNameString(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isValidDirective">
               <h3>
                  isValidDirective 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isValidDirective reports whether dir is a valid directive text,
meaning angle brackets are matched, ignoring comments and strings.</p>
               
               <pre><code>func isValidDirective(dir Directive) bool</code></pre>
            </article>
            
            <article class="function" data-name="lookupXMLName">
               <h3>
                  lookupXMLName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lookupXMLName returns the fieldInfo for typ's XMLName field
in case it exists and has a valid xml field tag, otherwise
it returns nil.</p>
               
               <pre><code>func lookupXMLName(typ reflect.Type) (xmlname *fieldInfo)</code></pre>
            </article>
            
            <article class="function" data-name="markPrefix">
               <h3>
                  markPrefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *printer) markPrefix()</code></pre>
            </article>
            
            <article class="function" data-name="marshalAttr">
               <h3>
                  marshalAttr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>marshalAttr marshals an attribute with the given name and value, adding to start.Attr.</p>
               
               <pre><code>func (p *printer) marshalAttr(start *StartElement, name Name, val reflect.Value) error</code></pre>
            </article>
            
            <article class="function" data-name="marshalInterface">
               <h3>
                  marshalInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>marshalInterface marshals a Marshaler interface value.</p>
               
               <pre><code>func (p *printer) marshalInterface(val Marshaler, start StartElement) error</code></pre>
            </article>
            
            <article class="function" data-name="marshalSimple">
               <h3>
                  marshalSimple 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *printer) marshalSimple(typ reflect.Type, val reflect.Value) (string, []byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="marshalStruct">
               <h3>
                  marshalStruct 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error</code></pre>
            </article>
            
            <article class="function" data-name="marshalTextInterface">
               <h3>
                  marshalTextInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>marshalTextInterface marshals a TextMarshaler interface value.</p>
               
               <pre><code>func (p *printer) marshalTextInterface(val encoding.TextMarshaler, start StartElement) error</code></pre>
            </article>
            
            <article class="function" data-name="marshalValue">
               <h3>
                  marshalValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>marshalValue writes one or more XML elements representing val.
If val was obtained from a struct field, finfo must have its details.</p>
               
               <pre><code>func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo, startTemplate *StartElement) error</code></pre>
            </article>
            
            <article class="function" data-name="mustgetc">
               <h3>
                  mustgetc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Must read a single byte.
If there is no byte to read,
set d.err to SyntaxError("unexpected EOF")
and return ok==false</p>
               
               <pre><code>func (d *Decoder) mustgetc() (b byte, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="name">
               <h3>
                  name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Get name: /first(first|second)
Do not set d.err if the name is missing (unless unexpected EOF is received):
let the caller provide better context.</p>
               
               <pre><code>func (d *Decoder) name() (s string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="nsname">
               <h3>
                  nsname 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Get name space name: name with a : stuck in the middle.
The part before the : is the name space identifier.</p>
               
               <pre><code>func (d *Decoder) nsname() (name Name, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="pop">
               <h3>
                  pop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *Decoder) pop() *stack</code></pre>
            </article>
            
            <article class="function" data-name="popEOF">
               <h3>
                  popEOF 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Undo a pushEOF.
The element must have been finished, so the EOF should be at the top of the stack.</p>
               
               <pre><code>func (d *Decoder) popEOF() bool</code></pre>
            </article>
            
            <article class="function" data-name="popElement">
               <h3>
                  popElement 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Record that we are ending an element with the given name.
The name must match the record at the top of the stack,
which must be a pushElement record.
After popping the element, apply any undo records from
the stack to restore the name translations that existed
before we saw this element.</p>
               
               <pre><code>func (d *Decoder) popElement(t *EndElement) bool</code></pre>
            </article>
            
            <article class="function" data-name="popPrefix">
               <h3>
                  popPrefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *printer) popPrefix()</code></pre>
            </article>
            
            <article class="function" data-name="procInst">
               <h3>
                  procInst 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>procInst parses the `param="..."` or `param='...'`
value out of the provided string, returning "" if not found.</p>
               
               <pre><code>func procInst(param string, s string) string</code></pre>
            </article>
            
            <article class="function" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *Decoder) push(kind int) *stack</code></pre>
            </article>
            
            <article class="function" data-name="push">
               <h3>
                  push 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>push adds parent elements to the stack and writes open tags.</p>
               
               <pre><code>func (s *parentStack) push(parents []string) error</code></pre>
            </article>
            
            <article class="function" data-name="pushEOF">
               <h3>
                  pushEOF 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Record that after the current element is finished
(that element is already pushed on the stack)
Token should return EOF until popEOF is called.</p>
               
               <pre><code>func (d *Decoder) pushEOF()</code></pre>
            </article>
            
            <article class="function" data-name="pushElement">
               <h3>
                  pushElement 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Record that we are starting an element with the given name.</p>
               
               <pre><code>func (d *Decoder) pushElement(name Name)</code></pre>
            </article>
            
            <article class="function" data-name="pushNs">
               <h3>
                  pushNs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Record that we are changing the value of ns[local].
The old value is url, ok.</p>
               
               <pre><code>func (d *Decoder) pushNs(local string, url string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="rawToken">
               <h3>
                  rawToken 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *Decoder) rawToken() (Token, error)</code></pre>
            </article>
            
            <article class="function" data-name="readName">
               <h3>
                  readName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read a name and append its bytes to d.buf.
The name is delimited by any single-byte character not valid in names.
All multi-byte characters are accepted; the caller must check their validity.</p>
               
               <pre><code>func (d *Decoder) readName() (ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="receiverType">
               <h3>
                  receiverType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>receiverType returns the receiver type to use in an expression like "%s.MethodName".</p>
               
               <pre><code>func receiverType(val any) string</code></pre>
            </article>
            
            <article class="function" data-name="savedOffset">
               <h3>
                  savedOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Return saved offset.
If we did ungetc (nextByte >= 0), have to back up one.</p>
               
               <pre><code>func (d *Decoder) savedOffset() int</code></pre>
            </article>
            
            <article class="function" data-name="space">
               <h3>
                  space 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Skip spaces if any</p>
               
               <pre><code>func (d *Decoder) space()</code></pre>
            </article>
            
            <article class="function" data-name="structFieldInfo">
               <h3>
                  structFieldInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>structFieldInfo builds and returns a fieldInfo for f.</p>
               
               <pre><code>func structFieldInfo(typ reflect.Type, f *reflect.StructField) (*fieldInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="switchToReader">
               <h3>
                  switchToReader 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *Decoder) switchToReader(r io.Reader)</code></pre>
            </article>
            
            <article class="function" data-name="syntaxError">
               <h3>
                  syntaxError 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Creates a SyntaxError with the current line number.</p>
               
               <pre><code>func (d *Decoder) syntaxError(msg string) error</code></pre>
            </article>
            
            <article class="function" data-name="text">
               <h3>
                  text 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read plain text section (XML calls it character data).
If quote >= 0, we are in a quoted string and need to find the matching quote.
If cdata == true, we are in a <![CDATA[ section and need to find ]]>.
On failure return nil and leave the error in d.err.</p>
               
               <pre><code>func (d *Decoder) text(quote int, cdata bool) []byte</code></pre>
            </article>
            
            <article class="function" data-name="translate">
               <h3>
                  translate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Apply name space translation to name n.
The default name space (for Space=="")
applies only to element names, not to attribute names.</p>
               
               <pre><code>func (d *Decoder) translate(n *Name, isElementName bool)</code></pre>
            </article>
            
            <article class="function" data-name="trim">
               <h3>
                  trim 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>trim updates the XML context to match the longest common prefix of the stack
and the given parents. A closing tag will be written for every parent
popped. Passing a zero slice or nil will close all the elements.</p>
               
               <pre><code>func (s *parentStack) trim(parents []string) error</code></pre>
            </article>
            
            <article class="function" data-name="ungetc">
               <h3>
                  ungetc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Unread a single byte.</p>
               
               <pre><code>func (d *Decoder) ungetc(b byte)</code></pre>
            </article>
            
            <article class="function" data-name="unmarshal">
               <h3>
                  unmarshal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Unmarshal a single XML element into val.</p>
               
               <pre><code>func (d *Decoder) unmarshal(val reflect.Value, start *StartElement, depth int) error</code></pre>
            </article>
            
            <article class="function" data-name="unmarshalAttr">
               <h3>
                  unmarshalAttr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unmarshalAttr unmarshals a single XML attribute into val.</p>
               
               <pre><code>func (d *Decoder) unmarshalAttr(val reflect.Value, attr Attr) error</code></pre>
            </article>
            
            <article class="function" data-name="unmarshalInterface">
               <h3>
                  unmarshalInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unmarshalInterface unmarshals a single XML element into val.
start is the opening tag of the element.</p>
               
               <pre><code>func (d *Decoder) unmarshalInterface(val Unmarshaler, start *StartElement) error</code></pre>
            </article>
            
            <article class="function" data-name="unmarshalPath">
               <h3>
                  unmarshalPath 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unmarshalPath walks down an XML structure looking for wanted
paths, and calls unmarshal on them.
The consumed result tells whether XML elements have been consumed
from the Decoder until start's matching end element, or if it's
still untouched because start is uninteresting for sv's fields.</p>
               
               <pre><code>func (d *Decoder) unmarshalPath(tinfo *typeInfo, sv reflect.Value, parents []string, start *StartElement, depth int) (consumed bool, err error)</code></pre>
            </article>
            
            <article class="function" data-name="unmarshalTextInterface">
               <h3>
                  unmarshalTextInterface 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unmarshalTextInterface unmarshals a single XML element into val.
The chardata contained in the element (but not its children)
is passed to the text unmarshaler.</p>
               
               <pre><code>func (d *Decoder) unmarshalTextInterface(val encoding.TextUnmarshaler) error</code></pre>
            </article>
            
            <article class="function" data-name="value">
               <h3>
                  value 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>value returns v's field value corresponding to finfo.
It's equivalent to v.FieldByIndex(finfo.idx), but when passed
initNilPointers, it initializes and dereferences pointers as necessary.
When passed dontInitNilPointers and a nil pointer is reached, the function
returns a zero reflect.Value.</p>
               
               <pre><code>func (finfo *fieldInfo) value(v reflect.Value, shouldInitNilPointers bool) reflect.Value</code></pre>
            </article>
            
            <article class="function" data-name="writeEnd">
               <h3>
                  writeEnd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *printer) writeEnd(name Name) error</code></pre>
            </article>
            
            <article class="function" data-name="writeIndent">
               <h3>
                  writeIndent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *printer) writeIndent(depthDelta int)</code></pre>
            </article>
            
            <article class="function" data-name="writeStart">
               <h3>
                  writeStart 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>writeStart writes the given start element.</p>
               
               <pre><code>func (p *printer) writeStart(start *StartElement) error</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
