<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - scripttest</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>scripttest</code>
         </h1>
         <hr />
         
         <article class="global" data-name="readmeTmpl">
            <h2>readmeTmpl</h2>
            <hr />
            
            <pre><code>readmeTmpl</code></pre>
         </article>
          
         <article class="struct" data-name="ToolReplacement">
            <h2>type ToolReplacement struct</h2>
            <hr />
            
            <p>ToolReplacement records the name of a tool to replace
within a given GOROOT for script testing purposes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ToolName string
ReplacementPath string
EnvVar string</code></pre>
         </article>
         
         <article class="struct" data-name="skipError">
            <h2>type skipError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">msg string</code></pre>
         </article>
          
         <article class="function" data-name="SetupTestGoRoot">
            <h2>SetupTestGoRoot</h2>
            <hr />
            
            <p>SetupTestGoRoot sets up a temporary GOROOT for use with script test
execution. It copies the existing goroot bin and pkg dirs using
symlinks (if possible) or raw copying. Return value is the path to
the newly created testgoroot dir.</p>
            
            <pre><code>func SetupTestGoRoot(t *testing.T, tmpdir string, goroot string) string</code></pre>
         </article>
         
         <article class="function" data-name="ReplaceGoToolInTestGoRoot">
            <h2>ReplaceGoToolInTestGoRoot</h2>
            <hr />
            
            <p>ReplaceGoToolInTestGoRoot replaces the go tool binary toolname with
an alternate executable newtoolpath within a test GOROOT directory
previously created by SetupTestGoRoot.</p>
            
            <pre><code>func ReplaceGoToolInTestGoRoot(t *testing.T, testgoroot string, toolname string, newtoolpath string)</code></pre>
         </article>
         
         <article class="function" data-name="linkOrCopy">
            <h2>linkOrCopy</h2>
            <hr />
            
            <p>linkOrCopy creates a link to src at dst, or if the symlink fails
(platform doesn't support) then copies src to dst.</p>
            
            <pre><code>func linkOrCopy(t *testing.T, src string, dst string)</code></pre>
         </article>
         
         <article class="function" data-name="AddToolChainScriptConditions">
            <h2>AddToolChainScriptConditions</h2>
            <hr />
            
            <p>AddToolChainScriptConditions accepts a [script.Cond] map and adds into it a
set of commonly used conditions for doing toolchains testing,
including whether the platform supports cgo, a buildmode condition,
support for GOEXPERIMENT testing, etc. Callers must also pass in
current GOHOSTOOS/GOHOSTARCH settings, since some of the conditions
introduced can be influenced by them.</p>
            
            <pre><code>func AddToolChainScriptConditions(t *testing.T, conds *ast.MapType, goHostOS string, goHostArch string)</code></pre>
         </article>
         
         <article class="function" data-name="sysCondition">
            <h2>sysCondition</h2>
            <hr />
            
            <pre><code>func sysCondition(flag string, f func, needsCgo bool, goHostOS string, goHostArch string) script.Cond</code></pre>
         </article>
         
         <article class="function" data-name="hasBuildmode">
            <h2>hasBuildmode</h2>
            <hr />
            
            <pre><code>func hasBuildmode(s *script.State, mode string) (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="cgoLinkExt">
            <h2>cgoLinkExt</h2>
            <hr />
            
            <pre><code>func cgoLinkExt(s *script.State) (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="mustLinkExt">
            <h2>mustLinkExt</h2>
            <hr />
            
            <pre><code>func mustLinkExt(s *script.State) (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="pieLinkExt">
            <h2>pieLinkExt</h2>
            <hr />
            
            <pre><code>func pieLinkExt(s *script.State) (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="hasGodebug">
            <h2>hasGodebug</h2>
            <hr />
            
            <pre><code>func hasGodebug(s *script.State, value string) (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="hasGoexperiment">
            <h2>hasGoexperiment</h2>
            <hr />
            
            <pre><code>func hasGoexperiment(s *script.State, value string) (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="checkScriptReadme">
            <h2>checkScriptReadme</h2>
            <hr />
            
            <pre><code>func checkScriptReadme(t *testing.T, engine *script.Engine, env []string, scriptspath string, gotool string, fixReadme bool)</code></pre>
         </article>
         
         <article class="function" data-name="RunToolScriptTest">
            <h2>RunToolScriptTest</h2>
            <hr />
            
            <p>RunToolScriptTest kicks off a set of script tests runs for
a tool of some sort (compiler, linker, etc). The expectation
is that we'll be called from the top level cmd/X dir for tool X,
and that instead of executing the install tool X we'll use the
test binary instead.</p>
            
            <pre><code>func RunToolScriptTest(t *testing.T, repls []ToolReplacement, scriptsdir string, fixReadme bool)</code></pre>
         </article>
         
         <article class="function" data-name="RunTests">
            <h2>RunTests</h2>
            <hr />
            
            <p>RunTests kicks off one or more script-based tests using the
specified engine, running all test files that match pattern.
This function adapted from Russ's rsc.io/script/scripttest#Run
function, which was in turn forked off cmd/go's runner.</p>
            
            <pre><code>func RunTests(t *testing.T, ctx context.Context, engine *script.Engine, env []string, pattern string)</code></pre>
         </article>
         
         <article class="function" data-name="initScriptDirs">
            <h2>initScriptDirs</h2>
            <hr />
            
            <pre><code>func initScriptDirs(t testing.TB, s *script.State)</code></pre>
         </article>
         
         <article class="function" data-name="tempEnvName">
            <h2>tempEnvName</h2>
            <hr />
            
            <pre><code>func tempEnvName() string</code></pre>
         </article>
         
         <article class="function" data-name="scriptCC">
            <h2>scriptCC</h2>
            <hr />
            
            <p>scriptCC runs the platform C compiler.</p>
            
            <pre><code>func scriptCC(cmdExec script.Cmd, ccexe string) script.Cmd</code></pre>
         </article>
         
         <article class="function" data-name="DefaultCmds">
            <h2>DefaultCmds</h2>
            <hr />
            
            <p>DefaultCmds returns a set of broadly useful script commands.

This set includes all of the commands in script.DefaultCmds,
as well as a "skip" command that halts the script and causes the
testing.TB passed to Run to be skipped.</p>
            
            <pre><code>func DefaultCmds() *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="DefaultConds">
            <h2>DefaultConds</h2>
            <hr />
            
            <p>DefaultConds returns a set of broadly useful script conditions.

This set includes all of the conditions in script.DefaultConds,
as well as:

  - Conditions of the form "exec:foo" are active when the executable "foo" is
    found in the test process's PATH, and inactive when the executable is
    not found.

  - "short" is active when testing.Short() is true.

  - "verbose" is active when testing.Verbose() is true.</p>
            
            <pre><code>func DefaultConds() *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="Run">
            <h2>Run</h2>
            <hr />
            
            <p>Run runs the script from the given filename starting at the given initial state.
When the script completes, Run closes the state.</p>
            
            <pre><code>func Run(t testing.TB, e *script.Engine, s *script.State, filename string, testScript io.Reader)</code></pre>
         </article>
         
         <article class="function" data-name="Skip">
            <h2>Skip</h2>
            <hr />
            
            <p>Skip returns a sentinel error that causes Run to mark the test as skipped.</p>
            
            <pre><code>func Skip() script.Cmd</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="CachedExec">
            <h2>CachedExec</h2>
            <hr />
            
            <p>CachedExec returns a Condition that reports whether the PATH of the test
binary itself (not the script's current environment) contains the named
executable.</p>
            
            <pre><code>func CachedExec() script.Cond</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
