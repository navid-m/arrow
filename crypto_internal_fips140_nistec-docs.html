<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - nistec</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="crypto_internal_fips140_nistec__asm-docs.html">_asm</a>
         <br />
         
         <a href="crypto_internal_fips140_nistec_fiat-docs.html">fiat</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>nistec</code>
         </h1>
         <hr />
         
         <article class="global" data-name="p256ElementLength">
            <h2>p256ElementLength</h2>
            <hr />
            
            <pre><code>p256ElementLength</code></pre>
         </article>
         
         <article class="global" data-name="p256UncompressedLength">
            <h2>p256UncompressedLength</h2>
            <hr />
            
            <pre><code>p256UncompressedLength</code></pre>
         </article>
         
         <article class="global" data-name="p256CompressedLength">
            <h2>p256CompressedLength</h2>
            <hr />
            
            <pre><code>p256CompressedLength</code></pre>
         </article>
         
         <article class="global" data-name="_p256B">
            <h2>_p256B</h2>
            <hr />
            
            <pre><code>_p256B *fiat.P256Element</code></pre>
         </article>
         
         <article class="global" data-name="_p256BOnce">
            <h2>_p256BOnce</h2>
            <hr />
            
            <pre><code>_p256BOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="p256GeneratorTables">
            <h2>p256GeneratorTables</h2>
            <hr />
            
            <p>p256GeneratorTables is a series of precomputed multiples of G, the canonical
generator. The first p256AffineTable contains multiples of G. The second one
multiples of [2⁶]G, the third one of [2¹²]G, and so on, where each successive
table is the previous table doubled six times. Six is the width of the
sliding window used in ScalarBaseMult, and having each table already
pre-doubled lets us avoid the doublings between windows entirely. This table
aliases into p256PrecomputedEmbed.</p>
            
            <pre><code>p256GeneratorTables *[]p256AffineTable</code></pre>
         </article>
         
         <article class="global" data-name="p256One">
            <h2>p256One</h2>
            <hr />
            
            <p>p256One is one in the Montgomery domain.</p>
            
            <pre><code>p256One</code></pre>
         </article>
         
         <article class="global" data-name="p256Zero">
            <h2>p256Zero</h2>
            <hr />
            
            <pre><code>p256Zero</code></pre>
         </article>
         
         <article class="global" data-name="p256P">
            <h2>p256P</h2>
            <hr />
            
            <p>p256P is 2²⁵⁶ - 2²²⁴ + 2¹⁹² + 2⁹⁶ - 1 in the Montgomery domain.</p>
            
            <pre><code>p256P</code></pre>
         </article>
         
         <article class="global" data-name="p256ElementLength">
            <h2>p256ElementLength</h2>
            <hr />
            
            <pre><code>p256ElementLength</code></pre>
         </article>
         
         <article class="global" data-name="p256UncompressedLength">
            <h2>p256UncompressedLength</h2>
            <hr />
            
            <pre><code>p256UncompressedLength</code></pre>
         </article>
         
         <article class="global" data-name="p256CompressedLength">
            <h2>p256CompressedLength</h2>
            <hr />
            
            <pre><code>p256CompressedLength</code></pre>
         </article>
         
         <article class="global" data-name="p256Precomputed">
            <h2>p256Precomputed</h2>
            <hr />
            
            <p>p256Precomputed is a series of precomputed multiples of G, the canonical
generator. The first p256AffineTable contains multiples of G. The second one
multiples of [2⁶]G, the third one of [2¹²]G, and so on, where each successive
table is the previous table doubled six times. Six is the width of the
sliding window used in p256ScalarBaseMult, and having each table already
pre-doubled lets us avoid the doublings between windows entirely. This table
aliases into p256PrecomputedEmbed.</p>
            
            <pre><code>p256Precomputed *[]p256AffineTable</code></pre>
         </article>
         
         <article class="global" data-name="p384ElementLength">
            <h2>p384ElementLength</h2>
            <hr />
            
            <p>p384ElementLength is the length of an element of the base or scalar field,
which have the same bytes length for all NIST P curves.</p>
            
            <pre><code>p384ElementLength</code></pre>
         </article>
         
         <article class="global" data-name="_p384B">
            <h2>_p384B</h2>
            <hr />
            
            <pre><code>_p384B *fiat.P384Element</code></pre>
         </article>
         
         <article class="global" data-name="_p384BOnce">
            <h2>_p384BOnce</h2>
            <hr />
            
            <pre><code>_p384BOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="p384GeneratorTable">
            <h2>p384GeneratorTable</h2>
            <hr />
            
            <pre><code>p384GeneratorTable *[]p384Table</code></pre>
         </article>
         
         <article class="global" data-name="p384GeneratorTableOnce">
            <h2>p384GeneratorTableOnce</h2>
            <hr />
            
            <pre><code>p384GeneratorTableOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="p521ElementLength">
            <h2>p521ElementLength</h2>
            <hr />
            
            <p>p521ElementLength is the length of an element of the base or scalar field,
which have the same bytes length for all NIST P curves.</p>
            
            <pre><code>p521ElementLength</code></pre>
         </article>
         
         <article class="global" data-name="_p521B">
            <h2>_p521B</h2>
            <hr />
            
            <pre><code>_p521B *fiat.P521Element</code></pre>
         </article>
         
         <article class="global" data-name="_p521BOnce">
            <h2>_p521BOnce</h2>
            <hr />
            
            <pre><code>_p521BOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="p521GeneratorTable">
            <h2>p521GeneratorTable</h2>
            <hr />
            
            <pre><code>p521GeneratorTable *[]p521Table</code></pre>
         </article>
         
         <article class="global" data-name="p521GeneratorTableOnce">
            <h2>p521GeneratorTableOnce</h2>
            <hr />
            
            <pre><code>p521GeneratorTableOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="p224ElementLength">
            <h2>p224ElementLength</h2>
            <hr />
            
            <p>p224ElementLength is the length of an element of the base or scalar field,
which have the same bytes length for all NIST P curves.</p>
            
            <pre><code>p224ElementLength</code></pre>
         </article>
         
         <article class="global" data-name="_p224B">
            <h2>_p224B</h2>
            <hr />
            
            <pre><code>_p224B *fiat.P224Element</code></pre>
         </article>
         
         <article class="global" data-name="_p224BOnce">
            <h2>_p224BOnce</h2>
            <hr />
            
            <pre><code>_p224BOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="p224GeneratorTable">
            <h2>p224GeneratorTable</h2>
            <hr />
            
            <pre><code>p224GeneratorTable *[]p224Table</code></pre>
         </article>
         
         <article class="global" data-name="p224GeneratorTableOnce">
            <h2>p224GeneratorTableOnce</h2>
            <hr />
            
            <pre><code>p224GeneratorTableOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="p224GG">
            <h2>p224GG</h2>
            <hr />
            
            <pre><code>p224GG *[]fiat.P224Element</code></pre>
         </article>
         
         <article class="global" data-name="p224GGOnce">
            <h2>p224GGOnce</h2>
            <hr />
            
            <pre><code>p224GGOnce sync.Once</code></pre>
         </article>
         
         <article class="global" data-name="p256PrecomputedEmbed">
            <h2>p256PrecomputedEmbed</h2>
            <hr />
            
            <p>p256PrecomputedEmbed is the precomputed table of P-256 basepoint multiples.
See [p256Precomputed]. It's not embedded with go:embed because it's not
supported within the FIPS module boundary.</p>
            
            <pre><code>p256PrecomputedEmbed</code></pre>
         </article>
          
         <article class="struct" data-name="P256Point">
            <h2>type P256Point struct</h2>
            <hr />
            
            <p>P256Point is a P-256 point. The zero value is NOT valid.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">x fiat.P256Element
y fiat.P256Element
z fiat.P256Element</code></pre>
         </article>
         
         <article class="struct" data-name="p256AffinePoint">
            <h2>type p256AffinePoint struct</h2>
            <hr />
            
            <p>p256AffinePoint is a point in affine coordinates (x, y). x and y are still
Montgomery domain elements. The point can't be the point at infinity.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">x fiat.P256Element
y fiat.P256Element</code></pre>
         </article>
         
         <article class="struct" data-name="P256Point">
            <h2>type P256Point struct</h2>
            <hr />
            
            <p>P256Point is a P-256 point. The zero value should not be assumed to be valid
(although it is in this implementation).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">x p256Element
y p256Element
z p256Element</code></pre>
         </article>
         
         <article class="struct" data-name="p256AffinePoint">
            <h2>type p256AffinePoint struct</h2>
            <hr />
            
            <p>p256AffinePoint is a point in affine coordinates (x, y). x and y are still
Montgomery domain elements. The point can't be the point at infinity.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">x p256Element
y p256Element</code></pre>
         </article>
         
         <article class="struct" data-name="P384Point">
            <h2>type P384Point struct</h2>
            <hr />
            
            <p>P384Point is a P384 point. The zero value is NOT valid.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">x *fiat.P384Element
y *fiat.P384Element
z *fiat.P384Element</code></pre>
         </article>
         
         <article class="struct" data-name="P521Point">
            <h2>type P521Point struct</h2>
            <hr />
            
            <p>P521Point is a P521 point. The zero value is NOT valid.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">x *fiat.P521Element
y *fiat.P521Element
z *fiat.P521Element</code></pre>
         </article>
         
         <article class="struct" data-name="P224Point">
            <h2>type P224Point struct</h2>
            <hr />
            
            <p>P224Point is a P224 point. The zero value is NOT valid.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">x *fiat.P224Element
y *fiat.P224Element
z *fiat.P224Element</code></pre>
         </article>
          
         <article class="function" data-name="NewP256Point">
            <h2>NewP256Point</h2>
            <hr />
            
            <p>NewP256Point returns a new P256Point representing the point at infinity point.</p>
            
            <pre><code>func NewP256Point() *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="SetGenerator">
            <h2>SetGenerator</h2>
            <hr />
            
            <p>SetGenerator sets p to the canonical generator and returns p.</p>
            
            <pre><code>func SetGenerator() *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>Set sets p = q and returns p.</p>
            
            <pre><code>func Set(q *P256Point) *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="SetBytes">
            <h2>SetBytes</h2>
            <hr />
            
            <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
            
            <pre><code>func SetBytes(b []byte) (*P256Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="p256B">
            <h2>p256B</h2>
            <hr />
            
            <pre><code>func p256B() *fiat.P256Element</code></pre>
         </article>
         
         <article class="function" data-name="p256Polynomial">
            <h2>p256Polynomial</h2>
            <hr />
            
            <p>p256Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
            
            <pre><code>func p256Polynomial(y2 *fiat.P256Element, x *fiat.P256Element) *fiat.P256Element</code></pre>
         </article>
         
         <article class="function" data-name="p256CheckOnCurve">
            <h2>p256CheckOnCurve</h2>
            <hr />
            
            <pre><code>func p256CheckOnCurve(x *fiat.P256Element, y *fiat.P256Element) error</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
            
            <pre><code>func Bytes() []byte</code></pre>
         </article>
         
         <article class="function" data-name="bytes">
            <h2>bytes</h2>
            <hr />
            
            <pre><code>func bytes(out *[]byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="BytesX">
            <h2>BytesX</h2>
            <hr />
            
            <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
            
            <pre><code>func BytesX() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="bytesX">
            <h2>bytesX</h2>
            <hr />
            
            <pre><code>func bytesX(out *[]byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="BytesCompressed">
            <h2>BytesCompressed</h2>
            <hr />
            
            <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
            
            <pre><code>func BytesCompressed() []byte</code></pre>
         </article>
         
         <article class="function" data-name="bytesCompressed">
            <h2>bytesCompressed</h2>
            <hr />
            
            <pre><code>func bytesCompressed(out *[]byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
            
            <pre><code>func Add(p1 *P256Point, p2 *P256Point) *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="Double">
            <h2>Double</h2>
            <hr />
            
            <p>Double sets q = p + p, and returns q. The points may overlap.</p>
            
            <pre><code>func Double(p *P256Point) *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="Projective">
            <h2>Projective</h2>
            <hr />
            
            <pre><code>func Projective() *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="AddAffine">
            <h2>AddAffine</h2>
            <hr />
            
            <p>AddAffine sets q = p1 + p2, if infinity == 0, and to p1 if infinity == 1.
p2 can't be the point at infinity as it can't be represented in affine
coordinates, instead callers can set p2 to an arbitrary point and set
infinity to 1.</p>
            
            <pre><code>func AddAffine(p1 *P256Point, p2 *p256AffinePoint, infinity int) *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="Select">
            <h2>Select</h2>
            <hr />
            
            <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
            
            <pre><code>func Select(p1 *P256Point, p2 *P256Point, cond int) *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="SetBytes">
            <h2>SetBytes</h2>
            <hr />
            
            <p>SetBytes sets s to the big-endian value of x, reducing it as necessary.</p>
            
            <pre><code>func SetBytes(x []byte) (*p256OrdElement, error)</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <pre><code>func Bytes() []byte</code></pre>
         </article>
         
         <article class="function" data-name="Rsh">
            <h2>Rsh</h2>
            <hr />
            
            <p>Rsh returns the 64 least significant bits of x >> n. n must be lower
than 256. The value of n leaks through timing side-channels.</p>
            
            <pre><code>func Rsh(n int) uint64</code></pre>
         </article>
         
         <article class="function" data-name="Select">
            <h2>Select</h2>
            <hr />
            
            <p>Select selects the n-th multiple of the table base point into p. It works in
constant time. n must be in [0, 16]. If n is 0, p is set to the identity point.</p>
            
            <pre><code>func Select(p *P256Point, n uint8)</code></pre>
         </article>
         
         <article class="function" data-name="Compute">
            <h2>Compute</h2>
            <hr />
            
            <p>Compute populates the table to the first 16 multiples of q.</p>
            
            <pre><code>func Compute(q *P256Point) *p256Table</code></pre>
         </article>
         
         <article class="function" data-name="boothW5">
            <h2>boothW5</h2>
            <hr />
            
            <pre><code>func boothW5(in uint64) (uint8, int)</code></pre>
         </article>
         
         <article class="function" data-name="ScalarMult">
            <h2>ScalarMult</h2>
            <hr />
            
            <p>ScalarMult sets r = scalar * q, where scalar is a 32-byte big endian value,
and returns r. If scalar is not 32 bytes long, ScalarMult returns an error
and the receiver is unchanged.</p>
            
            <pre><code>func ScalarMult(q *P256Point, scalar []byte) (*P256Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="Negate">
            <h2>Negate</h2>
            <hr />
            
            <p>Negate sets p to -p, if cond == 1, and to p if cond == 0.</p>
            
            <pre><code>func Negate(cond int) *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="Select">
            <h2>Select</h2>
            <hr />
            
            <p>Select selects the n-th multiple of the table base point into p. It works in
constant time. n can be in [0, 32], but (unlike p256Table.Select) if n is 0,
p is set to an undefined value.</p>
            
            <pre><code>func Select(p *p256AffinePoint, n uint8)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="boothW6">
            <h2>boothW6</h2>
            <hr />
            
            <pre><code>func boothW6(in uint64) (uint8, int)</code></pre>
         </article>
         
         <article class="function" data-name="ScalarBaseMult">
            <h2>ScalarBaseMult</h2>
            <hr />
            
            <p>ScalarBaseMult sets p = scalar * generator, where scalar is a 32-byte big
endian value, and returns r. If scalar is not 32 bytes long, ScalarBaseMult
returns an error and the receiver is unchanged.</p>
            
            <pre><code>func ScalarBaseMult(scalar []byte) (*P256Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="Negate">
            <h2>Negate</h2>
            <hr />
            
            <p>Negate sets p to -p, if cond == 1, and to p if cond == 0.</p>
            
            <pre><code>func Negate(cond int) *p256AffinePoint</code></pre>
         </article>
         
         <article class="function" data-name="p256Sqrt">
            <h2>p256Sqrt</h2>
            <hr />
            
            <p>p256Sqrt sets e to a square root of x. If x is not a square, p256Sqrt returns
false and e is unchanged. e and x can overlap.</p>
            
            <pre><code>func p256Sqrt(e *fiat.P256Element, x *fiat.P256Element) isSquare bool</code></pre>
         </article>
         
         <article class="function" data-name="p256Square">
            <h2>p256Square</h2>
            <hr />
            
            <p>p256Square sets e to the square of x, repeated n times > 1.</p>
            
            <pre><code>func p256Square(e *fiat.P256Element, x *fiat.P256Element, n int)</code></pre>
         </article>
         
         <article class="function" data-name="NewP256Point">
            <h2>NewP256Point</h2>
            <hr />
            
            <p>NewP256Point returns a new P256Point representing the point at infinity.</p>
            
            <pre><code>func NewP256Point() *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="SetGenerator">
            <h2>SetGenerator</h2>
            <hr />
            
            <p>SetGenerator sets p to the canonical generator and returns p.</p>
            
            <pre><code>func SetGenerator() *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>Set sets p = q and returns p.</p>
            
            <pre><code>func Set(q *P256Point) *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="SetBytes">
            <h2>SetBytes</h2>
            <hr />
            
            <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
            
            <pre><code>func SetBytes(b []byte) (*P256Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="p256Polynomial">
            <h2>p256Polynomial</h2>
            <hr />
            
            <p>p256Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
            
            <pre><code>func p256Polynomial(y2 *p256Element, x *p256Element) *p256Element</code></pre>
         </article>
         
         <article class="function" data-name="p256CheckOnCurve">
            <h2>p256CheckOnCurve</h2>
            <hr />
            
            <pre><code>func p256CheckOnCurve(x *p256Element, y *p256Element) error</code></pre>
         </article>
         
         <article class="function" data-name="p256LessThanP">
            <h2>p256LessThanP</h2>
            <hr />
            
            <p>p256LessThanP returns 1 if x < p, and 0 otherwise. Note that a p256Element is
not allowed to be equal to or greater than p, so if this function returns 0
then x is invalid.</p>
            
            <pre><code>func p256LessThanP(x *p256Element) int</code></pre>
         </article>
         
         <article class="function" data-name="p256BigToLittle">
            <h2>p256BigToLittle</h2>
            <hr />
            
            <pre><code>func p256BigToLittle(l *p256Element, b *[]byte)</code></pre>
         </article>
         
         <article class="function" data-name="bytesToLimbs">
            <h2>bytesToLimbs</h2>
            <hr />
            
            <pre><code>func bytesToLimbs(l *[]uint64, b *[]byte)</code></pre>
         </article>
         
         <article class="function" data-name="p256LittleToBig">
            <h2>p256LittleToBig</h2>
            <hr />
            
            <pre><code>func p256LittleToBig(b *[]byte, l *p256Element)</code></pre>
         </article>
         
         <article class="function" data-name="limbsToBytes">
            <h2>limbsToBytes</h2>
            <hr />
            
            <pre><code>func limbsToBytes(b *[]byte, l *[]uint64)</code></pre>
         </article>
         
         <article class="function" data-name="p256Add">
            <h2>p256Add</h2>
            <hr />
            
            <p>p256Add sets res = x + y.</p>
            
            <pre><code>func p256Add(res *p256Element, x *p256Element, y *p256Element)</code></pre>
         </article>
         
         <article class="function" data-name="p256Sqrt">
            <h2>p256Sqrt</h2>
            <hr />
            
            <p>p256Sqrt sets e to a square root of x. If x is not a square, p256Sqrt returns
false and e is unchanged. e and x can overlap.</p>
            
            <pre><code>func p256Sqrt(e *p256Element, x *p256Element) isSquare bool</code></pre>
         </article>
         
         <article class="function" data-name="p256Mul">
            <h2>p256Mul</h2>
            <hr />
            
            <p>Montgomery multiplication. Sets res = in1 * in2 * R⁻¹ mod p.</p>
            
            <pre><code>func p256Mul(res *p256Element, in1 *p256Element, in2 *p256Element)</code></pre>
         </article>
         
         <article class="function" data-name="p256Sqr">
            <h2>p256Sqr</h2>
            <hr />
            
            <p>Montgomery square, repeated n times (n >= 1).</p>
            
            <pre><code>func p256Sqr(res *p256Element, in *p256Element, n int)</code></pre>
         </article>
         
         <article class="function" data-name="p256FromMont">
            <h2>p256FromMont</h2>
            <hr />
            
            <p>Montgomery multiplication by R⁻¹, or 1 outside the domain.
Sets res = in * R⁻¹, bringing res out of the Montgomery domain.</p>
            
            <pre><code>func p256FromMont(res *p256Element, in *p256Element)</code></pre>
         </article>
         
         <article class="function" data-name="p256NegCond">
            <h2>p256NegCond</h2>
            <hr />
            
            <p>If cond is not 0, sets val = -val mod p.</p>
            
            <pre><code>func p256NegCond(val *p256Element, cond int)</code></pre>
         </article>
         
         <article class="function" data-name="p256MovCond">
            <h2>p256MovCond</h2>
            <hr />
            
            <p>If cond is 0, sets res = b, otherwise sets res = a.</p>
            
            <pre><code>func p256MovCond(res *P256Point, a *P256Point, b *P256Point, cond int)</code></pre>
         </article>
         
         <article class="function" data-name="p256Select">
            <h2>p256Select</h2>
            <hr />
            
            <p>p256Select sets res to the point at index idx in the table.
idx must be in [0, 15]. It executes in constant time.</p>
            
            <pre><code>func p256Select(res *P256Point, table *p256Table, idx int)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="p256SelectAffine">
            <h2>p256SelectAffine</h2>
            <hr />
            
            <p>p256SelectAffine sets res to the point at index idx in the table.
idx must be in [0, 31]. It executes in constant time.</p>
            
            <pre><code>func p256SelectAffine(res *p256AffinePoint, table *p256AffineTable, idx int)</code></pre>
         </article>
         
         <article class="function" data-name="p256PointAddAffineAsm">
            <h2>p256PointAddAffineAsm</h2>
            <hr />
            
            <p>Point addition with an affine point and constant time conditions.
If zero is 0, sets res = in2. If sel is 0, sets res = in1.
If sign is not 0, sets res = in1 + -in2. Otherwise, sets res = in1 + in2</p>
            
            <pre><code>func p256PointAddAffineAsm(res *P256Point, in1 *P256Point, in2 *p256AffinePoint, sign int, sel int, zero int)</code></pre>
         </article>
         
         <article class="function" data-name="p256PointAddAsm">
            <h2>p256PointAddAsm</h2>
            <hr />
            
            <p>Point addition. Sets res = in1 + in2. Returns one if the two input points
were equal and zero otherwise. If in1 or in2 are the point at infinity, res
and the return value are undefined.</p>
            
            <pre><code>func p256PointAddAsm(res *P256Point, in1 *P256Point, in2 *P256Point) int</code></pre>
         </article>
         
         <article class="function" data-name="p256PointDoubleAsm">
            <h2>p256PointDoubleAsm</h2>
            <hr />
            
            <p>Point doubling. Sets res = in + in. in can be the point at infinity.</p>
            
            <pre><code>func p256PointDoubleAsm(res *P256Point, in *P256Point)</code></pre>
         </article>
         
         <article class="function" data-name="p256OrdReduce">
            <h2>p256OrdReduce</h2>
            <hr />
            
            <p>p256OrdReduce ensures s is in the range [0, ord(G)-1].</p>
            
            <pre><code>func p256OrdReduce(s *p256OrdElement)</code></pre>
         </article>
         
         <article class="function" data-name="p256OrdLittleToBig">
            <h2>p256OrdLittleToBig</h2>
            <hr />
            
            <pre><code>func p256OrdLittleToBig(b *[]byte, l *p256OrdElement)</code></pre>
         </article>
         
         <article class="function" data-name="p256OrdBigToLittle">
            <h2>p256OrdBigToLittle</h2>
            <hr />
            
            <pre><code>func p256OrdBigToLittle(l *p256OrdElement, b *[]byte)</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
            
            <pre><code>func Add(r1 *P256Point, r2 *P256Point) *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="Double">
            <h2>Double</h2>
            <hr />
            
            <p>Double sets q = p + p, and returns q. The points may overlap.</p>
            
            <pre><code>func Double(p *P256Point) *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="ScalarBaseMult">
            <h2>ScalarBaseMult</h2>
            <hr />
            
            <p>ScalarBaseMult sets r = scalar * generator, where scalar is a 32-byte big
endian value, and returns r. If scalar is not 32 bytes long, ScalarBaseMult
returns an error and the receiver is unchanged.</p>
            
            <pre><code>func ScalarBaseMult(scalar []byte) (*P256Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="ScalarMult">
            <h2>ScalarMult</h2>
            <hr />
            
            <p>ScalarMult sets r = scalar * q, where scalar is a 32-byte big endian value,
and returns r. If scalar is not 32 bytes long, ScalarBaseMult returns an
error and the receiver is unchanged.</p>
            
            <pre><code>func ScalarMult(q *P256Point, scalar []byte) (*P256Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="uint64IsZero">
            <h2>uint64IsZero</h2>
            <hr />
            
            <p>uint64IsZero returns 1 if x is zero and zero otherwise.</p>
            
            <pre><code>func uint64IsZero(x uint64) int</code></pre>
         </article>
         
         <article class="function" data-name="p256Equal">
            <h2>p256Equal</h2>
            <hr />
            
            <p>p256Equal returns 1 if a and b are equal and 0 otherwise.</p>
            
            <pre><code>func p256Equal(a *p256Element, b *p256Element) int</code></pre>
         </article>
         
         <article class="function" data-name="isInfinity">
            <h2>isInfinity</h2>
            <hr />
            
            <p>isInfinity returns 1 if p is the point at infinity and 0 otherwise.</p>
            
            <pre><code>func isInfinity() int</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
            
            <pre><code>func Bytes() []byte</code></pre>
         </article>
         
         <article class="function" data-name="bytes">
            <h2>bytes</h2>
            <hr />
            
            <pre><code>func bytes(out *[]byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="affineFromMont">
            <h2>affineFromMont</h2>
            <hr />
            
            <p>affineFromMont sets (x, y) to the affine coordinates of p, converted out of the
Montgomery domain.</p>
            
            <pre><code>func affineFromMont(x *p256Element, y *p256Element)</code></pre>
         </article>
         
         <article class="function" data-name="BytesX">
            <h2>BytesX</h2>
            <hr />
            
            <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
            
            <pre><code>func BytesX() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="bytesX">
            <h2>bytesX</h2>
            <hr />
            
            <pre><code>func bytesX(out *[]byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="BytesCompressed">
            <h2>BytesCompressed</h2>
            <hr />
            
            <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
            
            <pre><code>func BytesCompressed() []byte</code></pre>
         </article>
         
         <article class="function" data-name="bytesCompressed">
            <h2>bytesCompressed</h2>
            <hr />
            
            <pre><code>func bytesCompressed(out *[]byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Select">
            <h2>Select</h2>
            <hr />
            
            <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
            
            <pre><code>func Select(p1 *P256Point, p2 *P256Point, cond int) *P256Point</code></pre>
         </article>
         
         <article class="function" data-name="p256Inverse">
            <h2>p256Inverse</h2>
            <hr />
            
            <p>p256Inverse sets out to in⁻¹ mod p. If in is zero, out will be zero.</p>
            
            <pre><code>func p256Inverse(out *p256Element, in *p256Element)</code></pre>
         </article>
         
         <article class="function" data-name="boothW5">
            <h2>boothW5</h2>
            <hr />
            
            <pre><code>func boothW5(in uint) (int, int)</code></pre>
         </article>
         
         <article class="function" data-name="boothW6">
            <h2>boothW6</h2>
            <hr />
            
            <pre><code>func boothW6(in uint) (int, int)</code></pre>
         </article>
         
         <article class="function" data-name="p256BaseMult">
            <h2>p256BaseMult</h2>
            <hr />
            
            <pre><code>func p256BaseMult(scalar *p256OrdElement)</code></pre>
         </article>
         
         <article class="function" data-name="p256ScalarMult">
            <h2>p256ScalarMult</h2>
            <hr />
            
            <pre><code>func p256ScalarMult(scalar *p256OrdElement)</code></pre>
         </article>
         
         <article class="function" data-name="NewP384Point">
            <h2>NewP384Point</h2>
            <hr />
            
            <p>NewP384Point returns a new P384Point representing the point at infinity point.</p>
            
            <pre><code>func NewP384Point() *P384Point</code></pre>
         </article>
         
         <article class="function" data-name="SetGenerator">
            <h2>SetGenerator</h2>
            <hr />
            
            <p>SetGenerator sets p to the canonical generator and returns p.</p>
            
            <pre><code>func SetGenerator() *P384Point</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>Set sets p = q and returns p.</p>
            
            <pre><code>func Set(q *P384Point) *P384Point</code></pre>
         </article>
         
         <article class="function" data-name="SetBytes">
            <h2>SetBytes</h2>
            <hr />
            
            <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
            
            <pre><code>func SetBytes(b []byte) (*P384Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="p384B">
            <h2>p384B</h2>
            <hr />
            
            <pre><code>func p384B() *fiat.P384Element</code></pre>
         </article>
         
         <article class="function" data-name="p384Polynomial">
            <h2>p384Polynomial</h2>
            <hr />
            
            <p>p384Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
            
            <pre><code>func p384Polynomial(y2 *fiat.P384Element, x *fiat.P384Element) *fiat.P384Element</code></pre>
         </article>
         
         <article class="function" data-name="p384CheckOnCurve">
            <h2>p384CheckOnCurve</h2>
            <hr />
            
            <pre><code>func p384CheckOnCurve(x *fiat.P384Element, y *fiat.P384Element) error</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
            
            <pre><code>func Bytes() []byte</code></pre>
         </article>
         
         <article class="function" data-name="bytes">
            <h2>bytes</h2>
            <hr />
            
            <pre><code>func bytes(out *[]byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="BytesX">
            <h2>BytesX</h2>
            <hr />
            
            <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
            
            <pre><code>func BytesX() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="bytesX">
            <h2>bytesX</h2>
            <hr />
            
            <pre><code>func bytesX(out *[]byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="BytesCompressed">
            <h2>BytesCompressed</h2>
            <hr />
            
            <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
            
            <pre><code>func BytesCompressed() []byte</code></pre>
         </article>
         
         <article class="function" data-name="bytesCompressed">
            <h2>bytesCompressed</h2>
            <hr />
            
            <pre><code>func bytesCompressed(out *[]byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
            
            <pre><code>func Add(p1 *P384Point, p2 *P384Point) *P384Point</code></pre>
         </article>
         
         <article class="function" data-name="Double">
            <h2>Double</h2>
            <hr />
            
            <p>Double sets q = p + p, and returns q. The points may overlap.</p>
            
            <pre><code>func Double(p *P384Point) *P384Point</code></pre>
         </article>
         
         <article class="function" data-name="Select">
            <h2>Select</h2>
            <hr />
            
            <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
            
            <pre><code>func Select(p1 *P384Point, p2 *P384Point, cond int) *P384Point</code></pre>
         </article>
         
         <article class="function" data-name="Select">
            <h2>Select</h2>
            <hr />
            
            <p>Select selects the n-th multiple of the table base point into p. It works in
constant time by iterating over every entry of the table. n must be in [0, 15].</p>
            
            <pre><code>func Select(p *P384Point, n uint8)</code></pre>
         </article>
         
         <article class="function" data-name="ScalarMult">
            <h2>ScalarMult</h2>
            <hr />
            
            <p>ScalarMult sets p = scalar * q, and returns p.</p>
            
            <pre><code>func ScalarMult(q *P384Point, scalar []byte) (*P384Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="generatorTable">
            <h2>generatorTable</h2>
            <hr />
            
            <p>generatorTable returns a sequence of p384Tables. The first table contains
multiples of G. Each successive table is the previous table doubled four
times.</p>
            
            <pre><code>func generatorTable() *[]p384Table</code></pre>
         </article>
         
         <article class="function" data-name="ScalarBaseMult">
            <h2>ScalarBaseMult</h2>
            <hr />
            
            <p>ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
returns p.</p>
            
            <pre><code>func ScalarBaseMult(scalar []byte) (*P384Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="p384Sqrt">
            <h2>p384Sqrt</h2>
            <hr />
            
            <p>p384Sqrt sets e to a square root of x. If x is not a square, p384Sqrt returns
false and e is unchanged. e and x can overlap.</p>
            
            <pre><code>func p384Sqrt(e *fiat.P384Element, x *fiat.P384Element) isSquare bool</code></pre>
         </article>
         
         <article class="function" data-name="p384SqrtCandidate">
            <h2>p384SqrtCandidate</h2>
            <hr />
            
            <p>p384SqrtCandidate sets z to a square root candidate for x. z and x must not overlap.</p>
            
            <pre><code>func p384SqrtCandidate(z *fiat.P384Element, x *fiat.P384Element)</code></pre>
         </article>
         
         <article class="function" data-name="NewP521Point">
            <h2>NewP521Point</h2>
            <hr />
            
            <p>NewP521Point returns a new P521Point representing the point at infinity point.</p>
            
            <pre><code>func NewP521Point() *P521Point</code></pre>
         </article>
         
         <article class="function" data-name="SetGenerator">
            <h2>SetGenerator</h2>
            <hr />
            
            <p>SetGenerator sets p to the canonical generator and returns p.</p>
            
            <pre><code>func SetGenerator() *P521Point</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>Set sets p = q and returns p.</p>
            
            <pre><code>func Set(q *P521Point) *P521Point</code></pre>
         </article>
         
         <article class="function" data-name="SetBytes">
            <h2>SetBytes</h2>
            <hr />
            
            <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
            
            <pre><code>func SetBytes(b []byte) (*P521Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="p521B">
            <h2>p521B</h2>
            <hr />
            
            <pre><code>func p521B() *fiat.P521Element</code></pre>
         </article>
         
         <article class="function" data-name="p521Polynomial">
            <h2>p521Polynomial</h2>
            <hr />
            
            <p>p521Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
            
            <pre><code>func p521Polynomial(y2 *fiat.P521Element, x *fiat.P521Element) *fiat.P521Element</code></pre>
         </article>
         
         <article class="function" data-name="p521CheckOnCurve">
            <h2>p521CheckOnCurve</h2>
            <hr />
            
            <pre><code>func p521CheckOnCurve(x *fiat.P521Element, y *fiat.P521Element) error</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
            
            <pre><code>func Bytes() []byte</code></pre>
         </article>
         
         <article class="function" data-name="bytes">
            <h2>bytes</h2>
            <hr />
            
            <pre><code>func bytes(out *[]byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="BytesX">
            <h2>BytesX</h2>
            <hr />
            
            <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
            
            <pre><code>func BytesX() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="bytesX">
            <h2>bytesX</h2>
            <hr />
            
            <pre><code>func bytesX(out *[]byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="BytesCompressed">
            <h2>BytesCompressed</h2>
            <hr />
            
            <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
            
            <pre><code>func BytesCompressed() []byte</code></pre>
         </article>
         
         <article class="function" data-name="bytesCompressed">
            <h2>bytesCompressed</h2>
            <hr />
            
            <pre><code>func bytesCompressed(out *[]byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
            
            <pre><code>func Add(p1 *P521Point, p2 *P521Point) *P521Point</code></pre>
         </article>
         
         <article class="function" data-name="Double">
            <h2>Double</h2>
            <hr />
            
            <p>Double sets q = p + p, and returns q. The points may overlap.</p>
            
            <pre><code>func Double(p *P521Point) *P521Point</code></pre>
         </article>
         
         <article class="function" data-name="Select">
            <h2>Select</h2>
            <hr />
            
            <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
            
            <pre><code>func Select(p1 *P521Point, p2 *P521Point, cond int) *P521Point</code></pre>
         </article>
         
         <article class="function" data-name="Select">
            <h2>Select</h2>
            <hr />
            
            <p>Select selects the n-th multiple of the table base point into p. It works in
constant time by iterating over every entry of the table. n must be in [0, 15].</p>
            
            <pre><code>func Select(p *P521Point, n uint8)</code></pre>
         </article>
         
         <article class="function" data-name="ScalarMult">
            <h2>ScalarMult</h2>
            <hr />
            
            <p>ScalarMult sets p = scalar * q, and returns p.</p>
            
            <pre><code>func ScalarMult(q *P521Point, scalar []byte) (*P521Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="generatorTable">
            <h2>generatorTable</h2>
            <hr />
            
            <p>generatorTable returns a sequence of p521Tables. The first table contains
multiples of G. Each successive table is the previous table doubled four
times.</p>
            
            <pre><code>func generatorTable() *[]p521Table</code></pre>
         </article>
         
         <article class="function" data-name="ScalarBaseMult">
            <h2>ScalarBaseMult</h2>
            <hr />
            
            <p>ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
returns p.</p>
            
            <pre><code>func ScalarBaseMult(scalar []byte) (*P521Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="p521Sqrt">
            <h2>p521Sqrt</h2>
            <hr />
            
            <p>p521Sqrt sets e to a square root of x. If x is not a square, p521Sqrt returns
false and e is unchanged. e and x can overlap.</p>
            
            <pre><code>func p521Sqrt(e *fiat.P521Element, x *fiat.P521Element) isSquare bool</code></pre>
         </article>
         
         <article class="function" data-name="p521SqrtCandidate">
            <h2>p521SqrtCandidate</h2>
            <hr />
            
            <p>p521SqrtCandidate sets z to a square root candidate for x. z and x must not overlap.</p>
            
            <pre><code>func p521SqrtCandidate(z *fiat.P521Element, x *fiat.P521Element)</code></pre>
         </article>
         
         <article class="function" data-name="NewP224Point">
            <h2>NewP224Point</h2>
            <hr />
            
            <p>NewP224Point returns a new P224Point representing the point at infinity point.</p>
            
            <pre><code>func NewP224Point() *P224Point</code></pre>
         </article>
         
         <article class="function" data-name="SetGenerator">
            <h2>SetGenerator</h2>
            <hr />
            
            <p>SetGenerator sets p to the canonical generator and returns p.</p>
            
            <pre><code>func SetGenerator() *P224Point</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>Set sets p = q and returns p.</p>
            
            <pre><code>func Set(q *P224Point) *P224Point</code></pre>
         </article>
         
         <article class="function" data-name="SetBytes">
            <h2>SetBytes</h2>
            <hr />
            
            <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
            
            <pre><code>func SetBytes(b []byte) (*P224Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="p224B">
            <h2>p224B</h2>
            <hr />
            
            <pre><code>func p224B() *fiat.P224Element</code></pre>
         </article>
         
         <article class="function" data-name="p224Polynomial">
            <h2>p224Polynomial</h2>
            <hr />
            
            <p>p224Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
            
            <pre><code>func p224Polynomial(y2 *fiat.P224Element, x *fiat.P224Element) *fiat.P224Element</code></pre>
         </article>
         
         <article class="function" data-name="p224CheckOnCurve">
            <h2>p224CheckOnCurve</h2>
            <hr />
            
            <pre><code>func p224CheckOnCurve(x *fiat.P224Element, y *fiat.P224Element) error</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
            
            <pre><code>func Bytes() []byte</code></pre>
         </article>
         
         <article class="function" data-name="bytes">
            <h2>bytes</h2>
            <hr />
            
            <pre><code>func bytes(out *[]byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="BytesX">
            <h2>BytesX</h2>
            <hr />
            
            <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
            
            <pre><code>func BytesX() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="bytesX">
            <h2>bytesX</h2>
            <hr />
            
            <pre><code>func bytesX(out *[]byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="BytesCompressed">
            <h2>BytesCompressed</h2>
            <hr />
            
            <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
            
            <pre><code>func BytesCompressed() []byte</code></pre>
         </article>
         
         <article class="function" data-name="bytesCompressed">
            <h2>bytesCompressed</h2>
            <hr />
            
            <pre><code>func bytesCompressed(out *[]byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
            
            <pre><code>func Add(p1 *P224Point, p2 *P224Point) *P224Point</code></pre>
         </article>
         
         <article class="function" data-name="Double">
            <h2>Double</h2>
            <hr />
            
            <p>Double sets q = p + p, and returns q. The points may overlap.</p>
            
            <pre><code>func Double(p *P224Point) *P224Point</code></pre>
         </article>
         
         <article class="function" data-name="Select">
            <h2>Select</h2>
            <hr />
            
            <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
            
            <pre><code>func Select(p1 *P224Point, p2 *P224Point, cond int) *P224Point</code></pre>
         </article>
         
         <article class="function" data-name="Select">
            <h2>Select</h2>
            <hr />
            
            <p>Select selects the n-th multiple of the table base point into p. It works in
constant time by iterating over every entry of the table. n must be in [0, 15].</p>
            
            <pre><code>func Select(p *P224Point, n uint8)</code></pre>
         </article>
         
         <article class="function" data-name="ScalarMult">
            <h2>ScalarMult</h2>
            <hr />
            
            <p>ScalarMult sets p = scalar * q, and returns p.</p>
            
            <pre><code>func ScalarMult(q *P224Point, scalar []byte) (*P224Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="generatorTable">
            <h2>generatorTable</h2>
            <hr />
            
            <p>generatorTable returns a sequence of p224Tables. The first table contains
multiples of G. Each successive table is the previous table doubled four
times.</p>
            
            <pre><code>func generatorTable() *[]p224Table</code></pre>
         </article>
         
         <article class="function" data-name="ScalarBaseMult">
            <h2>ScalarBaseMult</h2>
            <hr />
            
            <p>ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
returns p.</p>
            
            <pre><code>func ScalarBaseMult(scalar []byte) (*P224Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="p224Sqrt">
            <h2>p224Sqrt</h2>
            <hr />
            
            <p>p224Sqrt sets e to a square root of x. If x is not a square, p224Sqrt returns
false and e is unchanged. e and x can overlap.</p>
            
            <pre><code>func p224Sqrt(e *fiat.P224Element, x *fiat.P224Element) isSquare bool</code></pre>
         </article>
         
         <article class="function" data-name="p224SqrtCandidate">
            <h2>p224SqrtCandidate</h2>
            <hr />
            
            <p>p224SqrtCandidate sets r to a square root candidate for x. r and x must not overlap.</p>
            
            <pre><code>func p224SqrtCandidate(r *fiat.P224Element, x *fiat.P224Element)</code></pre>
         </article>
         
         <article class="function" data-name="dangerousObjs">
            <h2>dangerousObjs</h2>
            <hr />
            
            <p>Lightly adapted from the bytes test package. Allocate a pair of T one at the start of a page, another at the
end. Any access beyond or before the page boundary should cause a fault. This is linux specific.</p>
            
            <pre><code>func dangerousObjs(t *testing.T) (start *T, end *T)</code></pre>
         </article>
         
         <article class="function" data-name="TestP256SelectAffinePageBoundary">
            <h2>TestP256SelectAffinePageBoundary</h2>
            <hr />
            
            <pre><code>func TestP256SelectAffinePageBoundary(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestP256SelectPageBoundary">
            <h2>TestP256SelectPageBoundary</h2>
            <hr />
            
            <pre><code>func TestP256SelectPageBoundary(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="p256OrdMul">
            <h2>p256OrdMul</h2>
            <hr />
            
            <p>Montgomery multiplication modulo org(G). Sets res = in1 * in2 * R⁻¹.</p>
            
            <pre><code>func p256OrdMul(res *p256OrdElement, in1 *p256OrdElement, in2 *p256OrdElement)</code></pre>
         </article>
         
         <article class="function" data-name="p256OrdSqr">
            <h2>p256OrdSqr</h2>
            <hr />
            
            <p>Montgomery square modulo org(G), repeated n times (n >= 1).</p>
            
            <pre><code>func p256OrdSqr(res *p256OrdElement, in *p256OrdElement, n int)</code></pre>
         </article>
         
         <article class="function" data-name="P256OrdInverse">
            <h2>P256OrdInverse</h2>
            <hr />
            
            <pre><code>func P256OrdInverse(k []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="P256OrdInverse">
            <h2>P256OrdInverse</h2>
            <hr />
            
            <pre><code>func P256OrdInverse(k []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestP256PrecomputedTable">
            <h2>TestP256PrecomputedTable</h2>
            <hr />
            
            <pre><code>func TestP256PrecomputedTable(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testP256AffineTable">
            <h2>testP256AffineTable</h2>
            <hr />
            
            <pre><code>func testP256AffineTable(t *testing.T, base *P256Point, table *p256AffineTable)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
