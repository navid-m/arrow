<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - nistec</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="crypto_internal_fips140_nistec__asm-docs.html">_asm</a></li>
               
               <li><a href="crypto_internal_fips140_nistec_fiat-docs.html">fiat</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>nistec</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>_ "crypto/internal/fips140/check"
"crypto/internal/fips140/nistec/fiat"
"crypto/internal/fips140/subtle"
"errors"
"sync"
"crypto/internal/fips140deps/byteorder"
"errors"
"math/bits"
"runtime"
"unsafe"
"crypto/internal/fips140/nistec/fiat"
"crypto/internal/fips140/subtle"
"errors"
"sync"
"crypto/internal/fips140/nistec/fiat"
"sync"
"crypto/internal/fips140/nistec/fiat"
"crypto/internal/fips140/subtle"
"crypto/internal/fips140deps/byteorder"
"crypto/internal/fips140deps/cpu"
"errors"
"math/bits"
"sync"
"unsafe"
"errors"
"errors"
"crypto/internal/fips140/nistec/fiat"
"crypto/internal/fips140/subtle"
"errors"
"sync"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="_p224B" data-name="_p224B">
               <h3>
                  _p224B 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_p224B" class="anchor" title="Link to _p224B">#</a>
               </h3>
               
               <pre><code>var _p224B *fiat.P224Element</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_p224BOnce" data-name="_p224BOnce">
               <h3>
                  _p224BOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_p224BOnce" class="anchor" title="Link to _p224BOnce">#</a>
               </h3>
               
               <pre><code>var _p224BOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_p256B" data-name="_p256B">
               <h3>
                  _p256B 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_p256B" class="anchor" title="Link to _p256B">#</a>
               </h3>
               
               <pre><code>var _p256B *fiat.P256Element</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_p256BOnce" data-name="_p256BOnce">
               <h3>
                  _p256BOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_p256BOnce" class="anchor" title="Link to _p256BOnce">#</a>
               </h3>
               
               <pre><code>var _p256BOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_p384B" data-name="_p384B">
               <h3>
                  _p384B 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_p384B" class="anchor" title="Link to _p384B">#</a>
               </h3>
               
               <pre><code>var _p384B *fiat.P384Element</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_p384BOnce" data-name="_p384BOnce">
               <h3>
                  _p384BOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_p384BOnce" class="anchor" title="Link to _p384BOnce">#</a>
               </h3>
               
               <pre><code>var _p384BOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_p521B" data-name="_p521B">
               <h3>
                  _p521B 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_p521B" class="anchor" title="Link to _p521B">#</a>
               </h3>
               
               <pre><code>var _p521B *fiat.P521Element</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_p521BOnce" data-name="_p521BOnce">
               <h3>
                  _p521BOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_p521BOnce" class="anchor" title="Link to _p521BOnce">#</a>
               </h3>
               
               <pre><code>var _p521BOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p224ElementLength" data-name="p224ElementLength">
               <h3>
                  p224ElementLength 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#p224ElementLength" class="anchor" title="Link to p224ElementLength">#</a>
               </h3>
               
               <p>p224ElementLength is the length of an element of the base or scalar field,
which have the same bytes length for all NIST P curves.</p>
               
               <pre><code>const p224ElementLength = 28</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p224GG" data-name="p224GG">
               <h3>
                  p224GG 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p224GG" class="anchor" title="Link to p224GG">#</a>
               </h3>
               
               <pre><code>var p224GG *[96]fiat.P224Element</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p224GGOnce" data-name="p224GGOnce">
               <h3>
                  p224GGOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p224GGOnce" class="anchor" title="Link to p224GGOnce">#</a>
               </h3>
               
               <pre><code>var p224GGOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p224GeneratorTable" data-name="p224GeneratorTable">
               <h3>
                  p224GeneratorTable 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p224GeneratorTable" class="anchor" title="Link to p224GeneratorTable">#</a>
               </h3>
               
               <pre><code>var p224GeneratorTable *[*ast.BinaryExpr]p224Table</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p224GeneratorTableOnce" data-name="p224GeneratorTableOnce">
               <h3>
                  p224GeneratorTableOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p224GeneratorTableOnce" class="anchor" title="Link to p224GeneratorTableOnce">#</a>
               </h3>
               
               <pre><code>var p224GeneratorTableOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256CompressedLength" data-name="p256CompressedLength">
               <h3>
                  p256CompressedLength 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#p256CompressedLength" class="anchor" title="Link to p256CompressedLength">#</a>
               </h3>
               
               <pre><code>const p256CompressedLength = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256CompressedLength" data-name="p256CompressedLength">
               <h3>
                  p256CompressedLength 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#p256CompressedLength" class="anchor" title="Link to p256CompressedLength">#</a>
               </h3>
               
               <pre><code>const p256CompressedLength = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256ElementLength" data-name="p256ElementLength">
               <h3>
                  p256ElementLength 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#p256ElementLength" class="anchor" title="Link to p256ElementLength">#</a>
               </h3>
               
               <pre><code>const p256ElementLength = 32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256ElementLength" data-name="p256ElementLength">
               <h3>
                  p256ElementLength 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#p256ElementLength" class="anchor" title="Link to p256ElementLength">#</a>
               </h3>
               
               <pre><code>const p256ElementLength = 32</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256GeneratorTables" data-name="p256GeneratorTables">
               <h3>
                  p256GeneratorTables 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p256GeneratorTables" class="anchor" title="Link to p256GeneratorTables">#</a>
               </h3>
               
               <p>p256GeneratorTables is a series of precomputed multiples of G, the canonical
generator. The first p256AffineTable contains multiples of G. The second one
multiples of [2⁶]G, the third one of [2¹²]G, and so on, where each successive
table is the previous table doubled six times. Six is the width of the
sliding window used in ScalarBaseMult, and having each table already
pre-doubled lets us avoid the doublings between windows entirely. This table
aliases into p256PrecomputedEmbed.</p>
               
               <pre><code>var p256GeneratorTables *[43]p256AffineTable</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256One" data-name="p256One">
               <h3>
                  p256One 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p256One" class="anchor" title="Link to p256One">#</a>
               </h3>
               
               <p>p256One is one in the Montgomery domain.</p>
               
               <pre><code>var p256One = p256Element{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256P" data-name="p256P">
               <h3>
                  p256P 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p256P" class="anchor" title="Link to p256P">#</a>
               </h3>
               
               <p>p256P is 2²⁵⁶ - 2²²⁴ + 2¹⁹² + 2⁹⁶ - 1 in the Montgomery domain.</p>
               
               <pre><code>var p256P = p256Element{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256Precomputed" data-name="p256Precomputed">
               <h3>
                  p256Precomputed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p256Precomputed" class="anchor" title="Link to p256Precomputed">#</a>
               </h3>
               
               <p>p256Precomputed is a series of precomputed multiples of G, the canonical
generator. The first p256AffineTable contains multiples of G. The second one
multiples of [2⁶]G, the third one of [2¹²]G, and so on, where each successive
table is the previous table doubled six times. Six is the width of the
sliding window used in p256ScalarBaseMult, and having each table already
pre-doubled lets us avoid the doublings between windows entirely. This table
aliases into p256PrecomputedEmbed.</p>
               
               <pre><code>var p256Precomputed *[43]p256AffineTable</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256PrecomputedEmbed" data-name="p256PrecomputedEmbed">
               <h3>
                  p256PrecomputedEmbed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p256PrecomputedEmbed" class="anchor" title="Link to p256PrecomputedEmbed">#</a>
               </h3>
               
               <p>p256PrecomputedEmbed is the precomputed table of P-256 basepoint multiples.
See [p256Precomputed]. It's not embedded with go:embed because it's not
supported within the FIPS module boundary.</p>
               
               <pre><code>var p256PrecomputedEmbed = [...]byte{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256UncompressedLength" data-name="p256UncompressedLength">
               <h3>
                  p256UncompressedLength 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#p256UncompressedLength" class="anchor" title="Link to p256UncompressedLength">#</a>
               </h3>
               
               <pre><code>const p256UncompressedLength = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256UncompressedLength" data-name="p256UncompressedLength">
               <h3>
                  p256UncompressedLength 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#p256UncompressedLength" class="anchor" title="Link to p256UncompressedLength">#</a>
               </h3>
               
               <pre><code>const p256UncompressedLength = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p256Zero" data-name="p256Zero">
               <h3>
                  p256Zero 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p256Zero" class="anchor" title="Link to p256Zero">#</a>
               </h3>
               
               <pre><code>var p256Zero = p256Element{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p384ElementLength" data-name="p384ElementLength">
               <h3>
                  p384ElementLength 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#p384ElementLength" class="anchor" title="Link to p384ElementLength">#</a>
               </h3>
               
               <p>p384ElementLength is the length of an element of the base or scalar field,
which have the same bytes length for all NIST P curves.</p>
               
               <pre><code>const p384ElementLength = 48</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p384GeneratorTable" data-name="p384GeneratorTable">
               <h3>
                  p384GeneratorTable 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p384GeneratorTable" class="anchor" title="Link to p384GeneratorTable">#</a>
               </h3>
               
               <pre><code>var p384GeneratorTable *[*ast.BinaryExpr]p384Table</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p384GeneratorTableOnce" data-name="p384GeneratorTableOnce">
               <h3>
                  p384GeneratorTableOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p384GeneratorTableOnce" class="anchor" title="Link to p384GeneratorTableOnce">#</a>
               </h3>
               
               <pre><code>var p384GeneratorTableOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p521ElementLength" data-name="p521ElementLength">
               <h3>
                  p521ElementLength 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#p521ElementLength" class="anchor" title="Link to p521ElementLength">#</a>
               </h3>
               
               <p>p521ElementLength is the length of an element of the base or scalar field,
which have the same bytes length for all NIST P curves.</p>
               
               <pre><code>const p521ElementLength = 66</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p521GeneratorTable" data-name="p521GeneratorTable">
               <h3>
                  p521GeneratorTable 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p521GeneratorTable" class="anchor" title="Link to p521GeneratorTable">#</a>
               </h3>
               
               <pre><code>var p521GeneratorTable *[*ast.BinaryExpr]p521Table</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="p521GeneratorTableOnce" data-name="p521GeneratorTableOnce">
               <h3>
                  p521GeneratorTableOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#p521GeneratorTableOnce" class="anchor" title="Link to p521GeneratorTableOnce">#</a>
               </h3>
               
               <pre><code>var p521GeneratorTableOnce sync.Once</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="p224Table" data-name="p224Table">
               <h3>
                  p224Table
                  <span class="badge type-badge">type</span>
                  <a href="#p224Table" class="anchor" title="Link to p224Table">#</a>
               </h3>
               
               <p>A p224Table holds the first 15 multiples of a point at offset -1, so [1]P
is at table[0], [15]P is at table[14], and [0]P is implicitly the identity
point.</p>
               
               <pre><code>type p224Table [15]*P224Point</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="p256AffineTable" data-name="p256AffineTable">
               <h3>
                  p256AffineTable
                  <span class="badge type-badge">type</span>
                  <a href="#p256AffineTable" class="anchor" title="Link to p256AffineTable">#</a>
               </h3>
               
               <p>p256AffineTable is a table of the first 32 multiples of a point. Points are
stored at an index offset of -1 like in p256Table, and [0]P is not stored.</p>
               
               <pre><code>type p256AffineTable [32]p256AffinePoint</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="p256AffineTable" data-name="p256AffineTable">
               <h3>
                  p256AffineTable
                  <span class="badge type-badge">type</span>
                  <a href="#p256AffineTable" class="anchor" title="Link to p256AffineTable">#</a>
               </h3>
               
               <p>p256AffineTable is a table of the first 32 multiples of a point. Points are
stored at an index offset of -1 like in p256Table, and [0]P is not stored.</p>
               
               <pre><code>type p256AffineTable [32]p256AffinePoint</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="p256Element" data-name="p256Element">
               <h3>
                  p256Element
                  <span class="badge type-badge">type</span>
                  <a href="#p256Element" class="anchor" title="Link to p256Element">#</a>
               </h3>
               
               <p>p256Element is a P-256 base field element in [0, P-1] in the Montgomery
domain (with R 2²⁵⁶) as four limbs in little-endian order value.</p>
               
               <pre><code>type p256Element [4]uint64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="p256OrdElement" data-name="p256OrdElement">
               <h3>
                  p256OrdElement
                  <span class="badge type-badge">type</span>
                  <a href="#p256OrdElement" class="anchor" title="Link to p256OrdElement">#</a>
               </h3>
               
               <p>p256OrdElement is a P-256 scalar field element in [0, ord(G)-1] in the
Montgomery domain (with R 2²⁵⁶) as four uint64 limbs in little-endian order.</p>
               
               <pre><code>type p256OrdElement [4]uint64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="p256OrdElement" data-name="p256OrdElement">
               <h3>
                  p256OrdElement
                  <span class="badge type-badge">type</span>
                  <a href="#p256OrdElement" class="anchor" title="Link to p256OrdElement">#</a>
               </h3>
               
               <p>p256OrdElement is a P-256 scalar field element in [0, ord(G)-1] in the
Montgomery domain (with R 2²⁵⁶) as four uint64 limbs in little-endian order.</p>
               
               <pre><code>type p256OrdElement [4]uint64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="p256Table" data-name="p256Table">
               <h3>
                  p256Table
                  <span class="badge type-badge">type</span>
                  <a href="#p256Table" class="anchor" title="Link to p256Table">#</a>
               </h3>
               
               <p>p256Table is a table of the first 16 multiples of a point. Points are stored
at an index offset of -1 so [8]P is at index 7, P is at 0, and [16]P is at 15.
[0]P is the point at infinity and it's not stored.</p>
               
               <pre><code>type p256Table [16]P256Point</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="p256Table" data-name="p256Table">
               <h3>
                  p256Table
                  <span class="badge type-badge">type</span>
                  <a href="#p256Table" class="anchor" title="Link to p256Table">#</a>
               </h3>
               
               <p>p256Table is a table of the first 16 multiples of a point. Points are stored
at an index offset of -1 so [8]P is at index 7, P is at 0, and [16]P is at 15.
[0]P is the point at infinity and it's not stored.</p>
               
               <pre><code>type p256Table [16]P256Point</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="p384Table" data-name="p384Table">
               <h3>
                  p384Table
                  <span class="badge type-badge">type</span>
                  <a href="#p384Table" class="anchor" title="Link to p384Table">#</a>
               </h3>
               
               <p>A p384Table holds the first 15 multiples of a point at offset -1, so [1]P
is at table[0], [15]P is at table[14], and [0]P is implicitly the identity
point.</p>
               
               <pre><code>type p384Table [15]*P384Point</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="p521Table" data-name="p521Table">
               <h3>
                  p521Table
                  <span class="badge type-badge">type</span>
                  <a href="#p521Table" class="anchor" title="Link to p521Table">#</a>
               </h3>
               
               <p>A p521Table holds the first 15 multiples of a point at offset -1, so [1]P
is at table[0], [15]P is at table[14], and [0]P is implicitly the identity
point.</p>
               
               <pre><code>type p521Table [15]*P521Point</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="P224Point" data-name="P224Point">
               <h3>
                  P224Point
                  <span class="badge">struct</span>
                  <a href="#P224Point" class="anchor" title="Link to P224Point">#</a>
               </h3>
               
               <p>P224Point is a P224 point. The zero value is NOT valid.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type P224Point struct {
x *fiat.P224Element
y *fiat.P224Element
z *fiat.P224Element
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="P256Point" data-name="P256Point">
               <h3>
                  P256Point
                  <span class="badge">struct</span>
                  <a href="#P256Point" class="anchor" title="Link to P256Point">#</a>
               </h3>
               
               <p>P256Point is a P-256 point. The zero value should not be assumed to be valid
(although it is in this implementation).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type P256Point struct {
x p256Element
y p256Element
z p256Element
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="P256Point" data-name="P256Point">
               <h3>
                  P256Point
                  <span class="badge">struct</span>
                  <a href="#P256Point" class="anchor" title="Link to P256Point">#</a>
               </h3>
               
               <p>P256Point is a P-256 point. The zero value is NOT valid.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type P256Point struct {
x fiat.P256Element
y fiat.P256Element
z fiat.P256Element
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="P384Point" data-name="P384Point">
               <h3>
                  P384Point
                  <span class="badge">struct</span>
                  <a href="#P384Point" class="anchor" title="Link to P384Point">#</a>
               </h3>
               
               <p>P384Point is a P384 point. The zero value is NOT valid.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type P384Point struct {
x *fiat.P384Element
y *fiat.P384Element
z *fiat.P384Element
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="P521Point" data-name="P521Point">
               <h3>
                  P521Point
                  <span class="badge">struct</span>
                  <a href="#P521Point" class="anchor" title="Link to P521Point">#</a>
               </h3>
               
               <p>P521Point is a P521 point. The zero value is NOT valid.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type P521Point struct {
x *fiat.P521Element
y *fiat.P521Element
z *fiat.P521Element
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="p256AffinePoint" data-name="p256AffinePoint">
               <h3>
                  p256AffinePoint
                  <span class="badge">struct</span>
                  <a href="#p256AffinePoint" class="anchor" title="Link to p256AffinePoint">#</a>
               </h3>
               
               <p>p256AffinePoint is a point in affine coordinates (x, y). x and y are still
Montgomery domain elements. The point can't be the point at infinity.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type p256AffinePoint struct {
x p256Element
y p256Element
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="p256AffinePoint" data-name="p256AffinePoint">
               <h3>
                  p256AffinePoint
                  <span class="badge">struct</span>
                  <a href="#p256AffinePoint" class="anchor" title="Link to p256AffinePoint">#</a>
               </h3>
               
               <p>p256AffinePoint is a point in affine coordinates (x, y). x and y are still
Montgomery domain elements. The point can't be the point at infinity.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type p256AffinePoint struct {
x fiat.P256Element
y fiat.P256Element
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P384Point) Add(p1 *P384Point, p2 *P384Point) *P384Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P521Point) Add(p1 *P521Point, p2 *P521Point) *P521Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P256Point) Add(p1 *P256Point, p2 *P256Point) *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P256Point) Add(r1 *P256Point, r2 *P256Point) *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P224Point) Add(p1 *P224Point, p2 *P224Point) *P224Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddAffine" data-name="AddAffine">
               <h3>
                  AddAffine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddAffine" class="anchor" title="Link to AddAffine">#</a>
               </h3>
               
               <p>AddAffine sets q = p1 + p2, if infinity == 0, and to p1 if infinity == 1.
p2 can't be the point at infinity as it can't be represented in affine
coordinates, instead callers can set p2 to an arbitrary point and set
infinity to 1.</p>
               
               <pre><code>func (q *P256Point) AddAffine(p1 *P256Point, p2 *p256AffinePoint, infinity int) *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <pre><code>func (s *p256OrdElement) Bytes() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P384Point) Bytes() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P521Point) Bytes() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P256Point) Bytes() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P224Point) Bytes() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P256Point) Bytes() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BytesCompressed" data-name="BytesCompressed">
               <h3>
                  BytesCompressed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BytesCompressed" class="anchor" title="Link to BytesCompressed">#</a>
               </h3>
               
               <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P521Point) BytesCompressed() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BytesCompressed" data-name="BytesCompressed">
               <h3>
                  BytesCompressed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BytesCompressed" class="anchor" title="Link to BytesCompressed">#</a>
               </h3>
               
               <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P224Point) BytesCompressed() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BytesCompressed" data-name="BytesCompressed">
               <h3>
                  BytesCompressed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BytesCompressed" class="anchor" title="Link to BytesCompressed">#</a>
               </h3>
               
               <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P384Point) BytesCompressed() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BytesCompressed" data-name="BytesCompressed">
               <h3>
                  BytesCompressed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BytesCompressed" class="anchor" title="Link to BytesCompressed">#</a>
               </h3>
               
               <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P256Point) BytesCompressed() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BytesCompressed" data-name="BytesCompressed">
               <h3>
                  BytesCompressed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BytesCompressed" class="anchor" title="Link to BytesCompressed">#</a>
               </h3>
               
               <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P256Point) BytesCompressed() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BytesX" data-name="BytesX">
               <h3>
                  BytesX 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BytesX" class="anchor" title="Link to BytesX">#</a>
               </h3>
               
               <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
               
               <pre><code>func (p *P521Point) BytesX() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BytesX" data-name="BytesX">
               <h3>
                  BytesX 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BytesX" class="anchor" title="Link to BytesX">#</a>
               </h3>
               
               <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
               
               <pre><code>func (p *P256Point) BytesX() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BytesX" data-name="BytesX">
               <h3>
                  BytesX 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BytesX" class="anchor" title="Link to BytesX">#</a>
               </h3>
               
               <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
               
               <pre><code>func (p *P256Point) BytesX() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BytesX" data-name="BytesX">
               <h3>
                  BytesX 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BytesX" class="anchor" title="Link to BytesX">#</a>
               </h3>
               
               <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
               
               <pre><code>func (p *P384Point) BytesX() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BytesX" data-name="BytesX">
               <h3>
                  BytesX 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BytesX" class="anchor" title="Link to BytesX">#</a>
               </h3>
               
               <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
               
               <pre><code>func (p *P224Point) BytesX() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Compute" data-name="Compute">
               <h3>
                  Compute 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Compute" class="anchor" title="Link to Compute">#</a>
               </h3>
               
               <p>Compute populates the table to the first 16 multiples of q.</p>
               
               <pre><code>func (table *p256Table) Compute(q *P256Point) *p256Table</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Double" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Double" class="anchor" title="Link to Double">#</a>
               </h3>
               
               <p>Double sets q = p + p, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P384Point) Double(p *P384Point) *P384Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Double" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Double" class="anchor" title="Link to Double">#</a>
               </h3>
               
               <p>Double sets q = p + p, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P224Point) Double(p *P224Point) *P224Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Double" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Double" class="anchor" title="Link to Double">#</a>
               </h3>
               
               <p>Double sets q = p + p, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P256Point) Double(p *P256Point) *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Double" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Double" class="anchor" title="Link to Double">#</a>
               </h3>
               
               <p>Double sets q = p + p, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P256Point) Double(p *P256Point) *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Double" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Double" class="anchor" title="Link to Double">#</a>
               </h3>
               
               <p>Double sets q = p + p, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P521Point) Double(p *P521Point) *P521Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Negate" data-name="Negate">
               <h3>
                  Negate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Negate" class="anchor" title="Link to Negate">#</a>
               </h3>
               
               <p>Negate sets p to -p, if cond == 1, and to p if cond == 0.</p>
               
               <pre><code>func (p *p256AffinePoint) Negate(cond int) *p256AffinePoint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Negate" data-name="Negate">
               <h3>
                  Negate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Negate" class="anchor" title="Link to Negate">#</a>
               </h3>
               
               <p>Negate sets p to -p, if cond == 1, and to p if cond == 0.</p>
               
               <pre><code>func (p *P256Point) Negate(cond int) *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewP224Point" data-name="NewP224Point">
               <h3>
                  NewP224Point 
                  <span class="badge">function</span>
                  
                  <a href="#NewP224Point" class="anchor" title="Link to NewP224Point">#</a>
               </h3>
               
               <p>NewP224Point returns a new P224Point representing the point at infinity point.</p>
               
               <pre><code>func NewP224Point() *P224Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewP256Point" data-name="NewP256Point">
               <h3>
                  NewP256Point 
                  <span class="badge">function</span>
                  
                  <a href="#NewP256Point" class="anchor" title="Link to NewP256Point">#</a>
               </h3>
               
               <p>NewP256Point returns a new P256Point representing the point at infinity point.</p>
               
               <pre><code>func NewP256Point() *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewP256Point" data-name="NewP256Point">
               <h3>
                  NewP256Point 
                  <span class="badge">function</span>
                  
                  <a href="#NewP256Point" class="anchor" title="Link to NewP256Point">#</a>
               </h3>
               
               <p>NewP256Point returns a new P256Point representing the point at infinity.</p>
               
               <pre><code>func NewP256Point() *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewP384Point" data-name="NewP384Point">
               <h3>
                  NewP384Point 
                  <span class="badge">function</span>
                  
                  <a href="#NewP384Point" class="anchor" title="Link to NewP384Point">#</a>
               </h3>
               
               <p>NewP384Point returns a new P384Point representing the point at infinity point.</p>
               
               <pre><code>func NewP384Point() *P384Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewP521Point" data-name="NewP521Point">
               <h3>
                  NewP521Point 
                  <span class="badge">function</span>
                  
                  <a href="#NewP521Point" class="anchor" title="Link to NewP521Point">#</a>
               </h3>
               
               <p>NewP521Point returns a new P521Point representing the point at infinity point.</p>
               
               <pre><code>func NewP521Point() *P521Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="P256OrdInverse" data-name="P256OrdInverse">
               <h3>
                  P256OrdInverse 
                  <span class="badge">function</span>
                  
                  <a href="#P256OrdInverse" class="anchor" title="Link to P256OrdInverse">#</a>
               </h3>
               
               <pre><code>func P256OrdInverse(k []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="P256OrdInverse" data-name="P256OrdInverse">
               <h3>
                  P256OrdInverse 
                  <span class="badge">function</span>
                  
                  <a href="#P256OrdInverse" class="anchor" title="Link to P256OrdInverse">#</a>
               </h3>
               
               <pre><code>func P256OrdInverse(k []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Projective" data-name="Projective">
               <h3>
                  Projective 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Projective" class="anchor" title="Link to Projective">#</a>
               </h3>
               
               <pre><code>func (p *p256AffinePoint) Projective() *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Rsh" data-name="Rsh">
               <h3>
                  Rsh 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Rsh" class="anchor" title="Link to Rsh">#</a>
               </h3>
               
               <p>Rsh returns the 64 least significant bits of x >> n. n must be lower
than 256. The value of n leaks through timing side-channels.</p>
               
               <pre><code>func (s *p256OrdElement) Rsh(n int) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarBaseMult" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarBaseMult" class="anchor" title="Link to ScalarBaseMult">#</a>
               </h3>
               
               <p>ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
returns p.</p>
               
               <pre><code>func (p *P224Point) ScalarBaseMult(scalar []byte) (*P224Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarBaseMult" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarBaseMult" class="anchor" title="Link to ScalarBaseMult">#</a>
               </h3>
               
               <p>ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
returns p.</p>
               
               <pre><code>func (p *P384Point) ScalarBaseMult(scalar []byte) (*P384Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarBaseMult" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarBaseMult" class="anchor" title="Link to ScalarBaseMult">#</a>
               </h3>
               
               <p>ScalarBaseMult sets r = scalar * generator, where scalar is a 32-byte big
endian value, and returns r. If scalar is not 32 bytes long, ScalarBaseMult
returns an error and the receiver is unchanged.</p>
               
               <pre><code>func (r *P256Point) ScalarBaseMult(scalar []byte) (*P256Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarBaseMult" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarBaseMult" class="anchor" title="Link to ScalarBaseMult">#</a>
               </h3>
               
               <p>ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
returns p.</p>
               
               <pre><code>func (p *P521Point) ScalarBaseMult(scalar []byte) (*P521Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarBaseMult" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarBaseMult" class="anchor" title="Link to ScalarBaseMult">#</a>
               </h3>
               
               <p>ScalarBaseMult sets p = scalar * generator, where scalar is a 32-byte big
endian value, and returns r. If scalar is not 32 bytes long, ScalarBaseMult
returns an error and the receiver is unchanged.</p>
               
               <pre><code>func (p *P256Point) ScalarBaseMult(scalar []byte) (*P256Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarMult" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarMult" class="anchor" title="Link to ScalarMult">#</a>
               </h3>
               
               <p>ScalarMult sets p = scalar * q, and returns p.</p>
               
               <pre><code>func (p *P224Point) ScalarMult(q *P224Point, scalar []byte) (*P224Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarMult" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarMult" class="anchor" title="Link to ScalarMult">#</a>
               </h3>
               
               <p>ScalarMult sets r = scalar * q, where scalar is a 32-byte big endian value,
and returns r. If scalar is not 32 bytes long, ScalarBaseMult returns an
error and the receiver is unchanged.</p>
               
               <pre><code>func (r *P256Point) ScalarMult(q *P256Point, scalar []byte) (*P256Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarMult" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarMult" class="anchor" title="Link to ScalarMult">#</a>
               </h3>
               
               <p>ScalarMult sets p = scalar * q, and returns p.</p>
               
               <pre><code>func (p *P521Point) ScalarMult(q *P521Point, scalar []byte) (*P521Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarMult" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarMult" class="anchor" title="Link to ScalarMult">#</a>
               </h3>
               
               <p>ScalarMult sets r = scalar * q, where scalar is a 32-byte big endian value,
and returns r. If scalar is not 32 bytes long, ScalarMult returns an error
and the receiver is unchanged.</p>
               
               <pre><code>func (p *P256Point) ScalarMult(q *P256Point, scalar []byte) (*P256Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScalarMult" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScalarMult" class="anchor" title="Link to ScalarMult">#</a>
               </h3>
               
               <p>ScalarMult sets p = scalar * q, and returns p.</p>
               
               <pre><code>func (p *P384Point) ScalarMult(q *P384Point, scalar []byte) (*P384Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Select" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Select" class="anchor" title="Link to Select">#</a>
               </h3>
               
               <p>Select selects the n-th multiple of the table base point into p. It works in
constant time. n can be in [0, 32], but (unlike p256Table.Select) if n is 0,
p is set to an undefined value.</p>
               
               <pre><code>func (table *p256AffineTable) Select(p *p256AffinePoint, n uint8)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Select" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Select" class="anchor" title="Link to Select">#</a>
               </h3>
               
               <p>Select selects the n-th multiple of the table base point into p. It works in
constant time by iterating over every entry of the table. n must be in [0, 15].</p>
               
               <pre><code>func (table *p224Table) Select(p *P224Point, n uint8)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Select" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Select" class="anchor" title="Link to Select">#</a>
               </h3>
               
               <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
               
               <pre><code>func (q *P224Point) Select(p1 *P224Point, p2 *P224Point, cond int) *P224Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Select" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Select" class="anchor" title="Link to Select">#</a>
               </h3>
               
               <p>Select selects the n-th multiple of the table base point into p. It works in
constant time by iterating over every entry of the table. n must be in [0, 15].</p>
               
               <pre><code>func (table *p384Table) Select(p *P384Point, n uint8)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Select" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Select" class="anchor" title="Link to Select">#</a>
               </h3>
               
               <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
               
               <pre><code>func (q *P384Point) Select(p1 *P384Point, p2 *P384Point, cond int) *P384Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Select" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Select" class="anchor" title="Link to Select">#</a>
               </h3>
               
               <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
               
               <pre><code>func (q *P256Point) Select(p1 *P256Point, p2 *P256Point, cond int) *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Select" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Select" class="anchor" title="Link to Select">#</a>
               </h3>
               
               <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
               
               <pre><code>func (q *P256Point) Select(p1 *P256Point, p2 *P256Point, cond int) *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Select" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Select" class="anchor" title="Link to Select">#</a>
               </h3>
               
               <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
               
               <pre><code>func (q *P521Point) Select(p1 *P521Point, p2 *P521Point, cond int) *P521Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Select" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Select" class="anchor" title="Link to Select">#</a>
               </h3>
               
               <p>Select selects the n-th multiple of the table base point into p. It works in
constant time. n must be in [0, 16]. If n is 0, p is set to the identity point.</p>
               
               <pre><code>func (table *p256Table) Select(p *P256Point, n uint8)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Select" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Select" class="anchor" title="Link to Select">#</a>
               </h3>
               
               <p>Select selects the n-th multiple of the table base point into p. It works in
constant time by iterating over every entry of the table. n must be in [0, 15].</p>
               
               <pre><code>func (table *p521Table) Select(p *P521Point, n uint8)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set sets p = q and returns p.</p>
               
               <pre><code>func (p *P256Point) Set(q *P256Point) *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set sets p = q and returns p.</p>
               
               <pre><code>func (p *P521Point) Set(q *P521Point) *P521Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set sets p = q and returns p.</p>
               
               <pre><code>func (p *P256Point) Set(q *P256Point) *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set sets p = q and returns p.</p>
               
               <pre><code>func (p *P384Point) Set(q *P384Point) *P384Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set sets p = q and returns p.</p>
               
               <pre><code>func (p *P224Point) Set(q *P224Point) *P224Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBytes" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBytes" class="anchor" title="Link to SetBytes">#</a>
               </h3>
               
               <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
               
               <pre><code>func (p *P256Point) SetBytes(b []byte) (*P256Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBytes" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBytes" class="anchor" title="Link to SetBytes">#</a>
               </h3>
               
               <p>SetBytes sets s to the big-endian value of x, reducing it as necessary.</p>
               
               <pre><code>func (s *p256OrdElement) SetBytes(x []byte) (*p256OrdElement, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBytes" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBytes" class="anchor" title="Link to SetBytes">#</a>
               </h3>
               
               <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
               
               <pre><code>func (p *P224Point) SetBytes(b []byte) (*P224Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBytes" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBytes" class="anchor" title="Link to SetBytes">#</a>
               </h3>
               
               <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
               
               <pre><code>func (p *P521Point) SetBytes(b []byte) (*P521Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBytes" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBytes" class="anchor" title="Link to SetBytes">#</a>
               </h3>
               
               <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
               
               <pre><code>func (p *P384Point) SetBytes(b []byte) (*P384Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetBytes" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetBytes" class="anchor" title="Link to SetBytes">#</a>
               </h3>
               
               <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
               
               <pre><code>func (p *P256Point) SetBytes(b []byte) (*P256Point, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetGenerator" data-name="SetGenerator">
               <h3>
                  SetGenerator 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetGenerator" class="anchor" title="Link to SetGenerator">#</a>
               </h3>
               
               <p>SetGenerator sets p to the canonical generator and returns p.</p>
               
               <pre><code>func (p *P256Point) SetGenerator() *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetGenerator" data-name="SetGenerator">
               <h3>
                  SetGenerator 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetGenerator" class="anchor" title="Link to SetGenerator">#</a>
               </h3>
               
               <p>SetGenerator sets p to the canonical generator and returns p.</p>
               
               <pre><code>func (p *P256Point) SetGenerator() *P256Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetGenerator" data-name="SetGenerator">
               <h3>
                  SetGenerator 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetGenerator" class="anchor" title="Link to SetGenerator">#</a>
               </h3>
               
               <p>SetGenerator sets p to the canonical generator and returns p.</p>
               
               <pre><code>func (p *P384Point) SetGenerator() *P384Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetGenerator" data-name="SetGenerator">
               <h3>
                  SetGenerator 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetGenerator" class="anchor" title="Link to SetGenerator">#</a>
               </h3>
               
               <p>SetGenerator sets p to the canonical generator and returns p.</p>
               
               <pre><code>func (p *P521Point) SetGenerator() *P521Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetGenerator" data-name="SetGenerator">
               <h3>
                  SetGenerator 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetGenerator" class="anchor" title="Link to SetGenerator">#</a>
               </h3>
               
               <p>SetGenerator sets p to the canonical generator and returns p.</p>
               
               <pre><code>func (p *P224Point) SetGenerator() *P224Point</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="affineFromMont" data-name="affineFromMont">
               <h3>
                  affineFromMont 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#affineFromMont" class="anchor" title="Link to affineFromMont">#</a>
               </h3>
               
               <p>affineFromMont sets (x, y) to the affine coordinates of p, converted out of the
Montgomery domain.</p>
               
               <pre><code>func (p *P256Point) affineFromMont(x *p256Element, y *p256Element)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boothW5" data-name="boothW5">
               <h3>
                  boothW5 
                  <span class="badge">function</span>
                  
                  <a href="#boothW5" class="anchor" title="Link to boothW5">#</a>
               </h3>
               
               <pre><code>func boothW5(in uint) (int, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boothW5" data-name="boothW5">
               <h3>
                  boothW5 
                  <span class="badge">function</span>
                  
                  <a href="#boothW5" class="anchor" title="Link to boothW5">#</a>
               </h3>
               
               <pre><code>func boothW5(in uint64) (uint8, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boothW6" data-name="boothW6">
               <h3>
                  boothW6 
                  <span class="badge">function</span>
                  
                  <a href="#boothW6" class="anchor" title="Link to boothW6">#</a>
               </h3>
               
               <pre><code>func boothW6(in uint64) (uint8, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boothW6" data-name="boothW6">
               <h3>
                  boothW6 
                  <span class="badge">function</span>
                  
                  <a href="#boothW6" class="anchor" title="Link to boothW6">#</a>
               </h3>
               
               <pre><code>func boothW6(in uint) (int, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytes" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytes" class="anchor" title="Link to bytes">#</a>
               </h3>
               
               <pre><code>func (p *P384Point) bytes(out *[*ast.BinaryExpr]byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytes" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytes" class="anchor" title="Link to bytes">#</a>
               </h3>
               
               <pre><code>func (p *P224Point) bytes(out *[*ast.BinaryExpr]byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytes" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytes" class="anchor" title="Link to bytes">#</a>
               </h3>
               
               <pre><code>func (p *P521Point) bytes(out *[*ast.BinaryExpr]byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytes" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytes" class="anchor" title="Link to bytes">#</a>
               </h3>
               
               <pre><code>func (p *P256Point) bytes(out *[p256UncompressedLength]byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytes" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytes" class="anchor" title="Link to bytes">#</a>
               </h3>
               
               <pre><code>func (p *P256Point) bytes(out *[p256UncompressedLength]byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesCompressed" data-name="bytesCompressed">
               <h3>
                  bytesCompressed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytesCompressed" class="anchor" title="Link to bytesCompressed">#</a>
               </h3>
               
               <pre><code>func (p *P384Point) bytesCompressed(out *[*ast.BinaryExpr]byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesCompressed" data-name="bytesCompressed">
               <h3>
                  bytesCompressed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytesCompressed" class="anchor" title="Link to bytesCompressed">#</a>
               </h3>
               
               <pre><code>func (p *P256Point) bytesCompressed(out *[p256CompressedLength]byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesCompressed" data-name="bytesCompressed">
               <h3>
                  bytesCompressed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytesCompressed" class="anchor" title="Link to bytesCompressed">#</a>
               </h3>
               
               <pre><code>func (p *P256Point) bytesCompressed(out *[p256CompressedLength]byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesCompressed" data-name="bytesCompressed">
               <h3>
                  bytesCompressed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytesCompressed" class="anchor" title="Link to bytesCompressed">#</a>
               </h3>
               
               <pre><code>func (p *P521Point) bytesCompressed(out *[*ast.BinaryExpr]byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesCompressed" data-name="bytesCompressed">
               <h3>
                  bytesCompressed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytesCompressed" class="anchor" title="Link to bytesCompressed">#</a>
               </h3>
               
               <pre><code>func (p *P224Point) bytesCompressed(out *[*ast.BinaryExpr]byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesToLimbs" data-name="bytesToLimbs">
               <h3>
                  bytesToLimbs 
                  <span class="badge">function</span>
                  
                  <a href="#bytesToLimbs" class="anchor" title="Link to bytesToLimbs">#</a>
               </h3>
               
               <pre><code>func bytesToLimbs(l *[4]uint64, b *[32]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesX" data-name="bytesX">
               <h3>
                  bytesX 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytesX" class="anchor" title="Link to bytesX">#</a>
               </h3>
               
               <pre><code>func (p *P521Point) bytesX(out *[p521ElementLength]byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesX" data-name="bytesX">
               <h3>
                  bytesX 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytesX" class="anchor" title="Link to bytesX">#</a>
               </h3>
               
               <pre><code>func (p *P224Point) bytesX(out *[p224ElementLength]byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesX" data-name="bytesX">
               <h3>
                  bytesX 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytesX" class="anchor" title="Link to bytesX">#</a>
               </h3>
               
               <pre><code>func (p *P256Point) bytesX(out *[p256ElementLength]byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesX" data-name="bytesX">
               <h3>
                  bytesX 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytesX" class="anchor" title="Link to bytesX">#</a>
               </h3>
               
               <pre><code>func (p *P256Point) bytesX(out *[p256ElementLength]byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bytesX" data-name="bytesX">
               <h3>
                  bytesX 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bytesX" class="anchor" title="Link to bytesX">#</a>
               </h3>
               
               <pre><code>func (p *P384Point) bytesX(out *[p384ElementLength]byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="generatorTable" data-name="generatorTable">
               <h3>
                  generatorTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#generatorTable" class="anchor" title="Link to generatorTable">#</a>
               </h3>
               
               <p>generatorTable returns a sequence of p224Tables. The first table contains
multiples of G. Each successive table is the previous table doubled four
times.</p>
               
               <pre><code>func (p *P224Point) generatorTable() *[*ast.BinaryExpr]p224Table</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="generatorTable" data-name="generatorTable">
               <h3>
                  generatorTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#generatorTable" class="anchor" title="Link to generatorTable">#</a>
               </h3>
               
               <p>generatorTable returns a sequence of p521Tables. The first table contains
multiples of G. Each successive table is the previous table doubled four
times.</p>
               
               <pre><code>func (p *P521Point) generatorTable() *[*ast.BinaryExpr]p521Table</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="generatorTable" data-name="generatorTable">
               <h3>
                  generatorTable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#generatorTable" class="anchor" title="Link to generatorTable">#</a>
               </h3>
               
               <p>generatorTable returns a sequence of p384Tables. The first table contains
multiples of G. Each successive table is the previous table doubled four
times.</p>
               
               <pre><code>func (p *P384Point) generatorTable() *[*ast.BinaryExpr]p384Table</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isInfinity" data-name="isInfinity">
               <h3>
                  isInfinity 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isInfinity" class="anchor" title="Link to isInfinity">#</a>
               </h3>
               
               <p>isInfinity returns 1 if p is the point at infinity and 0 otherwise.</p>
               
               <pre><code>func (p *P256Point) isInfinity() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="limbsToBytes" data-name="limbsToBytes">
               <h3>
                  limbsToBytes 
                  <span class="badge">function</span>
                  
                  <a href="#limbsToBytes" class="anchor" title="Link to limbsToBytes">#</a>
               </h3>
               
               <pre><code>func limbsToBytes(b *[32]byte, l *[4]uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p224B" data-name="p224B">
               <h3>
                  p224B 
                  <span class="badge">function</span>
                  
                  <a href="#p224B" class="anchor" title="Link to p224B">#</a>
               </h3>
               
               <pre><code>func p224B() *fiat.P224Element</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p224CheckOnCurve" data-name="p224CheckOnCurve">
               <h3>
                  p224CheckOnCurve 
                  <span class="badge">function</span>
                  
                  <a href="#p224CheckOnCurve" class="anchor" title="Link to p224CheckOnCurve">#</a>
               </h3>
               
               <pre><code>func p224CheckOnCurve(x *fiat.P224Element, y *fiat.P224Element) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p224Polynomial" data-name="p224Polynomial">
               <h3>
                  p224Polynomial 
                  <span class="badge">function</span>
                  
                  <a href="#p224Polynomial" class="anchor" title="Link to p224Polynomial">#</a>
               </h3>
               
               <p>p224Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
               
               <pre><code>func p224Polynomial(y2 *fiat.P224Element, x *fiat.P224Element) *fiat.P224Element</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p224Sqrt" data-name="p224Sqrt">
               <h3>
                  p224Sqrt 
                  <span class="badge">function</span>
                  
                  <a href="#p224Sqrt" class="anchor" title="Link to p224Sqrt">#</a>
               </h3>
               
               <p>p224Sqrt sets e to a square root of x. If x is not a square, p224Sqrt returns
false and e is unchanged. e and x can overlap.</p>
               
               <pre><code>func p224Sqrt(e *fiat.P224Element, x *fiat.P224Element) (isSquare bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p224SqrtCandidate" data-name="p224SqrtCandidate">
               <h3>
                  p224SqrtCandidate 
                  <span class="badge">function</span>
                  
                  <a href="#p224SqrtCandidate" class="anchor" title="Link to p224SqrtCandidate">#</a>
               </h3>
               
               <p>p224SqrtCandidate sets r to a square root candidate for x. r and x must not overlap.</p>
               
               <pre><code>func p224SqrtCandidate(r *fiat.P224Element, x *fiat.P224Element)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256Add" data-name="p256Add">
               <h3>
                  p256Add 
                  <span class="badge">function</span>
                  
                  <a href="#p256Add" class="anchor" title="Link to p256Add">#</a>
               </h3>
               
               <p>p256Add sets res = x + y.</p>
               
               <pre><code>func p256Add(res *p256Element, x *p256Element, y *p256Element)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256B" data-name="p256B">
               <h3>
                  p256B 
                  <span class="badge">function</span>
                  
                  <a href="#p256B" class="anchor" title="Link to p256B">#</a>
               </h3>
               
               <pre><code>func p256B() *fiat.P256Element</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256BaseMult" data-name="p256BaseMult">
               <h3>
                  p256BaseMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#p256BaseMult" class="anchor" title="Link to p256BaseMult">#</a>
               </h3>
               
               <pre><code>func (p *P256Point) p256BaseMult(scalar *p256OrdElement)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256BigToLittle" data-name="p256BigToLittle">
               <h3>
                  p256BigToLittle 
                  <span class="badge">function</span>
                  
                  <a href="#p256BigToLittle" class="anchor" title="Link to p256BigToLittle">#</a>
               </h3>
               
               <pre><code>func p256BigToLittle(l *p256Element, b *[32]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256CheckOnCurve" data-name="p256CheckOnCurve">
               <h3>
                  p256CheckOnCurve 
                  <span class="badge">function</span>
                  
                  <a href="#p256CheckOnCurve" class="anchor" title="Link to p256CheckOnCurve">#</a>
               </h3>
               
               <pre><code>func p256CheckOnCurve(x *p256Element, y *p256Element) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256CheckOnCurve" data-name="p256CheckOnCurve">
               <h3>
                  p256CheckOnCurve 
                  <span class="badge">function</span>
                  
                  <a href="#p256CheckOnCurve" class="anchor" title="Link to p256CheckOnCurve">#</a>
               </h3>
               
               <pre><code>func p256CheckOnCurve(x *fiat.P256Element, y *fiat.P256Element) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256Equal" data-name="p256Equal">
               <h3>
                  p256Equal 
                  <span class="badge">function</span>
                  
                  <a href="#p256Equal" class="anchor" title="Link to p256Equal">#</a>
               </h3>
               
               <p>p256Equal returns 1 if a and b are equal and 0 otherwise.</p>
               
               <pre><code>func p256Equal(a *p256Element, b *p256Element) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256FromMont" data-name="p256FromMont">
               <h3>
                  p256FromMont 
                  <span class="badge">function</span>
                  
                  <a href="#p256FromMont" class="anchor" title="Link to p256FromMont">#</a>
               </h3>
               
               <p>Montgomery multiplication by R⁻¹, or 1 outside the domain.
Sets res = in * R⁻¹, bringing res out of the Montgomery domain.
go:noescape</p>
               
               <pre><code>func p256FromMont(res *p256Element, in *p256Element)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256Inverse" data-name="p256Inverse">
               <h3>
                  p256Inverse 
                  <span class="badge">function</span>
                  
                  <a href="#p256Inverse" class="anchor" title="Link to p256Inverse">#</a>
               </h3>
               
               <p>p256Inverse sets out to in⁻¹ mod p. If in is zero, out will be zero.</p>
               
               <pre><code>func p256Inverse(out *p256Element, in *p256Element)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256LessThanP" data-name="p256LessThanP">
               <h3>
                  p256LessThanP 
                  <span class="badge">function</span>
                  
                  <a href="#p256LessThanP" class="anchor" title="Link to p256LessThanP">#</a>
               </h3>
               
               <p>p256LessThanP returns 1 if x < p, and 0 otherwise. Note that a p256Element is
not allowed to be equal to or greater than p, so if this function returns 0
then x is invalid.</p>
               
               <pre><code>func p256LessThanP(x *p256Element) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256LittleToBig" data-name="p256LittleToBig">
               <h3>
                  p256LittleToBig 
                  <span class="badge">function</span>
                  
                  <a href="#p256LittleToBig" class="anchor" title="Link to p256LittleToBig">#</a>
               </h3>
               
               <pre><code>func p256LittleToBig(b *[32]byte, l *p256Element)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256MovCond" data-name="p256MovCond">
               <h3>
                  p256MovCond 
                  <span class="badge">function</span>
                  
                  <a href="#p256MovCond" class="anchor" title="Link to p256MovCond">#</a>
               </h3>
               
               <p>If cond is 0, sets res = b, otherwise sets res = a.
go:noescape</p>
               
               <pre><code>func p256MovCond(res *P256Point, a *P256Point, b *P256Point, cond int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256Mul" data-name="p256Mul">
               <h3>
                  p256Mul 
                  <span class="badge">function</span>
                  
                  <a href="#p256Mul" class="anchor" title="Link to p256Mul">#</a>
               </h3>
               
               <p>Montgomery multiplication. Sets res = in1 * in2 * R⁻¹ mod p.
go:noescape</p>
               
               <pre><code>func p256Mul(res *p256Element, in1 *p256Element, in2 *p256Element)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256NegCond" data-name="p256NegCond">
               <h3>
                  p256NegCond 
                  <span class="badge">function</span>
                  
                  <a href="#p256NegCond" class="anchor" title="Link to p256NegCond">#</a>
               </h3>
               
               <p>If cond is not 0, sets val = -val mod p.
go:noescape</p>
               
               <pre><code>func p256NegCond(val *p256Element, cond int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256OrdBigToLittle" data-name="p256OrdBigToLittle">
               <h3>
                  p256OrdBigToLittle 
                  <span class="badge">function</span>
                  
                  <a href="#p256OrdBigToLittle" class="anchor" title="Link to p256OrdBigToLittle">#</a>
               </h3>
               
               <pre><code>func p256OrdBigToLittle(l *p256OrdElement, b *[32]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256OrdLittleToBig" data-name="p256OrdLittleToBig">
               <h3>
                  p256OrdLittleToBig 
                  <span class="badge">function</span>
                  
                  <a href="#p256OrdLittleToBig" class="anchor" title="Link to p256OrdLittleToBig">#</a>
               </h3>
               
               <pre><code>func p256OrdLittleToBig(b *[32]byte, l *p256OrdElement)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256OrdMul" data-name="p256OrdMul">
               <h3>
                  p256OrdMul 
                  <span class="badge">function</span>
                  
                  <a href="#p256OrdMul" class="anchor" title="Link to p256OrdMul">#</a>
               </h3>
               
               <p>Montgomery multiplication modulo org(G). Sets res = in1 * in2 * R⁻¹.
go:noescape</p>
               
               <pre><code>func p256OrdMul(res *p256OrdElement, in1 *p256OrdElement, in2 *p256OrdElement)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256OrdReduce" data-name="p256OrdReduce">
               <h3>
                  p256OrdReduce 
                  <span class="badge">function</span>
                  
                  <a href="#p256OrdReduce" class="anchor" title="Link to p256OrdReduce">#</a>
               </h3>
               
               <p>p256OrdReduce ensures s is in the range [0, ord(G)-1].</p>
               
               <pre><code>func p256OrdReduce(s *p256OrdElement)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256OrdSqr" data-name="p256OrdSqr">
               <h3>
                  p256OrdSqr 
                  <span class="badge">function</span>
                  
                  <a href="#p256OrdSqr" class="anchor" title="Link to p256OrdSqr">#</a>
               </h3>
               
               <p>Montgomery square modulo org(G), repeated n times (n >= 1).
go:noescape</p>
               
               <pre><code>func p256OrdSqr(res *p256OrdElement, in *p256OrdElement, n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256PointAddAffineAsm" data-name="p256PointAddAffineAsm">
               <h3>
                  p256PointAddAffineAsm 
                  <span class="badge">function</span>
                  
                  <a href="#p256PointAddAffineAsm" class="anchor" title="Link to p256PointAddAffineAsm">#</a>
               </h3>
               
               <p>Point addition with an affine point and constant time conditions.
If zero is 0, sets res = in2. If sel is 0, sets res = in1.
If sign is not 0, sets res = in1 + -in2. Otherwise, sets res = in1 + in2
go:noescape</p>
               
               <pre><code>func p256PointAddAffineAsm(res *P256Point, in1 *P256Point, in2 *p256AffinePoint, sign int, sel int, zero int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256PointAddAsm" data-name="p256PointAddAsm">
               <h3>
                  p256PointAddAsm 
                  <span class="badge">function</span>
                  
                  <a href="#p256PointAddAsm" class="anchor" title="Link to p256PointAddAsm">#</a>
               </h3>
               
               <p>Point addition. Sets res = in1 + in2. Returns one if the two input points
were equal and zero otherwise. If in1 or in2 are the point at infinity, res
and the return value are undefined.
go:noescape</p>
               
               <pre><code>func p256PointAddAsm(res *P256Point, in1 *P256Point, in2 *P256Point) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256PointDoubleAsm" data-name="p256PointDoubleAsm">
               <h3>
                  p256PointDoubleAsm 
                  <span class="badge">function</span>
                  
                  <a href="#p256PointDoubleAsm" class="anchor" title="Link to p256PointDoubleAsm">#</a>
               </h3>
               
               <p>Point doubling. Sets res = in + in. in can be the point at infinity.
go:noescape</p>
               
               <pre><code>func p256PointDoubleAsm(res *P256Point, in *P256Point)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256Polynomial" data-name="p256Polynomial">
               <h3>
                  p256Polynomial 
                  <span class="badge">function</span>
                  
                  <a href="#p256Polynomial" class="anchor" title="Link to p256Polynomial">#</a>
               </h3>
               
               <p>p256Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
               
               <pre><code>func p256Polynomial(y2 *fiat.P256Element, x *fiat.P256Element) *fiat.P256Element</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256Polynomial" data-name="p256Polynomial">
               <h3>
                  p256Polynomial 
                  <span class="badge">function</span>
                  
                  <a href="#p256Polynomial" class="anchor" title="Link to p256Polynomial">#</a>
               </h3>
               
               <p>p256Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
               
               <pre><code>func p256Polynomial(y2 *p256Element, x *p256Element) *p256Element</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256ScalarMult" data-name="p256ScalarMult">
               <h3>
                  p256ScalarMult 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#p256ScalarMult" class="anchor" title="Link to p256ScalarMult">#</a>
               </h3>
               
               <pre><code>func (p *P256Point) p256ScalarMult(scalar *p256OrdElement)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256Select" data-name="p256Select">
               <h3>
                  p256Select 
                  <span class="badge">function</span>
                  
                  <a href="#p256Select" class="anchor" title="Link to p256Select">#</a>
               </h3>
               
               <p>p256Select sets res to the point at index idx in the table.
idx must be in [0, 15]. It executes in constant time.
go:noescape</p>
               
               <pre><code>func p256Select(res *P256Point, table *p256Table, idx int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256SelectAffine" data-name="p256SelectAffine">
               <h3>
                  p256SelectAffine 
                  <span class="badge">function</span>
                  
                  <a href="#p256SelectAffine" class="anchor" title="Link to p256SelectAffine">#</a>
               </h3>
               
               <p>p256SelectAffine sets res to the point at index idx in the table.
idx must be in [0, 31]. It executes in constant time.
go:noescape</p>
               
               <pre><code>func p256SelectAffine(res *p256AffinePoint, table *p256AffineTable, idx int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256Sqr" data-name="p256Sqr">
               <h3>
                  p256Sqr 
                  <span class="badge">function</span>
                  
                  <a href="#p256Sqr" class="anchor" title="Link to p256Sqr">#</a>
               </h3>
               
               <p>Montgomery square, repeated n times (n >= 1).
go:noescape</p>
               
               <pre><code>func p256Sqr(res *p256Element, in *p256Element, n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256Sqrt" data-name="p256Sqrt">
               <h3>
                  p256Sqrt 
                  <span class="badge">function</span>
                  
                  <a href="#p256Sqrt" class="anchor" title="Link to p256Sqrt">#</a>
               </h3>
               
               <p>p256Sqrt sets e to a square root of x. If x is not a square, p256Sqrt returns
false and e is unchanged. e and x can overlap.</p>
               
               <pre><code>func p256Sqrt(e *fiat.P256Element, x *fiat.P256Element) (isSquare bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256Sqrt" data-name="p256Sqrt">
               <h3>
                  p256Sqrt 
                  <span class="badge">function</span>
                  
                  <a href="#p256Sqrt" class="anchor" title="Link to p256Sqrt">#</a>
               </h3>
               
               <p>p256Sqrt sets e to a square root of x. If x is not a square, p256Sqrt returns
false and e is unchanged. e and x can overlap.</p>
               
               <pre><code>func p256Sqrt(e *p256Element, x *p256Element) (isSquare bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p256Square" data-name="p256Square">
               <h3>
                  p256Square 
                  <span class="badge">function</span>
                  
                  <a href="#p256Square" class="anchor" title="Link to p256Square">#</a>
               </h3>
               
               <p>p256Square sets e to the square of x, repeated n times > 1.</p>
               
               <pre><code>func p256Square(e *fiat.P256Element, x *fiat.P256Element, n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p384B" data-name="p384B">
               <h3>
                  p384B 
                  <span class="badge">function</span>
                  
                  <a href="#p384B" class="anchor" title="Link to p384B">#</a>
               </h3>
               
               <pre><code>func p384B() *fiat.P384Element</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p384CheckOnCurve" data-name="p384CheckOnCurve">
               <h3>
                  p384CheckOnCurve 
                  <span class="badge">function</span>
                  
                  <a href="#p384CheckOnCurve" class="anchor" title="Link to p384CheckOnCurve">#</a>
               </h3>
               
               <pre><code>func p384CheckOnCurve(x *fiat.P384Element, y *fiat.P384Element) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p384Polynomial" data-name="p384Polynomial">
               <h3>
                  p384Polynomial 
                  <span class="badge">function</span>
                  
                  <a href="#p384Polynomial" class="anchor" title="Link to p384Polynomial">#</a>
               </h3>
               
               <p>p384Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
               
               <pre><code>func p384Polynomial(y2 *fiat.P384Element, x *fiat.P384Element) *fiat.P384Element</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p384Sqrt" data-name="p384Sqrt">
               <h3>
                  p384Sqrt 
                  <span class="badge">function</span>
                  
                  <a href="#p384Sqrt" class="anchor" title="Link to p384Sqrt">#</a>
               </h3>
               
               <p>p384Sqrt sets e to a square root of x. If x is not a square, p384Sqrt returns
false and e is unchanged. e and x can overlap.</p>
               
               <pre><code>func p384Sqrt(e *fiat.P384Element, x *fiat.P384Element) (isSquare bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p384SqrtCandidate" data-name="p384SqrtCandidate">
               <h3>
                  p384SqrtCandidate 
                  <span class="badge">function</span>
                  
                  <a href="#p384SqrtCandidate" class="anchor" title="Link to p384SqrtCandidate">#</a>
               </h3>
               
               <p>p384SqrtCandidate sets z to a square root candidate for x. z and x must not overlap.</p>
               
               <pre><code>func p384SqrtCandidate(z *fiat.P384Element, x *fiat.P384Element)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p521B" data-name="p521B">
               <h3>
                  p521B 
                  <span class="badge">function</span>
                  
                  <a href="#p521B" class="anchor" title="Link to p521B">#</a>
               </h3>
               
               <pre><code>func p521B() *fiat.P521Element</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p521CheckOnCurve" data-name="p521CheckOnCurve">
               <h3>
                  p521CheckOnCurve 
                  <span class="badge">function</span>
                  
                  <a href="#p521CheckOnCurve" class="anchor" title="Link to p521CheckOnCurve">#</a>
               </h3>
               
               <pre><code>func p521CheckOnCurve(x *fiat.P521Element, y *fiat.P521Element) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p521Polynomial" data-name="p521Polynomial">
               <h3>
                  p521Polynomial 
                  <span class="badge">function</span>
                  
                  <a href="#p521Polynomial" class="anchor" title="Link to p521Polynomial">#</a>
               </h3>
               
               <p>p521Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
               
               <pre><code>func p521Polynomial(y2 *fiat.P521Element, x *fiat.P521Element) *fiat.P521Element</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p521Sqrt" data-name="p521Sqrt">
               <h3>
                  p521Sqrt 
                  <span class="badge">function</span>
                  
                  <a href="#p521Sqrt" class="anchor" title="Link to p521Sqrt">#</a>
               </h3>
               
               <p>p521Sqrt sets e to a square root of x. If x is not a square, p521Sqrt returns
false and e is unchanged. e and x can overlap.</p>
               
               <pre><code>func p521Sqrt(e *fiat.P521Element, x *fiat.P521Element) (isSquare bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="p521SqrtCandidate" data-name="p521SqrtCandidate">
               <h3>
                  p521SqrtCandidate 
                  <span class="badge">function</span>
                  
                  <a href="#p521SqrtCandidate" class="anchor" title="Link to p521SqrtCandidate">#</a>
               </h3>
               
               <p>p521SqrtCandidate sets z to a square root candidate for x. z and x must not overlap.</p>
               
               <pre><code>func p521SqrtCandidate(z *fiat.P521Element, x *fiat.P521Element)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="uint64IsZero" data-name="uint64IsZero">
               <h3>
                  uint64IsZero 
                  <span class="badge">function</span>
                  
                  <a href="#uint64IsZero" class="anchor" title="Link to uint64IsZero">#</a>
               </h3>
               
               <p>uint64IsZero returns 1 if x is zero and zero otherwise.</p>
               
               <pre><code>func uint64IsZero(x uint64) int</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>