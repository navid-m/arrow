<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - nistec</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="crypto_internal_fips140_nistec__asm-docs.html">_asm</a></li>
               
               <li><a href="crypto_internal_fips140_nistec_fiat-docs.html">fiat</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>nistec</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"crypto/internal/fips140/nistec/fiat"
"sync"
"crypto/internal/fips140/nistec/fiat"
"crypto/internal/fips140/subtle"
"crypto/internal/fips140deps/byteorder"
"crypto/internal/fips140deps/cpu"
"errors"
"math/bits"
"sync"
"unsafe"
"crypto/internal/fips140deps/byteorder"
"errors"
"math/bits"
"runtime"
"unsafe"
"errors"
"errors"
"crypto/internal/fips140/nistec/fiat"
"crypto/internal/fips140/subtle"
"errors"
"sync"
"crypto/internal/fips140/nistec/fiat"
"crypto/internal/fips140/subtle"
"errors"
"sync"
_ "crypto/internal/fips140/check"
"crypto/internal/fips140/nistec/fiat"
"crypto/internal/fips140/subtle"
"errors"
"sync"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="_p224B">
               <h3>
                  _p224B 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _p224B *fiat.P224Element</code></pre>
            </article>
            
            <article class="global" data-name="_p224BOnce">
               <h3>
                  _p224BOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _p224BOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="_p256B">
               <h3>
                  _p256B 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _p256B *fiat.P256Element</code></pre>
            </article>
            
            <article class="global" data-name="_p256BOnce">
               <h3>
                  _p256BOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _p256BOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="_p384B">
               <h3>
                  _p384B 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _p384B *fiat.P384Element</code></pre>
            </article>
            
            <article class="global" data-name="_p384BOnce">
               <h3>
                  _p384BOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _p384BOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="_p521B">
               <h3>
                  _p521B 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _p521B *fiat.P521Element</code></pre>
            </article>
            
            <article class="global" data-name="_p521BOnce">
               <h3>
                  _p521BOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var _p521BOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="p224ElementLength">
               <h3>
                  p224ElementLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>p224ElementLength is the length of an element of the base or scalar field,
which have the same bytes length for all NIST P curves.</p>
               
               <pre><code>const p224ElementLength = 28</code></pre>
            </article>
            
            <article class="global" data-name="p224GG">
               <h3>
                  p224GG 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var p224GG *[96]fiat.P224Element</code></pre>
            </article>
            
            <article class="global" data-name="p224GGOnce">
               <h3>
                  p224GGOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var p224GGOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="p224GeneratorTable">
               <h3>
                  p224GeneratorTable 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var p224GeneratorTable *[*ast.BinaryExpr]p224Table</code></pre>
            </article>
            
            <article class="global" data-name="p224GeneratorTableOnce">
               <h3>
                  p224GeneratorTableOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var p224GeneratorTableOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="p256CompressedLength">
               <h3>
                  p256CompressedLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const p256CompressedLength = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="p256CompressedLength">
               <h3>
                  p256CompressedLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const p256CompressedLength = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="p256ElementLength">
               <h3>
                  p256ElementLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const p256ElementLength = 32</code></pre>
            </article>
            
            <article class="global" data-name="p256ElementLength">
               <h3>
                  p256ElementLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const p256ElementLength = 32</code></pre>
            </article>
            
            <article class="global" data-name="p256GeneratorTables">
               <h3>
                  p256GeneratorTables 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>p256GeneratorTables is a series of precomputed multiples of G, the canonical
generator. The first p256AffineTable contains multiples of G. The second one
multiples of [2⁶]G, the third one of [2¹²]G, and so on, where each successive
table is the previous table doubled six times. Six is the width of the
sliding window used in ScalarBaseMult, and having each table already
pre-doubled lets us avoid the doublings between windows entirely. This table
aliases into p256PrecomputedEmbed.</p>
               
               <pre><code>var p256GeneratorTables *[43]p256AffineTable</code></pre>
            </article>
            
            <article class="global" data-name="p256One">
               <h3>
                  p256One 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>p256One is one in the Montgomery domain.</p>
               
               <pre><code>var p256One = p256Element{...}</code></pre>
            </article>
            
            <article class="global" data-name="p256P">
               <h3>
                  p256P 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>p256P is 2²⁵⁶ - 2²²⁴ + 2¹⁹² + 2⁹⁶ - 1 in the Montgomery domain.</p>
               
               <pre><code>var p256P = p256Element{...}</code></pre>
            </article>
            
            <article class="global" data-name="p256Precomputed">
               <h3>
                  p256Precomputed 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>p256Precomputed is a series of precomputed multiples of G, the canonical
generator. The first p256AffineTable contains multiples of G. The second one
multiples of [2⁶]G, the third one of [2¹²]G, and so on, where each successive
table is the previous table doubled six times. Six is the width of the
sliding window used in p256ScalarBaseMult, and having each table already
pre-doubled lets us avoid the doublings between windows entirely. This table
aliases into p256PrecomputedEmbed.</p>
               
               <pre><code>var p256Precomputed *[43]p256AffineTable</code></pre>
            </article>
            
            <article class="global" data-name="p256PrecomputedEmbed">
               <h3>
                  p256PrecomputedEmbed 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>p256PrecomputedEmbed is the precomputed table of P-256 basepoint multiples.
See [p256Precomputed]. It's not embedded with go:embed because it's not
supported within the FIPS module boundary.</p>
               
               <pre><code>var p256PrecomputedEmbed = [...]byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="p256UncompressedLength">
               <h3>
                  p256UncompressedLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const p256UncompressedLength = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="p256UncompressedLength">
               <h3>
                  p256UncompressedLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const p256UncompressedLength = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="p256Zero">
               <h3>
                  p256Zero 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var p256Zero = p256Element{...}</code></pre>
            </article>
            
            <article class="global" data-name="p384ElementLength">
               <h3>
                  p384ElementLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>p384ElementLength is the length of an element of the base or scalar field,
which have the same bytes length for all NIST P curves.</p>
               
               <pre><code>const p384ElementLength = 48</code></pre>
            </article>
            
            <article class="global" data-name="p384GeneratorTable">
               <h3>
                  p384GeneratorTable 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var p384GeneratorTable *[*ast.BinaryExpr]p384Table</code></pre>
            </article>
            
            <article class="global" data-name="p384GeneratorTableOnce">
               <h3>
                  p384GeneratorTableOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var p384GeneratorTableOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="p521ElementLength">
               <h3>
                  p521ElementLength 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>p521ElementLength is the length of an element of the base or scalar field,
which have the same bytes length for all NIST P curves.</p>
               
               <pre><code>const p521ElementLength = 66</code></pre>
            </article>
            
            <article class="global" data-name="p521GeneratorTable">
               <h3>
                  p521GeneratorTable 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var p521GeneratorTable *[*ast.BinaryExpr]p521Table</code></pre>
            </article>
            
            <article class="global" data-name="p521GeneratorTableOnce">
               <h3>
                  p521GeneratorTableOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var p521GeneratorTableOnce sync.Once</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="p224Table">
               <h3>
                  p224Table
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A p224Table holds the first 15 multiples of a point at offset -1, so [1]P
is at table[0], [15]P is at table[14], and [0]P is implicitly the identity
point.</p>
               
               <pre><code>type p224Table [15]*P224Point</code></pre>
            </article>
            
            <article class="type" data-name="p256AffineTable">
               <h3>
                  p256AffineTable
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>p256AffineTable is a table of the first 32 multiples of a point. Points are
stored at an index offset of -1 like in p256Table, and [0]P is not stored.</p>
               
               <pre><code>type p256AffineTable [32]p256AffinePoint</code></pre>
            </article>
            
            <article class="type" data-name="p256AffineTable">
               <h3>
                  p256AffineTable
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>p256AffineTable is a table of the first 32 multiples of a point. Points are
stored at an index offset of -1 like in p256Table, and [0]P is not stored.</p>
               
               <pre><code>type p256AffineTable [32]p256AffinePoint</code></pre>
            </article>
            
            <article class="type" data-name="p256Element">
               <h3>
                  p256Element
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>p256Element is a P-256 base field element in [0, P-1] in the Montgomery
domain (with R 2²⁵⁶) as four limbs in little-endian order value.</p>
               
               <pre><code>type p256Element [4]uint64</code></pre>
            </article>
            
            <article class="type" data-name="p256OrdElement">
               <h3>
                  p256OrdElement
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>p256OrdElement is a P-256 scalar field element in [0, ord(G)-1] in the
Montgomery domain (with R 2²⁵⁶) as four uint64 limbs in little-endian order.</p>
               
               <pre><code>type p256OrdElement [4]uint64</code></pre>
            </article>
            
            <article class="type" data-name="p256OrdElement">
               <h3>
                  p256OrdElement
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>p256OrdElement is a P-256 scalar field element in [0, ord(G)-1] in the
Montgomery domain (with R 2²⁵⁶) as four uint64 limbs in little-endian order.</p>
               
               <pre><code>type p256OrdElement [4]uint64</code></pre>
            </article>
            
            <article class="type" data-name="p256Table">
               <h3>
                  p256Table
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>p256Table is a table of the first 16 multiples of a point. Points are stored
at an index offset of -1 so [8]P is at index 7, P is at 0, and [16]P is at 15.
[0]P is the point at infinity and it's not stored.</p>
               
               <pre><code>type p256Table [16]P256Point</code></pre>
            </article>
            
            <article class="type" data-name="p256Table">
               <h3>
                  p256Table
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>p256Table is a table of the first 16 multiples of a point. Points are stored
at an index offset of -1 so [8]P is at index 7, P is at 0, and [16]P is at 15.
[0]P is the point at infinity and it's not stored.</p>
               
               <pre><code>type p256Table [16]P256Point</code></pre>
            </article>
            
            <article class="type" data-name="p384Table">
               <h3>
                  p384Table
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A p384Table holds the first 15 multiples of a point at offset -1, so [1]P
is at table[0], [15]P is at table[14], and [0]P is implicitly the identity
point.</p>
               
               <pre><code>type p384Table [15]*P384Point</code></pre>
            </article>
            
            <article class="type" data-name="p521Table">
               <h3>
                  p521Table
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A p521Table holds the first 15 multiples of a point at offset -1, so [1]P
is at table[0], [15]P is at table[14], and [0]P is implicitly the identity
point.</p>
               
               <pre><code>type p521Table [15]*P521Point</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="P224Point">
               <h3>
                  P224Point
                  <span class="badge">struct</span>
               </h3>
               
               <p>P224Point is a P224 point. The zero value is NOT valid.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type P224Point struct {
x *fiat.P224Element
y *fiat.P224Element
z *fiat.P224Element
}</code></pre>
            </article>
            
            <article class="struct" data-name="P256Point">
               <h3>
                  P256Point
                  <span class="badge">struct</span>
               </h3>
               
               <p>P256Point is a P-256 point. The zero value is NOT valid.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type P256Point struct {
x fiat.P256Element
y fiat.P256Element
z fiat.P256Element
}</code></pre>
            </article>
            
            <article class="struct" data-name="P256Point">
               <h3>
                  P256Point
                  <span class="badge">struct</span>
               </h3>
               
               <p>P256Point is a P-256 point. The zero value should not be assumed to be valid
(although it is in this implementation).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type P256Point struct {
x p256Element
y p256Element
z p256Element
}</code></pre>
            </article>
            
            <article class="struct" data-name="P384Point">
               <h3>
                  P384Point
                  <span class="badge">struct</span>
               </h3>
               
               <p>P384Point is a P384 point. The zero value is NOT valid.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type P384Point struct {
x *fiat.P384Element
y *fiat.P384Element
z *fiat.P384Element
}</code></pre>
            </article>
            
            <article class="struct" data-name="P521Point">
               <h3>
                  P521Point
                  <span class="badge">struct</span>
               </h3>
               
               <p>P521Point is a P521 point. The zero value is NOT valid.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type P521Point struct {
x *fiat.P521Element
y *fiat.P521Element
z *fiat.P521Element
}</code></pre>
            </article>
            
            <article class="struct" data-name="p256AffinePoint">
               <h3>
                  p256AffinePoint
                  <span class="badge">struct</span>
               </h3>
               
               <p>p256AffinePoint is a point in affine coordinates (x, y). x and y are still
Montgomery domain elements. The point can't be the point at infinity.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type p256AffinePoint struct {
x fiat.P256Element
y fiat.P256Element
}</code></pre>
            </article>
            
            <article class="struct" data-name="p256AffinePoint">
               <h3>
                  p256AffinePoint
                  <span class="badge">struct</span>
               </h3>
               
               <p>p256AffinePoint is a point in affine coordinates (x, y). x and y are still
Montgomery domain elements. The point can't be the point at infinity.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type p256AffinePoint struct {
x p256Element
y p256Element
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P224Point) Add(p1 *P224Point, p2 *P224Point) *P224Point</code></pre>
            </article>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P256Point) Add(r1 *P256Point, r2 *P256Point) *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P521Point) Add(p1 *P521Point, p2 *P521Point) *P521Point</code></pre>
            </article>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P384Point) Add(p1 *P384Point, p2 *P384Point) *P384Point</code></pre>
            </article>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add sets q = p1 + p2, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P256Point) Add(p1 *P256Point, p2 *P256Point) *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="AddAffine">
               <h3>
                  AddAffine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddAffine sets q = p1 + p2, if infinity == 0, and to p1 if infinity == 1.
p2 can't be the point at infinity as it can't be represented in affine
coordinates, instead callers can set p2 to an arbitrary point and set
infinity to 1.</p>
               
               <pre><code>func (q *P256Point) AddAffine(p1 *P256Point, p2 *p256AffinePoint, infinity int) *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P384Point) Bytes() []byte</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P521Point) Bytes() []byte</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P256Point) Bytes() []byte</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P256Point) Bytes() []byte</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *p256OrdElement) Bytes() []byte</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bytes returns the uncompressed or infinity encoding of p, as specified in
SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at
infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P224Point) Bytes() []byte</code></pre>
            </article>
            
            <article class="function" data-name="BytesCompressed">
               <h3>
                  BytesCompressed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P224Point) BytesCompressed() []byte</code></pre>
            </article>
            
            <article class="function" data-name="BytesCompressed">
               <h3>
                  BytesCompressed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P256Point) BytesCompressed() []byte</code></pre>
            </article>
            
            <article class="function" data-name="BytesCompressed">
               <h3>
                  BytesCompressed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P256Point) BytesCompressed() []byte</code></pre>
            </article>
            
            <article class="function" data-name="BytesCompressed">
               <h3>
                  BytesCompressed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P384Point) BytesCompressed() []byte</code></pre>
            </article>
            
            <article class="function" data-name="BytesCompressed">
               <h3>
                  BytesCompressed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BytesCompressed returns the compressed or infinity encoding of p, as
specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the
point at infinity is shorter than all other encodings.</p>
               
               <pre><code>func (p *P521Point) BytesCompressed() []byte</code></pre>
            </article>
            
            <article class="function" data-name="BytesX">
               <h3>
                  BytesX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
               
               <pre><code>func (p *P224Point) BytesX() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="BytesX">
               <h3>
                  BytesX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
               
               <pre><code>func (p *P256Point) BytesX() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="BytesX">
               <h3>
                  BytesX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
               
               <pre><code>func (p *P521Point) BytesX() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="BytesX">
               <h3>
                  BytesX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
               
               <pre><code>func (p *P256Point) BytesX() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="BytesX">
               <h3>
                  BytesX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,
Version 2.0, Section 2.3.5, or an error if p is the point at infinity.</p>
               
               <pre><code>func (p *P384Point) BytesX() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Compute">
               <h3>
                  Compute 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Compute populates the table to the first 16 multiples of q.</p>
               
               <pre><code>func (table *p256Table) Compute(q *P256Point) *p256Table</code></pre>
            </article>
            
            <article class="function" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Double sets q = p + p, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P384Point) Double(p *P384Point) *P384Point</code></pre>
            </article>
            
            <article class="function" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Double sets q = p + p, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P256Point) Double(p *P256Point) *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Double sets q = p + p, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P224Point) Double(p *P224Point) *P224Point</code></pre>
            </article>
            
            <article class="function" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Double sets q = p + p, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P256Point) Double(p *P256Point) *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Double sets q = p + p, and returns q. The points may overlap.</p>
               
               <pre><code>func (q *P521Point) Double(p *P521Point) *P521Point</code></pre>
            </article>
            
            <article class="function" data-name="Negate">
               <h3>
                  Negate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Negate sets p to -p, if cond == 1, and to p if cond == 0.</p>
               
               <pre><code>func (p *P256Point) Negate(cond int) *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="Negate">
               <h3>
                  Negate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Negate sets p to -p, if cond == 1, and to p if cond == 0.</p>
               
               <pre><code>func (p *p256AffinePoint) Negate(cond int) *p256AffinePoint</code></pre>
            </article>
            
            <article class="function" data-name="NewP224Point">
               <h3>
                  NewP224Point 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewP224Point returns a new P224Point representing the point at infinity point.</p>
               
               <pre><code>func NewP224Point() *P224Point</code></pre>
            </article>
            
            <article class="function" data-name="NewP256Point">
               <h3>
                  NewP256Point 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewP256Point returns a new P256Point representing the point at infinity.</p>
               
               <pre><code>func NewP256Point() *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="NewP256Point">
               <h3>
                  NewP256Point 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewP256Point returns a new P256Point representing the point at infinity point.</p>
               
               <pre><code>func NewP256Point() *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="NewP384Point">
               <h3>
                  NewP384Point 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewP384Point returns a new P384Point representing the point at infinity point.</p>
               
               <pre><code>func NewP384Point() *P384Point</code></pre>
            </article>
            
            <article class="function" data-name="NewP521Point">
               <h3>
                  NewP521Point 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewP521Point returns a new P521Point representing the point at infinity point.</p>
               
               <pre><code>func NewP521Point() *P521Point</code></pre>
            </article>
            
            <article class="function" data-name="P256OrdInverse">
               <h3>
                  P256OrdInverse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func P256OrdInverse(k []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="P256OrdInverse">
               <h3>
                  P256OrdInverse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func P256OrdInverse(k []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Projective">
               <h3>
                  Projective 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *p256AffinePoint) Projective() *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="Rsh">
               <h3>
                  Rsh 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Rsh returns the 64 least significant bits of x >> n. n must be lower
than 256. The value of n leaks through timing side-channels.</p>
               
               <pre><code>func (s *p256OrdElement) Rsh(n int) uint64</code></pre>
            </article>
            
            <article class="function" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
returns p.</p>
               
               <pre><code>func (p *P521Point) ScalarBaseMult(scalar []byte) (*P521Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
returns p.</p>
               
               <pre><code>func (p *P384Point) ScalarBaseMult(scalar []byte) (*P384Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScalarBaseMult sets r = scalar * generator, where scalar is a 32-byte big
endian value, and returns r. If scalar is not 32 bytes long, ScalarBaseMult
returns an error and the receiver is unchanged.</p>
               
               <pre><code>func (r *P256Point) ScalarBaseMult(scalar []byte) (*P256Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScalarBaseMult sets p = scalar * B, where B is the canonical generator, and
returns p.</p>
               
               <pre><code>func (p *P224Point) ScalarBaseMult(scalar []byte) (*P224Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScalarBaseMult sets p = scalar * generator, where scalar is a 32-byte big
endian value, and returns r. If scalar is not 32 bytes long, ScalarBaseMult
returns an error and the receiver is unchanged.</p>
               
               <pre><code>func (p *P256Point) ScalarBaseMult(scalar []byte) (*P256Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScalarMult sets p = scalar * q, and returns p.</p>
               
               <pre><code>func (p *P224Point) ScalarMult(q *P224Point, scalar []byte) (*P224Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScalarMult sets p = scalar * q, and returns p.</p>
               
               <pre><code>func (p *P521Point) ScalarMult(q *P521Point, scalar []byte) (*P521Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScalarMult sets r = scalar * q, where scalar is a 32-byte big endian value,
and returns r. If scalar is not 32 bytes long, ScalarMult returns an error
and the receiver is unchanged.</p>
               
               <pre><code>func (p *P256Point) ScalarMult(q *P256Point, scalar []byte) (*P256Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScalarMult sets p = scalar * q, and returns p.</p>
               
               <pre><code>func (p *P384Point) ScalarMult(q *P384Point, scalar []byte) (*P384Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScalarMult sets r = scalar * q, where scalar is a 32-byte big endian value,
and returns r. If scalar is not 32 bytes long, ScalarBaseMult returns an
error and the receiver is unchanged.</p>
               
               <pre><code>func (r *P256Point) ScalarMult(q *P256Point, scalar []byte) (*P256Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
               
               <pre><code>func (q *P224Point) Select(p1 *P224Point, p2 *P224Point, cond int) *P224Point</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
               
               <pre><code>func (q *P521Point) Select(p1 *P521Point, p2 *P521Point, cond int) *P521Point</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
               
               <pre><code>func (q *P256Point) Select(p1 *P256Point, p2 *P256Point, cond int) *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Select selects the n-th multiple of the table base point into p. It works in
constant time by iterating over every entry of the table. n must be in [0, 15].</p>
               
               <pre><code>func (table *p521Table) Select(p *P521Point, n uint8)</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
               
               <pre><code>func (q *P384Point) Select(p1 *P384Point, p2 *P384Point, cond int) *P384Point</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Select selects the n-th multiple of the table base point into p. It works in
constant time by iterating over every entry of the table. n must be in [0, 15].</p>
               
               <pre><code>func (table *p384Table) Select(p *P384Point, n uint8)</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Select selects the n-th multiple of the table base point into p. It works in
constant time. n can be in [0, 32], but (unlike p256Table.Select) if n is 0,
p is set to an undefined value.</p>
               
               <pre><code>func (table *p256AffineTable) Select(p *p256AffinePoint, n uint8)</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Select selects the n-th multiple of the table base point into p. It works in
constant time. n must be in [0, 16]. If n is 0, p is set to the identity point.</p>
               
               <pre><code>func (table *p256Table) Select(p *P256Point, n uint8)</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Select sets q to p1 if cond == 1, and to p2 if cond == 0.</p>
               
               <pre><code>func (q *P256Point) Select(p1 *P256Point, p2 *P256Point, cond int) *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Select selects the n-th multiple of the table base point into p. It works in
constant time by iterating over every entry of the table. n must be in [0, 15].</p>
               
               <pre><code>func (table *p224Table) Select(p *P224Point, n uint8)</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set sets p = q and returns p.</p>
               
               <pre><code>func (p *P256Point) Set(q *P256Point) *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set sets p = q and returns p.</p>
               
               <pre><code>func (p *P384Point) Set(q *P384Point) *P384Point</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set sets p = q and returns p.</p>
               
               <pre><code>func (p *P256Point) Set(q *P256Point) *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set sets p = q and returns p.</p>
               
               <pre><code>func (p *P224Point) Set(q *P224Point) *P224Point</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set sets p = q and returns p.</p>
               
               <pre><code>func (p *P521Point) Set(q *P521Point) *P521Point</code></pre>
            </article>
            
            <article class="function" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
               
               <pre><code>func (p *P256Point) SetBytes(b []byte) (*P256Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
               
               <pre><code>func (p *P224Point) SetBytes(b []byte) (*P224Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
               
               <pre><code>func (p *P384Point) SetBytes(b []byte) (*P384Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
               
               <pre><code>func (p *P521Point) SetBytes(b []byte) (*P521Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBytes sets s to the big-endian value of x, reducing it as necessary.</p>
               
               <pre><code>func (s *p256OrdElement) SetBytes(x []byte) (*p256OrdElement, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBytes sets p to the compressed, uncompressed, or infinity value encoded in
b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on
the curve, it returns nil and an error, and the receiver is unchanged.
Otherwise, it returns p.</p>
               
               <pre><code>func (p *P256Point) SetBytes(b []byte) (*P256Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetGenerator">
               <h3>
                  SetGenerator 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetGenerator sets p to the canonical generator and returns p.</p>
               
               <pre><code>func (p *P521Point) SetGenerator() *P521Point</code></pre>
            </article>
            
            <article class="function" data-name="SetGenerator">
               <h3>
                  SetGenerator 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetGenerator sets p to the canonical generator and returns p.</p>
               
               <pre><code>func (p *P256Point) SetGenerator() *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="SetGenerator">
               <h3>
                  SetGenerator 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetGenerator sets p to the canonical generator and returns p.</p>
               
               <pre><code>func (p *P224Point) SetGenerator() *P224Point</code></pre>
            </article>
            
            <article class="function" data-name="SetGenerator">
               <h3>
                  SetGenerator 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetGenerator sets p to the canonical generator and returns p.</p>
               
               <pre><code>func (p *P384Point) SetGenerator() *P384Point</code></pre>
            </article>
            
            <article class="function" data-name="SetGenerator">
               <h3>
                  SetGenerator 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetGenerator sets p to the canonical generator and returns p.</p>
               
               <pre><code>func (p *P256Point) SetGenerator() *P256Point</code></pre>
            </article>
            
            <article class="function" data-name="affineFromMont">
               <h3>
                  affineFromMont 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>affineFromMont sets (x, y) to the affine coordinates of p, converted out of the
Montgomery domain.</p>
               
               <pre><code>func (p *P256Point) affineFromMont(x *p256Element, y *p256Element)</code></pre>
            </article>
            
            <article class="function" data-name="boothW5">
               <h3>
                  boothW5 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func boothW5(in uint64) (uint8, int)</code></pre>
            </article>
            
            <article class="function" data-name="boothW5">
               <h3>
                  boothW5 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func boothW5(in uint) (int, int)</code></pre>
            </article>
            
            <article class="function" data-name="boothW6">
               <h3>
                  boothW6 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func boothW6(in uint64) (uint8, int)</code></pre>
            </article>
            
            <article class="function" data-name="boothW6">
               <h3>
                  boothW6 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func boothW6(in uint) (int, int)</code></pre>
            </article>
            
            <article class="function" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P224Point) bytes(out *[*ast.BinaryExpr]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P521Point) bytes(out *[*ast.BinaryExpr]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P256Point) bytes(out *[p256UncompressedLength]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P256Point) bytes(out *[p256UncompressedLength]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P384Point) bytes(out *[*ast.BinaryExpr]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="bytesCompressed">
               <h3>
                  bytesCompressed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P256Point) bytesCompressed(out *[p256CompressedLength]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="bytesCompressed">
               <h3>
                  bytesCompressed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P384Point) bytesCompressed(out *[*ast.BinaryExpr]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="bytesCompressed">
               <h3>
                  bytesCompressed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P224Point) bytesCompressed(out *[*ast.BinaryExpr]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="bytesCompressed">
               <h3>
                  bytesCompressed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P256Point) bytesCompressed(out *[p256CompressedLength]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="bytesCompressed">
               <h3>
                  bytesCompressed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P521Point) bytesCompressed(out *[*ast.BinaryExpr]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="bytesToLimbs">
               <h3>
                  bytesToLimbs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func bytesToLimbs(l *[4]uint64, b *[32]byte)</code></pre>
            </article>
            
            <article class="function" data-name="bytesX">
               <h3>
                  bytesX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P384Point) bytesX(out *[p384ElementLength]byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="bytesX">
               <h3>
                  bytesX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P256Point) bytesX(out *[p256ElementLength]byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="bytesX">
               <h3>
                  bytesX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P256Point) bytesX(out *[p256ElementLength]byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="bytesX">
               <h3>
                  bytesX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P521Point) bytesX(out *[p521ElementLength]byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="bytesX">
               <h3>
                  bytesX 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P224Point) bytesX(out *[p224ElementLength]byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="generatorTable">
               <h3>
                  generatorTable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>generatorTable returns a sequence of p384Tables. The first table contains
multiples of G. Each successive table is the previous table doubled four
times.</p>
               
               <pre><code>func (p *P384Point) generatorTable() *[*ast.BinaryExpr]p384Table</code></pre>
            </article>
            
            <article class="function" data-name="generatorTable">
               <h3>
                  generatorTable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>generatorTable returns a sequence of p521Tables. The first table contains
multiples of G. Each successive table is the previous table doubled four
times.</p>
               
               <pre><code>func (p *P521Point) generatorTable() *[*ast.BinaryExpr]p521Table</code></pre>
            </article>
            
            <article class="function" data-name="generatorTable">
               <h3>
                  generatorTable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>generatorTable returns a sequence of p224Tables. The first table contains
multiples of G. Each successive table is the previous table doubled four
times.</p>
               
               <pre><code>func (p *P224Point) generatorTable() *[*ast.BinaryExpr]p224Table</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="isInfinity">
               <h3>
                  isInfinity 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isInfinity returns 1 if p is the point at infinity and 0 otherwise.</p>
               
               <pre><code>func (p *P256Point) isInfinity() int</code></pre>
            </article>
            
            <article class="function" data-name="limbsToBytes">
               <h3>
                  limbsToBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func limbsToBytes(b *[32]byte, l *[4]uint64)</code></pre>
            </article>
            
            <article class="function" data-name="p224B">
               <h3>
                  p224B 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p224B() *fiat.P224Element</code></pre>
            </article>
            
            <article class="function" data-name="p224CheckOnCurve">
               <h3>
                  p224CheckOnCurve 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p224CheckOnCurve(x *fiat.P224Element, y *fiat.P224Element) error</code></pre>
            </article>
            
            <article class="function" data-name="p224Polynomial">
               <h3>
                  p224Polynomial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p224Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
               
               <pre><code>func p224Polynomial(y2 *fiat.P224Element, x *fiat.P224Element) *fiat.P224Element</code></pre>
            </article>
            
            <article class="function" data-name="p224Sqrt">
               <h3>
                  p224Sqrt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p224Sqrt sets e to a square root of x. If x is not a square, p224Sqrt returns
false and e is unchanged. e and x can overlap.</p>
               
               <pre><code>func p224Sqrt(e *fiat.P224Element, x *fiat.P224Element) (isSquare bool)</code></pre>
            </article>
            
            <article class="function" data-name="p224SqrtCandidate">
               <h3>
                  p224SqrtCandidate 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p224SqrtCandidate sets r to a square root candidate for x. r and x must not overlap.</p>
               
               <pre><code>func p224SqrtCandidate(r *fiat.P224Element, x *fiat.P224Element)</code></pre>
            </article>
            
            <article class="function" data-name="p256Add">
               <h3>
                  p256Add 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p256Add sets res = x + y.</p>
               
               <pre><code>func p256Add(res *p256Element, x *p256Element, y *p256Element)</code></pre>
            </article>
            
            <article class="function" data-name="p256B">
               <h3>
                  p256B 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p256B() *fiat.P256Element</code></pre>
            </article>
            
            <article class="function" data-name="p256BaseMult">
               <h3>
                  p256BaseMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P256Point) p256BaseMult(scalar *p256OrdElement)</code></pre>
            </article>
            
            <article class="function" data-name="p256BigToLittle">
               <h3>
                  p256BigToLittle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p256BigToLittle(l *p256Element, b *[32]byte)</code></pre>
            </article>
            
            <article class="function" data-name="p256CheckOnCurve">
               <h3>
                  p256CheckOnCurve 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p256CheckOnCurve(x *fiat.P256Element, y *fiat.P256Element) error</code></pre>
            </article>
            
            <article class="function" data-name="p256CheckOnCurve">
               <h3>
                  p256CheckOnCurve 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p256CheckOnCurve(x *p256Element, y *p256Element) error</code></pre>
            </article>
            
            <article class="function" data-name="p256Equal">
               <h3>
                  p256Equal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p256Equal returns 1 if a and b are equal and 0 otherwise.</p>
               
               <pre><code>func p256Equal(a *p256Element, b *p256Element) int</code></pre>
            </article>
            
            <article class="function" data-name="p256FromMont">
               <h3>
                  p256FromMont 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Montgomery multiplication by R⁻¹, or 1 outside the domain.
Sets res = in * R⁻¹, bringing res out of the Montgomery domain.
go:noescape</p>
               
               <pre><code>func p256FromMont(res *p256Element, in *p256Element)</code></pre>
            </article>
            
            <article class="function" data-name="p256Inverse">
               <h3>
                  p256Inverse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p256Inverse sets out to in⁻¹ mod p. If in is zero, out will be zero.</p>
               
               <pre><code>func p256Inverse(out *p256Element, in *p256Element)</code></pre>
            </article>
            
            <article class="function" data-name="p256LessThanP">
               <h3>
                  p256LessThanP 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p256LessThanP returns 1 if x < p, and 0 otherwise. Note that a p256Element is
not allowed to be equal to or greater than p, so if this function returns 0
then x is invalid.</p>
               
               <pre><code>func p256LessThanP(x *p256Element) int</code></pre>
            </article>
            
            <article class="function" data-name="p256LittleToBig">
               <h3>
                  p256LittleToBig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p256LittleToBig(b *[32]byte, l *p256Element)</code></pre>
            </article>
            
            <article class="function" data-name="p256MovCond">
               <h3>
                  p256MovCond 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If cond is 0, sets res = b, otherwise sets res = a.
go:noescape</p>
               
               <pre><code>func p256MovCond(res *P256Point, a *P256Point, b *P256Point, cond int)</code></pre>
            </article>
            
            <article class="function" data-name="p256Mul">
               <h3>
                  p256Mul 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Montgomery multiplication. Sets res = in1 * in2 * R⁻¹ mod p.
go:noescape</p>
               
               <pre><code>func p256Mul(res *p256Element, in1 *p256Element, in2 *p256Element)</code></pre>
            </article>
            
            <article class="function" data-name="p256NegCond">
               <h3>
                  p256NegCond 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>If cond is not 0, sets val = -val mod p.
go:noescape</p>
               
               <pre><code>func p256NegCond(val *p256Element, cond int)</code></pre>
            </article>
            
            <article class="function" data-name="p256OrdBigToLittle">
               <h3>
                  p256OrdBigToLittle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p256OrdBigToLittle(l *p256OrdElement, b *[32]byte)</code></pre>
            </article>
            
            <article class="function" data-name="p256OrdLittleToBig">
               <h3>
                  p256OrdLittleToBig 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p256OrdLittleToBig(b *[32]byte, l *p256OrdElement)</code></pre>
            </article>
            
            <article class="function" data-name="p256OrdMul">
               <h3>
                  p256OrdMul 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Montgomery multiplication modulo org(G). Sets res = in1 * in2 * R⁻¹.
go:noescape</p>
               
               <pre><code>func p256OrdMul(res *p256OrdElement, in1 *p256OrdElement, in2 *p256OrdElement)</code></pre>
            </article>
            
            <article class="function" data-name="p256OrdReduce">
               <h3>
                  p256OrdReduce 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p256OrdReduce ensures s is in the range [0, ord(G)-1].</p>
               
               <pre><code>func p256OrdReduce(s *p256OrdElement)</code></pre>
            </article>
            
            <article class="function" data-name="p256OrdSqr">
               <h3>
                  p256OrdSqr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Montgomery square modulo org(G), repeated n times (n >= 1).
go:noescape</p>
               
               <pre><code>func p256OrdSqr(res *p256OrdElement, in *p256OrdElement, n int)</code></pre>
            </article>
            
            <article class="function" data-name="p256PointAddAffineAsm">
               <h3>
                  p256PointAddAffineAsm 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Point addition with an affine point and constant time conditions.
If zero is 0, sets res = in2. If sel is 0, sets res = in1.
If sign is not 0, sets res = in1 + -in2. Otherwise, sets res = in1 + in2
go:noescape</p>
               
               <pre><code>func p256PointAddAffineAsm(res *P256Point, in1 *P256Point, in2 *p256AffinePoint, sign int, sel int, zero int)</code></pre>
            </article>
            
            <article class="function" data-name="p256PointAddAsm">
               <h3>
                  p256PointAddAsm 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Point addition. Sets res = in1 + in2. Returns one if the two input points
were equal and zero otherwise. If in1 or in2 are the point at infinity, res
and the return value are undefined.
go:noescape</p>
               
               <pre><code>func p256PointAddAsm(res *P256Point, in1 *P256Point, in2 *P256Point) int</code></pre>
            </article>
            
            <article class="function" data-name="p256PointDoubleAsm">
               <h3>
                  p256PointDoubleAsm 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Point doubling. Sets res = in + in. in can be the point at infinity.
go:noescape</p>
               
               <pre><code>func p256PointDoubleAsm(res *P256Point, in *P256Point)</code></pre>
            </article>
            
            <article class="function" data-name="p256Polynomial">
               <h3>
                  p256Polynomial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p256Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
               
               <pre><code>func p256Polynomial(y2 *p256Element, x *p256Element) *p256Element</code></pre>
            </article>
            
            <article class="function" data-name="p256Polynomial">
               <h3>
                  p256Polynomial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p256Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
               
               <pre><code>func p256Polynomial(y2 *fiat.P256Element, x *fiat.P256Element) *fiat.P256Element</code></pre>
            </article>
            
            <article class="function" data-name="p256ScalarMult">
               <h3>
                  p256ScalarMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *P256Point) p256ScalarMult(scalar *p256OrdElement)</code></pre>
            </article>
            
            <article class="function" data-name="p256Select">
               <h3>
                  p256Select 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p256Select sets res to the point at index idx in the table.
idx must be in [0, 15]. It executes in constant time.
go:noescape</p>
               
               <pre><code>func p256Select(res *P256Point, table *p256Table, idx int)</code></pre>
            </article>
            
            <article class="function" data-name="p256SelectAffine">
               <h3>
                  p256SelectAffine 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p256SelectAffine sets res to the point at index idx in the table.
idx must be in [0, 31]. It executes in constant time.
go:noescape</p>
               
               <pre><code>func p256SelectAffine(res *p256AffinePoint, table *p256AffineTable, idx int)</code></pre>
            </article>
            
            <article class="function" data-name="p256Sqr">
               <h3>
                  p256Sqr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Montgomery square, repeated n times (n >= 1).
go:noescape</p>
               
               <pre><code>func p256Sqr(res *p256Element, in *p256Element, n int)</code></pre>
            </article>
            
            <article class="function" data-name="p256Sqrt">
               <h3>
                  p256Sqrt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p256Sqrt sets e to a square root of x. If x is not a square, p256Sqrt returns
false and e is unchanged. e and x can overlap.</p>
               
               <pre><code>func p256Sqrt(e *p256Element, x *p256Element) (isSquare bool)</code></pre>
            </article>
            
            <article class="function" data-name="p256Sqrt">
               <h3>
                  p256Sqrt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p256Sqrt sets e to a square root of x. If x is not a square, p256Sqrt returns
false and e is unchanged. e and x can overlap.</p>
               
               <pre><code>func p256Sqrt(e *fiat.P256Element, x *fiat.P256Element) (isSquare bool)</code></pre>
            </article>
            
            <article class="function" data-name="p256Square">
               <h3>
                  p256Square 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p256Square sets e to the square of x, repeated n times > 1.</p>
               
               <pre><code>func p256Square(e *fiat.P256Element, x *fiat.P256Element, n int)</code></pre>
            </article>
            
            <article class="function" data-name="p384B">
               <h3>
                  p384B 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p384B() *fiat.P384Element</code></pre>
            </article>
            
            <article class="function" data-name="p384CheckOnCurve">
               <h3>
                  p384CheckOnCurve 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p384CheckOnCurve(x *fiat.P384Element, y *fiat.P384Element) error</code></pre>
            </article>
            
            <article class="function" data-name="p384Polynomial">
               <h3>
                  p384Polynomial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p384Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
               
               <pre><code>func p384Polynomial(y2 *fiat.P384Element, x *fiat.P384Element) *fiat.P384Element</code></pre>
            </article>
            
            <article class="function" data-name="p384Sqrt">
               <h3>
                  p384Sqrt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p384Sqrt sets e to a square root of x. If x is not a square, p384Sqrt returns
false and e is unchanged. e and x can overlap.</p>
               
               <pre><code>func p384Sqrt(e *fiat.P384Element, x *fiat.P384Element) (isSquare bool)</code></pre>
            </article>
            
            <article class="function" data-name="p384SqrtCandidate">
               <h3>
                  p384SqrtCandidate 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p384SqrtCandidate sets z to a square root candidate for x. z and x must not overlap.</p>
               
               <pre><code>func p384SqrtCandidate(z *fiat.P384Element, x *fiat.P384Element)</code></pre>
            </article>
            
            <article class="function" data-name="p521B">
               <h3>
                  p521B 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p521B() *fiat.P521Element</code></pre>
            </article>
            
            <article class="function" data-name="p521CheckOnCurve">
               <h3>
                  p521CheckOnCurve 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func p521CheckOnCurve(x *fiat.P521Element, y *fiat.P521Element) error</code></pre>
            </article>
            
            <article class="function" data-name="p521Polynomial">
               <h3>
                  p521Polynomial 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p521Polynomial sets y2 to x³ - 3x + b, and returns y2.</p>
               
               <pre><code>func p521Polynomial(y2 *fiat.P521Element, x *fiat.P521Element) *fiat.P521Element</code></pre>
            </article>
            
            <article class="function" data-name="p521Sqrt">
               <h3>
                  p521Sqrt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p521Sqrt sets e to a square root of x. If x is not a square, p521Sqrt returns
false and e is unchanged. e and x can overlap.</p>
               
               <pre><code>func p521Sqrt(e *fiat.P521Element, x *fiat.P521Element) (isSquare bool)</code></pre>
            </article>
            
            <article class="function" data-name="p521SqrtCandidate">
               <h3>
                  p521SqrtCandidate 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>p521SqrtCandidate sets z to a square root candidate for x. z and x must not overlap.</p>
               
               <pre><code>func p521SqrtCandidate(z *fiat.P521Element, x *fiat.P521Element)</code></pre>
            </article>
            
            <article class="function" data-name="uint64IsZero">
               <h3>
                  uint64IsZero 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>uint64IsZero returns 1 if x is zero and zero otherwise.</p>
               
               <pre><code>func uint64IsZero(x uint64) int</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
