<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - edwards25519</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="crypto_internal_fips140_edwards25519_field-docs.html">field</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>edwards25519</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"crypto/internal/fips140deps/byteorder"
"errors"
"math/bits"
"sync"
"crypto/internal/fips140/subtle"
_ "crypto/internal/fips140/check"
"crypto/internal/fips140/edwards25519/field"
"errors"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>d is a constant in the curve equation.</p>
               
               <pre><code>var _</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>generator is the canonical curve basepoint. See TestGenerator for the
correspondence of this encoding with the values in RFC 8032.</p>
               
               <pre><code>var _</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>identity is the point at infinity.</p>
               
               <pre><code>var _</code></pre>
            </article>
            
            <article class="global" data-name="basepointNafTablePrecomp">
               <h3>
                  basepointNafTablePrecomp 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var basepointNafTablePrecomp struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="basepointTablePrecomp">
               <h3>
                  basepointTablePrecomp 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var basepointTablePrecomp struct{...}</code></pre>
            </article>
            
            <article class="global" data-name="d">
               <h3>
                  d 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>d is a constant in the curve equation.</p>
               
               <pre><code>var d = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="d2">
               <h3>
                  d2 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var d2 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="feOne">
               <h3>
                  feOne 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var feOne = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="generator">
               <h3>
                  generator 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>generator is the canonical curve basepoint. See TestGenerator for the
correspondence of this encoding with the values in RFC 8032.</p>
               
               <pre><code>var generator = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="identity">
               <h3>
                  identity 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>identity is the point at infinity.</p>
               
               <pre><code>var identity = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="scalarMinusOneBytes">
               <h3>
                  scalarMinusOneBytes 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>scalarMinusOneBytes is l - 1 in little endian.</p>
               
               <pre><code>var scalarMinusOneBytes = [32]byte{...}</code></pre>
            </article>
            
            <article class="global" data-name="scalarTwo168">
               <h3>
                  scalarTwo168 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>scalarTwo168 and scalarTwo336 are 2^168 and 2^336 modulo l, encoded as a
fiatScalarMontgomeryDomainFieldElement, which is a little-endian 4-limb value
in the 2^256 Montgomery domain.</p>
               
               <pre><code>var scalarTwo168 = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="scalarTwo336">
               <h3>
                  scalarTwo336 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var scalarTwo336 = *ast.UnaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="fiatScalarInt1">
               <h3>
                  fiatScalarInt1
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type fiatScalarInt1 int64</code></pre>
            </article>
            
            <article class="type" data-name="fiatScalarMontgomeryDomainFieldElement">
               <h3>
                  fiatScalarMontgomeryDomainFieldElement
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>The type fiatScalarMontgomeryDomainFieldElement is a field element in the Montgomery domain.
Bounds: [[0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff]]</p>
               
               <pre><code>type fiatScalarMontgomeryDomainFieldElement [4]uint64</code></pre>
            </article>
            
            <article class="type" data-name="fiatScalarNonMontgomeryDomainFieldElement">
               <h3>
                  fiatScalarNonMontgomeryDomainFieldElement
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>The type fiatScalarNonMontgomeryDomainFieldElement is a field element NOT in the Montgomery domain.
Bounds: [[0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff]]</p>
               
               <pre><code>type fiatScalarNonMontgomeryDomainFieldElement [4]uint64</code></pre>
            </article>
            
            <article class="type" data-name="fiatScalarUint1">
               <h3>
                  fiatScalarUint1
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type fiatScalarUint1 uint64</code></pre>
            </article>
            
            <article class="type" data-name="incomparable">
               <h3>
                  incomparable
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type incomparable [0]func()</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Point">
               <h3>
                  Point
                  <span class="badge">struct</span>
               </h3>
               
               <p>Point represents a point on the edwards25519 curve.
This type works similarly to math/big.Int, and all arguments and receivers
are allowed to alias.
The zero value is NOT valid, and it may be used only as a receiver.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Point struct {
_ incomparable
x field.Element
y field.Element
z field.Element
t field.Element
}</code></pre>
            </article>
            
            <article class="struct" data-name="Scalar">
               <h3>
                  Scalar
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Scalar is an integer modulo
l = 2^252 + 27742317777372353535851937790883648493
which is the prime order of the edwards25519 group.
This type works similarly to math/big.Int, and all arguments and
receivers are allowed to alias.
The zero value is a valid zero element.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Scalar struct {
s fiatScalarMontgomeryDomainFieldElement
}</code></pre>
            </article>
            
            <article class="struct" data-name="affineCached">
               <h3>
                  affineCached
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type affineCached struct {
YplusX field.Element
YminusX field.Element
T2d field.Element
}</code></pre>
            </article>
            
            <article class="struct" data-name="affineLookupTable">
               <h3>
                  affineLookupTable
                  <span class="badge">struct</span>
               </h3>
               
               <p>A precomputed lookup table for fixed-base, constant-time scalar muls.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type affineLookupTable struct {
points [8]affineCached
}</code></pre>
            </article>
            
            <article class="struct" data-name="nafLookupTable5">
               <h3>
                  nafLookupTable5
                  <span class="badge">struct</span>
               </h3>
               
               <p>A dynamic lookup table for variable-base, variable-time scalar muls.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nafLookupTable5 struct {
points [8]projCached
}</code></pre>
            </article>
            
            <article class="struct" data-name="nafLookupTable8">
               <h3>
                  nafLookupTable8
                  <span class="badge">struct</span>
               </h3>
               
               <p>A precomputed lookup table for fixed-base, variable-time scalar muls.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type nafLookupTable8 struct {
points [64]affineCached
}</code></pre>
            </article>
            
            <article class="struct" data-name="projCached">
               <h3>
                  projCached
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type projCached struct {
YplusX field.Element
YminusX field.Element
Z field.Element
T2d field.Element
}</code></pre>
            </article>
            
            <article class="struct" data-name="projLookupTable">
               <h3>
                  projLookupTable
                  <span class="badge">struct</span>
               </h3>
               
               <p>A dynamic lookup table for variable-base, constant-time scalar muls.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type projLookupTable struct {
points [8]projCached
}</code></pre>
            </article>
            
            <article class="struct" data-name="projP1xP1">
               <h3>
                  projP1xP1
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type projP1xP1 struct {
X field.Element
Y field.Element
Z field.Element
T field.Element
}</code></pre>
            </article>
            
            <article class="struct" data-name="projP2">
               <h3>
                  projP2
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type projP2 struct {
X field.Element
Y field.Element
Z field.Element
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add sets s = x + y mod l, and returns s.</p>
               
               <pre><code>func (s *Scalar) Add(x *Scalar, y *Scalar) *Scalar</code></pre>
            </article>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *projP1xP1) Add(p *Point, q *projCached) *projP1xP1</code></pre>
            </article>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add sets v = p + q, and returns v.</p>
               
               <pre><code>func (v *Point) Add(p *Point, q *Point) *Point</code></pre>
            </article>
            
            <article class="function" data-name="AddAffine">
               <h3>
                  AddAffine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *projP1xP1) AddAffine(p *Point, q *affineCached) *projP1xP1</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bytes returns the canonical 32-byte little-endian encoding of s.</p>
               
               <pre><code>func (s *Scalar) Bytes() []byte</code></pre>
            </article>
            
            <article class="function" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Bytes returns the canonical 32-byte encoding of v, according to RFC 8032,
Section 5.1.2.</p>
               
               <pre><code>func (v *Point) Bytes() []byte</code></pre>
            </article>
            
            <article class="function" data-name="CondNeg">
               <h3>
                  CondNeg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CondNeg negates v if cond == 1 and leaves it unchanged if cond == 0.</p>
               
               <pre><code>func (v *affineCached) CondNeg(cond int) *affineCached</code></pre>
            </article>
            
            <article class="function" data-name="CondNeg">
               <h3>
                  CondNeg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>CondNeg negates v if cond == 1 and leaves it unchanged if cond == 0.</p>
               
               <pre><code>func (v *projCached) CondNeg(cond int) *projCached</code></pre>
            </article>
            
            <article class="function" data-name="Double">
               <h3>
                  Double 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *projP1xP1) Double(p *projP2) *projP1xP1</code></pre>
            </article>
            
            <article class="function" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Equal returns 1 if v is equivalent to u, and 0 otherwise.</p>
               
               <pre><code>func (v *Point) Equal(u *Point) int</code></pre>
            </article>
            
            <article class="function" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Equal returns 1 if s and t are equal, and 0 otherwise.</p>
               
               <pre><code>func (s *Scalar) Equal(t *Scalar) int</code></pre>
            </article>
            
            <article class="function" data-name="FromP1xP1">
               <h3>
                  FromP1xP1 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *projP2) FromP1xP1(p *projP1xP1) *projP2</code></pre>
            </article>
            
            <article class="function" data-name="FromP3">
               <h3>
                  FromP3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *projP2) FromP3(p *Point) *projP2</code></pre>
            </article>
            
            <article class="function" data-name="FromP3">
               <h3>
                  FromP3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *projCached) FromP3(p *Point) *projCached</code></pre>
            </article>
            
            <article class="function" data-name="FromP3">
               <h3>
                  FromP3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Builds a lookup table at runtime. Fast.</p>
               
               <pre><code>func (v *projLookupTable) FromP3(q *Point)</code></pre>
            </article>
            
            <article class="function" data-name="FromP3">
               <h3>
                  FromP3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>This is not optimised for speed; fixed-base tables should be precomputed.</p>
               
               <pre><code>func (v *affineLookupTable) FromP3(q *Point)</code></pre>
            </article>
            
            <article class="function" data-name="FromP3">
               <h3>
                  FromP3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>This is not optimised for speed; fixed-base tables should be precomputed.</p>
               
               <pre><code>func (v *nafLookupTable8) FromP3(q *Point)</code></pre>
            </article>
            
            <article class="function" data-name="FromP3">
               <h3>
                  FromP3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *affineCached) FromP3(p *Point) *affineCached</code></pre>
            </article>
            
            <article class="function" data-name="FromP3">
               <h3>
                  FromP3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Builds a lookup table at runtime. Fast.</p>
               
               <pre><code>func (v *nafLookupTable5) FromP3(q *Point)</code></pre>
            </article>
            
            <article class="function" data-name="Multiply">
               <h3>
                  Multiply 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Multiply sets s = x * y mod l, and returns s.</p>
               
               <pre><code>func (s *Scalar) Multiply(x *Scalar, y *Scalar) *Scalar</code></pre>
            </article>
            
            <article class="function" data-name="MultiplyAdd">
               <h3>
                  MultiplyAdd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MultiplyAdd sets s = x * y + z mod l, and returns s. It is equivalent to
using Multiply and then Add.</p>
               
               <pre><code>func (s *Scalar) MultiplyAdd(x *Scalar, y *Scalar, z *Scalar) *Scalar</code></pre>
            </article>
            
            <article class="function" data-name="Negate">
               <h3>
                  Negate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Negate sets s = -x mod l, and returns s.</p>
               
               <pre><code>func (s *Scalar) Negate(x *Scalar) *Scalar</code></pre>
            </article>
            
            <article class="function" data-name="Negate">
               <h3>
                  Negate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Negate sets v = -p, and returns v.</p>
               
               <pre><code>func (v *Point) Negate(p *Point) *Point</code></pre>
            </article>
            
            <article class="function" data-name="NewGeneratorPoint">
               <h3>
                  NewGeneratorPoint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewGeneratorPoint returns a new Point set to the canonical generator.</p>
               
               <pre><code>func NewGeneratorPoint() *Point</code></pre>
            </article>
            
            <article class="function" data-name="NewIdentityPoint">
               <h3>
                  NewIdentityPoint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewIdentityPoint returns a new Point set to the identity.</p>
               
               <pre><code>func NewIdentityPoint() *Point</code></pre>
            </article>
            
            <article class="function" data-name="NewScalar">
               <h3>
                  NewScalar 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewScalar returns a new zero Scalar.</p>
               
               <pre><code>func NewScalar() *Scalar</code></pre>
            </article>
            
            <article class="function" data-name="ScalarBaseMult">
               <h3>
                  ScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScalarBaseMult sets v = x * B, where B is the canonical generator, and
returns v.
The scalar multiplication is done in constant time.</p>
               
               <pre><code>func (v *Point) ScalarBaseMult(x *Scalar) *Point</code></pre>
            </article>
            
            <article class="function" data-name="ScalarMult">
               <h3>
                  ScalarMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ScalarMult sets v = x * q, and returns v.
The scalar multiplication is done in constant time.</p>
               
               <pre><code>func (v *Point) ScalarMult(x *Scalar, q *Point) *Point</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Select sets v to a if cond == 1 and to b if cond == 0.</p>
               
               <pre><code>func (v *projCached) Select(a *projCached, b *projCached, cond int) *projCached</code></pre>
            </article>
            
            <article class="function" data-name="Select">
               <h3>
                  Select 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Select sets v to a if cond == 1 and to b if cond == 0.</p>
               
               <pre><code>func (v *affineCached) Select(a *affineCached, b *affineCached, cond int) *affineCached</code></pre>
            </article>
            
            <article class="function" data-name="SelectInto">
               <h3>
                  SelectInto 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set dest to x*Q, where -8 <= x <= 8, in constant time.</p>
               
               <pre><code>func (v *projLookupTable) SelectInto(dest *projCached, x int8)</code></pre>
            </article>
            
            <article class="function" data-name="SelectInto">
               <h3>
                  SelectInto 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set dest to x*Q, where -8 <= x <= 8, in constant time.</p>
               
               <pre><code>func (v *affineLookupTable) SelectInto(dest *affineCached, x int8)</code></pre>
            </article>
            
            <article class="function" data-name="SelectInto">
               <h3>
                  SelectInto 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Given odd x with 0 < x < 2^7, return x*Q (in variable time).</p>
               
               <pre><code>func (v *nafLookupTable8) SelectInto(dest *affineCached, x int8)</code></pre>
            </article>
            
            <article class="function" data-name="SelectInto">
               <h3>
                  SelectInto 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Given odd x with 0 < x < 2^4, return x*Q (in variable time).</p>
               
               <pre><code>func (v *nafLookupTable5) SelectInto(dest *projCached, x int8)</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set sets v = u, and returns v.</p>
               
               <pre><code>func (v *Point) Set(u *Point) *Point</code></pre>
            </article>
            
            <article class="function" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Set sets s = x, and returns s.</p>
               
               <pre><code>func (s *Scalar) Set(x *Scalar) *Scalar</code></pre>
            </article>
            
            <article class="function" data-name="SetBytes">
               <h3>
                  SetBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBytes sets v = x, where x is a 32-byte encoding of v. If x does not
represent a valid point on the curve, SetBytes returns nil and an error and
the receiver is unchanged. Otherwise, SetBytes returns v.
Note that SetBytes accepts all non-canonical encodings of valid points.
That is, it follows decoding rules that match most implementations in
the ecosystem rather than RFC 8032.</p>
               
               <pre><code>func (v *Point) SetBytes(x []byte) (*Point, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetBytesWithClamping">
               <h3>
                  SetBytesWithClamping 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetBytesWithClamping applies the buffer pruning described in RFC 8032,
Section 5.1.5 (also known as clamping) and sets s to the result. The input
must be 32 bytes, and it is not modified. If x is not of the right length,
SetBytesWithClamping returns nil and an error, and the receiver is unchanged.
Note that since Scalar values are always reduced modulo the prime order of
the curve, the resulting value will not preserve any of the cofactor-clearing
properties that clamping is meant to provide. It will however work as
expected as long as it is applied to points on the prime order subgroup, like
in Ed25519. In fact, it is lost to history why RFC 8032 adopted the
irrelevant RFC 7748 clamping, but it is now required for compatibility.</p>
               
               <pre><code>func (s *Scalar) SetBytesWithClamping(x []byte) (*Scalar, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetCanonicalBytes">
               <h3>
                  SetCanonicalBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetCanonicalBytes sets s = x, where x is a 32-byte little-endian encoding of
s, and returns s. If x is not a canonical encoding of s, SetCanonicalBytes
returns nil and an error, and the receiver is unchanged.</p>
               
               <pre><code>func (s *Scalar) SetCanonicalBytes(x []byte) (*Scalar, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetUniformBytes">
               <h3>
                  SetUniformBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetUniformBytes sets s = x mod l, where x is a 64-byte little-endian integer.
If x is not of the right length, SetUniformBytes returns nil and an error,
and the receiver is unchanged.
SetUniformBytes can be used to set s to a uniformly distributed value given
64 uniformly distributed random bytes.</p>
               
               <pre><code>func (s *Scalar) SetUniformBytes(x []byte) (*Scalar, error)</code></pre>
            </article>
            
            <article class="function" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *projP1xP1) Sub(p *Point, q *projCached) *projP1xP1</code></pre>
            </article>
            
            <article class="function" data-name="SubAffine">
               <h3>
                  SubAffine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *projP1xP1) SubAffine(p *Point, q *affineCached) *projP1xP1</code></pre>
            </article>
            
            <article class="function" data-name="Subtract">
               <h3>
                  Subtract 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Subtract sets v = p - q, and returns v.</p>
               
               <pre><code>func (v *Point) Subtract(p *Point, q *Point) *Point</code></pre>
            </article>
            
            <article class="function" data-name="Subtract">
               <h3>
                  Subtract 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Subtract sets s = x - y mod l, and returns s.</p>
               
               <pre><code>func (s *Scalar) Subtract(x *Scalar, y *Scalar) *Scalar</code></pre>
            </article>
            
            <article class="function" data-name="VarTimeDoubleScalarBaseMult">
               <h3>
                  VarTimeDoubleScalarBaseMult 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>VarTimeDoubleScalarBaseMult sets v = a * A + b * B, where B is the canonical
generator, and returns v.
Execution time depends on the inputs.</p>
               
               <pre><code>func (v *Point) VarTimeDoubleScalarBaseMult(a *Scalar, A *Point, b *Scalar) *Point</code></pre>
            </article>
            
            <article class="function" data-name="Zero">
               <h3>
                  Zero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *projP2) Zero() *projP2</code></pre>
            </article>
            
            <article class="function" data-name="Zero">
               <h3>
                  Zero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *projCached) Zero() *projCached</code></pre>
            </article>
            
            <article class="function" data-name="Zero">
               <h3>
                  Zero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *affineCached) Zero() *affineCached</code></pre>
            </article>
            
            <article class="function" data-name="basepointNafTable">
               <h3>
                  basepointNafTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>basepointNafTable is the nafLookupTable8 for the basepoint.
It is precomputed the first time it's used.</p>
               
               <pre><code>func basepointNafTable() *nafLookupTable8</code></pre>
            </article>
            
            <article class="function" data-name="basepointTable">
               <h3>
                  basepointTable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>basepointTable is a set of 32 affineLookupTables, where table i is generated
from 256i * basepoint. It is precomputed the first time it's used.</p>
               
               <pre><code>func basepointTable() *[32]affineLookupTable</code></pre>
            </article>
            
            <article class="function" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *Point) bytes(buf *[32]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="bytes">
               <h3>
                  bytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Scalar) bytes(out *[32]byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="checkInitialized">
               <h3>
                  checkInitialized 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkInitialized(points ...*Point)</code></pre>
            </article>
            
            <article class="function" data-name="copyFieldElement">
               <h3>
                  copyFieldElement 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func copyFieldElement(buf *[32]byte, v *field.Element) []byte</code></pre>
            </article>
            
            <article class="function" data-name="fiatScalarAdd">
               <h3>
                  fiatScalarAdd 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fiatScalarAdd adds two field elements in the Montgomery domain.
Preconditions:
0 ≤ eval arg1 < m
0 ≤ eval arg2 < m
Postconditions:
eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) + eval (from_montgomery arg2)) mod m
0 ≤ eval out1 < m</p>
               
               <pre><code>func fiatScalarAdd(out1 *fiatScalarMontgomeryDomainFieldElement, arg1 *fiatScalarMontgomeryDomainFieldElement, arg2 *fiatScalarMontgomeryDomainFieldElement)</code></pre>
            </article>
            
            <article class="function" data-name="fiatScalarCmovznzU64">
               <h3>
                  fiatScalarCmovznzU64 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fiatScalarCmovznzU64 is a single-word conditional move.
Postconditions:
out1 = (if arg1 = 0 then arg2 else arg3)
Input Bounds:
arg1: [0x0 ~> 0x1]
arg2: [0x0 ~> 0xffffffffffffffff]
arg3: [0x0 ~> 0xffffffffffffffff]
Output Bounds:
out1: [0x0 ~> 0xffffffffffffffff]</p>
               
               <pre><code>func fiatScalarCmovznzU64(out1 *uint64, arg1 fiatScalarUint1, arg2 uint64, arg3 uint64)</code></pre>
            </article>
            
            <article class="function" data-name="fiatScalarFromBytes">
               <h3>
                  fiatScalarFromBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fiatScalarFromBytes deserializes a field element NOT in the Montgomery domain from bytes in little-endian order.
Preconditions:
0 ≤ bytes_eval arg1 < m
Postconditions:
eval out1 mod m = bytes_eval arg1 mod m
0 ≤ eval out1 < m
Input Bounds:
arg1: [[0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0x1f]]
Output Bounds:
out1: [[0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0x1fffffffffffffff]]</p>
               
               <pre><code>func fiatScalarFromBytes(out1 *[4]uint64, arg1 *[32]uint8)</code></pre>
            </article>
            
            <article class="function" data-name="fiatScalarFromMontgomery">
               <h3>
                  fiatScalarFromMontgomery 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fiatScalarFromMontgomery translates a field element out of the Montgomery domain.
Preconditions:
0 ≤ eval arg1 < m
Postconditions:
eval out1 mod m = (eval arg1 * ((2^64)⁻¹ mod m)^4) mod m
0 ≤ eval out1 < m</p>
               
               <pre><code>func fiatScalarFromMontgomery(out1 *fiatScalarNonMontgomeryDomainFieldElement, arg1 *fiatScalarMontgomeryDomainFieldElement)</code></pre>
            </article>
            
            <article class="function" data-name="fiatScalarMul">
               <h3>
                  fiatScalarMul 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fiatScalarMul multiplies two field elements in the Montgomery domain.
Preconditions:
0 ≤ eval arg1 < m
0 ≤ eval arg2 < m
Postconditions:
eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg2)) mod m
0 ≤ eval out1 < m</p>
               
               <pre><code>func fiatScalarMul(out1 *fiatScalarMontgomeryDomainFieldElement, arg1 *fiatScalarMontgomeryDomainFieldElement, arg2 *fiatScalarMontgomeryDomainFieldElement)</code></pre>
            </article>
            
            <article class="function" data-name="fiatScalarNonzero">
               <h3>
                  fiatScalarNonzero 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fiatScalarNonzero outputs a single non-zero word if the input is non-zero and zero otherwise.
Preconditions:
0 ≤ eval arg1 < m
Postconditions:
out1 = 0 ↔ eval (from_montgomery arg1) mod m = 0
Input Bounds:
arg1: [[0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff]]
Output Bounds:
out1: [0x0 ~> 0xffffffffffffffff]</p>
               
               <pre><code>func fiatScalarNonzero(out1 *uint64, arg1 *[4]uint64)</code></pre>
            </article>
            
            <article class="function" data-name="fiatScalarOpp">
               <h3>
                  fiatScalarOpp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fiatScalarOpp negates a field element in the Montgomery domain.
Preconditions:
0 ≤ eval arg1 < m
Postconditions:
eval (from_montgomery out1) mod m = -eval (from_montgomery arg1) mod m
0 ≤ eval out1 < m</p>
               
               <pre><code>func fiatScalarOpp(out1 *fiatScalarMontgomeryDomainFieldElement, arg1 *fiatScalarMontgomeryDomainFieldElement)</code></pre>
            </article>
            
            <article class="function" data-name="fiatScalarSub">
               <h3>
                  fiatScalarSub 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fiatScalarSub subtracts two field elements in the Montgomery domain.
Preconditions:
0 ≤ eval arg1 < m
0 ≤ eval arg2 < m
Postconditions:
eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) - eval (from_montgomery arg2)) mod m
0 ≤ eval out1 < m</p>
               
               <pre><code>func fiatScalarSub(out1 *fiatScalarMontgomeryDomainFieldElement, arg1 *fiatScalarMontgomeryDomainFieldElement, arg2 *fiatScalarMontgomeryDomainFieldElement)</code></pre>
            </article>
            
            <article class="function" data-name="fiatScalarToBytes">
               <h3>
                  fiatScalarToBytes 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fiatScalarToBytes serializes a field element NOT in the Montgomery domain to bytes in little-endian order.
Preconditions:
0 ≤ eval arg1 < m
Postconditions:
out1 = map (λ x, ⌊((eval arg1 mod m) mod 2^(8 * (x + 1))) / 2^(8 * x)⌋) [0..31]
Input Bounds:
arg1: [[0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0x1fffffffffffffff]]
Output Bounds:
out1: [[0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0x1f]]</p>
               
               <pre><code>func fiatScalarToBytes(out1 *[32]uint8, arg1 *[4]uint64)</code></pre>
            </article>
            
            <article class="function" data-name="fiatScalarToMontgomery">
               <h3>
                  fiatScalarToMontgomery 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fiatScalarToMontgomery translates a field element into the Montgomery domain.
Preconditions:
0 ≤ eval arg1 < m
Postconditions:
eval (from_montgomery out1) mod m = eval arg1 mod m
0 ≤ eval out1 < m</p>
               
               <pre><code>func fiatScalarToMontgomery(out1 *fiatScalarMontgomeryDomainFieldElement, arg1 *fiatScalarNonMontgomeryDomainFieldElement)</code></pre>
            </article>
            
            <article class="function" data-name="fromP1xP1">
               <h3>
                  fromP1xP1 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *Point) fromP1xP1(p *projP1xP1) *Point</code></pre>
            </article>
            
            <article class="function" data-name="fromP2">
               <h3>
                  fromP2 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *Point) fromP2(p *projP2) *Point</code></pre>
            </article>
            
            <article class="function" data-name="isReduced">
               <h3>
                  isReduced 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isReduced returns whether the given scalar in 32-byte little endian encoded
form is reduced modulo l.</p>
               
               <pre><code>func isReduced(s []byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="nonAdjacentForm">
               <h3>
                  nonAdjacentForm 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>nonAdjacentForm computes a width-w non-adjacent form for this scalar.
w must be between 2 and 8, or nonAdjacentForm will panic.</p>
               
               <pre><code>func (s *Scalar) nonAdjacentForm(w uint) [256]int8</code></pre>
            </article>
            
            <article class="function" data-name="setShortBytes">
               <h3>
                  setShortBytes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setShortBytes sets s = x mod l, where x is a little-endian integer shorter
than 32 bytes.</p>
               
               <pre><code>func (s *Scalar) setShortBytes(x []byte) *Scalar</code></pre>
            </article>
            
            <article class="function" data-name="signedRadix16">
               <h3>
                  signedRadix16 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *Scalar) signedRadix16() [64]int8</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
