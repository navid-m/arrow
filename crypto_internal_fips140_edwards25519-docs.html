<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - edwards25519</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="crypto_internal_fips140_edwards25519_field-docs.html">field</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>edwards25519</code>
         </h1>
         <hr />
         
         <article class="global" data-name="scOneBytes">
            <h2>scOneBytes</h2>
            <hr />
            
            <pre><code>scOneBytes</code></pre>
         </article>
         
         <article class="global" data-name="scOne">
            <h2>scOne</h2>
            <hr />
            
            <pre><code>scOne</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="scMinusOne">
            <h2>scMinusOne</h2>
            <hr />
            
            <pre><code>scMinusOne</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="scalarTwo168">
            <h2>scalarTwo168</h2>
            <hr />
            
            <p>scalarTwo168 and scalarTwo336 are 2^168 and 2^336 modulo l, encoded as a
fiatScalarMontgomeryDomainFieldElement, which is a little-endian 4-limb value
in the 2^256 Montgomery domain.</p>
            
            <pre><code>scalarTwo168</code></pre>
         </article>
         
         <article class="global" data-name="scalarTwo336">
            <h2>scalarTwo336</h2>
            <hr />
            
            <pre><code>scalarTwo336</code></pre>
         </article>
         
         <article class="global" data-name="scalarMinusOneBytes">
            <h2>scalarMinusOneBytes</h2>
            <hr />
            
            <p>scalarMinusOneBytes is l - 1 in little endian.</p>
            
            <pre><code>scalarMinusOneBytes</code></pre>
         </article>
         
         <article class="global" data-name="basepointTablePrecomp">
            <h2>basepointTablePrecomp</h2>
            <hr />
            
            <pre><code>basepointTablePrecomp *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="basepointNafTablePrecomp">
            <h2>basepointNafTablePrecomp</h2>
            <hr />
            
            <pre><code>basepointNafTablePrecomp *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="dalekScalar">
            <h2>dalekScalar</h2>
            <hr />
            
            <p>a random scalar generated using dalek.</p>
            
            <pre><code>dalekScalar</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>a random scalar generated using dalek.</p>
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="dalekScalarBasepoint">
            <h2>dalekScalarBasepoint</h2>
            <hr />
            
            <p>the above, times the edwards25519 basepoint.</p>
            
            <pre><code>dalekScalarBasepoint</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>the above, times the edwards25519 basepoint.</p>
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="identity">
            <h2>identity</h2>
            <hr />
            
            <p>identity is the point at infinity.</p>
            
            <pre><code>identity</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>identity is the point at infinity.</p>
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="generator">
            <h2>generator</h2>
            <hr />
            
            <p>generator is the canonical curve basepoint. See TestGenerator for the
correspondence of this encoding with the values in RFC 8032.</p>
            
            <pre><code>generator</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>generator is the canonical curve basepoint. See TestGenerator for the
correspondence of this encoding with the values in RFC 8032.</p>
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="feOne">
            <h2>feOne</h2>
            <hr />
            
            <pre><code>feOne</code></pre>
         </article>
         
         <article class="global" data-name="d">
            <h2>d</h2>
            <hr />
            
            <p>d is a constant in the curve equation.</p>
            
            <pre><code>d</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>d is a constant in the curve equation.</p>
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="d2">
            <h2>d2</h2>
            <hr />
            
            <pre><code>d2</code></pre>
         </article>
         
         <article class="global" data-name="B">
            <h2>B</h2>
            <hr />
            
            <pre><code>B</code></pre>
         </article>
         
         <article class="global" data-name="I">
            <h2>I</h2>
            <hr />
            
            <pre><code>I</code></pre>
         </article>
          
         <article class="struct" data-name="Scalar">
            <h2>type Scalar struct</h2>
            <hr />
            
            <p>A Scalar is an integer modulo

	l = 2^252 + 27742317777372353535851937790883648493

which is the prime order of the edwards25519 group.

This type works similarly to math/big.Int, and all arguments and
receivers are allowed to alias.

The zero value is a valid zero element.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">s fiatScalarMontgomeryDomainFieldElement</code></pre>
         </article>
         
         <article class="struct" data-name="projLookupTable">
            <h2>type projLookupTable struct</h2>
            <hr />
            
            <p>A dynamic lookup table for variable-base, constant-time scalar muls.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">points []projCached</code></pre>
         </article>
         
         <article class="struct" data-name="affineLookupTable">
            <h2>type affineLookupTable struct</h2>
            <hr />
            
            <p>A precomputed lookup table for fixed-base, constant-time scalar muls.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">points []affineCached</code></pre>
         </article>
         
         <article class="struct" data-name="nafLookupTable5">
            <h2>type nafLookupTable5 struct</h2>
            <hr />
            
            <p>A dynamic lookup table for variable-base, variable-time scalar muls.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">points []projCached</code></pre>
         </article>
         
         <article class="struct" data-name="nafLookupTable8">
            <h2>type nafLookupTable8 struct</h2>
            <hr />
            
            <p>A precomputed lookup table for fixed-base, variable-time scalar muls.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">points []affineCached</code></pre>
         </article>
         
         <article class="struct" data-name="projP1xP1">
            <h2>type projP1xP1 struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">X field.Element
Y field.Element
Z field.Element
T field.Element</code></pre>
         </article>
         
         <article class="struct" data-name="projP2">
            <h2>type projP2 struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">X field.Element
Y field.Element
Z field.Element</code></pre>
         </article>
         
         <article class="struct" data-name="Point">
            <h2>type Point struct</h2>
            <hr />
            
            <p>Point represents a point on the edwards25519 curve.

This type works similarly to math/big.Int, and all arguments and receivers
are allowed to alias.

The zero value is NOT valid, and it may be used only as a receiver.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">_ incomparable
x field.Element
y field.Element
z field.Element
t field.Element</code></pre>
         </article>
         
         <article class="struct" data-name="projCached">
            <h2>type projCached struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">YplusX field.Element
YminusX field.Element
Z field.Element
T2d field.Element</code></pre>
         </article>
         
         <article class="struct" data-name="affineCached">
            <h2>type affineCached struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">YplusX field.Element
YminusX field.Element
T2d field.Element</code></pre>
         </article>
          
         <article class="function" data-name="fiatScalarCmovznzU64">
            <h2>fiatScalarCmovznzU64</h2>
            <hr />
            
            <p>fiatScalarCmovznzU64 is a single-word conditional move.

Postconditions:

	out1 = (if arg1 = 0 then arg2 else arg3)

Input Bounds:

	arg1: [0x0 ~> 0x1]
	arg2: [0x0 ~> 0xffffffffffffffff]
	arg3: [0x0 ~> 0xffffffffffffffff]

Output Bounds:

	out1: [0x0 ~> 0xffffffffffffffff]</p>
            
            <pre><code>func fiatScalarCmovznzU64(out1 *uint64, arg1 fiatScalarUint1, arg2 uint64, arg3 uint64)</code></pre>
         </article>
         
         <article class="function" data-name="fiatScalarMul">
            <h2>fiatScalarMul</h2>
            <hr />
            
            <p>fiatScalarMul multiplies two field elements in the Montgomery domain.

Preconditions:

	0 ≤ eval arg1 < m
	0 ≤ eval arg2 < m

Postconditions:

	eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg2)) mod m
	0 ≤ eval out1 < m</p>
            
            <pre><code>func fiatScalarMul(out1 *fiatScalarMontgomeryDomainFieldElement, arg1 *fiatScalarMontgomeryDomainFieldElement, arg2 *fiatScalarMontgomeryDomainFieldElement)</code></pre>
         </article>
         
         <article class="function" data-name="fiatScalarAdd">
            <h2>fiatScalarAdd</h2>
            <hr />
            
            <p>fiatScalarAdd adds two field elements in the Montgomery domain.

Preconditions:

	0 ≤ eval arg1 < m
	0 ≤ eval arg2 < m

Postconditions:

	eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) + eval (from_montgomery arg2)) mod m
	0 ≤ eval out1 < m</p>
            
            <pre><code>func fiatScalarAdd(out1 *fiatScalarMontgomeryDomainFieldElement, arg1 *fiatScalarMontgomeryDomainFieldElement, arg2 *fiatScalarMontgomeryDomainFieldElement)</code></pre>
         </article>
         
         <article class="function" data-name="fiatScalarSub">
            <h2>fiatScalarSub</h2>
            <hr />
            
            <p>fiatScalarSub subtracts two field elements in the Montgomery domain.

Preconditions:

	0 ≤ eval arg1 < m
	0 ≤ eval arg2 < m

Postconditions:

	eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) - eval (from_montgomery arg2)) mod m
	0 ≤ eval out1 < m</p>
            
            <pre><code>func fiatScalarSub(out1 *fiatScalarMontgomeryDomainFieldElement, arg1 *fiatScalarMontgomeryDomainFieldElement, arg2 *fiatScalarMontgomeryDomainFieldElement)</code></pre>
         </article>
         
         <article class="function" data-name="fiatScalarOpp">
            <h2>fiatScalarOpp</h2>
            <hr />
            
            <p>fiatScalarOpp negates a field element in the Montgomery domain.

Preconditions:

	0 ≤ eval arg1 < m

Postconditions:

	eval (from_montgomery out1) mod m = -eval (from_montgomery arg1) mod m
	0 ≤ eval out1 < m</p>
            
            <pre><code>func fiatScalarOpp(out1 *fiatScalarMontgomeryDomainFieldElement, arg1 *fiatScalarMontgomeryDomainFieldElement)</code></pre>
         </article>
         
         <article class="function" data-name="fiatScalarNonzero">
            <h2>fiatScalarNonzero</h2>
            <hr />
            
            <p>fiatScalarNonzero outputs a single non-zero word if the input is non-zero and zero otherwise.

Preconditions:

	0 ≤ eval arg1 < m

Postconditions:

	out1 = 0 ↔ eval (from_montgomery arg1) mod m = 0

Input Bounds:

	arg1: [[0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff]]

Output Bounds:

	out1: [0x0 ~> 0xffffffffffffffff]</p>
            
            <pre><code>func fiatScalarNonzero(out1 *uint64, arg1 *[]uint64)</code></pre>
         </article>
         
         <article class="function" data-name="fiatScalarFromMontgomery">
            <h2>fiatScalarFromMontgomery</h2>
            <hr />
            
            <p>fiatScalarFromMontgomery translates a field element out of the Montgomery domain.

Preconditions:

	0 ≤ eval arg1 < m

Postconditions:

	eval out1 mod m = (eval arg1 * ((2^64)⁻¹ mod m)^4) mod m
	0 ≤ eval out1 < m</p>
            
            <pre><code>func fiatScalarFromMontgomery(out1 *fiatScalarNonMontgomeryDomainFieldElement, arg1 *fiatScalarMontgomeryDomainFieldElement)</code></pre>
         </article>
         
         <article class="function" data-name="fiatScalarToMontgomery">
            <h2>fiatScalarToMontgomery</h2>
            <hr />
            
            <p>fiatScalarToMontgomery translates a field element into the Montgomery domain.

Preconditions:

	0 ≤ eval arg1 < m

Postconditions:

	eval (from_montgomery out1) mod m = eval arg1 mod m
	0 ≤ eval out1 < m</p>
            
            <pre><code>func fiatScalarToMontgomery(out1 *fiatScalarMontgomeryDomainFieldElement, arg1 *fiatScalarNonMontgomeryDomainFieldElement)</code></pre>
         </article>
         
         <article class="function" data-name="fiatScalarToBytes">
            <h2>fiatScalarToBytes</h2>
            <hr />
            
            <p>fiatScalarToBytes serializes a field element NOT in the Montgomery domain to bytes in little-endian order.

Preconditions:

	0 ≤ eval arg1 < m

Postconditions:

	out1 = map (λ x, ⌊((eval arg1 mod m) mod 2^(8 * (x + 1))) / 2^(8 * x)⌋) [0..31]

Input Bounds:

	arg1: [[0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0x1fffffffffffffff]]

Output Bounds:

	out1: [[0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0x1f]]</p>
            
            <pre><code>func fiatScalarToBytes(out1 *[]uint8, arg1 *[]uint64)</code></pre>
         </article>
         
         <article class="function" data-name="fiatScalarFromBytes">
            <h2>fiatScalarFromBytes</h2>
            <hr />
            
            <p>fiatScalarFromBytes deserializes a field element NOT in the Montgomery domain from bytes in little-endian order.

Preconditions:

	0 ≤ bytes_eval arg1 < m

Postconditions:

	eval out1 mod m = bytes_eval arg1 mod m
	0 ≤ eval out1 < m

Input Bounds:

	arg1: [[0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0xff], [0x0 ~> 0x1f]]

Output Bounds:

	out1: [[0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0xffffffffffffffff], [0x0 ~> 0x1fffffffffffffff]]</p>
            
            <pre><code>func fiatScalarFromBytes(out1 *[]uint64, arg1 *[]uint8)</code></pre>
         </article>
         
         <article class="function" data-name="quickCheckConfig">
            <h2>quickCheckConfig</h2>
            <hr />
            
            <p>quickCheckConfig returns a quick.Config that scales the max count by the
given factor if the -short flag is not set.</p>
            
            <pre><code>func quickCheckConfig(slowScale int) *quick.Config</code></pre>
         </article>
         
         <article class="function" data-name="Generate">
            <h2>Generate</h2>
            <hr />
            
            <p>Generate returns a valid (reduced modulo l) Scalar with a distribution
weighted towards high, low, and edge values.</p>
            
            <pre><code>func Generate(rand *mathrand.Rand, size int) reflect.Value</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarGenerate">
            <h2>TestScalarGenerate</h2>
            <hr />
            
            <pre><code>func TestScalarGenerate(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarSetCanonicalBytes">
            <h2>TestScalarSetCanonicalBytes</h2>
            <hr />
            
            <pre><code>func TestScalarSetCanonicalBytes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarSetUniformBytes">
            <h2>TestScalarSetUniformBytes</h2>
            <hr />
            
            <pre><code>func TestScalarSetUniformBytes(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarSetBytesWithClamping">
            <h2>TestScalarSetBytesWithClamping</h2>
            <hr />
            
            <pre><code>func TestScalarSetBytesWithClamping(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="bigIntFromLittleEndianBytes">
            <h2>bigIntFromLittleEndianBytes</h2>
            <hr />
            
            <pre><code>func bigIntFromLittleEndianBytes(b []byte) *big.Int</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarMultiplyDistributesOverAdd">
            <h2>TestScalarMultiplyDistributesOverAdd</h2>
            <hr />
            
            <pre><code>func TestScalarMultiplyDistributesOverAdd(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarAddLikeSubNeg">
            <h2>TestScalarAddLikeSubNeg</h2>
            <hr />
            
            <pre><code>func TestScalarAddLikeSubNeg(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarNonAdjacentForm">
            <h2>TestScalarNonAdjacentForm</h2>
            <hr />
            
            <pre><code>func TestScalarNonAdjacentForm(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Generate">
            <h2>Generate</h2>
            <hr />
            
            <pre><code>func Generate(rand *mathrand.Rand, size int) reflect.Value</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarEqual">
            <h2>TestScalarEqual</h2>
            <hr />
            
            <pre><code>func TestScalarEqual(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="NewScalar">
            <h2>NewScalar</h2>
            <hr />
            
            <p>NewScalar returns a new zero Scalar.</p>
            
            <pre><code>func NewScalar() *Scalar</code></pre>
         </article>
         
         <article class="function" data-name="MultiplyAdd">
            <h2>MultiplyAdd</h2>
            <hr />
            
            <p>MultiplyAdd sets s = x * y + z mod l, and returns s. It is equivalent to
using Multiply and then Add.</p>
            
            <pre><code>func MultiplyAdd(x *Scalar, y *Scalar, z *Scalar) *Scalar</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add sets s = x + y mod l, and returns s.</p>
            
            <pre><code>func Add(x *Scalar, y *Scalar) *Scalar</code></pre>
         </article>
         
         <article class="function" data-name="Subtract">
            <h2>Subtract</h2>
            <hr />
            
            <p>Subtract sets s = x - y mod l, and returns s.</p>
            
            <pre><code>func Subtract(x *Scalar, y *Scalar) *Scalar</code></pre>
         </article>
         
         <article class="function" data-name="Negate">
            <h2>Negate</h2>
            <hr />
            
            <p>Negate sets s = -x mod l, and returns s.</p>
            
            <pre><code>func Negate(x *Scalar) *Scalar</code></pre>
         </article>
         
         <article class="function" data-name="Multiply">
            <h2>Multiply</h2>
            <hr />
            
            <p>Multiply sets s = x * y mod l, and returns s.</p>
            
            <pre><code>func Multiply(x *Scalar, y *Scalar) *Scalar</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>Set sets s = x, and returns s.</p>
            
            <pre><code>func Set(x *Scalar) *Scalar</code></pre>
         </article>
         
         <article class="function" data-name="SetUniformBytes">
            <h2>SetUniformBytes</h2>
            <hr />
            
            <p>SetUniformBytes sets s = x mod l, where x is a 64-byte little-endian integer.
If x is not of the right length, SetUniformBytes returns nil and an error,
and the receiver is unchanged.

SetUniformBytes can be used to set s to a uniformly distributed value given
64 uniformly distributed random bytes.</p>
            
            <pre><code>func SetUniformBytes(x []byte) (*Scalar, error)</code></pre>
         </article>
         
         <article class="function" data-name="setShortBytes">
            <h2>setShortBytes</h2>
            <hr />
            
            <p>setShortBytes sets s = x mod l, where x is a little-endian integer shorter
than 32 bytes.</p>
            
            <pre><code>func setShortBytes(x []byte) *Scalar</code></pre>
         </article>
         
         <article class="function" data-name="SetCanonicalBytes">
            <h2>SetCanonicalBytes</h2>
            <hr />
            
            <p>SetCanonicalBytes sets s = x, where x is a 32-byte little-endian encoding of
s, and returns s. If x is not a canonical encoding of s, SetCanonicalBytes
returns nil and an error, and the receiver is unchanged.</p>
            
            <pre><code>func SetCanonicalBytes(x []byte) (*Scalar, error)</code></pre>
         </article>
         
         <article class="function" data-name="isReduced">
            <h2>isReduced</h2>
            <hr />
            
            <p>isReduced returns whether the given scalar in 32-byte little endian encoded
form is reduced modulo l.</p>
            
            <pre><code>func isReduced(s []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="SetBytesWithClamping">
            <h2>SetBytesWithClamping</h2>
            <hr />
            
            <p>SetBytesWithClamping applies the buffer pruning described in RFC 8032,
Section 5.1.5 (also known as clamping) and sets s to the result. The input
must be 32 bytes, and it is not modified. If x is not of the right length,
SetBytesWithClamping returns nil and an error, and the receiver is unchanged.

Note that since Scalar values are always reduced modulo the prime order of
the curve, the resulting value will not preserve any of the cofactor-clearing
properties that clamping is meant to provide. It will however work as
expected as long as it is applied to points on the prime order subgroup, like
in Ed25519. In fact, it is lost to history why RFC 8032 adopted the
irrelevant RFC 7748 clamping, but it is now required for compatibility.</p>
            
            <pre><code>func SetBytesWithClamping(x []byte) (*Scalar, error)</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns the canonical 32-byte little-endian encoding of s.</p>
            
            <pre><code>func Bytes() []byte</code></pre>
         </article>
         
         <article class="function" data-name="bytes">
            <h2>bytes</h2>
            <hr />
            
            <pre><code>func bytes(out *[]byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Equal">
            <h2>Equal</h2>
            <hr />
            
            <p>Equal returns 1 if s and t are equal, and 0 otherwise.</p>
            
            <pre><code>func Equal(t *Scalar) int</code></pre>
         </article>
         
         <article class="function" data-name="nonAdjacentForm">
            <h2>nonAdjacentForm</h2>
            <hr />
            
            <p>nonAdjacentForm computes a width-w non-adjacent form for this scalar.

w must be between 2 and 8, or nonAdjacentForm will panic.</p>
            
            <pre><code>func nonAdjacentForm(w uint) []int8</code></pre>
         </article>
         
         <article class="function" data-name="signedRadix16">
            <h2>signedRadix16</h2>
            <hr />
            
            <pre><code>func signedRadix16() []int8</code></pre>
         </article>
         
         <article class="function" data-name="basepointTable">
            <h2>basepointTable</h2>
            <hr />
            
            <p>basepointTable is a set of 32 affineLookupTables, where table i is generated
from 256i * basepoint. It is precomputed the first time it's used.</p>
            
            <pre><code>func basepointTable() *[]affineLookupTable</code></pre>
         </article>
         
         <article class="function" data-name="ScalarBaseMult">
            <h2>ScalarBaseMult</h2>
            <hr />
            
            <p>ScalarBaseMult sets v = x * B, where B is the canonical generator, and
returns v.

The scalar multiplication is done in constant time.</p>
            
            <pre><code>func ScalarBaseMult(x *Scalar) *Point</code></pre>
         </article>
         
         <article class="function" data-name="ScalarMult">
            <h2>ScalarMult</h2>
            <hr />
            
            <p>ScalarMult sets v = x * q, and returns v.

The scalar multiplication is done in constant time.</p>
            
            <pre><code>func ScalarMult(x *Scalar, q *Point) *Point</code></pre>
         </article>
         
         <article class="function" data-name="basepointNafTable">
            <h2>basepointNafTable</h2>
            <hr />
            
            <p>basepointNafTable is the nafLookupTable8 for the basepoint.
It is precomputed the first time it's used.</p>
            
            <pre><code>func basepointNafTable() *nafLookupTable8</code></pre>
         </article>
         
         <article class="function" data-name="VarTimeDoubleScalarBaseMult">
            <h2>VarTimeDoubleScalarBaseMult</h2>
            <hr />
            
            <p>VarTimeDoubleScalarBaseMult sets v = a * A + b * B, where B is the canonical
generator, and returns v.

Execution time depends on the inputs.</p>
            
            <pre><code>func VarTimeDoubleScalarBaseMult(a *Scalar, A *Point, b *Scalar) *Point</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarMultSmallScalars">
            <h2>TestScalarMultSmallScalars</h2>
            <hr />
            
            <pre><code>func TestScalarMultSmallScalars(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarMultVsDalek">
            <h2>TestScalarMultVsDalek</h2>
            <hr />
            
            <pre><code>func TestScalarMultVsDalek(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBaseMultVsDalek">
            <h2>TestBaseMultVsDalek</h2>
            <hr />
            
            <pre><code>func TestBaseMultVsDalek(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestVarTimeDoubleBaseMultVsDalek">
            <h2>TestVarTimeDoubleBaseMultVsDalek</h2>
            <hr />
            
            <pre><code>func TestVarTimeDoubleBaseMultVsDalek(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarMultDistributesOverAdd">
            <h2>TestScalarMultDistributesOverAdd</h2>
            <hr />
            
            <pre><code>func TestScalarMultDistributesOverAdd(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarMultNonIdentityPoint">
            <h2>TestScalarMultNonIdentityPoint</h2>
            <hr />
            
            <pre><code>func TestScalarMultNonIdentityPoint(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBasepointTableGeneration">
            <h2>TestBasepointTableGeneration</h2>
            <hr />
            
            <pre><code>func TestBasepointTableGeneration(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarMultMatchesBaseMult">
            <h2>TestScalarMultMatchesBaseMult</h2>
            <hr />
            
            <pre><code>func TestScalarMultMatchesBaseMult(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBasepointNafTableGeneration">
            <h2>TestBasepointNafTableGeneration</h2>
            <hr />
            
            <pre><code>func TestBasepointNafTableGeneration(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestVarTimeDoubleBaseMultMatchesBaseMult">
            <h2>TestVarTimeDoubleBaseMultMatchesBaseMult</h2>
            <hr />
            
            <pre><code>func TestVarTimeDoubleBaseMultMatchesBaseMult(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkScalarBaseMult">
            <h2>BenchmarkScalarBaseMult</h2>
            <hr />
            
            <pre><code>func BenchmarkScalarBaseMult(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkScalarMult">
            <h2>BenchmarkScalarMult</h2>
            <hr />
            
            <pre><code>func BenchmarkScalarMult(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkVarTimeDoubleScalarBaseMult">
            <h2>BenchmarkVarTimeDoubleScalarBaseMult</h2>
            <hr />
            
            <pre><code>func BenchmarkVarTimeDoubleScalarBaseMult(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="FromP3">
            <h2>FromP3</h2>
            <hr />
            
            <p>Builds a lookup table at runtime. Fast.</p>
            
            <pre><code>func FromP3(q *Point)</code></pre>
         </article>
         
         <article class="function" data-name="FromP3">
            <h2>FromP3</h2>
            <hr />
            
            <p>This is not optimised for speed; fixed-base tables should be precomputed.</p>
            
            <pre><code>func FromP3(q *Point)</code></pre>
         </article>
         
         <article class="function" data-name="FromP3">
            <h2>FromP3</h2>
            <hr />
            
            <p>Builds a lookup table at runtime. Fast.</p>
            
            <pre><code>func FromP3(q *Point)</code></pre>
         </article>
         
         <article class="function" data-name="FromP3">
            <h2>FromP3</h2>
            <hr />
            
            <p>This is not optimised for speed; fixed-base tables should be precomputed.</p>
            
            <pre><code>func FromP3(q *Point)</code></pre>
         </article>
         
         <article class="function" data-name="SelectInto">
            <h2>SelectInto</h2>
            <hr />
            
            <p>Set dest to x*Q, where -8 <= x <= 8, in constant time.</p>
            
            <pre><code>func SelectInto(dest *projCached, x int8)</code></pre>
         </article>
         
         <article class="function" data-name="SelectInto">
            <h2>SelectInto</h2>
            <hr />
            
            <p>Set dest to x*Q, where -8 <= x <= 8, in constant time.</p>
            
            <pre><code>func SelectInto(dest *affineCached, x int8)</code></pre>
         </article>
         
         <article class="function" data-name="SelectInto">
            <h2>SelectInto</h2>
            <hr />
            
            <p>Given odd x with 0 < x < 2^4, return x*Q (in variable time).</p>
            
            <pre><code>func SelectInto(dest *projCached, x int8)</code></pre>
         </article>
         
         <article class="function" data-name="SelectInto">
            <h2>SelectInto</h2>
            <hr />
            
            <p>Given odd x with 0 < x < 2^7, return x*Q (in variable time).</p>
            
            <pre><code>func SelectInto(dest *affineCached, x int8)</code></pre>
         </article>
         
         <article class="function" data-name="TestProjLookupTable">
            <h2>TestProjLookupTable</h2>
            <hr />
            
            <pre><code>func TestProjLookupTable(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAffineLookupTable">
            <h2>TestAffineLookupTable</h2>
            <hr />
            
            <pre><code>func TestAffineLookupTable(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNafLookupTable5">
            <h2>TestNafLookupTable5</h2>
            <hr />
            
            <pre><code>func TestNafLookupTable5(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNafLookupTable8">
            <h2>TestNafLookupTable8</h2>
            <hr />
            
            <pre><code>func TestNafLookupTable8(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="checkInitialized">
            <h2>checkInitialized</h2>
            <hr />
            
            <pre><code>func checkInitialized(points ...*Point)</code></pre>
         </article>
         
         <article class="function" data-name="Zero">
            <h2>Zero</h2>
            <hr />
            
            <pre><code>func Zero() *projP2</code></pre>
         </article>
         
         <article class="function" data-name="NewIdentityPoint">
            <h2>NewIdentityPoint</h2>
            <hr />
            
            <p>NewIdentityPoint returns a new Point set to the identity.</p>
            
            <pre><code>func NewIdentityPoint() *Point</code></pre>
         </article>
         
         <article class="function" data-name="NewGeneratorPoint">
            <h2>NewGeneratorPoint</h2>
            <hr />
            
            <p>NewGeneratorPoint returns a new Point set to the canonical generator.</p>
            
            <pre><code>func NewGeneratorPoint() *Point</code></pre>
         </article>
         
         <article class="function" data-name="Zero">
            <h2>Zero</h2>
            <hr />
            
            <pre><code>func Zero() *projCached</code></pre>
         </article>
         
         <article class="function" data-name="Zero">
            <h2>Zero</h2>
            <hr />
            
            <pre><code>func Zero() *affineCached</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>Set sets v = u, and returns v.</p>
            
            <pre><code>func Set(u *Point) *Point</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <p>Bytes returns the canonical 32-byte encoding of v, according to RFC 8032,
Section 5.1.2.</p>
            
            <pre><code>func Bytes() []byte</code></pre>
         </article>
         
         <article class="function" data-name="bytes">
            <h2>bytes</h2>
            <hr />
            
            <pre><code>func bytes(buf *[]byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="SetBytes">
            <h2>SetBytes</h2>
            <hr />
            
            <p>SetBytes sets v = x, where x is a 32-byte encoding of v. If x does not
represent a valid point on the curve, SetBytes returns nil and an error and
the receiver is unchanged. Otherwise, SetBytes returns v.

Note that SetBytes accepts all non-canonical encodings of valid points.
That is, it follows decoding rules that match most implementations in
the ecosystem rather than RFC 8032.</p>
            
            <pre><code>func SetBytes(x []byte) (*Point, error)</code></pre>
         </article>
         
         <article class="function" data-name="copyFieldElement">
            <h2>copyFieldElement</h2>
            <hr />
            
            <pre><code>func copyFieldElement(buf *[]byte, v *field.Element) []byte</code></pre>
         </article>
         
         <article class="function" data-name="FromP1xP1">
            <h2>FromP1xP1</h2>
            <hr />
            
            <pre><code>func FromP1xP1(p *projP1xP1) *projP2</code></pre>
         </article>
         
         <article class="function" data-name="FromP3">
            <h2>FromP3</h2>
            <hr />
            
            <pre><code>func FromP3(p *Point) *projP2</code></pre>
         </article>
         
         <article class="function" data-name="fromP1xP1">
            <h2>fromP1xP1</h2>
            <hr />
            
            <pre><code>func fromP1xP1(p *projP1xP1) *Point</code></pre>
         </article>
         
         <article class="function" data-name="fromP2">
            <h2>fromP2</h2>
            <hr />
            
            <pre><code>func fromP2(p *projP2) *Point</code></pre>
         </article>
         
         <article class="function" data-name="FromP3">
            <h2>FromP3</h2>
            <hr />
            
            <pre><code>func FromP3(p *Point) *projCached</code></pre>
         </article>
         
         <article class="function" data-name="FromP3">
            <h2>FromP3</h2>
            <hr />
            
            <pre><code>func FromP3(p *Point) *affineCached</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add sets v = p + q, and returns v.</p>
            
            <pre><code>func Add(p *Point, q *Point) *Point</code></pre>
         </article>
         
         <article class="function" data-name="Subtract">
            <h2>Subtract</h2>
            <hr />
            
            <p>Subtract sets v = p - q, and returns v.</p>
            
            <pre><code>func Subtract(p *Point, q *Point) *Point</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <pre><code>func Add(p *Point, q *projCached) *projP1xP1</code></pre>
         </article>
         
         <article class="function" data-name="Sub">
            <h2>Sub</h2>
            <hr />
            
            <pre><code>func Sub(p *Point, q *projCached) *projP1xP1</code></pre>
         </article>
         
         <article class="function" data-name="AddAffine">
            <h2>AddAffine</h2>
            <hr />
            
            <pre><code>func AddAffine(p *Point, q *affineCached) *projP1xP1</code></pre>
         </article>
         
         <article class="function" data-name="SubAffine">
            <h2>SubAffine</h2>
            <hr />
            
            <pre><code>func SubAffine(p *Point, q *affineCached) *projP1xP1</code></pre>
         </article>
         
         <article class="function" data-name="Double">
            <h2>Double</h2>
            <hr />
            
            <pre><code>func Double(p *projP2) *projP1xP1</code></pre>
         </article>
         
         <article class="function" data-name="Negate">
            <h2>Negate</h2>
            <hr />
            
            <p>Negate sets v = -p, and returns v.</p>
            
            <pre><code>func Negate(p *Point) *Point</code></pre>
         </article>
         
         <article class="function" data-name="Equal">
            <h2>Equal</h2>
            <hr />
            
            <p>Equal returns 1 if v is equivalent to u, and 0 otherwise.</p>
            
            <pre><code>func Equal(u *Point) int</code></pre>
         </article>
         
         <article class="function" data-name="Select">
            <h2>Select</h2>
            <hr />
            
            <p>Select sets v to a if cond == 1 and to b if cond == 0.</p>
            
            <pre><code>func Select(a *projCached, b *projCached, cond int) *projCached</code></pre>
         </article>
         
         <article class="function" data-name="Select">
            <h2>Select</h2>
            <hr />
            
            <p>Select sets v to a if cond == 1 and to b if cond == 0.</p>
            
            <pre><code>func Select(a *affineCached, b *affineCached, cond int) *affineCached</code></pre>
         </article>
         
         <article class="function" data-name="CondNeg">
            <h2>CondNeg</h2>
            <hr />
            
            <p>CondNeg negates v if cond == 1 and leaves it unchanged if cond == 0.</p>
            
            <pre><code>func CondNeg(cond int) *projCached</code></pre>
         </article>
         
         <article class="function" data-name="CondNeg">
            <h2>CondNeg</h2>
            <hr />
            
            <p>CondNeg negates v if cond == 1 and leaves it unchanged if cond == 0.</p>
            
            <pre><code>func CondNeg(cond int) *affineCached</code></pre>
         </article>
         
         <article class="function" data-name="checkOnCurve">
            <h2>checkOnCurve</h2>
            <hr />
            
            <pre><code>func checkOnCurve(t *testing.T, points ...*Point)</code></pre>
         </article>
         
         <article class="function" data-name="TestGenerator">
            <h2>TestGenerator</h2>
            <hr />
            
            <pre><code>func TestGenerator(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestAddSubNegOnBasePoint">
            <h2>TestAddSubNegOnBasePoint</h2>
            <hr />
            
            <pre><code>func TestAddSubNegOnBasePoint(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestComparable">
            <h2>TestComparable</h2>
            <hr />
            
            <pre><code>func TestComparable(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestInvalidEncodings">
            <h2>TestInvalidEncodings</h2>
            <hr />
            
            <pre><code>func TestInvalidEncodings(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestNonCanonicalPoints">
            <h2>TestNonCanonicalPoints</h2>
            <hr />
            
            <pre><code>func TestNonCanonicalPoints(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="decodeHex">
            <h2>decodeHex</h2>
            <hr />
            
            <pre><code>func decodeHex(s string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEncodingDecoding">
            <h2>BenchmarkEncodingDecoding</h2>
            <hr />
            
            <pre><code>func BenchmarkEncodingDecoding(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestScalarAliasing">
            <h2>TestScalarAliasing</h2>
            <hr />
            
            <pre><code>func TestScalarAliasing(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
