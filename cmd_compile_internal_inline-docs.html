<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - inline</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="cmd_compile_internal_inline_inlheur-docs.html">inlheur</a></li>
               
               <li><a href="cmd_compile_internal_inline_interleaved-docs.html">interleaved</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>inline</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"fmt"
"go/constant"
"internal/buildcfg"
"strconv"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/inline/inlheur"
"cmd/compile/internal/ir"
"cmd/compile/internal/logopt"
"cmd/compile/internal/pgoir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/pgo"
"cmd/internal/src"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="InlineCall">
               <h3>
                  InlineCall 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>InlineCall allows the inliner implementation to be overridden.
If it returns nil, the function will not be inlined.</p>
               
               <pre><code>var InlineCall = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="SSADumpInline">
               <h3>
                  SSADumpInline 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>SSADumpInline gives the SSA back end a chance to dump the function
when producing output for debugging the compiler itself.</p>
               
               <pre><code>var SSADumpInline = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="candHotCalleeMap">
               <h3>
                  candHotCalleeMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>List of all hot callee nodes.
TODO(prattmic): Make this non-global.</p>
               
               <pre><code>var candHotCalleeMap = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="candHotEdgeMap">
               <h3>
                  candHotEdgeMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>List of all hot call sites. CallSiteInfo.Callee is always nil.
TODO(prattmic): Make this non-global.</p>
               
               <pre><code>var candHotEdgeMap = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="hasHotCall">
               <h3>
                  hasHotCall 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Set of functions that contain hot call sites.</p>
               
               <pre><code>var hasHotCall = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="inlgen">
               <h3>
                  inlgen 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var inlgen int</code></pre>
            </article>
            
            <article class="global" data-name="inlineBigFunctionMaxCost">
               <h3>
                  inlineBigFunctionMaxCost 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineBigFunctionMaxCost = 20</code></pre>
            </article>
            
            <article class="global" data-name="inlineBigFunctionNodes">
               <h3>
                  inlineBigFunctionNodes 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineBigFunctionNodes = 5000</code></pre>
            </article>
            
            <article class="global" data-name="inlineCDFHotCallSiteThresholdPercent">
               <h3>
                  inlineCDFHotCallSiteThresholdPercent 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Threshold in CDF percentage for hot callsite inlining,
that is, for a threshold of X the hottest callsites that
make up the top X% of total edge weight will be
considered hot for inlining candidates.</p>
               
               <pre><code>var inlineCDFHotCallSiteThresholdPercent = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="inlineClosureCalledOnceCost">
               <h3>
                  inlineClosureCalledOnceCost 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineClosureCalledOnceCost = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="inlineExtraAppendCost">
               <h3>
                  inlineExtraAppendCost 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineExtraAppendCost = 0</code></pre>
            </article>
            
            <article class="global" data-name="inlineExtraCallCost">
               <h3>
                  inlineExtraCallCost 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>default is to inline if there's at most one call. -l=4 overrides this by using 1 instead.</p>
               
               <pre><code>const inlineExtraCallCost = 57</code></pre>
            </article>
            
            <article class="global" data-name="inlineExtraPanicCost">
               <h3>
                  inlineExtraPanicCost 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineExtraPanicCost = 1</code></pre>
            </article>
            
            <article class="global" data-name="inlineExtraThrowCost">
               <h3>
                  inlineExtraThrowCost 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineExtraThrowCost = inlineMaxBudget</code></pre>
            </article>
            
            <article class="global" data-name="inlineHotCallSiteThresholdPercent">
               <h3>
                  inlineHotCallSiteThresholdPercent 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Threshold in percentage for hot callsite inlining.</p>
               
               <pre><code>var inlineHotCallSiteThresholdPercent float64</code></pre>
            </article>
            
            <article class="global" data-name="inlineHotMaxBudget">
               <h3>
                  inlineHotMaxBudget 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Budget increased due to hotness.</p>
               
               <pre><code>var inlineHotMaxBudget int32 = 2000</code></pre>
            </article>
            
            <article class="global" data-name="inlineMaxBudget">
               <h3>
                  inlineMaxBudget 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineMaxBudget = 80</code></pre>
            </article>
            
            <article class="global" data-name="inlineParamCallCost">
               <h3>
                  inlineParamCallCost 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineParamCallCost = 17</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="hairyVisitor">
               <h3>
                  hairyVisitor
                  <span class="badge">struct</span>
               </h3>
               
               <p>hairyVisitor visits a function body to determine its inlining
hairiness and whether or not it can be inlined.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type hairyVisitor struct {
curFunc *ir.Func
isBigFunc bool
budget int32
maxBudget int32
reason string
extraCallCost int32
usedLocals ir.NameSet
do func(ir.Node) bool
profile *pgoir.Profile
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="CalleeEffects">
               <h3>
                  CalleeEffects 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CalleeEffects appends any side effects from evaluating callee to init.</p>
               
               <pre><code>func CalleeEffects(init *ir.Nodes, callee ir.Node)</code></pre>
            </article>
            
            <article class="function" data-name="CanInline">
               <h3>
                  CanInline 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CanInline determines whether fn is inlineable.
If so, CanInline saves copies of fn.Body and fn.Dcl in fn.Inl.
fn and fn.Body will already have been typechecked.</p>
               
               <pre><code>func CanInline(fn *ir.Func, profile *pgoir.Profile)</code></pre>
            </article>
            
            <article class="function" data-name="CanInlineFuncs">
               <h3>
                  CanInlineFuncs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CanInlineFuncs computes whether a batch of functions are inlinable.</p>
               
               <pre><code>func CanInlineFuncs(funcs []*ir.Func, profile *pgoir.Profile)</code></pre>
            </article>
            
            <article class="function" data-name="HasPgoHotInline">
               <h3>
                  HasPgoHotInline 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func HasPgoHotInline(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function" data-name="InlineCallTarget">
               <h3>
                  InlineCallTarget 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>InlineCallTarget returns the resolved-for-inlining target of a call.
It does not necessarily guarantee that the target can be inlined, though
obvious exclusions are applied.</p>
               
               <pre><code>func InlineCallTarget(callerfn *ir.Func, call *ir.CallExpr, profile *pgoir.Profile) *ir.Func</code></pre>
            </article>
            
            <article class="function" data-name="InlineImpossible">
               <h3>
                  InlineImpossible 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>InlineImpossible returns a non-empty reason string if fn is impossible to
inline regardless of cost or contents.</p>
               
               <pre><code>func InlineImpossible(fn *ir.Func) string</code></pre>
            </article>
            
            <article class="function" data-name="IsBigFunc">
               <h3>
                  IsBigFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsBigFunc reports whether fn is a "big" function.
Note: The criteria for "big" is heuristic and subject to change.</p>
               
               <pre><code>func IsBigFunc(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsPgoHotFunc">
               <h3>
                  IsPgoHotFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func IsPgoHotFunc(fn *ir.Func, profile *pgoir.Profile) bool</code></pre>
            </article>
            
            <article class="function" data-name="PGOInlinePrologue">
               <h3>
                  PGOInlinePrologue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>PGOInlinePrologue records the hot callsites from ir-graph.</p>
               
               <pre><code>func PGOInlinePrologue(p *pgoir.Profile)</code></pre>
            </article>
            
            <article class="function" data-name="PostProcessCallSites">
               <h3>
                  PostProcessCallSites 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func PostProcessCallSites(profile *pgoir.Profile)</code></pre>
            </article>
            
            <article class="function" data-name="TryInlineCall">
               <h3>
                  TryInlineCall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>TryInlineCall returns an inlined call expression for call, or nil
if inlining is not possible.</p>
               
               <pre><code>func TryInlineCall(callerfn *ir.Func, call *ir.CallExpr, bigCaller bool, profile *pgoir.Profile, closureCalledOnce bool) *ir.InlinedCallExpr</code></pre>
            </article>
            
            <article class="function" data-name="analyzeFuncProps">
               <h3>
                  analyzeFuncProps 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func analyzeFuncProps(fn *ir.Func, p *pgoir.Profile)</code></pre>
            </article>
            
            <article class="function" data-name="canDelayResults">
               <h3>
                  canDelayResults 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>canDelayResults reports whether inlined calls to fn can delay
declaring the result parameter until the "return" statement.</p>
               
               <pre><code>func canDelayResults(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function" data-name="canInlineCallExpr">
               <h3>
                  canInlineCallExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>canInlineCallExpr returns true if the call n from caller to callee
can be inlined, plus the score computed for the call expr in question,
and whether the callee is hot according to PGO.
bigCaller indicates that caller is a big function. log
indicates that the 'cannot inline' reason should be logged.
Preconditions: CanInline(callee) has already been called.</p>
               
               <pre><code>func canInlineCallExpr(callerfn *ir.Func, n *ir.CallExpr, callee *ir.Func, bigCaller bool, closureCalledOnce bool, log bool) (bool, int32, bool)</code></pre>
            </article>
            
            <article class="function" data-name="doList">
               <h3>
                  doList 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func doList(list []ir.Node, do func(ir.Node) bool) bool</code></pre>
            </article>
            
            <article class="function" data-name="doNode">
               <h3>
                  doNode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>doNode visits n and its children, updates the state in v, and returns true if
n makes the current function too hairy for inlining.</p>
               
               <pre><code>func (v *hairyVisitor) doNode(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="hotNodesFromCDF">
               <h3>
                  hotNodesFromCDF 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>hotNodesFromCDF computes an edge weight threshold and the list of hot
nodes that make up the given percentage of the CDF. The threshold, as
a percent, is the lower bound of weight for nodes to be considered hot
(currently only used in debug prints) (in case of equal weights,
comparing with the threshold may not accurately reflect which nodes are
considered hot).</p>
               
               <pre><code>func hotNodesFromCDF(p *pgoir.Profile) (float64, []pgo.NamedCallEdge)</code></pre>
            </article>
            
            <article class="function" data-name="inlCallee">
               <h3>
                  inlCallee 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>inlCallee takes a function-typed expression and returns the underlying function ONAME
that it refers to if statically known. Otherwise, it returns nil.
resolveOnly skips cost-based inlineability checks for closures; the result may not actually be inlineable.</p>
               
               <pre><code>func inlCallee(caller *ir.Func, fn ir.Node, profile *pgoir.Profile, resolveOnly bool) (res *ir.Func)</code></pre>
            </article>
            
            <article class="function" data-name="inlineBudget">
               <h3>
                  inlineBudget 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>inlineBudget determines the max budget for function 'fn' prior to
analyzing the hairiness of the body of 'fn'. We pass in the pgo
profile if available (which can change the budget), also a
'relaxed' flag, which expands the budget slightly to allow for the
possibility that a call to the function might have its score
adjusted downwards. If 'verbose' is set, then print a remark where
we boost the budget due to PGO.</p>
               
               <pre><code>func inlineBudget(fn *ir.Func, profile *pgoir.Profile, relaxed bool, verbose bool) int32</code></pre>
            </article>
            
            <article class="function" data-name="inlineCallCheck">
               <h3>
                  inlineCallCheck 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>inlineCallCheck returns whether a call will never be inlineable
for basic reasons, and whether the call is an intrinisic call.
The intrinsic result singles out intrinsic calls for debug logging.</p>
               
               <pre><code>func inlineCallCheck(callerfn *ir.Func, call *ir.CallExpr) (bool, bool)</code></pre>
            </article>
            
            <article class="function" data-name="inlineCostOK">
               <h3>
                  inlineCostOK 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>inlineCostOK returns true if call n from caller to callee is cheap enough to
inline. bigCaller indicates that caller is a big function.
In addition to the "cost OK" boolean, it also returns
- the "max cost" limit used to make the decision (which may differ depending on func size)
- the score assigned to this specific callsite
- whether the inlined function is "hot" according to PGO.</p>
               
               <pre><code>func inlineCostOK(n *ir.CallExpr, caller *ir.Func, callee *ir.Func, bigCaller bool, closureCalledOnce bool) (bool, int32, int32, bool)</code></pre>
            </article>
            
            <article class="function" data-name="isAtomicCoverageCounterUpdate">
               <h3>
                  isAtomicCoverageCounterUpdate 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isAtomicCoverageCounterUpdate examines the specified node to
determine whether it represents a call to sync/atomic.AddUint32 to
increment a coverage counter.</p>
               
               <pre><code>func isAtomicCoverageCounterUpdate(cn *ir.CallExpr) bool</code></pre>
            </article>
            
            <article class="function" data-name="isIndexingCoverageCounter">
               <h3>
                  isIndexingCoverageCounter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isIndexingCoverageCounter returns true if the specified node 'n' is indexing
into a coverage counter array.</p>
               
               <pre><code>func isIndexingCoverageCounter(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="mkinlcall">
               <h3>
                  mkinlcall 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>mkinlcall returns an OINLCALL node that can replace OCALLFUNC n, or
nil if it cannot be inlined. callerfn is the function that contains
n, and fn is the function being called.
The result of mkinlcall MUST be assigned back to n, e.g.
n.Left = mkinlcall(n.Left, fn, isddd)</p>
               
               <pre><code>func mkinlcall(callerfn *ir.Func, n *ir.CallExpr, fn *ir.Func, bigCaller bool, closureCalledOnce bool) *ir.InlinedCallExpr</code></pre>
            </article>
            
            <article class="function" data-name="noteInlinableFunc">
               <h3>
                  noteInlinableFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>noteInlinableFunc issues a message to the user that the specified
function is inlinable.</p>
               
               <pre><code>func noteInlinableFunc(n *ir.Name, fn *ir.Func, cost int32)</code></pre>
            </article>
            
            <article class="function" data-name="numNonClosures">
               <h3>
                  numNonClosures 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>numNonClosures returns the number of functions in list which are not closures.</p>
               
               <pre><code>func numNonClosures(list []*ir.Func) int</code></pre>
            </article>
            
            <article class="function" data-name="parsePos">
               <h3>
                  parsePos 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parsePos returns all the inlining positions and the innermost position.</p>
               
               <pre><code>func parsePos(pos src.XPos, posTmp []src.Pos) ([]src.Pos, src.Pos)</code></pre>
            </article>
            
            <article class="function" data-name="pruneUnusedAutos">
               <h3>
                  pruneUnusedAutos 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func pruneUnusedAutos(ll []*ir.Name, vis *hairyVisitor) []*ir.Name</code></pre>
            </article>
            
            <article class="function" data-name="tooHairy">
               <h3>
                  tooHairy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *hairyVisitor) tooHairy(fn *ir.Func) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
