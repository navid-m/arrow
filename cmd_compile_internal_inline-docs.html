<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - inline</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="cmd_compile_internal_inline_inlheur-docs.html">inlheur</a></li>
               
               <li><a href="cmd_compile_internal_inline_interleaved-docs.html">interleaved</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>inline</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"fmt"
"go/constant"
"internal/buildcfg"
"strconv"
"strings"
"cmd/compile/internal/base"
"cmd/compile/internal/inline/inlheur"
"cmd/compile/internal/ir"
"cmd/compile/internal/logopt"
"cmd/compile/internal/pgoir"
"cmd/compile/internal/typecheck"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/pgo"
"cmd/internal/src"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="InlineCall" data-name="InlineCall">
               <h3>
                  InlineCall 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#InlineCall" class="anchor" title="Link to InlineCall">#</a>
               </h3>
               
               <p>InlineCall allows the inliner implementation to be overridden.
If it returns nil, the function will not be inlined.</p>
               
               <pre><code>var InlineCall = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SSADumpInline" data-name="SSADumpInline">
               <h3>
                  SSADumpInline 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#SSADumpInline" class="anchor" title="Link to SSADumpInline">#</a>
               </h3>
               
               <p>SSADumpInline gives the SSA back end a chance to dump the function
when producing output for debugging the compiler itself.</p>
               
               <pre><code>var SSADumpInline = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="candHotCalleeMap" data-name="candHotCalleeMap">
               <h3>
                  candHotCalleeMap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#candHotCalleeMap" class="anchor" title="Link to candHotCalleeMap">#</a>
               </h3>
               
               <p>List of all hot callee nodes.
TODO(prattmic): Make this non-global.</p>
               
               <pre><code>var candHotCalleeMap = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="candHotEdgeMap" data-name="candHotEdgeMap">
               <h3>
                  candHotEdgeMap 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#candHotEdgeMap" class="anchor" title="Link to candHotEdgeMap">#</a>
               </h3>
               
               <p>List of all hot call sites. CallSiteInfo.Callee is always nil.
TODO(prattmic): Make this non-global.</p>
               
               <pre><code>var candHotEdgeMap = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="hasHotCall" data-name="hasHotCall">
               <h3>
                  hasHotCall 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#hasHotCall" class="anchor" title="Link to hasHotCall">#</a>
               </h3>
               
               <p>Set of functions that contain hot call sites.</p>
               
               <pre><code>var hasHotCall = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlgen" data-name="inlgen">
               <h3>
                  inlgen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#inlgen" class="anchor" title="Link to inlgen">#</a>
               </h3>
               
               <pre><code>var inlgen int</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlineBigFunctionMaxCost" data-name="inlineBigFunctionMaxCost">
               <h3>
                  inlineBigFunctionMaxCost 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inlineBigFunctionMaxCost" class="anchor" title="Link to inlineBigFunctionMaxCost">#</a>
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineBigFunctionMaxCost = 20</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlineBigFunctionNodes" data-name="inlineBigFunctionNodes">
               <h3>
                  inlineBigFunctionNodes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inlineBigFunctionNodes" class="anchor" title="Link to inlineBigFunctionNodes">#</a>
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineBigFunctionNodes = 5000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlineCDFHotCallSiteThresholdPercent" data-name="inlineCDFHotCallSiteThresholdPercent">
               <h3>
                  inlineCDFHotCallSiteThresholdPercent 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#inlineCDFHotCallSiteThresholdPercent" class="anchor" title="Link to inlineCDFHotCallSiteThresholdPercent">#</a>
               </h3>
               
               <p>Threshold in CDF percentage for hot callsite inlining,
that is, for a threshold of X the hottest callsites that
make up the top X% of total edge weight will be
considered hot for inlining candidates.</p>
               
               <pre><code>var inlineCDFHotCallSiteThresholdPercent = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlineClosureCalledOnceCost" data-name="inlineClosureCalledOnceCost">
               <h3>
                  inlineClosureCalledOnceCost 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inlineClosureCalledOnceCost" class="anchor" title="Link to inlineClosureCalledOnceCost">#</a>
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineClosureCalledOnceCost = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlineExtraAppendCost" data-name="inlineExtraAppendCost">
               <h3>
                  inlineExtraAppendCost 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inlineExtraAppendCost" class="anchor" title="Link to inlineExtraAppendCost">#</a>
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineExtraAppendCost = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlineExtraCallCost" data-name="inlineExtraCallCost">
               <h3>
                  inlineExtraCallCost 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inlineExtraCallCost" class="anchor" title="Link to inlineExtraCallCost">#</a>
               </h3>
               
               <p>default is to inline if there's at most one call. -l=4 overrides this by using 1 instead.</p>
               
               <pre><code>const inlineExtraCallCost = 57</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlineExtraPanicCost" data-name="inlineExtraPanicCost">
               <h3>
                  inlineExtraPanicCost 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inlineExtraPanicCost" class="anchor" title="Link to inlineExtraPanicCost">#</a>
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineExtraPanicCost = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlineExtraThrowCost" data-name="inlineExtraThrowCost">
               <h3>
                  inlineExtraThrowCost 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inlineExtraThrowCost" class="anchor" title="Link to inlineExtraThrowCost">#</a>
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineExtraThrowCost = inlineMaxBudget</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlineHotCallSiteThresholdPercent" data-name="inlineHotCallSiteThresholdPercent">
               <h3>
                  inlineHotCallSiteThresholdPercent 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#inlineHotCallSiteThresholdPercent" class="anchor" title="Link to inlineHotCallSiteThresholdPercent">#</a>
               </h3>
               
               <p>Threshold in percentage for hot callsite inlining.</p>
               
               <pre><code>var inlineHotCallSiteThresholdPercent float64</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlineHotMaxBudget" data-name="inlineHotMaxBudget">
               <h3>
                  inlineHotMaxBudget 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#inlineHotMaxBudget" class="anchor" title="Link to inlineHotMaxBudget">#</a>
               </h3>
               
               <p>Budget increased due to hotness.</p>
               
               <pre><code>var inlineHotMaxBudget int32 = 2000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlineMaxBudget" data-name="inlineMaxBudget">
               <h3>
                  inlineMaxBudget 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inlineMaxBudget" class="anchor" title="Link to inlineMaxBudget">#</a>
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineMaxBudget = 80</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="inlineParamCallCost" data-name="inlineParamCallCost">
               <h3>
                  inlineParamCallCost 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#inlineParamCallCost" class="anchor" title="Link to inlineParamCallCost">#</a>
               </h3>
               
               <p>Inlining budget parameters, gathered in one place</p>
               
               <pre><code>const inlineParamCallCost = 17</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="hairyVisitor" data-name="hairyVisitor">
               <h3>
                  hairyVisitor
                  <span class="badge">struct</span>
                  <a href="#hairyVisitor" class="anchor" title="Link to hairyVisitor">#</a>
               </h3>
               
               <p>hairyVisitor visits a function body to determine its inlining
hairiness and whether or not it can be inlined.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type hairyVisitor struct {
curFunc *ir.Func
isBigFunc bool
budget int32
maxBudget int32
reason string
extraCallCost int32
usedLocals ir.NameSet
do func(ir.Node) bool
profile *pgoir.Profile
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="CalleeEffects" data-name="CalleeEffects">
               <h3>
                  CalleeEffects 
                  <span class="badge">function</span>
                  
                  <a href="#CalleeEffects" class="anchor" title="Link to CalleeEffects">#</a>
               </h3>
               
               <p>CalleeEffects appends any side effects from evaluating callee to init.</p>
               
               <pre><code>func CalleeEffects(init *ir.Nodes, callee ir.Node)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanInline" data-name="CanInline">
               <h3>
                  CanInline 
                  <span class="badge">function</span>
                  
                  <a href="#CanInline" class="anchor" title="Link to CanInline">#</a>
               </h3>
               
               <p>CanInline determines whether fn is inlineable.
If so, CanInline saves copies of fn.Body and fn.Dcl in fn.Inl.
fn and fn.Body will already have been typechecked.</p>
               
               <pre><code>func CanInline(fn *ir.Func, profile *pgoir.Profile)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CanInlineFuncs" data-name="CanInlineFuncs">
               <h3>
                  CanInlineFuncs 
                  <span class="badge">function</span>
                  
                  <a href="#CanInlineFuncs" class="anchor" title="Link to CanInlineFuncs">#</a>
               </h3>
               
               <p>CanInlineFuncs computes whether a batch of functions are inlinable.</p>
               
               <pre><code>func CanInlineFuncs(funcs []*ir.Func, profile *pgoir.Profile)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="HasPgoHotInline" data-name="HasPgoHotInline">
               <h3>
                  HasPgoHotInline 
                  <span class="badge">function</span>
                  
                  <a href="#HasPgoHotInline" class="anchor" title="Link to HasPgoHotInline">#</a>
               </h3>
               
               <pre><code>func HasPgoHotInline(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InlineCallTarget" data-name="InlineCallTarget">
               <h3>
                  InlineCallTarget 
                  <span class="badge">function</span>
                  
                  <a href="#InlineCallTarget" class="anchor" title="Link to InlineCallTarget">#</a>
               </h3>
               
               <p>InlineCallTarget returns the resolved-for-inlining target of a call.
It does not necessarily guarantee that the target can be inlined, though
obvious exclusions are applied.</p>
               
               <pre><code>func InlineCallTarget(callerfn *ir.Func, call *ir.CallExpr, profile *pgoir.Profile) *ir.Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InlineImpossible" data-name="InlineImpossible">
               <h3>
                  InlineImpossible 
                  <span class="badge">function</span>
                  
                  <a href="#InlineImpossible" class="anchor" title="Link to InlineImpossible">#</a>
               </h3>
               
               <p>InlineImpossible returns a non-empty reason string if fn is impossible to
inline regardless of cost or contents.</p>
               
               <pre><code>func InlineImpossible(fn *ir.Func) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsBigFunc" data-name="IsBigFunc">
               <h3>
                  IsBigFunc 
                  <span class="badge">function</span>
                  
                  <a href="#IsBigFunc" class="anchor" title="Link to IsBigFunc">#</a>
               </h3>
               
               <p>IsBigFunc reports whether fn is a "big" function.
Note: The criteria for "big" is heuristic and subject to change.</p>
               
               <pre><code>func IsBigFunc(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsPgoHotFunc" data-name="IsPgoHotFunc">
               <h3>
                  IsPgoHotFunc 
                  <span class="badge">function</span>
                  
                  <a href="#IsPgoHotFunc" class="anchor" title="Link to IsPgoHotFunc">#</a>
               </h3>
               
               <pre><code>func IsPgoHotFunc(fn *ir.Func, profile *pgoir.Profile) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PGOInlinePrologue" data-name="PGOInlinePrologue">
               <h3>
                  PGOInlinePrologue 
                  <span class="badge">function</span>
                  
                  <a href="#PGOInlinePrologue" class="anchor" title="Link to PGOInlinePrologue">#</a>
               </h3>
               
               <p>PGOInlinePrologue records the hot callsites from ir-graph.</p>
               
               <pre><code>func PGOInlinePrologue(p *pgoir.Profile)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PostProcessCallSites" data-name="PostProcessCallSites">
               <h3>
                  PostProcessCallSites 
                  <span class="badge">function</span>
                  
                  <a href="#PostProcessCallSites" class="anchor" title="Link to PostProcessCallSites">#</a>
               </h3>
               
               <pre><code>func PostProcessCallSites(profile *pgoir.Profile)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TryInlineCall" data-name="TryInlineCall">
               <h3>
                  TryInlineCall 
                  <span class="badge">function</span>
                  
                  <a href="#TryInlineCall" class="anchor" title="Link to TryInlineCall">#</a>
               </h3>
               
               <p>TryInlineCall returns an inlined call expression for call, or nil
if inlining is not possible.</p>
               
               <pre><code>func TryInlineCall(callerfn *ir.Func, call *ir.CallExpr, bigCaller bool, profile *pgoir.Profile, closureCalledOnce bool) *ir.InlinedCallExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="analyzeFuncProps" data-name="analyzeFuncProps">
               <h3>
                  analyzeFuncProps 
                  <span class="badge">function</span>
                  
                  <a href="#analyzeFuncProps" class="anchor" title="Link to analyzeFuncProps">#</a>
               </h3>
               
               <pre><code>func analyzeFuncProps(fn *ir.Func, p *pgoir.Profile)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canDelayResults" data-name="canDelayResults">
               <h3>
                  canDelayResults 
                  <span class="badge">function</span>
                  
                  <a href="#canDelayResults" class="anchor" title="Link to canDelayResults">#</a>
               </h3>
               
               <p>canDelayResults reports whether inlined calls to fn can delay
declaring the result parameter until the "return" statement.</p>
               
               <pre><code>func canDelayResults(fn *ir.Func) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="canInlineCallExpr" data-name="canInlineCallExpr">
               <h3>
                  canInlineCallExpr 
                  <span class="badge">function</span>
                  
                  <a href="#canInlineCallExpr" class="anchor" title="Link to canInlineCallExpr">#</a>
               </h3>
               
               <p>canInlineCallExpr returns true if the call n from caller to callee
can be inlined, plus the score computed for the call expr in question,
and whether the callee is hot according to PGO.
bigCaller indicates that caller is a big function. log
indicates that the 'cannot inline' reason should be logged.
Preconditions: CanInline(callee) has already been called.</p>
               
               <pre><code>func canInlineCallExpr(callerfn *ir.Func, n *ir.CallExpr, callee *ir.Func, bigCaller bool, closureCalledOnce bool, log bool) (bool, int32, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doList" data-name="doList">
               <h3>
                  doList 
                  <span class="badge">function</span>
                  
                  <a href="#doList" class="anchor" title="Link to doList">#</a>
               </h3>
               
               <pre><code>func doList(list []ir.Node, do func(ir.Node) bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doNode" data-name="doNode">
               <h3>
                  doNode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#doNode" class="anchor" title="Link to doNode">#</a>
               </h3>
               
               <p>doNode visits n and its children, updates the state in v, and returns true if
n makes the current function too hairy for inlining.</p>
               
               <pre><code>func (v *hairyVisitor) doNode(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hotNodesFromCDF" data-name="hotNodesFromCDF">
               <h3>
                  hotNodesFromCDF 
                  <span class="badge">function</span>
                  
                  <a href="#hotNodesFromCDF" class="anchor" title="Link to hotNodesFromCDF">#</a>
               </h3>
               
               <p>hotNodesFromCDF computes an edge weight threshold and the list of hot
nodes that make up the given percentage of the CDF. The threshold, as
a percent, is the lower bound of weight for nodes to be considered hot
(currently only used in debug prints) (in case of equal weights,
comparing with the threshold may not accurately reflect which nodes are
considered hot).</p>
               
               <pre><code>func hotNodesFromCDF(p *pgoir.Profile) (float64, []pgo.NamedCallEdge)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inlCallee" data-name="inlCallee">
               <h3>
                  inlCallee 
                  <span class="badge">function</span>
                  
                  <a href="#inlCallee" class="anchor" title="Link to inlCallee">#</a>
               </h3>
               
               <p>inlCallee takes a function-typed expression and returns the underlying function ONAME
that it refers to if statically known. Otherwise, it returns nil.
resolveOnly skips cost-based inlineability checks for closures; the result may not actually be inlineable.</p>
               
               <pre><code>func inlCallee(caller *ir.Func, fn ir.Node, profile *pgoir.Profile, resolveOnly bool) (res *ir.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inlineBudget" data-name="inlineBudget">
               <h3>
                  inlineBudget 
                  <span class="badge">function</span>
                  
                  <a href="#inlineBudget" class="anchor" title="Link to inlineBudget">#</a>
               </h3>
               
               <p>inlineBudget determines the max budget for function 'fn' prior to
analyzing the hairiness of the body of 'fn'. We pass in the pgo
profile if available (which can change the budget), also a
'relaxed' flag, which expands the budget slightly to allow for the
possibility that a call to the function might have its score
adjusted downwards. If 'verbose' is set, then print a remark where
we boost the budget due to PGO.</p>
               
               <pre><code>func inlineBudget(fn *ir.Func, profile *pgoir.Profile, relaxed bool, verbose bool) int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inlineCallCheck" data-name="inlineCallCheck">
               <h3>
                  inlineCallCheck 
                  <span class="badge">function</span>
                  
                  <a href="#inlineCallCheck" class="anchor" title="Link to inlineCallCheck">#</a>
               </h3>
               
               <p>inlineCallCheck returns whether a call will never be inlineable
for basic reasons, and whether the call is an intrinisic call.
The intrinsic result singles out intrinsic calls for debug logging.</p>
               
               <pre><code>func inlineCallCheck(callerfn *ir.Func, call *ir.CallExpr) (bool, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="inlineCostOK" data-name="inlineCostOK">
               <h3>
                  inlineCostOK 
                  <span class="badge">function</span>
                  
                  <a href="#inlineCostOK" class="anchor" title="Link to inlineCostOK">#</a>
               </h3>
               
               <p>inlineCostOK returns true if call n from caller to callee is cheap enough to
inline. bigCaller indicates that caller is a big function.
In addition to the "cost OK" boolean, it also returns
- the "max cost" limit used to make the decision (which may differ depending on func size)
- the score assigned to this specific callsite
- whether the inlined function is "hot" according to PGO.</p>
               
               <pre><code>func inlineCostOK(n *ir.CallExpr, caller *ir.Func, callee *ir.Func, bigCaller bool, closureCalledOnce bool) (bool, int32, int32, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isAtomicCoverageCounterUpdate" data-name="isAtomicCoverageCounterUpdate">
               <h3>
                  isAtomicCoverageCounterUpdate 
                  <span class="badge">function</span>
                  
                  <a href="#isAtomicCoverageCounterUpdate" class="anchor" title="Link to isAtomicCoverageCounterUpdate">#</a>
               </h3>
               
               <p>isAtomicCoverageCounterUpdate examines the specified node to
determine whether it represents a call to sync/atomic.AddUint32 to
increment a coverage counter.</p>
               
               <pre><code>func isAtomicCoverageCounterUpdate(cn *ir.CallExpr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isIndexingCoverageCounter" data-name="isIndexingCoverageCounter">
               <h3>
                  isIndexingCoverageCounter 
                  <span class="badge">function</span>
                  
                  <a href="#isIndexingCoverageCounter" class="anchor" title="Link to isIndexingCoverageCounter">#</a>
               </h3>
               
               <p>isIndexingCoverageCounter returns true if the specified node 'n' is indexing
into a coverage counter array.</p>
               
               <pre><code>func isIndexingCoverageCounter(n ir.Node) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mkinlcall" data-name="mkinlcall">
               <h3>
                  mkinlcall 
                  <span class="badge">function</span>
                  
                  <a href="#mkinlcall" class="anchor" title="Link to mkinlcall">#</a>
               </h3>
               
               <p>mkinlcall returns an OINLCALL node that can replace OCALLFUNC n, or
nil if it cannot be inlined. callerfn is the function that contains
n, and fn is the function being called.
The result of mkinlcall MUST be assigned back to n, e.g.
n.Left = mkinlcall(n.Left, fn, isddd)</p>
               
               <pre><code>func mkinlcall(callerfn *ir.Func, n *ir.CallExpr, fn *ir.Func, bigCaller bool, closureCalledOnce bool) *ir.InlinedCallExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="noteInlinableFunc" data-name="noteInlinableFunc">
               <h3>
                  noteInlinableFunc 
                  <span class="badge">function</span>
                  
                  <a href="#noteInlinableFunc" class="anchor" title="Link to noteInlinableFunc">#</a>
               </h3>
               
               <p>noteInlinableFunc issues a message to the user that the specified
function is inlinable.</p>
               
               <pre><code>func noteInlinableFunc(n *ir.Name, fn *ir.Func, cost int32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="numNonClosures" data-name="numNonClosures">
               <h3>
                  numNonClosures 
                  <span class="badge">function</span>
                  
                  <a href="#numNonClosures" class="anchor" title="Link to numNonClosures">#</a>
               </h3>
               
               <p>numNonClosures returns the number of functions in list which are not closures.</p>
               
               <pre><code>func numNonClosures(list []*ir.Func) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePos" data-name="parsePos">
               <h3>
                  parsePos 
                  <span class="badge">function</span>
                  
                  <a href="#parsePos" class="anchor" title="Link to parsePos">#</a>
               </h3>
               
               <p>parsePos returns all the inlining positions and the innermost position.</p>
               
               <pre><code>func parsePos(pos src.XPos, posTmp []src.Pos) ([]src.Pos, src.Pos)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pruneUnusedAutos" data-name="pruneUnusedAutos">
               <h3>
                  pruneUnusedAutos 
                  <span class="badge">function</span>
                  
                  <a href="#pruneUnusedAutos" class="anchor" title="Link to pruneUnusedAutos">#</a>
               </h3>
               
               <pre><code>func pruneUnusedAutos(ll []*ir.Name, vis *hairyVisitor) []*ir.Name</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tooHairy" data-name="tooHairy">
               <h3>
                  tooHairy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tooHairy" class="anchor" title="Link to tooHairy">#</a>
               </h3>
               
               <pre><code>func (v *hairyVisitor) tooHairy(fn *ir.Func) bool</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>