<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - inline</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="cmd_compile_internal_inline_inlheur-docs.html">inlheur</a>
         <br />
         
         <a href="cmd_compile_internal_inline_interleaved-docs.html">interleaved</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>inline</code>
         </h1>
         <hr />
         
         <article class="global" data-name="inlineMaxBudget">
            <h2>inlineMaxBudget</h2>
            <hr />
            
            <p>Inlining budget parameters, gathered in one place</p>
            
            <pre><code>inlineMaxBudget</code></pre>
         </article>
         
         <article class="global" data-name="inlineExtraAppendCost">
            <h2>inlineExtraAppendCost</h2>
            <hr />
            
            <p>Inlining budget parameters, gathered in one place</p>
            
            <pre><code>inlineExtraAppendCost</code></pre>
         </article>
         
         <article class="global" data-name="inlineExtraCallCost">
            <h2>inlineExtraCallCost</h2>
            <hr />
            
            <p>default is to inline if there's at most one call. -l=4 overrides this by using 1 instead.</p>
            
            <pre><code>inlineExtraCallCost</code></pre>
         </article>
         
         <article class="global" data-name="inlineParamCallCost">
            <h2>inlineParamCallCost</h2>
            <hr />
            
            <p>Inlining budget parameters, gathered in one place</p>
            
            <pre><code>inlineParamCallCost</code></pre>
         </article>
         
         <article class="global" data-name="inlineExtraPanicCost">
            <h2>inlineExtraPanicCost</h2>
            <hr />
            
            <p>Inlining budget parameters, gathered in one place</p>
            
            <pre><code>inlineExtraPanicCost</code></pre>
         </article>
         
         <article class="global" data-name="inlineExtraThrowCost">
            <h2>inlineExtraThrowCost</h2>
            <hr />
            
            <p>Inlining budget parameters, gathered in one place</p>
            
            <pre><code>inlineExtraThrowCost</code></pre>
         </article>
         
         <article class="global" data-name="inlineBigFunctionNodes">
            <h2>inlineBigFunctionNodes</h2>
            <hr />
            
            <p>Inlining budget parameters, gathered in one place</p>
            
            <pre><code>inlineBigFunctionNodes</code></pre>
         </article>
         
         <article class="global" data-name="inlineBigFunctionMaxCost">
            <h2>inlineBigFunctionMaxCost</h2>
            <hr />
            
            <p>Inlining budget parameters, gathered in one place</p>
            
            <pre><code>inlineBigFunctionMaxCost</code></pre>
         </article>
         
         <article class="global" data-name="inlineClosureCalledOnceCost">
            <h2>inlineClosureCalledOnceCost</h2>
            <hr />
            
            <p>Inlining budget parameters, gathered in one place</p>
            
            <pre><code>inlineClosureCalledOnceCost</code></pre>
         </article>
         
         <article class="global" data-name="candHotCalleeMap">
            <h2>candHotCalleeMap</h2>
            <hr />
            
            <p>List of all hot callee nodes.
TODO(prattmic): Make this non-global.</p>
            
            <pre><code>candHotCalleeMap</code></pre>
         </article>
         
         <article class="global" data-name="hasHotCall">
            <h2>hasHotCall</h2>
            <hr />
            
            <p>Set of functions that contain hot call sites.</p>
            
            <pre><code>hasHotCall</code></pre>
         </article>
         
         <article class="global" data-name="candHotEdgeMap">
            <h2>candHotEdgeMap</h2>
            <hr />
            
            <p>List of all hot call sites. CallSiteInfo.Callee is always nil.
TODO(prattmic): Make this non-global.</p>
            
            <pre><code>candHotEdgeMap</code></pre>
         </article>
         
         <article class="global" data-name="inlineHotCallSiteThresholdPercent">
            <h2>inlineHotCallSiteThresholdPercent</h2>
            <hr />
            
            <p>Threshold in percentage for hot callsite inlining.</p>
            
            <pre><code>inlineHotCallSiteThresholdPercent float64</code></pre>
         </article>
         
         <article class="global" data-name="inlineCDFHotCallSiteThresholdPercent">
            <h2>inlineCDFHotCallSiteThresholdPercent</h2>
            <hr />
            
            <p>Threshold in CDF percentage for hot callsite inlining,
that is, for a threshold of X the hottest callsites that
make up the top X% of total edge weight will be
considered hot for inlining candidates.</p>
            
            <pre><code>inlineCDFHotCallSiteThresholdPercent</code></pre>
         </article>
         
         <article class="global" data-name="inlineHotMaxBudget">
            <h2>inlineHotMaxBudget</h2>
            <hr />
            
            <p>Budget increased due to hotness.</p>
            
            <pre><code>inlineHotMaxBudget int32</code></pre>
         </article>
         
         <article class="global" data-name="inlgen">
            <h2>inlgen</h2>
            <hr />
            
            <pre><code>inlgen int</code></pre>
         </article>
         
         <article class="global" data-name="SSADumpInline">
            <h2>SSADumpInline</h2>
            <hr />
            
            <p>SSADumpInline gives the SSA back end a chance to dump the function
when producing output for debugging the compiler itself.</p>
            
            <pre><code>SSADumpInline</code></pre>
         </article>
         
         <article class="global" data-name="InlineCall">
            <h2>InlineCall</h2>
            <hr />
            
            <p>InlineCall allows the inliner implementation to be overridden.
If it returns nil, the function will not be inlined.</p>
            
            <pre><code>InlineCall</code></pre>
         </article>
          
         <article class="struct" data-name="hairyVisitor">
            <h2>type hairyVisitor struct</h2>
            <hr />
            
            <p>hairyVisitor visits a function body to determine its inlining
hairiness and whether or not it can be inlined.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">curFunc *ir.Func
isBigFunc bool
budget int32
maxBudget int32
reason string
extraCallCost int32
usedLocals ir.NameSet
do func
profile *pgoir.Profile</code></pre>
         </article>
          
         <article class="function" data-name="IsPgoHotFunc">
            <h2>IsPgoHotFunc</h2>
            <hr />
            
            <pre><code>func IsPgoHotFunc(fn *ir.Func, profile *pgoir.Profile) bool</code></pre>
         </article>
         
         <article class="function" data-name="HasPgoHotInline">
            <h2>HasPgoHotInline</h2>
            <hr />
            
            <pre><code>func HasPgoHotInline(fn *ir.Func) bool</code></pre>
         </article>
         
         <article class="function" data-name="PGOInlinePrologue">
            <h2>PGOInlinePrologue</h2>
            <hr />
            
            <p>PGOInlinePrologue records the hot callsites from ir-graph.</p>
            
            <pre><code>func PGOInlinePrologue(p *pgoir.Profile)</code></pre>
         </article>
         
         <article class="function" data-name="hotNodesFromCDF">
            <h2>hotNodesFromCDF</h2>
            <hr />
            
            <p>hotNodesFromCDF computes an edge weight threshold and the list of hot
nodes that make up the given percentage of the CDF. The threshold, as
a percent, is the lower bound of weight for nodes to be considered hot
(currently only used in debug prints) (in case of equal weights,
comparing with the threshold may not accurately reflect which nodes are
considered hot).</p>
            
            <pre><code>func hotNodesFromCDF(p *pgoir.Profile) (float64, []pgo.NamedCallEdge)</code></pre>
         </article>
         
         <article class="function" data-name="CanInlineFuncs">
            <h2>CanInlineFuncs</h2>
            <hr />
            
            <p>CanInlineFuncs computes whether a batch of functions are inlinable.</p>
            
            <pre><code>func CanInlineFuncs(funcs []*ir.Func, profile *pgoir.Profile)</code></pre>
         </article>
         
         <article class="function" data-name="inlineBudget">
            <h2>inlineBudget</h2>
            <hr />
            
            <p>inlineBudget determines the max budget for function 'fn' prior to
analyzing the hairiness of the body of 'fn'. We pass in the pgo
profile if available (which can change the budget), also a
'relaxed' flag, which expands the budget slightly to allow for the
possibility that a call to the function might have its score
adjusted downwards. If 'verbose' is set, then print a remark where
we boost the budget due to PGO.</p>
            
            <pre><code>func inlineBudget(fn *ir.Func, profile *pgoir.Profile, relaxed bool, verbose bool) int32</code></pre>
         </article>
         
         <article class="function" data-name="CanInline">
            <h2>CanInline</h2>
            <hr />
            
            <p>CanInline determines whether fn is inlineable.
If so, CanInline saves copies of fn.Body and fn.Dcl in fn.Inl.
fn and fn.Body will already have been typechecked.</p>
            
            <pre><code>func CanInline(fn *ir.Func, profile *pgoir.Profile)</code></pre>
         </article>
         
         <article class="function" data-name="noteInlinableFunc">
            <h2>noteInlinableFunc</h2>
            <hr />
            
            <p>noteInlinableFunc issues a message to the user that the specified
function is inlinable.</p>
            
            <pre><code>func noteInlinableFunc(n *ir.Name, fn *ir.Func, cost int32)</code></pre>
         </article>
         
         <article class="function" data-name="InlineImpossible">
            <h2>InlineImpossible</h2>
            <hr />
            
            <p>InlineImpossible returns a non-empty reason string if fn is impossible to
inline regardless of cost or contents.</p>
            
            <pre><code>func InlineImpossible(fn *ir.Func) string</code></pre>
         </article>
         
         <article class="function" data-name="canDelayResults">
            <h2>canDelayResults</h2>
            <hr />
            
            <p>canDelayResults reports whether inlined calls to fn can delay
declaring the result parameter until the "return" statement.</p>
            
            <pre><code>func canDelayResults(fn *ir.Func) bool</code></pre>
         </article>
         
         <article class="function" data-name="tooHairy">
            <h2>tooHairy</h2>
            <hr />
            
            <pre><code>func tooHairy(fn *ir.Func) bool</code></pre>
         </article>
         
         <article class="function" data-name="doNode">
            <h2>doNode</h2>
            <hr />
            
            <p>doNode visits n and its children, updates the state in v, and returns true if
n makes the current function too hairy for inlining.</p>
            
            <pre><code>func doNode(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsBigFunc">
            <h2>IsBigFunc</h2>
            <hr />
            
            <p>IsBigFunc reports whether fn is a "big" function.

Note: The criteria for "big" is heuristic and subject to change.</p>
            
            <pre><code>func IsBigFunc(fn *ir.Func) bool</code></pre>
         </article>
         
         <article class="function" data-name="inlineCallCheck">
            <h2>inlineCallCheck</h2>
            <hr />
            
            <p>inlineCallCheck returns whether a call will never be inlineable
for basic reasons, and whether the call is an intrinisic call.
The intrinsic result singles out intrinsic calls for debug logging.</p>
            
            <pre><code>func inlineCallCheck(callerfn *ir.Func, call *ir.CallExpr) (bool, bool)</code></pre>
         </article>
         
         <article class="function" data-name="InlineCallTarget">
            <h2>InlineCallTarget</h2>
            <hr />
            
            <p>InlineCallTarget returns the resolved-for-inlining target of a call.
It does not necessarily guarantee that the target can be inlined, though
obvious exclusions are applied.</p>
            
            <pre><code>func InlineCallTarget(callerfn *ir.Func, call *ir.CallExpr, profile *pgoir.Profile) *ir.Func</code></pre>
         </article>
         
         <article class="function" data-name="TryInlineCall">
            <h2>TryInlineCall</h2>
            <hr />
            
            <p>TryInlineCall returns an inlined call expression for call, or nil
if inlining is not possible.</p>
            
            <pre><code>func TryInlineCall(callerfn *ir.Func, call *ir.CallExpr, bigCaller bool, profile *pgoir.Profile, closureCalledOnce bool) *ir.InlinedCallExpr</code></pre>
         </article>
         
         <article class="function" data-name="inlCallee">
            <h2>inlCallee</h2>
            <hr />
            
            <p>inlCallee takes a function-typed expression and returns the underlying function ONAME
that it refers to if statically known. Otherwise, it returns nil.
resolveOnly skips cost-based inlineability checks for closures; the result may not actually be inlineable.</p>
            
            <pre><code>func inlCallee(caller *ir.Func, fn ir.Node, profile *pgoir.Profile, resolveOnly bool) res *ir.Func</code></pre>
         </article>
         
         <article class="function" data-name="inlineCostOK">
            <h2>inlineCostOK</h2>
            <hr />
            
            <p>inlineCostOK returns true if call n from caller to callee is cheap enough to
inline. bigCaller indicates that caller is a big function.

In addition to the "cost OK" boolean, it also returns
  - the "max cost" limit used to make the decision (which may differ depending on func size)
  - the score assigned to this specific callsite
  - whether the inlined function is "hot" according to PGO.</p>
            
            <pre><code>func inlineCostOK(n *ir.CallExpr, caller *ir.Func, callee *ir.Func, bigCaller bool, closureCalledOnce bool) (bool, int32, int32, bool)</code></pre>
         </article>
         
         <article class="function" data-name="parsePos">
            <h2>parsePos</h2>
            <hr />
            
            <p>parsePos returns all the inlining positions and the innermost position.</p>
            
            <pre><code>func parsePos(pos src.XPos, posTmp []src.Pos) ([]src.Pos, src.Pos)</code></pre>
         </article>
         
         <article class="function" data-name="canInlineCallExpr">
            <h2>canInlineCallExpr</h2>
            <hr />
            
            <p>canInlineCallExpr returns true if the call n from caller to callee
can be inlined, plus the score computed for the call expr in question,
and whether the callee is hot according to PGO.
bigCaller indicates that caller is a big function. log
indicates that the 'cannot inline' reason should be logged.

Preconditions: CanInline(callee) has already been called.</p>
            
            <pre><code>func canInlineCallExpr(callerfn *ir.Func, n *ir.CallExpr, callee *ir.Func, bigCaller bool, closureCalledOnce bool, log bool) (bool, int32, bool)</code></pre>
         </article>
         
         <article class="function" data-name="mkinlcall">
            <h2>mkinlcall</h2>
            <hr />
            
            <p>mkinlcall returns an OINLCALL node that can replace OCALLFUNC n, or
nil if it cannot be inlined. callerfn is the function that contains
n, and fn is the function being called.

The result of mkinlcall MUST be assigned back to n, e.g.

	n.Left = mkinlcall(n.Left, fn, isddd)</p>
            
            <pre><code>func mkinlcall(callerfn *ir.Func, n *ir.CallExpr, fn *ir.Func, bigCaller bool, closureCalledOnce bool) *ir.InlinedCallExpr</code></pre>
         </article>
         
         <article class="function" data-name="CalleeEffects">
            <h2>CalleeEffects</h2>
            <hr />
            
            <p>CalleeEffects appends any side effects from evaluating callee to init.</p>
            
            <pre><code>func CalleeEffects(init *ir.Nodes, callee ir.Node)</code></pre>
         </article>
         
         <article class="function" data-name="pruneUnusedAutos">
            <h2>pruneUnusedAutos</h2>
            <hr />
            
            <pre><code>func pruneUnusedAutos(ll []*ir.Name, vis *hairyVisitor) []*ir.Name</code></pre>
         </article>
         
         <article class="function" data-name="numNonClosures">
            <h2>numNonClosures</h2>
            <hr />
            
            <p>numNonClosures returns the number of functions in list which are not closures.</p>
            
            <pre><code>func numNonClosures(list []*ir.Func) int</code></pre>
         </article>
         
         <article class="function" data-name="doList">
            <h2>doList</h2>
            <hr />
            
            <pre><code>func doList(list []ir.Node, do func) bool</code></pre>
         </article>
         
         <article class="function" data-name="isIndexingCoverageCounter">
            <h2>isIndexingCoverageCounter</h2>
            <hr />
            
            <p>isIndexingCoverageCounter returns true if the specified node 'n' is indexing
into a coverage counter array.</p>
            
            <pre><code>func isIndexingCoverageCounter(n ir.Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="isAtomicCoverageCounterUpdate">
            <h2>isAtomicCoverageCounterUpdate</h2>
            <hr />
            
            <p>isAtomicCoverageCounterUpdate examines the specified node to
determine whether it represents a call to sync/atomic.AddUint32 to
increment a coverage counter.</p>
            
            <pre><code>func isAtomicCoverageCounterUpdate(cn *ir.CallExpr) bool</code></pre>
         </article>
         
         <article class="function" data-name="PostProcessCallSites">
            <h2>PostProcessCallSites</h2>
            <hr />
            
            <pre><code>func PostProcessCallSites(profile *pgoir.Profile)</code></pre>
         </article>
         
         <article class="function" data-name="analyzeFuncProps">
            <h2>analyzeFuncProps</h2>
            <hr />
            
            <pre><code>func analyzeFuncProps(fn *ir.Func, p *pgoir.Profile)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
