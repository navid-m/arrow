<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - modfile</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>modfile</code>
         </h1>
         <hr />
         
         <article class="global" data-name="_EOF">
            <h2>_EOF</h2>
            <hr />
            
            <pre><code>_EOF tokenKind</code></pre>
         </article>
         
         <article class="global" data-name="_EOLCOMMENT">
            <h2>_EOLCOMMENT</h2>
            <hr />
            
            <pre><code>_EOLCOMMENT</code></pre>
         </article>
         
         <article class="global" data-name="_IDENT">
            <h2>_IDENT</h2>
            <hr />
            
            <pre><code>_IDENT</code></pre>
         </article>
         
         <article class="global" data-name="_STRING">
            <h2>_STRING</h2>
            <hr />
            
            <pre><code>_STRING</code></pre>
         </article>
         
         <article class="global" data-name="_COMMENT">
            <h2>_COMMENT</h2>
            <hr />
            
            <pre><code>_COMMENT</code></pre>
         </article>
         
         <article class="global" data-name="slashSlash">
            <h2>slashSlash</h2>
            <hr />
            
            <pre><code>slashSlash</code></pre>
         </article>
         
         <article class="global" data-name="moduleStr">
            <h2>moduleStr</h2>
            <hr />
            
            <pre><code>moduleStr</code></pre>
         </article>
         
         <article class="global" data-name="dontFixRetract">
            <h2>dontFixRetract</h2>
            <hr />
            
            <p>errDontFix is returned by a VersionFixer to indicate the version should be
left alone, even if it's not canonical.</p>
            
            <pre><code>dontFixRetract VersionFixer</code></pre>
         </article>
         
         <article class="global" data-name="GoVersionRE">
            <h2>GoVersionRE</h2>
            <hr />
            
            <pre><code>GoVersionRE</code></pre>
         </article>
         
         <article class="global" data-name="laxGoVersionRE">
            <h2>laxGoVersionRE</h2>
            <hr />
            
            <pre><code>laxGoVersionRE</code></pre>
         </article>
         
         <article class="global" data-name="ToolchainRE">
            <h2>ToolchainRE</h2>
            <hr />
            
            <p>Toolchains must be named beginning with `go1`,
like "go1.20.3" or "go1.20.3-gccgo". As a special case, "default" is also permitted.
Note that this regexp is a much looser condition than go/version.IsValid,
for forward compatibility.
(This code has to be work to identify new toolchains even if we tweak the syntax in the future.)</p>
            
            <pre><code>ToolchainRE</code></pre>
         </article>
         
         <article class="global" data-name="deprecatedRE">
            <h2>deprecatedRE</h2>
            <hr />
            
            <pre><code>deprecatedRE</code></pre>
         </article>
          
         <article class="struct" data-name="Position">
            <h2>type Position struct</h2>
            <hr />
            
            <p>A Position describes an arbitrary source position in a file, including the
file, line, column, and byte offset.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Line int
LineRune int
Byte int</code></pre>
         </article>
         
         <article class="struct" data-name="Comment">
            <h2>type Comment struct</h2>
            <hr />
            
            <p>A Comment represents a single // comment.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Start Position
Token string
Suffix bool</code></pre>
         </article>
         
         <article class="struct" data-name="Comments">
            <h2>type Comments struct</h2>
            <hr />
            
            <p>Comments collects the comments associated with an expression.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Before []Comment
Suffix []Comment
After []Comment</code></pre>
         </article>
         
         <article class="struct" data-name="FileSyntax">
            <h2>type FileSyntax struct</h2>
            <hr />
            
            <p>A FileSyntax represents an entire go.mod file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name string
Comments
Stmt []Expr</code></pre>
         </article>
         
         <article class="struct" data-name="CommentBlock">
            <h2>type CommentBlock struct</h2>
            <hr />
            
            <p>A CommentBlock represents a top-level block of comments separate
from any rule.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Comments
Start Position</code></pre>
         </article>
         
         <article class="struct" data-name="Line">
            <h2>type Line struct</h2>
            <hr />
            
            <p>A Line is a single line of tokens.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Comments
Start Position
Token []string
InBlock bool
End Position</code></pre>
         </article>
         
         <article class="struct" data-name="LineBlock">
            <h2>type LineBlock struct</h2>
            <hr />
            
            <p>A LineBlock is a factored block of lines, like

	require (
		"x"
		"y"
	)</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Comments
Start Position
LParen LParen
Token []string
Line []*Line
RParen RParen</code></pre>
         </article>
         
         <article class="struct" data-name="LParen">
            <h2>type LParen struct</h2>
            <hr />
            
            <p>An LParen represents the beginning of a parenthesized line block.
It is a place to store suffix comments.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Comments
Pos Position</code></pre>
         </article>
         
         <article class="struct" data-name="RParen">
            <h2>type RParen struct</h2>
            <hr />
            
            <p>An RParen represents the end of a parenthesized line block.
It is a place to store whole-line (before) comments.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Comments
Pos Position</code></pre>
         </article>
         
         <article class="struct" data-name="input">
            <h2>type input struct</h2>
            <hr />
            
            <p>An input represents a single input file being parsed.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">filename string
complete []byte
remaining []byte
tokenStart []byte
token token
pos Position
comments []Comment
file *FileSyntax
parseErrors ErrorList
pre []Expr
post []Expr</code></pre>
         </article>
         
         <article class="struct" data-name="token">
            <h2>type token struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">kind tokenKind
pos Position
endPos Position
text string</code></pre>
         </article>
         
         <article class="struct" data-name="File">
            <h2>type File struct</h2>
            <hr />
            
            <p>A File is the parsed, interpreted form of a go.mod file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Module *Module
Go *Go
Toolchain *Toolchain
Godebug []*Godebug
Require []*Require
Exclude []*Exclude
Replace []*Replace
Retract []*Retract
Tool []*Tool
Syntax *FileSyntax</code></pre>
         </article>
         
         <article class="struct" data-name="Module">
            <h2>type Module struct</h2>
            <hr />
            
            <p>A Module is the module statement.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Mod module.Version
Deprecated string
Syntax *Line</code></pre>
         </article>
         
         <article class="struct" data-name="Go">
            <h2>type Go struct</h2>
            <hr />
            
            <p>A Go is the go statement.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Version string
Syntax *Line</code></pre>
         </article>
         
         <article class="struct" data-name="Toolchain">
            <h2>type Toolchain struct</h2>
            <hr />
            
            <p>A Toolchain is the toolchain statement.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name string
Syntax *Line</code></pre>
         </article>
         
         <article class="struct" data-name="Godebug">
            <h2>type Godebug struct</h2>
            <hr />
            
            <p>A Godebug is a single godebug key=value statement.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Key string
Value string
Syntax *Line</code></pre>
         </article>
         
         <article class="struct" data-name="Exclude">
            <h2>type Exclude struct</h2>
            <hr />
            
            <p>An Exclude is a single exclude statement.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Mod module.Version
Syntax *Line</code></pre>
         </article>
         
         <article class="struct" data-name="Replace">
            <h2>type Replace struct</h2>
            <hr />
            
            <p>A Replace is a single replace statement.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Old module.Version
New module.Version
Syntax *Line</code></pre>
         </article>
         
         <article class="struct" data-name="Retract">
            <h2>type Retract struct</h2>
            <hr />
            
            <p>A Retract is a single retract statement.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">VersionInterval
Rationale string
Syntax *Line</code></pre>
         </article>
         
         <article class="struct" data-name="Tool">
            <h2>type Tool struct</h2>
            <hr />
            
            <p>A Tool is a single tool statement.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Path string
Syntax *Line</code></pre>
         </article>
         
         <article class="struct" data-name="VersionInterval">
            <h2>type VersionInterval struct</h2>
            <hr />
            
            <p>A VersionInterval represents a range of versions with upper and lower bounds.
Intervals are closed: both bounds are included. When Low is equal to High,
the interval may refer to a single version ('v1.2.3') or an interval
('[v1.2.3, v1.2.3]'); both have the same representation.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Low string
High string</code></pre>
         </article>
         
         <article class="struct" data-name="Require">
            <h2>type Require struct</h2>
            <hr />
            
            <p>A Require is a single require statement.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Mod module.Version
Indirect bool
Syntax *Line</code></pre>
         </article>
         
         <article class="struct" data-name="Error">
            <h2>type Error struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Filename string
Pos Position
Verb string
ModPath string
Err error</code></pre>
         </article>
         
         <article class="struct" data-name="WorkFile">
            <h2>type WorkFile struct</h2>
            <hr />
            
            <p>A WorkFile is the parsed, interpreted form of a go.work file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Go *Go
Toolchain *Toolchain
Godebug []*Godebug
Use []*Use
Replace []*Replace
Syntax *FileSyntax</code></pre>
         </article>
         
         <article class="struct" data-name="Use">
            <h2>type Use struct</h2>
            <hr />
            
            <p>A Use is a single directory statement.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Path string
ModulePath string
Syntax *Line</code></pre>
         </article>
         
         <article class="struct" data-name="printer">
            <h2>type printer struct</h2>
            <hr />
            
            <p>A printer collects the state during printing of a file or expression.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">bytes.Buffer
comment []Comment
margin int</code></pre>
         </article>
          
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <p>add returns the position at the end of s, assuming it starts at p.</p>
            
            <pre><code>func add(s string) Position</code></pre>
         </article>
         
         <article class="function" data-name="Comment">
            <h2>Comment</h2>
            <hr />
            
            <p>Comment returns the receiver. This isn't useful by itself, but
a [Comments] struct is embedded into all the expression
implementation types, and this gives each of those a Comment
method to satisfy the Expr interface.</p>
            
            <pre><code>func Comment() *Comments</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <pre><code>func Span() (start Position, end Position)</code></pre>
         </article>
         
         <article class="function" data-name="addLine">
            <h2>addLine</h2>
            <hr />
            
            <p>addLine adds a line containing the given tokens to the file.

If the first token of the hint matches the first token of the
line, the new line is added at the end of the block containing hint,
extracting hint into a new block if it is not yet in one.

If the hint is non-nil buts its first token does not match,
the new line is added after the block containing hint
(or hint itself, if not in a block).

If no hint is provided, addLine appends the line to the end of
the last block with a matching first token,
or to the end of the file if no such block exists.</p>
            
            <pre><code>func addLine(hint Expr, tokens ...string) *Line</code></pre>
         </article>
         
         <article class="function" data-name="updateLine">
            <h2>updateLine</h2>
            <hr />
            
            <pre><code>func updateLine(line *Line, tokens ...string)</code></pre>
         </article>
         
         <article class="function" data-name="markRemoved">
            <h2>markRemoved</h2>
            <hr />
            
            <p>markRemoved modifies line so that it (and its end-of-line comment, if any)
will be dropped by (*FileSyntax).Cleanup.</p>
            
            <pre><code>func markRemoved()</code></pre>
         </article>
         
         <article class="function" data-name="Cleanup">
            <h2>Cleanup</h2>
            <hr />
            
            <p>Cleanup cleans up the file syntax x after any edit operations.
To avoid quadratic behavior, (*Line).markRemoved marks the line as dead
by setting line.Token = nil but does not remove it from the slice
in which it appears. After edits have all been indicated,
calling Cleanup cleans out the dead lines.</p>
            
            <pre><code>func Cleanup()</code></pre>
         </article>
         
         <article class="function" data-name="commentsAdd">
            <h2>commentsAdd</h2>
            <hr />
            
            <pre><code>func commentsAdd(x []Comment, y []Comment) []Comment</code></pre>
         </article>
         
         <article class="function" data-name="stringsAdd">
            <h2>stringsAdd</h2>
            <hr />
            
            <pre><code>func stringsAdd(x []string, y []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <pre><code>func Span() (start Position, end Position)</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <pre><code>func Span() (start Position, end Position)</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <pre><code>func Span() (start Position, end Position)</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <pre><code>func Span() (start Position, end Position)</code></pre>
         </article>
         
         <article class="function" data-name="Span">
            <h2>Span</h2>
            <hr />
            
            <pre><code>func Span() (start Position, end Position)</code></pre>
         </article>
         
         <article class="function" data-name="newInput">
            <h2>newInput</h2>
            <hr />
            
            <pre><code>func newInput(filename string, data []byte) *input</code></pre>
         </article>
         
         <article class="function" data-name="parse">
            <h2>parse</h2>
            <hr />
            
            <p>parse parses the input file.</p>
            
            <pre><code>func parse(file string, data []byte) (f *FileSyntax, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <p>Error is called to report an error.
Error does not return: it panics.</p>
            
            <pre><code>func Error(s string)</code></pre>
         </article>
         
         <article class="function" data-name="eof">
            <h2>eof</h2>
            <hr />
            
            <p>eof reports whether the input has reached end of file.</p>
            
            <pre><code>func eof() bool</code></pre>
         </article>
         
         <article class="function" data-name="peekRune">
            <h2>peekRune</h2>
            <hr />
            
            <p>peekRune returns the next rune in the input without consuming it.</p>
            
            <pre><code>func peekRune() int</code></pre>
         </article>
         
         <article class="function" data-name="peekPrefix">
            <h2>peekPrefix</h2>
            <hr />
            
            <p>peekPrefix reports whether the remaining input begins with the given prefix.</p>
            
            <pre><code>func peekPrefix(prefix string) bool</code></pre>
         </article>
         
         <article class="function" data-name="readRune">
            <h2>readRune</h2>
            <hr />
            
            <p>readRune consumes and returns the next rune in the input.</p>
            
            <pre><code>func readRune() int</code></pre>
         </article>
         
         <article class="function" data-name="isComment">
            <h2>isComment</h2>
            <hr />
            
            <pre><code>func isComment() bool</code></pre>
         </article>
         
         <article class="function" data-name="isEOL">
            <h2>isEOL</h2>
            <hr />
            
            <p>isEOL returns whether a token terminates a line.</p>
            
            <pre><code>func isEOL() bool</code></pre>
         </article>
         
         <article class="function" data-name="startToken">
            <h2>startToken</h2>
            <hr />
            
            <p>startToken marks the beginning of the next input token.
It must be followed by a call to endToken, once the token's text has
been consumed using readRune.</p>
            
            <pre><code>func startToken()</code></pre>
         </article>
         
         <article class="function" data-name="endToken">
            <h2>endToken</h2>
            <hr />
            
            <p>endToken marks the end of an input token.
It records the actual token string in tok.text.
A single trailing newline (LF or CRLF) will be removed from comment tokens.</p>
            
            <pre><code>func endToken(kind tokenKind)</code></pre>
         </article>
         
         <article class="function" data-name="peek">
            <h2>peek</h2>
            <hr />
            
            <p>peek returns the kind of the next token returned by lex.</p>
            
            <pre><code>func peek() tokenKind</code></pre>
         </article>
         
         <article class="function" data-name="lex">
            <h2>lex</h2>
            <hr />
            
            <p>lex is called from the parser to obtain the next input token.</p>
            
            <pre><code>func lex() token</code></pre>
         </article>
         
         <article class="function" data-name="readToken">
            <h2>readToken</h2>
            <hr />
            
            <p>readToken lexes the next token from the text and stores it in in.token.</p>
            
            <pre><code>func readToken()</code></pre>
         </article>
         
         <article class="function" data-name="isIdent">
            <h2>isIdent</h2>
            <hr />
            
            <p>isIdent reports whether c is an identifier rune.
We treat most printable runes as identifier runes, except for a handful of
ASCII punctuation characters.</p>
            
            <pre><code>func isIdent(c int) bool</code></pre>
         </article>
         
         <article class="function" data-name="order">
            <h2>order</h2>
            <hr />
            
            <p>order walks the expression adding it and its subexpressions to the
preorder and postorder lists.</p>
            
            <pre><code>func order(x Expr)</code></pre>
         </article>
         
         <article class="function" data-name="assignComments">
            <h2>assignComments</h2>
            <hr />
            
            <p>assignComments attaches comments to nearby syntax.</p>
            
            <pre><code>func assignComments()</code></pre>
         </article>
         
         <article class="function" data-name="reverseComments">
            <h2>reverseComments</h2>
            <hr />
            
            <p>reverseComments reverses the []Comment list.</p>
            
            <pre><code>func reverseComments(list []Comment)</code></pre>
         </article>
         
         <article class="function" data-name="parseFile">
            <h2>parseFile</h2>
            <hr />
            
            <pre><code>func parseFile()</code></pre>
         </article>
         
         <article class="function" data-name="parseStmt">
            <h2>parseStmt</h2>
            <hr />
            
            <pre><code>func parseStmt()</code></pre>
         </article>
         
         <article class="function" data-name="parseLineBlock">
            <h2>parseLineBlock</h2>
            <hr />
            
            <pre><code>func parseLineBlock(start Position, token []string, lparen token) *LineBlock</code></pre>
         </article>
         
         <article class="function" data-name="parseLine">
            <h2>parseLine</h2>
            <hr />
            
            <pre><code>func parseLine() *Line</code></pre>
         </article>
         
         <article class="function" data-name="ModulePath">
            <h2>ModulePath</h2>
            <hr />
            
            <p>ModulePath returns the module path from the gomod file text.
If it cannot find a module path, it returns an empty string.
It is tolerant of unrelated problems in the go.mod file.</p>
            
            <pre><code>func ModulePath(mod []byte) string</code></pre>
         </article>
         
         <article class="function" data-name="markRemoved">
            <h2>markRemoved</h2>
            <hr />
            
            <pre><code>func markRemoved()</code></pre>
         </article>
         
         <article class="function" data-name="setVersion">
            <h2>setVersion</h2>
            <hr />
            
            <pre><code>func setVersion(v string)</code></pre>
         </article>
         
         <article class="function" data-name="setIndirect">
            <h2>setIndirect</h2>
            <hr />
            
            <p>setIndirect sets line to have (or not have) a "// indirect" comment.</p>
            
            <pre><code>func setIndirect(indirect bool)</code></pre>
         </article>
         
         <article class="function" data-name="isIndirect">
            <h2>isIndirect</h2>
            <hr />
            
            <p>isIndirect reports whether line has a "// indirect" comment,
meaning it is in go.mod only for its effect on indirect dependencies,
so that it can be dropped entirely once the effective version of the
indirect dependency reaches the given minimum version.</p>
            
            <pre><code>func isIndirect(line *Line) bool</code></pre>
         </article>
         
         <article class="function" data-name="AddModuleStmt">
            <h2>AddModuleStmt</h2>
            <hr />
            
            <pre><code>func AddModuleStmt(path string) error</code></pre>
         </article>
         
         <article class="function" data-name="AddComment">
            <h2>AddComment</h2>
            <hr />
            
            <pre><code>func AddComment(text string)</code></pre>
         </article>
         
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <p>Parse parses and returns a go.mod file.

file is the name of the file, used in positions and errors.

data is the content of the file.

fix is an optional function that canonicalizes module versions.
If fix is nil, all module versions must be canonical ([module.CanonicalVersion]
must return the same string).</p>
            
            <pre><code>func Parse(file string, data []byte, fix VersionFixer) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="ParseLax">
            <h2>ParseLax</h2>
            <hr />
            
            <p>ParseLax is like Parse but ignores unknown statements.
It is used when parsing go.mod files other than the main module,
under the theory that most statement types we add in the future will
only apply in the main module, like exclude and replace,
and so we get better gradual deployments if old go commands
simply ignore those statements when found in go.mod files
in dependencies.</p>
            
            <pre><code>func ParseLax(file string, data []byte, fix VersionFixer) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseToFile">
            <h2>parseToFile</h2>
            <hr />
            
            <pre><code>func parseToFile(file string, data []byte, fix VersionFixer, strict bool) (parsed *File, err error)</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <pre><code>func add(errs *ErrorList, block *LineBlock, line *Line, verb string, args []string, fix VersionFixer, strict bool)</code></pre>
         </article>
         
         <article class="function" data-name="parseReplace">
            <h2>parseReplace</h2>
            <hr />
            
            <pre><code>func parseReplace(filename string, line *Line, verb string, args []string, fix VersionFixer) (*Replace, *Error)</code></pre>
         </article>
         
         <article class="function" data-name="fixRetract">
            <h2>fixRetract</h2>
            <hr />
            
            <p>fixRetract applies fix to each retract directive in f, appending any errors
to errs.

Most versions are fixed as we parse the file, but for retract directives,
the relevant module path is the one specified with the module directive,
and that might appear at the end of the file (or not at all).</p>
            
            <pre><code>func fixRetract(fix VersionFixer, errs *ErrorList)</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <pre><code>func add(errs *ErrorList, line *Line, verb string, args []string, fix VersionFixer)</code></pre>
         </article>
         
         <article class="function" data-name="IsDirectoryPath">
            <h2>IsDirectoryPath</h2>
            <hr />
            
            <p>IsDirectoryPath reports whether the given path should be interpreted as a directory path.
Just like on the go command line, relative paths starting with a '.' or '..' path component
and rooted paths are directory paths; the rest are module paths.</p>
            
            <pre><code>func IsDirectoryPath(ns string) bool</code></pre>
         </article>
         
         <article class="function" data-name="MustQuote">
            <h2>MustQuote</h2>
            <hr />
            
            <p>MustQuote reports whether s must be quoted in order to appear as
a single token in a go.mod line.</p>
            
            <pre><code>func MustQuote(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="AutoQuote">
            <h2>AutoQuote</h2>
            <hr />
            
            <p>AutoQuote returns s or, if quoting is required for s to appear in a go.mod,
the quotation of s.</p>
            
            <pre><code>func AutoQuote(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="parseVersionInterval">
            <h2>parseVersionInterval</h2>
            <hr />
            
            <pre><code>func parseVersionInterval(verb string, path string, args *[]string, fix VersionFixer) (VersionInterval, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseString">
            <h2>parseString</h2>
            <hr />
            
            <pre><code>func parseString(s *string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseDeprecation">
            <h2>parseDeprecation</h2>
            <hr />
            
            <p>parseDeprecation extracts the text of comments on a "module" directive and
extracts a deprecation message from that.

A deprecation message is contained in a paragraph within a block of comments
that starts with "Deprecated:" (case sensitive). The message runs until the
end of the paragraph and does not include the "Deprecated:" prefix. If the
comment block has multiple paragraphs that start with "Deprecated:",
parseDeprecation returns the message from the first.</p>
            
            <pre><code>func parseDeprecation(block *LineBlock, line *Line) string</code></pre>
         </article>
         
         <article class="function" data-name="parseDirectiveComment">
            <h2>parseDirectiveComment</h2>
            <hr />
            
            <p>parseDirectiveComment extracts the text of comments on a directive.
If the directive's line does not have comments and is part of a block that
does have comments, the block's comments are used.</p>
            
            <pre><code>func parseDirectiveComment(block *LineBlock, line *Line) string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="parseVersion">
            <h2>parseVersion</h2>
            <hr />
            
            <pre><code>func parseVersion(verb string, path string, s *string, fix VersionFixer) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="modulePathMajor">
            <h2>modulePathMajor</h2>
            <hr />
            
            <pre><code>func modulePathMajor(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Format">
            <h2>Format</h2>
            <hr />
            
            <pre><code>func Format() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="Cleanup">
            <h2>Cleanup</h2>
            <hr />
            
            <p>Cleanup cleans up the file f after any edit operations.
To avoid quadratic behavior, modifications like [File.DropRequire]
clear the entry but do not remove it from the slice.
Cleanup cleans out all the cleared entries.</p>
            
            <pre><code>func Cleanup()</code></pre>
         </article>
         
         <article class="function" data-name="AddGoStmt">
            <h2>AddGoStmt</h2>
            <hr />
            
            <pre><code>func AddGoStmt(version string) error</code></pre>
         </article>
         
         <article class="function" data-name="DropGoStmt">
            <h2>DropGoStmt</h2>
            <hr />
            
            <p>DropGoStmt deletes the go statement from the file.</p>
            
            <pre><code>func DropGoStmt()</code></pre>
         </article>
         
         <article class="function" data-name="DropToolchainStmt">
            <h2>DropToolchainStmt</h2>
            <hr />
            
            <p>DropToolchainStmt deletes the toolchain statement from the file.</p>
            
            <pre><code>func DropToolchainStmt()</code></pre>
         </article>
         
         <article class="function" data-name="AddToolchainStmt">
            <h2>AddToolchainStmt</h2>
            <hr />
            
            <pre><code>func AddToolchainStmt(name string) error</code></pre>
         </article>
         
         <article class="function" data-name="AddGodebug">
            <h2>AddGodebug</h2>
            <hr />
            
            <p>AddGodebug sets the first godebug line for key to value,
preserving any existing comments for that line and removing all
other godebug lines for key.

If no line currently exists for key, AddGodebug adds a new line
at the end of the last godebug block.</p>
            
            <pre><code>func AddGodebug(key string, value string) error</code></pre>
         </article>
         
         <article class="function" data-name="addNewGodebug">
            <h2>addNewGodebug</h2>
            <hr />
            
            <p>addNewGodebug adds a new godebug key=value line at the end
of the last godebug block, regardless of any existing godebug lines for key.</p>
            
            <pre><code>func addNewGodebug(key string, value string)</code></pre>
         </article>
         
         <article class="function" data-name="AddRequire">
            <h2>AddRequire</h2>
            <hr />
            
            <p>AddRequire sets the first require line for path to version vers,
preserving any existing comments for that line and removing all
other lines for path.

If no line currently exists for path, AddRequire adds a new line
at the end of the last require block.</p>
            
            <pre><code>func AddRequire(path string, vers string) error</code></pre>
         </article>
         
         <article class="function" data-name="AddNewRequire">
            <h2>AddNewRequire</h2>
            <hr />
            
            <p>AddNewRequire adds a new require line for path at version vers at the end of
the last require block, regardless of any existing require lines for path.</p>
            
            <pre><code>func AddNewRequire(path string, vers string, indirect bool)</code></pre>
         </article>
         
         <article class="function" data-name="SetRequire">
            <h2>SetRequire</h2>
            <hr />
            
            <p>SetRequire updates the requirements of f to contain exactly req, preserving
the existing block structure and line comment contents (except for 'indirect'
markings) for the first requirement on each named module path.

The Syntax field is ignored for the requirements in req.

Any requirements not already present in the file are added to the block
containing the last require line.

The requirements in req must specify at most one distinct version for each
module path.

If any existing requirements may be removed, the caller should call
[File.Cleanup] after all edits are complete.</p>
            
            <pre><code>func SetRequire(req []*Require)</code></pre>
         </article>
         
         <article class="function" data-name="SetRequireSeparateIndirect">
            <h2>SetRequireSeparateIndirect</h2>
            <hr />
            
            <p>SetRequireSeparateIndirect updates the requirements of f to contain the given
requirements. Comment contents (except for 'indirect' markings) are retained
from the first existing requirement for each module path. Like SetRequire,
SetRequireSeparateIndirect adds requirements for new paths in req,
updates the version and "// indirect" comment on existing requirements,
and deletes requirements on paths not in req. Existing duplicate requirements
are deleted.

As its name suggests, SetRequireSeparateIndirect puts direct and indirect
requirements into two separate blocks, one containing only direct
requirements, and the other containing only indirect requirements.
SetRequireSeparateIndirect may move requirements between these two blocks
when their indirect markings change. However, SetRequireSeparateIndirect
won't move requirements from other blocks, especially blocks with comments.

If the file initially has one uncommented block of requirements,
SetRequireSeparateIndirect will split it into a direct-only and indirect-only
block. This aids in the transition to separate blocks.</p>
            
            <pre><code>func SetRequireSeparateIndirect(req []*Require)</code></pre>
         </article>
         
         <article class="function" data-name="DropGodebug">
            <h2>DropGodebug</h2>
            <hr />
            
            <pre><code>func DropGodebug(key string) error</code></pre>
         </article>
         
         <article class="function" data-name="DropRequire">
            <h2>DropRequire</h2>
            <hr />
            
            <pre><code>func DropRequire(path string) error</code></pre>
         </article>
         
         <article class="function" data-name="AddExclude">
            <h2>AddExclude</h2>
            <hr />
            
            <p>AddExclude adds a exclude statement to the mod file. Errors if the provided
version is not a canonical version string</p>
            
            <pre><code>func AddExclude(path string, vers string) error</code></pre>
         </article>
         
         <article class="function" data-name="DropExclude">
            <h2>DropExclude</h2>
            <hr />
            
            <pre><code>func DropExclude(path string, vers string) error</code></pre>
         </article>
         
         <article class="function" data-name="AddReplace">
            <h2>AddReplace</h2>
            <hr />
            
            <pre><code>func AddReplace(oldPath string, oldVers string, newPath string, newVers string) error</code></pre>
         </article>
         
         <article class="function" data-name="addReplace">
            <h2>addReplace</h2>
            <hr />
            
            <pre><code>func addReplace(syntax *FileSyntax, replace *[]*Replace, oldPath string, oldVers string, newPath string, newVers string) error</code></pre>
         </article>
         
         <article class="function" data-name="DropReplace">
            <h2>DropReplace</h2>
            <hr />
            
            <pre><code>func DropReplace(oldPath string, oldVers string) error</code></pre>
         </article>
         
         <article class="function" data-name="AddRetract">
            <h2>AddRetract</h2>
            <hr />
            
            <p>AddRetract adds a retract statement to the mod file. Errors if the provided
version interval does not consist of canonical version strings</p>
            
            <pre><code>func AddRetract(vi VersionInterval, rationale string) error</code></pre>
         </article>
         
         <article class="function" data-name="DropRetract">
            <h2>DropRetract</h2>
            <hr />
            
            <pre><code>func DropRetract(vi VersionInterval) error</code></pre>
         </article>
         
         <article class="function" data-name="AddTool">
            <h2>AddTool</h2>
            <hr />
            
            <p>AddTool adds a new tool directive with the given path.
It does nothing if the tool line already exists.</p>
            
            <pre><code>func AddTool(path string) error</code></pre>
         </article>
         
         <article class="function" data-name="DropTool">
            <h2>DropTool</h2>
            <hr />
            
            <p>RemoveTool removes a tool directive with the given path.
It does nothing if no such tool directive exists.</p>
            
            <pre><code>func DropTool(path string) error</code></pre>
         </article>
         
         <article class="function" data-name="SortBlocks">
            <h2>SortBlocks</h2>
            <hr />
            
            <pre><code>func SortBlocks()</code></pre>
         </article>
         
         <article class="function" data-name="removeDups">
            <h2>removeDups</h2>
            <hr />
            
            <p>removeDups removes duplicate exclude, replace and tool directives.

Earlier exclude and tool directives take priority.

Later replace directives take priority.

require directives are not de-duplicated. That's left up to higher-level
logic (MVS).

retract directives are not de-duplicated since comments are
meaningful, and versions may be retracted multiple times.</p>
            
            <pre><code>func removeDups()</code></pre>
         </article>
         
         <article class="function" data-name="removeDups">
            <h2>removeDups</h2>
            <hr />
            
            <pre><code>func removeDups(syntax *FileSyntax, exclude *[]*Exclude, replace *[]*Replace, tool *[]*Tool)</code></pre>
         </article>
         
         <article class="function" data-name="lineLess">
            <h2>lineLess</h2>
            <hr />
            
            <p>lineLess returns whether li should be sorted before lj. It sorts
lexicographically without assigning any special meaning to tokens.</p>
            
            <pre><code>func lineLess(li *Line, lj *Line) bool</code></pre>
         </article>
         
         <article class="function" data-name="lineExcludeLess">
            <h2>lineExcludeLess</h2>
            <hr />
            
            <p>lineExcludeLess reports whether li should be sorted before lj for lines in
an "exclude" block.</p>
            
            <pre><code>func lineExcludeLess(li *Line, lj *Line) bool</code></pre>
         </article>
         
         <article class="function" data-name="lineRetractLess">
            <h2>lineRetractLess</h2>
            <hr />
            
            <p>lineRetractLess returns whether li should be sorted before lj for lines in
a "retract" block. It treats each line as a version interval. Single versions
are compared as if they were intervals with the same low and high version.
Intervals are sorted in descending order, first by low version, then by
high version, using semver.Compare.</p>
            
            <pre><code>func lineRetractLess(li *Line, lj *Line) bool</code></pre>
         </article>
         
         <article class="function" data-name="checkCanonicalVersion">
            <h2>checkCanonicalVersion</h2>
            <hr />
            
            <p>checkCanonicalVersion returns a non-nil error if vers is not a canonical
version string or does not match the major version of path.

If path is non-empty, the error text suggests a format with a major version
corresponding to the path.</p>
            
            <pre><code>func checkCanonicalVersion(path string, vers string) error</code></pre>
         </article>
         
         <article class="function" data-name="ParseWork">
            <h2>ParseWork</h2>
            <hr />
            
            <p>ParseWork parses and returns a go.work file.

file is the name of the file, used in positions and errors.

data is the content of the file.

fix is an optional function that canonicalizes module versions.
If fix is nil, all module versions must be canonical ([module.CanonicalVersion]
must return the same string).</p>
            
            <pre><code>func ParseWork(file string, data []byte, fix VersionFixer) (*WorkFile, error)</code></pre>
         </article>
         
         <article class="function" data-name="Cleanup">
            <h2>Cleanup</h2>
            <hr />
            
            <p>Cleanup cleans up the file f after any edit operations.
To avoid quadratic behavior, modifications like [WorkFile.DropRequire]
clear the entry but do not remove it from the slice.
Cleanup cleans out all the cleared entries.</p>
            
            <pre><code>func Cleanup()</code></pre>
         </article>
         
         <article class="function" data-name="AddGoStmt">
            <h2>AddGoStmt</h2>
            <hr />
            
            <pre><code>func AddGoStmt(version string) error</code></pre>
         </article>
         
         <article class="function" data-name="AddToolchainStmt">
            <h2>AddToolchainStmt</h2>
            <hr />
            
            <pre><code>func AddToolchainStmt(name string) error</code></pre>
         </article>
         
         <article class="function" data-name="DropGoStmt">
            <h2>DropGoStmt</h2>
            <hr />
            
            <p>DropGoStmt deletes the go statement from the file.</p>
            
            <pre><code>func DropGoStmt()</code></pre>
         </article>
         
         <article class="function" data-name="DropToolchainStmt">
            <h2>DropToolchainStmt</h2>
            <hr />
            
            <p>DropToolchainStmt deletes the toolchain statement from the file.</p>
            
            <pre><code>func DropToolchainStmt()</code></pre>
         </article>
         
         <article class="function" data-name="AddGodebug">
            <h2>AddGodebug</h2>
            <hr />
            
            <p>AddGodebug sets the first godebug line for key to value,
preserving any existing comments for that line and removing all
other godebug lines for key.

If no line currently exists for key, AddGodebug adds a new line
at the end of the last godebug block.</p>
            
            <pre><code>func AddGodebug(key string, value string) error</code></pre>
         </article>
         
         <article class="function" data-name="addNewGodebug">
            <h2>addNewGodebug</h2>
            <hr />
            
            <p>addNewGodebug adds a new godebug key=value line at the end
of the last godebug block, regardless of any existing godebug lines for key.</p>
            
            <pre><code>func addNewGodebug(key string, value string)</code></pre>
         </article>
         
         <article class="function" data-name="DropGodebug">
            <h2>DropGodebug</h2>
            <hr />
            
            <pre><code>func DropGodebug(key string) error</code></pre>
         </article>
         
         <article class="function" data-name="AddUse">
            <h2>AddUse</h2>
            <hr />
            
            <pre><code>func AddUse(diskPath string, modulePath string) error</code></pre>
         </article>
         
         <article class="function" data-name="AddNewUse">
            <h2>AddNewUse</h2>
            <hr />
            
            <pre><code>func AddNewUse(diskPath string, modulePath string)</code></pre>
         </article>
         
         <article class="function" data-name="SetUse">
            <h2>SetUse</h2>
            <hr />
            
            <pre><code>func SetUse(dirs []*Use)</code></pre>
         </article>
         
         <article class="function" data-name="DropUse">
            <h2>DropUse</h2>
            <hr />
            
            <pre><code>func DropUse(path string) error</code></pre>
         </article>
         
         <article class="function" data-name="AddReplace">
            <h2>AddReplace</h2>
            <hr />
            
            <pre><code>func AddReplace(oldPath string, oldVers string, newPath string, newVers string) error</code></pre>
         </article>
         
         <article class="function" data-name="DropReplace">
            <h2>DropReplace</h2>
            <hr />
            
            <pre><code>func DropReplace(oldPath string, oldVers string) error</code></pre>
         </article>
         
         <article class="function" data-name="SortBlocks">
            <h2>SortBlocks</h2>
            <hr />
            
            <pre><code>func SortBlocks()</code></pre>
         </article>
         
         <article class="function" data-name="removeDups">
            <h2>removeDups</h2>
            <hr />
            
            <p>removeDups removes duplicate replace directives.

Later replace directives take priority.

require directives are not de-duplicated. That's left up to higher-level
logic (MVS).

retract directives are not de-duplicated since comments are
meaningful, and versions may be retracted multiple times.</p>
            
            <pre><code>func removeDups()</code></pre>
         </article>
         
         <article class="function" data-name="Format">
            <h2>Format</h2>
            <hr />
            
            <p>Format returns a go.mod file as a byte slice, formatted in standard style.</p>
            
            <pre><code>func Format(f *FileSyntax) []byte</code></pre>
         </article>
         
         <article class="function" data-name="printf">
            <h2>printf</h2>
            <hr />
            
            <p>printf prints to the buffer.</p>
            
            <pre><code>func printf(format string, args ...*ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="indent">
            <h2>indent</h2>
            <hr />
            
            <p>indent returns the position on the current line, in bytes, 0-indexed.</p>
            
            <pre><code>func indent() int</code></pre>
         </article>
         
         <article class="function" data-name="newline">
            <h2>newline</h2>
            <hr />
            
            <p>newline ends the current line, flushing end-of-line comments.</p>
            
            <pre><code>func newline()</code></pre>
         </article>
         
         <article class="function" data-name="trim">
            <h2>trim</h2>
            <hr />
            
            <p>trim removes trailing spaces and tabs from the current line.</p>
            
            <pre><code>func trim()</code></pre>
         </article>
         
         <article class="function" data-name="file">
            <h2>file</h2>
            <hr />
            
            <p>file formats the given file into the print buffer.</p>
            
            <pre><code>func file(f *FileSyntax)</code></pre>
         </article>
         
         <article class="function" data-name="expr">
            <h2>expr</h2>
            <hr />
            
            <pre><code>func expr(x Expr)</code></pre>
         </article>
         
         <article class="function" data-name="tokens">
            <h2>tokens</h2>
            <hr />
            
            <pre><code>func tokens(tokens []string)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
