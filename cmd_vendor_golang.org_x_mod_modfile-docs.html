<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - modfile</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>modfile</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"sort"
"strings"
"bytes"
"fmt"
"strings"
"bytes"
"errors"
"fmt"
"os"
"strconv"
"strings"
"unicode"
"unicode/utf8"
"errors"
"fmt"
"path/filepath"
"sort"
"strconv"
"strings"
"unicode"
"golang.org/x/mod/internal/lazyregexp"
"golang.org/x/mod/module"
"golang.org/x/mod/semver"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="GoVersionRE" data-name="GoVersionRE">
               <h3>
                  GoVersionRE 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#GoVersionRE" class="anchor" title="Link to GoVersionRE">#</a>
               </h3>
               
               <pre><code class="language-go">var GoVersionRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ToolchainRE" data-name="ToolchainRE">
               <h3>
                  ToolchainRE 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ToolchainRE" class="anchor" title="Link to ToolchainRE">#</a>
               </h3>
               
                  <p class="doc-comment">Toolchains must be named beginning with `go1`,
like "go1.20.3" or "go1.20.3-gccgo". As a special case, "default" is also permitted.
Note that this regexp is a much looser condition than go/version.IsValid,
for forward compatibility.
(This code has to be work to identify new toolchains even if we tweak the syntax in the future.)</p>
               
               <pre><code class="language-go">var ToolchainRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_COMMENT" data-name="_COMMENT">
               <h3>
                  _COMMENT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_COMMENT" class="anchor" title="Link to _COMMENT">#</a>
               </h3>
               
               <pre><code class="language-go">const _COMMENT</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_EOF" data-name="_EOF">
               <h3>
                  _EOF 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_EOF" class="anchor" title="Link to _EOF">#</a>
               </h3>
               
               <pre><code class="language-go">const _EOF tokenKind = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_EOLCOMMENT" data-name="_EOLCOMMENT">
               <h3>
                  _EOLCOMMENT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_EOLCOMMENT" class="anchor" title="Link to _EOLCOMMENT">#</a>
               </h3>
               
               <pre><code class="language-go">const _EOLCOMMENT</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_IDENT" data-name="_IDENT">
               <h3>
                  _IDENT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_IDENT" class="anchor" title="Link to _IDENT">#</a>
               </h3>
               
               <pre><code class="language-go">const _IDENT</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_STRING" data-name="_STRING">
               <h3>
                  _STRING 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_STRING" class="anchor" title="Link to _STRING">#</a>
               </h3>
               
               <pre><code class="language-go">const _STRING</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="deprecatedRE" data-name="deprecatedRE">
               <h3>
                  deprecatedRE 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#deprecatedRE" class="anchor" title="Link to deprecatedRE">#</a>
               </h3>
               
               <pre><code class="language-go">var deprecatedRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dontFixRetract" data-name="dontFixRetract">
               <h3>
                  dontFixRetract 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dontFixRetract" class="anchor" title="Link to dontFixRetract">#</a>
               </h3>
               
                  <p class="doc-comment">errDontFix is returned by a VersionFixer to indicate the version should be
left alone, even if it's not canonical.</p>
               
               <pre><code class="language-go">var dontFixRetract VersionFixer = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="laxGoVersionRE" data-name="laxGoVersionRE">
               <h3>
                  laxGoVersionRE 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#laxGoVersionRE" class="anchor" title="Link to laxGoVersionRE">#</a>
               </h3>
               
               <pre><code class="language-go">var laxGoVersionRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="moduleStr" data-name="moduleStr">
               <h3>
                  moduleStr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#moduleStr" class="anchor" title="Link to moduleStr">#</a>
               </h3>
               
               <pre><code class="language-go">var moduleStr = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="slashSlash" data-name="slashSlash">
               <h3>
                  slashSlash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#slashSlash" class="anchor" title="Link to slashSlash">#</a>
               </h3>
               
               <pre><code class="language-go">var slashSlash = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ErrorList" data-name="ErrorList">
               <h3>
                  ErrorList
                  <span class="badge type-badge">type</span>
                  <a href="#ErrorList" class="anchor" title="Link to ErrorList">#</a>
               </h3>
               
               <pre><code class="language-go">type ErrorList []Error</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="VersionFixer" data-name="VersionFixer">
               <h3>
                  VersionFixer
                  <span class="badge type-badge">type</span>
                  <a href="#VersionFixer" class="anchor" title="Link to VersionFixer">#</a>
               </h3>
               
               <pre><code class="language-go">type VersionFixer func(path string, version string) (string, error)</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="tokenKind" data-name="tokenKind">
               <h3>
                  tokenKind
                  <span class="badge type-badge">type</span>
                  <a href="#tokenKind" class="anchor" title="Link to tokenKind">#</a>
               </h3>
               
               <pre><code class="language-go">type tokenKind int</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Expr" data-name="Expr">
               <h3>
                  Expr
                  <span class="badge interface-badge">interface</span>
                  <a href="#Expr" class="anchor" title="Link to Expr">#</a>
               </h3>
               
               <p>An Expr represents an input element.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Expr interface {
Span() (start Position, end Position)
Comment() *Comments
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Comment" data-name="Comment">
               <h3>
                  Comment
                  <span class="badge">struct</span>
                  <a href="#Comment" class="anchor" title="Link to Comment">#</a>
               </h3>
               
               <p>A Comment represents a single // comment.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Comment struct {
Start Position
Token string
Suffix bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="CommentBlock" data-name="CommentBlock">
               <h3>
                  CommentBlock
                  <span class="badge">struct</span>
                  <a href="#CommentBlock" class="anchor" title="Link to CommentBlock">#</a>
               </h3>
               
               <p>A CommentBlock represents a top-level block of comments separate
from any rule.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type CommentBlock struct {
Comments
Start Position
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Comments" data-name="Comments">
               <h3>
                  Comments
                  <span class="badge">struct</span>
                  <a href="#Comments" class="anchor" title="Link to Comments">#</a>
               </h3>
               
               <p>Comments collects the comments associated with an expression.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Comments struct {
Before []Comment
Suffix []Comment
After []Comment
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error
                  <span class="badge">struct</span>
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Error struct {
Filename string
Pos Position
Verb string
ModPath string
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Exclude" data-name="Exclude">
               <h3>
                  Exclude
                  <span class="badge">struct</span>
                  <a href="#Exclude" class="anchor" title="Link to Exclude">#</a>
               </h3>
               
               <p>An Exclude is a single exclude statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Exclude struct {
Mod module.Version
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="File" data-name="File">
               <h3>
                  File
                  <span class="badge">struct</span>
                  <a href="#File" class="anchor" title="Link to File">#</a>
               </h3>
               
               <p>A File is the parsed, interpreted form of a go.mod file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type File struct {
Module *Module
Go *Go
Toolchain *Toolchain
Godebug []*Godebug
Require []*Require
Exclude []*Exclude
Replace []*Replace
Retract []*Retract
Tool []*Tool
Syntax *FileSyntax
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="FileSyntax" data-name="FileSyntax">
               <h3>
                  FileSyntax
                  <span class="badge">struct</span>
                  <a href="#FileSyntax" class="anchor" title="Link to FileSyntax">#</a>
               </h3>
               
               <p>A FileSyntax represents an entire go.mod file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type FileSyntax struct {
Name string
Comments
Stmt []Expr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Go" data-name="Go">
               <h3>
                  Go
                  <span class="badge">struct</span>
                  <a href="#Go" class="anchor" title="Link to Go">#</a>
               </h3>
               
               <p>A Go is the go statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Go struct {
Version string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Godebug" data-name="Godebug">
               <h3>
                  Godebug
                  <span class="badge">struct</span>
                  <a href="#Godebug" class="anchor" title="Link to Godebug">#</a>
               </h3>
               
               <p>A Godebug is a single godebug key=value statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Godebug struct {
Key string
Value string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="LParen" data-name="LParen">
               <h3>
                  LParen
                  <span class="badge">struct</span>
                  <a href="#LParen" class="anchor" title="Link to LParen">#</a>
               </h3>
               
               <p>An LParen represents the beginning of a parenthesized line block.
It is a place to store suffix comments.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type LParen struct {
Comments
Pos Position
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Line" data-name="Line">
               <h3>
                  Line
                  <span class="badge">struct</span>
                  <a href="#Line" class="anchor" title="Link to Line">#</a>
               </h3>
               
               <p>A Line is a single line of tokens.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Line struct {
Comments
Start Position
Token []string
InBlock bool
End Position
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="LineBlock" data-name="LineBlock">
               <h3>
                  LineBlock
                  <span class="badge">struct</span>
                  <a href="#LineBlock" class="anchor" title="Link to LineBlock">#</a>
               </h3>
               
               <p>A LineBlock is a factored block of lines, like
require (
"x"
"y"
)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type LineBlock struct {
Comments
Start Position
LParen LParen
Token []string
Line []*Line
RParen RParen
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Module" data-name="Module">
               <h3>
                  Module
                  <span class="badge">struct</span>
                  <a href="#Module" class="anchor" title="Link to Module">#</a>
               </h3>
               
               <p>A Module is the module statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Module struct {
Mod module.Version
Deprecated string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Position" data-name="Position">
               <h3>
                  Position
                  <span class="badge">struct</span>
                  <a href="#Position" class="anchor" title="Link to Position">#</a>
               </h3>
               
               <p>A Position describes an arbitrary source position in a file, including the
file, line, column, and byte offset.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Position struct {
Line int
LineRune int
Byte int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="RParen" data-name="RParen">
               <h3>
                  RParen
                  <span class="badge">struct</span>
                  <a href="#RParen" class="anchor" title="Link to RParen">#</a>
               </h3>
               
               <p>An RParen represents the end of a parenthesized line block.
It is a place to store whole-line (before) comments.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type RParen struct {
Comments
Pos Position
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Replace" data-name="Replace">
               <h3>
                  Replace
                  <span class="badge">struct</span>
                  <a href="#Replace" class="anchor" title="Link to Replace">#</a>
               </h3>
               
               <p>A Replace is a single replace statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Replace struct {
Old module.Version
New module.Version
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Require" data-name="Require">
               <h3>
                  Require
                  <span class="badge">struct</span>
                  <a href="#Require" class="anchor" title="Link to Require">#</a>
               </h3>
               
               <p>A Require is a single require statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Require struct {
Mod module.Version
Indirect bool
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Retract" data-name="Retract">
               <h3>
                  Retract
                  <span class="badge">struct</span>
                  <a href="#Retract" class="anchor" title="Link to Retract">#</a>
               </h3>
               
               <p>A Retract is a single retract statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Retract struct {
VersionInterval
Rationale string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Tool" data-name="Tool">
               <h3>
                  Tool
                  <span class="badge">struct</span>
                  <a href="#Tool" class="anchor" title="Link to Tool">#</a>
               </h3>
               
               <p>A Tool is a single tool statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Tool struct {
Path string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Toolchain" data-name="Toolchain">
               <h3>
                  Toolchain
                  <span class="badge">struct</span>
                  <a href="#Toolchain" class="anchor" title="Link to Toolchain">#</a>
               </h3>
               
               <p>A Toolchain is the toolchain statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Toolchain struct {
Name string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Use" data-name="Use">
               <h3>
                  Use
                  <span class="badge">struct</span>
                  <a href="#Use" class="anchor" title="Link to Use">#</a>
               </h3>
               
               <p>A Use is a single directory statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Use struct {
Path string
ModulePath string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="VersionInterval" data-name="VersionInterval">
               <h3>
                  VersionInterval
                  <span class="badge">struct</span>
                  <a href="#VersionInterval" class="anchor" title="Link to VersionInterval">#</a>
               </h3>
               
               <p>A VersionInterval represents a range of versions with upper and lower bounds.
Intervals are closed: both bounds are included. When Low is equal to High,
the interval may refer to a single version ('v1.2.3') or an interval
('[v1.2.3, v1.2.3]'); both have the same representation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type VersionInterval struct {
Low string
High string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="WorkFile" data-name="WorkFile">
               <h3>
                  WorkFile
                  <span class="badge">struct</span>
                  <a href="#WorkFile" class="anchor" title="Link to WorkFile">#</a>
               </h3>
               
               <p>A WorkFile is the parsed, interpreted form of a go.work file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type WorkFile struct {
Go *Go
Toolchain *Toolchain
Godebug []*Godebug
Use []*Use
Replace []*Replace
Syntax *FileSyntax
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="input" data-name="input">
               <h3>
                  input
                  <span class="badge">struct</span>
                  <a href="#input" class="anchor" title="Link to input">#</a>
               </h3>
               
               <p>An input represents a single input file being parsed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type input struct {
filename string
complete []byte
remaining []byte
tokenStart []byte
token token
pos Position
comments []Comment
file *FileSyntax
parseErrors ErrorList
pre []Expr
post []Expr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="printer" data-name="printer">
               <h3>
                  printer
                  <span class="badge">struct</span>
                  <a href="#printer" class="anchor" title="Link to printer">#</a>
               </h3>
               
               <p>A printer collects the state during printing of a file or expression.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type printer struct {
bytes.Buffer
comment []Comment
margin int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="token" data-name="token">
               <h3>
                  token
                  <span class="badge">struct</span>
                  <a href="#token" class="anchor" title="Link to token">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type token struct {
kind tokenKind
pos Position
endPos Position
text string
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AddComment" data-name="AddComment">
               <h3>
                  AddComment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddComment" class="anchor" title="Link to AddComment">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) AddComment(text string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddExclude" data-name="AddExclude">
               <h3>
                  AddExclude 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddExclude" class="anchor" title="Link to AddExclude">#</a>
               </h3>
               
               <p>AddExclude adds a exclude statement to the mod file. Errors if the provided
version is not a canonical version string</p>
               
               <pre><code class="language-go">func (f *File) AddExclude(path string, vers string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddGoStmt" data-name="AddGoStmt">
               <h3>
                  AddGoStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddGoStmt" class="anchor" title="Link to AddGoStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) AddGoStmt(version string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddGoStmt" data-name="AddGoStmt">
               <h3>
                  AddGoStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddGoStmt" class="anchor" title="Link to AddGoStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *WorkFile) AddGoStmt(version string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddGodebug" data-name="AddGodebug">
               <h3>
                  AddGodebug 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddGodebug" class="anchor" title="Link to AddGodebug">#</a>
               </h3>
               
               <p>AddGodebug sets the first godebug line for key to value,
preserving any existing comments for that line and removing all
other godebug lines for key.
If no line currently exists for key, AddGodebug adds a new line
at the end of the last godebug block.</p>
               
               <pre><code class="language-go">func (f *File) AddGodebug(key string, value string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddGodebug" data-name="AddGodebug">
               <h3>
                  AddGodebug 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddGodebug" class="anchor" title="Link to AddGodebug">#</a>
               </h3>
               
               <p>AddGodebug sets the first godebug line for key to value,
preserving any existing comments for that line and removing all
other godebug lines for key.
If no line currently exists for key, AddGodebug adds a new line
at the end of the last godebug block.</p>
               
               <pre><code class="language-go">func (f *WorkFile) AddGodebug(key string, value string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddModuleStmt" data-name="AddModuleStmt">
               <h3>
                  AddModuleStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddModuleStmt" class="anchor" title="Link to AddModuleStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) AddModuleStmt(path string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddNewRequire" data-name="AddNewRequire">
               <h3>
                  AddNewRequire 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddNewRequire" class="anchor" title="Link to AddNewRequire">#</a>
               </h3>
               
               <p>AddNewRequire adds a new require line for path at version vers at the end of
the last require block, regardless of any existing require lines for path.</p>
               
               <pre><code class="language-go">func (f *File) AddNewRequire(path string, vers string, indirect bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddNewUse" data-name="AddNewUse">
               <h3>
                  AddNewUse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddNewUse" class="anchor" title="Link to AddNewUse">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *WorkFile) AddNewUse(diskPath string, modulePath string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddReplace" data-name="AddReplace">
               <h3>
                  AddReplace 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddReplace" class="anchor" title="Link to AddReplace">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) AddReplace(oldPath string, oldVers string, newPath string, newVers string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddReplace" data-name="AddReplace">
               <h3>
                  AddReplace 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddReplace" class="anchor" title="Link to AddReplace">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *WorkFile) AddReplace(oldPath string, oldVers string, newPath string, newVers string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddRequire" data-name="AddRequire">
               <h3>
                  AddRequire 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddRequire" class="anchor" title="Link to AddRequire">#</a>
               </h3>
               
               <p>AddRequire sets the first require line for path to version vers,
preserving any existing comments for that line and removing all
other lines for path.
If no line currently exists for path, AddRequire adds a new line
at the end of the last require block.</p>
               
               <pre><code class="language-go">func (f *File) AddRequire(path string, vers string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddRetract" data-name="AddRetract">
               <h3>
                  AddRetract 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddRetract" class="anchor" title="Link to AddRetract">#</a>
               </h3>
               
               <p>AddRetract adds a retract statement to the mod file. Errors if the provided
version interval does not consist of canonical version strings</p>
               
               <pre><code class="language-go">func (f *File) AddRetract(vi VersionInterval, rationale string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddTool" data-name="AddTool">
               <h3>
                  AddTool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddTool" class="anchor" title="Link to AddTool">#</a>
               </h3>
               
               <p>AddTool adds a new tool directive with the given path.
It does nothing if the tool line already exists.</p>
               
               <pre><code class="language-go">func (f *File) AddTool(path string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddToolchainStmt" data-name="AddToolchainStmt">
               <h3>
                  AddToolchainStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddToolchainStmt" class="anchor" title="Link to AddToolchainStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) AddToolchainStmt(name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddToolchainStmt" data-name="AddToolchainStmt">
               <h3>
                  AddToolchainStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddToolchainStmt" class="anchor" title="Link to AddToolchainStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *WorkFile) AddToolchainStmt(name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AddUse" data-name="AddUse">
               <h3>
                  AddUse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AddUse" class="anchor" title="Link to AddUse">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *WorkFile) AddUse(diskPath string, modulePath string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AutoQuote" data-name="AutoQuote">
               <h3>
                  AutoQuote 
                  <span class="badge">function</span>
                  
                  <a href="#AutoQuote" class="anchor" title="Link to AutoQuote">#</a>
               </h3>
               
               <p>AutoQuote returns s or, if quoting is required for s to appear in a go.mod,
the quotation of s.</p>
               
               <pre><code class="language-go">func AutoQuote(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cleanup" data-name="Cleanup">
               <h3>
                  Cleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cleanup" class="anchor" title="Link to Cleanup">#</a>
               </h3>
               
               <p>Cleanup cleans up the file syntax x after any edit operations.
To avoid quadratic behavior, (*Line).markRemoved marks the line as dead
by setting line.Token = nil but does not remove it from the slice
in which it appears. After edits have all been indicated,
calling Cleanup cleans out the dead lines.</p>
               
               <pre><code class="language-go">func (x *FileSyntax) Cleanup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cleanup" data-name="Cleanup">
               <h3>
                  Cleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cleanup" class="anchor" title="Link to Cleanup">#</a>
               </h3>
               
               <p>Cleanup cleans up the file f after any edit operations.
To avoid quadratic behavior, modifications like [File.DropRequire]
clear the entry but do not remove it from the slice.
Cleanup cleans out all the cleared entries.</p>
               
               <pre><code class="language-go">func (f *File) Cleanup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Cleanup" data-name="Cleanup">
               <h3>
                  Cleanup 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Cleanup" class="anchor" title="Link to Cleanup">#</a>
               </h3>
               
               <p>Cleanup cleans up the file f after any edit operations.
To avoid quadratic behavior, modifications like [WorkFile.DropRequire]
clear the entry but do not remove it from the slice.
Cleanup cleans out all the cleared entries.</p>
               
               <pre><code class="language-go">func (f *WorkFile) Cleanup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Comment" data-name="Comment">
               <h3>
                  Comment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Comment" class="anchor" title="Link to Comment">#</a>
               </h3>
               
               <p>Comment returns the receiver. This isn't useful by itself, but
a [Comments] struct is embedded into all the expression
implementation types, and this gives each of those a Comment
method to satisfy the Expr interface.</p>
               
               <pre><code class="language-go">func (c *Comments) Comment() *Comments</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropExclude" data-name="DropExclude">
               <h3>
                  DropExclude 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropExclude" class="anchor" title="Link to DropExclude">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) DropExclude(path string, vers string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropGoStmt" data-name="DropGoStmt">
               <h3>
                  DropGoStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropGoStmt" class="anchor" title="Link to DropGoStmt">#</a>
               </h3>
               
               <p>DropGoStmt deletes the go statement from the file.</p>
               
               <pre><code class="language-go">func (f *WorkFile) DropGoStmt()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropGoStmt" data-name="DropGoStmt">
               <h3>
                  DropGoStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropGoStmt" class="anchor" title="Link to DropGoStmt">#</a>
               </h3>
               
               <p>DropGoStmt deletes the go statement from the file.</p>
               
               <pre><code class="language-go">func (f *File) DropGoStmt()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropGodebug" data-name="DropGodebug">
               <h3>
                  DropGodebug 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropGodebug" class="anchor" title="Link to DropGodebug">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) DropGodebug(key string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropGodebug" data-name="DropGodebug">
               <h3>
                  DropGodebug 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropGodebug" class="anchor" title="Link to DropGodebug">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *WorkFile) DropGodebug(key string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropReplace" data-name="DropReplace">
               <h3>
                  DropReplace 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropReplace" class="anchor" title="Link to DropReplace">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) DropReplace(oldPath string, oldVers string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropReplace" data-name="DropReplace">
               <h3>
                  DropReplace 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropReplace" class="anchor" title="Link to DropReplace">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *WorkFile) DropReplace(oldPath string, oldVers string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropRequire" data-name="DropRequire">
               <h3>
                  DropRequire 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropRequire" class="anchor" title="Link to DropRequire">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) DropRequire(path string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropRetract" data-name="DropRetract">
               <h3>
                  DropRetract 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropRetract" class="anchor" title="Link to DropRetract">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) DropRetract(vi VersionInterval) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropTool" data-name="DropTool">
               <h3>
                  DropTool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropTool" class="anchor" title="Link to DropTool">#</a>
               </h3>
               
               <p>RemoveTool removes a tool directive with the given path.
It does nothing if no such tool directive exists.</p>
               
               <pre><code class="language-go">func (f *File) DropTool(path string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropToolchainStmt" data-name="DropToolchainStmt">
               <h3>
                  DropToolchainStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropToolchainStmt" class="anchor" title="Link to DropToolchainStmt">#</a>
               </h3>
               
               <p>DropToolchainStmt deletes the toolchain statement from the file.</p>
               
               <pre><code class="language-go">func (f *File) DropToolchainStmt()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropToolchainStmt" data-name="DropToolchainStmt">
               <h3>
                  DropToolchainStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropToolchainStmt" class="anchor" title="Link to DropToolchainStmt">#</a>
               </h3>
               
               <p>DropToolchainStmt deletes the toolchain statement from the file.</p>
               
               <pre><code class="language-go">func (f *WorkFile) DropToolchainStmt()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DropUse" data-name="DropUse">
               <h3>
                  DropUse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DropUse" class="anchor" title="Link to DropUse">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *WorkFile) DropUse(path string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *Error) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e ErrorList) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>Error is called to report an error.
Error does not return: it panics.</p>
               
               <pre><code class="language-go">func (in *input) Error(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Format" data-name="Format">
               <h3>
                  Format 
                  <span class="badge">function</span>
                  
                  <a href="#Format" class="anchor" title="Link to Format">#</a>
               </h3>
               
               <p>Format returns a go.mod file as a byte slice, formatted in standard style.</p>
               
               <pre><code class="language-go">func Format(f *FileSyntax) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Format" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Format" class="anchor" title="Link to Format">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) Format() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDirectoryPath" data-name="IsDirectoryPath">
               <h3>
                  IsDirectoryPath 
                  <span class="badge">function</span>
                  
                  <a href="#IsDirectoryPath" class="anchor" title="Link to IsDirectoryPath">#</a>
               </h3>
               
               <p>IsDirectoryPath reports whether the given path should be interpreted as a directory path.
Just like on the go command line, relative paths starting with a '.' or '..' path component
and rooted paths are directory paths; the rest are module paths.</p>
               
               <pre><code class="language-go">func IsDirectoryPath(ns string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModulePath" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge">function</span>
                  
                  <a href="#ModulePath" class="anchor" title="Link to ModulePath">#</a>
               </h3>
               
               <p>ModulePath returns the module path from the gomod file text.
If it cannot find a module path, it returns an empty string.
It is tolerant of unrelated problems in the go.mod file.</p>
               
               <pre><code class="language-go">func ModulePath(mod []byte) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MustQuote" data-name="MustQuote">
               <h3>
                  MustQuote 
                  <span class="badge">function</span>
                  
                  <a href="#MustQuote" class="anchor" title="Link to MustQuote">#</a>
               </h3>
               
               <p>MustQuote reports whether s must be quoted in order to appear as
a single token in a go.mod line.</p>
               
               <pre><code class="language-go">func MustQuote(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Parse" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge">function</span>
                  
                  <a href="#Parse" class="anchor" title="Link to Parse">#</a>
               </h3>
               
               <p>Parse parses and returns a go.mod file.
file is the name of the file, used in positions and errors.
data is the content of the file.
fix is an optional function that canonicalizes module versions.
If fix is nil, all module versions must be canonical ([module.CanonicalVersion]
must return the same string).</p>
               
               <pre><code class="language-go">func Parse(file string, data []byte, fix VersionFixer) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseLax" data-name="ParseLax">
               <h3>
                  ParseLax 
                  <span class="badge">function</span>
                  
                  <a href="#ParseLax" class="anchor" title="Link to ParseLax">#</a>
               </h3>
               
               <p>ParseLax is like Parse but ignores unknown statements.
It is used when parsing go.mod files other than the main module,
under the theory that most statement types we add in the future will
only apply in the main module, like exclude and replace,
and so we get better gradual deployments if old go commands
simply ignore those statements when found in go.mod files
in dependencies.</p>
               
               <pre><code class="language-go">func ParseLax(file string, data []byte, fix VersionFixer) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseWork" data-name="ParseWork">
               <h3>
                  ParseWork 
                  <span class="badge">function</span>
                  
                  <a href="#ParseWork" class="anchor" title="Link to ParseWork">#</a>
               </h3>
               
               <p>ParseWork parses and returns a go.work file.
file is the name of the file, used in positions and errors.
data is the content of the file.
fix is an optional function that canonicalizes module versions.
If fix is nil, all module versions must be canonical ([module.CanonicalVersion]
must return the same string).</p>
               
               <pre><code class="language-go">func ParseWork(file string, data []byte, fix VersionFixer) (*WorkFile, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetRequire" data-name="SetRequire">
               <h3>
                  SetRequire 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetRequire" class="anchor" title="Link to SetRequire">#</a>
               </h3>
               
               <p>SetRequire updates the requirements of f to contain exactly req, preserving
the existing block structure and line comment contents (except for 'indirect'
markings) for the first requirement on each named module path.
The Syntax field is ignored for the requirements in req.
Any requirements not already present in the file are added to the block
containing the last require line.
The requirements in req must specify at most one distinct version for each
module path.
If any existing requirements may be removed, the caller should call
[File.Cleanup] after all edits are complete.</p>
               
               <pre><code class="language-go">func (f *File) SetRequire(req []*Require)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetRequireSeparateIndirect" data-name="SetRequireSeparateIndirect">
               <h3>
                  SetRequireSeparateIndirect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetRequireSeparateIndirect" class="anchor" title="Link to SetRequireSeparateIndirect">#</a>
               </h3>
               
               <p>SetRequireSeparateIndirect updates the requirements of f to contain the given
requirements. Comment contents (except for 'indirect' markings) are retained
from the first existing requirement for each module path. Like SetRequire,
SetRequireSeparateIndirect adds requirements for new paths in req,
updates the version and "// indirect" comment on existing requirements,
and deletes requirements on paths not in req. Existing duplicate requirements
are deleted.
As its name suggests, SetRequireSeparateIndirect puts direct and indirect
requirements into two separate blocks, one containing only direct
requirements, and the other containing only indirect requirements.
SetRequireSeparateIndirect may move requirements between these two blocks
when their indirect markings change. However, SetRequireSeparateIndirect
won't move requirements from other blocks, especially blocks with comments.
If the file initially has one uncommented block of requirements,
SetRequireSeparateIndirect will split it into a direct-only and indirect-only
block. This aids in the transition to separate blocks.</p>
               
               <pre><code class="language-go">func (f *File) SetRequireSeparateIndirect(req []*Require)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetUse" data-name="SetUse">
               <h3>
                  SetUse 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetUse" class="anchor" title="Link to SetUse">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *WorkFile) SetUse(dirs []*Use)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SortBlocks" data-name="SortBlocks">
               <h3>
                  SortBlocks 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SortBlocks" class="anchor" title="Link to SortBlocks">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) SortBlocks()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SortBlocks" data-name="SortBlocks">
               <h3>
                  SortBlocks 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SortBlocks" class="anchor" title="Link to SortBlocks">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *WorkFile) SortBlocks()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Span" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Span" class="anchor" title="Link to Span">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *Line) Span() (start Position, end Position)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Span" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Span" class="anchor" title="Link to Span">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *LineBlock) Span() (start Position, end Position)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Span" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Span" class="anchor" title="Link to Span">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *CommentBlock) Span() (start Position, end Position)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Span" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Span" class="anchor" title="Link to Span">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *LParen) Span() (start Position, end Position)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Span" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Span" class="anchor" title="Link to Span">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *FileSyntax) Span() (start Position, end Position)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Span" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Span" class="anchor" title="Link to Span">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *RParen) Span() (start Position, end Position)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *Error) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <p>add returns the position at the end of s, assuming it starts at p.</p>
               
               <pre><code class="language-go">func (p Position) add(s string) Position</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *File) add(errs *ErrorList, block *LineBlock, line *Line, verb string, args []string, fix VersionFixer, strict bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *WorkFile) add(errs *ErrorList, line *Line, verb string, args []string, fix VersionFixer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addLine" data-name="addLine">
               <h3>
                  addLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addLine" class="anchor" title="Link to addLine">#</a>
               </h3>
               
               <p>addLine adds a line containing the given tokens to the file.
If the first token of the hint matches the first token of the
line, the new line is added at the end of the block containing hint,
extracting hint into a new block if it is not yet in one.
If the hint is non-nil buts its first token does not match,
the new line is added after the block containing hint
(or hint itself, if not in a block).
If no hint is provided, addLine appends the line to the end of
the last block with a matching first token,
or to the end of the file if no such block exists.</p>
               
               <pre><code class="language-go">func (x *FileSyntax) addLine(hint Expr, tokens ...string) *Line</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addNewGodebug" data-name="addNewGodebug">
               <h3>
                  addNewGodebug 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addNewGodebug" class="anchor" title="Link to addNewGodebug">#</a>
               </h3>
               
               <p>addNewGodebug adds a new godebug key=value line at the end
of the last godebug block, regardless of any existing godebug lines for key.</p>
               
               <pre><code class="language-go">func (f *File) addNewGodebug(key string, value string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addNewGodebug" data-name="addNewGodebug">
               <h3>
                  addNewGodebug 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#addNewGodebug" class="anchor" title="Link to addNewGodebug">#</a>
               </h3>
               
               <p>addNewGodebug adds a new godebug key=value line at the end
of the last godebug block, regardless of any existing godebug lines for key.</p>
               
               <pre><code class="language-go">func (f *WorkFile) addNewGodebug(key string, value string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addReplace" data-name="addReplace">
               <h3>
                  addReplace 
                  <span class="badge">function</span>
                  
                  <a href="#addReplace" class="anchor" title="Link to addReplace">#</a>
               </h3>
               
               <pre><code class="language-go">func addReplace(syntax *FileSyntax, replace *[]*Replace, oldPath string, oldVers string, newPath string, newVers string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignComments" data-name="assignComments">
               <h3>
                  assignComments 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignComments" class="anchor" title="Link to assignComments">#</a>
               </h3>
               
               <p>assignComments attaches comments to nearby syntax.</p>
               
               <pre><code class="language-go">func (in *input) assignComments()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkCanonicalVersion" data-name="checkCanonicalVersion">
               <h3>
                  checkCanonicalVersion 
                  <span class="badge">function</span>
                  
                  <a href="#checkCanonicalVersion" class="anchor" title="Link to checkCanonicalVersion">#</a>
               </h3>
               
               <p>checkCanonicalVersion returns a non-nil error if vers is not a canonical
version string or does not match the major version of path.
If path is non-empty, the error text suggests a format with a major version
corresponding to the path.</p>
               
               <pre><code class="language-go">func checkCanonicalVersion(path string, vers string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commentsAdd" data-name="commentsAdd">
               <h3>
                  commentsAdd 
                  <span class="badge">function</span>
                  
                  <a href="#commentsAdd" class="anchor" title="Link to commentsAdd">#</a>
               </h3>
               
               <pre><code class="language-go">func commentsAdd(x []Comment, y []Comment) []Comment</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endToken" data-name="endToken">
               <h3>
                  endToken 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#endToken" class="anchor" title="Link to endToken">#</a>
               </h3>
               
               <p>endToken marks the end of an input token.
It records the actual token string in tok.text.
A single trailing newline (LF or CRLF) will be removed from comment tokens.</p>
               
               <pre><code class="language-go">func (in *input) endToken(kind tokenKind)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="eof" data-name="eof">
               <h3>
                  eof 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#eof" class="anchor" title="Link to eof">#</a>
               </h3>
               
               <p>eof reports whether the input has reached end of file.</p>
               
               <pre><code class="language-go">func (in *input) eof() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expr" data-name="expr">
               <h3>
                  expr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expr" class="anchor" title="Link to expr">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) expr(x Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="file" data-name="file">
               <h3>
                  file 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#file" class="anchor" title="Link to file">#</a>
               </h3>
               
               <p>file formats the given file into the print buffer.</p>
               
               <pre><code class="language-go">func (p *printer) file(f *FileSyntax)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixRetract" data-name="fixRetract">
               <h3>
                  fixRetract 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#fixRetract" class="anchor" title="Link to fixRetract">#</a>
               </h3>
               
               <p>fixRetract applies fix to each retract directive in f, appending any errors
to errs.
Most versions are fixed as we parse the file, but for retract directives,
the relevant module path is the one specified with the module directive,
and that might appear at the end of the file (or not at all).</p>
               
               <pre><code class="language-go">func (f *File) fixRetract(fix VersionFixer, errs *ErrorList)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indent" data-name="indent">
               <h3>
                  indent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#indent" class="anchor" title="Link to indent">#</a>
               </h3>
               
               <p>indent returns the position on the current line, in bytes, 0-indexed.</p>
               
               <pre><code class="language-go">func (p *printer) indent() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isComment" data-name="isComment">
               <h3>
                  isComment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isComment" class="anchor" title="Link to isComment">#</a>
               </h3>
               
               <pre><code class="language-go">func (k tokenKind) isComment() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isEOL" data-name="isEOL">
               <h3>
                  isEOL 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isEOL" class="anchor" title="Link to isEOL">#</a>
               </h3>
               
               <p>isEOL returns whether a token terminates a line.</p>
               
               <pre><code class="language-go">func (k tokenKind) isEOL() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isIdent" data-name="isIdent">
               <h3>
                  isIdent 
                  <span class="badge">function</span>
                  
                  <a href="#isIdent" class="anchor" title="Link to isIdent">#</a>
               </h3>
               
               <p>isIdent reports whether c is an identifier rune.
We treat most printable runes as identifier runes, except for a handful of
ASCII punctuation characters.</p>
               
               <pre><code class="language-go">func isIdent(c int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isIndirect" data-name="isIndirect">
               <h3>
                  isIndirect 
                  <span class="badge">function</span>
                  
                  <a href="#isIndirect" class="anchor" title="Link to isIndirect">#</a>
               </h3>
               
               <p>isIndirect reports whether line has a "// indirect" comment,
meaning it is in go.mod only for its effect on indirect dependencies,
so that it can be dropped entirely once the effective version of the
indirect dependency reaches the given minimum version.</p>
               
               <pre><code class="language-go">func isIndirect(line *Line) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lex" data-name="lex">
               <h3>
                  lex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#lex" class="anchor" title="Link to lex">#</a>
               </h3>
               
               <p>lex is called from the parser to obtain the next input token.</p>
               
               <pre><code class="language-go">func (in *input) lex() token</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lineExcludeLess" data-name="lineExcludeLess">
               <h3>
                  lineExcludeLess 
                  <span class="badge">function</span>
                  
                  <a href="#lineExcludeLess" class="anchor" title="Link to lineExcludeLess">#</a>
               </h3>
               
               <p>lineExcludeLess reports whether li should be sorted before lj for lines in
an "exclude" block.</p>
               
               <pre><code class="language-go">func lineExcludeLess(li *Line, lj *Line) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lineLess" data-name="lineLess">
               <h3>
                  lineLess 
                  <span class="badge">function</span>
                  
                  <a href="#lineLess" class="anchor" title="Link to lineLess">#</a>
               </h3>
               
               <p>lineLess returns whether li should be sorted before lj. It sorts
lexicographically without assigning any special meaning to tokens.</p>
               
               <pre><code class="language-go">func lineLess(li *Line, lj *Line) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lineRetractLess" data-name="lineRetractLess">
               <h3>
                  lineRetractLess 
                  <span class="badge">function</span>
                  
                  <a href="#lineRetractLess" class="anchor" title="Link to lineRetractLess">#</a>
               </h3>
               
               <p>lineRetractLess returns whether li should be sorted before lj for lines in
a "retract" block. It treats each line as a version interval. Single versions
are compared as if they were intervals with the same low and high version.
Intervals are sorted in descending order, first by low version, then by
high version, using semver.Compare.</p>
               
               <pre><code class="language-go">func lineRetractLess(li *Line, lj *Line) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="markRemoved" data-name="markRemoved">
               <h3>
                  markRemoved 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#markRemoved" class="anchor" title="Link to markRemoved">#</a>
               </h3>
               
               <p>markRemoved modifies line so that it (and its end-of-line comment, if any)
will be dropped by (*FileSyntax).Cleanup.</p>
               
               <pre><code class="language-go">func (line *Line) markRemoved()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="markRemoved" data-name="markRemoved">
               <h3>
                  markRemoved 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#markRemoved" class="anchor" title="Link to markRemoved">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *Require) markRemoved()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modulePathMajor" data-name="modulePathMajor">
               <h3>
                  modulePathMajor 
                  <span class="badge">function</span>
                  
                  <a href="#modulePathMajor" class="anchor" title="Link to modulePathMajor">#</a>
               </h3>
               
               <pre><code class="language-go">func modulePathMajor(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newInput" data-name="newInput">
               <h3>
                  newInput 
                  <span class="badge">function</span>
                  
                  <a href="#newInput" class="anchor" title="Link to newInput">#</a>
               </h3>
               
               <pre><code class="language-go">func newInput(filename string, data []byte) *input</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newline" data-name="newline">
               <h3>
                  newline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#newline" class="anchor" title="Link to newline">#</a>
               </h3>
               
               <p>newline ends the current line, flushing end-of-line comments.</p>
               
               <pre><code class="language-go">func (p *printer) newline()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="order" data-name="order">
               <h3>
                  order 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#order" class="anchor" title="Link to order">#</a>
               </h3>
               
               <p>order walks the expression adding it and its subexpressions to the
preorder and postorder lists.</p>
               
               <pre><code class="language-go">func (in *input) order(x Expr)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parse" data-name="parse">
               <h3>
                  parse 
                  <span class="badge">function</span>
                  
                  <a href="#parse" class="anchor" title="Link to parse">#</a>
               </h3>
               
               <p>parse parses the input file.</p>
               
               <pre><code class="language-go">func parse(file string, data []byte) (f *FileSyntax, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseDeprecation" data-name="parseDeprecation">
               <h3>
                  parseDeprecation 
                  <span class="badge">function</span>
                  
                  <a href="#parseDeprecation" class="anchor" title="Link to parseDeprecation">#</a>
               </h3>
               
               <p>parseDeprecation extracts the text of comments on a "module" directive and
extracts a deprecation message from that.
A deprecation message is contained in a paragraph within a block of comments
that starts with "Deprecated:" (case sensitive). The message runs until the
end of the paragraph and does not include the "Deprecated:" prefix. If the
comment block has multiple paragraphs that start with "Deprecated:",
parseDeprecation returns the message from the first.</p>
               
               <pre><code class="language-go">func parseDeprecation(block *LineBlock, line *Line) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseDirectiveComment" data-name="parseDirectiveComment">
               <h3>
                  parseDirectiveComment 
                  <span class="badge">function</span>
                  
                  <a href="#parseDirectiveComment" class="anchor" title="Link to parseDirectiveComment">#</a>
               </h3>
               
               <p>parseDirectiveComment extracts the text of comments on a directive.
If the directive's line does not have comments and is part of a block that
does have comments, the block's comments are used.</p>
               
               <pre><code class="language-go">func parseDirectiveComment(block *LineBlock, line *Line) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseFile" data-name="parseFile">
               <h3>
                  parseFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseFile" class="anchor" title="Link to parseFile">#</a>
               </h3>
               
               <pre><code class="language-go">func (in *input) parseFile()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseLine" data-name="parseLine">
               <h3>
                  parseLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseLine" class="anchor" title="Link to parseLine">#</a>
               </h3>
               
               <pre><code class="language-go">func (in *input) parseLine() *Line</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseLineBlock" data-name="parseLineBlock">
               <h3>
                  parseLineBlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseLineBlock" class="anchor" title="Link to parseLineBlock">#</a>
               </h3>
               
               <pre><code class="language-go">func (in *input) parseLineBlock(start Position, token []string, lparen token) *LineBlock</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseReplace" data-name="parseReplace">
               <h3>
                  parseReplace 
                  <span class="badge">function</span>
                  
                  <a href="#parseReplace" class="anchor" title="Link to parseReplace">#</a>
               </h3>
               
               <pre><code class="language-go">func parseReplace(filename string, line *Line, verb string, args []string, fix VersionFixer) (*Replace, *Error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseStmt" data-name="parseStmt">
               <h3>
                  parseStmt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseStmt" class="anchor" title="Link to parseStmt">#</a>
               </h3>
               
               <pre><code class="language-go">func (in *input) parseStmt()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseString" data-name="parseString">
               <h3>
                  parseString 
                  <span class="badge">function</span>
                  
                  <a href="#parseString" class="anchor" title="Link to parseString">#</a>
               </h3>
               
               <pre><code class="language-go">func parseString(s *string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseToFile" data-name="parseToFile">
               <h3>
                  parseToFile 
                  <span class="badge">function</span>
                  
                  <a href="#parseToFile" class="anchor" title="Link to parseToFile">#</a>
               </h3>
               
               <pre><code class="language-go">func parseToFile(file string, data []byte, fix VersionFixer, strict bool) (parsed *File, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseVersion" data-name="parseVersion">
               <h3>
                  parseVersion 
                  <span class="badge">function</span>
                  
                  <a href="#parseVersion" class="anchor" title="Link to parseVersion">#</a>
               </h3>
               
               <pre><code class="language-go">func parseVersion(verb string, path string, s *string, fix VersionFixer) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseVersionInterval" data-name="parseVersionInterval">
               <h3>
                  parseVersionInterval 
                  <span class="badge">function</span>
                  
                  <a href="#parseVersionInterval" class="anchor" title="Link to parseVersionInterval">#</a>
               </h3>
               
               <pre><code class="language-go">func parseVersionInterval(verb string, path string, args *[]string, fix VersionFixer) (VersionInterval, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="peek" data-name="peek">
               <h3>
                  peek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#peek" class="anchor" title="Link to peek">#</a>
               </h3>
               
               <p>peek returns the kind of the next token returned by lex.</p>
               
               <pre><code class="language-go">func (in *input) peek() tokenKind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="peekPrefix" data-name="peekPrefix">
               <h3>
                  peekPrefix 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#peekPrefix" class="anchor" title="Link to peekPrefix">#</a>
               </h3>
               
               <p>peekPrefix reports whether the remaining input begins with the given prefix.</p>
               
               <pre><code class="language-go">func (in *input) peekPrefix(prefix string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="peekRune" data-name="peekRune">
               <h3>
                  peekRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#peekRune" class="anchor" title="Link to peekRune">#</a>
               </h3>
               
               <p>peekRune returns the next rune in the input without consuming it.</p>
               
               <pre><code class="language-go">func (in *input) peekRune() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printf" data-name="printf">
               <h3>
                  printf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#printf" class="anchor" title="Link to printf">#</a>
               </h3>
               
               <p>printf prints to the buffer.</p>
               
               <pre><code class="language-go">func (p *printer) printf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readRune" data-name="readRune">
               <h3>
                  readRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readRune" class="anchor" title="Link to readRune">#</a>
               </h3>
               
               <p>readRune consumes and returns the next rune in the input.</p>
               
               <pre><code class="language-go">func (in *input) readRune() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readToken" data-name="readToken">
               <h3>
                  readToken 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readToken" class="anchor" title="Link to readToken">#</a>
               </h3>
               
               <p>readToken lexes the next token from the text and stores it in in.token.</p>
               
               <pre><code class="language-go">func (in *input) readToken()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeDups" data-name="removeDups">
               <h3>
                  removeDups 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#removeDups" class="anchor" title="Link to removeDups">#</a>
               </h3>
               
               <p>removeDups removes duplicate replace directives.
Later replace directives take priority.
require directives are not de-duplicated. That's left up to higher-level
logic (MVS).
retract directives are not de-duplicated since comments are
meaningful, and versions may be retracted multiple times.</p>
               
               <pre><code class="language-go">func (f *WorkFile) removeDups()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeDups" data-name="removeDups">
               <h3>
                  removeDups 
                  <span class="badge">function</span>
                  
                  <a href="#removeDups" class="anchor" title="Link to removeDups">#</a>
               </h3>
               
               <pre><code class="language-go">func removeDups(syntax *FileSyntax, exclude *[]*Exclude, replace *[]*Replace, tool *[]*Tool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeDups" data-name="removeDups">
               <h3>
                  removeDups 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#removeDups" class="anchor" title="Link to removeDups">#</a>
               </h3>
               
               <p>removeDups removes duplicate exclude, replace and tool directives.
Earlier exclude and tool directives take priority.
Later replace directives take priority.
require directives are not de-duplicated. That's left up to higher-level
logic (MVS).
retract directives are not de-duplicated since comments are
meaningful, and versions may be retracted multiple times.</p>
               
               <pre><code class="language-go">func (f *File) removeDups()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reverseComments" data-name="reverseComments">
               <h3>
                  reverseComments 
                  <span class="badge">function</span>
                  
                  <a href="#reverseComments" class="anchor" title="Link to reverseComments">#</a>
               </h3>
               
               <p>reverseComments reverses the []Comment list.</p>
               
               <pre><code class="language-go">func reverseComments(list []Comment)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setIndirect" data-name="setIndirect">
               <h3>
                  setIndirect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setIndirect" class="anchor" title="Link to setIndirect">#</a>
               </h3>
               
               <p>setIndirect sets line to have (or not have) a "// indirect" comment.</p>
               
               <pre><code class="language-go">func (r *Require) setIndirect(indirect bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setVersion" data-name="setVersion">
               <h3>
                  setVersion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setVersion" class="anchor" title="Link to setVersion">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *Require) setVersion(v string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startToken" data-name="startToken">
               <h3>
                  startToken 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startToken" class="anchor" title="Link to startToken">#</a>
               </h3>
               
               <p>startToken marks the beginning of the next input token.
It must be followed by a call to endToken, once the token's text has
been consumed using readRune.</p>
               
               <pre><code class="language-go">func (in *input) startToken()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stringsAdd" data-name="stringsAdd">
               <h3>
                  stringsAdd 
                  <span class="badge">function</span>
                  
                  <a href="#stringsAdd" class="anchor" title="Link to stringsAdd">#</a>
               </h3>
               
               <pre><code class="language-go">func stringsAdd(x []string, y []string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tokens" data-name="tokens">
               <h3>
                  tokens 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tokens" class="anchor" title="Link to tokens">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *printer) tokens(tokens []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trim" data-name="trim">
               <h3>
                  trim 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#trim" class="anchor" title="Link to trim">#</a>
               </h3>
               
               <p>trim removes trailing spaces and tabs from the current line.</p>
               
               <pre><code class="language-go">func (p *printer) trim()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateLine" data-name="updateLine">
               <h3>
                  updateLine 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateLine" class="anchor" title="Link to updateLine">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *FileSyntax) updateLine(line *Line, tokens ...string)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>