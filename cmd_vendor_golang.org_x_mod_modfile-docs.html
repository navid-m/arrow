<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - modfile</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>modfile</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"errors"
"fmt"
"os"
"strconv"
"strings"
"unicode"
"unicode/utf8"
"errors"
"fmt"
"path/filepath"
"sort"
"strconv"
"strings"
"unicode"
"golang.org/x/mod/internal/lazyregexp"
"golang.org/x/mod/module"
"golang.org/x/mod/semver"
"fmt"
"sort"
"strings"
"bytes"
"fmt"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="GoVersionRE">
               <h3>
                  GoVersionRE 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var GoVersionRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="ToolchainRE">
               <h3>
                  ToolchainRE 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Toolchains must be named beginning with `go1`,
like "go1.20.3" or "go1.20.3-gccgo". As a special case, "default" is also permitted.
Note that this regexp is a much looser condition than go/version.IsValid,
for forward compatibility.
(This code has to be work to identify new toolchains even if we tweak the syntax in the future.)</p>
               
               <pre><code>var ToolchainRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="_COMMENT">
               <h3>
                  _COMMENT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _COMMENT</code></pre>
            </article>
            
            <article class="global" data-name="_EOF">
               <h3>
                  _EOF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _EOF tokenKind = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="_EOLCOMMENT">
               <h3>
                  _EOLCOMMENT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _EOLCOMMENT</code></pre>
            </article>
            
            <article class="global" data-name="_IDENT">
               <h3>
                  _IDENT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _IDENT</code></pre>
            </article>
            
            <article class="global" data-name="_STRING">
               <h3>
                  _STRING 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _STRING</code></pre>
            </article>
            
            <article class="global" data-name="deprecatedRE">
               <h3>
                  deprecatedRE 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var deprecatedRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="dontFixRetract">
               <h3>
                  dontFixRetract 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>errDontFix is returned by a VersionFixer to indicate the version should be
left alone, even if it's not canonical.</p>
               
               <pre><code>var dontFixRetract VersionFixer = *ast.FuncLit</code></pre>
            </article>
            
            <article class="global" data-name="laxGoVersionRE">
               <h3>
                  laxGoVersionRE 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var laxGoVersionRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="moduleStr">
               <h3>
                  moduleStr 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var moduleStr = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="slashSlash">
               <h3>
                  slashSlash 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var slashSlash = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="ErrorList">
               <h3>
                  ErrorList
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type ErrorList []Error</code></pre>
            </article>
            
            <article class="type" data-name="VersionFixer">
               <h3>
                  VersionFixer
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type VersionFixer func(path string, version string) (string, error)</code></pre>
            </article>
            
            <article class="type" data-name="tokenKind">
               <h3>
                  tokenKind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type tokenKind int</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Expr">
               <h3>
                  Expr
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>An Expr represents an input element.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Expr interface {
Span() (start Position, end Position)
Comment() *Comments
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Comment">
               <h3>
                  Comment
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Comment represents a single // comment.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Comment struct {
Start Position
Token string
Suffix bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="CommentBlock">
               <h3>
                  CommentBlock
                  <span class="badge">struct</span>
               </h3>
               
               <p>A CommentBlock represents a top-level block of comments separate
from any rule.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CommentBlock struct {
Comments
Start Position
}</code></pre>
            </article>
            
            <article class="struct" data-name="Comments">
               <h3>
                  Comments
                  <span class="badge">struct</span>
               </h3>
               
               <p>Comments collects the comments associated with an expression.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Comments struct {
Before []Comment
Suffix []Comment
After []Comment
}</code></pre>
            </article>
            
            <article class="struct" data-name="Error">
               <h3>
                  Error
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Error struct {
Filename string
Pos Position
Verb string
ModPath string
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="Exclude">
               <h3>
                  Exclude
                  <span class="badge">struct</span>
               </h3>
               
               <p>An Exclude is a single exclude statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Exclude struct {
Mod module.Version
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct" data-name="File">
               <h3>
                  File
                  <span class="badge">struct</span>
               </h3>
               
               <p>A File is the parsed, interpreted form of a go.mod file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type File struct {
Module *Module
Go *Go
Toolchain *Toolchain
Godebug []*Godebug
Require []*Require
Exclude []*Exclude
Replace []*Replace
Retract []*Retract
Tool []*Tool
Syntax *FileSyntax
}</code></pre>
            </article>
            
            <article class="struct" data-name="FileSyntax">
               <h3>
                  FileSyntax
                  <span class="badge">struct</span>
               </h3>
               
               <p>A FileSyntax represents an entire go.mod file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FileSyntax struct {
Name string
Comments
Stmt []Expr
}</code></pre>
            </article>
            
            <article class="struct" data-name="Go">
               <h3>
                  Go
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Go is the go statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Go struct {
Version string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct" data-name="Godebug">
               <h3>
                  Godebug
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Godebug is a single godebug key=value statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Godebug struct {
Key string
Value string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct" data-name="LParen">
               <h3>
                  LParen
                  <span class="badge">struct</span>
               </h3>
               
               <p>An LParen represents the beginning of a parenthesized line block.
It is a place to store suffix comments.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type LParen struct {
Comments
Pos Position
}</code></pre>
            </article>
            
            <article class="struct" data-name="Line">
               <h3>
                  Line
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Line is a single line of tokens.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Line struct {
Comments
Start Position
Token []string
InBlock bool
End Position
}</code></pre>
            </article>
            
            <article class="struct" data-name="LineBlock">
               <h3>
                  LineBlock
                  <span class="badge">struct</span>
               </h3>
               
               <p>A LineBlock is a factored block of lines, like
require (
"x"
"y"
)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type LineBlock struct {
Comments
Start Position
LParen LParen
Token []string
Line []*Line
RParen RParen
}</code></pre>
            </article>
            
            <article class="struct" data-name="Module">
               <h3>
                  Module
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Module is the module statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Module struct {
Mod module.Version
Deprecated string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct" data-name="Position">
               <h3>
                  Position
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Position describes an arbitrary source position in a file, including the
file, line, column, and byte offset.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Position struct {
Line int
LineRune int
Byte int
}</code></pre>
            </article>
            
            <article class="struct" data-name="RParen">
               <h3>
                  RParen
                  <span class="badge">struct</span>
               </h3>
               
               <p>An RParen represents the end of a parenthesized line block.
It is a place to store whole-line (before) comments.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type RParen struct {
Comments
Pos Position
}</code></pre>
            </article>
            
            <article class="struct" data-name="Replace">
               <h3>
                  Replace
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Replace is a single replace statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Replace struct {
Old module.Version
New module.Version
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct" data-name="Require">
               <h3>
                  Require
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Require is a single require statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Require struct {
Mod module.Version
Indirect bool
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct" data-name="Retract">
               <h3>
                  Retract
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Retract is a single retract statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Retract struct {
VersionInterval
Rationale string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct" data-name="Tool">
               <h3>
                  Tool
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Tool is a single tool statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Tool struct {
Path string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct" data-name="Toolchain">
               <h3>
                  Toolchain
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Toolchain is the toolchain statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Toolchain struct {
Name string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct" data-name="Use">
               <h3>
                  Use
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Use is a single directory statement.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Use struct {
Path string
ModulePath string
Syntax *Line
}</code></pre>
            </article>
            
            <article class="struct" data-name="VersionInterval">
               <h3>
                  VersionInterval
                  <span class="badge">struct</span>
               </h3>
               
               <p>A VersionInterval represents a range of versions with upper and lower bounds.
Intervals are closed: both bounds are included. When Low is equal to High,
the interval may refer to a single version ('v1.2.3') or an interval
('[v1.2.3, v1.2.3]'); both have the same representation.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type VersionInterval struct {
Low string
High string
}</code></pre>
            </article>
            
            <article class="struct" data-name="WorkFile">
               <h3>
                  WorkFile
                  <span class="badge">struct</span>
               </h3>
               
               <p>A WorkFile is the parsed, interpreted form of a go.work file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type WorkFile struct {
Go *Go
Toolchain *Toolchain
Godebug []*Godebug
Use []*Use
Replace []*Replace
Syntax *FileSyntax
}</code></pre>
            </article>
            
            <article class="struct" data-name="input">
               <h3>
                  input
                  <span class="badge">struct</span>
               </h3>
               
               <p>An input represents a single input file being parsed.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type input struct {
filename string
complete []byte
remaining []byte
tokenStart []byte
token token
pos Position
comments []Comment
file *FileSyntax
parseErrors ErrorList
pre []Expr
post []Expr
}</code></pre>
            </article>
            
            <article class="struct" data-name="printer">
               <h3>
                  printer
                  <span class="badge">struct</span>
               </h3>
               
               <p>A printer collects the state during printing of a file or expression.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type printer struct {
bytes.Buffer
comment []Comment
margin int
}</code></pre>
            </article>
            
            <article class="struct" data-name="token">
               <h3>
                  token
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type token struct {
kind tokenKind
pos Position
endPos Position
text string
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AddComment">
               <h3>
                  AddComment 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) AddComment(text string)</code></pre>
            </article>
            
            <article class="function" data-name="AddExclude">
               <h3>
                  AddExclude 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddExclude adds a exclude statement to the mod file. Errors if the provided
version is not a canonical version string</p>
               
               <pre><code>func (f *File) AddExclude(path string, vers string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddGoStmt">
               <h3>
                  AddGoStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *WorkFile) AddGoStmt(version string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddGoStmt">
               <h3>
                  AddGoStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) AddGoStmt(version string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddGodebug">
               <h3>
                  AddGodebug 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddGodebug sets the first godebug line for key to value,
preserving any existing comments for that line and removing all
other godebug lines for key.
If no line currently exists for key, AddGodebug adds a new line
at the end of the last godebug block.</p>
               
               <pre><code>func (f *File) AddGodebug(key string, value string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddGodebug">
               <h3>
                  AddGodebug 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddGodebug sets the first godebug line for key to value,
preserving any existing comments for that line and removing all
other godebug lines for key.
If no line currently exists for key, AddGodebug adds a new line
at the end of the last godebug block.</p>
               
               <pre><code>func (f *WorkFile) AddGodebug(key string, value string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddModuleStmt">
               <h3>
                  AddModuleStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) AddModuleStmt(path string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddNewRequire">
               <h3>
                  AddNewRequire 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddNewRequire adds a new require line for path at version vers at the end of
the last require block, regardless of any existing require lines for path.</p>
               
               <pre><code>func (f *File) AddNewRequire(path string, vers string, indirect bool)</code></pre>
            </article>
            
            <article class="function" data-name="AddNewUse">
               <h3>
                  AddNewUse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *WorkFile) AddNewUse(diskPath string, modulePath string)</code></pre>
            </article>
            
            <article class="function" data-name="AddReplace">
               <h3>
                  AddReplace 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *WorkFile) AddReplace(oldPath string, oldVers string, newPath string, newVers string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddReplace">
               <h3>
                  AddReplace 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) AddReplace(oldPath string, oldVers string, newPath string, newVers string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddRequire">
               <h3>
                  AddRequire 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddRequire sets the first require line for path to version vers,
preserving any existing comments for that line and removing all
other lines for path.
If no line currently exists for path, AddRequire adds a new line
at the end of the last require block.</p>
               
               <pre><code>func (f *File) AddRequire(path string, vers string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddRetract">
               <h3>
                  AddRetract 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddRetract adds a retract statement to the mod file. Errors if the provided
version interval does not consist of canonical version strings</p>
               
               <pre><code>func (f *File) AddRetract(vi VersionInterval, rationale string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddTool">
               <h3>
                  AddTool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddTool adds a new tool directive with the given path.
It does nothing if the tool line already exists.</p>
               
               <pre><code>func (f *File) AddTool(path string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddToolchainStmt">
               <h3>
                  AddToolchainStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) AddToolchainStmt(name string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddToolchainStmt">
               <h3>
                  AddToolchainStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *WorkFile) AddToolchainStmt(name string) error</code></pre>
            </article>
            
            <article class="function" data-name="AddUse">
               <h3>
                  AddUse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *WorkFile) AddUse(diskPath string, modulePath string) error</code></pre>
            </article>
            
            <article class="function" data-name="AutoQuote">
               <h3>
                  AutoQuote 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AutoQuote returns s or, if quoting is required for s to appear in a go.mod,
the quotation of s.</p>
               
               <pre><code>func AutoQuote(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="Cleanup">
               <h3>
                  Cleanup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Cleanup cleans up the file syntax x after any edit operations.
To avoid quadratic behavior, (*Line).markRemoved marks the line as dead
by setting line.Token = nil but does not remove it from the slice
in which it appears. After edits have all been indicated,
calling Cleanup cleans out the dead lines.</p>
               
               <pre><code>func (x *FileSyntax) Cleanup()</code></pre>
            </article>
            
            <article class="function" data-name="Cleanup">
               <h3>
                  Cleanup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Cleanup cleans up the file f after any edit operations.
To avoid quadratic behavior, modifications like [WorkFile.DropRequire]
clear the entry but do not remove it from the slice.
Cleanup cleans out all the cleared entries.</p>
               
               <pre><code>func (f *WorkFile) Cleanup()</code></pre>
            </article>
            
            <article class="function" data-name="Cleanup">
               <h3>
                  Cleanup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Cleanup cleans up the file f after any edit operations.
To avoid quadratic behavior, modifications like [File.DropRequire]
clear the entry but do not remove it from the slice.
Cleanup cleans out all the cleared entries.</p>
               
               <pre><code>func (f *File) Cleanup()</code></pre>
            </article>
            
            <article class="function" data-name="Comment">
               <h3>
                  Comment 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Comment returns the receiver. This isn't useful by itself, but
a [Comments] struct is embedded into all the expression
implementation types, and this gives each of those a Comment
method to satisfy the Expr interface.</p>
               
               <pre><code>func (c *Comments) Comment() *Comments</code></pre>
            </article>
            
            <article class="function" data-name="DropExclude">
               <h3>
                  DropExclude 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) DropExclude(path string, vers string) error</code></pre>
            </article>
            
            <article class="function" data-name="DropGoStmt">
               <h3>
                  DropGoStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DropGoStmt deletes the go statement from the file.</p>
               
               <pre><code>func (f *File) DropGoStmt()</code></pre>
            </article>
            
            <article class="function" data-name="DropGoStmt">
               <h3>
                  DropGoStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DropGoStmt deletes the go statement from the file.</p>
               
               <pre><code>func (f *WorkFile) DropGoStmt()</code></pre>
            </article>
            
            <article class="function" data-name="DropGodebug">
               <h3>
                  DropGodebug 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *WorkFile) DropGodebug(key string) error</code></pre>
            </article>
            
            <article class="function" data-name="DropGodebug">
               <h3>
                  DropGodebug 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) DropGodebug(key string) error</code></pre>
            </article>
            
            <article class="function" data-name="DropReplace">
               <h3>
                  DropReplace 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) DropReplace(oldPath string, oldVers string) error</code></pre>
            </article>
            
            <article class="function" data-name="DropReplace">
               <h3>
                  DropReplace 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *WorkFile) DropReplace(oldPath string, oldVers string) error</code></pre>
            </article>
            
            <article class="function" data-name="DropRequire">
               <h3>
                  DropRequire 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) DropRequire(path string) error</code></pre>
            </article>
            
            <article class="function" data-name="DropRetract">
               <h3>
                  DropRetract 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) DropRetract(vi VersionInterval) error</code></pre>
            </article>
            
            <article class="function" data-name="DropTool">
               <h3>
                  DropTool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RemoveTool removes a tool directive with the given path.
It does nothing if no such tool directive exists.</p>
               
               <pre><code>func (f *File) DropTool(path string) error</code></pre>
            </article>
            
            <article class="function" data-name="DropToolchainStmt">
               <h3>
                  DropToolchainStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DropToolchainStmt deletes the toolchain statement from the file.</p>
               
               <pre><code>func (f *WorkFile) DropToolchainStmt()</code></pre>
            </article>
            
            <article class="function" data-name="DropToolchainStmt">
               <h3>
                  DropToolchainStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>DropToolchainStmt deletes the toolchain statement from the file.</p>
               
               <pre><code>func (f *File) DropToolchainStmt()</code></pre>
            </article>
            
            <article class="function" data-name="DropUse">
               <h3>
                  DropUse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *WorkFile) DropUse(path string) error</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *Error) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e ErrorList) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Error is called to report an error.
Error does not return: it panics.</p>
               
               <pre><code>func (in *input) Error(s string)</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Format returns a go.mod file as a byte slice, formatted in standard style.</p>
               
               <pre><code>func Format(f *FileSyntax) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) Format() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="IsDirectoryPath">
               <h3>
                  IsDirectoryPath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsDirectoryPath reports whether the given path should be interpreted as a directory path.
Just like on the go command line, relative paths starting with a '.' or '..' path component
and rooted paths are directory paths; the rest are module paths.</p>
               
               <pre><code>func IsDirectoryPath(ns string) bool</code></pre>
            </article>
            
            <article class="function" data-name="ModulePath">
               <h3>
                  ModulePath 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ModulePath returns the module path from the gomod file text.
If it cannot find a module path, it returns an empty string.
It is tolerant of unrelated problems in the go.mod file.</p>
               
               <pre><code>func ModulePath(mod []byte) string</code></pre>
            </article>
            
            <article class="function" data-name="MustQuote">
               <h3>
                  MustQuote 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>MustQuote reports whether s must be quoted in order to appear as
a single token in a go.mod line.</p>
               
               <pre><code>func MustQuote(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Parse parses and returns a go.mod file.
file is the name of the file, used in positions and errors.
data is the content of the file.
fix is an optional function that canonicalizes module versions.
If fix is nil, all module versions must be canonical ([module.CanonicalVersion]
must return the same string).</p>
               
               <pre><code>func Parse(file string, data []byte, fix VersionFixer) (*File, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseLax">
               <h3>
                  ParseLax 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseLax is like Parse but ignores unknown statements.
It is used when parsing go.mod files other than the main module,
under the theory that most statement types we add in the future will
only apply in the main module, like exclude and replace,
and so we get better gradual deployments if old go commands
simply ignore those statements when found in go.mod files
in dependencies.</p>
               
               <pre><code>func ParseLax(file string, data []byte, fix VersionFixer) (*File, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseWork">
               <h3>
                  ParseWork 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseWork parses and returns a go.work file.
file is the name of the file, used in positions and errors.
data is the content of the file.
fix is an optional function that canonicalizes module versions.
If fix is nil, all module versions must be canonical ([module.CanonicalVersion]
must return the same string).</p>
               
               <pre><code>func ParseWork(file string, data []byte, fix VersionFixer) (*WorkFile, error)</code></pre>
            </article>
            
            <article class="function" data-name="SetRequire">
               <h3>
                  SetRequire 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetRequire updates the requirements of f to contain exactly req, preserving
the existing block structure and line comment contents (except for 'indirect'
markings) for the first requirement on each named module path.
The Syntax field is ignored for the requirements in req.
Any requirements not already present in the file are added to the block
containing the last require line.
The requirements in req must specify at most one distinct version for each
module path.
If any existing requirements may be removed, the caller should call
[File.Cleanup] after all edits are complete.</p>
               
               <pre><code>func (f *File) SetRequire(req []*Require)</code></pre>
            </article>
            
            <article class="function" data-name="SetRequireSeparateIndirect">
               <h3>
                  SetRequireSeparateIndirect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetRequireSeparateIndirect updates the requirements of f to contain the given
requirements. Comment contents (except for 'indirect' markings) are retained
from the first existing requirement for each module path. Like SetRequire,
SetRequireSeparateIndirect adds requirements for new paths in req,
updates the version and "// indirect" comment on existing requirements,
and deletes requirements on paths not in req. Existing duplicate requirements
are deleted.
As its name suggests, SetRequireSeparateIndirect puts direct and indirect
requirements into two separate blocks, one containing only direct
requirements, and the other containing only indirect requirements.
SetRequireSeparateIndirect may move requirements between these two blocks
when their indirect markings change. However, SetRequireSeparateIndirect
won't move requirements from other blocks, especially blocks with comments.
If the file initially has one uncommented block of requirements,
SetRequireSeparateIndirect will split it into a direct-only and indirect-only
block. This aids in the transition to separate blocks.</p>
               
               <pre><code>func (f *File) SetRequireSeparateIndirect(req []*Require)</code></pre>
            </article>
            
            <article class="function" data-name="SetUse">
               <h3>
                  SetUse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *WorkFile) SetUse(dirs []*Use)</code></pre>
            </article>
            
            <article class="function" data-name="SortBlocks">
               <h3>
                  SortBlocks 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *WorkFile) SortBlocks()</code></pre>
            </article>
            
            <article class="function" data-name="SortBlocks">
               <h3>
                  SortBlocks 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) SortBlocks()</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *CommentBlock) Span() (start Position, end Position)</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *LParen) Span() (start Position, end Position)</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *RParen) Span() (start Position, end Position)</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *LineBlock) Span() (start Position, end Position)</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *Line) Span() (start Position, end Position)</code></pre>
            </article>
            
            <article class="function" data-name="Span">
               <h3>
                  Span 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *FileSyntax) Span() (start Position, end Position)</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *Error) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) add(errs *ErrorList, block *LineBlock, line *Line, verb string, args []string, fix VersionFixer, strict bool)</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *WorkFile) add(errs *ErrorList, line *Line, verb string, args []string, fix VersionFixer)</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>add returns the position at the end of s, assuming it starts at p.</p>
               
               <pre><code>func (p Position) add(s string) Position</code></pre>
            </article>
            
            <article class="function" data-name="addLine">
               <h3>
                  addLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addLine adds a line containing the given tokens to the file.
If the first token of the hint matches the first token of the
line, the new line is added at the end of the block containing hint,
extracting hint into a new block if it is not yet in one.
If the hint is non-nil buts its first token does not match,
the new line is added after the block containing hint
(or hint itself, if not in a block).
If no hint is provided, addLine appends the line to the end of
the last block with a matching first token,
or to the end of the file if no such block exists.</p>
               
               <pre><code>func (x *FileSyntax) addLine(hint Expr, tokens ...string) *Line</code></pre>
            </article>
            
            <article class="function" data-name="addNewGodebug">
               <h3>
                  addNewGodebug 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addNewGodebug adds a new godebug key=value line at the end
of the last godebug block, regardless of any existing godebug lines for key.</p>
               
               <pre><code>func (f *WorkFile) addNewGodebug(key string, value string)</code></pre>
            </article>
            
            <article class="function" data-name="addNewGodebug">
               <h3>
                  addNewGodebug 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addNewGodebug adds a new godebug key=value line at the end
of the last godebug block, regardless of any existing godebug lines for key.</p>
               
               <pre><code>func (f *File) addNewGodebug(key string, value string)</code></pre>
            </article>
            
            <article class="function" data-name="addReplace">
               <h3>
                  addReplace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func addReplace(syntax *FileSyntax, replace *[]*Replace, oldPath string, oldVers string, newPath string, newVers string) error</code></pre>
            </article>
            
            <article class="function" data-name="assignComments">
               <h3>
                  assignComments 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>assignComments attaches comments to nearby syntax.</p>
               
               <pre><code>func (in *input) assignComments()</code></pre>
            </article>
            
            <article class="function" data-name="checkCanonicalVersion">
               <h3>
                  checkCanonicalVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkCanonicalVersion returns a non-nil error if vers is not a canonical
version string or does not match the major version of path.
If path is non-empty, the error text suggests a format with a major version
corresponding to the path.</p>
               
               <pre><code>func checkCanonicalVersion(path string, vers string) error</code></pre>
            </article>
            
            <article class="function" data-name="commentsAdd">
               <h3>
                  commentsAdd 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func commentsAdd(x []Comment, y []Comment) []Comment</code></pre>
            </article>
            
            <article class="function" data-name="endToken">
               <h3>
                  endToken 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>endToken marks the end of an input token.
It records the actual token string in tok.text.
A single trailing newline (LF or CRLF) will be removed from comment tokens.</p>
               
               <pre><code>func (in *input) endToken(kind tokenKind)</code></pre>
            </article>
            
            <article class="function" data-name="eof">
               <h3>
                  eof 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>eof reports whether the input has reached end of file.</p>
               
               <pre><code>func (in *input) eof() bool</code></pre>
            </article>
            
            <article class="function" data-name="expr">
               <h3>
                  expr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *printer) expr(x Expr)</code></pre>
            </article>
            
            <article class="function" data-name="file">
               <h3>
                  file 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>file formats the given file into the print buffer.</p>
               
               <pre><code>func (p *printer) file(f *FileSyntax)</code></pre>
            </article>
            
            <article class="function" data-name="fixRetract">
               <h3>
                  fixRetract 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fixRetract applies fix to each retract directive in f, appending any errors
to errs.
Most versions are fixed as we parse the file, but for retract directives,
the relevant module path is the one specified with the module directive,
and that might appear at the end of the file (or not at all).</p>
               
               <pre><code>func (f *File) fixRetract(fix VersionFixer, errs *ErrorList)</code></pre>
            </article>
            
            <article class="function" data-name="indent">
               <h3>
                  indent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>indent returns the position on the current line, in bytes, 0-indexed.</p>
               
               <pre><code>func (p *printer) indent() int</code></pre>
            </article>
            
            <article class="function" data-name="isComment">
               <h3>
                  isComment 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (k tokenKind) isComment() bool</code></pre>
            </article>
            
            <article class="function" data-name="isEOL">
               <h3>
                  isEOL 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>isEOL returns whether a token terminates a line.</p>
               
               <pre><code>func (k tokenKind) isEOL() bool</code></pre>
            </article>
            
            <article class="function" data-name="isIdent">
               <h3>
                  isIdent 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isIdent reports whether c is an identifier rune.
We treat most printable runes as identifier runes, except for a handful of
ASCII punctuation characters.</p>
               
               <pre><code>func isIdent(c int) bool</code></pre>
            </article>
            
            <article class="function" data-name="isIndirect">
               <h3>
                  isIndirect 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isIndirect reports whether line has a "// indirect" comment,
meaning it is in go.mod only for its effect on indirect dependencies,
so that it can be dropped entirely once the effective version of the
indirect dependency reaches the given minimum version.</p>
               
               <pre><code>func isIndirect(line *Line) bool</code></pre>
            </article>
            
            <article class="function" data-name="lex">
               <h3>
                  lex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lex is called from the parser to obtain the next input token.</p>
               
               <pre><code>func (in *input) lex() token</code></pre>
            </article>
            
            <article class="function" data-name="lineExcludeLess">
               <h3>
                  lineExcludeLess 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lineExcludeLess reports whether li should be sorted before lj for lines in
an "exclude" block.</p>
               
               <pre><code>func lineExcludeLess(li *Line, lj *Line) bool</code></pre>
            </article>
            
            <article class="function" data-name="lineLess">
               <h3>
                  lineLess 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lineLess returns whether li should be sorted before lj. It sorts
lexicographically without assigning any special meaning to tokens.</p>
               
               <pre><code>func lineLess(li *Line, lj *Line) bool</code></pre>
            </article>
            
            <article class="function" data-name="lineRetractLess">
               <h3>
                  lineRetractLess 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lineRetractLess returns whether li should be sorted before lj for lines in
a "retract" block. It treats each line as a version interval. Single versions
are compared as if they were intervals with the same low and high version.
Intervals are sorted in descending order, first by low version, then by
high version, using semver.Compare.</p>
               
               <pre><code>func lineRetractLess(li *Line, lj *Line) bool</code></pre>
            </article>
            
            <article class="function" data-name="markRemoved">
               <h3>
                  markRemoved 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>markRemoved modifies line so that it (and its end-of-line comment, if any)
will be dropped by (*FileSyntax).Cleanup.</p>
               
               <pre><code>func (line *Line) markRemoved()</code></pre>
            </article>
            
            <article class="function" data-name="markRemoved">
               <h3>
                  markRemoved 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Require) markRemoved()</code></pre>
            </article>
            
            <article class="function" data-name="modulePathMajor">
               <h3>
                  modulePathMajor 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func modulePathMajor(path string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="newInput">
               <h3>
                  newInput 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newInput(filename string, data []byte) *input</code></pre>
            </article>
            
            <article class="function" data-name="newline">
               <h3>
                  newline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>newline ends the current line, flushing end-of-line comments.</p>
               
               <pre><code>func (p *printer) newline()</code></pre>
            </article>
            
            <article class="function" data-name="order">
               <h3>
                  order 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>order walks the expression adding it and its subexpressions to the
preorder and postorder lists.</p>
               
               <pre><code>func (in *input) order(x Expr)</code></pre>
            </article>
            
            <article class="function" data-name="parse">
               <h3>
                  parse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parse parses the input file.</p>
               
               <pre><code>func parse(file string, data []byte) (f *FileSyntax, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseDeprecation">
               <h3>
                  parseDeprecation 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseDeprecation extracts the text of comments on a "module" directive and
extracts a deprecation message from that.
A deprecation message is contained in a paragraph within a block of comments
that starts with "Deprecated:" (case sensitive). The message runs until the
end of the paragraph and does not include the "Deprecated:" prefix. If the
comment block has multiple paragraphs that start with "Deprecated:",
parseDeprecation returns the message from the first.</p>
               
               <pre><code>func parseDeprecation(block *LineBlock, line *Line) string</code></pre>
            </article>
            
            <article class="function" data-name="parseDirectiveComment">
               <h3>
                  parseDirectiveComment 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseDirectiveComment extracts the text of comments on a directive.
If the directive's line does not have comments and is part of a block that
does have comments, the block's comments are used.</p>
               
               <pre><code>func parseDirectiveComment(block *LineBlock, line *Line) string</code></pre>
            </article>
            
            <article class="function" data-name="parseFile">
               <h3>
                  parseFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) parseFile()</code></pre>
            </article>
            
            <article class="function" data-name="parseLine">
               <h3>
                  parseLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) parseLine() *Line</code></pre>
            </article>
            
            <article class="function" data-name="parseLineBlock">
               <h3>
                  parseLineBlock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) parseLineBlock(start Position, token []string, lparen token) *LineBlock</code></pre>
            </article>
            
            <article class="function" data-name="parseReplace">
               <h3>
                  parseReplace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseReplace(filename string, line *Line, verb string, args []string, fix VersionFixer) (*Replace, *Error)</code></pre>
            </article>
            
            <article class="function" data-name="parseStmt">
               <h3>
                  parseStmt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (in *input) parseStmt()</code></pre>
            </article>
            
            <article class="function" data-name="parseString">
               <h3>
                  parseString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseString(s *string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="parseToFile">
               <h3>
                  parseToFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseToFile(file string, data []byte, fix VersionFixer, strict bool) (parsed *File, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseVersion">
               <h3>
                  parseVersion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseVersion(verb string, path string, s *string, fix VersionFixer) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="parseVersionInterval">
               <h3>
                  parseVersionInterval 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseVersionInterval(verb string, path string, args *[]string, fix VersionFixer) (VersionInterval, error)</code></pre>
            </article>
            
            <article class="function" data-name="peek">
               <h3>
                  peek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>peek returns the kind of the next token returned by lex.</p>
               
               <pre><code>func (in *input) peek() tokenKind</code></pre>
            </article>
            
            <article class="function" data-name="peekPrefix">
               <h3>
                  peekPrefix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>peekPrefix reports whether the remaining input begins with the given prefix.</p>
               
               <pre><code>func (in *input) peekPrefix(prefix string) bool</code></pre>
            </article>
            
            <article class="function" data-name="peekRune">
               <h3>
                  peekRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>peekRune returns the next rune in the input without consuming it.</p>
               
               <pre><code>func (in *input) peekRune() int</code></pre>
            </article>
            
            <article class="function" data-name="printf">
               <h3>
                  printf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>printf prints to the buffer.</p>
               
               <pre><code>func (p *printer) printf(format string, args ...interface{})</code></pre>
            </article>
            
            <article class="function" data-name="readRune">
               <h3>
                  readRune 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>readRune consumes and returns the next rune in the input.</p>
               
               <pre><code>func (in *input) readRune() int</code></pre>
            </article>
            
            <article class="function" data-name="readToken">
               <h3>
                  readToken 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>readToken lexes the next token from the text and stores it in in.token.</p>
               
               <pre><code>func (in *input) readToken()</code></pre>
            </article>
            
            <article class="function" data-name="removeDups">
               <h3>
                  removeDups 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>removeDups removes duplicate replace directives.
Later replace directives take priority.
require directives are not de-duplicated. That's left up to higher-level
logic (MVS).
retract directives are not de-duplicated since comments are
meaningful, and versions may be retracted multiple times.</p>
               
               <pre><code>func (f *WorkFile) removeDups()</code></pre>
            </article>
            
            <article class="function" data-name="removeDups">
               <h3>
                  removeDups 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>removeDups removes duplicate exclude, replace and tool directives.
Earlier exclude and tool directives take priority.
Later replace directives take priority.
require directives are not de-duplicated. That's left up to higher-level
logic (MVS).
retract directives are not de-duplicated since comments are
meaningful, and versions may be retracted multiple times.</p>
               
               <pre><code>func (f *File) removeDups()</code></pre>
            </article>
            
            <article class="function" data-name="removeDups">
               <h3>
                  removeDups 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func removeDups(syntax *FileSyntax, exclude *[]*Exclude, replace *[]*Replace, tool *[]*Tool)</code></pre>
            </article>
            
            <article class="function" data-name="reverseComments">
               <h3>
                  reverseComments 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>reverseComments reverses the []Comment list.</p>
               
               <pre><code>func reverseComments(list []Comment)</code></pre>
            </article>
            
            <article class="function" data-name="setIndirect">
               <h3>
                  setIndirect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setIndirect sets line to have (or not have) a "// indirect" comment.</p>
               
               <pre><code>func (r *Require) setIndirect(indirect bool)</code></pre>
            </article>
            
            <article class="function" data-name="setVersion">
               <h3>
                  setVersion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *Require) setVersion(v string)</code></pre>
            </article>
            
            <article class="function" data-name="startToken">
               <h3>
                  startToken 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>startToken marks the beginning of the next input token.
It must be followed by a call to endToken, once the token's text has
been consumed using readRune.</p>
               
               <pre><code>func (in *input) startToken()</code></pre>
            </article>
            
            <article class="function" data-name="stringsAdd">
               <h3>
                  stringsAdd 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func stringsAdd(x []string, y []string) []string</code></pre>
            </article>
            
            <article class="function" data-name="tokens">
               <h3>
                  tokens 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *printer) tokens(tokens []string)</code></pre>
            </article>
            
            <article class="function" data-name="trim">
               <h3>
                  trim 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>trim removes trailing spaces and tabs from the current line.</p>
               
               <pre><code>func (p *printer) trim()</code></pre>
            </article>
            
            <article class="function" data-name="updateLine">
               <h3>
                  updateLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *FileSyntax) updateLine(line *Line, tokens ...string)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
