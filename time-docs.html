<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - time</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="time_tzdata-docs.html">tzdata</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>time</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"errors"
"internal/bytealg"
"runtime"
"syscall"
_ "unsafe"
"syscall"
"errors"
"internal/syscall/windows/registry"
"syscall"
"errors"
"syscall"
"errors"
"math/bits"
_ "unsafe"
"errors"
"sync"
"syscall"
"internal/itoa"
"syscall/js"
"errors"
"runtime"
"syscall"
"syscall"
"errors"
"syscall"
"syscall"
_ "time/tzdata"
"errors"
"internal/stringslite"
_ "unsafe"
"internal/godebug"
"unsafe"
"errors"
"syscall"
"unsafe"
"errors"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="ANSIC">
               <h3>
                  ANSIC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const ANSIC = "Mon Jan _2 15:04:05 2006"</code></pre>
            </article>
            
            <article class="global" data-name="April">
               <h3>
                  April 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const April</code></pre>
            </article>
            
            <article class="global" data-name="August">
               <h3>
                  August 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const August</code></pre>
            </article>
            
            <article class="global" data-name="DateOnly">
               <h3>
                  DateOnly 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const DateOnly = "2006-01-02"</code></pre>
            </article>
            
            <article class="global" data-name="DateTime">
               <h3>
                  DateTime 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const DateTime = "2006-01-02 15:04:05"</code></pre>
            </article>
            
            <article class="global" data-name="December">
               <h3>
                  December 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const December</code></pre>
            </article>
            
            <article class="global" data-name="February">
               <h3>
                  February 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const February</code></pre>
            </article>
            
            <article class="global" data-name="Friday">
               <h3>
                  Friday 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Friday</code></pre>
            </article>
            
            <article class="global" data-name="Hour">
               <h3>
                  Hour 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
To count the number of units in a [Duration], divide:
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
To convert an integer number of units to a Duration, multiply:
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</p>
               
               <pre><code>const Hour = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="January">
               <h3>
                  January 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const January Month = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="July">
               <h3>
                  July 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const July</code></pre>
            </article>
            
            <article class="global" data-name="June">
               <h3>
                  June 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const June</code></pre>
            </article>
            
            <article class="global" data-name="Kitchen">
               <h3>
                  Kitchen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const Kitchen = "3:04PM"</code></pre>
            </article>
            
            <article class="global" data-name="Layout">
               <h3>
                  Layout 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const Layout = "01/02 03:04:05PM '06 -0700"</code></pre>
            </article>
            
            <article class="global" data-name="Local">
               <h3>
                  Local 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Local represents the system's local time zone.
On Unix systems, Local consults the TZ environment
variable to find the time zone to use. No TZ means
use the system default /etc/localtime.
TZ="" means use UTC.
TZ="foo" means use file foo in the system timezone directory.</p>
               
               <pre><code>var Local *Location = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="March">
               <h3>
                  March 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const March</code></pre>
            </article>
            
            <article class="global" data-name="May">
               <h3>
                  May 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const May</code></pre>
            </article>
            
            <article class="global" data-name="Microsecond">
               <h3>
                  Microsecond 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
To count the number of units in a [Duration], divide:
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
To convert an integer number of units to a Duration, multiply:
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</p>
               
               <pre><code>const Microsecond = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="Millisecond">
               <h3>
                  Millisecond 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
To count the number of units in a [Duration], divide:
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
To convert an integer number of units to a Duration, multiply:
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</p>
               
               <pre><code>const Millisecond = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="Minute">
               <h3>
                  Minute 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
To count the number of units in a [Duration], divide:
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
To convert an integer number of units to a Duration, multiply:
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</p>
               
               <pre><code>const Minute = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="Monday">
               <h3>
                  Monday 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Monday</code></pre>
            </article>
            
            <article class="global" data-name="Nanosecond">
               <h3>
                  Nanosecond 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
To count the number of units in a [Duration], divide:
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
To convert an integer number of units to a Duration, multiply:
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</p>
               
               <pre><code>const Nanosecond Duration = 1</code></pre>
            </article>
            
            <article class="global" data-name="November">
               <h3>
                  November 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const November</code></pre>
            </article>
            
            <article class="global" data-name="October">
               <h3>
                  October 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const October</code></pre>
            </article>
            
            <article class="global" data-name="RFC1123">
               <h3>
                  RFC1123 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const RFC1123 = "Mon, 02 Jan 2006 15:04:05 MST"</code></pre>
            </article>
            
            <article class="global" data-name="RFC1123Z">
               <h3>
                  RFC1123Z 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const RFC1123Z = "Mon, 02 Jan 2006 15:04:05 -0700"</code></pre>
            </article>
            
            <article class="global" data-name="RFC3339">
               <h3>
                  RFC3339 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const RFC3339 = "2006-01-02T15:04:05Z07:00"</code></pre>
            </article>
            
            <article class="global" data-name="RFC3339Nano">
               <h3>
                  RFC3339Nano 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const RFC3339Nano = "2006-01-02T15:04:05.999999999Z07:00"</code></pre>
            </article>
            
            <article class="global" data-name="RFC822">
               <h3>
                  RFC822 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const RFC822 = "02 Jan 06 15:04 MST"</code></pre>
            </article>
            
            <article class="global" data-name="RFC822Z">
               <h3>
                  RFC822Z 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const RFC822Z = "02 Jan 06 15:04 -0700"</code></pre>
            </article>
            
            <article class="global" data-name="RFC850">
               <h3>
                  RFC850 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const RFC850 = "Monday, 02-Jan-06 15:04:05 MST"</code></pre>
            </article>
            
            <article class="global" data-name="RubyDate">
               <h3>
                  RubyDate 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const RubyDate = "Mon Jan 02 15:04:05 -0700 2006"</code></pre>
            </article>
            
            <article class="global" data-name="Saturday">
               <h3>
                  Saturday 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Saturday</code></pre>
            </article>
            
            <article class="global" data-name="Second">
               <h3>
                  Second 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
To count the number of units in a [Duration], divide:
second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
To convert an integer number of units to a Duration, multiply:
seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s</p>
               
               <pre><code>const Second = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="September">
               <h3>
                  September 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const September</code></pre>
            </article>
            
            <article class="global" data-name="Stamp">
               <h3>
                  Stamp 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Handy time stamps.</p>
               
               <pre><code>const Stamp = "Jan _2 15:04:05"</code></pre>
            </article>
            
            <article class="global" data-name="StampMicro">
               <h3>
                  StampMicro 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const StampMicro = "Jan _2 15:04:05.000000"</code></pre>
            </article>
            
            <article class="global" data-name="StampMilli">
               <h3>
                  StampMilli 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const StampMilli = "Jan _2 15:04:05.000"</code></pre>
            </article>
            
            <article class="global" data-name="StampNano">
               <h3>
                  StampNano 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const StampNano = "Jan _2 15:04:05.000000000"</code></pre>
            </article>
            
            <article class="global" data-name="Sunday">
               <h3>
                  Sunday 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Sunday Weekday = iota</code></pre>
            </article>
            
            <article class="global" data-name="Thursday">
               <h3>
                  Thursday 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Thursday</code></pre>
            </article>
            
            <article class="global" data-name="TimeOnly">
               <h3>
                  TimeOnly 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const TimeOnly = "15:04:05"</code></pre>
            </article>
            
            <article class="global" data-name="Tuesday">
               <h3>
                  Tuesday 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Tuesday</code></pre>
            </article>
            
            <article class="global" data-name="UTC">
               <h3>
                  UTC 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>UTC represents Universal Coordinated Time (UTC).</p>
               
               <pre><code>var UTC *Location = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="UnixDate">
               <h3>
                  UnixDate 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are predefined layouts for use in [Time.Format] and [time.Parse].
The reference time used in these layouts is the specific time stamp:
01/02 03:04:05PM '06 -0700
(January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
That value is recorded as the constant named [Layout], listed below. As a Unix
time, this is 1136239445. Since MST is GMT-0700, the reference would be
printed by the Unix date command as:
Mon Jan 2 15:04:05 MST 2006
It is a regrettable historic error that the date uses the American convention
of putting the numerical month before the day.
The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.
Note that the [RFC822], [RFC850], and [RFC1123] formats should be applied
only to local times. Applying them to UTC times will use "UTC" as the
time zone abbreviation, while strictly speaking those RFCs require the
use of "GMT" in that case.
When using the [RFC1123] or [RFC1123Z] formats for parsing, note that these
formats define a leading zero for the day-in-month portion, which is not
strictly allowed by RFC 1123. This will result in an error when parsing
date strings that occur in the first 9 days of a given month.
In general [RFC1123Z] should be used instead of [RFC1123] for servers
that insist on that format, and [RFC3339] should be preferred for new protocols.
[RFC3339], [RFC822], [RFC822Z], [RFC1123], and [RFC1123Z] are useful for formatting;
when used with time.Parse they do not accept all the time formats
permitted by the RFCs and they do accept time formats not formally defined.
The [RFC3339Nano] format removes trailing zeros from the seconds field
and thus may not sort correctly once formatted.
Most programs can use one of the defined constants as the layout passed to
Format or Parse. The rest of this comment can be ignored unless you are
creating a custom layout string.
To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like [ANSIC], [StampMicro] or
[Kitchen] for examples. The model is to demonstrate what the reference time
looks like so that the Format and Parse methods can apply the same
transformation to a general time value.
Here is a summary of the components of a layout string. Each element shows by
example the formatting of an element of the reference time. Only these values
are recognized. Text in the layout string that is not recognized as part of
the reference time is echoed verbatim during Format and expected to appear
verbatim in the input to Parse.
Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
Numeric time zone offsets format as follows:
"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone. Thus:
"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
Within the format string, the underscores in "_2" and "__2" represent spaces
that may be replaced by digits if the following number has multiple digits,
for compatibility with fixed-width Unix time formats. A leading zero represents
a zero-padded value.
The formats __2 and 002 are space-padded and zero-padded
three-character day of year; there is no unpadded day of year format.
A comma or decimal point followed by one or more zeros represents
a fractional second, printed to the given number of decimal places.
A comma or decimal point followed by one or more nines represents
a fractional second, printed to the given number of decimal places, with
trailing zeros removed.
For example "15:04:05,000" or "15:04:05.000" formats or parses with
millisecond precision.
Some valid layouts are invalid time values for time.Parse, due to formats
such as _ for space padding and Z for zone information.</p>
               
               <pre><code>const UnixDate = "Mon Jan _2 15:04:05 MST 2006"</code></pre>
            </article>
            
            <article class="global" data-name="Wednesday">
               <h3>
                  Wednesday 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const Wednesday</code></pre>
            </article>
            
            <article class="global" data-name="_">
               <h3>
                  _ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const _ = iota</code></pre>
            </article>
            
            <article class="global" data-name="abbrs">
               <h3>
                  abbrs 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var abbrs = map[string]abbr{...}</code></pre>
            </article>
            
            <article class="global" data-name="absoluteToInternal">
               <h3>
                  absoluteToInternal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets to convert between internal and absolute or Unix times.</p>
               
               <pre><code>const absoluteToInternal int64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="absoluteToUnix">
               <h3>
                  absoluteToUnix 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code>const absoluteToUnix = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="absoluteYears">
               <h3>
                  absoluteYears 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>absoluteYears is the number of years we subtract from internal time to get absolute time.
This value must be 0 mod 400, and it defines the “absolute zero instant”
mentioned in the “Computations on Times” comment above: March 1, -absoluteYears.
Dates before the absolute epoch will not compute correctly,
but otherwise the value can be changed as needed.</p>
               
               <pre><code>const absoluteYears = 292277022400</code></pre>
            </article>
            
            <article class="global" data-name="allowGorootSource">
               <h3>
                  allowGorootSource 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var allowGorootSource = true</code></pre>
            </article>
            
            <article class="global" data-name="alpha">
               <h3>
                  alpha 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>alpha and omega are the beginning and end of time for zone
transitions.</p>
               
               <pre><code>const alpha = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="asynctimerchan">
               <h3>
                  asynctimerchan 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var asynctimerchan = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="aus">
               <h3>
                  aus 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var aus = syscall.Timezoneinformation{...}</code></pre>
            </article>
            
            <article class="global" data-name="daysPer400Years">
               <h3>
                  daysPer400Years 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code>const daysPer400Years = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="errAtoi">
               <h3>
                  errAtoi 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Never printed, just needs to be non-nil for return by atoi.</p>
               
               <pre><code>var errAtoi = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errBad">
               <h3>
                  errBad 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errBad = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errBadData">
               <h3>
                  errBadData 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errBadData = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errLeadingInt">
               <h3>
                  errLeadingInt 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errLeadingInt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errLocation">
               <h3>
                  errLocation 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errLocation = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="hasMonotonic">
               <h3>
                  hasMonotonic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const hasMonotonic = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="internalToAbsolute">
               <h3>
                  internalToAbsolute 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code>const internalToAbsolute = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="internalToUnix">
               <h3>
                  internalToUnix 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code>const internalToUnix int64 = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="internalYear">
               <h3>
                  internalYear 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The year of the zero Time.
Assumed by the unixToInternal computation below.</p>
               
               <pre><code>const internalYear = 1</code></pre>
            </article>
            
            <article class="global" data-name="loadFromEmbeddedTZData">
               <h3>
                  loadFromEmbeddedTZData 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>loadFromEmbeddedTZData is used to load a specific tzdata file
from tzdata information embedded in the binary itself.
This is set when the time/tzdata package is imported,
via registerLoadFromEmbeddedTzdata.</p>
               
               <pre><code>var loadFromEmbeddedTZData func(zipname string) (string, error)</code></pre>
            </article>
            
            <article class="global" data-name="loadTzinfoFromTzdata">
               <h3>
                  loadTzinfoFromTzdata 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>loadTzinfoFromTzdata returns the time zone information of the time zone
with the given name, from a tzdata database file as they are typically
found on android.</p>
               
               <pre><code>var loadTzinfoFromTzdata func(file string, name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="global" data-name="localLoc">
               <h3>
                  localLoc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>localLoc is separate so that initLocal can initialize
it even if a client has changed Local.</p>
               
               <pre><code>var localLoc Location</code></pre>
            </article>
            
            <article class="global" data-name="localOnce">
               <h3>
                  localOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var localOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="longDayNames">
               <h3>
                  longDayNames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var longDayNames = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="longMonthNames">
               <h3>
                  longMonthNames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var longMonthNames = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="lowerhex">
               <h3>
                  lowerhex 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are borrowed from unicode/utf8 and strconv and replicate behavior in
that package, since we can't take a dependency on either.</p>
               
               <pre><code>const lowerhex = "0123456789abcdef"</code></pre>
            </article>
            
            <article class="global" data-name="marchThruDecember">
               <h3>
                  marchThruDecember 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Days from March 1 through end of year</p>
               
               <pre><code>const marchThruDecember = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxDuration">
               <h3>
                  maxDuration 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxDuration Duration = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxFileSize">
               <h3>
                  maxFileSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>maxFileSize is the max permitted size of files read by readFile.
As reference, the zoneinfo.zip distributed by Go is ~350 KB,
so 10MB is overkill.</p>
               
               <pre><code>const maxFileSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="maxWall">
               <h3>
                  maxWall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const maxWall = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="minDuration">
               <h3>
                  minDuration 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const minDuration Duration = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="minWall">
               <h3>
                  minWall 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const minWall = wallToInternal</code></pre>
            </article>
            
            <article class="global" data-name="nsecMask">
               <h3>
                  nsecMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nsecMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="nsecShift">
               <h3>
                  nsecShift 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nsecShift = 30</code></pre>
            </article>
            
            <article class="global" data-name="omega">
               <h3>
                  omega 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>alpha and omega are the beginning and end of time for zone
transitions.</p>
               
               <pre><code>const omega = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var platformZoneSources []string</code></pre>
            </article>
            
            <article class="global" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var platformZoneSources = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>in wasip1 zoneinfo is managed by the runtime.</p>
               
               <pre><code>var platformZoneSources = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var platformZoneSources = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var platformZoneSources []string</code></pre>
            </article>
            
            <article class="global" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var platformZoneSources []string</code></pre>
            </article>
            
            <article class="global" data-name="platformZoneSources">
               <h3>
                  platformZoneSources 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Many systems use /usr/share/zoneinfo, Solaris 2 has
/usr/share/lib/zoneinfo, IRIX 6 has /usr/lib/locale/TZ,
NixOS has /etc/zoneinfo.</p>
               
               <pre><code>var platformZoneSources = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="ruleDOY">
               <h3>
                  ruleDOY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ruleDOY</code></pre>
            </article>
            
            <article class="global" data-name="ruleJulian">
               <h3>
                  ruleJulian 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ruleJulian ruleKind = iota</code></pre>
            </article>
            
            <article class="global" data-name="ruleMonthWeekDay">
               <h3>
                  ruleMonthWeekDay 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ruleMonthWeekDay</code></pre>
            </article>
            
            <article class="global" data-name="runeError">
               <h3>
                  runeError 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are borrowed from unicode/utf8 and strconv and replicate behavior in
that package, since we can't take a dependency on either.</p>
               
               <pre><code>const runeError = '\uFFFD'</code></pre>
            </article>
            
            <article class="global" data-name="runeSelf">
               <h3>
                  runeSelf 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>These are borrowed from unicode/utf8 and strconv and replicate behavior in
that package, since we can't take a dependency on either.</p>
               
               <pre><code>const runeSelf = 0x80</code></pre>
            </article>
            
            <article class="global" data-name="secondsPerDay">
               <h3>
                  secondsPerDay 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code>const secondsPerDay = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="secondsPerHour">
               <h3>
                  secondsPerHour 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code>const secondsPerHour = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="secondsPerMinute">
               <h3>
                  secondsPerMinute 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code>const secondsPerMinute = 60</code></pre>
            </article>
            
            <article class="global" data-name="secondsPerWeek">
               <h3>
                  secondsPerWeek 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code>const secondsPerWeek = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="seekCurrent">
               <h3>
                  seekCurrent 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Copies of io.Seek* constants to avoid importing "io":</p>
               
               <pre><code>const seekCurrent = 1</code></pre>
            </article>
            
            <article class="global" data-name="seekEnd">
               <h3>
                  seekEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Copies of io.Seek* constants to avoid importing "io":</p>
               
               <pre><code>const seekEnd = 2</code></pre>
            </article>
            
            <article class="global" data-name="seekStart">
               <h3>
                  seekStart 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Copies of io.Seek* constants to avoid importing "io":</p>
               
               <pre><code>const seekStart = 0</code></pre>
            </article>
            
            <article class="global" data-name="shortDayNames">
               <h3>
                  shortDayNames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var shortDayNames = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="shortMonthNames">
               <h3>
                  shortMonthNames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var shortMonthNames = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="startNano">
               <h3>
                  startNano 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Monotonic times are reported as offsets from startNano.
We initialize startNano to runtimeNano() - 1 so that on systems where
monotonic time resolution is fairly low (e.g. Windows 2008
which appears to have a default resolution of 15ms),
we avoid ever reporting a monotonic time of 0.
(Callers may want to use 0 as "time not set".)</p>
               
               <pre><code>var startNano int64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="std0x">
               <h3>
                  std0x 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>std0x records the std values for "01", "02", ..., "06".</p>
               
               <pre><code>var std0x = [...]int{...}</code></pre>
            </article>
            
            <article class="global" data-name="stdArgShift">
               <h3>
                  stdArgShift 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdArgShift = 16</code></pre>
            </article>
            
            <article class="global" data-name="stdDay">
               <h3>
                  stdDay 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdDay</code></pre>
            </article>
            
            <article class="global" data-name="stdFracSecond0">
               <h3>
                  stdFracSecond0 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdFracSecond0</code></pre>
            </article>
            
            <article class="global" data-name="stdFracSecond9">
               <h3>
                  stdFracSecond9 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdFracSecond9</code></pre>
            </article>
            
            <article class="global" data-name="stdHour">
               <h3>
                  stdHour 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdHour = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="stdHour12">
               <h3>
                  stdHour12 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdHour12</code></pre>
            </article>
            
            <article class="global" data-name="stdISO8601ColonSecondsTZ">
               <h3>
                  stdISO8601ColonSecondsTZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdISO8601ColonSecondsTZ</code></pre>
            </article>
            
            <article class="global" data-name="stdISO8601ColonTZ">
               <h3>
                  stdISO8601ColonTZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdISO8601ColonTZ</code></pre>
            </article>
            
            <article class="global" data-name="stdISO8601SecondsTZ">
               <h3>
                  stdISO8601SecondsTZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdISO8601SecondsTZ</code></pre>
            </article>
            
            <article class="global" data-name="stdISO8601ShortTZ">
               <h3>
                  stdISO8601ShortTZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdISO8601ShortTZ</code></pre>
            </article>
            
            <article class="global" data-name="stdISO8601TZ">
               <h3>
                  stdISO8601TZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdISO8601TZ</code></pre>
            </article>
            
            <article class="global" data-name="stdLongMonth">
               <h3>
                  stdLongMonth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdLongMonth = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="stdLongWeekDay">
               <h3>
                  stdLongWeekDay 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdLongWeekDay</code></pre>
            </article>
            
            <article class="global" data-name="stdLongYear">
               <h3>
                  stdLongYear 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdLongYear = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="stdMask">
               <h3>
                  stdMask 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="stdMinute">
               <h3>
                  stdMinute 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdMinute</code></pre>
            </article>
            
            <article class="global" data-name="stdMonth">
               <h3>
                  stdMonth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdMonth</code></pre>
            </article>
            
            <article class="global" data-name="stdNeedClock">
               <h3>
                  stdNeedClock 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdNeedClock = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="stdNeedDate">
               <h3>
                  stdNeedDate 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdNeedDate = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="stdNeedYday">
               <h3>
                  stdNeedYday 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdNeedYday = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="stdNumColonSecondsTZ">
               <h3>
                  stdNumColonSecondsTZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdNumColonSecondsTZ</code></pre>
            </article>
            
            <article class="global" data-name="stdNumColonTZ">
               <h3>
                  stdNumColonTZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdNumColonTZ</code></pre>
            </article>
            
            <article class="global" data-name="stdNumMonth">
               <h3>
                  stdNumMonth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdNumMonth</code></pre>
            </article>
            
            <article class="global" data-name="stdNumSecondsTz">
               <h3>
                  stdNumSecondsTz 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdNumSecondsTz</code></pre>
            </article>
            
            <article class="global" data-name="stdNumShortTZ">
               <h3>
                  stdNumShortTZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdNumShortTZ</code></pre>
            </article>
            
            <article class="global" data-name="stdNumTZ">
               <h3>
                  stdNumTZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdNumTZ</code></pre>
            </article>
            
            <article class="global" data-name="stdPM">
               <h3>
                  stdPM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdPM = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="stdSecond">
               <h3>
                  stdSecond 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdSecond</code></pre>
            </article>
            
            <article class="global" data-name="stdSeparatorShift">
               <h3>
                  stdSeparatorShift 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdSeparatorShift = 28</code></pre>
            </article>
            
            <article class="global" data-name="stdTZ">
               <h3>
                  stdTZ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdTZ = iota</code></pre>
            </article>
            
            <article class="global" data-name="stdUnderDay">
               <h3>
                  stdUnderDay 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdUnderDay</code></pre>
            </article>
            
            <article class="global" data-name="stdUnderYearDay">
               <h3>
                  stdUnderYearDay 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdUnderYearDay = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="stdWeekDay">
               <h3>
                  stdWeekDay 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdWeekDay</code></pre>
            </article>
            
            <article class="global" data-name="stdYear">
               <h3>
                  stdYear 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdYear</code></pre>
            </article>
            
            <article class="global" data-name="stdZeroDay">
               <h3>
                  stdZeroDay 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdZeroDay</code></pre>
            </article>
            
            <article class="global" data-name="stdZeroHour12">
               <h3>
                  stdZeroHour12 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdZeroHour12</code></pre>
            </article>
            
            <article class="global" data-name="stdZeroMinute">
               <h3>
                  stdZeroMinute 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdZeroMinute</code></pre>
            </article>
            
            <article class="global" data-name="stdZeroMonth">
               <h3>
                  stdZeroMonth 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdZeroMonth</code></pre>
            </article>
            
            <article class="global" data-name="stdZeroSecond">
               <h3>
                  stdZeroSecond 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdZeroSecond</code></pre>
            </article>
            
            <article class="global" data-name="stdZeroYearDay">
               <h3>
                  stdZeroYearDay 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdZeroYearDay</code></pre>
            </article>
            
            <article class="global" data-name="stdpm">
               <h3>
                  stdpm 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const stdpm</code></pre>
            </article>
            
            <article class="global" data-name="timeBinaryVersionV1">
               <h3>
                  timeBinaryVersionV1 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const timeBinaryVersionV1 byte = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="timeBinaryVersionV2">
               <h3>
                  timeBinaryVersionV2 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const timeBinaryVersionV2</code></pre>
            </article>
            
            <article class="global" data-name="unitMap">
               <h3>
                  unitMap 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var unitMap = map[string]uint64{...}</code></pre>
            </article>
            
            <article class="global" data-name="unixToAbsolute">
               <h3>
                  unixToAbsolute 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code>const unixToAbsolute = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="unixToInternal">
               <h3>
                  unixToInternal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code>const unixToInternal int64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="unnamedFixedZones">
               <h3>
                  unnamedFixedZones 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var unnamedFixedZones []*Location</code></pre>
            </article>
            
            <article class="global" data-name="unnamedFixedZonesOnce">
               <h3>
                  unnamedFixedZonesOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var unnamedFixedZonesOnce sync.Once</code></pre>
            </article>
            
            <article class="global" data-name="usPacific">
               <h3>
                  usPacific 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var usPacific = syscall.Timezoneinformation{...}</code></pre>
            </article>
            
            <article class="global" data-name="utcLoc">
               <h3>
                  utcLoc 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>utcLoc is separate so that get can refer to &utcLoc
and ensure that it never returns a nil *Location,
even if a badly behaved client has changed UTC.</p>
               
               <pre><code>var utcLoc = Location{...}</code></pre>
            </article>
            
            <article class="global" data-name="wallToInternal">
               <h3>
                  wallToInternal 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>To keep the various units separate, we define integer types
for each. These are never stored in interfaces nor allocated,
so their type information does not appear in Go binaries.</p>
               
               <pre><code>const wallToInternal int64 = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="zoneinfo">
               <h3>
                  zoneinfo 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var zoneinfo *string</code></pre>
            </article>
            
            <article class="global" data-name="zoneinfoOnce">
               <h3>
                  zoneinfoOnce 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var zoneinfoOnce sync.Once</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Duration">
               <h3>
                  Duration
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Duration represents the elapsed time between two instants
as an int64 nanosecond count. The representation limits the
largest representable duration to approximately 290 years.</p>
               
               <pre><code>type Duration int64</code></pre>
            </article>
            
            <article class="type" data-name="Month">
               <h3>
                  Month
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Month specifies a month of the year (January = 1, ...).</p>
               
               <pre><code>type Month int</code></pre>
            </article>
            
            <article class="type" data-name="Weekday">
               <h3>
                  Weekday
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A Weekday specifies a day of the week (Sunday = 0, ...).</p>
               
               <pre><code>type Weekday int</code></pre>
            </article>
            
            <article class="type" data-name="absCentury">
               <h3>
                  absCentury
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An absCentury counts the number of centuries since the absolute zero instant.</p>
               
               <pre><code>type absCentury uint64</code></pre>
            </article>
            
            <article class="type" data-name="absCyear">
               <h3>
                  absCyear
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An absCyear counts the number of years since the start of a century.</p>
               
               <pre><code>type absCyear int</code></pre>
            </article>
            
            <article class="type" data-name="absDays">
               <h3>
                  absDays
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An absDays counts the number of days since the absolute zero instant.</p>
               
               <pre><code>type absDays uint64</code></pre>
            </article>
            
            <article class="type" data-name="absJanFeb">
               <h3>
                  absJanFeb
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An absJanFeb is a single bit (0 or 1) denoting whether a given day falls in January or February.
That is a special case because the absolute years start in March (unlike normal calendar years).</p>
               
               <pre><code>type absJanFeb int</code></pre>
            </article>
            
            <article class="type" data-name="absLeap">
               <h3>
                  absLeap
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An absLeap is a single bit (0 or 1) denoting whether a given year is a leap year.</p>
               
               <pre><code>type absLeap int</code></pre>
            </article>
            
            <article class="type" data-name="absMonth">
               <h3>
                  absMonth
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An absMonth counts the number of months since the start of a year.
absMonth=0 denotes March.</p>
               
               <pre><code>type absMonth int</code></pre>
            </article>
            
            <article class="type" data-name="absSeconds">
               <h3>
                  absSeconds
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An absSeconds counts the number of seconds since the absolute zero instant.</p>
               
               <pre><code>type absSeconds uint64</code></pre>
            </article>
            
            <article class="type" data-name="absYday">
               <h3>
                  absYday
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An absYday counts the number of days since the start of a year.
Note that absolute years start on March 1.</p>
               
               <pre><code>type absYday int</code></pre>
            </article>
            
            <article class="type" data-name="fileSizeError">
               <h3>
                  fileSizeError
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type fileSizeError string</code></pre>
            </article>
            
            <article class="type" data-name="ruleKind">
               <h3>
                  ruleKind
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>ruleKind is the kinds of rules that can be seen in a tzset string.</p>
               
               <pre><code>type ruleKind int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="Location">
               <h3>
                  Location
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Location maps time instants to the zone in use at that time.
Typically, the Location represents the collection of time offsets
in use in a geographical area. For many Locations the time offset varies
depending on whether daylight savings time is in use at the time instant.
Location is used to provide a time zone in a printed Time value and for
calculations involving intervals that may cross daylight savings time
boundaries.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Location struct {
name string
zone []zone
tx []zoneTrans
extend string
cacheStart int64
cacheEnd int64
cacheZone *zone
}</code></pre>
            </article>
            
            <article class="struct" data-name="ParseError">
               <h3>
                  ParseError
                  <span class="badge">struct</span>
               </h3>
               
               <p>ParseError describes a problem parsing a time string.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ParseError struct {
Layout string
Value string
LayoutElem string
ValueElem string
Message string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Ticker">
               <h3>
                  Ticker
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Ticker holds a channel that delivers “ticks” of a clock
at intervals.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Ticker struct {
C <-chan Time
initTicker bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Time">
               <h3>
                  Time
                  <span class="badge">struct</span>
               </h3>
               
               <p>A Time represents an instant in time with nanosecond precision.
Programs using times should typically store and pass them as values,
not pointers. That is, time variables and struct fields should be of
type [time.Time], not *time.Time.
A Time value can be used by multiple goroutines simultaneously except
that the methods [Time.GobDecode], [Time.UnmarshalBinary], [Time.UnmarshalJSON] and
[Time.UnmarshalText] are not concurrency-safe.
Time instants can be compared using the [Time.Before], [Time.After], and [Time.Equal] methods.
The [Time.Sub] method subtracts two instants, producing a [Duration].
The [Time.Add] method adds a Time and a Duration, producing a Time.
The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
As this time is unlikely to come up in practice, the [Time.IsZero] method gives
a simple way of detecting a time that has not been initialized explicitly.
Each time has an associated [Location]. The methods [Time.Local], [Time.UTC], and Time.In return a
Time with a specific Location. Changing the Location of a Time value with
these methods does not change the actual instant it represents, only the time
zone in which to interpret it.
Representations of a Time value saved by the [Time.GobEncode], [Time.MarshalBinary], [Time.AppendBinary],
[Time.MarshalJSON], [Time.MarshalText] and [Time.AppendText] methods store the [Time.Location]'s offset,
but not the location name. They therefore lose information about Daylight Saving Time.
In addition to the required “wall clock” reading, a Time may contain an optional
reading of the current process's monotonic clock, to provide additional precision
for comparison or subtraction.
See the “Monotonic Clocks” section in the package documentation for details.
Note that the Go == operator compares not just the time instant but also the
Location and the monotonic clock reading. Therefore, Time values should not
be used as map or database keys without first guaranteeing that the
identical Location has been set for all values, which can be achieved
through use of the UTC or Local method, and that the monotonic clock reading
has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)
to t == u, since t.Equal uses the most accurate comparison available and
correctly handles the case when only one of its arguments has a monotonic
clock reading.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Time struct {
wall uint64
ext int64
loc *Location
}</code></pre>
            </article>
            
            <article class="struct" data-name="Timer">
               <h3>
                  Timer
                  <span class="badge">struct</span>
               </h3>
               
               <p>The Timer type represents a single event.
When the Timer expires, the current time will be sent on C,
unless the Timer was created by [AfterFunc].
A Timer must be created with [NewTimer] or AfterFunc.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Timer struct {
C <-chan Time
initTimer bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="abbr">
               <h3>
                  abbr
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type abbr struct {
std string
dst string
}</code></pre>
            </article>
            
            <article class="struct" data-name="dataIO">
               <h3>
                  dataIO
                  <span class="badge">struct</span>
               </h3>
               
               <p>Simple I/O interface to binary blob of data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dataIO struct {
p []byte
error bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="rule">
               <h3>
                  rule
                  <span class="badge">struct</span>
               </h3>
               
               <p>rule is a rule read from a tzset string.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rule struct {
kind ruleKind
day int
week int
mon int
time int
}</code></pre>
            </article>
            
            <article class="struct" data-name="zone">
               <h3>
                  zone
                  <span class="badge">struct</span>
               </h3>
               
               <p>A zone represents a single time zone such as CET.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type zone struct {
name string
offset int
isDST bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="zoneTrans">
               <h3>
                  zoneTrans
                  <span class="badge">struct</span>
               </h3>
               
               <p>A zoneTrans represents a single time zone transition.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type zoneTrans struct {
when int64
index uint8
isstd bool
isutc bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Abs">
               <h3>
                  Abs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Abs returns the absolute value of d.
As a special case, Duration([math.MinInt64]) is converted to Duration([math.MaxInt64]),
reducing its magnitude by 1 nanosecond.</p>
               
               <pre><code>func (d Duration) Abs() Duration</code></pre>
            </article>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add returns the time t+d.</p>
               
               <pre><code>func (t Time) Add(d Duration) Time</code></pre>
            </article>
            
            <article class="function" data-name="AddDate">
               <h3>
                  AddDate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddDate returns the time corresponding to adding the
given number of years, months, and days to t.
For example, AddDate(-1, 2, 3) applied to January 1, 2011
returns March 4, 2010.
Note that dates are fundamentally coupled to timezones, and calendrical
periods like days don't have fixed durations. AddDate uses the Location of
the Time value to determine these durations. That means that the same
AddDate arguments can produce a different shift in absolute time depending on
the base Time value and its Location. For example, AddDate(0, 0, 1) applied
to 12:00 on March 27 always returns 12:00 on March 28. At some locations and
in some years this is a 24 hour shift. In others it's a 23 hour shift due to
daylight savings time transitions.
AddDate normalizes its result in the same way that Date does,
so, for example, adding one month to October 31 yields
December 1, the normalized form for November 31.</p>
               
               <pre><code>func (t Time) AddDate(years int, months int, days int) Time</code></pre>
            </article>
            
            <article class="function" data-name="After">
               <h3>
                  After 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>After reports whether the time instant t is after u.</p>
               
               <pre><code>func (t Time) After(u Time) bool</code></pre>
            </article>
            
            <article class="function" data-name="After">
               <h3>
                  After 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>After waits for the duration to elapse and then sends the current time
on the returned channel.
It is equivalent to [NewTimer](d).C.
Before Go 1.23, this documentation warned that the underlying
[Timer] would not be recovered by the garbage collector until the
timer fired, and that if efficiency was a concern, code should use
NewTimer instead and call [Timer.Stop] if the timer is no longer needed.
As of Go 1.23, the garbage collector can recover unreferenced,
unstopped timers. There is no reason to prefer NewTimer when After will do.</p>
               
               <pre><code>func After(d Duration) (<-chan Time)</code></pre>
            </article>
            
            <article class="function" data-name="AfterFunc">
               <h3>
                  AfterFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>AfterFunc waits for the duration to elapse and then calls f
in its own goroutine. It returns a [Timer] that can
be used to cancel the call using its Stop method.
The returned Timer's C field is not used and will be nil.</p>
               
               <pre><code>func AfterFunc(d Duration, f func()) *Timer</code></pre>
            </article>
            
            <article class="function" data-name="AppendBinary">
               <h3>
                  AppendBinary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendBinary implements the [encoding.BinaryAppender] interface.</p>
               
               <pre><code>func (t Time) AppendBinary(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="AppendFormat">
               <h3>
                  AppendFormat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendFormat is like [Time.Format] but appends the textual
representation to b and returns the extended buffer.</p>
               
               <pre><code>func (t Time) AppendFormat(b []byte, layout string) []byte</code></pre>
            </article>
            
            <article class="function" data-name="AppendText">
               <h3>
                  AppendText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AppendText implements the [encoding.TextAppender] interface.
The time is formatted in RFC 3339 format with sub-second precision.
If the timestamp cannot be represented as valid RFC 3339
(e.g., the year is out of range), then an error is returned.</p>
               
               <pre><code>func (t Time) AppendText(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Before">
               <h3>
                  Before 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Before reports whether the time instant t is before u.</p>
               
               <pre><code>func (t Time) Before(u Time) bool</code></pre>
            </article>
            
            <article class="function" data-name="Clock">
               <h3>
                  Clock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Clock returns the hour, minute, and second within the day specified by t.</p>
               
               <pre><code>func (t Time) Clock() (hour int, min int, sec int)</code></pre>
            </article>
            
            <article class="function" data-name="Compare">
               <h3>
                  Compare 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Compare compares the time instant t with u. If t is before u, it returns -1;
if t is after u, it returns +1; if they're the same, it returns 0.</p>
               
               <pre><code>func (t Time) Compare(u Time) int</code></pre>
            </article>
            
            <article class="function" data-name="Date">
               <h3>
                  Date 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Date returns the Time corresponding to
yyyy-mm-dd hh:mm:ss + nsec nanoseconds
in the appropriate zone for that time in the given location.
The month, day, hour, min, sec, and nsec values may be outside
their usual ranges and will be normalized during the conversion.
For example, October 32 converts to November 1.
A daylight savings time transition skips or repeats times.
For example, in the United States, March 13, 2011 2:15am never occurred,
while November 6, 2011 1:15am occurred twice. In such cases, the
choice of time zone, and therefore the time, is not well-defined.
Date returns a time that is correct in one of the two zones involved
in the transition, but it does not guarantee which.
Date panics if loc is nil.</p>
               
               <pre><code>func Date(year int, month Month, day int, hour int, min int, sec int, nsec int, loc *Location) Time</code></pre>
            </article>
            
            <article class="function" data-name="Date">
               <h3>
                  Date 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Date returns the year, month, and day in which t occurs.</p>
               
               <pre><code>func (t Time) Date() (year int, month Month, day int)</code></pre>
            </article>
            
            <article class="function" data-name="Day">
               <h3>
                  Day 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Day returns the day of the month specified by t.</p>
               
               <pre><code>func (t Time) Day() int</code></pre>
            </article>
            
            <article class="function" data-name="Equal">
               <h3>
                  Equal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Equal reports whether t and u represent the same time instant.
Two times can be equal even if they are in different locations.
For example, 6:00 +0200 and 4:00 UTC are Equal.
See the documentation on the Time type for the pitfalls of using == with
Time values; most code should use Equal instead.</p>
               
               <pre><code>func (t Time) Equal(u Time) bool</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f fileSizeError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Error returns the string representation of a ParseError.</p>
               
               <pre><code>func (e *ParseError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="FixedZone">
               <h3>
                  FixedZone 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>FixedZone returns a [Location] that always uses
the given zone name and offset (seconds east of UTC).</p>
               
               <pre><code>func FixedZone(name string, offset int) *Location</code></pre>
            </article>
            
            <article class="function" data-name="Format">
               <h3>
                  Format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Format returns a textual representation of the time value formatted according
to the layout defined by the argument. See the documentation for the
constant called [Layout] to see how to represent the layout format.
The executable example for [Time.Format] demonstrates the working
of the layout string in detail and is a good reference.</p>
               
               <pre><code>func (t Time) Format(layout string) string</code></pre>
            </article>
            
            <article class="function" data-name="GoString">
               <h3>
                  GoString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GoString implements [fmt.GoStringer] and formats t to be printed in Go source
code.</p>
               
               <pre><code>func (t Time) GoString() string</code></pre>
            </article>
            
            <article class="function" data-name="GobDecode">
               <h3>
                  GobDecode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GobDecode implements the gob.GobDecoder interface.</p>
               
               <pre><code>func (t *Time) GobDecode(data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="GobEncode">
               <h3>
                  GobEncode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>GobEncode implements the gob.GobEncoder interface.</p>
               
               <pre><code>func (t Time) GobEncode() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Hour">
               <h3>
                  Hour 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Hour returns the hour within the day specified by t, in the range [0, 23].</p>
               
               <pre><code>func (t Time) Hour() int</code></pre>
            </article>
            
            <article class="function" data-name="Hours">
               <h3>
                  Hours 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Hours returns the duration as a floating point number of hours.</p>
               
               <pre><code>func (d Duration) Hours() float64</code></pre>
            </article>
            
            <article class="function" data-name="ISOWeek">
               <h3>
                  ISOWeek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ISOWeek returns the ISO 8601 year and week number in which t occurs.
Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to
week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1
of year n+1.</p>
               
               <pre><code>func (t Time) ISOWeek() (year int, week int)</code></pre>
            </article>
            
            <article class="function" data-name="In">
               <h3>
                  In 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>In returns a copy of t representing the same time instant, but
with the copy's location information set to loc for display
purposes.
In panics if loc is nil.</p>
               
               <pre><code>func (t Time) In(loc *Location) Time</code></pre>
            </article>
            
            <article class="function" data-name="IsDST">
               <h3>
                  IsDST 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsDST reports whether the time in the configured location is in Daylight Savings Time.</p>
               
               <pre><code>func (t Time) IsDST() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsZero">
               <h3>
                  IsZero 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsZero reports whether t represents the zero time instant,
January 1, year 1, 00:00:00 UTC.</p>
               
               <pre><code>func (t Time) IsZero() bool</code></pre>
            </article>
            
            <article class="function" data-name="LoadLocation">
               <h3>
                  LoadLocation 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LoadLocation returns the Location with the given name.
If the name is "" or "UTC", LoadLocation returns UTC.
If the name is "Local", LoadLocation returns Local.
Otherwise, the name is taken to be a location name corresponding to a file
in the IANA Time Zone database, such as "America/New_York".
LoadLocation looks for the IANA Time Zone database in the following
locations in order:
- the directory or uncompressed zip file named by the ZONEINFO environment variable
- on a Unix system, the system standard installation location
- $GOROOT/lib/time/zoneinfo.zip
- the time/tzdata package, if it was imported</p>
               
               <pre><code>func LoadLocation(name string) (*Location, error)</code></pre>
            </article>
            
            <article class="function" data-name="LoadLocationFromTZData">
               <h3>
                  LoadLocationFromTZData 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>LoadLocationFromTZData returns a Location with the given name
initialized from the IANA Time Zone database-formatted data.
The data should be in the format of a standard IANA time zone file
(for example, the content of /etc/localtime on Unix systems).</p>
               
               <pre><code>func LoadLocationFromTZData(name string, data []byte) (*Location, error)</code></pre>
            </article>
            
            <article class="function" data-name="Local">
               <h3>
                  Local 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Local returns t with the location set to local time.</p>
               
               <pre><code>func (t Time) Local() Time</code></pre>
            </article>
            
            <article class="function" data-name="Location">
               <h3>
                  Location 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Location returns the time zone information associated with t.</p>
               
               <pre><code>func (t Time) Location() *Location</code></pre>
            </article>
            
            <article class="function" data-name="MarshalBinary">
               <h3>
                  MarshalBinary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalBinary implements the [encoding.BinaryMarshaler] interface.</p>
               
               <pre><code>func (t Time) MarshalBinary() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalJSON">
               <h3>
                  MarshalJSON 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalJSON implements the [encoding/json.Marshaler] interface.
The time is a quoted string in the RFC 3339 format with sub-second precision.
If the timestamp cannot be represented as valid RFC 3339
(e.g., the year is out of range), then an error is reported.</p>
               
               <pre><code>func (t Time) MarshalJSON() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="MarshalText">
               <h3>
                  MarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MarshalText implements the [encoding.TextMarshaler] interface. The output
matches that of calling the [Time.AppendText] method.
See [Time.AppendText] for more information.</p>
               
               <pre><code>func (t Time) MarshalText() ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Microseconds">
               <h3>
                  Microseconds 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Microseconds returns the duration as an integer microsecond count.</p>
               
               <pre><code>func (d Duration) Microseconds() int64</code></pre>
            </article>
            
            <article class="function" data-name="Milliseconds">
               <h3>
                  Milliseconds 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Milliseconds returns the duration as an integer millisecond count.</p>
               
               <pre><code>func (d Duration) Milliseconds() int64</code></pre>
            </article>
            
            <article class="function" data-name="Minute">
               <h3>
                  Minute 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Minute returns the minute offset within the hour specified by t, in the range [0, 59].</p>
               
               <pre><code>func (t Time) Minute() int</code></pre>
            </article>
            
            <article class="function" data-name="Minutes">
               <h3>
                  Minutes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Minutes returns the duration as a floating point number of minutes.</p>
               
               <pre><code>func (d Duration) Minutes() float64</code></pre>
            </article>
            
            <article class="function" data-name="Month">
               <h3>
                  Month 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Month returns the month of the year specified by t.</p>
               
               <pre><code>func (t Time) Month() Month</code></pre>
            </article>
            
            <article class="function" data-name="Nanosecond">
               <h3>
                  Nanosecond 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Nanosecond returns the nanosecond offset within the second specified by t,
in the range [0, 999999999].</p>
               
               <pre><code>func (t Time) Nanosecond() int</code></pre>
            </article>
            
            <article class="function" data-name="Nanoseconds">
               <h3>
                  Nanoseconds 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Nanoseconds returns the duration as an integer nanosecond count.</p>
               
               <pre><code>func (d Duration) Nanoseconds() int64</code></pre>
            </article>
            
            <article class="function" data-name="NewTicker">
               <h3>
                  NewTicker 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewTicker returns a new [Ticker] containing a channel that will send
the current time on the channel after each tick. The period of the
ticks is specified by the duration argument. The ticker will adjust
the time interval or drop ticks to make up for slow receivers.
The duration d must be greater than zero; if not, NewTicker will
panic.
Before Go 1.23, the garbage collector did not recover
tickers that had not yet expired or been stopped, so code often
immediately deferred t.Stop after calling NewTicker, to make
the ticker recoverable when it was no longer needed.
As of Go 1.23, the garbage collector can recover unreferenced
tickers, even if they haven't been stopped.
The Stop method is no longer necessary to help the garbage collector.
(Code may of course still want to call Stop to stop the ticker for other reasons.)</p>
               
               <pre><code>func NewTicker(d Duration) *Ticker</code></pre>
            </article>
            
            <article class="function" data-name="NewTimer">
               <h3>
                  NewTimer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewTimer creates a new Timer that will send
the current time on its channel after at least duration d.
Before Go 1.23, the garbage collector did not recover
timers that had not yet expired or been stopped, so code often
immediately deferred t.Stop after calling NewTimer, to make
the timer recoverable when it was no longer needed.
As of Go 1.23, the garbage collector can recover unreferenced
timers, even if they haven't expired or been stopped.
The Stop method is no longer necessary to help the garbage collector.
(Code may of course still want to call Stop to stop the timer for other reasons.)
Before Go 1.23, the channel associated with a Timer was
asynchronous (buffered, capacity 1), which meant that
stale time values could be received even after [Timer.Stop]
or [Timer.Reset] returned.
As of Go 1.23, the channel is synchronous (unbuffered, capacity 0),
eliminating the possibility of those stale values.
The GODEBUG setting asynctimerchan=1 restores both pre-Go 1.23
behaviors: when set, unexpired timers won't be garbage collected, and
channels will have buffered capacity. This setting may be removed
in Go 1.27 or later.</p>
               
               <pre><code>func NewTimer(d Duration) *Timer</code></pre>
            </article>
            
            <article class="function" data-name="Now">
               <h3>
                  Now 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Now returns the current local time.</p>
               
               <pre><code>func Now() Time</code></pre>
            </article>
            
            <article class="function" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Parse parses a formatted string and returns the time value it represents.
See the documentation for the constant called [Layout] to see how to
represent the format. The second argument must be parseable using
the format string (layout) provided as the first argument.
The example for [Time.Format] demonstrates the working of the layout string
in detail and is a good reference.
When parsing (only), the input may contain a fractional second
field immediately after the seconds field, even if the layout does not
signify its presence. In that case either a comma or a decimal point
followed by a maximal series of digits is parsed as a fractional second.
Fractional seconds are truncated to nanosecond precision.
Elements omitted from the layout are assumed to be zero or, when
zero is impossible, one, so parsing "3:04pm" returns the time
corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is
0, this time is before the zero Time).
Years must be in the range 0000..9999. The day of the week is checked
for syntax but it is otherwise ignored.
For layouts specifying the two-digit year 06, a value NN >= 69 will be treated
as 19NN and a value NN < 69 will be treated as 20NN.
The remainder of this comment describes the handling of time zones.
In the absence of a time zone indicator, Parse returns a time in UTC.
When parsing a time with a zone offset like -0700, if the offset corresponds
to a time zone used by the current location ([Local]), then Parse uses that
location and zone in the returned time. Otherwise it records the time as
being in a fabricated location with time fixed at the given zone offset.
When parsing a time with a zone abbreviation like MST, if the zone abbreviation
has a defined offset in the current location, then that offset is used.
The zone abbreviation "UTC" is recognized as UTC regardless of location.
If the zone abbreviation is unknown, Parse records the time as being
in a fabricated location with the given zone abbreviation and a zero offset.
This choice means that such a time can be parsed and reformatted with the
same layout losslessly, but the exact instant used in the representation will
differ by the actual zone offset. To avoid such problems, prefer time layouts
that use a numeric zone offset, or use [ParseInLocation].</p>
               
               <pre><code>func Parse(layout string, value string) (Time, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseDuration">
               <h3>
                  ParseDuration 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseDuration parses a duration string.
A duration string is a possibly signed sequence of
decimal numbers, each with optional fraction and a unit suffix,
such as "300ms", "-1.5h" or "2h45m".
Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".</p>
               
               <pre><code>func ParseDuration(s string) (Duration, error)</code></pre>
            </article>
            
            <article class="function" data-name="ParseInLocation">
               <h3>
                  ParseInLocation 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>ParseInLocation is like Parse but differs in two important ways.
First, in the absence of time zone information, Parse interprets a time as UTC;
ParseInLocation interprets the time as in the given location.
Second, when given a zone offset or abbreviation, Parse tries to match it
against the Local location; ParseInLocation uses the given location.</p>
               
               <pre><code>func ParseInLocation(layout string, value string, loc *Location) (Time, error)</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset changes the timer to expire after duration d.
It returns true if the timer had been active, false if the timer had
expired or been stopped.
For a func-based timer created with [AfterFunc](d, f), Reset either reschedules
when f will run, in which case Reset returns true, or schedules f
to run again, in which case it returns false.
When Reset returns false, Reset neither waits for the prior f to
complete before returning nor does it guarantee that the subsequent
goroutine running f does not run concurrently with the prior
one. If the caller needs to know whether the prior execution of
f is completed, it must coordinate with f explicitly.
For a chan-based timer created with NewTimer, as of Go 1.23,
any receive from t.C after Reset has returned is guaranteed not
to receive a time value corresponding to the previous timer settings;
if the program has not received from t.C already and the timer is
running, Reset is guaranteed to return true.
Before Go 1.23, the only safe way to use Reset was to call [Timer.Stop]
and explicitly drain the timer first.
See the [NewTimer] documentation for more details.</p>
               
               <pre><code>func (t *Timer) Reset(d Duration) bool</code></pre>
            </article>
            
            <article class="function" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Reset stops a ticker and resets its period to the specified duration.
The next tick will arrive after the new period elapses. The duration d
must be greater than zero; if not, Reset will panic.</p>
               
               <pre><code>func (t *Ticker) Reset(d Duration)</code></pre>
            </article>
            
            <article class="function" data-name="Round">
               <h3>
                  Round 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Round returns the result of rounding d to the nearest multiple of m.
The rounding behavior for halfway values is to round away from zero.
If the result exceeds the maximum (or minimum)
value that can be stored in a [Duration],
Round returns the maximum (or minimum) duration.
If m <= 0, Round returns d unchanged.</p>
               
               <pre><code>func (d Duration) Round(m Duration) Duration</code></pre>
            </article>
            
            <article class="function" data-name="Round">
               <h3>
                  Round 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Round returns the result of rounding t to the nearest multiple of d (since the zero time).
The rounding behavior for halfway values is to round up.
If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.
Round operates on the time as an absolute duration since the
zero time; it does not operate on the presentation form of the
time. Thus, Round(Hour) may return a time with a non-zero
minute, depending on the time's Location.</p>
               
               <pre><code>func (t Time) Round(d Duration) Time</code></pre>
            </article>
            
            <article class="function" data-name="Second">
               <h3>
                  Second 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Second returns the second offset within the minute specified by t, in the range [0, 59].</p>
               
               <pre><code>func (t Time) Second() int</code></pre>
            </article>
            
            <article class="function" data-name="Seconds">
               <h3>
                  Seconds 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Seconds returns the duration as a floating point number of seconds.</p>
               
               <pre><code>func (d Duration) Seconds() float64</code></pre>
            </article>
            
            <article class="function" data-name="Since">
               <h3>
                  Since 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Since returns the time elapsed since t.
It is shorthand for time.Now().Sub(t).</p>
               
               <pre><code>func Since(t Time) Duration</code></pre>
            </article>
            
            <article class="function" data-name="Sleep">
               <h3>
                  Sleep 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Sleep pauses the current goroutine for at least the duration d.
A negative or zero duration causes Sleep to return immediately.</p>
               
               <pre><code>func Sleep(d Duration)</code></pre>
            </article>
            
            <article class="function" data-name="Stop">
               <h3>
                  Stop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Stop prevents the [Timer] from firing.
It returns true if the call stops the timer, false if the timer has already
expired or been stopped.
For a func-based timer created with [AfterFunc](d, f),
if t.Stop returns false, then the timer has already expired
and the function f has been started in its own goroutine;
Stop does not wait for f to complete before returning.
If the caller needs to know whether f is completed,
it must coordinate with f explicitly.
For a chan-based timer created with NewTimer(d), as of Go 1.23,
any receive from t.C after Stop has returned is guaranteed to block
rather than receive a stale time value from before the Stop;
if the program has not received from t.C already and the timer is
running, Stop is guaranteed to return true.
Before Go 1.23, the only safe way to use Stop was insert an extra
<-t.C if Stop returned false to drain a potential stale value.
See the [NewTimer] documentation for more details.</p>
               
               <pre><code>func (t *Timer) Stop() bool</code></pre>
            </article>
            
            <article class="function" data-name="Stop">
               <h3>
                  Stop 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Stop turns off a ticker. After Stop, no more ticks will be sent.
Stop does not close the channel, to prevent a concurrent goroutine
reading from the channel from seeing an erroneous "tick".</p>
               
               <pre><code>func (t *Ticker) Stop()</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a descriptive name for the time zone information,
corresponding to the name argument to [LoadLocation] or [FixedZone].</p>
               
               <pre><code>func (l *Location) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the English name of the day ("Sunday", "Monday", ...).</p>
               
               <pre><code>func (d Weekday) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the English name of the month ("January", "February", ...).</p>
               
               <pre><code>func (m Month) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the time formatted using the format string
"2006-01-02 15:04:05.999999999 -0700 MST"
If the time has a monotonic clock reading, the returned string
includes a final field "m=±<value>", where value is the monotonic
clock reading formatted as a decimal number of seconds.
The returned string is meant for debugging; for a stable serialized
representation, use t.MarshalText, t.MarshalBinary, or t.Format
with an explicit format string.</p>
               
               <pre><code>func (t Time) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a string representing the duration in the form "72h3m0.5s".
Leading zero units are omitted. As a special case, durations less than one
second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure
that the leading digit is non-zero. The zero duration formats as 0s.</p>
               
               <pre><code>func (d Duration) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Sub">
               <h3>
                  Sub 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Sub returns the duration t-u. If the result exceeds the maximum (or minimum)
value that can be stored in a [Duration], the maximum (or minimum) duration
will be returned.
To compute t-d for a duration d, use t.Add(-d).</p>
               
               <pre><code>func (t Time) Sub(u Time) Duration</code></pre>
            </article>
            
            <article class="function" data-name="Tick">
               <h3>
                  Tick 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Tick is a convenience wrapper for [NewTicker] providing access to the ticking
channel only. Unlike NewTicker, Tick will return nil if d <= 0.
Before Go 1.23, this documentation warned that the underlying
[Ticker] would never be recovered by the garbage collector, and that
if efficiency was a concern, code should use NewTicker instead and
call [Ticker.Stop] when the ticker is no longer needed.
As of Go 1.23, the garbage collector can recover unreferenced
tickers, even if they haven't been stopped.
The Stop method is no longer necessary to help the garbage collector.
There is no longer any reason to prefer NewTicker when Tick will do.</p>
               
               <pre><code>func Tick(d Duration) (<-chan Time)</code></pre>
            </article>
            
            <article class="function" data-name="Truncate">
               <h3>
                  Truncate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Truncate returns the result of rounding d toward zero to a multiple of m.
If m <= 0, Truncate returns d unchanged.</p>
               
               <pre><code>func (d Duration) Truncate(m Duration) Duration</code></pre>
            </article>
            
            <article class="function" data-name="Truncate">
               <h3>
                  Truncate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Truncate returns the result of rounding t down to a multiple of d (since the zero time).
If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.
Truncate operates on the time as an absolute duration since the
zero time; it does not operate on the presentation form of the
time. Thus, Truncate(Hour) may return a time with a non-zero
minute, depending on the time's Location.</p>
               
               <pre><code>func (t Time) Truncate(d Duration) Time</code></pre>
            </article>
            
            <article class="function" data-name="UTC">
               <h3>
                  UTC 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UTC returns t with the location set to UTC.</p>
               
               <pre><code>func (t Time) UTC() Time</code></pre>
            </article>
            
            <article class="function" data-name="Unix">
               <h3>
                  Unix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Unix returns the local Time corresponding to the given Unix time,
sec seconds and nsec nanoseconds since January 1, 1970 UTC.
It is valid to pass nsec outside the range [0, 999999999].
Not all sec values have a corresponding time value. One such
value is 1<<63-1 (the largest int64 value).</p>
               
               <pre><code>func Unix(sec int64, nsec int64) Time</code></pre>
            </article>
            
            <article class="function" data-name="Unix">
               <h3>
                  Unix 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Unix returns t as a Unix time, the number of seconds elapsed
since January 1, 1970 UTC. The result does not depend on the
location associated with t.
Unix-like operating systems often record time as a 32-bit
count of seconds, but since the method here returns a 64-bit
value it is valid for billions of years into the past or future.</p>
               
               <pre><code>func (t Time) Unix() int64</code></pre>
            </article>
            
            <article class="function" data-name="UnixMicro">
               <h3>
                  UnixMicro 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnixMicro returns t as a Unix time, the number of microseconds elapsed since
January 1, 1970 UTC. The result is undefined if the Unix time in
microseconds cannot be represented by an int64 (a date before year -290307 or
after year 294246). The result does not depend on the location associated
with t.</p>
               
               <pre><code>func (t Time) UnixMicro() int64</code></pre>
            </article>
            
            <article class="function" data-name="UnixMicro">
               <h3>
                  UnixMicro 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>UnixMicro returns the local Time corresponding to the given Unix time,
usec microseconds since January 1, 1970 UTC.</p>
               
               <pre><code>func UnixMicro(usec int64) Time</code></pre>
            </article>
            
            <article class="function" data-name="UnixMilli">
               <h3>
                  UnixMilli 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnixMilli returns t as a Unix time, the number of milliseconds elapsed since
January 1, 1970 UTC. The result is undefined if the Unix time in
milliseconds cannot be represented by an int64 (a date more than 292 million
years before or after 1970). The result does not depend on the
location associated with t.</p>
               
               <pre><code>func (t Time) UnixMilli() int64</code></pre>
            </article>
            
            <article class="function" data-name="UnixMilli">
               <h3>
                  UnixMilli 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>UnixMilli returns the local Time corresponding to the given Unix time,
msec milliseconds since January 1, 1970 UTC.</p>
               
               <pre><code>func UnixMilli(msec int64) Time</code></pre>
            </article>
            
            <article class="function" data-name="UnixNano">
               <h3>
                  UnixNano 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnixNano returns t as a Unix time, the number of nanoseconds elapsed
since January 1, 1970 UTC. The result is undefined if the Unix time
in nanoseconds cannot be represented by an int64 (a date before the year
1678 or after 2262). Note that this means the result of calling UnixNano
on the zero Time is undefined. The result does not depend on the
location associated with t.</p>
               
               <pre><code>func (t Time) UnixNano() int64</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalBinary">
               <h3>
                  UnmarshalBinary 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalBinary implements the [encoding.BinaryUnmarshaler] interface.</p>
               
               <pre><code>func (t *Time) UnmarshalBinary(data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalJSON">
               <h3>
                  UnmarshalJSON 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalJSON implements the [encoding/json.Unmarshaler] interface.
The time must be a quoted string in the RFC 3339 format.</p>
               
               <pre><code>func (t *Time) UnmarshalJSON(data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="UnmarshalText">
               <h3>
                  UnmarshalText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>UnmarshalText implements the [encoding.TextUnmarshaler] interface.
The time must be in the RFC 3339 format.</p>
               
               <pre><code>func (t *Time) UnmarshalText(data []byte) error</code></pre>
            </article>
            
            <article class="function" data-name="Until">
               <h3>
                  Until 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Until returns the duration until t.
It is shorthand for t.Sub(time.Now()).</p>
               
               <pre><code>func Until(t Time) Duration</code></pre>
            </article>
            
            <article class="function" data-name="Weekday">
               <h3>
                  Weekday 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Weekday returns the day of the week specified by t.</p>
               
               <pre><code>func (t Time) Weekday() Weekday</code></pre>
            </article>
            
            <article class="function" data-name="Year">
               <h3>
                  Year 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Year returns the year in which t occurs.</p>
               
               <pre><code>func (t Time) Year() int</code></pre>
            </article>
            
            <article class="function" data-name="YearDay">
               <h3>
                  YearDay 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years,
and [1,366] in leap years.</p>
               
               <pre><code>func (t Time) YearDay() int</code></pre>
            </article>
            
            <article class="function" data-name="Zone">
               <h3>
                  Zone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Zone computes the time zone in effect at time t, returning the abbreviated
name of the zone (such as "CET") and its offset in seconds east of UTC.</p>
               
               <pre><code>func (t Time) Zone() (name string, offset int)</code></pre>
            </article>
            
            <article class="function" data-name="ZoneBounds">
               <h3>
                  ZoneBounds 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ZoneBounds returns the bounds of the time zone in effect at time t.
The zone begins at start and the next zone begins at end.
If the zone begins at the beginning of time, start will be returned as a zero Time.
If the zone goes on forever, end will be returned as a zero Time.
The Location of the returned times will be the same as t.</p>
               
               <pre><code>func (t Time) ZoneBounds() (start Time, end Time)</code></pre>
            </article>
            
            <article class="function" data-name="abbrev">
               <h3>
                  abbrev 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>abbrev returns the abbreviations to use for the given zone z.</p>
               
               <pre><code>func abbrev(z *syscall.Timezoneinformation) (std string, dst string)</code></pre>
            </article>
            
            <article class="function" data-name="absSec">
               <h3>
                  absSec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>absSec returns the time t as an absolute seconds, adjusted by the zone offset.
It is called when computing a presentation property like Month or Hour.
We'd rather call it abs, but there are linknames to abs that make that problematic.
See timeAbs below.</p>
               
               <pre><code>func (t Time) absSec() absSeconds</code></pre>
            </article>
            
            <article class="function" data-name="addSec">
               <h3>
                  addSec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>addSec adds d seconds to the time.</p>
               
               <pre><code>func (t *Time) addSec(d int64)</code></pre>
            </article>
            
            <article class="function" data-name="androidLoadTzinfoFromTzdata">
               <h3>
                  androidLoadTzinfoFromTzdata 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func androidLoadTzinfoFromTzdata(file string, name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="appendFormat">
               <h3>
                  appendFormat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t Time) appendFormat(b []byte, layout string) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendFormatRFC3339">
               <h3>
                  appendFormatRFC3339 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t Time) appendFormatRFC3339(b []byte, nanos bool) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendInt">
               <h3>
                  appendInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendInt appends the decimal form of x to b and returns the result.
If the decimal form (excluding sign) is shorter than width, the result is padded with leading 0's.
Duplicates functionality in strconv, but avoids dependency.</p>
               
               <pre><code>func appendInt(b []byte, x int, width int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendNano">
               <h3>
                  appendNano 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>appendNano appends a fractional second, as nanoseconds, to b
and returns the result. The nanosec must be within [0, 999999999].</p>
               
               <pre><code>func appendNano(b []byte, nanosec int, std int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="appendStrictRFC3339">
               <h3>
                  appendStrictRFC3339 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t Time) appendStrictRFC3339(b []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="appendTo">
               <h3>
                  appendTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t Time) appendTo(b []byte, errPrefix string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="atoi">
               <h3>
                  atoi 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Duplicates functionality in strconv, but avoids dependency.</p>
               
               <pre><code>func atoi(s bytes) (x int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="big4">
               <h3>
                  big4 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dataIO) big4() (n uint32, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="big8">
               <h3>
                  big8 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dataIO) big8() (n uint64, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="byte">
               <h3>
                  byte 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dataIO) byte() (n byte, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="byteString">
               <h3>
                  byteString 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Make a string by stopping at the first NUL</p>
               
               <pre><code>func byteString(p []byte) string</code></pre>
            </article>
            
            <article class="function" data-name="clock">
               <h3>
                  clock 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>clock returns the hour, minute, and second within the day specified by abs.</p>
               
               <pre><code>func (abs absSeconds) clock() (hour int, min int, sec int)</code></pre>
            </article>
            
            <article class="function" data-name="closefd">
               <h3>
                  closefd 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func closefd(fd uintptr)</code></pre>
            </article>
            
            <article class="function" data-name="closefd">
               <h3>
                  closefd 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func closefd(fd uintptr)</code></pre>
            </article>
            
            <article class="function" data-name="closefd">
               <h3>
                  closefd 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func closefd(fd uintptr)</code></pre>
            </article>
            
            <article class="function" data-name="commaOrPeriod">
               <h3>
                  commaOrPeriod 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func commaOrPeriod(b byte) bool</code></pre>
            </article>
            
            <article class="function" data-name="containsDotDot">
               <h3>
                  containsDotDot 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>containsDotDot reports whether s contains "..".</p>
               
               <pre><code>func containsDotDot(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="cutspace">
               <h3>
                  cutspace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func cutspace(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="date">
               <h3>
                  date 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>date converts days into standard year, month, day.</p>
               
               <pre><code>func (days absDays) date() (year int, month Month, day int)</code></pre>
            </article>
            
            <article class="function" data-name="dateToAbsDays">
               <h3>
                  dateToAbsDays 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>dateToAbsDays takes a standard year/month/day and returns the
number of days from the absolute epoch to that day.
The days argument can be out of range and in particular can be negative.</p>
               
               <pre><code>func dateToAbsDays(year int64, month Month, day int) absDays</code></pre>
            </article>
            
            <article class="function" data-name="days">
               <h3>
                  days 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>days converts absolute seconds to absolute days.</p>
               
               <pre><code>func (abs absSeconds) days() absDays</code></pre>
            </article>
            
            <article class="function" data-name="daysBefore">
               <h3>
                  daysBefore 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>daysBefore returns the number of days in a non-leap year before month m.
daysBefore(December+1) returns 365.</p>
               
               <pre><code>func daysBefore(m Month) int</code></pre>
            </article>
            
            <article class="function" data-name="daysIn">
               <h3>
                  daysIn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func daysIn(m Month, year int) int</code></pre>
            </article>
            
            <article class="function" data-name="digitsLen">
               <h3>
                  digitsLen 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func digitsLen(std int) int</code></pre>
            </article>
            
            <article class="function" data-name="div">
               <h3>
                  div 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>div divides t by d and returns the quotient parity and remainder.
We don't use the quotient parity anymore (round half up instead of round to even)
but it's still here in case we change our minds.</p>
               
               <pre><code>func div(t Time, d Duration) (qmod2 int, r Duration)</code></pre>
            </article>
            
            <article class="function" data-name="extractCAPS">
               <h3>
                  extractCAPS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>extractCAPS extracts capital letters from description desc.</p>
               
               <pre><code>func extractCAPS(desc string) string</code></pre>
            </article>
            
            <article class="function" data-name="fields">
               <h3>
                  fields 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Copied from strings to avoid a dependency.</p>
               
               <pre><code>func fields(s string) []string</code></pre>
            </article>
            
            <article class="function" data-name="findZone">
               <h3>
                  findZone 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func findZone(zones []zone, name string, offset int, isDST bool) int</code></pre>
            </article>
            
            <article class="function" data-name="firstZoneUsed">
               <h3>
                  firstZoneUsed 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>firstZoneUsed reports whether the first zone is used by some
transition.</p>
               
               <pre><code>func (l *Location) firstZoneUsed() bool</code></pre>
            </article>
            
            <article class="function" data-name="fixedZone">
               <h3>
                  fixedZone 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fixedZone(name string, offset int) *Location</code></pre>
            </article>
            
            <article class="function" data-name="fmtFrac">
               <h3>
                  fmtFrac 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fmtFrac formats the fraction of v/10**prec (e.g., ".12345") into the
tail of buf, omitting trailing zeros. It omits the decimal
point too when the fraction is 0. It returns the index where the
output bytes begin and the value v/10**prec.</p>
               
               <pre><code>func fmtFrac(buf []byte, v uint64, prec int) (nw int, nv uint64)</code></pre>
            </article>
            
            <article class="function" data-name="fmtInt">
               <h3>
                  fmtInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>fmtInt formats v into the tail of buf.
It returns the index where the output begins.</p>
               
               <pre><code>func fmtInt(buf []byte, v uint64) int</code></pre>
            </article>
            
            <article class="function" data-name="format">
               <h3>
                  format 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>format formats the representation of d into the end of buf and
returns the offset of the first character.</p>
               
               <pre><code>func (d Duration) format(buf *[32]byte) int</code></pre>
            </article>
            
            <article class="function" data-name="get">
               <h3>
                  get 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *Location) get() *Location</code></pre>
            </article>
            
            <article class="function" data-name="get2">
               <h3>
                  get2 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>get2 returns the little-endian 16-bit value in b.</p>
               
               <pre><code>func get2(b []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="get4">
               <h3>
                  get4 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>get4 returns the little-endian 32-bit value in b.</p>
               
               <pre><code>func get4(b []byte) int</code></pre>
            </article>
            
            <article class="function" data-name="getnum">
               <h3>
                  getnum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>getnum parses s[0:1] or s[0:2] (fixed forces s[0:2])
as a decimal integer and returns the integer and the
remainder of the string.</p>
               
               <pre><code>func getnum(s string, fixed bool) (int, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="getnum3">
               <h3>
                  getnum3 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>getnum3 parses s[0:1], s[0:2], or s[0:3] (fixed forces s[0:3])
as a decimal integer and returns the integer and the remainder
of the string.</p>
               
               <pre><code>func getnum3(s string, fixed bool) (int, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="goFunc">
               <h3>
                  goFunc 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func goFunc(arg any, seq uintptr, delta int64)</code></pre>
            </article>
            
            <article class="function" data-name="gorootZoneSource">
               <h3>
                  gorootZoneSource 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func gorootZoneSource(goroot string) (string, bool)</code></pre>
            </article>
            
            <article class="function" data-name="gorootZoneSource">
               <h3>
                  gorootZoneSource 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func gorootZoneSource(goroot string) (string, bool)</code></pre>
            </article>
            
            <article class="function" data-name="gorootZoneSource">
               <h3>
                  gorootZoneSource 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func gorootZoneSource(goroot string) (string, bool)</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initLocal()</code></pre>
            </article>
            
            <article class="function" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initLocal()</code></pre>
            </article>
            
            <article class="function" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initLocal()</code></pre>
            </article>
            
            <article class="function" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initLocal()</code></pre>
            </article>
            
            <article class="function" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initLocal()</code></pre>
            </article>
            
            <article class="function" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initLocal()</code></pre>
            </article>
            
            <article class="function" data-name="initLocal">
               <h3>
                  initLocal 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initLocal()</code></pre>
            </article>
            
            <article class="function" data-name="initLocalFromTZI">
               <h3>
                  initLocalFromTZI 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func initLocalFromTZI(i *syscall.Timezoneinformation)</code></pre>
            </article>
            
            <article class="function" data-name="interrupt">
               <h3>
                  interrupt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>for testing: whatever interrupts a sleep</p>
               
               <pre><code>func interrupt()</code></pre>
            </article>
            
            <article class="function" data-name="interrupt">
               <h3>
                  interrupt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>for testing: whatever interrupts a sleep</p>
               
               <pre><code>func interrupt()</code></pre>
            </article>
            
            <article class="function" data-name="interrupt">
               <h3>
                  interrupt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>for testing: whatever interrupts a sleep</p>
               
               <pre><code>func interrupt()</code></pre>
            </article>
            
            <article class="function" data-name="isDigit">
               <h3>
                  isDigit 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isDigit reports whether s[i] is in range and is a decimal digit.</p>
               
               <pre><code>func isDigit(s bytes, i int) bool</code></pre>
            </article>
            
            <article class="function" data-name="isLeap">
               <h3>
                  isLeap 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isLeap(year int) bool</code></pre>
            </article>
            
            <article class="function" data-name="isSpace">
               <h3>
                  isSpace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func isSpace(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="janFeb">
               <h3>
                  janFeb 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>janFeb returns 1 if the March 1-based ayday is in January or February, 0 otherwise.</p>
               
               <pre><code>func (ayday absYday) janFeb() absJanFeb</code></pre>
            </article>
            
            <article class="function" data-name="leadingFraction">
               <h3>
                  leadingFraction 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>leadingFraction consumes the leading [0-9]* from s.
It is used only for fractions, so does not return an error on overflow,
it just stops accumulating precision.</p>
               
               <pre><code>func leadingFraction(s string) (x uint64, scale float64, rem string)</code></pre>
            </article>
            
            <article class="function" data-name="leadingInt">
               <h3>
                  leadingInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>leadingInt consumes the leading [0-9]* from s.</p>
               
               <pre><code>func leadingInt(s bytes) (x uint64, rem bytes, err error)</code></pre>
            </article>
            
            <article class="function" data-name="leap">
               <h3>
                  leap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>leap returns 1 if (century, cyear) is a leap year, 0 otherwise.</p>
               
               <pre><code>func (century absCentury) leap(cyear absCyear) absLeap</code></pre>
            </article>
            
            <article class="function" data-name="legacyAbsClock">
               <h3>
                  legacyAbsClock 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname legacyAbsClock time.absClock</p>
               
               <pre><code>func legacyAbsClock(abs uint64) (hour int, min int, sec int)</code></pre>
            </article>
            
            <article class="function" data-name="legacyAbsDate">
               <h3>
                  legacyAbsDate 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname legacyAbsDate time.absDate</p>
               
               <pre><code>func legacyAbsDate(abs uint64, full bool) (year int, month Month, day int, yday int)</code></pre>
            </article>
            
            <article class="function" data-name="legacyTimeTimeAbs">
               <h3>
                  legacyTimeTimeAbs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname legacyTimeTimeAbs time.Time.abs</p>
               
               <pre><code>func legacyTimeTimeAbs(t Time) uint64</code></pre>
            </article>
            
            <article class="function" data-name="lessThanHalf">
               <h3>
                  lessThanHalf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lessThanHalf reports whether x+x < y but avoids overflow,
assuming x and y are both positive (Duration is signed).</p>
               
               <pre><code>func lessThanHalf(x Duration, y Duration) bool</code></pre>
            </article>
            
            <article class="function" data-name="loadLocation">
               <h3>
                  loadLocation 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>loadLocation returns the Location with the given name from one of
the specified sources. See loadTzinfo for a list of supported sources.
The first timezone data matching the given name that is successfully loaded
and parsed is returned as a Location.</p>
               
               <pre><code>func loadLocation(name string, sources []string) (z *Location, firstErr error)</code></pre>
            </article>
            
            <article class="function" data-name="loadTzinfo">
               <h3>
                  loadTzinfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>loadTzinfo returns the time zone information of the time zone
with the given name, from a given source. A source may be a
timezone database directory, tzdata database file or an uncompressed
zip file, containing the contents of such a directory.</p>
               
               <pre><code>func loadTzinfo(name string, source string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="loadTzinfoFromDirOrZip">
               <h3>
                  loadTzinfoFromDirOrZip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>loadTzinfoFromDirOrZip returns the contents of the file with the given name
in dir. dir can either be an uncompressed zip file, or a directory.</p>
               
               <pre><code>func loadTzinfoFromDirOrZip(dir string, name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="loadTzinfoFromZip">
               <h3>
                  loadTzinfoFromZip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>loadTzinfoFromZip returns the contents of the file with the given name
in the given uncompressed zip file.</p>
               
               <pre><code>func loadTzinfoFromZip(zipfile string, name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="loadZoneDataPlan9">
               <h3>
                  loadZoneDataPlan9 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func loadZoneDataPlan9(s string) (l *Location, err error)</code></pre>
            </article>
            
            <article class="function" data-name="loadZoneFilePlan9">
               <h3>
                  loadZoneFilePlan9 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func loadZoneFilePlan9(name string) (*Location, error)</code></pre>
            </article>
            
            <article class="function" data-name="locabs">
               <h3>
                  locabs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>locabs is a combination of the Zone and abs methods,
extracting both return values from a single zone lookup.</p>
               
               <pre><code>func (t Time) locabs() (name string, offset int, abs absSeconds)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookup returns information about the time zone in use at an
instant in time expressed as seconds since January 1, 1970 00:00:00 UTC.
The returned information gives the name of the zone (such as "CET"),
the start and end times bracketing sec when that zone is in effect,
the offset in seconds east of UTC (such as -5*60*60), and whether
the daylight savings is being observed at that time.</p>
               
               <pre><code>func (l *Location) lookup(sec int64) (name string, offset int, start int64, end int64, isDST bool)</code></pre>
            </article>
            
            <article class="function" data-name="lookup">
               <h3>
                  lookup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lookup(tab []string, val string) (int, string, error)</code></pre>
            </article>
            
            <article class="function" data-name="lookupFirstZone">
               <h3>
                  lookupFirstZone 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupFirstZone returns the index of the time zone to use for times
before the first transition time, or when there are no transition
times.
The reference implementation in localtime.c from
https://www.iana.org/time-zones/repository/releases/tzcode2013g.tar.gz
implements the following algorithm for these cases:
1. If the first zone is unused by the transitions, use it.
2. Otherwise, if there are transition times, and the first
transition is to a zone in daylight time, find the first
non-daylight-time zone before and closest to the first transition
zone.
3. Otherwise, use the first zone that is not daylight time, if
there is one.
4. Otherwise, use the first zone.</p>
               
               <pre><code>func (l *Location) lookupFirstZone() int</code></pre>
            </article>
            
            <article class="function" data-name="lookupName">
               <h3>
                  lookupName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>lookupName returns information about the time zone with
the given name (such as "EST") at the given pseudo-Unix time
(what the given time of day would be in UTC).</p>
               
               <pre><code>func (l *Location) lookupName(name string, unix int64) (offset int, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="match">
               <h3>
                  match 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>match reports whether s1 and s2 match ignoring case.
It is assumed s1 and s2 are the same length.</p>
               
               <pre><code>func match(s1 string, s2 string) bool</code></pre>
            </article>
            
            <article class="function" data-name="matchZoneKey">
               <h3>
                  matchZoneKey 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>matchZoneKey checks if stdname and dstname match the corresponding key
values "MUI_Std" and "MUI_Dlt" or "Std" and "Dlt" in the kname key stored
under the open registry key zones.</p>
               
               <pre><code>func matchZoneKey(zones registry.Key, kname string, stdname string, dstname string) (matched bool, err2 error)</code></pre>
            </article>
            
            <article class="function" data-name="mono">
               <h3>
                  mono 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>mono returns t's monotonic clock reading.
It returns 0 for a missing reading.
This function is used only for testing,
so it's OK that technically 0 is a valid
monotonic clock reading as well.</p>
               
               <pre><code>func (t *Time) mono() int64</code></pre>
            </article>
            
            <article class="function" data-name="month">
               <h3>
                  month 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>month returns the standard Month for (m, janFeb)</p>
               
               <pre><code>func (m absMonth) month(janFeb absJanFeb) Month</code></pre>
            </article>
            
            <article class="function" data-name="newParseError">
               <h3>
                  newParseError 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newParseError creates a new ParseError.
The provided value and valueElem are cloned to avoid escaping their values.</p>
               
               <pre><code>func newParseError(layout string, value string, layoutElem string, valueElem string, message string) *ParseError</code></pre>
            </article>
            
            <article class="function" data-name="newTimer">
               <h3>
                  newTimer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>The arg cp is a chan Time, but the declaration in runtime uses a pointer,
so we use a pointer here too. This keeps some tools that aggressively
compare linknamed symbol definitions happier.
go:linkname newTimer</p>
               
               <pre><code>func newTimer(when int64, period int64, f func(any, uintptr, int64), arg any, cp unsafe.Pointer) *Timer</code></pre>
            </article>
            
            <article class="function" data-name="nextStdChunk">
               <h3>
                  nextStdChunk 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>nextStdChunk finds the first occurrence of a std string in
layout and returns the text before, the std string, and the text after.
nextStdChunk should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- github.com/searKing/golang/go
Do not remove or change the type signature.
See go.dev/issue/67401.
go:linkname nextStdChunk</p>
               
               <pre><code>func nextStdChunk(layout string) (prefix string, std int, suffix string)</code></pre>
            </article>
            
            <article class="function" data-name="norm">
               <h3>
                  norm 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>norm returns nhi, nlo such that
hi * base + lo == nhi * base + nlo
0 <= nlo < base</p>
               
               <pre><code>func norm(hi int, lo int, base int) (nhi int, nlo int)</code></pre>
            </article>
            
            <article class="function" data-name="now">
               <h3>
                  now 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Provided by package runtime.
now returns the current real time, and is superseded by runtimeNow which returns
the fake synctest clock when appropriate.
now should be an internal detail,
but widely used packages access it using linkname.
Notable members of the hall of shame include:
- gitee.com/quant1x/gox
- github.com/phuslu/log
- github.com/sethvargo/go-limiter
- github.com/ulule/limiter/v3
Do not remove or change the type signature.
See go.dev/issue/67401.</p>
               
               <pre><code>func now() (sec int64, nsec int32, mono int64)</code></pre>
            </article>
            
            <article class="function" data-name="nsec">
               <h3>
                  nsec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>nsec returns the time's nanoseconds.</p>
               
               <pre><code>func (t *Time) nsec() int32</code></pre>
            </article>
            
            <article class="function" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func open(name string) (uintptr, error)</code></pre>
            </article>
            
            <article class="function" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func open(name string) (uintptr, error)</code></pre>
            </article>
            
            <article class="function" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func open(name string) (uintptr, error)</code></pre>
            </article>
            
            <article class="function" data-name="parse">
               <h3>
                  parse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parse(layout string, value string, defaultLocation *Location, local *Location) (Time, error)</code></pre>
            </article>
            
            <article class="function" data-name="parseGMT">
               <h3>
                  parseGMT 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseGMT parses a GMT time zone. The input string is known to start "GMT".
The function checks whether that is followed by a sign and a number in the
range -23 through +23 excluding zero.</p>
               
               <pre><code>func parseGMT(value string) int</code></pre>
            </article>
            
            <article class="function" data-name="parseNanoseconds">
               <h3>
                  parseNanoseconds 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseNanoseconds(value bytes, nbytes int) (ns int, rangeErrString string, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseRFC3339">
               <h3>
                  parseRFC3339 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseRFC3339(s bytes, local *Location) (Time, bool)</code></pre>
            </article>
            
            <article class="function" data-name="parseSignedOffset">
               <h3>
                  parseSignedOffset 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseSignedOffset parses a signed timezone offset (e.g. "+03" or "-04").
The function checks for a signed number in the range -23 through +23 excluding zero.
Returns length of the found offset string or 0 otherwise.</p>
               
               <pre><code>func parseSignedOffset(value string) int</code></pre>
            </article>
            
            <article class="function" data-name="parseStrictRFC3339">
               <h3>
                  parseStrictRFC3339 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseStrictRFC3339(b []byte) (Time, error)</code></pre>
            </article>
            
            <article class="function" data-name="parseTimeZone">
               <h3>
                  parseTimeZone 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseTimeZone parses a time zone string and returns its length. Time zones
are human-generated and unpredictable. We can't do precise error checking.
On the other hand, for a correct parse there must be a time zone at the
beginning of the string, so it's almost always true that there's one
there. We look at the beginning of the string for a run of upper-case letters.
If there are more than 5, it's an error.
If there are 4 or 5 and the last is a T, it's a time zone.
If there are 3, it's a time zone.
Otherwise, other than special cases, it's not a time zone.
GMT is special because it can have an hour offset.</p>
               
               <pre><code>func parseTimeZone(value string) (length int, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="preadn">
               <h3>
                  preadn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func preadn(fd uintptr, buf []byte, off int) error</code></pre>
            </article>
            
            <article class="function" data-name="preadn">
               <h3>
                  preadn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func preadn(fd uintptr, buf []byte, off int) error</code></pre>
            </article>
            
            <article class="function" data-name="preadn">
               <h3>
                  preadn 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func preadn(fd uintptr, buf []byte, off int) error</code></pre>
            </article>
            
            <article class="function" data-name="pseudoUnix">
               <h3>
                  pseudoUnix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>pseudoUnix returns the pseudo-Unix time (seconds since Jan 1 1970 *LOCAL TIME*)
denoted by the system date+time d in the given year.
It is up to the caller to convert this local time into a UTC-based time.</p>
               
               <pre><code>func pseudoUnix(year int, d *syscall.Systemtime) int64</code></pre>
            </article>
            
            <article class="function" data-name="quote">
               <h3>
                  quote 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func quote(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="read">
               <h3>
                  read 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func read(fd uintptr, buf []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="read">
               <h3>
                  read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *dataIO) read(n int) []byte</code></pre>
            </article>
            
            <article class="function" data-name="read">
               <h3>
                  read 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func read(fd uintptr, buf []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="read">
               <h3>
                  read 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func read(fd uintptr, buf []byte) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="readFile">
               <h3>
                  readFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readFile reads and returns the content of the named file.
It is a trivial implementation of os.ReadFile, reimplemented
here to avoid depending on io/ioutil or os.
It returns an error if name exceeds maxFileSize bytes.</p>
               
               <pre><code>func readFile(name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="registerLoadFromEmbeddedTZData">
               <h3>
                  registerLoadFromEmbeddedTZData 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>registerLoadFromEmbeddedTZData is called by the time/tzdata package,
if it is imported.
go:linkname registerLoadFromEmbeddedTZData</p>
               
               <pre><code>func registerLoadFromEmbeddedTZData(f func(string) (string, error))</code></pre>
            </article>
            
            <article class="function" data-name="resetTimer">
               <h3>
                  resetTimer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname resetTimer</p>
               
               <pre><code>func resetTimer(t *Timer, when int64, period int64) bool</code></pre>
            </article>
            
            <article class="function" data-name="rest">
               <h3>
                  rest 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>rest returns the rest of the data in the buffer.</p>
               
               <pre><code>func (d *dataIO) rest() []byte</code></pre>
            </article>
            
            <article class="function" data-name="runtimeNano">
               <h3>
                  runtimeNano 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>runtimeNano returns the current value of the runtime clock in nanoseconds.
When called within a synctest.Run bubble, it returns the group's fake clock.
go:linkname runtimeNano</p>
               
               <pre><code>func runtimeNano() int64</code></pre>
            </article>
            
            <article class="function" data-name="runtimeNow">
               <h3>
                  runtimeNow 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>runtimeNow returns the current time.
When called within a synctest.Run bubble, it returns the group's fake clock.
go:linkname runtimeNow</p>
               
               <pre><code>func runtimeNow() (sec int64, nsec int32, mono int64)</code></pre>
            </article>
            
            <article class="function" data-name="sec">
               <h3>
                  sec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>sec returns the time's seconds since Jan 1 year 1.</p>
               
               <pre><code>func (t *Time) sec() int64</code></pre>
            </article>
            
            <article class="function" data-name="sendTime">
               <h3>
                  sendTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>sendTime does a non-blocking send of the current time on c.</p>
               
               <pre><code>func sendTime(c any, seq uintptr, delta int64)</code></pre>
            </article>
            
            <article class="function" data-name="separator">
               <h3>
                  separator 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func separator(std int) byte</code></pre>
            </article>
            
            <article class="function" data-name="setLoc">
               <h3>
                  setLoc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setLoc sets the location associated with the time.</p>
               
               <pre><code>func (t *Time) setLoc(loc *Location)</code></pre>
            </article>
            
            <article class="function" data-name="setMono">
               <h3>
                  setMono 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>setMono sets the monotonic clock reading in t.
If t cannot hold a monotonic clock reading,
because its wall time is too large,
setMono is a no-op.</p>
               
               <pre><code>func (t *Time) setMono(m int64)</code></pre>
            </article>
            
            <article class="function" data-name="skip">
               <h3>
                  skip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>skip removes the given prefix from value,
treating runs of space characters as equivalent.</p>
               
               <pre><code>func skip(value string, prefix string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="split">
               <h3>
                  split 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>split splits days into century, cyear, ayday.</p>
               
               <pre><code>func (days absDays) split() (century absCentury, cyear absCyear, ayday absYday)</code></pre>
            </article>
            
            <article class="function" data-name="split">
               <h3>
                  split 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>split splits ayday into absolute month and standard (1-based) day-in-month.</p>
               
               <pre><code>func (ayday absYday) split() (m absMonth, mday int)</code></pre>
            </article>
            
            <article class="function" data-name="startsWithLowerCase">
               <h3>
                  startsWithLowerCase 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>startsWithLowerCase reports whether the string has a lower-case letter at the beginning.
Its purpose is to prevent matching strings like "Month" when looking for "Mon".</p>
               
               <pre><code>func startsWithLowerCase(str string) bool</code></pre>
            </article>
            
            <article class="function" data-name="stdFracSecond">
               <h3>
                  stdFracSecond 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>The "std" value passed to appendNano contains two packed fields: the number of
digits after the decimal and the separator character (period or comma).
These functions pack and unpack that variable.</p>
               
               <pre><code>func stdFracSecond(code int, n int, c int) int</code></pre>
            </article>
            
            <article class="function" data-name="stopTimer">
               <h3>
                  stopTimer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>go:linkname stopTimer</p>
               
               <pre><code>func stopTimer(*Timer) bool</code></pre>
            </article>
            
            <article class="function" data-name="stripMono">
               <h3>
                  stripMono 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>stripMono strips the monotonic clock reading in t.</p>
               
               <pre><code>func (t *Time) stripMono()</code></pre>
            </article>
            
            <article class="function" data-name="subMono">
               <h3>
                  subMono 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func subMono(t int64, u int64) Duration</code></pre>
            </article>
            
            <article class="function" data-name="syncTimer">
               <h3>
                  syncTimer 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>syncTimer returns c as an unsafe.Pointer, for passing to newTimer.
If the GODEBUG asynctimerchan has disabled the async timer chan
code, then syncTimer always returns nil, to disable the special
channel code paths in the runtime.</p>
               
               <pre><code>func syncTimer(c chan Time) unsafe.Pointer</code></pre>
            </article>
            
            <article class="function" data-name="toEnglishName">
               <h3>
                  toEnglishName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>toEnglishName searches the registry for an English name of a time zone
whose zone names are stdname and dstname and returns the English name.</p>
               
               <pre><code>func toEnglishName(stdname string, dstname string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="tzruleTime">
               <h3>
                  tzruleTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tzruleTime takes a year, a rule, and a timezone offset,
and returns the number of seconds since the start of the year
that the rule takes effect.</p>
               
               <pre><code>func tzruleTime(year int, r rule, off int) int</code></pre>
            </article>
            
            <article class="function" data-name="tzset">
               <h3>
                  tzset 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tzset takes a timezone string like the one found in the TZ environment
variable, the time of the last time zone transition expressed as seconds
since January 1, 1970 00:00:00 UTC, and a time expressed the same way.
We call this a tzset string since in C the function tzset reads TZ.
The return values are as for lookup, plus ok which reports whether the
parse succeeded.</p>
               
               <pre><code>func tzset(s string, lastTxSec int64, sec int64) (name string, offset int, start int64, end int64, isDST bool, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="tzsetName">
               <h3>
                  tzsetName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tzsetName returns the timezone name at the start of the tzset string s,
and the remainder of s, and reports whether the parsing is OK.</p>
               
               <pre><code>func tzsetName(s string) (string, string, bool)</code></pre>
            </article>
            
            <article class="function" data-name="tzsetNum">
               <h3>
                  tzsetNum 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tzsetNum parses a number from a tzset string.
It returns the number, and the remainder of the string, and reports success.
The number must be between min and max.</p>
               
               <pre><code>func tzsetNum(s string, min int, max int) (num int, rest string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="tzsetOffset">
               <h3>
                  tzsetOffset 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tzsetOffset returns the timezone offset at the start of the tzset string s,
and the remainder of s, and reports whether the parsing is OK.
The timezone offset is returned as a number of seconds.</p>
               
               <pre><code>func tzsetOffset(s string) (offset int, rest string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="tzsetRule">
               <h3>
                  tzsetRule 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>tzsetRule parses a rule from a tzset string.
It returns the rule, and the remainder of the string, and reports success.</p>
               
               <pre><code>func tzsetRule(s string) (rule, string, bool)</code></pre>
            </article>
            
            <article class="function" data-name="unixSec">
               <h3>
                  unixSec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unixSec returns the time's seconds since Jan 1 1970 (Unix time).</p>
               
               <pre><code>func (t *Time) unixSec() int64</code></pre>
            </article>
            
            <article class="function" data-name="unixTime">
               <h3>
                  unixTime 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func unixTime(sec int64, nsec int32) Time</code></pre>
            </article>
            
            <article class="function" data-name="weekday">
               <h3>
                  weekday 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>weekday returns the day of the week specified by days.</p>
               
               <pre><code>func (days absDays) weekday() Weekday</code></pre>
            </article>
            
            <article class="function" data-name="when">
               <h3>
                  when 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>when is a helper function for setting the 'when' field of a runtimeTimer.
It returns what the time will be, in nanoseconds, Duration d in the future.
If d is negative, it is ignored. If the returned value would be less than
zero because of an overflow, MaxInt64 is returned.</p>
               
               <pre><code>func when(d Duration) int64</code></pre>
            </article>
            
            <article class="function" data-name="yday">
               <h3>
                  yday 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>yday returns the standard 1-based yday for (ayday, janFeb, leap).</p>
               
               <pre><code>func (ayday absYday) yday(janFeb absJanFeb, leap absLeap) int</code></pre>
            </article>
            
            <article class="function" data-name="year">
               <h3>
                  year 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>year returns the standard year for (century, cyear, janFeb).</p>
               
               <pre><code>func (century absCentury) year(cyear absCyear, janFeb absJanFeb) int</code></pre>
            </article>
            
            <article class="function" data-name="yearYday">
               <h3>
                  yearYday 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>yearYday converts days into the standard year and 1-based yday.</p>
               
               <pre><code>func (days absDays) yearYday() (year int, yday int)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
