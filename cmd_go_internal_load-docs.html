<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - load</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>load</code>
         </h1>
         <hr />
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ ImportPathError</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ ImportPathError</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ ImportPathError</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ ImportPathError</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ ImportPathError</code></pre>
         </article>
         
         <article class="global" data-name="packageCache">
            <h2>packageCache</h2>
            <hr />
            
            <p>packageCache is a lookup cache for LoadImport,
so that if we look up a package multiple times
we return the same pointer each time.</p>
            
            <pre><code>packageCache</code></pre>
         </article>
         
         <article class="global" data-name="ResolveImport">
            <h2>ResolveImport</h2>
            <hr />
            
            <p>ResolveImport means that loadImport should do import path expansion.
That is, ResolveImport means that the import path came from
a source file and has not been expanded yet to account for
vendoring or possible module adjustment.
Every import path should be loaded initially with ResolveImport,
and then the expanded version (for example with the /vendor/ in it)
gets recorded as the canonical import path. At that point, future loads
of that package must not pass ResolveImport, because
disallowVendor will reject direct use of paths containing /vendor/.</p>
            
            <pre><code>ResolveImport</code></pre>
         </article>
         
         <article class="global" data-name="ResolveModule">
            <h2>ResolveModule</h2>
            <hr />
            
            <p>ResolveModule is for download (part of "go get") and indicates
that the module adjustment should be done, but not vendor adjustment.</p>
            
            <pre><code>ResolveModule</code></pre>
         </article>
         
         <article class="global" data-name="GetTestDeps">
            <h2>GetTestDeps</h2>
            <hr />
            
            <p>GetTestDeps is for download (part of "go get") and indicates
that test dependencies should be fetched too.</p>
            
            <pre><code>GetTestDeps</code></pre>
         </article>
         
         <article class="global" data-name="cmdlinePkg">
            <h2>cmdlinePkg</h2>
            <hr />
            
            <p>cmdlinePkg is for a package mentioned on the command line.</p>
            
            <pre><code>cmdlinePkg</code></pre>
         </article>
         
         <article class="global" data-name="cmdlinePkgLiteral">
            <h2>cmdlinePkgLiteral</h2>
            <hr />
            
            <p>cmdlinePkgLiteral is for a package mentioned on the command line
without using any wildcards or meta-patterns.</p>
            
            <pre><code>cmdlinePkgLiteral</code></pre>
         </article>
         
         <article class="global" data-name="resolvedImportCache">
            <h2>resolvedImportCache</h2>
            <hr />
            
            <p>resolvedImportCache maps import strings to canonical package names.</p>
            
            <pre><code>resolvedImportCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="packageDataCache">
            <h2>packageDataCache</h2>
            <hr />
            
            <p>packageDataCache maps canonical package names (string) to package metadata.</p>
            
            <pre><code>packageDataCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="preloadWorkerCount">
            <h2>preloadWorkerCount</h2>
            <hr />
            
            <p>preloadWorkerCount is the number of concurrent goroutines that can load
packages. Experimentally, there are diminishing returns with more than
4 workers. This was measured on the following machines.

* MacBookPro with a 4-core Intel Core i7 CPU
* Linux workstation with 6-core Intel Xeon CPU
* Linux workstation with 24-core Intel Xeon CPU

It is very likely (though not confirmed) that this workload is limited
by memory bandwidth. We don't have a good way to determine the number of
workers that would saturate the bus though, so runtime.GOMAXPROCS
seems like a reasonable default.</p>
            
            <pre><code>preloadWorkerCount</code></pre>
         </article>
         
         <article class="global" data-name="isDirCache">
            <h2>isDirCache</h2>
            <hr />
            
            <pre><code>isDirCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="modulePrefix">
            <h2>modulePrefix</h2>
            <hr />
            
            <pre><code>modulePrefix</code></pre>
         </article>
         
         <article class="global" data-name="goModPathCache">
            <h2>goModPathCache</h2>
            <hr />
            
            <pre><code>goModPathCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="ToTool">
            <h2>ToTool</h2>
            <hr />
            
            <pre><code>ToTool TargetDir</code></pre>
         </article>
         
         <article class="global" data-name="ToBin">
            <h2>ToBin</h2>
            <hr />
            
            <pre><code>ToBin</code></pre>
         </article>
         
         <article class="global" data-name="StalePath">
            <h2>StalePath</h2>
            <hr />
            
            <pre><code>StalePath</code></pre>
         </article>
         
         <article class="global" data-name="cgoExclude">
            <h2>cgoExclude</h2>
            <hr />
            
            <pre><code>cgoExclude</code></pre>
         </article>
         
         <article class="global" data-name="cgoSyscallExclude">
            <h2>cgoSyscallExclude</h2>
            <hr />
            
            <pre><code>cgoSyscallExclude</code></pre>
         </article>
         
         <article class="global" data-name="foldPath">
            <h2>foldPath</h2>
            <hr />
            
            <pre><code>foldPath</code></pre>
         </article>
         
         <article class="global" data-name="vcsStatusCache">
            <h2>vcsStatusCache</h2>
            <hr />
            
            <p>vcsStatusCache maps repository directories (string)
to their VCS information.</p>
            
            <pre><code>vcsStatusCache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="TestMainDeps">
            <h2>TestMainDeps</h2>
            <hr />
            
            <pre><code>TestMainDeps</code></pre>
         </article>
         
         <article class="global" data-name="testFileSet">
            <h2>testFileSet</h2>
            <hr />
            
            <pre><code>testFileSet</code></pre>
         </article>
         
         <article class="global" data-name="testmainTmpl">
            <h2>testmainTmpl</h2>
            <hr />
            
            <pre><code>testmainTmpl</code></pre>
         </article>
         
         <article class="global" data-name="testmainTmplNewCoverage">
            <h2>testmainTmplNewCoverage</h2>
            <hr />
            
            <pre><code>testmainTmplNewCoverage</code></pre>
         </article>
         
         <article class="global" data-name="BuildAsmflags">
            <h2>BuildAsmflags</h2>
            <hr />
            
            <pre><code>BuildAsmflags PerPackageFlag</code></pre>
         </article>
         
         <article class="global" data-name="BuildGcflags">
            <h2>BuildGcflags</h2>
            <hr />
            
            <pre><code>BuildGcflags PerPackageFlag</code></pre>
         </article>
         
         <article class="global" data-name="BuildLdflags">
            <h2>BuildLdflags</h2>
            <hr />
            
            <pre><code>BuildLdflags PerPackageFlag</code></pre>
         </article>
         
         <article class="global" data-name="BuildGccgoflags">
            <h2>BuildGccgoflags</h2>
            <hr />
            
            <pre><code>BuildGccgoflags PerPackageFlag</code></pre>
         </article>
         
         <article class="global" data-name="ppfTests">
            <h2>ppfTests</h2>
            <hr />
            
            <pre><code>ppfTests</code></pre>
         </article>
         
         <article class="global" data-name="ErrNotGoDebug">
            <h2>ErrNotGoDebug</h2>
            <hr />
            
            <pre><code>ErrNotGoDebug</code></pre>
         </article>
         
         <article class="global" data-name="defaultPrinter">
            <h2>defaultPrinter</h2>
            <hr />
            
            <pre><code>defaultPrinter</code></pre>
         </article>
          
         <article class="struct" data-name="Package">
            <h2>type Package struct</h2>
            <hr />
            
            <p>A Package describes a single package found in a directory.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">PackagePublic
Internal PackageInternal</code></pre>
         </article>
         
         <article class="struct" data-name="PackagePublic">
            <h2>type PackagePublic struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Dir string
ImportPath string
ImportComment string
Name string
Doc string
Target string
Shlib string
Root string
ConflictDir string
ForTest string
Export string
BuildID string
Module *modinfo.ModulePublic
Match []string
Goroot bool
Standard bool
DepOnly bool
BinaryOnly bool
Incomplete bool
DefaultGODEBUG string
Stale bool
StaleReason string
GoFiles []string
CgoFiles []string
CompiledGoFiles []string
IgnoredGoFiles []string
InvalidGoFiles []string
IgnoredOtherFiles []string
CFiles []string
CXXFiles []string
MFiles []string
HFiles []string
FFiles []string
SFiles []string
SwigFiles []string
SwigCXXFiles []string
SysoFiles []string
EmbedPatterns []string
EmbedFiles []string
CgoCFLAGS []string
CgoCPPFLAGS []string
CgoCXXFLAGS []string
CgoFFLAGS []string
CgoLDFLAGS []string
CgoPkgConfig []string
Imports []string
ImportMap *ast.MapType
Deps []string
Error *PackageError
DepsErrors []*PackageError
TestGoFiles []string
TestImports []string
TestEmbedPatterns []string
TestEmbedFiles []string
XTestGoFiles []string
XTestImports []string
XTestEmbedPatterns []string
XTestEmbedFiles []string</code></pre>
         </article>
         
         <article class="struct" data-name="PackageInternal">
            <h2>type PackageInternal struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Build *build.Package
Imports []*Package
CompiledImports []string
RawImports []string
ForceLibrary bool
CmdlineFiles bool
CmdlinePkg bool
CmdlinePkgLiteral bool
Local bool
LocalPrefix string
ExeName string
FuzzInstrument bool
Cover CoverSetup
CoverVars *ast.MapType
OmitDebug bool
GobinSubdir bool
BuildInfo *debug.BuildInfo
TestmainGo *[]byte
Embed *ast.MapType
OrigImportPath string
PGOProfile string
ForMain string
Asmflags []string
Gcflags []string
Ldflags []string
Gccgoflags []string</code></pre>
         </article>
         
         <article class="struct" data-name="NoGoError">
            <h2>type NoGoError struct</h2>
            <hr />
            
            <p>A NoGoError indicates that no Go files for the package were applicable to the
build for that package.

That may be because there were no files whatsoever, or because all files were
excluded, or because all non-excluded files were test sources.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Package *Package</code></pre>
         </article>
         
         <article class="struct" data-name="CoverVar">
            <h2>type CoverVar struct</h2>
            <hr />
            
            <p>CoverVar holds the name of the generated coverage variables targeting the named file.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">File string
Var string</code></pre>
         </article>
         
         <article class="struct" data-name="CoverSetup">
            <h2>type CoverSetup struct</h2>
            <hr />
            
            <p>CoverSetup holds parameters related to coverage setup for a given package (covermode, etc).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Mode string
Cfg string
GenMeta bool</code></pre>
         </article>
         
         <article class="struct" data-name="PackageError">
            <h2>type PackageError struct</h2>
            <hr />
            
            <p>A PackageError describes an error loading information about a package.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ImportStack ImportStack
Pos string
Err error
IsImportCycle bool
alwaysPrintStack bool</code></pre>
         </article>
         
         <article class="struct" data-name="importError">
            <h2>type importError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">importPath string
err error</code></pre>
         </article>
         
         <article class="struct" data-name="ImportInfo">
            <h2>type ImportInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Pkg string
Pos *token.Position</code></pre>
         </article>
         
         <article class="struct" data-name="importSpec">
            <h2>type importSpec struct</h2>
            <hr />
            
            <p>importSpec describes an import declaration in source code. It is used as a
cache key for resolvedImportCache.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
parentPath string
parentDir string
parentRoot string
parentIsStd bool
mode int</code></pre>
         </article>
         
         <article class="struct" data-name="resolvedImport">
            <h2>type resolvedImport struct</h2>
            <hr />
            
            <p>resolvedImport holds a canonical identifier for a package. It may also contain
a path to the package's directory and an error if one occurred. resolvedImport
is the value type in resolvedImportCache.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
dir string
err error</code></pre>
         </article>
         
         <article class="struct" data-name="preload">
            <h2>type preload struct</h2>
            <hr />
            
            <p>preload holds state for managing concurrent preloading of package data.

A preload should be created with newPreload before loading a large
package graph. flush must be called when package loading is complete
to ensure preload goroutines are no longer active. This is necessary
because of global mutable state that cannot safely be read and written
concurrently. In particular, packageDataCache may be cleared by "go get"
in GOPATH mode, and modload.loaded (accessed via modload.Lookup) may be
modified by modload.LoadPackages.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">cancel *ast.ChanType
sema *ast.ChanType</code></pre>
         </article>
         
         <article class="struct" data-name="EmbedError">
            <h2>type EmbedError struct</h2>
            <hr />
            
            <p>An EmbedError indicates a problem with a go:embed directive.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Pattern string
Err error</code></pre>
         </article>
         
         <article class="struct" data-name="PackageOpts">
            <h2>type PackageOpts struct</h2>
            <hr />
            
            <p>PackageOpts control the behavior of PackagesAndErrors and other package
loading functions.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">IgnoreImports bool
ModResolveTests bool
MainOnly bool
AutoVCS bool
SuppressBuildInfo bool
SuppressEmbedFiles bool</code></pre>
         </article>
         
         <article class="struct" data-name="mainPackageError">
            <h2>type mainPackageError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">importPath string</code></pre>
         </article>
         
         <article class="struct" data-name="TestCover">
            <h2>type TestCover struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Mode string
Local bool
Pkgs []*Package
Paths []string
Vars []coverInfo</code></pre>
         </article>
         
         <article class="struct" data-name="coverInfo">
            <h2>type coverInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Package *Package
Vars *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="testFuncs">
            <h2>type testFuncs struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Tests []testFunc
Benchmarks []testFunc
FuzzTargets []testFunc
Examples []testFunc
TestMain *testFunc
Package *Package
ImportTest bool
NeedTest bool
ImportXtest bool
NeedXtest bool
Cover *TestCover</code></pre>
         </article>
         
         <article class="struct" data-name="testFunc">
            <h2>type testFunc struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Package string
Name string
Output string
Unordered bool</code></pre>
         </article>
         
         <article class="struct" data-name="PerPackageFlag">
            <h2>type PerPackageFlag struct</h2>
            <hr />
            
            <p>A PerPackageFlag is a command-line flag implementation (a flag.Value)
that allows specifying different effective flags for different packages.
See 'go help build' for more details about per-package flags.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">raw string
present bool
values []ppfValue</code></pre>
         </article>
         
         <article class="struct" data-name="ppfValue">
            <h2>type ppfValue struct</h2>
            <hr />
            
            <p>A ppfValue is a single <pattern>=<flags> per-package flag value.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">match func
flags []string</code></pre>
         </article>
         
         <article class="struct" data-name="ppfTestPackage">
            <h2>type ppfTestPackage struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
dir string
cmdline bool
flags []string</code></pre>
         </article>
         
         <article class="struct" data-name="ppfTest">
            <h2>type ppfTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">args []string
pkgs []ppfTestPackage</code></pre>
         </article>
         
         <article class="struct" data-name="TextPrinter">
            <h2>type TextPrinter struct</h2>
            <hr />
            
            <p>A TextPrinter emits text format output to Writer.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Writer io.Writer</code></pre>
         </article>
         
         <article class="struct" data-name="JSONPrinter">
            <h2>type JSONPrinter struct</h2>
            <hr />
            
            <p>A JSONPrinter emits output about a build in JSON format.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">enc *json.Encoder</code></pre>
         </article>
         
         <article class="struct" data-name="jsonBuildEvent">
            <h2>type jsonBuildEvent struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ImportPath string
Action string
Output string</code></pre>
         </article>
          
         <article class="function" data-name="expandPath">
            <h2>expandPath</h2>
            <hr />
            
            <p>expandPath returns the symlink-expanded form of path.</p>
            
            <pre><code>func expandPath(p string) string</code></pre>
         </article>
         
         <article class="function" data-name="AllFiles">
            <h2>AllFiles</h2>
            <hr />
            
            <p>AllFiles returns the names of all the files considered for the package.
This is used for sanity and security checks, so we include all files,
even IgnoredGoFiles, because some subcommands consider them.
The go/build package filtered others out (like foo_wrongGOARCH.s)
and that's OK.</p>
            
            <pre><code>func AllFiles() []string</code></pre>
         </article>
         
         <article class="function" data-name="Desc">
            <h2>Desc</h2>
            <hr />
            
            <p>Desc returns the package "description", for use in b.showOutput.</p>
            
            <pre><code>func Desc() string</code></pre>
         </article>
         
         <article class="function" data-name="IsTestOnly">
            <h2>IsTestOnly</h2>
            <hr />
            
            <p>IsTestOnly reports whether p is a test-only package.

A “test-only” package is one that:
  - is a test-only variant of an ordinary package, or
  - is a synthesized "main" package for a test binary, or
  - contains only _test.go files.</p>
            
            <pre><code>func IsTestOnly() bool</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="setLoadPackageDataError">
            <h2>setLoadPackageDataError</h2>
            <hr />
            
            <p>setLoadPackageDataError presents an error found when loading package data
as a *PackageError. It has special cases for some common errors to improve
messages shown to users and reduce redundancy.

setLoadPackageDataError returns true if it's safe to load information about
imported packages, for example, if there was a parse error loading imports
in one file, but other files are okay.</p>
            
            <pre><code>func setLoadPackageDataError(err error, path string, stk *ImportStack, importPos []token.Position)</code></pre>
         </article>
         
         <article class="function" data-name="Resolve">
            <h2>Resolve</h2>
            <hr />
            
            <p>Resolve returns the resolved version of imports,
which should be p.TestImports or p.XTestImports, NOT p.Imports.
The imports in p.TestImports and p.XTestImports are not recursively
loaded during the initial load of p, so they list the imports found in
the source file, but most processing should be over the vendor-resolved
import paths. We do this resolution lazily both to avoid file system work
and because the eventual real load of the test imports (during 'go test')
can produce better error messages if it starts with the original paths.
The initial load of p loads all the non-test imports and rewrites
the vendored paths, so nothing should ever call p.vendored(p.Imports).</p>
            
            <pre><code>func Resolve(imports []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="copyBuild">
            <h2>copyBuild</h2>
            <hr />
            
            <pre><code>func copyBuild(opts PackageOpts, pp *build.Package)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="MarshalJSON">
            <h2>MarshalJSON</h2>
            <hr />
            
            <p>PackageError implements MarshalJSON so that Err is marshaled as a string
and non-essential fields are omitted.</p>
            
            <pre><code>func MarshalJSON() ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="setPos">
            <h2>setPos</h2>
            <hr />
            
            <pre><code>func setPos(posList []token.Position)</code></pre>
         </article>
         
         <article class="function" data-name="ImportErrorf">
            <h2>ImportErrorf</h2>
            <hr />
            
            <pre><code>func ImportErrorf(path string, format string, args ...any) ImportPathError</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="ImportPath">
            <h2>ImportPath</h2>
            <hr />
            
            <pre><code>func ImportPath() string</code></pre>
         </article>
         
         <article class="function" data-name="NewImportInfo">
            <h2>NewImportInfo</h2>
            <hr />
            
            <pre><code>func NewImportInfo(pkg string, pos *token.Position) ImportInfo</code></pre>
         </article>
         
         <article class="function" data-name="Push">
            <h2>Push</h2>
            <hr />
            
            <pre><code>func Push(p ImportInfo)</code></pre>
         </article>
         
         <article class="function" data-name="Pop">
            <h2>Pop</h2>
            <hr />
            
            <pre><code>func Pop()</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() ImportStack</code></pre>
         </article>
         
         <article class="function" data-name="Pkgs">
            <h2>Pkgs</h2>
            <hr />
            
            <pre><code>func Pkgs() []string</code></pre>
         </article>
         
         <article class="function" data-name="PkgsWithPos">
            <h2>PkgsWithPos</h2>
            <hr />
            
            <pre><code>func PkgsWithPos() []string</code></pre>
         </article>
         
         <article class="function" data-name="Top">
            <h2>Top</h2>
            <hr />
            
            <pre><code>func Top() (ImportInfo, bool)</code></pre>
         </article>
         
         <article class="function" data-name="shorterThan">
            <h2>shorterThan</h2>
            <hr />
            
            <p>shorterThan reports whether sp is shorter than t.
We use this to record the shortest import sequence
that leads to a particular package.</p>
            
            <pre><code>func shorterThan(t []string) bool</code></pre>
         </article>
         
         <article class="function" data-name="dirToImportPath">
            <h2>dirToImportPath</h2>
            <hr />
            
            <p>dirToImportPath returns the pseudo-import path we use for a package
outside the Go path. It begins with _/ and then contains the full path
to the directory. If the package lives in c:\home\gopher\my\pkg then
the pseudo-import path is _/c_/home/gopher/my/pkg.
Using a pseudo-import path like this makes the ./ imports no longer
a special case, so that all the code to deal with ordinary imports works
automatically.</p>
            
            <pre><code>func dirToImportPath(dir string) string</code></pre>
         </article>
         
         <article class="function" data-name="makeImportValid">
            <h2>makeImportValid</h2>
            <hr />
            
            <pre><code>func makeImportValid(r rune) rune</code></pre>
         </article>
         
         <article class="function" data-name="LoadPackage">
            <h2>LoadPackage</h2>
            <hr />
            
            <p>LoadPackage does Load import, but without a parent package load context</p>
            
            <pre><code>func LoadPackage(ctx context.Context, opts PackageOpts, path string, srcDir string, stk *ImportStack, importPos []token.Position, mode int) *Package</code></pre>
         </article>
         
         <article class="function" data-name="loadImport">
            <h2>loadImport</h2>
            <hr />
            
            <p>loadImport scans the directory named by path, which must be an import path,
but possibly a local import path (an absolute file system path or one beginning
with ./ or ../). A local relative path is interpreted relative to srcDir.
It returns a *Package describing the package found in that directory.
loadImport does not set tool flags and should only be used by
this package, as part of a bigger load operation.
The returned PackageError, if any, describes why parent is not allowed
to import the named package, with the error referring to importPos.
The PackageError can only be non-nil when parent is not nil.</p>
            
            <pre><code>func loadImport(ctx context.Context, opts PackageOpts, pre *preload, path string, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) (*Package, *PackageError)</code></pre>
         </article>
         
         <article class="function" data-name="extractFirstImport">
            <h2>extractFirstImport</h2>
            <hr />
            
            <pre><code>func extractFirstImport(importPos []token.Position) *token.Position</code></pre>
         </article>
         
         <article class="function" data-name="loadPackageData">
            <h2>loadPackageData</h2>
            <hr />
            
            <p>loadPackageData loads information needed to construct a *Package. The result
is cached, and later calls to loadPackageData for the same package will return
the same data.

loadPackageData returns a non-nil package even if err is non-nil unless
the package path is malformed (for example, the path contains "mod/" or "@").

loadPackageData returns a boolean, loaded, which is true if this is the
first time the package was loaded. Callers may preload imports in this case.</p>
            
            <pre><code>func loadPackageData(ctx context.Context, path string, parentPath string, parentDir string, parentRoot string, parentIsStd bool, mode int) (bp *build.Package, loaded bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="newPreload">
            <h2>newPreload</h2>
            <hr />
            
            <p>newPreload creates a new preloader. flush must be called later to avoid
accessing global state while it is being modified.</p>
            
            <pre><code>func newPreload() *preload</code></pre>
         </article>
         
         <article class="function" data-name="preloadMatches">
            <h2>preloadMatches</h2>
            <hr />
            
            <p>preloadMatches loads data for package paths matched by patterns.
When preloadMatches returns, some packages may not be loaded yet, but
loadPackageData and loadImport are always safe to call.</p>
            
            <pre><code>func preloadMatches(ctx context.Context, opts PackageOpts, matches []*search.Match)</code></pre>
         </article>
         
         <article class="function" data-name="preloadImports">
            <h2>preloadImports</h2>
            <hr />
            
            <p>preloadImports queues a list of imports for preloading.
When preloadImports returns, some packages may not be loaded yet,
but loadPackageData and loadImport are always safe to call.</p>
            
            <pre><code>func preloadImports(ctx context.Context, opts PackageOpts, imports []string, parent *build.Package)</code></pre>
         </article>
         
         <article class="function" data-name="flush">
            <h2>flush</h2>
            <hr />
            
            <p>flush stops pending preload operations. flush blocks until preload calls to
loadPackageData have completed. The preloader will not make any new calls
to loadPackageData.</p>
            
            <pre><code>func flush()</code></pre>
         </article>
         
         <article class="function" data-name="cleanImport">
            <h2>cleanImport</h2>
            <hr />
            
            <pre><code>func cleanImport(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="isDir">
            <h2>isDir</h2>
            <hr />
            
            <pre><code>func isDir(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="ResolveImportPath">
            <h2>ResolveImportPath</h2>
            <hr />
            
            <p>ResolveImportPath returns the true meaning of path when it appears in parent.
There are two different resolutions applied.
First, there is Go 1.5 vendoring (golang.org/s/go15vendor).
If vendor expansion doesn't trigger, then the path is also subject to
Go 1.11 module legacy conversion (golang.org/issue/25069).</p>
            
            <pre><code>func ResolveImportPath(parent *Package, path string) found string</code></pre>
         </article>
         
         <article class="function" data-name="resolveImportPath">
            <h2>resolveImportPath</h2>
            <hr />
            
            <pre><code>func resolveImportPath(path string, parentPath string, parentDir string, parentRoot string, parentIsStd bool) found string</code></pre>
         </article>
         
         <article class="function" data-name="dirAndRoot">
            <h2>dirAndRoot</h2>
            <hr />
            
            <p>dirAndRoot returns the source directory and workspace root
for the package p, guaranteeing that root is a path prefix of dir.</p>
            
            <pre><code>func dirAndRoot(path string, dir string, root string) (string, string)</code></pre>
         </article>
         
         <article class="function" data-name="vendoredImportPath">
            <h2>vendoredImportPath</h2>
            <hr />
            
            <p>vendoredImportPath returns the vendor-expansion of path when it appears in parent.
If parent is x/y/z, then path might expand to x/y/z/vendor/path, x/y/vendor/path,
x/vendor/path, vendor/path, or else stay path if none of those exist.
vendoredImportPath returns the expanded path or, if no expansion is found, the original.</p>
            
            <pre><code>func vendoredImportPath(path string, parentPath string, parentDir string, parentRoot string) found string</code></pre>
         </article>
         
         <article class="function" data-name="goModPath">
            <h2>goModPath</h2>
            <hr />
            
            <p>goModPath returns the module path in the go.mod in dir, if any.</p>
            
            <pre><code>func goModPath(dir string) path string</code></pre>
         </article>
         
         <article class="function" data-name="findVersionElement">
            <h2>findVersionElement</h2>
            <hr />
            
            <p>findVersionElement returns the slice indices of the final version element /vN in path.
If there is no such element, it returns -1, -1.</p>
            
            <pre><code>func findVersionElement(path string) (i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="isVersionElement">
            <h2>isVersionElement</h2>
            <hr />
            
            <p>isVersionElement reports whether s is a well-formed path version element:
v2, v3, v10, etc, but not v0, v05, v1.</p>
            
            <pre><code>func isVersionElement(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="moduleImportPath">
            <h2>moduleImportPath</h2>
            <hr />
            
            <p>moduleImportPath translates import paths found in go modules
back down to paths that can be resolved in ordinary builds.

Define “new” code as code with a go.mod file in the same directory
or a parent directory. If an import in new code says x/y/v2/z but
x/y/v2/z does not exist and x/y/go.mod says “module x/y/v2”,
then go build will read the import as x/y/z instead.
See golang.org/issue/25069.</p>
            
            <pre><code>func moduleImportPath(path string, parentPath string, parentDir string, parentRoot string) found string</code></pre>
         </article>
         
         <article class="function" data-name="hasGoFiles">
            <h2>hasGoFiles</h2>
            <hr />
            
            <p>hasGoFiles reports whether dir contains any files with names ending in .go.
For a vendor check we must exclude directories that contain no .go files.
Otherwise it is not possible to vendor just a/b/c and still import the
non-vendored a/b. See golang.org/issue/13832.</p>
            
            <pre><code>func hasGoFiles(dir string) bool</code></pre>
         </article>
         
         <article class="function" data-name="reusePackage">
            <h2>reusePackage</h2>
            <hr />
            
            <p>reusePackage reuses package p to satisfy the import at the top
of the import stack stk. If this use causes an import loop,
reusePackage updates p's error information to record the loop.</p>
            
            <pre><code>func reusePackage(p *Package, stk *ImportStack) *Package</code></pre>
         </article>
         
         <article class="function" data-name="disallowInternal">
            <h2>disallowInternal</h2>
            <hr />
            
            <p>disallowInternal checks that srcDir (containing package importerPath, if non-empty)
is allowed to import p.
If the import is allowed, disallowInternal returns the original package p.
If not, it returns a new package containing just an appropriate error.</p>
            
            <pre><code>func disallowInternal(ctx context.Context, srcDir string, importer *Package, importerPath string, p *Package, stk *ImportStack) *PackageError</code></pre>
         </article>
         
         <article class="function" data-name="findInternal">
            <h2>findInternal</h2>
            <hr />
            
            <p>findInternal looks for the final "internal" path element in the given import path.
If there isn't one, findInternal returns ok=false.
Otherwise, findInternal returns ok=true and the index of the "internal".</p>
            
            <pre><code>func findInternal(path string) (index int, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="disallowVendor">
            <h2>disallowVendor</h2>
            <hr />
            
            <p>disallowVendor checks that srcDir is allowed to import p as path.
If the import is allowed, disallowVendor returns the original package p.
If not, it returns a PackageError.</p>
            
            <pre><code>func disallowVendor(srcDir string, path string, importerPath string, p *Package, stk *ImportStack) *PackageError</code></pre>
         </article>
         
         <article class="function" data-name="disallowVendorVisibility">
            <h2>disallowVendorVisibility</h2>
            <hr />
            
            <p>disallowVendorVisibility checks that srcDir is allowed to import p.
The rules are the same as for /internal/ except that a path ending in /vendor
is not subject to the rules, only subdirectories of vendor.
This allows people to have packages and commands named vendor,
for maximal compatibility with existing source trees.</p>
            
            <pre><code>func disallowVendorVisibility(srcDir string, p *Package, importerPath string, stk *ImportStack) *PackageError</code></pre>
         </article>
         
         <article class="function" data-name="FindVendor">
            <h2>FindVendor</h2>
            <hr />
            
            <p>FindVendor looks for the last non-terminating "vendor" path element in the given import path.
If there isn't one, FindVendor returns ok=false.
Otherwise, FindVendor returns ok=true and the index of the "vendor".

Note that terminating "vendor" elements don't count: "x/vendor" is its own package,
not the vendored copy of an import "" (the empty import path).
This will allow people to have packages or commands named vendor.
This may help reduce breakage, or it may just be confusing. We'll see.</p>
            
            <pre><code>func FindVendor(path string) (index int, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="InstallTargetDir">
            <h2>InstallTargetDir</h2>
            <hr />
            
            <p>InstallTargetDir reports the target directory for installing the command p.</p>
            
            <pre><code>func InstallTargetDir(p *Package) TargetDir</code></pre>
         </article>
         
         <article class="function" data-name="exeFromImportPath">
            <h2>exeFromImportPath</h2>
            <hr />
            
            <p>exeFromImportPath returns an executable name
for a package using the import path.

The executable name is the last element of the import path.
In module-aware mode, an additional rule is used on import paths
consisting of two or more path elements. If the last element is
a vN path element specifying the major version, then the
second last element of the import path is used instead.</p>
            
            <pre><code>func exeFromImportPath() string</code></pre>
         </article>
         
         <article class="function" data-name="exeFromFiles">
            <h2>exeFromFiles</h2>
            <hr />
            
            <p>exeFromFiles returns an executable name for a package
using the first element in GoFiles or CgoFiles collections without the prefix.

Returns empty string in case of empty collection.</p>
            
            <pre><code>func exeFromFiles() string</code></pre>
         </article>
         
         <article class="function" data-name="DefaultExecName">
            <h2>DefaultExecName</h2>
            <hr />
            
            <p>DefaultExecName returns the default executable name for a package</p>
            
            <pre><code>func DefaultExecName() string</code></pre>
         </article>
         
         <article class="function" data-name="load">
            <h2>load</h2>
            <hr />
            
            <p>load populates p using information from bp, err, which should
be the result of calling build.Context.Import.
stk contains the import stack, not including path itself.</p>
            
            <pre><code>func load(ctx context.Context, opts PackageOpts, path string, stk *ImportStack, importPos []token.Position, bp *build.Package, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="ResolveEmbed">
            <h2>ResolveEmbed</h2>
            <hr />
            
            <p>ResolveEmbed resolves //go:embed patterns and returns only the file list.
For use by go mod vendor to find embedded files it should copy into the
vendor directory.
TODO(#42504): Once go mod vendor uses load.PackagesAndErrors, just
call (*Package).ResolveEmbed</p>
            
            <pre><code>func ResolveEmbed(dir string, patterns []string) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="resolveEmbed">
            <h2>resolveEmbed</h2>
            <hr />
            
            <p>resolveEmbed resolves //go:embed patterns to precise file lists.
It sets files to the list of unique files matched (for go list),
and it sets pmap to the more precise mapping from
patterns to files.</p>
            
            <pre><code>func resolveEmbed(pkgdir string, patterns []string) (files []string, pmap *ast.MapType, err error)</code></pre>
         </article>
         
         <article class="function" data-name="validEmbedPattern">
            <h2>validEmbedPattern</h2>
            <hr />
            
            <pre><code>func validEmbedPattern(pattern string) bool</code></pre>
         </article>
         
         <article class="function" data-name="isBadEmbedName">
            <h2>isBadEmbedName</h2>
            <hr />
            
            <p>isBadEmbedName reports whether name is the base name of a file that
can't or won't be included in modules and therefore shouldn't be treated
as existing for embedding.</p>
            
            <pre><code>func isBadEmbedName(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="appendBuildSetting">
            <h2>appendBuildSetting</h2>
            <hr />
            
            <pre><code>func appendBuildSetting(info *debug.BuildInfo, key string, value string)</code></pre>
         </article>
         
         <article class="function" data-name="setBuildInfo">
            <h2>setBuildInfo</h2>
            <hr />
            
            <p>setBuildInfo gathers build information and sets it into
p.Internal.BuildInfo, which will later be formatted as a string and embedded
in the binary. setBuildInfo should only be called on a main package with no
errors.

This information can be retrieved using debug.ReadBuildInfo.

Note that the GoVersion field is not set here to avoid encoding it twice.
It is stored separately in the binary, mostly for historical reasons.</p>
            
            <pre><code>func setBuildInfo(ctx context.Context, autoVCS bool)</code></pre>
         </article>
         
         <article class="function" data-name="SafeArg">
            <h2>SafeArg</h2>
            <hr />
            
            <p>SafeArg reports whether arg is a "safe" command-line argument,
meaning that when it appears in a command-line, it probably
doesn't have some special meaning other than its own name.
Obviously args beginning with - are not safe (they look like flags).
Less obviously, args beginning with @ are not safe (they look like
GNU binutils flagfile specifiers, sometimes called "response files").
To be conservative, we reject almost any arg beginning with non-alphanumeric ASCII.
We accept leading . _ and / as likely in file system paths.
There is a copy of this function in cmd/compile/internal/gc/noder.go.</p>
            
            <pre><code>func SafeArg(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="LinkerDeps">
            <h2>LinkerDeps</h2>
            <hr />
            
            <p>LinkerDeps returns the list of linker-induced dependencies for main package p.</p>
            
            <pre><code>func LinkerDeps(p *Package) ([]string, error)</code></pre>
         </article>
         
         <article class="function" data-name="externalLinkingReason">
            <h2>externalLinkingReason</h2>
            <hr />
            
            <p>externalLinkingReason reports the reason external linking is required
even for programs that do not use cgo, or the empty string if external
linking is not required.</p>
            
            <pre><code>func externalLinkingReason(p *Package) what string</code></pre>
         </article>
         
         <article class="function" data-name="mkAbs">
            <h2>mkAbs</h2>
            <hr />
            
            <p>mkAbs rewrites list, which must be paths relative to p.Dir,
into a sorted list of absolute paths. It edits list in place but for
convenience also returns list back to its caller.</p>
            
            <pre><code>func mkAbs(list []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="InternalGoFiles">
            <h2>InternalGoFiles</h2>
            <hr />
            
            <p>InternalGoFiles returns the list of Go files being built for the package,
using absolute paths.</p>
            
            <pre><code>func InternalGoFiles() []string</code></pre>
         </article>
         
         <article class="function" data-name="InternalXGoFiles">
            <h2>InternalXGoFiles</h2>
            <hr />
            
            <p>InternalXGoFiles returns the list of Go files being built for the XTest package,
using absolute paths.</p>
            
            <pre><code>func InternalXGoFiles() []string</code></pre>
         </article>
         
         <article class="function" data-name="InternalAllGoFiles">
            <h2>InternalAllGoFiles</h2>
            <hr />
            
            <p>InternalAllGoFiles returns the list of all Go files possibly relevant for the package,
using absolute paths. "Possibly relevant" means that files are not excluded
due to build tags, but files with names beginning with . or _ are still excluded.</p>
            
            <pre><code>func InternalAllGoFiles() []string</code></pre>
         </article>
         
         <article class="function" data-name="UsesSwig">
            <h2>UsesSwig</h2>
            <hr />
            
            <p>UsesSwig reports whether the package needs to run SWIG.</p>
            
            <pre><code>func UsesSwig() bool</code></pre>
         </article>
         
         <article class="function" data-name="UsesCgo">
            <h2>UsesCgo</h2>
            <hr />
            
            <p>UsesCgo reports whether the package needs to run cgo</p>
            
            <pre><code>func UsesCgo() bool</code></pre>
         </article>
         
         <article class="function" data-name="PackageList">
            <h2>PackageList</h2>
            <hr />
            
            <p>PackageList returns the list of packages in the dag rooted at roots
as visited in a depth-first post-order traversal.</p>
            
            <pre><code>func PackageList(roots []*Package) []*Package</code></pre>
         </article>
         
         <article class="function" data-name="TestPackageList">
            <h2>TestPackageList</h2>
            <hr />
            
            <p>TestPackageList returns the list of packages in the dag rooted at roots
as visited in a depth-first post-order traversal, including the test
imports of the roots. This ignores errors in test packages.</p>
            
            <pre><code>func TestPackageList(ctx context.Context, opts PackageOpts, roots []*Package) []*Package</code></pre>
         </article>
         
         <article class="function" data-name="LoadImportWithFlags">
            <h2>LoadImportWithFlags</h2>
            <hr />
            
            <p>LoadImportWithFlags loads the package with the given import path and
sets tool flags on that package. This function is useful loading implicit
dependencies (like sync/atomic for coverage).
TODO(jayconrod): delete this function and set flags automatically
in LoadImport instead.</p>
            
            <pre><code>func LoadImportWithFlags(path string, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) (*Package, *PackageError)</code></pre>
         </article>
         
         <article class="function" data-name="LoadPackageWithFlags">
            <h2>LoadPackageWithFlags</h2>
            <hr />
            
            <p>LoadPackageWithFlags is the same as LoadImportWithFlags but without a parent.
It's then guaranteed to not return an error</p>
            
            <pre><code>func LoadPackageWithFlags(path string, srcDir string, stk *ImportStack, importPos []token.Position, mode int) *Package</code></pre>
         </article>
         
         <article class="function" data-name="PackagesAndErrors">
            <h2>PackagesAndErrors</h2>
            <hr />
            
            <p>PackagesAndErrors returns the packages named by the command line arguments
'patterns'. If a named package cannot be loaded, PackagesAndErrors returns
a *Package with the Error field describing the failure. If errors are found
loading imported packages, the DepsErrors field is set. The Incomplete field
may be set as well.

To obtain a flat list of packages, use PackageList.
To report errors loading packages, use ReportPackageErrors.</p>
            
            <pre><code>func PackagesAndErrors(ctx context.Context, opts PackageOpts, patterns []string) []*Package</code></pre>
         </article>
         
         <article class="function" data-name="setPGOProfilePath">
            <h2>setPGOProfilePath</h2>
            <hr />
            
            <p>setPGOProfilePath sets the PGO profile path for pkgs.
In -pgo=auto mode, it finds the default PGO profile.</p>
            
            <pre><code>func setPGOProfilePath(pkgs []*Package)</code></pre>
         </article>
         
         <article class="function" data-name="CheckPackageErrors">
            <h2>CheckPackageErrors</h2>
            <hr />
            
            <p>CheckPackageErrors prints errors encountered loading pkgs and their
dependencies, then exits with a non-zero status if any errors were found.</p>
            
            <pre><code>func CheckPackageErrors(pkgs []*Package)</code></pre>
         </article>
         
         <article class="function" data-name="PackageErrors">
            <h2>PackageErrors</h2>
            <hr />
            
            <p>PackageErrors calls report for errors encountered loading pkgs and their dependencies.</p>
            
            <pre><code>func PackageErrors(pkgs []*Package, report func)</code></pre>
         </article>
         
         <article class="function" data-name="mainPackagesOnly">
            <h2>mainPackagesOnly</h2>
            <hr />
            
            <p>mainPackagesOnly filters out non-main packages matched only by arguments
containing "..." and returns the remaining main packages.

Packages with missing, invalid, or ambiguous names may be treated as
possibly-main packages.

mainPackagesOnly sets a non-main package's Error field and returns it if it
is named by a literal argument.

mainPackagesOnly prints warnings for non-literal arguments that only match
non-main packages.</p>
            
            <pre><code>func mainPackagesOnly(pkgs []*Package, matches []*search.Match) []*Package</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="ImportPath">
            <h2>ImportPath</h2>
            <hr />
            
            <pre><code>func ImportPath() string</code></pre>
         </article>
         
         <article class="function" data-name="setToolFlags">
            <h2>setToolFlags</h2>
            <hr />
            
            <pre><code>func setToolFlags(pkgs ...*Package)</code></pre>
         </article>
         
         <article class="function" data-name="GoFilesPackage">
            <h2>GoFilesPackage</h2>
            <hr />
            
            <p>GoFilesPackage creates a package for building a collection of Go files
(typically named on the command line). The target is named p.a for
package p or named after the first Go file for package main.</p>
            
            <pre><code>func GoFilesPackage(ctx context.Context, opts PackageOpts, gofiles []string) *Package</code></pre>
         </article>
         
         <article class="function" data-name="PackagesAndErrorsOutsideModule">
            <h2>PackagesAndErrorsOutsideModule</h2>
            <hr />
            
            <p>PackagesAndErrorsOutsideModule is like PackagesAndErrors but runs in
module-aware mode and ignores the go.mod file in the current directory or any
parent directory, if there is one. This is used in the implementation of 'go
install pkg@version' and other commands that support similar forms.

modload.ForceUseModules must be true, and modload.RootMode must be NoRoot
before calling this function.

PackagesAndErrorsOutsideModule imposes several constraints to avoid
ambiguity. All arguments must have the same version suffix (not just a suffix
that resolves to the same version). They must refer to packages in the same
module, which must not be std or cmd. That module is not considered the main
module, but its go.mod file (if it has one) must not contain directives that
would cause it to be interpreted differently if it were the main module
(replace, exclude).</p>
            
            <pre><code>func PackagesAndErrorsOutsideModule(ctx context.Context, opts PackageOpts, args []string) ([]*Package, error)</code></pre>
         </article>
         
         <article class="function" data-name="EnsureImport">
            <h2>EnsureImport</h2>
            <hr />
            
            <p>EnsureImport ensures that package p imports the named package.</p>
            
            <pre><code>func EnsureImport(p *Package, pkg string)</code></pre>
         </article>
         
         <article class="function" data-name="PrepareForCoverageBuild">
            <h2>PrepareForCoverageBuild</h2>
            <hr />
            
            <p>PrepareForCoverageBuild is a helper invoked for "go install
-cover", "go run -cover", and "go build -cover" (but not used by
"go test -cover"). It walks through the packages being built (and
dependencies) and marks them for coverage instrumentation when
appropriate, and possibly adding additional deps where needed.</p>
            
            <pre><code>func PrepareForCoverageBuild(pkgs []*Package)</code></pre>
         </article>
         
         <article class="function" data-name="SelectCoverPackages">
            <h2>SelectCoverPackages</h2>
            <hr />
            
            <pre><code>func SelectCoverPackages(roots []*Package, match []func, op string) []*Package</code></pre>
         </article>
         
         <article class="function" data-name="DeclareCoverVars">
            <h2>DeclareCoverVars</h2>
            <hr />
            
            <p>DeclareCoverVars attaches the required cover variables names
to the files, to be used when annotating the files. This
function only called when using legacy coverage test/build
(e.g. GOEXPERIMENT=coverageredesign is off).</p>
            
            <pre><code>func DeclareCoverVars(p *Package, files ...string) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="TestPkgDefaultExecName">
            <h2>TestPkgDefaultExecName</h2>
            <hr />
            
            <pre><code>func TestPkgDefaultExecName(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIsVersionElement">
            <h2>TestIsVersionElement</h2>
            <hr />
            
            <pre><code>func TestIsVersionElement(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="MatchPackage">
            <h2>MatchPackage</h2>
            <hr />
            
            <p>MatchPackage(pattern, cwd)(p) reports whether package p matches pattern in the working directory cwd.</p>
            
            <pre><code>func MatchPackage(pattern string, cwd string) func</code></pre>
         </article>
         
         <article class="function" data-name="TestPackagesFor">
            <h2>TestPackagesFor</h2>
            <hr />
            
            <p>TestPackagesFor is like TestPackagesAndErrors but it returns
the package containing an error if the test packages or
their dependencies have errors.
Only test packages without errors are returned.</p>
            
            <pre><code>func TestPackagesFor(ctx context.Context, opts PackageOpts, p *Package, cover *TestCover) (pmain *Package, ptest *Package, pxtest *Package, perr *Package)</code></pre>
         </article>
         
         <article class="function" data-name="TestPackagesAndErrors">
            <h2>TestPackagesAndErrors</h2>
            <hr />
            
            <p>TestPackagesAndErrors returns three packages:
  - pmain, the package main corresponding to the test binary (running tests in ptest and pxtest).
  - ptest, the package p compiled with added "package p" test files.
  - pxtest, the result of compiling any "package p_test" (external) test files.

If the package has no "package p_test" test files, pxtest will be nil.
If the non-test compilation of package p can be reused
(for example, if there are no "package p" test files and
package p need not be instrumented for coverage or any other reason),
then the returned ptest == p.

If done is non-nil, TestPackagesAndErrors will finish filling out the returned
package structs in a goroutine and call done once finished. The members of the
returned packages should not be accessed until done is called.

The caller is expected to have checked that len(p.TestGoFiles)+len(p.XTestGoFiles) > 0,
or else there's no point in any of this.</p>
            
            <pre><code>func TestPackagesAndErrors(ctx context.Context, done func, opts PackageOpts, p *Package, cover *TestCover) (pmain *Package, ptest *Package, pxtest *Package)</code></pre>
         </article>
         
         <article class="function" data-name="recompileForTest">
            <h2>recompileForTest</h2>
            <hr />
            
            <p>recompileForTest copies and replaces certain packages in pmain's dependency
graph. This is necessary for two reasons. First, if ptest is different than
preal, packages that import the package under test should get ptest instead
of preal. This is particularly important if pxtest depends on functionality
exposed in test sources in ptest. Second, if there is a main package
(other than pmain) anywhere, we need to set p.Internal.ForceLibrary and
clear p.Internal.BuildInfo in the test copy to prevent link conflicts.
This may happen if both -coverpkg and the command line patterns include
multiple main packages.</p>
            
            <pre><code>func recompileForTest(pmain *Package, preal *Package, ptest *Package, pxtest *Package) *PackageError</code></pre>
         </article>
         
         <article class="function" data-name="isTestFunc">
            <h2>isTestFunc</h2>
            <hr />
            
            <p>isTestFunc tells whether fn has the type of a testing function. arg
specifies the parameter type we look for: B, F, M or T.</p>
            
            <pre><code>func isTestFunc(fn *ast.FuncDecl, arg string) bool</code></pre>
         </article>
         
         <article class="function" data-name="isTest">
            <h2>isTest</h2>
            <hr />
            
            <p>isTest tells whether name looks like a test (or benchmark, according to prefix).
It is a Test (say) if there is a character after Test that is not a lower-case letter.
We don't want TesticularCancer.</p>
            
            <pre><code>func isTest(name string, prefix string) bool</code></pre>
         </article>
         
         <article class="function" data-name="loadTestFuncs">
            <h2>loadTestFuncs</h2>
            <hr />
            
            <p>loadTestFuncs returns the testFuncs describing the tests that will be run.
The returned testFuncs is always non-nil, even if an error occurred while
processing test files.</p>
            
            <pre><code>func loadTestFuncs(ptest *Package) (*testFuncs, error)</code></pre>
         </article>
         
         <article class="function" data-name="formatTestmain">
            <h2>formatTestmain</h2>
            <hr />
            
            <p>formatTestmain returns the content of the _testmain.go file for t.</p>
            
            <pre><code>func formatTestmain(t *testFuncs) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="ImportPath">
            <h2>ImportPath</h2>
            <hr />
            
            <p>ImportPath returns the import path of the package being tested, if it is within GOPATH.
This is printed by the testing package when running benchmarks.</p>
            
            <pre><code>func ImportPath() string</code></pre>
         </article>
         
         <article class="function" data-name="Covered">
            <h2>Covered</h2>
            <hr />
            
            <p>Covered returns a string describing which packages are being tested for coverage.
If the covered package is the same as the tested package, it returns the empty string.
Otherwise it is a comma-separated human-readable list of packages beginning with
" in", ready for use in the coverage message.</p>
            
            <pre><code>func Covered() string</code></pre>
         </article>
         
         <article class="function" data-name="CoverSelectedPackages">
            <h2>CoverSelectedPackages</h2>
            <hr />
            
            <pre><code>func CoverSelectedPackages() string</code></pre>
         </article>
         
         <article class="function" data-name="Tested">
            <h2>Tested</h2>
            <hr />
            
            <p>Tested returns the name of the package being tested.</p>
            
            <pre><code>func Tested() string</code></pre>
         </article>
         
         <article class="function" data-name="load">
            <h2>load</h2>
            <hr />
            
            <pre><code>func load(filename string, pkg string, doImport *bool, seen *bool) error</code></pre>
         </article>
         
         <article class="function" data-name="checkTestFunc">
            <h2>checkTestFunc</h2>
            <hr />
            
            <pre><code>func checkTestFunc(fn *ast.FuncDecl, arg string) error</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <p>Set is called each time the flag is encountered on the command line.</p>
            
            <pre><code>func Set(v string) error</code></pre>
         </article>
         
         <article class="function" data-name="set">
            <h2>set</h2>
            <hr />
            
            <p>set is the implementation of Set, taking a cwd (current working directory) for easier testing.</p>
            
            <pre><code>func set(v string, cwd string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Present">
            <h2>Present</h2>
            <hr />
            
            <p>Present reports whether the flag appeared on the command line.</p>
            
            <pre><code>func Present() bool</code></pre>
         </article>
         
         <article class="function" data-name="For">
            <h2>For</h2>
            <hr />
            
            <p>For returns the flags to use for the given package.</p>
            
            <pre><code>func For(p *Package) []string</code></pre>
         </article>
         
         <article class="function" data-name="ppfDirTest">
            <h2>ppfDirTest</h2>
            <hr />
            
            <pre><code>func ppfDirTest(pattern string, nmatch int, dirs ...string) ppfTest</code></pre>
         </article>
         
         <article class="function" data-name="TestPerPackageFlag">
            <h2>TestPerPackageFlag</h2>
            <hr />
            
            <pre><code>func TestPerPackageFlag(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="ParseGoDebug">
            <h2>ParseGoDebug</h2>
            <hr />
            
            <pre><code>func ParseGoDebug(text string) (key string, value string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="defaultGODEBUG">
            <h2>defaultGODEBUG</h2>
            <hr />
            
            <p>defaultGODEBUG returns the default GODEBUG setting for the main package p.
When building a test binary, directives, testDirectives, and xtestDirectives
list additional directives from the package under test.</p>
            
            <pre><code>func defaultGODEBUG(p *Package, directives []build.Directive, testDirectives []build.Directive, xtestDirectives []build.Directive) string</code></pre>
         </article>
         
         <article class="function" data-name="godebugForGoVersion">
            <h2>godebugForGoVersion</h2>
            <hr />
            
            <pre><code>func godebugForGoVersion(v string) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="DefaultPrinter">
            <h2>DefaultPrinter</h2>
            <hr />
            
            <p>DefaultPrinter returns the default Printer.</p>
            
            <pre><code>func DefaultPrinter() Printer</code></pre>
         </article>
         
         <article class="function" data-name="ensureNewline">
            <h2>ensureNewline</h2>
            <hr />
            
            <pre><code>func ensureNewline(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="Printf">
            <h2>Printf</h2>
            <hr />
            
            <pre><code>func Printf(_ *Package, format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Errorf">
            <h2>Errorf</h2>
            <hr />
            
            <pre><code>func Errorf(_ *Package, format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="NewJSONPrinter">
            <h2>NewJSONPrinter</h2>
            <hr />
            
            <pre><code>func NewJSONPrinter(w io.Writer) *JSONPrinter</code></pre>
         </article>
         
         <article class="function" data-name="Printf">
            <h2>Printf</h2>
            <hr />
            
            <pre><code>func Printf(pkg *Package, format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="Errorf">
            <h2>Errorf</h2>
            <hr />
            
            <pre><code>func Errorf(pkg *Package, format string, args ...any)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
