<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>load - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>load</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"path/filepath"
"strings"
"cmd/go/internal/search"
"cmd/internal/pkgpattern"
"bytes"
"context"
"errors"
"fmt"
"go/ast"
"go/build"
"go/doc"
"go/parser"
"go/token"
"internal/lazytemplate"
"maps"
"path/filepath"
"slices"
"sort"
"strings"
"unicode"
"unicode/utf8"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/str"
"cmd/go/internal/trace"
"cmd/go/internal/base"
"cmd/internal/quoted"
"fmt"
"strings"
"errors"
"fmt"
"go/build"
"internal/godebugs"
"maps"
"sort"
"strconv"
"strings"
"cmd/go/internal/fips140"
"cmd/go/internal/gover"
"cmd/go/internal/modload"
"path/filepath"
"bytes"
"context"
"crypto/sha256"
"encoding/json"
"errors"
"fmt"
"go/build"
"go/scanner"
"go/token"
"internal/platform"
"io/fs"
"os"
pathpkg "path"
"path/filepath"
"runtime"
"runtime/debug"
"slices"
"sort"
"strconv"
"strings"
"time"
"unicode"
"unicode/utf8"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"cmd/go/internal/fips140"
"cmd/go/internal/fsys"
"cmd/go/internal/gover"
"cmd/go/internal/imports"
"cmd/go/internal/modfetch"
"cmd/go/internal/modindex"
"cmd/go/internal/modinfo"
"cmd/go/internal/modload"
"cmd/go/internal/search"
"cmd/go/internal/str"
"cmd/go/internal/trace"
"cmd/go/internal/vcs"
"cmd/internal/par"
"cmd/internal/pathcache"
"cmd/internal/pkgpattern"
"golang.org/x/mod/modfile"
"golang.org/x/mod/module"
"cmd/go/internal/base"
"cmd/go/internal/cfg"
"encoding/json"
"fmt"
"io"
"os"
"strings"
"sync"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="BuildAsmflags" data-name="BuildAsmflags">
               <h3>
                  BuildAsmflags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#BuildAsmflags" class="anchor" title="Link to BuildAsmflags">#</a>
               </h3>
               
               <pre><code class="language-go">var BuildAsmflags PerPackageFlag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BuildGccgoflags" data-name="BuildGccgoflags">
               <h3>
                  BuildGccgoflags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#BuildGccgoflags" class="anchor" title="Link to BuildGccgoflags">#</a>
               </h3>
               
               <pre><code class="language-go">var BuildGccgoflags PerPackageFlag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BuildGcflags" data-name="BuildGcflags">
               <h3>
                  BuildGcflags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#BuildGcflags" class="anchor" title="Link to BuildGcflags">#</a>
               </h3>
               
               <pre><code class="language-go">var BuildGcflags PerPackageFlag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BuildLdflags" data-name="BuildLdflags">
               <h3>
                  BuildLdflags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#BuildLdflags" class="anchor" title="Link to BuildLdflags">#</a>
               </h3>
               
               <pre><code class="language-go">var BuildLdflags PerPackageFlag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNotGoDebug" data-name="ErrNotGoDebug">
               <h3>
                  ErrNotGoDebug 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNotGoDebug" class="anchor" title="Link to ErrNotGoDebug">#</a>
               </h3>
               
               <pre><code class="language-go">var ErrNotGoDebug = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="GetTestDeps" data-name="GetTestDeps">
               <h3>
                  GetTestDeps 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#GetTestDeps" class="anchor" title="Link to GetTestDeps">#</a>
               </h3>
               
                  <p class="doc-comment">GetTestDeps is for download (part of "go get") and indicates
that test dependencies should be fetched too.</p>
               
               <pre><code class="language-go">const GetTestDeps</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ResolveImport" data-name="ResolveImport">
               <h3>
                  ResolveImport 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ResolveImport" class="anchor" title="Link to ResolveImport">#</a>
               </h3>
               
                  <p class="doc-comment">ResolveImport means that loadImport should do import path expansion.
That is, ResolveImport means that the import path came from
a source file and has not been expanded yet to account for
vendoring or possible module adjustment.
Every import path should be loaded initially with ResolveImport,
and then the expanded version (for example with the /vendor/ in it)
gets recorded as the canonical import path. At that point, future loads
of that package must not pass ResolveImport, because
disallowVendor will reject direct use of paths containing /vendor/.</p>
               
               <pre><code class="language-go">const ResolveImport = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ResolveModule" data-name="ResolveModule">
               <h3>
                  ResolveModule 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ResolveModule" class="anchor" title="Link to ResolveModule">#</a>
               </h3>
               
                  <p class="doc-comment">ResolveModule is for download (part of "go get") and indicates
that the module adjustment should be done, but not vendor adjustment.</p>
               
               <pre><code class="language-go">const ResolveModule</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StalePath" data-name="StalePath">
               <h3>
                  StalePath 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StalePath" class="anchor" title="Link to StalePath">#</a>
               </h3>
               
               <pre><code class="language-go">const StalePath</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TestMainDeps" data-name="TestMainDeps">
               <h3>
                  TestMainDeps 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#TestMainDeps" class="anchor" title="Link to TestMainDeps">#</a>
               </h3>
               
               <pre><code class="language-go">var TestMainDeps = []string{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ToBin" data-name="ToBin">
               <h3>
                  ToBin 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ToBin" class="anchor" title="Link to ToBin">#</a>
               </h3>
               
               <pre><code class="language-go">const ToBin</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ToTool" data-name="ToTool">
               <h3>
                  ToTool 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ToTool" class="anchor" title="Link to ToTool">#</a>
               </h3>
               
               <pre><code class="language-go">const ToTool TargetDir = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ ImportPathError = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ ImportPathError = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ ImportPathError = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ ImportPathError = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">var _ ImportPathError = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cgoExclude" data-name="cgoExclude">
               <h3>
                  cgoExclude 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cgoExclude" class="anchor" title="Link to cgoExclude">#</a>
               </h3>
               
               <pre><code class="language-go">var cgoExclude = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cgoSyscallExclude" data-name="cgoSyscallExclude">
               <h3>
                  cgoSyscallExclude 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#cgoSyscallExclude" class="anchor" title="Link to cgoSyscallExclude">#</a>
               </h3>
               
               <pre><code class="language-go">var cgoSyscallExclude = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cmdlinePkg" data-name="cmdlinePkg">
               <h3>
                  cmdlinePkg 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#cmdlinePkg" class="anchor" title="Link to cmdlinePkg">#</a>
               </h3>
               
                  <p class="doc-comment">cmdlinePkg is for a package mentioned on the command line.</p>
               
               <pre><code class="language-go">const cmdlinePkg</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="cmdlinePkgLiteral" data-name="cmdlinePkgLiteral">
               <h3>
                  cmdlinePkgLiteral 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#cmdlinePkgLiteral" class="anchor" title="Link to cmdlinePkgLiteral">#</a>
               </h3>
               
                  <p class="doc-comment">cmdlinePkgLiteral is for a package mentioned on the command line
without using any wildcards or meta-patterns.</p>
               
               <pre><code class="language-go">const cmdlinePkgLiteral</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultPrinter" data-name="defaultPrinter">
               <h3>
                  defaultPrinter 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultPrinter" class="anchor" title="Link to defaultPrinter">#</a>
               </h3>
               
               <pre><code class="language-go">var defaultPrinter = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="foldPath" data-name="foldPath">
               <h3>
                  foldPath 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#foldPath" class="anchor" title="Link to foldPath">#</a>
               </h3>
               
               <pre><code class="language-go">var foldPath = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goModPathCache" data-name="goModPathCache">
               <h3>
                  goModPathCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goModPathCache" class="anchor" title="Link to goModPathCache">#</a>
               </h3>
               
               <pre><code class="language-go">var goModPathCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="isDirCache" data-name="isDirCache">
               <h3>
                  isDirCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#isDirCache" class="anchor" title="Link to isDirCache">#</a>
               </h3>
               
               <pre><code class="language-go">var isDirCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="modulePrefix" data-name="modulePrefix">
               <h3>
                  modulePrefix 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#modulePrefix" class="anchor" title="Link to modulePrefix">#</a>
               </h3>
               
               <pre><code class="language-go">var modulePrefix = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="packageCache" data-name="packageCache">
               <h3>
                  packageCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#packageCache" class="anchor" title="Link to packageCache">#</a>
               </h3>
               
                  <p class="doc-comment">packageCache is a lookup cache for LoadImport,
so that if we look up a package multiple times
we return the same pointer each time.</p>
               
               <pre><code class="language-go">var packageCache = map[string]*Package{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="packageDataCache" data-name="packageDataCache">
               <h3>
                  packageDataCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#packageDataCache" class="anchor" title="Link to packageDataCache">#</a>
               </h3>
               
                  <p class="doc-comment">packageDataCache maps canonical package names (string) to package metadata.</p>
               
               <pre><code class="language-go">var packageDataCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="preloadWorkerCount" data-name="preloadWorkerCount">
               <h3>
                  preloadWorkerCount 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#preloadWorkerCount" class="anchor" title="Link to preloadWorkerCount">#</a>
               </h3>
               
                  <p class="doc-comment">preloadWorkerCount is the number of concurrent goroutines that can load
packages. Experimentally, there are diminishing returns with more than
4 workers. This was measured on the following machines.
* MacBookPro with a 4-core Intel Core i7 CPU
* Linux workstation with 6-core Intel Xeon CPU
* Linux workstation with 24-core Intel Xeon CPU
It is very likely (though not confirmed) that this workload is limited
by memory bandwidth. We don't have a good way to determine the number of
workers that would saturate the bus though, so runtime.GOMAXPROCS
seems like a reasonable default.</p>
               
               <pre><code class="language-go">var preloadWorkerCount = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="resolvedImportCache" data-name="resolvedImportCache">
               <h3>
                  resolvedImportCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#resolvedImportCache" class="anchor" title="Link to resolvedImportCache">#</a>
               </h3>
               
                  <p class="doc-comment">resolvedImportCache maps import strings to canonical package names.</p>
               
               <pre><code class="language-go">var resolvedImportCache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testFileSet" data-name="testFileSet">
               <h3>
                  testFileSet 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testFileSet" class="anchor" title="Link to testFileSet">#</a>
               </h3>
               
               <pre><code class="language-go">var testFileSet = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testmainTmpl" data-name="testmainTmpl">
               <h3>
                  testmainTmpl 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testmainTmpl" class="anchor" title="Link to testmainTmpl">#</a>
               </h3>
               
               <pre><code class="language-go">var testmainTmpl = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testmainTmplNewCoverage" data-name="testmainTmplNewCoverage">
               <h3>
                  testmainTmplNewCoverage 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testmainTmplNewCoverage" class="anchor" title="Link to testmainTmplNewCoverage">#</a>
               </h3>
               
               <pre><code class="language-go">var testmainTmplNewCoverage = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="vcsStatusCache" data-name="vcsStatusCache">
               <h3>
                  vcsStatusCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#vcsStatusCache" class="anchor" title="Link to vcsStatusCache">#</a>
               </h3>
               
                  <p class="doc-comment">vcsStatusCache maps repository directories (string)
to their VCS information.</p>
               
               <pre><code class="language-go">var vcsStatusCache *ast.IndexListExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ImportStack" data-name="ImportStack">
               <h3>
                  ImportStack
                  <span class="badge type-badge">type</span>
                  <a href="#ImportStack" class="anchor" title="Link to ImportStack">#</a>
               </h3>
               
               <p>An ImportStack is a stack of import paths, possibly with the suffix " (test)" appended.
The import path of a test package is the import path of the corresponding
non-test package with the suffix "_test" added.</p>
               
               <pre><code class="language-go">type ImportStack []ImportInfo</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="TargetDir" data-name="TargetDir">
               <h3>
                  TargetDir
                  <span class="badge type-badge">type</span>
                  <a href="#TargetDir" class="anchor" title="Link to TargetDir">#</a>
               </h3>
               
               <pre><code class="language-go">type TargetDir int</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="ImportPathError" data-name="ImportPathError">
               <h3>
                  ImportPathError
                  <span class="badge interface-badge">interface</span>
                  <a href="#ImportPathError" class="anchor" title="Link to ImportPathError">#</a>
               </h3>
               
               <p>ImportPathError is a type of error that prevents a package from being loaded
for a given import path. When such a package is loaded, a *Package is
returned with Err wrapping an ImportPathError: the error is attached to
the imported package, not the importing package.
The string returned by ImportPath must appear in the string returned by
Error. Errors that wrap ImportPathError (such as PackageError) may omit
the import path.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type ImportPathError interface {
error
ImportPath() string
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Printer" data-name="Printer">
               <h3>
                  Printer
                  <span class="badge interface-badge">interface</span>
                  <a href="#Printer" class="anchor" title="Link to Printer">#</a>
               </h3>
               
               <p>A Printer reports output about a Package.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Printer interface {
Printf(pkg *Package, format string, args ...any)
Errorf(pkg *Package, format string, args ...any)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="CoverSetup" data-name="CoverSetup">
               <h3>
                  CoverSetup
                  <span class="badge">struct</span>
                  <a href="#CoverSetup" class="anchor" title="Link to CoverSetup">#</a>
               </h3>
               
               <p>CoverSetup holds parameters related to coverage setup for a given package (covermode, etc).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type CoverSetup struct {
Mode string
Cfg string
GenMeta bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="CoverVar" data-name="CoverVar">
               <h3>
                  CoverVar
                  <span class="badge">struct</span>
                  <a href="#CoverVar" class="anchor" title="Link to CoverVar">#</a>
               </h3>
               
               <p>CoverVar holds the name of the generated coverage variables targeting the named file.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type CoverVar struct {
File string
Var string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="EmbedError" data-name="EmbedError">
               <h3>
                  EmbedError
                  <span class="badge">struct</span>
                  <a href="#EmbedError" class="anchor" title="Link to EmbedError">#</a>
               </h3>
               
               <p>An EmbedError indicates a problem with a go:embed directive.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type EmbedError struct {
Pattern string
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ImportInfo" data-name="ImportInfo">
               <h3>
                  ImportInfo
                  <span class="badge">struct</span>
                  <a href="#ImportInfo" class="anchor" title="Link to ImportInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ImportInfo struct {
Pkg string
Pos *token.Position
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="JSONPrinter" data-name="JSONPrinter">
               <h3>
                  JSONPrinter
                  <span class="badge">struct</span>
                  <a href="#JSONPrinter" class="anchor" title="Link to JSONPrinter">#</a>
               </h3>
               
               <p>A JSONPrinter emits output about a build in JSON format.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type JSONPrinter struct {
enc *json.Encoder
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="NoGoError" data-name="NoGoError">
               <h3>
                  NoGoError
                  <span class="badge">struct</span>
                  <a href="#NoGoError" class="anchor" title="Link to NoGoError">#</a>
               </h3>
               
               <p>A NoGoError indicates that no Go files for the package were applicable to the
build for that package.
That may be because there were no files whatsoever, or because all files were
excluded, or because all non-excluded files were test sources.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type NoGoError struct {
Package *Package
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Package" data-name="Package">
               <h3>
                  Package
                  <span class="badge">struct</span>
                  <a href="#Package" class="anchor" title="Link to Package">#</a>
               </h3>
               
               <p>A Package describes a single package found in a directory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Package struct {
PackagePublic
Internal PackageInternal
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PackageError" data-name="PackageError">
               <h3>
                  PackageError
                  <span class="badge">struct</span>
                  <a href="#PackageError" class="anchor" title="Link to PackageError">#</a>
               </h3>
               
               <p>A PackageError describes an error loading information about a package.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PackageError struct {
ImportStack ImportStack
Pos string
Err error
IsImportCycle bool
alwaysPrintStack bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PackageInternal" data-name="PackageInternal">
               <h3>
                  PackageInternal
                  <span class="badge">struct</span>
                  <a href="#PackageInternal" class="anchor" title="Link to PackageInternal">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PackageInternal struct {
Build *build.Package
Imports []*Package
CompiledImports []string
RawImports []string
ForceLibrary bool
CmdlineFiles bool
CmdlinePkg bool
CmdlinePkgLiteral bool
Local bool
LocalPrefix string
ExeName string
FuzzInstrument bool
Cover CoverSetup
CoverVars map[string]*CoverVar
OmitDebug bool
GobinSubdir bool
BuildInfo *debug.BuildInfo
TestmainGo *[]byte
Embed map[string][]string
OrigImportPath string
PGOProfile string
ForMain string
Asmflags []string
Gcflags []string
Ldflags []string
Gccgoflags []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PackageOpts" data-name="PackageOpts">
               <h3>
                  PackageOpts
                  <span class="badge">struct</span>
                  <a href="#PackageOpts" class="anchor" title="Link to PackageOpts">#</a>
               </h3>
               
               <p>PackageOpts control the behavior of PackagesAndErrors and other package
loading functions.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PackageOpts struct {
IgnoreImports bool
ModResolveTests bool
MainOnly bool
AutoVCS bool
SuppressBuildInfo bool
SuppressEmbedFiles bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PackagePublic" data-name="PackagePublic">
               <h3>
                  PackagePublic
                  <span class="badge">struct</span>
                  <a href="#PackagePublic" class="anchor" title="Link to PackagePublic">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PackagePublic struct {
Dir string `json:",omitempty"`
ImportPath string `json:",omitempty"`
ImportComment string `json:",omitempty"`
Name string `json:",omitempty"`
Doc string `json:",omitempty"`
Target string `json:",omitempty"`
Shlib string `json:",omitempty"`
Root string `json:",omitempty"`
ConflictDir string `json:",omitempty"`
ForTest string `json:",omitempty"`
Export string `json:",omitempty"`
BuildID string `json:",omitempty"`
Module *modinfo.ModulePublic `json:",omitempty"`
Match []string `json:",omitempty"`
Goroot bool `json:",omitempty"`
Standard bool `json:",omitempty"`
DepOnly bool `json:",omitempty"`
BinaryOnly bool `json:",omitempty"`
Incomplete bool `json:",omitempty"`
DefaultGODEBUG string `json:",omitempty"`
Stale bool `json:",omitempty"`
StaleReason string `json:",omitempty"`
GoFiles []string `json:",omitempty"`
CgoFiles []string `json:",omitempty"`
CompiledGoFiles []string `json:",omitempty"`
IgnoredGoFiles []string `json:",omitempty"`
InvalidGoFiles []string `json:",omitempty"`
IgnoredOtherFiles []string `json:",omitempty"`
CFiles []string `json:",omitempty"`
CXXFiles []string `json:",omitempty"`
MFiles []string `json:",omitempty"`
HFiles []string `json:",omitempty"`
FFiles []string `json:",omitempty"`
SFiles []string `json:",omitempty"`
SwigFiles []string `json:",omitempty"`
SwigCXXFiles []string `json:",omitempty"`
SysoFiles []string `json:",omitempty"`
EmbedPatterns []string `json:",omitempty"`
EmbedFiles []string `json:",omitempty"`
CgoCFLAGS []string `json:",omitempty"`
CgoCPPFLAGS []string `json:",omitempty"`
CgoCXXFLAGS []string `json:",omitempty"`
CgoFFLAGS []string `json:",omitempty"`
CgoLDFLAGS []string `json:",omitempty"`
CgoPkgConfig []string `json:",omitempty"`
Imports []string `json:",omitempty"`
ImportMap map[string]string `json:",omitempty"`
Deps []string `json:",omitempty"`
Error *PackageError `json:",omitempty"`
DepsErrors []*PackageError `json:",omitempty"`
TestGoFiles []string `json:",omitempty"`
TestImports []string `json:",omitempty"`
TestEmbedPatterns []string `json:",omitempty"`
TestEmbedFiles []string `json:",omitempty"`
XTestGoFiles []string `json:",omitempty"`
XTestImports []string `json:",omitempty"`
XTestEmbedPatterns []string `json:",omitempty"`
XTestEmbedFiles []string `json:",omitempty"`
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PerPackageFlag" data-name="PerPackageFlag">
               <h3>
                  PerPackageFlag
                  <span class="badge">struct</span>
                  <a href="#PerPackageFlag" class="anchor" title="Link to PerPackageFlag">#</a>
               </h3>
               
               <p>A PerPackageFlag is a command-line flag implementation (a flag.Value)
that allows specifying different effective flags for different packages.
See 'go help build' for more details about per-package flags.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PerPackageFlag struct {
raw string
present bool
values []ppfValue
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TestCover" data-name="TestCover">
               <h3>
                  TestCover
                  <span class="badge">struct</span>
                  <a href="#TestCover" class="anchor" title="Link to TestCover">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type TestCover struct {
Mode string
Local bool
Pkgs []*Package
Paths []string
Vars []coverInfo
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="TextPrinter" data-name="TextPrinter">
               <h3>
                  TextPrinter
                  <span class="badge">struct</span>
                  <a href="#TextPrinter" class="anchor" title="Link to TextPrinter">#</a>
               </h3>
               
               <p>A TextPrinter emits text format output to Writer.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type TextPrinter struct {
Writer io.Writer
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="coverInfo" data-name="coverInfo">
               <h3>
                  coverInfo
                  <span class="badge">struct</span>
                  <a href="#coverInfo" class="anchor" title="Link to coverInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type coverInfo struct {
Package *Package
Vars map[string]*CoverVar
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="importError" data-name="importError">
               <h3>
                  importError
                  <span class="badge">struct</span>
                  <a href="#importError" class="anchor" title="Link to importError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type importError struct {
importPath string
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="importSpec" data-name="importSpec">
               <h3>
                  importSpec
                  <span class="badge">struct</span>
                  <a href="#importSpec" class="anchor" title="Link to importSpec">#</a>
               </h3>
               
               <p>importSpec describes an import declaration in source code. It is used as a
cache key for resolvedImportCache.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type importSpec struct {
path string
parentPath string
parentDir string
parentRoot string
parentIsStd bool
mode int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="jsonBuildEvent" data-name="jsonBuildEvent">
               <h3>
                  jsonBuildEvent
                  <span class="badge">struct</span>
                  <a href="#jsonBuildEvent" class="anchor" title="Link to jsonBuildEvent">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type jsonBuildEvent struct {
ImportPath string
Action string
Output string `json:",omitempty"`
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="mainPackageError" data-name="mainPackageError">
               <h3>
                  mainPackageError
                  <span class="badge">struct</span>
                  <a href="#mainPackageError" class="anchor" title="Link to mainPackageError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type mainPackageError struct {
importPath string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ppfValue" data-name="ppfValue">
               <h3>
                  ppfValue
                  <span class="badge">struct</span>
                  <a href="#ppfValue" class="anchor" title="Link to ppfValue">#</a>
               </h3>
               
               <p>A ppfValue is a single <pattern>=<flags> per-package flag value.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ppfValue struct {
match func(*Package) bool
flags []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="preload" data-name="preload">
               <h3>
                  preload
                  <span class="badge">struct</span>
                  <a href="#preload" class="anchor" title="Link to preload">#</a>
               </h3>
               
               <p>preload holds state for managing concurrent preloading of package data.
A preload should be created with newPreload before loading a large
package graph. flush must be called when package loading is complete
to ensure preload goroutines are no longer active. This is necessary
because of global mutable state that cannot safely be read and written
concurrently. In particular, packageDataCache may be cleared by "go get"
in GOPATH mode, and modload.loaded (accessed via modload.Lookup) may be
modified by modload.LoadPackages.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type preload struct {
cancel chan struct{...}
sema chan struct{...}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="resolvedImport" data-name="resolvedImport">
               <h3>
                  resolvedImport
                  <span class="badge">struct</span>
                  <a href="#resolvedImport" class="anchor" title="Link to resolvedImport">#</a>
               </h3>
               
               <p>resolvedImport holds a canonical identifier for a package. It may also contain
a path to the package's directory and an error if one occurred. resolvedImport
is the value type in resolvedImportCache.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type resolvedImport struct {
path string
dir string
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="testFunc" data-name="testFunc">
               <h3>
                  testFunc
                  <span class="badge">struct</span>
                  <a href="#testFunc" class="anchor" title="Link to testFunc">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type testFunc struct {
Package string
Name string
Output string
Unordered bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="testFuncs" data-name="testFuncs">
               <h3>
                  testFuncs
                  <span class="badge">struct</span>
                  <a href="#testFuncs" class="anchor" title="Link to testFuncs">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type testFuncs struct {
Tests []testFunc
Benchmarks []testFunc
FuzzTargets []testFunc
Examples []testFunc
TestMain *testFunc
Package *Package
ImportTest bool
NeedTest bool
ImportXtest bool
NeedXtest bool
Cover *TestCover
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AllFiles" data-name="AllFiles">
               <h3>
                  AllFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AllFiles" class="anchor" title="Link to AllFiles">#</a>
               </h3>
               
               <p>AllFiles returns the names of all the files considered for the package.
This is used for sanity and security checks, so we include all files,
even IgnoredGoFiles, because some subcommands consider them.
The go/build package filtered others out (like foo_wrongGOARCH.s)
and that's OK.</p>
               
               <pre><code class="language-go">func (p *Package) AllFiles() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckPackageErrors" data-name="CheckPackageErrors">
               <h3>
                  CheckPackageErrors 
                  <span class="badge">function</span>
                  
                  <a href="#CheckPackageErrors" class="anchor" title="Link to CheckPackageErrors">#</a>
               </h3>
               
               <p>CheckPackageErrors prints errors encountered loading pkgs and their
dependencies, then exits with a non-zero status if any errors were found.</p>
               
               <pre><code class="language-go">func CheckPackageErrors(pkgs []*Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Copy" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Copy" class="anchor" title="Link to Copy">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *ImportStack) Copy() ImportStack</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CoverSelectedPackages" data-name="CoverSelectedPackages">
               <h3>
                  CoverSelectedPackages 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CoverSelectedPackages" class="anchor" title="Link to CoverSelectedPackages">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *testFuncs) CoverSelectedPackages() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Covered" data-name="Covered">
               <h3>
                  Covered 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Covered" class="anchor" title="Link to Covered">#</a>
               </h3>
               
               <p>Covered returns a string describing which packages are being tested for coverage.
If the covered package is the same as the tested package, it returns the empty string.
Otherwise it is a comma-separated human-readable list of packages beginning with
" in", ready for use in the coverage message.</p>
               
               <pre><code class="language-go">func (t *testFuncs) Covered() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DeclareCoverVars" data-name="DeclareCoverVars">
               <h3>
                  DeclareCoverVars 
                  <span class="badge">function</span>
                  
                  <a href="#DeclareCoverVars" class="anchor" title="Link to DeclareCoverVars">#</a>
               </h3>
               
               <p>DeclareCoverVars attaches the required cover variables names
to the files, to be used when annotating the files. This
function only called when using legacy coverage test/build
(e.g. GOEXPERIMENT=coverageredesign is off).</p>
               
               <pre><code class="language-go">func DeclareCoverVars(p *Package, files ...string) map[string]*CoverVar</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DefaultExecName" data-name="DefaultExecName">
               <h3>
                  DefaultExecName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DefaultExecName" class="anchor" title="Link to DefaultExecName">#</a>
               </h3>
               
               <p>DefaultExecName returns the default executable name for a package</p>
               
               <pre><code class="language-go">func (p *Package) DefaultExecName() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DefaultPrinter" data-name="DefaultPrinter">
               <h3>
                  DefaultPrinter 
                  <span class="badge">function</span>
                  
                  <a href="#DefaultPrinter" class="anchor" title="Link to DefaultPrinter">#</a>
               </h3>
               
               <p>DefaultPrinter returns the default Printer.</p>
               
               <pre><code class="language-go">func DefaultPrinter() Printer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Desc" data-name="Desc">
               <h3>
                  Desc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Desc" class="anchor" title="Link to Desc">#</a>
               </h3>
               
               <p>Desc returns the package "description", for use in b.showOutput.</p>
               
               <pre><code class="language-go">func (p *Package) Desc() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EnsureImport" data-name="EnsureImport">
               <h3>
                  EnsureImport 
                  <span class="badge">function</span>
                  
                  <a href="#EnsureImport" class="anchor" title="Link to EnsureImport">#</a>
               </h3>
               
               <p>EnsureImport ensures that package p imports the named package.</p>
               
               <pre><code class="language-go">func EnsureImport(p *Package, pkg string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *NoGoError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *EmbedError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *importError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *mainPackageError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *PackageError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Errorf" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Errorf" class="anchor" title="Link to Errorf">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *JSONPrinter) Errorf(pkg *Package, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Errorf" data-name="Errorf">
               <h3>
                  Errorf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Errorf" class="anchor" title="Link to Errorf">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *TextPrinter) Errorf(_ *Package, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FindVendor" data-name="FindVendor">
               <h3>
                  FindVendor 
                  <span class="badge">function</span>
                  
                  <a href="#FindVendor" class="anchor" title="Link to FindVendor">#</a>
               </h3>
               
               <p>FindVendor looks for the last non-terminating "vendor" path element in the given import path.
If there isn't one, FindVendor returns ok=false.
Otherwise, FindVendor returns ok=true and the index of the "vendor".
Note that terminating "vendor" elements don't count: "x/vendor" is its own package,
not the vendored copy of an import "" (the empty import path).
This will allow people to have packages or commands named vendor.
This may help reduce breakage, or it may just be confusing. We'll see.</p>
               
               <pre><code class="language-go">func FindVendor(path string) (index int, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="For" data-name="For">
               <h3>
                  For 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#For" class="anchor" title="Link to For">#</a>
               </h3>
               
               <p>For returns the flags to use for the given package.</p>
               
               <pre><code class="language-go">func (f *PerPackageFlag) For(p *Package) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoFilesPackage" data-name="GoFilesPackage">
               <h3>
                  GoFilesPackage 
                  <span class="badge">function</span>
                  
                  <a href="#GoFilesPackage" class="anchor" title="Link to GoFilesPackage">#</a>
               </h3>
               
               <p>GoFilesPackage creates a package for building a collection of Go files
(typically named on the command line). The target is named p.a for
package p or named after the first Go file for package main.</p>
               
               <pre><code class="language-go">func GoFilesPackage(ctx context.Context, opts PackageOpts, gofiles []string) *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportErrorf" data-name="ImportErrorf">
               <h3>
                  ImportErrorf 
                  <span class="badge">function</span>
                  
                  <a href="#ImportErrorf" class="anchor" title="Link to ImportErrorf">#</a>
               </h3>
               
               <pre><code class="language-go">func ImportErrorf(path string, format string, args ...any) ImportPathError</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPath" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPath" class="anchor" title="Link to ImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *importError) ImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPath" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPath" class="anchor" title="Link to ImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *mainPackageError) ImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPath" data-name="ImportPath">
               <h3>
                  ImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPath" class="anchor" title="Link to ImportPath">#</a>
               </h3>
               
               <p>ImportPath returns the import path of the package being tested, if it is within GOPATH.
This is printed by the testing package when running benchmarks.</p>
               
               <pre><code class="language-go">func (t *testFuncs) ImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InstallTargetDir" data-name="InstallTargetDir">
               <h3>
                  InstallTargetDir 
                  <span class="badge">function</span>
                  
                  <a href="#InstallTargetDir" class="anchor" title="Link to InstallTargetDir">#</a>
               </h3>
               
               <p>InstallTargetDir reports the target directory for installing the command p.</p>
               
               <pre><code class="language-go">func InstallTargetDir(p *Package) TargetDir</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InternalAllGoFiles" data-name="InternalAllGoFiles">
               <h3>
                  InternalAllGoFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InternalAllGoFiles" class="anchor" title="Link to InternalAllGoFiles">#</a>
               </h3>
               
               <p>InternalAllGoFiles returns the list of all Go files possibly relevant for the package,
using absolute paths. "Possibly relevant" means that files are not excluded
due to build tags, but files with names beginning with . or _ are still excluded.</p>
               
               <pre><code class="language-go">func (p *Package) InternalAllGoFiles() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InternalGoFiles" data-name="InternalGoFiles">
               <h3>
                  InternalGoFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InternalGoFiles" class="anchor" title="Link to InternalGoFiles">#</a>
               </h3>
               
               <p>InternalGoFiles returns the list of Go files being built for the package,
using absolute paths.</p>
               
               <pre><code class="language-go">func (p *Package) InternalGoFiles() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InternalXGoFiles" data-name="InternalXGoFiles">
               <h3>
                  InternalXGoFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InternalXGoFiles" class="anchor" title="Link to InternalXGoFiles">#</a>
               </h3>
               
               <p>InternalXGoFiles returns the list of Go files being built for the XTest package,
using absolute paths.</p>
               
               <pre><code class="language-go">func (p *Package) InternalXGoFiles() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsTestOnly" data-name="IsTestOnly">
               <h3>
                  IsTestOnly 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsTestOnly" class="anchor" title="Link to IsTestOnly">#</a>
               </h3>
               
               <p>IsTestOnly reports whether p is a test-only package.
A “test-only” package is one that:
- is a test-only variant of an ordinary package, or
- is a synthesized "main" package for a test binary, or
- contains only _test.go files.</p>
               
               <pre><code class="language-go">func (p *Package) IsTestOnly() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LinkerDeps" data-name="LinkerDeps">
               <h3>
                  LinkerDeps 
                  <span class="badge">function</span>
                  
                  <a href="#LinkerDeps" class="anchor" title="Link to LinkerDeps">#</a>
               </h3>
               
               <p>LinkerDeps returns the list of linker-induced dependencies for main package p.</p>
               
               <pre><code class="language-go">func LinkerDeps(p *Package) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadImportWithFlags" data-name="LoadImportWithFlags">
               <h3>
                  LoadImportWithFlags 
                  <span class="badge">function</span>
                  
                  <a href="#LoadImportWithFlags" class="anchor" title="Link to LoadImportWithFlags">#</a>
               </h3>
               
               <p>LoadImportWithFlags loads the package with the given import path and
sets tool flags on that package. This function is useful loading implicit
dependencies (like sync/atomic for coverage).
TODO(jayconrod): delete this function and set flags automatically
in LoadImport instead.</p>
               
               <pre><code class="language-go">func LoadImportWithFlags(path string, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) (*Package, *PackageError)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadPackage" data-name="LoadPackage">
               <h3>
                  LoadPackage 
                  <span class="badge">function</span>
                  
                  <a href="#LoadPackage" class="anchor" title="Link to LoadPackage">#</a>
               </h3>
               
               <p>LoadPackage does Load import, but without a parent package load context</p>
               
               <pre><code class="language-go">func LoadPackage(ctx context.Context, opts PackageOpts, path string, srcDir string, stk *ImportStack, importPos []token.Position, mode int) *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LoadPackageWithFlags" data-name="LoadPackageWithFlags">
               <h3>
                  LoadPackageWithFlags 
                  <span class="badge">function</span>
                  
                  <a href="#LoadPackageWithFlags" class="anchor" title="Link to LoadPackageWithFlags">#</a>
               </h3>
               
               <p>LoadPackageWithFlags is the same as LoadImportWithFlags but without a parent.
It's then guaranteed to not return an error</p>
               
               <pre><code class="language-go">func LoadPackageWithFlags(path string, srcDir string, stk *ImportStack, importPos []token.Position, mode int) *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MarshalJSON" data-name="MarshalJSON">
               <h3>
                  MarshalJSON 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#MarshalJSON" class="anchor" title="Link to MarshalJSON">#</a>
               </h3>
               
               <p>PackageError implements MarshalJSON so that Err is marshaled as a string
and non-essential fields are omitted.</p>
               
               <pre><code class="language-go">func (p *PackageError) MarshalJSON() ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MatchPackage" data-name="MatchPackage">
               <h3>
                  MatchPackage 
                  <span class="badge">function</span>
                  
                  <a href="#MatchPackage" class="anchor" title="Link to MatchPackage">#</a>
               </h3>
               
               <p>MatchPackage(pattern, cwd)(p) reports whether package p matches pattern in the working directory cwd.</p>
               
               <pre><code class="language-go">func MatchPackage(pattern string, cwd string) (func(*Package) bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewImportInfo" data-name="NewImportInfo">
               <h3>
                  NewImportInfo 
                  <span class="badge">function</span>
                  
                  <a href="#NewImportInfo" class="anchor" title="Link to NewImportInfo">#</a>
               </h3>
               
               <pre><code class="language-go">func NewImportInfo(pkg string, pos *token.Position) ImportInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewJSONPrinter" data-name="NewJSONPrinter">
               <h3>
                  NewJSONPrinter 
                  <span class="badge">function</span>
                  
                  <a href="#NewJSONPrinter" class="anchor" title="Link to NewJSONPrinter">#</a>
               </h3>
               
               <pre><code class="language-go">func NewJSONPrinter(w io.Writer) *JSONPrinter</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PackageErrors" data-name="PackageErrors">
               <h3>
                  PackageErrors 
                  <span class="badge">function</span>
                  
                  <a href="#PackageErrors" class="anchor" title="Link to PackageErrors">#</a>
               </h3>
               
               <p>PackageErrors calls report for errors encountered loading pkgs and their dependencies.</p>
               
               <pre><code class="language-go">func PackageErrors(pkgs []*Package, report func(*Package))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PackageList" data-name="PackageList">
               <h3>
                  PackageList 
                  <span class="badge">function</span>
                  
                  <a href="#PackageList" class="anchor" title="Link to PackageList">#</a>
               </h3>
               
               <p>PackageList returns the list of packages in the dag rooted at roots
as visited in a depth-first post-order traversal.</p>
               
               <pre><code class="language-go">func PackageList(roots []*Package) []*Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PackagesAndErrors" data-name="PackagesAndErrors">
               <h3>
                  PackagesAndErrors 
                  <span class="badge">function</span>
                  
                  <a href="#PackagesAndErrors" class="anchor" title="Link to PackagesAndErrors">#</a>
               </h3>
               
               <p>PackagesAndErrors returns the packages named by the command line arguments
'patterns'. If a named package cannot be loaded, PackagesAndErrors returns
a *Package with the Error field describing the failure. If errors are found
loading imported packages, the DepsErrors field is set. The Incomplete field
may be set as well.
To obtain a flat list of packages, use PackageList.
To report errors loading packages, use ReportPackageErrors.</p>
               
               <pre><code class="language-go">func PackagesAndErrors(ctx context.Context, opts PackageOpts, patterns []string) []*Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PackagesAndErrorsOutsideModule" data-name="PackagesAndErrorsOutsideModule">
               <h3>
                  PackagesAndErrorsOutsideModule 
                  <span class="badge">function</span>
                  
                  <a href="#PackagesAndErrorsOutsideModule" class="anchor" title="Link to PackagesAndErrorsOutsideModule">#</a>
               </h3>
               
               <p>PackagesAndErrorsOutsideModule is like PackagesAndErrors but runs in
module-aware mode and ignores the go.mod file in the current directory or any
parent directory, if there is one. This is used in the implementation of 'go
install pkg@version' and other commands that support similar forms.
modload.ForceUseModules must be true, and modload.RootMode must be NoRoot
before calling this function.
PackagesAndErrorsOutsideModule imposes several constraints to avoid
ambiguity. All arguments must have the same version suffix (not just a suffix
that resolves to the same version). They must refer to packages in the same
module, which must not be std or cmd. That module is not considered the main
module, but its go.mod file (if it has one) must not contain directives that
would cause it to be interpreted differently if it were the main module
(replace, exclude).</p>
               
               <pre><code class="language-go">func PackagesAndErrorsOutsideModule(ctx context.Context, opts PackageOpts, args []string) ([]*Package, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ParseGoDebug" data-name="ParseGoDebug">
               <h3>
                  ParseGoDebug 
                  <span class="badge">function</span>
                  
                  <a href="#ParseGoDebug" class="anchor" title="Link to ParseGoDebug">#</a>
               </h3>
               
               <pre><code class="language-go">func ParseGoDebug(text string) (key string, value string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pkgs" data-name="Pkgs">
               <h3>
                  Pkgs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pkgs" class="anchor" title="Link to Pkgs">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *ImportStack) Pkgs() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PkgsWithPos" data-name="PkgsWithPos">
               <h3>
                  PkgsWithPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PkgsWithPos" class="anchor" title="Link to PkgsWithPos">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *ImportStack) PkgsWithPos() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pop" data-name="Pop">
               <h3>
                  Pop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pop" class="anchor" title="Link to Pop">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *ImportStack) Pop()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PrepareForCoverageBuild" data-name="PrepareForCoverageBuild">
               <h3>
                  PrepareForCoverageBuild 
                  <span class="badge">function</span>
                  
                  <a href="#PrepareForCoverageBuild" class="anchor" title="Link to PrepareForCoverageBuild">#</a>
               </h3>
               
               <p>PrepareForCoverageBuild is a helper invoked for "go install
-cover", "go run -cover", and "go build -cover" (but not used by
"go test -cover"). It walks through the packages being built (and
dependencies) and marks them for coverage instrumentation when
appropriate, and possibly adding additional deps where needed.</p>
               
               <pre><code class="language-go">func PrepareForCoverageBuild(pkgs []*Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Present" data-name="Present">
               <h3>
                  Present 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Present" class="anchor" title="Link to Present">#</a>
               </h3>
               
               <p>Present reports whether the flag appeared on the command line.</p>
               
               <pre><code class="language-go">func (f *PerPackageFlag) Present() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Printf" data-name="Printf">
               <h3>
                  Printf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Printf" class="anchor" title="Link to Printf">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *JSONPrinter) Printf(pkg *Package, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Printf" data-name="Printf">
               <h3>
                  Printf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Printf" class="anchor" title="Link to Printf">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *TextPrinter) Printf(_ *Package, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Push" data-name="Push">
               <h3>
                  Push 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Push" class="anchor" title="Link to Push">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *ImportStack) Push(p ImportInfo)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Resolve" data-name="Resolve">
               <h3>
                  Resolve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Resolve" class="anchor" title="Link to Resolve">#</a>
               </h3>
               
               <p>Resolve returns the resolved version of imports,
which should be p.TestImports or p.XTestImports, NOT p.Imports.
The imports in p.TestImports and p.XTestImports are not recursively
loaded during the initial load of p, so they list the imports found in
the source file, but most processing should be over the vendor-resolved
import paths. We do this resolution lazily both to avoid file system work
and because the eventual real load of the test imports (during 'go test')
can produce better error messages if it starts with the original paths.
The initial load of p loads all the non-test imports and rewrites
the vendored paths, so nothing should ever call p.vendored(p.Imports).</p>
               
               <pre><code class="language-go">func (p *Package) Resolve(imports []string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ResolveEmbed" data-name="ResolveEmbed">
               <h3>
                  ResolveEmbed 
                  <span class="badge">function</span>
                  
                  <a href="#ResolveEmbed" class="anchor" title="Link to ResolveEmbed">#</a>
               </h3>
               
               <p>ResolveEmbed resolves //go:embed patterns and returns only the file list.
For use by go mod vendor to find embedded files it should copy into the
vendor directory.
TODO(#42504): Once go mod vendor uses load.PackagesAndErrors, just
call (*Package).ResolveEmbed</p>
               
               <pre><code class="language-go">func ResolveEmbed(dir string, patterns []string) ([]string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ResolveImportPath" data-name="ResolveImportPath">
               <h3>
                  ResolveImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#ResolveImportPath" class="anchor" title="Link to ResolveImportPath">#</a>
               </h3>
               
               <p>ResolveImportPath returns the true meaning of path when it appears in parent.
There are two different resolutions applied.
First, there is Go 1.5 vendoring (golang.org/s/go15vendor).
If vendor expansion doesn't trigger, then the path is also subject to
Go 1.11 module legacy conversion (golang.org/issue/25069).</p>
               
               <pre><code class="language-go">func ResolveImportPath(parent *Package, path string) (found string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SafeArg" data-name="SafeArg">
               <h3>
                  SafeArg 
                  <span class="badge">function</span>
                  
                  <a href="#SafeArg" class="anchor" title="Link to SafeArg">#</a>
               </h3>
               
               <p>SafeArg reports whether arg is a "safe" command-line argument,
meaning that when it appears in a command-line, it probably
doesn't have some special meaning other than its own name.
Obviously args beginning with - are not safe (they look like flags).
Less obviously, args beginning with @ are not safe (they look like
GNU binutils flagfile specifiers, sometimes called "response files").
To be conservative, we reject almost any arg beginning with non-alphanumeric ASCII.
We accept leading . _ and / as likely in file system paths.
There is a copy of this function in cmd/compile/internal/gc/noder.go.</p>
               
               <pre><code class="language-go">func SafeArg(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SelectCoverPackages" data-name="SelectCoverPackages">
               <h3>
                  SelectCoverPackages 
                  <span class="badge">function</span>
                  
                  <a href="#SelectCoverPackages" class="anchor" title="Link to SelectCoverPackages">#</a>
               </h3>
               
               <pre><code class="language-go">func SelectCoverPackages(roots []*Package, match []func(*Package) bool, op string) []*Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>Set is called each time the flag is encountered on the command line.</p>
               
               <pre><code class="language-go">func (f *PerPackageFlag) Set(v string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *PerPackageFlag) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Top" data-name="Top">
               <h3>
                  Top 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Top" class="anchor" title="Link to Top">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *ImportStack) Top() (ImportInfo, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *PackageError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *importError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *EmbedError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UsesCgo" data-name="UsesCgo">
               <h3>
                  UsesCgo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UsesCgo" class="anchor" title="Link to UsesCgo">#</a>
               </h3>
               
               <p>UsesCgo reports whether the package needs to run cgo</p>
               
               <pre><code class="language-go">func (p *Package) UsesCgo() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UsesSwig" data-name="UsesSwig">
               <h3>
                  UsesSwig 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UsesSwig" class="anchor" title="Link to UsesSwig">#</a>
               </h3>
               
               <p>UsesSwig reports whether the package needs to run SWIG.</p>
               
               <pre><code class="language-go">func (p *Package) UsesSwig() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendBuildSetting" data-name="appendBuildSetting">
               <h3>
                  appendBuildSetting 
                  <span class="badge">function</span>
                  
                  <a href="#appendBuildSetting" class="anchor" title="Link to appendBuildSetting">#</a>
               </h3>
               
               <pre><code class="language-go">func appendBuildSetting(info *debug.BuildInfo, key string, value string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkTestFunc" data-name="checkTestFunc">
               <h3>
                  checkTestFunc 
                  <span class="badge">function</span>
                  
                  <a href="#checkTestFunc" class="anchor" title="Link to checkTestFunc">#</a>
               </h3>
               
               <pre><code class="language-go">func checkTestFunc(fn *ast.FuncDecl, arg string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanImport" data-name="cleanImport">
               <h3>
                  cleanImport 
                  <span class="badge">function</span>
                  
                  <a href="#cleanImport" class="anchor" title="Link to cleanImport">#</a>
               </h3>
               
               <pre><code class="language-go">func cleanImport(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyBuild" data-name="copyBuild">
               <h3>
                  copyBuild 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#copyBuild" class="anchor" title="Link to copyBuild">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *Package) copyBuild(opts PackageOpts, pp *build.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultGODEBUG" data-name="defaultGODEBUG">
               <h3>
                  defaultGODEBUG 
                  <span class="badge">function</span>
                  
                  <a href="#defaultGODEBUG" class="anchor" title="Link to defaultGODEBUG">#</a>
               </h3>
               
               <p>defaultGODEBUG returns the default GODEBUG setting for the main package p.
When building a test binary, directives, testDirectives, and xtestDirectives
list additional directives from the package under test.</p>
               
               <pre><code class="language-go">func defaultGODEBUG(p *Package, directives []build.Directive, testDirectives []build.Directive, xtestDirectives []build.Directive) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dirAndRoot" data-name="dirAndRoot">
               <h3>
                  dirAndRoot 
                  <span class="badge">function</span>
                  
                  <a href="#dirAndRoot" class="anchor" title="Link to dirAndRoot">#</a>
               </h3>
               
               <p>dirAndRoot returns the source directory and workspace root
for the package p, guaranteeing that root is a path prefix of dir.</p>
               
               <pre><code class="language-go">func dirAndRoot(path string, dir string, root string) (string, string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dirToImportPath" data-name="dirToImportPath">
               <h3>
                  dirToImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#dirToImportPath" class="anchor" title="Link to dirToImportPath">#</a>
               </h3>
               
               <p>dirToImportPath returns the pseudo-import path we use for a package
outside the Go path. It begins with _/ and then contains the full path
to the directory. If the package lives in c:\home\gopher\my\pkg then
the pseudo-import path is _/c_/home/gopher/my/pkg.
Using a pseudo-import path like this makes the ./ imports no longer
a special case, so that all the code to deal with ordinary imports works
automatically.</p>
               
               <pre><code class="language-go">func dirToImportPath(dir string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="disallowInternal" data-name="disallowInternal">
               <h3>
                  disallowInternal 
                  <span class="badge">function</span>
                  
                  <a href="#disallowInternal" class="anchor" title="Link to disallowInternal">#</a>
               </h3>
               
               <p>disallowInternal checks that srcDir (containing package importerPath, if non-empty)
is allowed to import p.
If the import is allowed, disallowInternal returns the original package p.
If not, it returns a new package containing just an appropriate error.</p>
               
               <pre><code class="language-go">func disallowInternal(ctx context.Context, srcDir string, importer *Package, importerPath string, p *Package, stk *ImportStack) *PackageError</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="disallowVendor" data-name="disallowVendor">
               <h3>
                  disallowVendor 
                  <span class="badge">function</span>
                  
                  <a href="#disallowVendor" class="anchor" title="Link to disallowVendor">#</a>
               </h3>
               
               <p>disallowVendor checks that srcDir is allowed to import p as path.
If the import is allowed, disallowVendor returns the original package p.
If not, it returns a PackageError.</p>
               
               <pre><code class="language-go">func disallowVendor(srcDir string, path string, importerPath string, p *Package, stk *ImportStack) *PackageError</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="disallowVendorVisibility" data-name="disallowVendorVisibility">
               <h3>
                  disallowVendorVisibility 
                  <span class="badge">function</span>
                  
                  <a href="#disallowVendorVisibility" class="anchor" title="Link to disallowVendorVisibility">#</a>
               </h3>
               
               <p>disallowVendorVisibility checks that srcDir is allowed to import p.
The rules are the same as for /internal/ except that a path ending in /vendor
is not subject to the rules, only subdirectories of vendor.
This allows people to have packages and commands named vendor,
for maximal compatibility with existing source trees.</p>
               
               <pre><code class="language-go">func disallowVendorVisibility(srcDir string, p *Package, importerPath string, stk *ImportStack) *PackageError</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ensureNewline" data-name="ensureNewline">
               <h3>
                  ensureNewline 
                  <span class="badge">function</span>
                  
                  <a href="#ensureNewline" class="anchor" title="Link to ensureNewline">#</a>
               </h3>
               
               <pre><code class="language-go">func ensureNewline(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exeFromFiles" data-name="exeFromFiles">
               <h3>
                  exeFromFiles 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exeFromFiles" class="anchor" title="Link to exeFromFiles">#</a>
               </h3>
               
               <p>exeFromFiles returns an executable name for a package
using the first element in GoFiles or CgoFiles collections without the prefix.
Returns empty string in case of empty collection.</p>
               
               <pre><code class="language-go">func (p *Package) exeFromFiles() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exeFromImportPath" data-name="exeFromImportPath">
               <h3>
                  exeFromImportPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exeFromImportPath" class="anchor" title="Link to exeFromImportPath">#</a>
               </h3>
               
               <p>exeFromImportPath returns an executable name
for a package using the import path.
The executable name is the last element of the import path.
In module-aware mode, an additional rule is used on import paths
consisting of two or more path elements. If the last element is
a vN path element specifying the major version, then the
second last element of the import path is used instead.</p>
               
               <pre><code class="language-go">func (p *Package) exeFromImportPath() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expandPath" data-name="expandPath">
               <h3>
                  expandPath 
                  <span class="badge">function</span>
                  
                  <a href="#expandPath" class="anchor" title="Link to expandPath">#</a>
               </h3>
               
               <p>expandPath returns the symlink-expanded form of path.</p>
               
               <pre><code class="language-go">func expandPath(p string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="externalLinkingReason" data-name="externalLinkingReason">
               <h3>
                  externalLinkingReason 
                  <span class="badge">function</span>
                  
                  <a href="#externalLinkingReason" class="anchor" title="Link to externalLinkingReason">#</a>
               </h3>
               
               <p>externalLinkingReason reports the reason external linking is required
even for programs that do not use cgo, or the empty string if external
linking is not required.</p>
               
               <pre><code class="language-go">func externalLinkingReason(p *Package) (what string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="extractFirstImport" data-name="extractFirstImport">
               <h3>
                  extractFirstImport 
                  <span class="badge">function</span>
                  
                  <a href="#extractFirstImport" class="anchor" title="Link to extractFirstImport">#</a>
               </h3>
               
               <pre><code class="language-go">func extractFirstImport(importPos []token.Position) *token.Position</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findInternal" data-name="findInternal">
               <h3>
                  findInternal 
                  <span class="badge">function</span>
                  
                  <a href="#findInternal" class="anchor" title="Link to findInternal">#</a>
               </h3>
               
               <p>findInternal looks for the final "internal" path element in the given import path.
If there isn't one, findInternal returns ok=false.
Otherwise, findInternal returns ok=true and the index of the "internal".</p>
               
               <pre><code class="language-go">func findInternal(path string) (index int, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findVersionElement" data-name="findVersionElement">
               <h3>
                  findVersionElement 
                  <span class="badge">function</span>
                  
                  <a href="#findVersionElement" class="anchor" title="Link to findVersionElement">#</a>
               </h3>
               
               <p>findVersionElement returns the slice indices of the final version element /vN in path.
If there is no such element, it returns -1, -1.</p>
               
               <pre><code class="language-go">func findVersionElement(path string) (i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="flush" data-name="flush">
               <h3>
                  flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#flush" class="anchor" title="Link to flush">#</a>
               </h3>
               
               <p>flush stops pending preload operations. flush blocks until preload calls to
loadPackageData have completed. The preloader will not make any new calls
to loadPackageData.</p>
               
               <pre><code class="language-go">func (pre *preload) flush()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatTestmain" data-name="formatTestmain">
               <h3>
                  formatTestmain 
                  <span class="badge">function</span>
                  
                  <a href="#formatTestmain" class="anchor" title="Link to formatTestmain">#</a>
               </h3>
               
               <p>formatTestmain returns the content of the _testmain.go file for t.</p>
               
               <pre><code class="language-go">func formatTestmain(t *testFuncs) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goModPath" data-name="goModPath">
               <h3>
                  goModPath 
                  <span class="badge">function</span>
                  
                  <a href="#goModPath" class="anchor" title="Link to goModPath">#</a>
               </h3>
               
               <p>goModPath returns the module path in the go.mod in dir, if any.</p>
               
               <pre><code class="language-go">func goModPath(dir string) (path string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="godebugForGoVersion" data-name="godebugForGoVersion">
               <h3>
                  godebugForGoVersion 
                  <span class="badge">function</span>
                  
                  <a href="#godebugForGoVersion" class="anchor" title="Link to godebugForGoVersion">#</a>
               </h3>
               
               <pre><code class="language-go">func godebugForGoVersion(v string) map[string]string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasGoFiles" data-name="hasGoFiles">
               <h3>
                  hasGoFiles 
                  <span class="badge">function</span>
                  
                  <a href="#hasGoFiles" class="anchor" title="Link to hasGoFiles">#</a>
               </h3>
               
               <p>hasGoFiles reports whether dir contains any files with names ending in .go.
For a vendor check we must exclude directories that contain no .go files.
Otherwise it is not possible to vendor just a/b/c and still import the
non-vendored a/b. See golang.org/issue/13832.</p>
               
               <pre><code class="language-go">func hasGoFiles(dir string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isBadEmbedName" data-name="isBadEmbedName">
               <h3>
                  isBadEmbedName 
                  <span class="badge">function</span>
                  
                  <a href="#isBadEmbedName" class="anchor" title="Link to isBadEmbedName">#</a>
               </h3>
               
               <p>isBadEmbedName reports whether name is the base name of a file that
can't or won't be included in modules and therefore shouldn't be treated
as existing for embedding.</p>
               
               <pre><code class="language-go">func isBadEmbedName(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDir" data-name="isDir">
               <h3>
                  isDir 
                  <span class="badge">function</span>
                  
                  <a href="#isDir" class="anchor" title="Link to isDir">#</a>
               </h3>
               
               <pre><code class="language-go">func isDir(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTest" data-name="isTest">
               <h3>
                  isTest 
                  <span class="badge">function</span>
                  
                  <a href="#isTest" class="anchor" title="Link to isTest">#</a>
               </h3>
               
               <p>isTest tells whether name looks like a test (or benchmark, according to prefix).
It is a Test (say) if there is a character after Test that is not a lower-case letter.
We don't want TesticularCancer.</p>
               
               <pre><code class="language-go">func isTest(name string, prefix string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isTestFunc" data-name="isTestFunc">
               <h3>
                  isTestFunc 
                  <span class="badge">function</span>
                  
                  <a href="#isTestFunc" class="anchor" title="Link to isTestFunc">#</a>
               </h3>
               
               <p>isTestFunc tells whether fn has the type of a testing function. arg
specifies the parameter type we look for: B, F, M or T.</p>
               
               <pre><code class="language-go">func isTestFunc(fn *ast.FuncDecl, arg string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isVersionElement" data-name="isVersionElement">
               <h3>
                  isVersionElement 
                  <span class="badge">function</span>
                  
                  <a href="#isVersionElement" class="anchor" title="Link to isVersionElement">#</a>
               </h3>
               
               <p>isVersionElement reports whether s is a well-formed path version element:
v2, v3, v10, etc, but not v0, v05, v1.</p>
               
               <pre><code class="language-go">func isVersionElement(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="load" data-name="load">
               <h3>
                  load 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#load" class="anchor" title="Link to load">#</a>
               </h3>
               
               <pre><code class="language-go">func (t *testFuncs) load(filename string, pkg string, doImport *bool, seen *bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="load" data-name="load">
               <h3>
                  load 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#load" class="anchor" title="Link to load">#</a>
               </h3>
               
               <p>load populates p using information from bp, err, which should
be the result of calling build.Context.Import.
stk contains the import stack, not including path itself.</p>
               
               <pre><code class="language-go">func (p *Package) load(ctx context.Context, opts PackageOpts, path string, stk *ImportStack, importPos []token.Position, bp *build.Package, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadImport" data-name="loadImport">
               <h3>
                  loadImport 
                  <span class="badge">function</span>
                  
                  <a href="#loadImport" class="anchor" title="Link to loadImport">#</a>
               </h3>
               
               <p>loadImport scans the directory named by path, which must be an import path,
but possibly a local import path (an absolute file system path or one beginning
with ./ or ../). A local relative path is interpreted relative to srcDir.
It returns a *Package describing the package found in that directory.
loadImport does not set tool flags and should only be used by
this package, as part of a bigger load operation.
The returned PackageError, if any, describes why parent is not allowed
to import the named package, with the error referring to importPos.
The PackageError can only be non-nil when parent is not nil.</p>
               
               <pre><code class="language-go">func loadImport(ctx context.Context, opts PackageOpts, pre *preload, path string, srcDir string, parent *Package, stk *ImportStack, importPos []token.Position, mode int) (*Package, *PackageError)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadPackageData" data-name="loadPackageData">
               <h3>
                  loadPackageData 
                  <span class="badge">function</span>
                  
                  <a href="#loadPackageData" class="anchor" title="Link to loadPackageData">#</a>
               </h3>
               
               <p>loadPackageData loads information needed to construct a *Package. The result
is cached, and later calls to loadPackageData for the same package will return
the same data.
loadPackageData returns a non-nil package even if err is non-nil unless
the package path is malformed (for example, the path contains "mod/" or "@").
loadPackageData returns a boolean, loaded, which is true if this is the
first time the package was loaded. Callers may preload imports in this case.</p>
               
               <pre><code class="language-go">func loadPackageData(ctx context.Context, path string, parentPath string, parentDir string, parentRoot string, parentIsStd bool, mode int) (bp *build.Package, loaded bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadTestFuncs" data-name="loadTestFuncs">
               <h3>
                  loadTestFuncs 
                  <span class="badge">function</span>
                  
                  <a href="#loadTestFuncs" class="anchor" title="Link to loadTestFuncs">#</a>
               </h3>
               
               <p>loadTestFuncs returns the testFuncs describing the tests that will be run.
The returned testFuncs is always non-nil, even if an error occurred while
processing test files.</p>
               
               <pre><code class="language-go">func loadTestFuncs(ptest *Package) (*testFuncs, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mainPackagesOnly" data-name="mainPackagesOnly">
               <h3>
                  mainPackagesOnly 
                  <span class="badge">function</span>
                  
                  <a href="#mainPackagesOnly" class="anchor" title="Link to mainPackagesOnly">#</a>
               </h3>
               
               <p>mainPackagesOnly filters out non-main packages matched only by arguments
containing "..." and returns the remaining main packages.
Packages with missing, invalid, or ambiguous names may be treated as
possibly-main packages.
mainPackagesOnly sets a non-main package's Error field and returns it if it
is named by a literal argument.
mainPackagesOnly prints warnings for non-literal arguments that only match
non-main packages.</p>
               
               <pre><code class="language-go">func mainPackagesOnly(pkgs []*Package, matches []*search.Match) []*Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeImportValid" data-name="makeImportValid">
               <h3>
                  makeImportValid 
                  <span class="badge">function</span>
                  
                  <a href="#makeImportValid" class="anchor" title="Link to makeImportValid">#</a>
               </h3>
               
               <pre><code class="language-go">func makeImportValid(r rune) rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mkAbs" data-name="mkAbs">
               <h3>
                  mkAbs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mkAbs" class="anchor" title="Link to mkAbs">#</a>
               </h3>
               
               <p>mkAbs rewrites list, which must be paths relative to p.Dir,
into a sorted list of absolute paths. It edits list in place but for
convenience also returns list back to its caller.</p>
               
               <pre><code class="language-go">func (p *Package) mkAbs(list []string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="moduleImportPath" data-name="moduleImportPath">
               <h3>
                  moduleImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#moduleImportPath" class="anchor" title="Link to moduleImportPath">#</a>
               </h3>
               
               <p>moduleImportPath translates import paths found in go modules
back down to paths that can be resolved in ordinary builds.
Define “new” code as code with a go.mod file in the same directory
or a parent directory. If an import in new code says x/y/v2/z but
x/y/v2/z does not exist and x/y/go.mod says “module x/y/v2”,
then go build will read the import as x/y/z instead.
See golang.org/issue/25069.</p>
               
               <pre><code class="language-go">func moduleImportPath(path string, parentPath string, parentDir string, parentRoot string) (found string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newPreload" data-name="newPreload">
               <h3>
                  newPreload 
                  <span class="badge">function</span>
                  
                  <a href="#newPreload" class="anchor" title="Link to newPreload">#</a>
               </h3>
               
               <p>newPreload creates a new preloader. flush must be called later to avoid
accessing global state while it is being modified.</p>
               
               <pre><code class="language-go">func newPreload() *preload</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="preloadImports" data-name="preloadImports">
               <h3>
                  preloadImports 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#preloadImports" class="anchor" title="Link to preloadImports">#</a>
               </h3>
               
               <p>preloadImports queues a list of imports for preloading.
When preloadImports returns, some packages may not be loaded yet,
but loadPackageData and loadImport are always safe to call.</p>
               
               <pre><code class="language-go">func (pre *preload) preloadImports(ctx context.Context, opts PackageOpts, imports []string, parent *build.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="preloadMatches" data-name="preloadMatches">
               <h3>
                  preloadMatches 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#preloadMatches" class="anchor" title="Link to preloadMatches">#</a>
               </h3>
               
               <p>preloadMatches loads data for package paths matched by patterns.
When preloadMatches returns, some packages may not be loaded yet, but
loadPackageData and loadImport are always safe to call.</p>
               
               <pre><code class="language-go">func (pre *preload) preloadMatches(ctx context.Context, opts PackageOpts, matches []*search.Match)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recompileForTest" data-name="recompileForTest">
               <h3>
                  recompileForTest 
                  <span class="badge">function</span>
                  
                  <a href="#recompileForTest" class="anchor" title="Link to recompileForTest">#</a>
               </h3>
               
               <p>recompileForTest copies and replaces certain packages in pmain's dependency
graph. This is necessary for two reasons. First, if ptest is different than
preal, packages that import the package under test should get ptest instead
of preal. This is particularly important if pxtest depends on functionality
exposed in test sources in ptest. Second, if there is a main package
(other than pmain) anywhere, we need to set p.Internal.ForceLibrary and
clear p.Internal.BuildInfo in the test copy to prevent link conflicts.
This may happen if both -coverpkg and the command line patterns include
multiple main packages.</p>
               
               <pre><code class="language-go">func recompileForTest(pmain *Package, preal *Package, ptest *Package, pxtest *Package) *PackageError</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveEmbed" data-name="resolveEmbed">
               <h3>
                  resolveEmbed 
                  <span class="badge">function</span>
                  
                  <a href="#resolveEmbed" class="anchor" title="Link to resolveEmbed">#</a>
               </h3>
               
               <p>resolveEmbed resolves //go:embed patterns to precise file lists.
It sets files to the list of unique files matched (for go list),
and it sets pmap to the more precise mapping from
patterns to files.</p>
               
               <pre><code class="language-go">func resolveEmbed(pkgdir string, patterns []string) (files []string, pmap map[string][]string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="resolveImportPath" data-name="resolveImportPath">
               <h3>
                  resolveImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#resolveImportPath" class="anchor" title="Link to resolveImportPath">#</a>
               </h3>
               
               <pre><code class="language-go">func resolveImportPath(path string, parentPath string, parentDir string, parentRoot string, parentIsStd bool) (found string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reusePackage" data-name="reusePackage">
               <h3>
                  reusePackage 
                  <span class="badge">function</span>
                  
                  <a href="#reusePackage" class="anchor" title="Link to reusePackage">#</a>
               </h3>
               
               <p>reusePackage reuses package p to satisfy the import at the top
of the import stack stk. If this use causes an import loop,
reusePackage updates p's error information to record the loop.</p>
               
               <pre><code class="language-go">func reusePackage(p *Package, stk *ImportStack) *Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="set" data-name="set">
               <h3>
                  set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#set" class="anchor" title="Link to set">#</a>
               </h3>
               
               <p>set is the implementation of Set, taking a cwd (current working directory) for easier testing.</p>
               
               <pre><code class="language-go">func (f *PerPackageFlag) set(v string, cwd string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setBuildInfo" data-name="setBuildInfo">
               <h3>
                  setBuildInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setBuildInfo" class="anchor" title="Link to setBuildInfo">#</a>
               </h3>
               
               <p>setBuildInfo gathers build information and sets it into
p.Internal.BuildInfo, which will later be formatted as a string and embedded
in the binary. setBuildInfo should only be called on a main package with no
errors.
This information can be retrieved using debug.ReadBuildInfo.
Note that the GoVersion field is not set here to avoid encoding it twice.
It is stored separately in the binary, mostly for historical reasons.</p>
               
               <pre><code class="language-go">func (p *Package) setBuildInfo(ctx context.Context, autoVCS bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setLoadPackageDataError" data-name="setLoadPackageDataError">
               <h3>
                  setLoadPackageDataError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setLoadPackageDataError" class="anchor" title="Link to setLoadPackageDataError">#</a>
               </h3>
               
               <p>setLoadPackageDataError presents an error found when loading package data
as a *PackageError. It has special cases for some common errors to improve
messages shown to users and reduce redundancy.
setLoadPackageDataError returns true if it's safe to load information about
imported packages, for example, if there was a parse error loading imports
in one file, but other files are okay.</p>
               
               <pre><code class="language-go">func (p *Package) setLoadPackageDataError(err error, path string, stk *ImportStack, importPos []token.Position)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setPGOProfilePath" data-name="setPGOProfilePath">
               <h3>
                  setPGOProfilePath 
                  <span class="badge">function</span>
                  
                  <a href="#setPGOProfilePath" class="anchor" title="Link to setPGOProfilePath">#</a>
               </h3>
               
               <p>setPGOProfilePath sets the PGO profile path for pkgs.
In -pgo=auto mode, it finds the default PGO profile.</p>
               
               <pre><code class="language-go">func setPGOProfilePath(pkgs []*Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setPos" data-name="setPos">
               <h3>
                  setPos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setPos" class="anchor" title="Link to setPos">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *PackageError) setPos(posList []token.Position)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setToolFlags" data-name="setToolFlags">
               <h3>
                  setToolFlags 
                  <span class="badge">function</span>
                  
                  <a href="#setToolFlags" class="anchor" title="Link to setToolFlags">#</a>
               </h3>
               
               <pre><code class="language-go">func setToolFlags(pkgs ...*Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shorterThan" data-name="shorterThan">
               <h3>
                  shorterThan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#shorterThan" class="anchor" title="Link to shorterThan">#</a>
               </h3>
               
               <p>shorterThan reports whether sp is shorter than t.
We use this to record the shortest import sequence
that leads to a particular package.</p>
               
               <pre><code class="language-go">func (sp *ImportStack) shorterThan(t []string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="validEmbedPattern" data-name="validEmbedPattern">
               <h3>
                  validEmbedPattern 
                  <span class="badge">function</span>
                  
                  <a href="#validEmbedPattern" class="anchor" title="Link to validEmbedPattern">#</a>
               </h3>
               
               <pre><code class="language-go">func validEmbedPattern(pattern string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="vendoredImportPath" data-name="vendoredImportPath">
               <h3>
                  vendoredImportPath 
                  <span class="badge">function</span>
                  
                  <a href="#vendoredImportPath" class="anchor" title="Link to vendoredImportPath">#</a>
               </h3>
               
               <p>vendoredImportPath returns the vendor-expansion of path when it appears in parent.
If parent is x/y/z, then path might expand to x/y/z/vendor/path, x/y/vendor/path,
x/vendor/path, vendor/path, or else stay path if none of those exist.
vendoredImportPath returns the expanded path or, if no expansion is found, the original.</p>
               
               <pre><code class="language-go">func vendoredImportPath(path string, parentPath string, parentDir string, parentRoot string) (found string)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>