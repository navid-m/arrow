<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - base32</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>base32</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"io"
"slices"
"strconv"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="HexEncoding" data-name="HexEncoding">
               <h3>
                  HexEncoding 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#HexEncoding" class="anchor" title="Link to HexEncoding">#</a>
               </h3>
               
               <p>HexEncoding is the “Extended Hex Alphabet” defined in RFC 4648.
It is typically used in DNS.</p>
               
               <pre><code class="language-go">var HexEncoding = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NoPadding" data-name="NoPadding">
               <h3>
                  NoPadding 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NoPadding" class="anchor" title="Link to NoPadding">#</a>
               </h3>
               
               <pre><code class="language-go">const NoPadding rune = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StdEncoding" data-name="StdEncoding">
               <h3>
                  StdEncoding 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#StdEncoding" class="anchor" title="Link to StdEncoding">#</a>
               </h3>
               
               <p>StdEncoding is the standard base32 encoding, as defined in RFC 4648.</p>
               
               <pre><code class="language-go">var StdEncoding = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="StdPadding" data-name="StdPadding">
               <h3>
                  StdPadding 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#StdPadding" class="anchor" title="Link to StdPadding">#</a>
               </h3>
               
               <pre><code class="language-go">const StdPadding rune = '='</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="decodeMapInitialize" data-name="decodeMapInitialize">
               <h3>
                  decodeMapInitialize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#decodeMapInitialize" class="anchor" title="Link to decodeMapInitialize">#</a>
               </h3>
               
               <pre><code class="language-go">const decodeMapInitialize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="invalidIndex" data-name="invalidIndex">
               <h3>
                  invalidIndex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#invalidIndex" class="anchor" title="Link to invalidIndex">#</a>
               </h3>
               
               <pre><code class="language-go">const invalidIndex = '\xff'</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="CorruptInputError" data-name="CorruptInputError">
               <h3>
                  CorruptInputError
                  <span class="badge type-badge">type</span>
                  <a href="#CorruptInputError" class="anchor" title="Link to CorruptInputError">#</a>
               </h3>
               
               <pre><code class="language-go">type CorruptInputError int64</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Encoding" data-name="Encoding">
               <h3>
                  Encoding
                  <span class="badge">struct</span>
                  <a href="#Encoding" class="anchor" title="Link to Encoding">#</a>
               </h3>
               
               <p>An Encoding is a radix 32 encoding/decoding scheme, defined by a
32-character alphabet. The most common is the "base32" encoding
introduced for SASL GSSAPI and standardized in RFC 4648.
The alternate "base32hex" encoding is used in DNSSEC.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Encoding struct {
encode [32]byte
decodeMap [256]uint8
padChar rune
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="decoder" data-name="decoder">
               <h3>
                  decoder
                  <span class="badge">struct</span>
                  <a href="#decoder" class="anchor" title="Link to decoder">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type decoder struct {
err error
enc *Encoding
r io.Reader
end bool
buf [1024]byte
nbuf int
out []byte
outbuf [*ast.BinaryExpr]byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="encoder" data-name="encoder">
               <h3>
                  encoder
                  <span class="badge">struct</span>
                  <a href="#encoder" class="anchor" title="Link to encoder">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type encoder struct {
err error
enc *Encoding
w io.Writer
buf [5]byte
nbuf int
out [1024]byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="newlineFilteringReader" data-name="newlineFilteringReader">
               <h3>
                  newlineFilteringReader
                  <span class="badge">struct</span>
                  <a href="#newlineFilteringReader" class="anchor" title="Link to newlineFilteringReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type newlineFilteringReader struct {
wrapped io.Reader
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AppendDecode" data-name="AppendDecode">
               <h3>
                  AppendDecode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendDecode" class="anchor" title="Link to AppendDecode">#</a>
               </h3>
               
               <p>AppendDecode appends the base32 decoded src to dst
and returns the extended buffer.
If the input is malformed, it returns the partially decoded src and an error.
New line characters (\r and \n) are ignored.</p>
               
               <pre><code class="language-go">func (enc *Encoding) AppendDecode(dst []byte, src []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AppendEncode" data-name="AppendEncode">
               <h3>
                  AppendEncode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AppendEncode" class="anchor" title="Link to AppendEncode">#</a>
               </h3>
               
               <p>AppendEncode appends the base32 encoded src to dst
and returns the extended buffer.</p>
               
               <pre><code class="language-go">func (enc *Encoding) AppendEncode(dst []byte, src []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close flushes any pending output from the encoder.
It is an error to call Write after calling Close.</p>
               
               <pre><code class="language-go">func (e *encoder) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Decode" data-name="Decode">
               <h3>
                  Decode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Decode" class="anchor" title="Link to Decode">#</a>
               </h3>
               
               <p>Decode decodes src using the encoding enc. It writes at most
[Encoding.DecodedLen](len(src)) bytes to dst and returns the number of bytes
written. The caller must ensure that dst is large enough to hold all
the decoded data. If src contains invalid base32 data, it will return the
number of bytes successfully written and [CorruptInputError].
Newline characters (\r and \n) are ignored.</p>
               
               <pre><code class="language-go">func (enc *Encoding) Decode(dst []byte, src []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DecodeString" data-name="DecodeString">
               <h3>
                  DecodeString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DecodeString" class="anchor" title="Link to DecodeString">#</a>
               </h3>
               
               <p>DecodeString returns the bytes represented by the base32 string s.
If the input is malformed, it returns the partially decoded data and
[CorruptInputError]. New line characters (\r and \n) are ignored.</p>
               
               <pre><code class="language-go">func (enc *Encoding) DecodeString(s string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DecodedLen" data-name="DecodedLen">
               <h3>
                  DecodedLen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#DecodedLen" class="anchor" title="Link to DecodedLen">#</a>
               </h3>
               
               <p>DecodedLen returns the maximum length in bytes of the decoded data
corresponding to n bytes of base32-encoded data.</p>
               
               <pre><code class="language-go">func (enc *Encoding) DecodedLen(n int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Encode" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Encode" class="anchor" title="Link to Encode">#</a>
               </h3>
               
               <p>Encode encodes src using the encoding enc,
writing [Encoding.EncodedLen](len(src)) bytes to dst.
The encoding pads the output to a multiple of 8 bytes,
so Encode is not appropriate for use on individual blocks
of a large data stream. Use [NewEncoder] instead.</p>
               
               <pre><code class="language-go">func (enc *Encoding) Encode(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EncodeToString" data-name="EncodeToString">
               <h3>
                  EncodeToString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EncodeToString" class="anchor" title="Link to EncodeToString">#</a>
               </h3>
               
               <p>EncodeToString returns the base32 encoding of src.</p>
               
               <pre><code class="language-go">func (enc *Encoding) EncodeToString(src []byte) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="EncodedLen" data-name="EncodedLen">
               <h3>
                  EncodedLen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#EncodedLen" class="anchor" title="Link to EncodedLen">#</a>
               </h3>
               
               <p>EncodedLen returns the length in bytes of the base32 encoding
of an input buffer of length n.</p>
               
               <pre><code class="language-go">func (enc *Encoding) EncodedLen(n int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e CorruptInputError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewDecoder" data-name="NewDecoder">
               <h3>
                  NewDecoder 
                  <span class="badge">function</span>
                  
                  <a href="#NewDecoder" class="anchor" title="Link to NewDecoder">#</a>
               </h3>
               
               <p>NewDecoder constructs a new base32 stream decoder.</p>
               
               <pre><code class="language-go">func NewDecoder(enc *Encoding, r io.Reader) io.Reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewEncoder" data-name="NewEncoder">
               <h3>
                  NewEncoder 
                  <span class="badge">function</span>
                  
                  <a href="#NewEncoder" class="anchor" title="Link to NewEncoder">#</a>
               </h3>
               
               <p>NewEncoder returns a new base32 stream encoder. Data written to
the returned writer will be encoded using enc and then written to w.
Base32 encodings operate in 5-byte blocks; when finished
writing, the caller must Close the returned encoder to flush any
partially written blocks.</p>
               
               <pre><code class="language-go">func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewEncoding" data-name="NewEncoding">
               <h3>
                  NewEncoding 
                  <span class="badge">function</span>
                  
                  <a href="#NewEncoding" class="anchor" title="Link to NewEncoding">#</a>
               </h3>
               
               <p>NewEncoding returns a new padded Encoding defined by the given alphabet,
which must be a 32-byte string that contains unique byte values and
does not contain the padding character or CR / LF ('\r', '\n').
The alphabet is treated as a sequence of byte values
without any special treatment for multi-byte UTF-8.
The resulting Encoding uses the default padding character ('='),
which may be changed or disabled via [Encoding.WithPadding].</p>
               
               <pre><code class="language-go">func NewEncoding(encoder string) *Encoding</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code class="language-go">func (r *newlineFilteringReader) Read(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code class="language-go">func (d *decoder) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WithPadding" data-name="WithPadding">
               <h3>
                  WithPadding 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WithPadding" class="anchor" title="Link to WithPadding">#</a>
               </h3>
               
               <p>WithPadding creates a new encoding identical to enc except
with a specified padding character, or NoPadding to disable padding.
The padding character must not be '\r' or '\n',
must not be contained in the encoding's alphabet,
must not be negative, and must be a rune equal or below '\xff'.
Padding characters above '\x7f' are encoded as their exact byte value
rather than using the UTF-8 representation of the codepoint.</p>
               
               <pre><code class="language-go">func (enc Encoding) WithPadding(padding rune) *Encoding</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code class="language-go">func (e *encoder) Write(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decode" data-name="decode">
               <h3>
                  decode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#decode" class="anchor" title="Link to decode">#</a>
               </h3>
               
               <p>decode is like Decode but returns an additional 'end' value, which
indicates if end-of-message padding was encountered and thus any
additional data is an error. This method assumes that src has been
stripped of all supported whitespace ('\r' and '\n').</p>
               
               <pre><code class="language-go">func (enc *Encoding) decode(dst []byte, src []byte) (n int, end bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decodedLen" data-name="decodedLen">
               <h3>
                  decodedLen 
                  <span class="badge">function</span>
                  
                  <a href="#decodedLen" class="anchor" title="Link to decodedLen">#</a>
               </h3>
               
               <pre><code class="language-go">func decodedLen(n int, padChar rune) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readEncodedData" data-name="readEncodedData">
               <h3>
                  readEncodedData 
                  <span class="badge">function</span>
                  
                  <a href="#readEncodedData" class="anchor" title="Link to readEncodedData">#</a>
               </h3>
               
               <pre><code class="language-go">func readEncodedData(r io.Reader, buf []byte, min int, expectsPadding bool) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stripNewlines" data-name="stripNewlines">
               <h3>
                  stripNewlines 
                  <span class="badge">function</span>
                  
                  <a href="#stripNewlines" class="anchor" title="Link to stripNewlines">#</a>
               </h3>
               
               <p>stripNewlines removes newline characters and returns the number
of non-newline characters copied to dst.</p>
               
               <pre><code class="language-go">func stripNewlines(dst []byte, src []byte) int</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();

               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);

               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;

               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               // Apply Prism highlighting again
               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>