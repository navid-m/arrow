<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - base32</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>base32</code>
         </h1>
         <hr />
         
         <article class="global" data-name="StdPadding">
            <h2>StdPadding</h2>
            <hr />
            
            <pre><code>StdPadding rune</code></pre>
         </article>
         
         <article class="global" data-name="NoPadding">
            <h2>NoPadding</h2>
            <hr />
            
            <pre><code>NoPadding rune</code></pre>
         </article>
         
         <article class="global" data-name="decodeMapInitialize">
            <h2>decodeMapInitialize</h2>
            <hr />
            
            <pre><code>decodeMapInitialize</code></pre>
         </article>
         
         <article class="global" data-name="invalidIndex">
            <h2>invalidIndex</h2>
            <hr />
            
            <pre><code>invalidIndex</code></pre>
         </article>
         
         <article class="global" data-name="StdEncoding">
            <h2>StdEncoding</h2>
            <hr />
            
            <p>StdEncoding is the standard base32 encoding, as defined in RFC 4648.</p>
            
            <pre><code>StdEncoding</code></pre>
         </article>
         
         <article class="global" data-name="HexEncoding">
            <h2>HexEncoding</h2>
            <hr />
            
            <p>HexEncoding is the “Extended Hex Alphabet” defined in RFC 4648.
It is typically used in DNS.</p>
            
            <pre><code>HexEncoding</code></pre>
         </article>
         
         <article class="global" data-name="pairs">
            <h2>pairs</h2>
            <hr />
            
            <pre><code>pairs</code></pre>
         </article>
         
         <article class="global" data-name="bigtest">
            <h2>bigtest</h2>
            <hr />
            
            <pre><code>bigtest</code></pre>
         </article>
          
         <article class="struct" data-name="Encoding">
            <h2>type Encoding struct</h2>
            <hr />
            
            <p>An Encoding is a radix 32 encoding/decoding scheme, defined by a
32-character alphabet. The most common is the "base32" encoding
introduced for SASL GSSAPI and standardized in RFC 4648.
The alternate "base32hex" encoding is used in DNSSEC.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">encode []byte
decodeMap []uint8
padChar rune</code></pre>
         </article>
         
         <article class="struct" data-name="encoder">
            <h2>type encoder struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">err error
enc *Encoding
w io.Writer
buf []byte
nbuf int
out []byte</code></pre>
         </article>
         
         <article class="struct" data-name="decoder">
            <h2>type decoder struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">err error
enc *Encoding
r io.Reader
end bool
buf []byte
nbuf int
out []byte
outbuf []byte</code></pre>
         </article>
         
         <article class="struct" data-name="newlineFilteringReader">
            <h2>type newlineFilteringReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">wrapped io.Reader</code></pre>
         </article>
         
         <article class="struct" data-name="testpair">
            <h2>type testpair struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">decoded string
encoded string</code></pre>
         </article>
         
         <article class="struct" data-name="badReader">
            <h2>type badReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">data []byte
errs []error
called int
limit int</code></pre>
         </article>
          
         <article class="function" data-name="NewEncoding">
            <h2>NewEncoding</h2>
            <hr />
            
            <p>NewEncoding returns a new padded Encoding defined by the given alphabet,
which must be a 32-byte string that contains unique byte values and
does not contain the padding character or CR / LF ('\r', '\n').
The alphabet is treated as a sequence of byte values
without any special treatment for multi-byte UTF-8.
The resulting Encoding uses the default padding character ('='),
which may be changed or disabled via [Encoding.WithPadding].</p>
            
            <pre><code>func NewEncoding(encoder string) *Encoding</code></pre>
         </article>
         
         <article class="function" data-name="WithPadding">
            <h2>WithPadding</h2>
            <hr />
            
            <p>WithPadding creates a new encoding identical to enc except
with a specified padding character, or NoPadding to disable padding.
The padding character must not be '\r' or '\n',
must not be contained in the encoding's alphabet,
must not be negative, and must be a rune equal or below '\xff'.
Padding characters above '\x7f' are encoded as their exact byte value
rather than using the UTF-8 representation of the codepoint.</p>
            
            <pre><code>func WithPadding(padding rune) *Encoding</code></pre>
         </article>
         
         <article class="function" data-name="Encode">
            <h2>Encode</h2>
            <hr />
            
            <p>Encode encodes src using the encoding enc,
writing [Encoding.EncodedLen](len(src)) bytes to dst.

The encoding pads the output to a multiple of 8 bytes,
so Encode is not appropriate for use on individual blocks
of a large data stream. Use [NewEncoder] instead.</p>
            
            <pre><code>func Encode(dst []byte, src []byte)</code></pre>
         </article>
         
         <article class="function" data-name="AppendEncode">
            <h2>AppendEncode</h2>
            <hr />
            
            <p>AppendEncode appends the base32 encoded src to dst
and returns the extended buffer.</p>
            
            <pre><code>func AppendEncode(dst []byte, src []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="EncodeToString">
            <h2>EncodeToString</h2>
            <hr />
            
            <p>EncodeToString returns the base32 encoding of src.</p>
            
            <pre><code>func EncodeToString(src []byte) string</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close flushes any pending output from the encoder.
It is an error to call Write after calling Close.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="NewEncoder">
            <h2>NewEncoder</h2>
            <hr />
            
            <p>NewEncoder returns a new base32 stream encoder. Data written to
the returned writer will be encoded using enc and then written to w.
Base32 encodings operate in 5-byte blocks; when finished
writing, the caller must Close the returned encoder to flush any
partially written blocks.</p>
            
            <pre><code>func NewEncoder(enc *Encoding, w io.Writer) io.WriteCloser</code></pre>
         </article>
         
         <article class="function" data-name="EncodedLen">
            <h2>EncodedLen</h2>
            <hr />
            
            <p>EncodedLen returns the length in bytes of the base32 encoding
of an input buffer of length n.</p>
            
            <pre><code>func EncodedLen(n int) int</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="decode">
            <h2>decode</h2>
            <hr />
            
            <p>decode is like Decode but returns an additional 'end' value, which
indicates if end-of-message padding was encountered and thus any
additional data is an error. This method assumes that src has been
stripped of all supported whitespace ('\r' and '\n').</p>
            
            <pre><code>func decode(dst []byte, src []byte) (n int, end bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Decode">
            <h2>Decode</h2>
            <hr />
            
            <p>Decode decodes src using the encoding enc. It writes at most
[Encoding.DecodedLen](len(src)) bytes to dst and returns the number of bytes
written. The caller must ensure that dst is large enough to hold all
the decoded data. If src contains invalid base32 data, it will return the
number of bytes successfully written and [CorruptInputError].
Newline characters (\r and \n) are ignored.</p>
            
            <pre><code>func Decode(dst []byte, src []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="AppendDecode">
            <h2>AppendDecode</h2>
            <hr />
            
            <p>AppendDecode appends the base32 decoded src to dst
and returns the extended buffer.
If the input is malformed, it returns the partially decoded src and an error.
New line characters (\r and \n) are ignored.</p>
            
            <pre><code>func AppendDecode(dst []byte, src []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="DecodeString">
            <h2>DecodeString</h2>
            <hr />
            
            <p>DecodeString returns the bytes represented by the base32 string s.
If the input is malformed, it returns the partially decoded data and
[CorruptInputError]. New line characters (\r and \n) are ignored.</p>
            
            <pre><code>func DecodeString(s string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="readEncodedData">
            <h2>readEncodedData</h2>
            <hr />
            
            <pre><code>func readEncodedData(r io.Reader, buf []byte, min int, expectsPadding bool) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="stripNewlines">
            <h2>stripNewlines</h2>
            <hr />
            
            <p>stripNewlines removes newline characters and returns the number
of non-newline characters copied to dst.</p>
            
            <pre><code>func stripNewlines(dst []byte, src []byte) int</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewDecoder">
            <h2>NewDecoder</h2>
            <hr />
            
            <p>NewDecoder constructs a new base32 stream decoder.</p>
            
            <pre><code>func NewDecoder(enc *Encoding, r io.Reader) io.Reader</code></pre>
         </article>
         
         <article class="function" data-name="DecodedLen">
            <h2>DecodedLen</h2>
            <hr />
            
            <p>DecodedLen returns the maximum length in bytes of the decoded data
corresponding to n bytes of base32-encoded data.</p>
            
            <pre><code>func DecodedLen(n int) int</code></pre>
         </article>
         
         <article class="function" data-name="decodedLen">
            <h2>decodedLen</h2>
            <hr />
            
            <pre><code>func decodedLen(n int, padChar rune) int</code></pre>
         </article>
         
         <article class="function" data-name="testEqual">
            <h2>testEqual</h2>
            <hr />
            
            <pre><code>func testEqual(t *testing.T, msg string, args ...any) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestEncode">
            <h2>TestEncode</h2>
            <hr />
            
            <pre><code>func TestEncode(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEncoder">
            <h2>TestEncoder</h2>
            <hr />
            
            <pre><code>func TestEncoder(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEncoderBuffering">
            <h2>TestEncoderBuffering</h2>
            <hr />
            
            <pre><code>func TestEncoderBuffering(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecoderBufferingWithPadding">
            <h2>TestDecoderBufferingWithPadding</h2>
            <hr />
            
            <pre><code>func TestDecoderBufferingWithPadding(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecoderBufferingWithoutPadding">
            <h2>TestDecoderBufferingWithoutPadding</h2>
            <hr />
            
            <pre><code>func TestDecoderBufferingWithoutPadding(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecode">
            <h2>TestDecode</h2>
            <hr />
            
            <pre><code>func TestDecode(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecoder">
            <h2>TestDecoder</h2>
            <hr />
            
            <pre><code>func TestDecoder(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <p>Populates p with data, returns a count of the bytes written and an
error.  The error returned is taken from badReader.errs, with each
invocation of Read returning the next error in this slice, or io.EOF,
if all errors from the slice have already been returned.  The
number of bytes returned is determined by the size of the input buffer
the test passes to decoder.Read and will be a multiple of 8, unless
badReader.limit is non zero.</p>
            
            <pre><code>func Read(p []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue20044">
            <h2>TestIssue20044</h2>
            <hr />
            
            <p>TestIssue20044 tests that decoder.Read behaves correctly when the caller
supplied reader returns an error.</p>
            
            <pre><code>func TestIssue20044(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecoderError">
            <h2>TestDecoderError</h2>
            <hr />
            
            <p>TestDecoderError verifies decode errors are propagated when there are no read
errors.</p>
            
            <pre><code>func TestDecoderError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestReaderEOF">
            <h2>TestReaderEOF</h2>
            <hr />
            
            <p>TestReaderEOF ensures decoder.Read behaves correctly when input data is
exhausted.</p>
            
            <pre><code>func TestReaderEOF(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecoderBuffering">
            <h2>TestDecoderBuffering</h2>
            <hr />
            
            <pre><code>func TestDecoderBuffering(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecodeCorrupt">
            <h2>TestDecodeCorrupt</h2>
            <hr />
            
            <pre><code>func TestDecodeCorrupt(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBig">
            <h2>TestBig</h2>
            <hr />
            
            <pre><code>func TestBig(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testStringEncoding">
            <h2>testStringEncoding</h2>
            <hr />
            
            <pre><code>func testStringEncoding(t *testing.T, expected string, examples []string)</code></pre>
         </article>
         
         <article class="function" data-name="TestNewLineCharacters">
            <h2>TestNewLineCharacters</h2>
            <hr />
            
            <pre><code>func TestNewLineCharacters(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecoderIssue4779">
            <h2>TestDecoderIssue4779</h2>
            <hr />
            
            <pre><code>func TestDecoderIssue4779(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEncode">
            <h2>BenchmarkEncode</h2>
            <hr />
            
            <pre><code>func BenchmarkEncode(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEncodeToString">
            <h2>BenchmarkEncodeToString</h2>
            <hr />
            
            <pre><code>func BenchmarkEncodeToString(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecode">
            <h2>BenchmarkDecode</h2>
            <hr />
            
            <pre><code>func BenchmarkDecode(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecodeString">
            <h2>BenchmarkDecodeString</h2>
            <hr />
            
            <pre><code>func BenchmarkDecodeString(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestWithCustomPadding">
            <h2>TestWithCustomPadding</h2>
            <hr />
            
            <pre><code>func TestWithCustomPadding(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWithoutPadding">
            <h2>TestWithoutPadding</h2>
            <hr />
            
            <pre><code>func TestWithoutPadding(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecodeWithPadding">
            <h2>TestDecodeWithPadding</h2>
            <hr />
            
            <pre><code>func TestDecodeWithPadding(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecodeWithWrongPadding">
            <h2>TestDecodeWithWrongPadding</h2>
            <hr />
            
            <pre><code>func TestDecodeWithWrongPadding(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBufferedDecodingSameError">
            <h2>TestBufferedDecodingSameError</h2>
            <hr />
            
            <pre><code>func TestBufferedDecodingSameError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBufferedDecodingPadding">
            <h2>TestBufferedDecodingPadding</h2>
            <hr />
            
            <pre><code>func TestBufferedDecodingPadding(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEncodedLen">
            <h2>TestEncodedLen</h2>
            <hr />
            
            <pre><code>func TestEncodedLen(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecodedLen">
            <h2>TestDecodedLen</h2>
            <hr />
            
            <pre><code>func TestDecodedLen(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWithoutPaddingClose">
            <h2>TestWithoutPaddingClose</h2>
            <hr />
            
            <pre><code>func TestWithoutPaddingClose(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecodeReadAll">
            <h2>TestDecodeReadAll</h2>
            <hr />
            
            <pre><code>func TestDecodeReadAll(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecodeSmallBuffer">
            <h2>TestDecodeSmallBuffer</h2>
            <hr />
            
            <pre><code>func TestDecodeSmallBuffer(t *testing.T)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
