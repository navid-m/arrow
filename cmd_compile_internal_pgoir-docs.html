<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - pgoir</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>pgoir</code>
         </h1>
         <hr />
         
         <article class="global" data-name="LookupFunc">
            <h2>LookupFunc</h2>
            <hr />
            
            <p>LookupFunc looks up a function or method in export data. It is expected to
be overridden by package noder, to break a dependency cycle.</p>
            
            <pre><code>LookupFunc</code></pre>
         </article>
         
         <article class="global" data-name="PostLookupCleanup">
            <h2>PostLookupCleanup</h2>
            <hr />
            
            <p>PostLookupCleanup performs any remaining cleanup operations needed
after a series of calls to LookupFunc, specifically reading in the
bodies of functions that may have been delayed due being encountered
in a stage where the reader's curfn state was not set up.</p>
            
            <pre><code>PostLookupCleanup</code></pre>
         </article>
          
         <article class="struct" data-name="IRGraph">
            <h2>type IRGraph struct</h2>
            <hr />
            
            <p>IRGraph is a call graph with nodes pointing to IRs of functions and edges
carrying weights and callsite information.

Nodes for indirect calls may have missing IR (IRNode.AST == nil) if the node
is not visible from this package (e.g., not in the transitive deps). Keeping
these nodes allows determining the hottest edge from a call even if that
callee is not available.

TODO(prattmic): Consider merging this data structure with Graph. This is
effectively a copy of Graph aggregated to line number and pointing to IR.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">IRNodes *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="IRNode">
            <h2>type IRNode struct</h2>
            <hr />
            
            <p>IRNode represents a node (function) in the IRGraph.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">AST *ir.Func
LinkerSymbolName string
OutEdges *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="IREdge">
            <h2>type IREdge struct</h2>
            <hr />
            
            <p>IREdge represents a call edge in the IRGraph with source, destination,
weight, callsite, and line number information.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Src *IRNode
Dst *IRNode
Weight int64
CallSiteOffset int</code></pre>
         </article>
         
         <article class="struct" data-name="CallSiteInfo">
            <h2>type CallSiteInfo struct</h2>
            <hr />
            
            <p>CallSiteInfo captures call-site information and its caller/callee.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">LineOffset int
Caller *ir.Func
Callee *ir.Func</code></pre>
         </article>
         
         <article class="struct" data-name="Profile">
            <h2>type Profile struct</h2>
            <hr />
            
            <p>Profile contains the processed PGO profile and weighted call graph used for
PGO optimizations.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*pgo.Profile
WeightedCG *IRGraph</code></pre>
         </article>
          
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <p>Name returns the symbol name of this function.</p>
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="New">
            <h2>New</h2>
            <hr />
            
            <p>New generates a profile-graph from the profile or pre-processed profile.</p>
            
            <pre><code>func New(profileFile string) (*Profile, error)</code></pre>
         </article>
         
         <article class="function" data-name="createIRGraph">
            <h2>createIRGraph</h2>
            <hr />
            
            <p>initializeIRGraph builds the IRGraph by visiting all the ir.Func in decl list
of a package.</p>
            
            <pre><code>func createIRGraph(namedEdgeMap pgo.NamedEdgeMap) *IRGraph</code></pre>
         </article>
         
         <article class="function" data-name="visitIR">
            <h2>visitIR</h2>
            <hr />
            
            <p>visitIR traverses the body of each ir.Func adds edges to g from ir.Func to
any called function in the body.</p>
            
            <pre><code>func visitIR(fn *ir.Func, namedEdgeMap pgo.NamedEdgeMap, g *IRGraph)</code></pre>
         </article>
         
         <article class="function" data-name="createIRGraphEdge">
            <h2>createIRGraphEdge</h2>
            <hr />
            
            <p>createIRGraphEdge traverses the nodes in the body of ir.Func and adds edges
between the callernode which points to the ir.Func and the nodes in the
body.</p>
            
            <pre><code>func createIRGraphEdge(fn *ir.Func, callernode *IRNode, name string, namedEdgeMap pgo.NamedEdgeMap, g *IRGraph)</code></pre>
         </article>
         
         <article class="function" data-name="NodeLineOffset">
            <h2>NodeLineOffset</h2>
            <hr />
            
            <p>NodeLineOffset returns the line offset of n in fn.</p>
            
            <pre><code>func NodeLineOffset(n ir.Node, fn *ir.Func) int</code></pre>
         </article>
         
         <article class="function" data-name="addIREdge">
            <h2>addIREdge</h2>
            <hr />
            
            <p>addIREdge adds an edge between caller and new node that points to `callee`
based on the profile-graph and NodeMap.</p>
            
            <pre><code>func addIREdge(callerNode *IRNode, callerName string, call ir.Node, callee *ir.Func, namedEdgeMap pgo.NamedEdgeMap, g *IRGraph)</code></pre>
         </article>
         
         <article class="function" data-name="addIndirectEdges">
            <h2>addIndirectEdges</h2>
            <hr />
            
            <p>addIndirectEdges adds indirect call edges found in the profile to the graph,
to be used for devirtualization.

N.B. despite the name, addIndirectEdges will add any edges discovered via
the profile. We don't know for sure that they are indirect, but assume they
are since direct calls would already be added. (e.g., direct calls that have
been deleted from source since the profile was taken would be added here).

TODO(prattmic): Devirtualization runs before inlining, so we can't devirtualize
calls inside inlined call bodies. If we did add that, we'd need edges from
inlined bodies as well.</p>
            
            <pre><code>func addIndirectEdges(g *IRGraph, namedEdgeMap pgo.NamedEdgeMap)</code></pre>
         </article>
         
         <article class="function" data-name="PrintWeightedCallGraphDOT">
            <h2>PrintWeightedCallGraphDOT</h2>
            <hr />
            
            <p>PrintWeightedCallGraphDOT prints IRGraph in DOT format.</p>
            
            <pre><code>func PrintWeightedCallGraphDOT(edgeThreshold float64)</code></pre>
         </article>
         
         <article class="function" data-name="DirectCallee">
            <h2>DirectCallee</h2>
            <hr />
            
            <p>DirectCallee takes a function-typed expression and returns the underlying
function that it refers to if statically known. Otherwise, it returns nil.

Equivalent to inline.inlCallee without calling CanInline on closures.</p>
            
            <pre><code>func DirectCallee(fn ir.Node) *ir.Func</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
