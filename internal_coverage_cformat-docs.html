<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - cformat</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>cformat</code>
         </h1>
         <hr />
          
         <article class="struct" data-name="Formatter">
            <h2>type Formatter struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pm *ast.MapType
pkg string
p *pstate
cm coverage.CounterMode</code></pre>
         </article>
         
         <article class="struct" data-name="pstate">
            <h2>type pstate struct</h2>
            <hr />
            
            <p>pstate records package-level coverage data state:
- a table of functions (file/fname/literal)
- a map recording the index/ID of each func encountered so far
- a table storing execution count for the coverable units in each func</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">funcs []fnfile
funcTable *ast.MapType
unitTable *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="extcu">
            <h2>type extcu struct</h2>
            <hr />
            
            <p>extcu encapsulates a coverable unit within some function.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">fnfid uint32
coverage.CoverableUnit</code></pre>
         </article>
         
         <article class="struct" data-name="fnfile">
            <h2>type fnfile struct</h2>
            <hr />
            
            <p>fnfile is a function-name/file-name tuple.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">file string
fname string
lit bool</code></pre>
         </article>
          
         <article class="function" data-name="NewFormatter">
            <h2>NewFormatter</h2>
            <hr />
            
            <pre><code>func NewFormatter(cm coverage.CounterMode) *Formatter</code></pre>
         </article>
         
         <article class="function" data-name="SetPackage">
            <h2>SetPackage</h2>
            <hr />
            
            <p>SetPackage tells the formatter that we're about to visit the
coverage data for the package with the specified import path.
Note that it's OK to call SetPackage more than once with the
same import path; counter data values will be accumulated.</p>
            
            <pre><code>func SetPackage(importpath string)</code></pre>
         </article>
         
         <article class="function" data-name="AddUnit">
            <h2>AddUnit</h2>
            <hr />
            
            <p>AddUnit passes info on a single coverable unit (file, funcname,
literal flag, range of lines, and counter value) to the formatter.
Counter values will be accumulated where appropriate.</p>
            
            <pre><code>func AddUnit(file string, fname string, isfnlit bool, unit coverage.CoverableUnit, count uint32)</code></pre>
         </article>
         
         <article class="function" data-name="sortUnits">
            <h2>sortUnits</h2>
            <hr />
            
            <p>sortUnits sorts a slice of extcu objects in a package according to
source position information (e.g. file and line). Note that we don't
include function name as part of the sorting criteria, the thinking
being that is better to provide things in the original source order.</p>
            
            <pre><code>func sortUnits(units []extcu)</code></pre>
         </article>
         
         <article class="function" data-name="EmitTextual">
            <h2>EmitTextual</h2>
            <hr />
            
            <p>EmitTextual writes the accumulated coverage data for 'pkgs' in the legacy
cmd/cover text format to the writer 'w'; if pkgs is empty, text output
is emitted for all packages recorded.  We sort the data items by
importpath, source file, and line number before emitting (this sorting
is not explicitly mandated by the format, but seems like a good idea
for repeatable/deterministic dumps).</p>
            
            <pre><code>func EmitTextual(pkgs []string, w io.Writer) error</code></pre>
         </article>
         
         <article class="function" data-name="EmitPercent">
            <h2>EmitPercent</h2>
            <hr />
            
            <p>EmitPercent writes out a "percentage covered" string to the writer
'w', selecting the set of packages in 'pkgs' and suffixing the
printed string with 'inpkgs'.</p>
            
            <pre><code>func EmitPercent(w io.Writer, pkgs []string, inpkgs string, noteEmpty bool, aggregate bool) error</code></pre>
         </article>
         
         <article class="function" data-name="EmitFuncs">
            <h2>EmitFuncs</h2>
            <hr />
            
            <p>EmitFuncs writes out a function-level summary to the writer 'w'. A
note on handling function literals: although we collect coverage
data for unnamed literals, it probably does not make sense to
include them in the function summary since there isn't any good way
to name them (this is also consistent with the legacy cmd/cover
implementation). We do want to include their counts in the overall
summary however.</p>
            
            <pre><code>func EmitFuncs(w io.Writer) error</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
