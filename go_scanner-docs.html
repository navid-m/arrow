<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>scanner - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>scanner</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"go/token"
"io"
"sort"
"bytes"
"fmt"
"go/token"
"path/filepath"
"strconv"
"unicode"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ScanComments" data-name="ScanComments">
               <h3>
                  ScanComments 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ScanComments" class="anchor" title="Link to ScanComments">#</a>
               </h3>
               
               <pre><code class="language-go">const ScanComments Mode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bom" data-name="bom">
               <h3>
                  bom 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bom" class="anchor" title="Link to bom">#</a>
               </h3>
               
               <pre><code class="language-go">const bom = 0xFEFF</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dontInsertSemis" data-name="dontInsertSemis">
               <h3>
                  dontInsertSemis 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#dontInsertSemis" class="anchor" title="Link to dontInsertSemis">#</a>
               </h3>
               
               <pre><code class="language-go">const dontInsertSemis</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="eof" data-name="eof">
               <h3>
                  eof 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#eof" class="anchor" title="Link to eof">#</a>
               </h3>
               
               <pre><code class="language-go">const eof = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="prefix" data-name="prefix">
               <h3>
                  prefix 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#prefix" class="anchor" title="Link to prefix">#</a>
               </h3>
               
               <pre><code class="language-go">var prefix = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ErrorHandler" data-name="ErrorHandler">
               <h3>
                  ErrorHandler
                  <span class="badge type-badge">type</span>
                  <a href="#ErrorHandler" class="anchor" title="Link to ErrorHandler">#</a>
               </h3>
               
               <p>An ErrorHandler may be provided to [Scanner.Init]. If a syntax error is
encountered and a handler was installed, the handler is called with a
position and an error message. The position points to the beginning of
the offending token.</p>
               
               <pre><code class="language-go">type ErrorHandler func(pos token.Position, msg string)</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="ErrorList" data-name="ErrorList">
               <h3>
                  ErrorList
                  <span class="badge type-badge">type</span>
                  <a href="#ErrorList" class="anchor" title="Link to ErrorList">#</a>
               </h3>
               
               <p>ErrorList is a list of *Errors.
The zero value for an ErrorList is an empty ErrorList ready to use.</p>
               
               <pre><code class="language-go">type ErrorList []*Error</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="Mode" data-name="Mode">
               <h3>
                  Mode
                  <span class="badge type-badge">type</span>
                  <a href="#Mode" class="anchor" title="Link to Mode">#</a>
               </h3>
               
               <p>A mode value is a set of flags (or 0).
They control scanner behavior.</p>
               
               <pre><code class="language-go">type Mode uint</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error
                  <span class="badge">struct</span>
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>In an [ErrorList], an error is represented by an *Error.
The position Pos, if valid, points to the beginning of
the offending token, and the error condition is described
by Msg.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Error struct {
Pos token.Position
Msg string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Scanner" data-name="Scanner">
               <h3>
                  Scanner
                  <span class="badge">struct</span>
                  <a href="#Scanner" class="anchor" title="Link to Scanner">#</a>
               </h3>
               
               <p>A Scanner holds the scanner's internal state while processing
a given text. It can be allocated as part of another data
structure but must be initialized via [Scanner.Init] before use.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Scanner struct {
file *token.File
dir string
src []byte
err ErrorHandler
mode Mode
ch rune
offset int
rdOffset int
lineOffset int
insertSemi bool
nlPos token.Pos
ErrorCount int
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Add" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Add" class="anchor" title="Link to Add">#</a>
               </h3>
               
               <p>Add adds an [Error] with given position and error message to an [ErrorList].</p>
               
               <pre><code class="language-go">func (p *ErrorList) Add(pos token.Position, msg string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Err" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Err" class="anchor" title="Link to Err">#</a>
               </h3>
               
               <p>Err returns an error equivalent to this error list.
If the list is empty, Err returns nil.</p>
               
               <pre><code class="language-go">func (p ErrorList) Err() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>Error implements the error interface.</p>
               
               <pre><code class="language-go">func (e Error) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <p>An [ErrorList] implements the error interface.</p>
               
               <pre><code class="language-go">func (p ErrorList) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Init" data-name="Init">
               <h3>
                  Init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Init" class="anchor" title="Link to Init">#</a>
               </h3>
               
               <p>Init prepares the scanner s to tokenize the text src by setting the
scanner at the beginning of src. The scanner uses the file set file
for position information and it adds line information for each line.
It is ok to re-use the same file when re-scanning the same file as
line information which is already present is ignored. Init causes a
panic if the file size does not match the src size.
Calls to [Scanner.Scan] will invoke the error handler err if they encounter a
syntax error and err is not nil. Also, for each error encountered,
the [Scanner] field ErrorCount is incremented by one. The mode parameter
determines how comments are handled.
Note that Init may call err if there is an error in the first character
of the file.</p>
               
               <pre><code class="language-go">func (s *Scanner) Init(file *token.File, src []byte, err ErrorHandler, mode Mode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Len" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Len" class="anchor" title="Link to Len">#</a>
               </h3>
               
               <p>[ErrorList] implements the sort Interface.</p>
               
               <pre><code class="language-go">func (p ErrorList) Len() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Less" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Less" class="anchor" title="Link to Less">#</a>
               </h3>
               
               <pre><code class="language-go">func (p ErrorList) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PrintError" data-name="PrintError">
               <h3>
                  PrintError 
                  <span class="badge">function</span>
                  
                  <a href="#PrintError" class="anchor" title="Link to PrintError">#</a>
               </h3>
               
               <p>PrintError is a utility function that prints a list of errors to w,
one error per line, if the err parameter is an [ErrorList]. Otherwise
it prints the err string.</p>
               
               <pre><code class="language-go">func PrintError(w io.Writer, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RemoveMultiples" data-name="RemoveMultiples">
               <h3>
                  RemoveMultiples 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RemoveMultiples" class="anchor" title="Link to RemoveMultiples">#</a>
               </h3>
               
               <p>RemoveMultiples sorts an [ErrorList] and removes all but the first error per line.</p>
               
               <pre><code class="language-go">func (p *ErrorList) RemoveMultiples()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset resets an [ErrorList] to no errors.</p>
               
               <pre><code class="language-go">func (p *ErrorList) Reset()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Scan" data-name="Scan">
               <h3>
                  Scan 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Scan" class="anchor" title="Link to Scan">#</a>
               </h3>
               
               <p>Scan scans the next token and returns the token position, the token,
and its literal string if applicable. The source end is indicated by
[token.EOF].
If the returned token is a literal ([token.IDENT], [token.INT], [token.FLOAT],
[token.IMAG], [token.CHAR], [token.STRING]) or [token.COMMENT], the literal string
has the corresponding value.
If the returned token is a keyword, the literal string is the keyword.
If the returned token is [token.SEMICOLON], the corresponding
literal string is ";" if the semicolon was present in the source,
and "\n" if the semicolon was inserted because of a newline or
at EOF.
If the returned token is [token.ILLEGAL], the literal string is the
offending character.
In all other cases, Scan returns an empty literal string.
For more tolerant parsing, Scan will return a valid token if
possible even if a syntax error was encountered. Thus, even
if the resulting token sequence contains no illegal tokens,
a client may not assume that no error occurred. Instead it
must check the scanner's ErrorCount or the number of calls
of the error handler, if there was one installed.
Scan adds line information to the file added to the file
set with Init. Token positions are relative to that file
and thus relative to the file set.</p>
               
               <pre><code class="language-go">func (s *Scanner) Scan() (pos token.Pos, tok token.Token, lit string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sort" data-name="Sort">
               <h3>
                  Sort 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sort" class="anchor" title="Link to Sort">#</a>
               </h3>
               
               <p>Sort sorts an [ErrorList]. *[Error] entries are sorted by position,
other errors are sorted by error message, and before any *[Error]
entry.</p>
               
               <pre><code class="language-go">func (p ErrorList) Sort()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Swap" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Swap" class="anchor" title="Link to Swap">#</a>
               </h3>
               
               <pre><code class="language-go">func (p ErrorList) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="digitVal" data-name="digitVal">
               <h3>
                  digitVal 
                  <span class="badge">function</span>
                  
                  <a href="#digitVal" class="anchor" title="Link to digitVal">#</a>
               </h3>
               
               <pre><code class="language-go">func digitVal(ch rune) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="digits" data-name="digits">
               <h3>
                  digits 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#digits" class="anchor" title="Link to digits">#</a>
               </h3>
               
               <p>digits accepts the sequence { digit | '_' }.
If base <= 10, digits accepts any decimal digit but records
the offset (relative to the source start) of a digit >= base
in *invalid, if *invalid < 0.
digits returns a bitset describing whether the sequence contained
digits (bit 0 is set), or separators '_' (bit 1 is set).</p>
               
               <pre><code class="language-go">func (s *Scanner) digits(base int, invalid *int) (digsep int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="error" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#error" class="anchor" title="Link to error">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Scanner) error(offs int, msg string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errorf" data-name="errorf">
               <h3>
                  errorf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#errorf" class="anchor" title="Link to errorf">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Scanner) errorf(offs int, format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="invalidSep" data-name="invalidSep">
               <h3>
                  invalidSep 
                  <span class="badge">function</span>
                  
                  <a href="#invalidSep" class="anchor" title="Link to invalidSep">#</a>
               </h3>
               
               <p>invalidSep returns the index of the first invalid separator in x, or -1.</p>
               
               <pre><code class="language-go">func invalidSep(x string) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDecimal" data-name="isDecimal">
               <h3>
                  isDecimal 
                  <span class="badge">function</span>
                  
                  <a href="#isDecimal" class="anchor" title="Link to isDecimal">#</a>
               </h3>
               
               <pre><code class="language-go">func isDecimal(ch rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDigit" data-name="isDigit">
               <h3>
                  isDigit 
                  <span class="badge">function</span>
                  
                  <a href="#isDigit" class="anchor" title="Link to isDigit">#</a>
               </h3>
               
               <pre><code class="language-go">func isDigit(ch rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isHex" data-name="isHex">
               <h3>
                  isHex 
                  <span class="badge">function</span>
                  
                  <a href="#isHex" class="anchor" title="Link to isHex">#</a>
               </h3>
               
               <pre><code class="language-go">func isHex(ch rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isLetter" data-name="isLetter">
               <h3>
                  isLetter 
                  <span class="badge">function</span>
                  
                  <a href="#isLetter" class="anchor" title="Link to isLetter">#</a>
               </h3>
               
               <pre><code class="language-go">func isLetter(ch rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="litname" data-name="litname">
               <h3>
                  litname 
                  <span class="badge">function</span>
                  
                  <a href="#litname" class="anchor" title="Link to litname">#</a>
               </h3>
               
               <pre><code class="language-go">func litname(prefix rune) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lower" data-name="lower">
               <h3>
                  lower 
                  <span class="badge">function</span>
                  
                  <a href="#lower" class="anchor" title="Link to lower">#</a>
               </h3>
               
               <pre><code class="language-go">func lower(ch rune) rune</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="next" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#next" class="anchor" title="Link to next">#</a>
               </h3>
               
               <p>Read the next Unicode char into s.ch.
s.ch < 0 means end-of-file.
For optimization, there is some overlap between this method and
s.scanIdentifier.</p>
               
               <pre><code class="language-go">func (s *Scanner) next()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="peek" data-name="peek">
               <h3>
                  peek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#peek" class="anchor" title="Link to peek">#</a>
               </h3>
               
               <p>peek returns the byte following the most recently read character without
advancing the scanner. If the scanner is at EOF, peek returns 0.</p>
               
               <pre><code class="language-go">func (s *Scanner) peek() byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanComment" data-name="scanComment">
               <h3>
                  scanComment 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanComment" class="anchor" title="Link to scanComment">#</a>
               </h3>
               
               <p>scanComment returns the text of the comment and (if nonzero)
the offset of the first newline within it, which implies a
/*...*/ comment.</p>
               
               <pre><code class="language-go">func (s *Scanner) scanComment() (string, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanEscape" data-name="scanEscape">
               <h3>
                  scanEscape 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanEscape" class="anchor" title="Link to scanEscape">#</a>
               </h3>
               
               <p>scanEscape parses an escape sequence where rune is the accepted
escaped quote. In case of a syntax error, it stops at the offending
character (without consuming it) and returns false. Otherwise
it returns true.</p>
               
               <pre><code class="language-go">func (s *Scanner) scanEscape(quote rune) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanIdentifier" data-name="scanIdentifier">
               <h3>
                  scanIdentifier 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanIdentifier" class="anchor" title="Link to scanIdentifier">#</a>
               </h3>
               
               <p>scanIdentifier reads the string of valid identifier characters at s.offset.
It must only be called when s.ch is known to be a valid letter.
Be careful when making changes to this function: it is optimized and affects
scanning performance significantly.</p>
               
               <pre><code class="language-go">func (s *Scanner) scanIdentifier() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanNumber" data-name="scanNumber">
               <h3>
                  scanNumber 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanNumber" class="anchor" title="Link to scanNumber">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Scanner) scanNumber() (token.Token, string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanRawString" data-name="scanRawString">
               <h3>
                  scanRawString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanRawString" class="anchor" title="Link to scanRawString">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Scanner) scanRawString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanRune" data-name="scanRune">
               <h3>
                  scanRune 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanRune" class="anchor" title="Link to scanRune">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Scanner) scanRune() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanString" data-name="scanString">
               <h3>
                  scanString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanString" class="anchor" title="Link to scanString">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Scanner) scanString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skipWhitespace" data-name="skipWhitespace">
               <h3>
                  skipWhitespace 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#skipWhitespace" class="anchor" title="Link to skipWhitespace">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Scanner) skipWhitespace()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stripCR" data-name="stripCR">
               <h3>
                  stripCR 
                  <span class="badge">function</span>
                  
                  <a href="#stripCR" class="anchor" title="Link to stripCR">#</a>
               </h3>
               
               <pre><code class="language-go">func stripCR(b []byte, comment bool) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="switch2" data-name="switch2">
               <h3>
                  switch2 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#switch2" class="anchor" title="Link to switch2">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Scanner) switch2(tok0 token.Token, tok1 token.Token) token.Token</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="switch3" data-name="switch3">
               <h3>
                  switch3 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#switch3" class="anchor" title="Link to switch3">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Scanner) switch3(tok0 token.Token, tok1 token.Token, ch2 rune, tok2 token.Token) token.Token</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="switch4" data-name="switch4">
               <h3>
                  switch4 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#switch4" class="anchor" title="Link to switch4">#</a>
               </h3>
               
               <pre><code class="language-go">func (s *Scanner) switch4(tok0 token.Token, tok1 token.Token, ch2 rune, tok2 token.Token, tok3 token.Token) token.Token</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="trailingDigits" data-name="trailingDigits">
               <h3>
                  trailingDigits 
                  <span class="badge">function</span>
                  
                  <a href="#trailingDigits" class="anchor" title="Link to trailingDigits">#</a>
               </h3>
               
               <pre><code class="language-go">func trailingDigits(text []byte) (int, int, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateLineInfo" data-name="updateLineInfo">
               <h3>
                  updateLineInfo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateLineInfo" class="anchor" title="Link to updateLineInfo">#</a>
               </h3>
               
               <p>updateLineInfo parses the incoming comment text at offset offs
as a line directive. If successful, it updates the line info table
for the position next per the line directive.</p>
               
               <pre><code class="language-go">func (s *Scanner) updateLineInfo(next int, offs int, text []byte)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>