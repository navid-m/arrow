<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - os</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <ul class="subpackage-list">
               
               <li><a href="os_exec-docs.html">exec</a></li>
               
               <li><a href="os_signal-docs.html">signal</a></li>
               
               <li><a href="os_user-docs.html">user</a></li>
               
            </ul>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>os</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"syscall"
"unsafe"
"syscall"
"internal/filepathlite"
"syscall"
"time"
"io"
"io/fs"
"syscall"
"syscall"
"unsafe"
"syscall"
"unsafe"
"syscall"
"unsafe"
"syscall"
"internal/syscall/windows"
"syscall"
"runtime"
"internal/filepathlite"
"syscall"
"time"
"internal/bytealg"
"internal/poll"
"internal/stringslite"
"io"
"runtime"
"sync"
"sync/atomic"
"syscall"
"time"
"syscall"
"time"
"internal/syscall/windows"
"syscall"
"internal/poll"
"io"
"runtime"
"syscall"
"internal/syscall/unix"
"io"
"syscall"
"internal/filepathlite"
"syscall"
"time"
"syscall"
"unsafe"
"syscall"
"unsafe"
"internal/testlog"
"runtime"
"syscall"
"syscall"
"syscall"
"unsafe"
"errors"
"internal/bytealg"
"internal/stringslite"
"internal/testlog"
"io/fs"
"runtime"
"slices"
"syscall"
"runtime"
"syscall"
"runtime"
"syscall"
"errors"
"internal/testlog"
"runtime"
"sync"
"sync/atomic"
"syscall"
"time"
"internal/filepathlite"
"internal/poll"
"io"
"syscall"
"unsafe"
"errors"
"sync/atomic"
"errors"
"internal/filepathlite"
"internal/stringslite"
"internal/syscall/windows"
"runtime"
"syscall"
"unsafe"
"internal/testlog"
"io"
"syscall"
"syscall"
"unsafe"
"errors"
_ "unsafe"
"syscall"
"internal/filepathlite"
"syscall"
"time"
"syscall"
"unsafe"
"io/fs"
"syscall"
"syscall"
"time"
"internal/poll"
"io"
"syscall"
"errors"
"internal/syscall/unix"
"runtime"
"sync"
"syscall"
_ "unsafe"
"io"
"runtime"
"syscall"
"internal/filepathlite"
"syscall"
"time"
"internal/filepathlite"
"internal/godebug"
"internal/syscall/windows"
"sync"
"syscall"
"time"
"unsafe"
"io"
"runtime"
"syscall"
"unsafe"
"runtime"
"syscall"
"internal/poll"
"syscall"
"syscall"
"internal/syscall/windows"
"io"
"io/fs"
"runtime"
"sync"
"syscall"
"unsafe"
"syscall"
"unsafe"
"runtime"
"sync"
"syscall"
"syscall"
"syscall"
"errors"
"internal/filepathlite"
"internal/godebug"
"internal/poll"
"internal/syscall/windows"
"runtime"
"sync"
"sync/atomic"
"syscall"
"unsafe"
"internal/filepathlite"
"syscall"
"time"
"syscall"
"unsafe"
"internal/testlog"
"syscall"
"syscall"
"errors"
"runtime"
"internal/filepathlite"
"syscall"
"runtime"
"slices"
"sync"
"syscall"
"internal/poll"
"io/fs"
"internal/itoa"
"runtime"
"syscall"
"time"
"syscall"
_ "unsafe"
"errors"
"internal/bytealg"
"internal/itoa"
_ "unsafe"
"syscall"
"unsafe"
"internal/poll"
"syscall"
"syscall"
"unsafe"
"internal/poll"
"internal/syscall/unix"
"io/fs"
"runtime"
"sync/atomic"
"syscall"
_ "unsafe"
"internal/byteorder"
"internal/goarch"
"io"
"runtime"
"sync"
"syscall"
"unsafe"
"internal/poll"
"internal/filepathlite"
"syscall"
"time"
"syscall"
"syscall"
"errors"
"internal/stringslite"
"runtime"
"internal/itoa"
"internal/syscall/execenv"
"runtime"
"syscall"
"errors"
"runtime"
"syscall"
"time"
"internal/itoa"
"syscall"
"runtime"
"syscall"
"time"
"internal/syscall/unix"
"runtime"
"syscall"
"internal/filepathlite"
"internal/syscall/windows"
"syscall"
"syscall"
"errors"
"internal/syscall/unix"
"runtime"
"syscall"
"internal/filepathlite"
"syscall"
"time"
"internal/filepathlite"
"internal/syscall/windows"
"syscall"
"unsafe"
"io"
"errors"
"internal/syscall/windows"
"runtime"
"syscall"
"time"
"errors"
"slices"
"syscall"
"internal/filepathlite"
"syscall"
"time"
"syscall"
"time"
"errors"
"internal/filepathlite"
"internal/poll"
"internal/testlog"
"io"
"io/fs"
"runtime"
"syscall"
"time"
"unsafe"
"internal/filepathlite"
"syscall"
"time"
"internal/bytealg"
"internal/filepathlite"
"io"
"io/fs"
"slices"
"syscall"
"unsafe"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="Args" data-name="Args">
               <h3>
                  Args 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Args" class="anchor" title="Link to Args">#</a>
               </h3>
               
               <p>Args hold the command-line arguments, starting with the program name.</p>
               
               <pre><code>var Args []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DevNull" data-name="DevNull">
               <h3>
                  DevNull 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DevNull" class="anchor" title="Link to DevNull">#</a>
               </h3>
               
               <p>DevNull is the name of the operating system's “null device.”
On Unix-like systems, it is "/dev/null"; on Windows, "NUL".</p>
               
               <pre><code>const DevNull = "/dev/null"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DevNull" data-name="DevNull">
               <h3>
                  DevNull 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DevNull" class="anchor" title="Link to DevNull">#</a>
               </h3>
               
               <p>DevNull is the name of the operating system's “null device.”
On Unix-like systems, it is "/dev/null"; on Windows, "NUL".</p>
               
               <pre><code>const DevNull = "/dev/null"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DevNull" data-name="DevNull">
               <h3>
                  DevNull 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DevNull" class="anchor" title="Link to DevNull">#</a>
               </h3>
               
               <p>DevNull is the name of the operating system's “null device.”
On Unix-like systems, it is "/dev/null"; on Windows, "NUL".</p>
               
               <pre><code>const DevNull = "NUL"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrClosed" data-name="ErrClosed">
               <h3>
                  ErrClosed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrClosed" class="anchor" title="Link to ErrClosed">#</a>
               </h3>
               
               <p>Portable analogs of some common system call errors.
Errors returned from this package may be tested against these errors
with [errors.Is].</p>
               
               <pre><code>var ErrClosed = fs.ErrClosed</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrDeadlineExceeded" data-name="ErrDeadlineExceeded">
               <h3>
                  ErrDeadlineExceeded 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrDeadlineExceeded" class="anchor" title="Link to ErrDeadlineExceeded">#</a>
               </h3>
               
               <p>Portable analogs of some common system call errors.
Errors returned from this package may be tested against these errors
with [errors.Is].</p>
               
               <pre><code>var ErrDeadlineExceeded = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrExist" data-name="ErrExist">
               <h3>
                  ErrExist 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrExist" class="anchor" title="Link to ErrExist">#</a>
               </h3>
               
               <p>Portable analogs of some common system call errors.
Errors returned from this package may be tested against these errors
with [errors.Is].</p>
               
               <pre><code>var ErrExist = fs.ErrExist</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrInvalid" data-name="ErrInvalid">
               <h3>
                  ErrInvalid 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrInvalid" class="anchor" title="Link to ErrInvalid">#</a>
               </h3>
               
               <p>ErrInvalid indicates an invalid argument.
Methods on File will return this error when the receiver is nil.</p>
               
               <pre><code>var ErrInvalid = fs.ErrInvalid</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNoDeadline" data-name="ErrNoDeadline">
               <h3>
                  ErrNoDeadline 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNoDeadline" class="anchor" title="Link to ErrNoDeadline">#</a>
               </h3>
               
               <p>Portable analogs of some common system call errors.
Errors returned from this package may be tested against these errors
with [errors.Is].</p>
               
               <pre><code>var ErrNoDeadline = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrNotExist" data-name="ErrNotExist">
               <h3>
                  ErrNotExist 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNotExist" class="anchor" title="Link to ErrNotExist">#</a>
               </h3>
               
               <p>Portable analogs of some common system call errors.
Errors returned from this package may be tested against these errors
with [errors.Is].</p>
               
               <pre><code>var ErrNotExist = fs.ErrNotExist</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrPermission" data-name="ErrPermission">
               <h3>
                  ErrPermission 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrPermission" class="anchor" title="Link to ErrPermission">#</a>
               </h3>
               
               <p>Portable analogs of some common system call errors.
Errors returned from this package may be tested against these errors
with [errors.Is].</p>
               
               <pre><code>var ErrPermission = fs.ErrPermission</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrProcessDone" data-name="ErrProcessDone">
               <h3>
                  ErrProcessDone 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrProcessDone" class="anchor" title="Link to ErrProcessDone">#</a>
               </h3>
               
               <p>ErrProcessDone indicates a [Process] has finished.</p>
               
               <pre><code>var ErrProcessDone = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Interrupt" data-name="Interrupt">
               <h3>
                  Interrupt 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Interrupt" class="anchor" title="Link to Interrupt">#</a>
               </h3>
               
               <p>The only signal values guaranteed to be present in the os package
on all systems are Interrupt (send the process an interrupt) and
Kill (force the process to exit). Interrupt is not implemented on
Windows; using it with [os.Process.Signal] will return an error.</p>
               
               <pre><code>var Interrupt Signal = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Interrupt" data-name="Interrupt">
               <h3>
                  Interrupt 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Interrupt" class="anchor" title="Link to Interrupt">#</a>
               </h3>
               
               <p>The only signal values guaranteed to be present in the os package on all
systems are os.Interrupt (send the process an interrupt) and os.Kill (force
the process to exit). On Windows, sending os.Interrupt to a process with
os.Process.Signal is not implemented; it will return an error instead of
sending a signal.</p>
               
               <pre><code>var Interrupt Signal = syscall.SIGINT</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Kill" data-name="Kill">
               <h3>
                  Kill 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Kill" class="anchor" title="Link to Kill">#</a>
               </h3>
               
               <p>The only signal values guaranteed to be present in the os package on all
systems are os.Interrupt (send the process an interrupt) and os.Kill (force
the process to exit). On Windows, sending os.Interrupt to a process with
os.Process.Signal is not implemented; it will return an error instead of
sending a signal.</p>
               
               <pre><code>var Kill Signal = syscall.SIGKILL</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Kill" data-name="Kill">
               <h3>
                  Kill 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Kill" class="anchor" title="Link to Kill">#</a>
               </h3>
               
               <p>The only signal values guaranteed to be present in the os package
on all systems are Interrupt (send the process an interrupt) and
Kill (force the process to exit). Interrupt is not implemented on
Windows; using it with [os.Process.Signal] will return an error.</p>
               
               <pre><code>var Kill Signal = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeAppend" data-name="ModeAppend">
               <h3>
                  ModeAppend 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeAppend" class="anchor" title="Link to ModeAppend">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModeAppend = fs.ModeAppend</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeCharDevice" data-name="ModeCharDevice">
               <h3>
                  ModeCharDevice 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeCharDevice" class="anchor" title="Link to ModeCharDevice">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModeCharDevice = fs.ModeCharDevice</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeDevice" data-name="ModeDevice">
               <h3>
                  ModeDevice 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeDevice" class="anchor" title="Link to ModeDevice">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModeDevice = fs.ModeDevice</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeDir" data-name="ModeDir">
               <h3>
                  ModeDir 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeDir" class="anchor" title="Link to ModeDir">#</a>
               </h3>
               
               <p>The single letters are the abbreviations
used by the String method's formatting.</p>
               
               <pre><code>const ModeDir = fs.ModeDir</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeExclusive" data-name="ModeExclusive">
               <h3>
                  ModeExclusive 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeExclusive" class="anchor" title="Link to ModeExclusive">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModeExclusive = fs.ModeExclusive</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeIrregular" data-name="ModeIrregular">
               <h3>
                  ModeIrregular 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeIrregular" class="anchor" title="Link to ModeIrregular">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModeIrregular = fs.ModeIrregular</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeNamedPipe" data-name="ModeNamedPipe">
               <h3>
                  ModeNamedPipe 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeNamedPipe" class="anchor" title="Link to ModeNamedPipe">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModeNamedPipe = fs.ModeNamedPipe</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModePerm" data-name="ModePerm">
               <h3>
                  ModePerm 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModePerm" class="anchor" title="Link to ModePerm">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModePerm = fs.ModePerm</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeSetgid" data-name="ModeSetgid">
               <h3>
                  ModeSetgid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeSetgid" class="anchor" title="Link to ModeSetgid">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModeSetgid = fs.ModeSetgid</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeSetuid" data-name="ModeSetuid">
               <h3>
                  ModeSetuid 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeSetuid" class="anchor" title="Link to ModeSetuid">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModeSetuid = fs.ModeSetuid</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeSocket" data-name="ModeSocket">
               <h3>
                  ModeSocket 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeSocket" class="anchor" title="Link to ModeSocket">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModeSocket = fs.ModeSocket</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeSticky" data-name="ModeSticky">
               <h3>
                  ModeSticky 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeSticky" class="anchor" title="Link to ModeSticky">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModeSticky = fs.ModeSticky</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeSymlink" data-name="ModeSymlink">
               <h3>
                  ModeSymlink 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeSymlink" class="anchor" title="Link to ModeSymlink">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModeSymlink = fs.ModeSymlink</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeTemporary" data-name="ModeTemporary">
               <h3>
                  ModeTemporary 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeTemporary" class="anchor" title="Link to ModeTemporary">#</a>
               </h3>
               
               <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
               
               <pre><code>const ModeTemporary = fs.ModeTemporary</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ModeType" data-name="ModeType">
               <h3>
                  ModeType 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ModeType" class="anchor" title="Link to ModeType">#</a>
               </h3>
               
               <p>Mask for the type bits. For regular files, none will be set.</p>
               
               <pre><code>const ModeType = fs.ModeType</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="O_APPEND" data-name="O_APPEND">
               <h3>
                  O_APPEND 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#O_APPEND" class="anchor" title="Link to O_APPEND">#</a>
               </h3>
               
               <p>The remaining values may be or'ed in to control behavior.</p>
               
               <pre><code>const O_APPEND int = syscall.O_APPEND</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="O_CREATE" data-name="O_CREATE">
               <h3>
                  O_CREATE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#O_CREATE" class="anchor" title="Link to O_CREATE">#</a>
               </h3>
               
               <p>Flags to OpenFile wrapping those of the underlying system. Not all
flags may be implemented on a given system.</p>
               
               <pre><code>const O_CREATE int = syscall.O_CREAT</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="O_EXCL" data-name="O_EXCL">
               <h3>
                  O_EXCL 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#O_EXCL" class="anchor" title="Link to O_EXCL">#</a>
               </h3>
               
               <p>Flags to OpenFile wrapping those of the underlying system. Not all
flags may be implemented on a given system.</p>
               
               <pre><code>const O_EXCL int = syscall.O_EXCL</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="O_RDONLY" data-name="O_RDONLY">
               <h3>
                  O_RDONLY 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#O_RDONLY" class="anchor" title="Link to O_RDONLY">#</a>
               </h3>
               
               <p>Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.</p>
               
               <pre><code>const O_RDONLY int = syscall.O_RDONLY</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="O_RDWR" data-name="O_RDWR">
               <h3>
                  O_RDWR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#O_RDWR" class="anchor" title="Link to O_RDWR">#</a>
               </h3>
               
               <p>Flags to OpenFile wrapping those of the underlying system. Not all
flags may be implemented on a given system.</p>
               
               <pre><code>const O_RDWR int = syscall.O_RDWR</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="O_SYNC" data-name="O_SYNC">
               <h3>
                  O_SYNC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#O_SYNC" class="anchor" title="Link to O_SYNC">#</a>
               </h3>
               
               <p>Flags to OpenFile wrapping those of the underlying system. Not all
flags may be implemented on a given system.</p>
               
               <pre><code>const O_SYNC int = syscall.O_SYNC</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="O_TRUNC" data-name="O_TRUNC">
               <h3>
                  O_TRUNC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#O_TRUNC" class="anchor" title="Link to O_TRUNC">#</a>
               </h3>
               
               <p>Flags to OpenFile wrapping those of the underlying system. Not all
flags may be implemented on a given system.</p>
               
               <pre><code>const O_TRUNC int = syscall.O_TRUNC</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="O_WRONLY" data-name="O_WRONLY">
               <h3>
                  O_WRONLY 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#O_WRONLY" class="anchor" title="Link to O_WRONLY">#</a>
               </h3>
               
               <p>Flags to OpenFile wrapping those of the underlying system. Not all
flags may be implemented on a given system.</p>
               
               <pre><code>const O_WRONLY int = syscall.O_WRONLY</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PathListSeparator" data-name="PathListSeparator">
               <h3>
                  PathListSeparator 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PathListSeparator" class="anchor" title="Link to PathListSeparator">#</a>
               </h3>
               
               <pre><code>const PathListSeparator = '\000'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PathListSeparator" data-name="PathListSeparator">
               <h3>
                  PathListSeparator 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PathListSeparator" class="anchor" title="Link to PathListSeparator">#</a>
               </h3>
               
               <pre><code>const PathListSeparator = ':'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PathListSeparator" data-name="PathListSeparator">
               <h3>
                  PathListSeparator 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PathListSeparator" class="anchor" title="Link to PathListSeparator">#</a>
               </h3>
               
               <pre><code>const PathListSeparator = ';'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PathSeparator" data-name="PathSeparator">
               <h3>
                  PathSeparator 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PathSeparator" class="anchor" title="Link to PathSeparator">#</a>
               </h3>
               
               <pre><code>const PathSeparator = '/'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PathSeparator" data-name="PathSeparator">
               <h3>
                  PathSeparator 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PathSeparator" class="anchor" title="Link to PathSeparator">#</a>
               </h3>
               
               <pre><code>const PathSeparator = '\\'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="PathSeparator" data-name="PathSeparator">
               <h3>
                  PathSeparator 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#PathSeparator" class="anchor" title="Link to PathSeparator">#</a>
               </h3>
               
               <pre><code>const PathSeparator = '/'</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SEEK_CUR" data-name="SEEK_CUR">
               <h3>
                  SEEK_CUR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SEEK_CUR" class="anchor" title="Link to SEEK_CUR">#</a>
               </h3>
               
               <p>Seek whence values.
Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.</p>
               
               <pre><code>const SEEK_CUR int = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SEEK_END" data-name="SEEK_END">
               <h3>
                  SEEK_END 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SEEK_END" class="anchor" title="Link to SEEK_END">#</a>
               </h3>
               
               <p>Seek whence values.
Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.</p>
               
               <pre><code>const SEEK_END int = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SEEK_SET" data-name="SEEK_SET">
               <h3>
                  SEEK_SET 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SEEK_SET" class="anchor" title="Link to SEEK_SET">#</a>
               </h3>
               
               <p>Seek whence values.
Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.</p>
               
               <pre><code>const SEEK_SET int = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Stderr" data-name="Stderr">
               <h3>
                  Stderr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Stderr" class="anchor" title="Link to Stderr">#</a>
               </h3>
               
               <p>Stdin, Stdout, and Stderr are open Files pointing to the standard input,
standard output, and standard error file descriptors.
Note that the Go runtime writes to standard error for panics and crashes;
closing Stderr may cause those messages to go elsewhere, perhaps
to a file opened later.</p>
               
               <pre><code>var Stderr = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Stdin" data-name="Stdin">
               <h3>
                  Stdin 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Stdin" class="anchor" title="Link to Stdin">#</a>
               </h3>
               
               <p>Stdin, Stdout, and Stderr are open Files pointing to the standard input,
standard output, and standard error file descriptors.
Note that the Go runtime writes to standard error for panics and crashes;
closing Stderr may cause those messages to go elsewhere, perhaps
to a file opened later.</p>
               
               <pre><code>var Stdin = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Stdout" data-name="Stdout">
               <h3>
                  Stdout 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Stdout" class="anchor" title="Link to Stdout">#</a>
               </h3>
               
               <p>Stdin, Stdout, and Stderr are open Files pointing to the standard input,
standard output, and standard error file descriptors.
Note that the Go runtime writes to standard error for panics and crashes;
closing Stderr may cause those messages to go elsewhere, perhaps
to a file opened later.</p>
               
               <pre><code>var Stdout = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_CTL_KERN" data-name="_CTL_KERN">
               <h3>
                  _CTL_KERN 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_CTL_KERN" class="anchor" title="Link to _CTL_KERN">#</a>
               </h3>
               
               <p>From DragonFly's <sys/sysctl.h></p>
               
               <pre><code>const _CTL_KERN = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_CTL_KERN" data-name="_CTL_KERN">
               <h3>
                  _CTL_KERN 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_CTL_KERN" class="anchor" title="Link to _CTL_KERN">#</a>
               </h3>
               
               <p>From NetBSD's <sys/sysctl.h></p>
               
               <pre><code>const _CTL_KERN = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_CTL_KERN" data-name="_CTL_KERN">
               <h3>
                  _CTL_KERN 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_CTL_KERN" class="anchor" title="Link to _CTL_KERN">#</a>
               </h3>
               
               <p>From FreeBSD's <sys/sysctl.h></p>
               
               <pre><code>const _CTL_KERN = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_KERN_PROC" data-name="_KERN_PROC">
               <h3>
                  _KERN_PROC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_KERN_PROC" class="anchor" title="Link to _KERN_PROC">#</a>
               </h3>
               
               <p>From FreeBSD's <sys/sysctl.h></p>
               
               <pre><code>const _KERN_PROC = 14</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_KERN_PROC" data-name="_KERN_PROC">
               <h3>
                  _KERN_PROC 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_KERN_PROC" class="anchor" title="Link to _KERN_PROC">#</a>
               </h3>
               
               <p>From DragonFly's <sys/sysctl.h></p>
               
               <pre><code>const _KERN_PROC = 14</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_KERN_PROC_ARGS" data-name="_KERN_PROC_ARGS">
               <h3>
                  _KERN_PROC_ARGS 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_KERN_PROC_ARGS" class="anchor" title="Link to _KERN_PROC_ARGS">#</a>
               </h3>
               
               <p>From NetBSD's <sys/sysctl.h></p>
               
               <pre><code>const _KERN_PROC_ARGS = 48</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_KERN_PROC_PATHNAME" data-name="_KERN_PROC_PATHNAME">
               <h3>
                  _KERN_PROC_PATHNAME 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_KERN_PROC_PATHNAME" class="anchor" title="Link to _KERN_PROC_PATHNAME">#</a>
               </h3>
               
               <p>From NetBSD's <sys/sysctl.h></p>
               
               <pre><code>const _KERN_PROC_PATHNAME = 5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_KERN_PROC_PATHNAME" data-name="_KERN_PROC_PATHNAME">
               <h3>
                  _KERN_PROC_PATHNAME 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_KERN_PROC_PATHNAME" class="anchor" title="Link to _KERN_PROC_PATHNAME">#</a>
               </h3>
               
               <p>From FreeBSD's <sys/sysctl.h></p>
               
               <pre><code>const _KERN_PROC_PATHNAME = 12</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_KERN_PROC_PATHNAME" data-name="_KERN_PROC_PATHNAME">
               <h3>
                  _KERN_PROC_PATHNAME 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_KERN_PROC_PATHNAME" class="anchor" title="Link to _KERN_PROC_PATHNAME">#</a>
               </h3>
               
               <p>From DragonFly's <sys/sysctl.h></p>
               
               <pre><code>const _KERN_PROC_PATHNAME = 9</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_P_PID" data-name="_P_PID">
               <h3>
                  _P_PID 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_P_PID" class="anchor" title="Link to _P_PID">#</a>
               </h3>
               
               <pre><code>const _P_PID = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_P_PID" data-name="_P_PID">
               <h3>
                  _P_PID 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_P_PID" class="anchor" title="Link to _P_PID">#</a>
               </h3>
               
               <pre><code>const _P_PID = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_P_PID" data-name="_P_PID">
               <h3>
                  _P_PID 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_P_PID" class="anchor" title="Link to _P_PID">#</a>
               </h3>
               
               <pre><code>const _P_PID = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_P_PID" data-name="_P_PID">
               <h3>
                  _P_PID 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_P_PID" class="anchor" title="Link to _P_PID">#</a>
               </h3>
               
               <pre><code>const _P_PID = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_P_PID" data-name="_P_PID">
               <h3>
                  _P_PID 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_P_PID" class="anchor" title="Link to _P_PID">#</a>
               </h3>
               
               <pre><code>const _P_PID = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_S_IFDOOR" data-name="_S_IFDOOR">
               <h3>
                  _S_IFDOOR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_S_IFDOOR" class="anchor" title="Link to _S_IFDOOR">#</a>
               </h3>
               
               <p>These constants aren't in the syscall package, which is frozen.
Values taken from golang.org/x/sys/unix.</p>
               
               <pre><code>const _S_IFDOOR = 0xd000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_S_IFNAM" data-name="_S_IFNAM">
               <h3>
                  _S_IFNAM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_S_IFNAM" class="anchor" title="Link to _S_IFNAM">#</a>
               </h3>
               
               <p>These constants aren't in the syscall package, which is frozen.
Values taken from golang.org/x/sys/unix.</p>
               
               <pre><code>const _S_IFNAM = 0x5000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_S_IFPORT" data-name="_S_IFPORT">
               <h3>
                  _S_IFPORT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_S_IFPORT" class="anchor" title="Link to _S_IFPORT">#</a>
               </h3>
               
               <p>These constants aren't in the syscall package, which is frozen.
Values taken from golang.org/x/sys/unix.</p>
               
               <pre><code>const _S_IFPORT = 0xe000</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_UTIME_OMIT" data-name="_UTIME_OMIT">
               <h3>
                  _UTIME_OMIT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_UTIME_OMIT" class="anchor" title="Link to _UTIME_OMIT">#</a>
               </h3>
               
               <pre><code>const _UTIME_OMIT = unix.UTIME_OMIT</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_UTIME_OMIT" data-name="_UTIME_OMIT">
               <h3>
                  _UTIME_OMIT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_UTIME_OMIT" class="anchor" title="Link to _UTIME_OMIT">#</a>
               </h3>
               
               <p>This matches the value in syscall/syscall_windows.go.</p>
               
               <pre><code>const _UTIME_OMIT = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="allowReadDirFileID" data-name="allowReadDirFileID">
               <h3>
                  allowReadDirFileID 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#allowReadDirFileID" class="anchor" title="Link to allowReadDirFileID">#</a>
               </h3>
               
               <p>allowReadDirFileID indicates whether File.readdir should try to use FILE_ID_BOTH_DIR_INFO
if the underlying file system supports it.
Useful for testing purposes.</p>
               
               <pre><code>var allowReadDirFileID = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bitSize16" data-name="bitSize16">
               <h3>
                  bitSize16 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#bitSize16" class="anchor" title="Link to bitSize16">#</a>
               </h3>
               
               <pre><code>const bitSize16 = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="blockSize" data-name="blockSize">
               <h3>
                  blockSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#blockSize" class="anchor" title="Link to blockSize">#</a>
               </h3>
               
               <p>More than 5760 to work around https://golang.org/issue/24015.</p>
               
               <pre><code>const blockSize = 8192</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="checkPidfdOnce" data-name="checkPidfdOnce">
               <h3>
                  checkPidfdOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#checkPidfdOnce" class="anchor" title="Link to checkPidfdOnce">#</a>
               </h3>
               
               <pre><code>var checkPidfdOnce = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="checkWrapErr" data-name="checkWrapErr">
               <h3>
                  checkWrapErr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#checkWrapErr" class="anchor" title="Link to checkWrapErr">#</a>
               </h3>
               
               <p>checkWrapErr is the test hook to enable checking unexpected wrapped errors of poll.ErrFileClosing.
It is set to true in the export_test.go for tests (including fuzz tests).</p>
               
               <pre><code>var checkWrapErr = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="chmodMask" data-name="chmodMask">
               <h3>
                  chmodMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#chmodMask" class="anchor" title="Link to chmodMask">#</a>
               </h3>
               
               <pre><code>const chmodMask = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dirBufPool" data-name="dirBufPool">
               <h3>
                  dirBufPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dirBufPool" class="anchor" title="Link to dirBufPool">#</a>
               </h3>
               
               <pre><code>var dirBufPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dirBufPool" data-name="dirBufPool">
               <h3>
                  dirBufPool 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dirBufPool" class="anchor" title="Link to dirBufPool">#</a>
               </h3>
               
               <pre><code>var dirBufPool = sync.Pool{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dirBufSize" data-name="dirBufSize">
               <h3>
                  dirBufSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#dirBufSize" class="anchor" title="Link to dirBufSize">#</a>
               </h3>
               
               <p>dirBufSize is the size of the dirInfo buffer.
The buffer must be big enough to hold at least a single entry.
The filename alone can be 512 bytes (MAX_PATH*2), and the fixed part of
the FILE_ID_BOTH_DIR_INFO structure is 105 bytes, so dirBufSize
should not be set below 1024 bytes (512+105+safety buffer).
Windows 8.1 and earlier only works with buffer sizes up to 64 kB.</p>
               
               <pre><code>const dirBufSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errENOMEM" data-name="errENOMEM">
               <h3>
                  errENOMEM 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#errENOMEM" class="anchor" title="Link to errENOMEM">#</a>
               </h3>
               
               <pre><code>const errENOMEM = syscall.ENOMEM</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errENOMEM" data-name="errENOMEM">
               <h3>
                  errENOMEM 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errENOMEM" class="anchor" title="Link to errENOMEM">#</a>
               </h3>
               
               <pre><code>var errENOMEM = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errENOSYS" data-name="errENOSYS">
               <h3>
                  errENOSYS 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errENOSYS" class="anchor" title="Link to errENOSYS">#</a>
               </h3>
               
               <pre><code>var errENOSYS = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errENOSYS" data-name="errENOSYS">
               <h3>
                  errENOSYS 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#errENOSYS" class="anchor" title="Link to errENOSYS">#</a>
               </h3>
               
               <pre><code>const errENOSYS = syscall.ENOSYS</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errERANGE" data-name="errERANGE">
               <h3>
                  errERANGE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#errERANGE" class="anchor" title="Link to errERANGE">#</a>
               </h3>
               
               <pre><code>const errERANGE = syscall.ERANGE</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errERANGE" data-name="errERANGE">
               <h3>
                  errERANGE 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errERANGE" class="anchor" title="Link to errERANGE">#</a>
               </h3>
               
               <pre><code>var errERANGE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errPathEscapes" data-name="errPathEscapes">
               <h3>
                  errPathEscapes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errPathEscapes" class="anchor" title="Link to errPathEscapes">#</a>
               </h3>
               
               <pre><code>var errPathEscapes = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errPatternHasSeparator" data-name="errPatternHasSeparator">
               <h3>
                  errPatternHasSeparator 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errPatternHasSeparator" class="anchor" title="Link to errPatternHasSeparator">#</a>
               </h3>
               
               <pre><code>var errPatternHasSeparator = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errWd" data-name="errWd">
               <h3>
                  errWd 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errWd" class="anchor" title="Link to errWd">#</a>
               </h3>
               
               <p>We query the working directory at init, to use it later to search for the
executable file
errWd will be checked later, if we need to use initWd</p>
               
               <pre><code>var errWd</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errWriteAtInAppendMode" data-name="errWriteAtInAppendMode">
               <h3>
                  errWriteAtInAppendMode 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errWriteAtInAppendMode" class="anchor" title="Link to errWriteAtInAppendMode">#</a>
               </h3>
               
               <pre><code>var errWriteAtInAppendMode = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="executableMIB" data-name="executableMIB">
               <h3>
                  executableMIB 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#executableMIB" class="anchor" title="Link to executableMIB">#</a>
               </h3>
               
               <pre><code>var executableMIB = [4]int32{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="executableMIB" data-name="executableMIB">
               <h3>
                  executableMIB 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#executableMIB" class="anchor" title="Link to executableMIB">#</a>
               </h3>
               
               <pre><code>var executableMIB = [4]int32{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="executableMIB" data-name="executableMIB">
               <h3>
                  executableMIB 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#executableMIB" class="anchor" title="Link to executableMIB">#</a>
               </h3>
               
               <pre><code>var executableMIB = [4]int32{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="executablePath" data-name="executablePath">
               <h3>
                  executablePath 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#executablePath" class="anchor" title="Link to executablePath">#</a>
               </h3>
               
               <p>go:linkname executablePath</p>
               
               <pre><code>var executablePath string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="executablePath" data-name="executablePath">
               <h3>
                  executablePath 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#executablePath" class="anchor" title="Link to executablePath">#</a>
               </h3>
               
               <p>go:linkname executablePath</p>
               
               <pre><code>var executablePath string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="getwdCache" data-name="getwdCache">
               <h3>
                  getwdCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#getwdCache" class="anchor" title="Link to getwdCache">#</a>
               </h3>
               
               <pre><code>var getwdCache struct{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initCwd" data-name="initCwd">
               <h3>
                  initCwd 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#initCwd" class="anchor" title="Link to initCwd">#</a>
               </h3>
               
               <pre><code>var initCwd = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initCwd" data-name="initCwd">
               <h3>
                  initCwd 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#initCwd" class="anchor" title="Link to initCwd">#</a>
               </h3>
               
               <pre><code>var initCwd = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initCwdErr" data-name="initCwdErr">
               <h3>
                  initCwdErr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#initCwdErr" class="anchor" title="Link to initCwdErr">#</a>
               </h3>
               
               <pre><code>var initCwdErr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initCwdErr" data-name="initCwdErr">
               <h3>
                  initCwdErr 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#initCwdErr" class="anchor" title="Link to initCwdErr">#</a>
               </h3>
               
               <pre><code>var initCwdErr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="initWd" data-name="initWd">
               <h3>
                  initWd 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#initWd" class="anchor" title="Link to initWd">#</a>
               </h3>
               
               <p>We query the working directory at init, to use it later to search for the
executable file
errWd will be checked later, if we need to use initWd</p>
               
               <pre><code>var initWd = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="kindNewFile" data-name="kindNewFile">
               <h3>
                  kindNewFile 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#kindNewFile" class="anchor" title="Link to kindNewFile">#</a>
               </h3>
               
               <p>kindNewFile means that the descriptor was passed to us via NewFile.</p>
               
               <pre><code>const kindNewFile newFileKind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="kindNoPoll" data-name="kindNoPoll">
               <h3>
                  kindNoPoll 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#kindNoPoll" class="anchor" title="Link to kindNoPoll">#</a>
               </h3>
               
               <p>kindNoPoll means that we should not put the descriptor into
non-blocking mode, because we know it is not a pipe or FIFO.
Used by openDirAt and openDirNolog for directories.</p>
               
               <pre><code>const kindNoPoll</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="kindOpenFile" data-name="kindOpenFile">
               <h3>
                  kindOpenFile 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#kindOpenFile" class="anchor" title="Link to kindOpenFile">#</a>
               </h3>
               
               <p>kindOpenFile means that the descriptor was opened using
Open, Create, or OpenFile.</p>
               
               <pre><code>const kindOpenFile</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="kindPipe" data-name="kindPipe">
               <h3>
                  kindPipe 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#kindPipe" class="anchor" title="Link to kindPipe">#</a>
               </h3>
               
               <p>kindPipe means that the descriptor was opened using Pipe.</p>
               
               <pre><code>const kindPipe</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="kindSock" data-name="kindSock">
               <h3>
                  kindSock 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#kindSock" class="anchor" title="Link to kindSock">#</a>
               </h3>
               
               <p>kindSock means that the descriptor is a network file descriptor
that was created from net package and was opened using net_newUnixFile.</p>
               
               <pre><code>const kindSock</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="lstat" data-name="lstat">
               <h3>
                  lstat 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#lstat" class="anchor" title="Link to lstat">#</a>
               </h3>
               
               <p>lstat is overridden in tests.</p>
               
               <pre><code>var lstat = Lstat</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="modeHandle" data-name="modeHandle">
               <h3>
                  modeHandle 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#modeHandle" class="anchor" title="Link to modeHandle">#</a>
               </h3>
               
               <p>modeHandle means that Process operations use handle, which is
initialized with an OS process handle.
Note that Release and Wait will deactivate and eventually close the
handle, so acquire may fail, indicating the reason.</p>
               
               <pre><code>const modeHandle</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="modePID" data-name="modePID">
               <h3>
                  modePID 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#modePID" class="anchor" title="Link to modePID">#</a>
               </h3>
               
               <p>modePID means that Process operations such use the raw PID from the
Pid field. handle is not used.
This may be due to the host not supporting handles, or because
Process was created as a literal, leaving handle unset.
This must be the zero value so Process literals get modePID.</p>
               
               <pre><code>const modePID processMode = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pidReleased" data-name="pidReleased">
               <h3>
                  pidReleased 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#pidReleased" class="anchor" title="Link to pidReleased">#</a>
               </h3>
               
               <pre><code>const pidReleased = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pidUnset" data-name="pidUnset">
               <h3>
                  pidUnset 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#pidUnset" class="anchor" title="Link to pidUnset">#</a>
               </h3>
               
               <p>Special values for Process.Pid.</p>
               
               <pre><code>const pidUnset = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pollCopyFileRange" data-name="pollCopyFileRange">
               <h3>
                  pollCopyFileRange 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#pollCopyFileRange" class="anchor" title="Link to pollCopyFileRange">#</a>
               </h3>
               
               <pre><code>var pollCopyFileRange = poll.CopyFileRange</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pollCopyFileRange" data-name="pollCopyFileRange">
               <h3>
                  pollCopyFileRange 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#pollCopyFileRange" class="anchor" title="Link to pollCopyFileRange">#</a>
               </h3>
               
               <pre><code>var pollCopyFileRange = poll.CopyFileRange</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pollSplice" data-name="pollSplice">
               <h3>
                  pollSplice 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#pollSplice" class="anchor" title="Link to pollSplice">#</a>
               </h3>
               
               <pre><code>var pollSplice = poll.Splice</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="processStatusMask" data-name="processStatusMask">
               <h3>
                  processStatusMask 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#processStatusMask" class="anchor" title="Link to processStatusMask">#</a>
               </h3>
               
               <pre><code>const processStatusMask = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="readdirDirEntry" data-name="readdirDirEntry">
               <h3>
                  readdirDirEntry 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#readdirDirEntry" class="anchor" title="Link to readdirDirEntry">#</a>
               </h3>
               
               <pre><code>const readdirDirEntry</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="readdirFileInfo" data-name="readdirFileInfo">
               <h3>
                  readdirFileInfo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#readdirFileInfo" class="anchor" title="Link to readdirFileInfo">#</a>
               </h3>
               
               <pre><code>const readdirFileInfo</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="readdirName" data-name="readdirName">
               <h3>
                  readdirName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#readdirName" class="anchor" title="Link to readdirName">#</a>
               </h3>
               
               <pre><code>const readdirName readdirMode = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="rootMaxSymlinks" data-name="rootMaxSymlinks">
               <h3>
                  rootMaxSymlinks 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#rootMaxSymlinks" class="anchor" title="Link to rootMaxSymlinks">#</a>
               </h3>
               
               <p>Maximum number of symbolic links we will follow when resolving a file in a root.
8 is __POSIX_SYMLOOP_MAX (the minimum allowed value for SYMLOOP_MAX),
and a common limit.</p>
               
               <pre><code>const rootMaxSymlinks = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sizeOfDirent" data-name="sizeOfDirent">
               <h3>
                  sizeOfDirent 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sizeOfDirent" class="anchor" title="Link to sizeOfDirent">#</a>
               </h3>
               
               <p>https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md#-dirent-record</p>
               
               <pre><code>const sizeOfDirent = 24</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="statusDone" data-name="statusDone">
               <h3>
                  statusDone 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#statusDone" class="anchor" title="Link to statusDone">#</a>
               </h3>
               
               <p>statusDone indicates that the PID/handle should not be used because
the process is done (has been successfully Wait'd on).</p>
               
               <pre><code>const statusDone processStatus = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="statusOK" data-name="statusOK">
               <h3>
                  statusOK 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#statusOK" class="anchor" title="Link to statusOK">#</a>
               </h3>
               
               <p>PID/handle OK to use.</p>
               
               <pre><code>const statusOK processStatus = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="statusReleased" data-name="statusReleased">
               <h3>
                  statusReleased 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#statusReleased" class="anchor" title="Link to statusReleased">#</a>
               </h3>
               
               <p>statusReleased indicates that the PID/handle should not be used
because the process is released.</p>
               
               <pre><code>const statusReleased processStatus = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="supportsCloseOnExec" data-name="supportsCloseOnExec">
               <h3>
                  supportsCloseOnExec 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#supportsCloseOnExec" class="anchor" title="Link to supportsCloseOnExec">#</a>
               </h3>
               
               <p>supportsCloseOnExec reports whether the platform supports the
O_CLOEXEC flag.
On Darwin, the O_CLOEXEC flag was introduced in OS X 10.7 (Darwin 11.0.0).
See https://support.apple.com/kb/HT1633.
On FreeBSD, the O_CLOEXEC flag was introduced in version 8.3.</p>
               
               <pre><code>const supportsCloseOnExec = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="supportsCloseOnExec" data-name="supportsCloseOnExec">
               <h3>
                  supportsCloseOnExec 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#supportsCloseOnExec" class="anchor" title="Link to supportsCloseOnExec">#</a>
               </h3>
               
               <p>supportsCloseOnExec reports whether the platform supports the
O_CLOEXEC flag.</p>
               
               <pre><code>const supportsCloseOnExec = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="supportsCloseOnExec" data-name="supportsCloseOnExec">
               <h3>
                  supportsCloseOnExec 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#supportsCloseOnExec" class="anchor" title="Link to supportsCloseOnExec">#</a>
               </h3>
               
               <p>supportsCloseOnExec reports whether the platform supports the
O_CLOEXEC flag.</p>
               
               <pre><code>const supportsCloseOnExec = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="supportsCreateWithStickyBit" data-name="supportsCreateWithStickyBit">
               <h3>
                  supportsCreateWithStickyBit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#supportsCreateWithStickyBit" class="anchor" title="Link to supportsCreateWithStickyBit">#</a>
               </h3>
               
               <p>According to sticky(8), neither open(2) nor mkdir(2) will create
a file with the sticky bit set.</p>
               
               <pre><code>const supportsCreateWithStickyBit = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="supportsCreateWithStickyBit" data-name="supportsCreateWithStickyBit">
               <h3>
                  supportsCreateWithStickyBit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#supportsCreateWithStickyBit" class="anchor" title="Link to supportsCreateWithStickyBit">#</a>
               </h3>
               
               <pre><code>const supportsCreateWithStickyBit = true</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="testingForceReadDirLstat" data-name="testingForceReadDirLstat">
               <h3>
                  testingForceReadDirLstat 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#testingForceReadDirLstat" class="anchor" title="Link to testingForceReadDirLstat">#</a>
               </h3>
               
               <p>testingForceReadDirLstat forces ReadDir to call Lstat, for testing that code path.
This can be difficult to provoke on some Unix systems otherwise.</p>
               
               <pre><code>var testingForceReadDirLstat bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="useGetTempPath2" data-name="useGetTempPath2">
               <h3>
                  useGetTempPath2 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#useGetTempPath2" class="anchor" title="Link to useGetTempPath2">#</a>
               </h3>
               
               <pre><code>var useGetTempPath2 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="winreadlinkvolume" data-name="winreadlinkvolume">
               <h3>
                  winreadlinkvolume 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#winreadlinkvolume" class="anchor" title="Link to winreadlinkvolume">#</a>
               </h3>
               
               <pre><code>var winreadlinkvolume = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="winsymlink" data-name="winsymlink">
               <h3>
                  winsymlink 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#winsymlink" class="anchor" title="Link to winsymlink">#</a>
               </h3>
               
               <pre><code>var winsymlink = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="DirEntry" data-name="DirEntry">
               <h3>
                  DirEntry
                  <span class="badge type-badge">type</span>
                  <a href="#DirEntry" class="anchor" title="Link to DirEntry">#</a>
               </h3>
               
               <p>A DirEntry is an entry read from a directory
(using the [ReadDir] function or a [File.ReadDir] method).</p>
               
               <pre><code>type DirEntry fs.DirEntry</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="FileInfo" data-name="FileInfo">
               <h3>
                  FileInfo
                  <span class="badge type-badge">type</span>
                  <a href="#FileInfo" class="anchor" title="Link to FileInfo">#</a>
               </h3>
               
               <p>A FileInfo describes a file and is returned by [Stat] and [Lstat].</p>
               
               <pre><code>type FileInfo fs.FileInfo</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="FileMode" data-name="FileMode">
               <h3>
                  FileMode
                  <span class="badge type-badge">type</span>
                  <a href="#FileMode" class="anchor" title="Link to FileMode">#</a>
               </h3>
               
               <p>A FileMode represents a file's mode and permission bits.
The bits have the same definition on all systems, so that
information about files can be moved from one system
to another portably. Not all bits apply to all systems.
The only required bit is [ModeDir] for directories.</p>
               
               <pre><code>type FileMode fs.FileMode</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="PathError" data-name="PathError">
               <h3>
                  PathError
                  <span class="badge type-badge">type</span>
                  <a href="#PathError" class="anchor" title="Link to PathError">#</a>
               </h3>
               
               <p>PathError records an error and the operation and file path that caused it.</p>
               
               <pre><code>type PathError fs.PathError</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="dirFS" data-name="dirFS">
               <h3>
                  dirFS
                  <span class="badge type-badge">type</span>
                  <a href="#dirFS" class="anchor" title="Link to dirFS">#</a>
               </h3>
               
               <pre><code>type dirFS string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="errSymlink" data-name="errSymlink">
               <h3>
                  errSymlink
                  <span class="badge type-badge">type</span>
                  <a href="#errSymlink" class="anchor" title="Link to errSymlink">#</a>
               </h3>
               
               <p>errSymlink reports that a file being operated on is actually a symlink,
and the target of that symlink.</p>
               
               <pre><code>type errSymlink string</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="newFileKind" data-name="newFileKind">
               <h3>
                  newFileKind
                  <span class="badge type-badge">type</span>
                  <a href="#newFileKind" class="anchor" title="Link to newFileKind">#</a>
               </h3>
               
               <p>newFileKind describes the kind of file to newFile.</p>
               
               <pre><code>type newFileKind int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="processMode" data-name="processMode">
               <h3>
                  processMode
                  <span class="badge type-badge">type</span>
                  <a href="#processMode" class="anchor" title="Link to processMode">#</a>
               </h3>
               
               <pre><code>type processMode uint8</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="processStatus" data-name="processStatus">
               <h3>
                  processStatus
                  <span class="badge type-badge">type</span>
                  <a href="#processStatus" class="anchor" title="Link to processStatus">#</a>
               </h3>
               
               <pre><code>type processStatus uint64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="readdirMode" data-name="readdirMode">
               <h3>
                  readdirMode
                  <span class="badge type-badge">type</span>
                  <a href="#readdirMode" class="anchor" title="Link to readdirMode">#</a>
               </h3>
               
               <pre><code>type readdirMode int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="rootFS" data-name="rootFS">
               <h3>
                  rootFS
                  <span class="badge type-badge">type</span>
                  <a href="#rootFS" class="anchor" title="Link to rootFS">#</a>
               </h3>
               
               <pre><code>type rootFS Root</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="syscallErrorType" data-name="syscallErrorType">
               <h3>
                  syscallErrorType
                  <span class="badge type-badge">type</span>
                  <a href="#syscallErrorType" class="anchor" title="Link to syscallErrorType">#</a>
               </h3>
               
               <pre><code>type syscallErrorType syscall.Errno</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="syscallErrorType" data-name="syscallErrorType">
               <h3>
                  syscallErrorType
                  <span class="badge type-badge">type</span>
                  <a href="#syscallErrorType" class="anchor" title="Link to syscallErrorType">#</a>
               </h3>
               
               <pre><code>type syscallErrorType syscall.ErrorString</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="sysfdType" data-name="sysfdType">
               <h3>
                  sysfdType
                  <span class="badge type-badge">type</span>
                  <a href="#sysfdType" class="anchor" title="Link to sysfdType">#</a>
               </h3>
               
               <pre><code>type sysfdType syscall.Handle</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="sysfdType" data-name="sysfdType">
               <h3>
                  sysfdType
                  <span class="badge type-badge">type</span>
                  <a href="#sysfdType" class="anchor" title="Link to sysfdType">#</a>
               </h3>
               
               <pre><code>type sysfdType int</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="Signal" data-name="Signal">
               <h3>
                  Signal
                  <span class="badge interface-badge">interface</span>
                  <a href="#Signal" class="anchor" title="Link to Signal">#</a>
               </h3>
               
               <p>A Signal represents an operating system signal.
The usual underlying implementation is operating system-dependent:
on Unix it is syscall.Signal.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Signal interface {
String() string
Signal()
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="timeout" data-name="timeout">
               <h3>
                  timeout
                  <span class="badge interface-badge">interface</span>
                  <a href="#timeout" class="anchor" title="Link to timeout">#</a>
               </h3>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type timeout interface {
Timeout() bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="File" data-name="File">
               <h3>
                  File
                  <span class="badge">struct</span>
                  <a href="#File" class="anchor" title="Link to File">#</a>
               </h3>
               
               <p>File represents an open file descriptor.
The methods of File are safe for concurrent use.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type File struct {
*file
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="LinkError" data-name="LinkError">
               <h3>
                  LinkError
                  <span class="badge">struct</span>
                  <a href="#LinkError" class="anchor" title="Link to LinkError">#</a>
               </h3>
               
               <p>LinkError records an error during a link or symlink or rename
system call and the paths that caused it.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type LinkError struct {
Op string
Old string
New string
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ProcAttr" data-name="ProcAttr">
               <h3>
                  ProcAttr
                  <span class="badge">struct</span>
                  <a href="#ProcAttr" class="anchor" title="Link to ProcAttr">#</a>
               </h3>
               
               <p>ProcAttr holds the attributes that will be applied to a new process
started by StartProcess.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ProcAttr struct {
Dir string
Env []string
Files []*File
Sys *syscall.SysProcAttr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Process" data-name="Process">
               <h3>
                  Process
                  <span class="badge">struct</span>
                  <a href="#Process" class="anchor" title="Link to Process">#</a>
               </h3>
               
               <p>Process stores the information about a process created by [StartProcess].</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Process struct {
Pid int
mode processMode
state atomic.Uint64
sigMu sync.RWMutex
handle uintptr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ProcessState" data-name="ProcessState">
               <h3>
                  ProcessState
                  <span class="badge">struct</span>
                  <a href="#ProcessState" class="anchor" title="Link to ProcessState">#</a>
               </h3>
               
               <p>ProcessState stores information about a process, as reported by Wait.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ProcessState struct {
pid int
status syscall.WaitStatus
rusage *syscall.Rusage
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ProcessState" data-name="ProcessState">
               <h3>
                  ProcessState
                  <span class="badge">struct</span>
                  <a href="#ProcessState" class="anchor" title="Link to ProcessState">#</a>
               </h3>
               
               <p>ProcessState stores information about a process, as reported by Wait.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ProcessState struct {
pid int
status *syscall.Waitmsg
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Root" data-name="Root">
               <h3>
                  Root
                  <span class="badge">struct</span>
                  <a href="#Root" class="anchor" title="Link to Root">#</a>
               </h3>
               
               <p>Root may be used to only access files within a single directory tree.
Methods on Root can only access files and directories beneath a root directory.
If any component of a file name passed to a method of Root references a location
outside the root, the method returns an error.
File names may reference the directory itself (.).
Methods on Root will follow symbolic links, but symbolic links may not
reference a location outside the root.
Symbolic links must not be absolute.
Methods on Root do not prohibit traversal of filesystem boundaries,
Linux bind mounts, /proc special files, or access to Unix device files.
Methods on Root are safe to be used from multiple goroutines simultaneously.
On most platforms, creating a Root opens a file descriptor or handle referencing
the directory. If the directory is moved, methods on Root reference the original
directory in its new location.
Root's behavior differs on some platforms:
- When GOOS=windows, file names may not reference Windows reserved device names
such as NUL and COM1.
- When GOOS=js, Root is vulnerable to TOCTOU (time-of-check-time-of-use)
attacks in symlink validation, and cannot ensure that operations will not
escape the root.
- When GOOS=plan9 or GOOS=js, Root does not track directories across renames.
On these platforms, a Root references a directory name, not a file descriptor.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Root struct {
root *root
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="SyscallError" data-name="SyscallError">
               <h3>
                  SyscallError
                  <span class="badge">struct</span>
                  <a href="#SyscallError" class="anchor" title="Link to SyscallError">#</a>
               </h3>
               
               <p>SyscallError records an error from a specific system call.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type SyscallError struct {
Syscall string
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dirEntry" data-name="dirEntry">
               <h3>
                  dirEntry
                  <span class="badge">struct</span>
                  <a href="#dirEntry" class="anchor" title="Link to dirEntry">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dirEntry struct {
fs *fileStat
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dirEntry" data-name="dirEntry">
               <h3>
                  dirEntry
                  <span class="badge">struct</span>
                  <a href="#dirEntry" class="anchor" title="Link to dirEntry">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dirEntry struct {
fs *fileStat
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dirInfo" data-name="dirInfo">
               <h3>
                  dirInfo
                  <span class="badge">struct</span>
                  <a href="#dirInfo" class="anchor" title="Link to dirInfo">#</a>
               </h3>
               
               <p>Auxiliary information if the File describes a directory</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dirInfo struct {
mu sync.Mutex
buf *[]byte
nbuf int
bufp int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dirInfo" data-name="dirInfo">
               <h3>
                  dirInfo
                  <span class="badge">struct</span>
                  <a href="#dirInfo" class="anchor" title="Link to dirInfo">#</a>
               </h3>
               
               <p>Auxiliary information if the File describes a directory</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dirInfo struct {
mu sync.Mutex
buf [syscall.STATMAX]byte
nbuf int
bufp int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dirInfo" data-name="dirInfo">
               <h3>
                  dirInfo
                  <span class="badge">struct</span>
                  <a href="#dirInfo" class="anchor" title="Link to dirInfo">#</a>
               </h3>
               
               <p>Auxiliary information if the File describes a directory</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dirInfo struct {
dir uintptr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dirInfo" data-name="dirInfo">
               <h3>
                  dirInfo
                  <span class="badge">struct</span>
                  <a href="#dirInfo" class="anchor" title="Link to dirInfo">#</a>
               </h3>
               
               <p>Auxiliary information if the File describes a directory</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dirInfo struct {
mu sync.Mutex
buf *[]byte
bufp int
h syscall.Handle
vol uint32
class uint32
path string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="file" data-name="file">
               <h3>
                  file
                  <span class="badge">struct</span>
                  <a href="#file" class="anchor" title="Link to file">#</a>
               </h3>
               
               <p>file is the real representation of *File.
The extra level of indirection ensures that no clients of os
can overwrite this data, which could cause the finalizer
to close the wrong file descriptor.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type file struct {
pfd poll.FD
name string
dirinfo *ast.IndexExpr
nonblock bool
stdoutOrErr bool
appendMode bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="file" data-name="file">
               <h3>
                  file
                  <span class="badge">struct</span>
                  <a href="#file" class="anchor" title="Link to file">#</a>
               </h3>
               
               <p>file is the real representation of *File.
The extra level of indirection ensures that no clients of os
can overwrite this data, which could cause the finalizer
to close the wrong file descriptor.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type file struct {
pfd poll.FD
name string
dirinfo *ast.IndexExpr
appendMode bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="file" data-name="file">
               <h3>
                  file
                  <span class="badge">struct</span>
                  <a href="#file" class="anchor" title="Link to file">#</a>
               </h3>
               
               <p>file is the real representation of *File.
The extra level of indirection ensures that no clients of os
can overwrite this data, which could cause the finalizer
to close the wrong file descriptor.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type file struct {
fdmu poll.FDMutex
fd int
name string
dirinfo *ast.IndexExpr
appendMode bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileStat" data-name="fileStat">
               <h3>
                  fileStat
                  <span class="badge">struct</span>
                  <a href="#fileStat" class="anchor" title="Link to fileStat">#</a>
               </h3>
               
               <p>A fileStat is the implementation of FileInfo returned by Stat and Lstat.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileStat struct {
name string
size int64
mode FileMode
modTime time.Time
sys any
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileStat" data-name="fileStat">
               <h3>
                  fileStat
                  <span class="badge">struct</span>
                  <a href="#fileStat" class="anchor" title="Link to fileStat">#</a>
               </h3>
               
               <p>A fileStat is the implementation of FileInfo returned by Stat and Lstat.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileStat struct {
name string
FileAttributes uint32
CreationTime syscall.Filetime
LastAccessTime syscall.Filetime
LastWriteTime syscall.Filetime
FileSizeHigh uint32
FileSizeLow uint32
ReparseTag uint32
filetype uint32
sync.Mutex
path string
vol uint32
idxhi uint32
idxlo uint32
appendNameToPath bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileStat" data-name="fileStat">
               <h3>
                  fileStat
                  <span class="badge">struct</span>
                  <a href="#fileStat" class="anchor" title="Link to fileStat">#</a>
               </h3>
               
               <p>A fileStat is the implementation of FileInfo returned by Stat and Lstat.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileStat struct {
name string
size int64
mode FileMode
modTime time.Time
sys syscall.Stat_t
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileWithoutReadFrom" data-name="fileWithoutReadFrom">
               <h3>
                  fileWithoutReadFrom
                  <span class="badge">struct</span>
                  <a href="#fileWithoutReadFrom" class="anchor" title="Link to fileWithoutReadFrom">#</a>
               </h3>
               
               <p>fileWithoutReadFrom implements all the methods of *File other
than ReadFrom. This is used to permit ReadFrom to call io.Copy
without leading to a recursive call to ReadFrom.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileWithoutReadFrom struct {
noReadFrom
*File
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileWithoutWriteTo" data-name="fileWithoutWriteTo">
               <h3>
                  fileWithoutWriteTo
                  <span class="badge">struct</span>
                  <a href="#fileWithoutWriteTo" class="anchor" title="Link to fileWithoutWriteTo">#</a>
               </h3>
               
               <p>fileWithoutWriteTo implements all the methods of *File other
than WriteTo. This is used to permit WriteTo to call io.Copy
without leading to a recursive call to WriteTo.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileWithoutWriteTo struct {
noWriteTo
*File
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="noReadFrom" data-name="noReadFrom">
               <h3>
                  noReadFrom
                  <span class="badge">struct</span>
                  <a href="#noReadFrom" class="anchor" title="Link to noReadFrom">#</a>
               </h3>
               
               <p>noReadFrom can be embedded alongside another type to
hide the ReadFrom method of that other type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type noReadFrom struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="noWriteTo" data-name="noWriteTo">
               <h3>
                  noWriteTo
                  <span class="badge">struct</span>
                  <a href="#noWriteTo" class="anchor" title="Link to noWriteTo">#</a>
               </h3>
               
               <p>noWriteTo can be embedded alongside another type to
hide the WriteTo method of that other type.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type noWriteTo struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="rawConn" data-name="rawConn">
               <h3>
                  rawConn
                  <span class="badge">struct</span>
                  <a href="#rawConn" class="anchor" title="Link to rawConn">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rawConn struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="rawConn" data-name="rawConn">
               <h3>
                  rawConn
                  <span class="badge">struct</span>
                  <a href="#rawConn" class="anchor" title="Link to rawConn">#</a>
               </h3>
               
               <p>rawConn implements syscall.RawConn.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rawConn struct {
file *File
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="root" data-name="root">
               <h3>
                  root
                  <span class="badge">struct</span>
                  <a href="#root" class="anchor" title="Link to root">#</a>
               </h3>
               
               <p>root implementation for platforms with no openat.
Currently plan9 and js.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type root struct {
name string
closed atomic.Bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="root" data-name="root">
               <h3>
                  root
                  <span class="badge">struct</span>
                  <a href="#root" class="anchor" title="Link to root">#</a>
               </h3>
               
               <p>root implementation for platforms with a function to open a file
relative to a directory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type root struct {
name string
mu sync.Mutex
fd sysfdType
refs int
closed bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="unixDirent" data-name="unixDirent">
               <h3>
                  unixDirent
                  <span class="badge">struct</span>
                  <a href="#unixDirent" class="anchor" title="Link to unixDirent">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type unixDirent struct {
parent string
name string
typ FileMode
info FileInfo
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Chdir" data-name="Chdir">
               <h3>
                  Chdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Chdir" class="anchor" title="Link to Chdir">#</a>
               </h3>
               
               <p>Chdir changes the current working directory to the file,
which must be a directory.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func (f *File) Chdir() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chdir" data-name="Chdir">
               <h3>
                  Chdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Chdir" class="anchor" title="Link to Chdir">#</a>
               </h3>
               
               <p>Chdir changes the current working directory to the file,
which must be a directory.
If there is an error, it will be of type [*PathError].</p>
               
               <pre><code>func (f *File) Chdir() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chdir" data-name="Chdir">
               <h3>
                  Chdir 
                  <span class="badge">function</span>
                  
                  <a href="#Chdir" class="anchor" title="Link to Chdir">#</a>
               </h3>
               
               <p>Chdir changes the current working directory to the named directory.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func Chdir(dir string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chmod" data-name="Chmod">
               <h3>
                  Chmod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Chmod" class="anchor" title="Link to Chmod">#</a>
               </h3>
               
               <p>Chmod changes the mode of the file to mode.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func (f *File) Chmod(mode FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chmod" data-name="Chmod">
               <h3>
                  Chmod 
                  <span class="badge">function</span>
                  
                  <a href="#Chmod" class="anchor" title="Link to Chmod">#</a>
               </h3>
               
               <p>Chmod changes the mode of the named file to mode.
If the file is a symbolic link, it changes the mode of the link's target.
If there is an error, it will be of type *PathError.
A different subset of the mode bits are used, depending on the
operating system.
On Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and
ModeSticky are used.
On Windows, only the 0o200 bit (owner writable) of mode is used; it
controls whether the file's read-only attribute is set or cleared.
The other bits are currently unused. For compatibility with Go 1.12
and earlier, use a non-zero mode. Use mode 0o400 for a read-only
file and 0o600 for a readable+writable file.
On Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,
and ModeTemporary are used.</p>
               
               <pre><code>func Chmod(name string, mode FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chown" data-name="Chown">
               <h3>
                  Chown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Chown" class="anchor" title="Link to Chown">#</a>
               </h3>
               
               <p>Chown changes the numeric uid and gid of the named file.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func (f *File) Chown(uid int, gid int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chown" data-name="Chown">
               <h3>
                  Chown 
                  <span class="badge">function</span>
                  
                  <a href="#Chown" class="anchor" title="Link to Chown">#</a>
               </h3>
               
               <p>Chown changes the numeric uid and gid of the named file.
If the file is a symbolic link, it changes the uid and gid of the link's target.
A uid or gid of -1 means to not change that value.
If there is an error, it will be of type *PathError.
On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or
EPLAN9 error, wrapped in *PathError.</p>
               
               <pre><code>func Chown(name string, uid int, gid int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chown" data-name="Chown">
               <h3>
                  Chown 
                  <span class="badge">function</span>
                  
                  <a href="#Chown" class="anchor" title="Link to Chown">#</a>
               </h3>
               
               <p>Chown changes the numeric uid and gid of the named file.
If the file is a symbolic link, it changes the uid and gid of the link's target.
A uid or gid of -1 means to not change that value.
If there is an error, it will be of type [*PathError].
On Windows or Plan 9, Chown always returns the [syscall.EWINDOWS] or
EPLAN9 error, wrapped in *PathError.</p>
               
               <pre><code>func Chown(name string, uid int, gid int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chown" data-name="Chown">
               <h3>
                  Chown 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Chown" class="anchor" title="Link to Chown">#</a>
               </h3>
               
               <p>Chown changes the numeric uid and gid of the named file.
If there is an error, it will be of type [*PathError].
On Windows, it always returns the [syscall.EWINDOWS] error, wrapped
in *PathError.</p>
               
               <pre><code>func (f *File) Chown(uid int, gid int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chtimes" data-name="Chtimes">
               <h3>
                  Chtimes 
                  <span class="badge">function</span>
                  
                  <a href="#Chtimes" class="anchor" title="Link to Chtimes">#</a>
               </h3>
               
               <p>Chtimes changes the access and modification times of the named
file, similar to the Unix utime() or utimes() functions.
A zero time.Time value will leave the corresponding file time unchanged.
The underlying filesystem may truncate or round the values to a
less precise time unit.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func Chtimes(name string, atime time.Time, mtime time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Chtimes" data-name="Chtimes">
               <h3>
                  Chtimes 
                  <span class="badge">function</span>
                  
                  <a href="#Chtimes" class="anchor" title="Link to Chtimes">#</a>
               </h3>
               
               <p>Chtimes changes the access and modification times of the named
file, similar to the Unix utime() or utimes() functions.
A zero [time.Time] value will leave the corresponding file time unchanged.
The underlying filesystem may truncate or round the values to a
less precise time unit.
If there is an error, it will be of type [*PathError].</p>
               
               <pre><code>func Chtimes(name string, atime time.Time, mtime time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Clearenv" data-name="Clearenv">
               <h3>
                  Clearenv 
                  <span class="badge">function</span>
                  
                  <a href="#Clearenv" class="anchor" title="Link to Clearenv">#</a>
               </h3>
               
               <p>Clearenv deletes all environment variables.</p>
               
               <pre><code>func Clearenv()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the [File], rendering it unusable for I/O.
On files that support [File.SetDeadline], any pending I/O operations will
be canceled and return immediately with an [ErrClosed] error.
Close will return an error if it has already been called.</p>
               
               <pre><code>func (f *File) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (r *root) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the Root.
After Close is called, methods on Root return errors.</p>
               
               <pre><code>func (r *Root) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the File, rendering it unusable for I/O.
On files that support SetDeadline, any pending I/O operations will
be canceled and return immediately with an ErrClosed error.
Close will return an error if it has already been called.</p>
               
               <pre><code>func (f *File) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <pre><code>func (r *root) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Control" data-name="Control">
               <h3>
                  Control 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Control" class="anchor" title="Link to Control">#</a>
               </h3>
               
               <pre><code>func (c *rawConn) Control(f func(uintptr)) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Control" data-name="Control">
               <h3>
                  Control 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Control" class="anchor" title="Link to Control">#</a>
               </h3>
               
               <pre><code>func (c *rawConn) Control(f func(uintptr)) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CopyFS" data-name="CopyFS">
               <h3>
                  CopyFS 
                  <span class="badge">function</span>
                  
                  <a href="#CopyFS" class="anchor" title="Link to CopyFS">#</a>
               </h3>
               
               <p>CopyFS copies the file system fsys into the directory dir,
creating dir if necessary.
Files are created with mode 0o666 plus any execute permissions
from the source, and directories are created with mode 0o777
(before umask).
CopyFS will not overwrite existing files. If a file name in fsys
already exists in the destination, CopyFS will return an error
such that errors.Is(err, fs.ErrExist) will be true.
Symbolic links in fsys are not supported. A *PathError with Err set
to ErrInvalid is returned when copying from a symbolic link.
Symbolic links in dir are followed.
New files added to fsys (including if dir is a subdirectory of fsys)
while CopyFS is running are not guaranteed to be copied.
Copying stops at and returns the first error encountered.</p>
               
               <pre><code>func CopyFS(dir string, fsys fs.FS) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Create" data-name="Create">
               <h3>
                  Create 
                  <span class="badge">function</span>
                  
                  <a href="#Create" class="anchor" title="Link to Create">#</a>
               </h3>
               
               <p>Create creates or truncates the named file. If the file already exists,
it is truncated. If the file does not exist, it is created with mode 0o666
(before umask). If successful, methods on the returned File can
be used for I/O; the associated file descriptor has mode O_RDWR.
The directory containing the file must already exist.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func Create(name string) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Create" data-name="Create">
               <h3>
                  Create 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Create" class="anchor" title="Link to Create">#</a>
               </h3>
               
               <p>Create creates or truncates the named file in the root.
See [Create] for more details.</p>
               
               <pre><code>func (r *Root) Create(name string) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CreateTemp" data-name="CreateTemp">
               <h3>
                  CreateTemp 
                  <span class="badge">function</span>
                  
                  <a href="#CreateTemp" class="anchor" title="Link to CreateTemp">#</a>
               </h3>
               
               <p>CreateTemp creates a new temporary file in the directory dir,
opens the file for reading and writing, and returns the resulting file.
The filename is generated by taking pattern and adding a random string to the end.
If pattern includes a "*", the random string replaces the last "*".
The file is created with mode 0o600 (before umask).
If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by [TempDir].
Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file.
The caller can use the file's Name method to find the pathname of the file.
It is the caller's responsibility to remove the file when it is no longer needed.</p>
               
               <pre><code>func CreateTemp(dir string, pattern string) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="DirFS" data-name="DirFS">
               <h3>
                  DirFS 
                  <span class="badge">function</span>
                  
                  <a href="#DirFS" class="anchor" title="Link to DirFS">#</a>
               </h3>
               
               <p>DirFS returns a file system (an fs.FS) for the tree of files rooted at the directory dir.
Note that DirFS("/prefix") only guarantees that the Open calls it makes to the
operating system will begin with "/prefix": DirFS("/prefix").Open("file") is the
same as os.Open("/prefix/file"). So if /prefix/file is a symbolic link pointing outside
the /prefix tree, then using DirFS does not stop the access any more than using
os.Open does. Additionally, the root of the fs.FS returned for a relative path,
DirFS("prefix"), will be affected by later calls to Chdir. DirFS is therefore not
a general substitute for a chroot-style security mechanism when the directory tree
contains arbitrary content.
Use [Root.FS] to obtain a fs.FS that prevents escapes from the tree via symbolic links.
The directory dir must not be "".
The result implements [io/fs.StatFS], [io/fs.ReadFileFS] and
[io/fs.ReadDirFS].</p>
               
               <pre><code>func DirFS(dir string) fs.FS</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Environ" data-name="Environ">
               <h3>
                  Environ 
                  <span class="badge">function</span>
                  
                  <a href="#Environ" class="anchor" title="Link to Environ">#</a>
               </h3>
               
               <p>Environ returns a copy of strings representing the environment,
in the form "key=value".</p>
               
               <pre><code>func Environ() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (errSymlink) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *SyscallError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *LinkError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Executable" data-name="Executable">
               <h3>
                  Executable 
                  <span class="badge">function</span>
                  
                  <a href="#Executable" class="anchor" title="Link to Executable">#</a>
               </h3>
               
               <p>Executable returns the path name for the executable that started
the current process. There is no guarantee that the path is still
pointing to the correct executable. If a symlink was used to start
the process, depending on the operating system, the result might
be the symlink or the path it pointed to. If a stable result is
needed, [path/filepath.EvalSymlinks] might help.
Executable returns an absolute path unless an error occurred.
The main use case is finding resources located relative to an
executable.</p>
               
               <pre><code>func Executable() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Exit" data-name="Exit">
               <h3>
                  Exit 
                  <span class="badge">function</span>
                  
                  <a href="#Exit" class="anchor" title="Link to Exit">#</a>
               </h3>
               
               <p>Exit causes the current program to exit with the given status code.
Conventionally, code zero indicates success, non-zero an error.
The program terminates immediately; deferred functions are not run.
For portability, the status code should be in the range [0, 125].</p>
               
               <pre><code>func Exit(code int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExitCode" data-name="ExitCode">
               <h3>
                  ExitCode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ExitCode" class="anchor" title="Link to ExitCode">#</a>
               </h3>
               
               <p>ExitCode returns the exit code of the exited process, or -1
if the process hasn't exited or was terminated by a signal.</p>
               
               <pre><code>func (p *ProcessState) ExitCode() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExitCode" data-name="ExitCode">
               <h3>
                  ExitCode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ExitCode" class="anchor" title="Link to ExitCode">#</a>
               </h3>
               
               <p>ExitCode returns the exit code of the exited process, or -1
if the process hasn't exited or was terminated by a signal.</p>
               
               <pre><code>func (p *ProcessState) ExitCode() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Exited" data-name="Exited">
               <h3>
                  Exited 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Exited" class="anchor" title="Link to Exited">#</a>
               </h3>
               
               <p>Exited reports whether the program has exited.
On Unix systems this reports true if the program exited due to calling exit,
but false if the program terminated due to a signal.</p>
               
               <pre><code>func (p *ProcessState) Exited() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Expand" data-name="Expand">
               <h3>
                  Expand 
                  <span class="badge">function</span>
                  
                  <a href="#Expand" class="anchor" title="Link to Expand">#</a>
               </h3>
               
               <p>Expand replaces ${var} or $var in the string based on the mapping function.
For example, [os.ExpandEnv](s) is equivalent to [os.Expand](s, [os.Getenv]).</p>
               
               <pre><code>func Expand(s string, mapping func(string) string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExpandEnv" data-name="ExpandEnv">
               <h3>
                  ExpandEnv 
                  <span class="badge">function</span>
                  
                  <a href="#ExpandEnv" class="anchor" title="Link to ExpandEnv">#</a>
               </h3>
               
               <p>ExpandEnv replaces ${var} or $var in the string according to the values
of the current environment variables. References to undefined
variables are replaced by the empty string.</p>
               
               <pre><code>func ExpandEnv(s string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FS" data-name="FS">
               <h3>
                  FS 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FS" class="anchor" title="Link to FS">#</a>
               </h3>
               
               <p>FS returns a file system (an fs.FS) for the tree of files in the root.
The result implements [io/fs.StatFS], [io/fs.ReadFileFS] and
[io/fs.ReadDirFS].</p>
               
               <pre><code>func (r *Root) FS() fs.FS</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fd" data-name="Fd">
               <h3>
                  Fd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fd" class="anchor" title="Link to Fd">#</a>
               </h3>
               
               <p>Fd returns the integer Plan 9 file descriptor referencing the open file.
If f is closed, the file descriptor becomes invalid.
If f is garbage collected, a finalizer may close the file descriptor,
making it invalid; see [runtime.SetFinalizer] for more information on when
a finalizer might be run. On Unix systems this will cause the [File.SetDeadline]
methods to stop working.
As an alternative, see the f.SyscallConn method.</p>
               
               <pre><code>func (f *File) Fd() uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fd" data-name="Fd">
               <h3>
                  Fd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fd" class="anchor" title="Link to Fd">#</a>
               </h3>
               
               <p>Fd returns the Windows handle referencing the open file.
If f is closed, the file descriptor becomes invalid.
If f is garbage collected, a finalizer may close the file descriptor,
making it invalid; see [runtime.SetFinalizer] for more information on when
a finalizer might be run. On Unix systems this will cause the [File.SetDeadline]
methods to stop working.</p>
               
               <pre><code>func (file *File) Fd() uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Fd" data-name="Fd">
               <h3>
                  Fd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Fd" class="anchor" title="Link to Fd">#</a>
               </h3>
               
               <p>Fd returns the integer Unix file descriptor referencing the open file.
If f is closed, the file descriptor becomes invalid.
If f is garbage collected, a finalizer may close the file descriptor,
making it invalid; see [runtime.SetFinalizer] for more information on when
a finalizer might be run. On Unix systems this will cause the [File.SetDeadline]
methods to stop working.
Because file descriptors can be reused, the returned file descriptor may
only be closed through the [File.Close] method of f, or by its finalizer during
garbage collection. Otherwise, during garbage collection the finalizer
may close an unrelated file descriptor with the same (reused) number.
As an alternative, see the f.SyscallConn method.</p>
               
               <pre><code>func (f *File) Fd() uintptr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FindProcess" data-name="FindProcess">
               <h3>
                  FindProcess 
                  <span class="badge">function</span>
                  
                  <a href="#FindProcess" class="anchor" title="Link to FindProcess">#</a>
               </h3>
               
               <p>FindProcess looks for a running process by its pid.
The [Process] it returns can be used to obtain information
about the underlying operating system process.
On Unix systems, FindProcess always succeeds and returns a Process
for the given pid, regardless of whether the process exists. To test whether
the process actually exists, see whether p.Signal(syscall.Signal(0)) reports
an error.</p>
               
               <pre><code>func FindProcess(pid int) (*Process, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Getegid" data-name="Getegid">
               <h3>
                  Getegid 
                  <span class="badge">function</span>
                  
                  <a href="#Getegid" class="anchor" title="Link to Getegid">#</a>
               </h3>
               
               <p>Getegid returns the numeric effective group id of the caller.
On Windows, it returns -1.</p>
               
               <pre><code>func Getegid() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Getenv" data-name="Getenv">
               <h3>
                  Getenv 
                  <span class="badge">function</span>
                  
                  <a href="#Getenv" class="anchor" title="Link to Getenv">#</a>
               </h3>
               
               <p>Getenv retrieves the value of the environment variable named by the key.
It returns the value, which will be empty if the variable is not present.
To distinguish between an empty value and an unset value, use [LookupEnv].</p>
               
               <pre><code>func Getenv(key string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Geteuid" data-name="Geteuid">
               <h3>
                  Geteuid 
                  <span class="badge">function</span>
                  
                  <a href="#Geteuid" class="anchor" title="Link to Geteuid">#</a>
               </h3>
               
               <p>Geteuid returns the numeric effective user id of the caller.
On Windows, it returns -1.</p>
               
               <pre><code>func Geteuid() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Getgid" data-name="Getgid">
               <h3>
                  Getgid 
                  <span class="badge">function</span>
                  
                  <a href="#Getgid" class="anchor" title="Link to Getgid">#</a>
               </h3>
               
               <p>Getgid returns the numeric group id of the caller.
On Windows, it returns -1.</p>
               
               <pre><code>func Getgid() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Getgroups" data-name="Getgroups">
               <h3>
                  Getgroups 
                  <span class="badge">function</span>
                  
                  <a href="#Getgroups" class="anchor" title="Link to Getgroups">#</a>
               </h3>
               
               <p>Getgroups returns a list of the numeric ids of groups that the caller belongs to.
On Windows, it returns [syscall.EWINDOWS]. See the [os/user] package
for a possible alternative.</p>
               
               <pre><code>func Getgroups() ([]int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Getpagesize" data-name="Getpagesize">
               <h3>
                  Getpagesize 
                  <span class="badge">function</span>
                  
                  <a href="#Getpagesize" class="anchor" title="Link to Getpagesize">#</a>
               </h3>
               
               <p>Getpagesize returns the underlying system's memory page size.</p>
               
               <pre><code>func Getpagesize() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Getpid" data-name="Getpid">
               <h3>
                  Getpid 
                  <span class="badge">function</span>
                  
                  <a href="#Getpid" class="anchor" title="Link to Getpid">#</a>
               </h3>
               
               <p>Getpid returns the process id of the caller.</p>
               
               <pre><code>func Getpid() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Getppid" data-name="Getppid">
               <h3>
                  Getppid 
                  <span class="badge">function</span>
                  
                  <a href="#Getppid" class="anchor" title="Link to Getppid">#</a>
               </h3>
               
               <p>Getppid returns the process id of the caller's parent.</p>
               
               <pre><code>func Getppid() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Getuid" data-name="Getuid">
               <h3>
                  Getuid 
                  <span class="badge">function</span>
                  
                  <a href="#Getuid" class="anchor" title="Link to Getuid">#</a>
               </h3>
               
               <p>Getuid returns the numeric user id of the caller.
On Windows, it returns -1.</p>
               
               <pre><code>func Getuid() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Getwd" data-name="Getwd">
               <h3>
                  Getwd 
                  <span class="badge">function</span>
                  
                  <a href="#Getwd" class="anchor" title="Link to Getwd">#</a>
               </h3>
               
               <p>Getwd returns an absolute path name corresponding to the
current directory. If the current directory can be
reached via multiple paths (due to symbolic links),
Getwd may return any one of them.
On Unix platforms, if the environment variable PWD
provides an absolute name, and it is a name of the
current directory, it is returned.</p>
               
               <pre><code>func Getwd() (dir string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Hostname" data-name="Hostname">
               <h3>
                  Hostname 
                  <span class="badge">function</span>
                  
                  <a href="#Hostname" class="anchor" title="Link to Hostname">#</a>
               </h3>
               
               <p>Hostname returns the host name reported by the kernel.</p>
               
               <pre><code>func Hostname() (name string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Info" data-name="Info">
               <h3>
                  Info 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Info" class="anchor" title="Link to Info">#</a>
               </h3>
               
               <pre><code>func (de dirEntry) Info() (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Info" data-name="Info">
               <h3>
                  Info 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Info" class="anchor" title="Link to Info">#</a>
               </h3>
               
               <pre><code>func (d *unixDirent) Info() (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Info" data-name="Info">
               <h3>
                  Info 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Info" class="anchor" title="Link to Info">#</a>
               </h3>
               
               <pre><code>func (de dirEntry) Info() (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDir" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDir" class="anchor" title="Link to IsDir">#</a>
               </h3>
               
               <pre><code>func (de dirEntry) IsDir() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDir" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDir" class="anchor" title="Link to IsDir">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) IsDir() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDir" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDir" class="anchor" title="Link to IsDir">#</a>
               </h3>
               
               <pre><code>func (d *unixDirent) IsDir() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDir" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDir" class="anchor" title="Link to IsDir">#</a>
               </h3>
               
               <pre><code>func (de dirEntry) IsDir() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsExist" data-name="IsExist">
               <h3>
                  IsExist 
                  <span class="badge">function</span>
                  
                  <a href="#IsExist" class="anchor" title="Link to IsExist">#</a>
               </h3>
               
               <p>IsExist returns a boolean indicating whether its argument is known to report
that a file or directory already exists. It is satisfied by [ErrExist] as
well as some syscall errors.
This function predates [errors.Is]. It only supports errors returned by
the os package. New code should use errors.Is(err, fs.ErrExist).</p>
               
               <pre><code>func IsExist(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsNotExist" data-name="IsNotExist">
               <h3>
                  IsNotExist 
                  <span class="badge">function</span>
                  
                  <a href="#IsNotExist" class="anchor" title="Link to IsNotExist">#</a>
               </h3>
               
               <p>IsNotExist returns a boolean indicating whether its argument is known to
report that a file or directory does not exist. It is satisfied by
[ErrNotExist] as well as some syscall errors.
This function predates [errors.Is]. It only supports errors returned by
the os package. New code should use errors.Is(err, fs.ErrNotExist).</p>
               
               <pre><code>func IsNotExist(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsPathSeparator" data-name="IsPathSeparator">
               <h3>
                  IsPathSeparator 
                  <span class="badge">function</span>
                  
                  <a href="#IsPathSeparator" class="anchor" title="Link to IsPathSeparator">#</a>
               </h3>
               
               <p>IsPathSeparator reports whether c is a directory separator character.</p>
               
               <pre><code>func IsPathSeparator(c uint8) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsPathSeparator" data-name="IsPathSeparator">
               <h3>
                  IsPathSeparator 
                  <span class="badge">function</span>
                  
                  <a href="#IsPathSeparator" class="anchor" title="Link to IsPathSeparator">#</a>
               </h3>
               
               <p>IsPathSeparator reports whether c is a directory separator character.</p>
               
               <pre><code>func IsPathSeparator(c uint8) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsPathSeparator" data-name="IsPathSeparator">
               <h3>
                  IsPathSeparator 
                  <span class="badge">function</span>
                  
                  <a href="#IsPathSeparator" class="anchor" title="Link to IsPathSeparator">#</a>
               </h3>
               
               <p>IsPathSeparator reports whether c is a directory separator character.</p>
               
               <pre><code>func IsPathSeparator(c uint8) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsPermission" data-name="IsPermission">
               <h3>
                  IsPermission 
                  <span class="badge">function</span>
                  
                  <a href="#IsPermission" class="anchor" title="Link to IsPermission">#</a>
               </h3>
               
               <p>IsPermission returns a boolean indicating whether its argument is known to
report that permission is denied. It is satisfied by [ErrPermission] as well
as some syscall errors.
This function predates [errors.Is]. It only supports errors returned by
the os package. New code should use errors.Is(err, fs.ErrPermission).</p>
               
               <pre><code>func IsPermission(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsTimeout" data-name="IsTimeout">
               <h3>
                  IsTimeout 
                  <span class="badge">function</span>
                  
                  <a href="#IsTimeout" class="anchor" title="Link to IsTimeout">#</a>
               </h3>
               
               <p>IsTimeout returns a boolean indicating whether its argument is known
to report that a timeout occurred.
This function predates [errors.Is], and the notion of whether an
error indicates a timeout can be ambiguous. For example, the Unix
error EWOULDBLOCK sometimes indicates a timeout and sometimes does not.
New code should use errors.Is with a value appropriate to the call
returning the error, such as [os.ErrDeadlineExceeded].</p>
               
               <pre><code>func IsTimeout(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Kill" data-name="Kill">
               <h3>
                  Kill 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Kill" class="anchor" title="Link to Kill">#</a>
               </h3>
               
               <p>Kill causes the [Process] to exit immediately. Kill does not wait until
the Process has actually exited. This only kills the Process itself,
not any other processes it may have started.</p>
               
               <pre><code>func (p *Process) Kill() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lchown" data-name="Lchown">
               <h3>
                  Lchown 
                  <span class="badge">function</span>
                  
                  <a href="#Lchown" class="anchor" title="Link to Lchown">#</a>
               </h3>
               
               <p>Lchown changes the numeric uid and gid of the named file.
If the file is a symbolic link, it changes the uid and gid of the link itself.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func Lchown(name string, uid int, gid int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lchown" data-name="Lchown">
               <h3>
                  Lchown 
                  <span class="badge">function</span>
                  
                  <a href="#Lchown" class="anchor" title="Link to Lchown">#</a>
               </h3>
               
               <p>Lchown changes the numeric uid and gid of the named file.
If the file is a symbolic link, it changes the uid and gid of the link itself.
If there is an error, it will be of type [*PathError].
On Windows, it always returns the [syscall.EWINDOWS] error, wrapped
in *PathError.</p>
               
               <pre><code>func Lchown(name string, uid int, gid int) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Link" data-name="Link">
               <h3>
                  Link 
                  <span class="badge">function</span>
                  
                  <a href="#Link" class="anchor" title="Link to Link">#</a>
               </h3>
               
               <p>Link creates newname as a hard link to the oldname file.
If there is an error, it will be of type *LinkError.</p>
               
               <pre><code>func Link(oldname string, newname string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Link" data-name="Link">
               <h3>
                  Link 
                  <span class="badge">function</span>
                  
                  <a href="#Link" class="anchor" title="Link to Link">#</a>
               </h3>
               
               <p>Link creates newname as a hard link to the oldname file.
If there is an error, it will be of type *LinkError.</p>
               
               <pre><code>func Link(oldname string, newname string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Link" data-name="Link">
               <h3>
                  Link 
                  <span class="badge">function</span>
                  
                  <a href="#Link" class="anchor" title="Link to Link">#</a>
               </h3>
               
               <p>Link creates newname as a hard link to the oldname file.
If there is an error, it will be of type *LinkError.</p>
               
               <pre><code>func Link(oldname string, newname string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LookupEnv" data-name="LookupEnv">
               <h3>
                  LookupEnv 
                  <span class="badge">function</span>
                  
                  <a href="#LookupEnv" class="anchor" title="Link to LookupEnv">#</a>
               </h3>
               
               <p>LookupEnv retrieves the value of the environment variable named
by the key. If the variable is present in the environment the
value (which may be empty) is returned and the boolean is true.
Otherwise the returned value will be empty and the boolean will
be false.</p>
               
               <pre><code>func LookupEnv(key string) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lstat" data-name="Lstat">
               <h3>
                  Lstat 
                  <span class="badge">function</span>
                  
                  <a href="#Lstat" class="anchor" title="Link to Lstat">#</a>
               </h3>
               
               <p>Lstat returns a [FileInfo] describing the named file.
If the file is a symbolic link, the returned FileInfo
describes the symbolic link. Lstat makes no attempt to follow the link.
If there is an error, it will be of type [*PathError].
On Windows, if the file is a reparse point that is a surrogate for another
named entity (such as a symbolic link or mounted folder), the returned
FileInfo describes the reparse point, and makes no attempt to resolve it.</p>
               
               <pre><code>func Lstat(name string) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lstat" data-name="Lstat">
               <h3>
                  Lstat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lstat" class="anchor" title="Link to Lstat">#</a>
               </h3>
               
               <p>Lstat returns a [FileInfo] describing the named file in the root.
If the file is a symbolic link, the returned FileInfo
describes the symbolic link.
See [Lstat] for more details.</p>
               
               <pre><code>func (r *Root) Lstat(name string) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mkdir" data-name="Mkdir">
               <h3>
                  Mkdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mkdir" class="anchor" title="Link to Mkdir">#</a>
               </h3>
               
               <p>Mkdir creates a new directory in the root
with the specified name and permission bits (before umask).
See [Mkdir] for more details.
If perm contains bits other than the nine least-significant bits (0o777),
OpenFile returns an error.</p>
               
               <pre><code>func (r *Root) Mkdir(name string, perm FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mkdir" data-name="Mkdir">
               <h3>
                  Mkdir 
                  <span class="badge">function</span>
                  
                  <a href="#Mkdir" class="anchor" title="Link to Mkdir">#</a>
               </h3>
               
               <p>Mkdir creates a new directory with the specified name and permission
bits (before umask).
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func Mkdir(name string, perm FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MkdirAll" data-name="MkdirAll">
               <h3>
                  MkdirAll 
                  <span class="badge">function</span>
                  
                  <a href="#MkdirAll" class="anchor" title="Link to MkdirAll">#</a>
               </h3>
               
               <p>MkdirAll creates a directory named path,
along with any necessary parents, and returns nil,
or else returns an error.
The permission bits perm (before umask) are used for all
directories that MkdirAll creates.
If path is already a directory, MkdirAll does nothing
and returns nil.</p>
               
               <pre><code>func MkdirAll(path string, perm FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="MkdirTemp" data-name="MkdirTemp">
               <h3>
                  MkdirTemp 
                  <span class="badge">function</span>
                  
                  <a href="#MkdirTemp" class="anchor" title="Link to MkdirTemp">#</a>
               </h3>
               
               <p>MkdirTemp creates a new temporary directory in the directory dir
and returns the pathname of the new directory.
The new directory's name is generated by adding a random string to the end of pattern.
If pattern includes a "*", the random string replaces the last "*" instead.
The directory is created with mode 0o700 (before umask).
If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir.
Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.
It is the caller's responsibility to remove the directory when it is no longer needed.</p>
               
               <pre><code>func MkdirTemp(dir string, pattern string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModTime" data-name="ModTime">
               <h3>
                  ModTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModTime" class="anchor" title="Link to ModTime">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) ModTime() time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModTime" data-name="ModTime">
               <h3>
                  ModTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModTime" class="anchor" title="Link to ModTime">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) ModTime() time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModTime" data-name="ModTime">
               <h3>
                  ModTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModTime" class="anchor" title="Link to ModTime">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) ModTime() time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mode" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mode" class="anchor" title="Link to Mode">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) Mode() FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mode" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mode" class="anchor" title="Link to Mode">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) Mode() FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mode" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mode" class="anchor" title="Link to Mode">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) Mode() FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code>func (de dirEntry) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <p>Name returns the name of the directory presented to OpenRoot.
It is safe to call Name after [Close].</p>
               
               <pre><code>func (r *Root) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code>func (de dirEntry) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code>func (r *root) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code>func (r *root) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code>func (d *unixDirent) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <p>Name returns the name of the file as presented to Open.
It is safe to call Name after [Close].</p>
               
               <pre><code>func (f *File) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewFile" data-name="NewFile">
               <h3>
                  NewFile 
                  <span class="badge">function</span>
                  
                  <a href="#NewFile" class="anchor" title="Link to NewFile">#</a>
               </h3>
               
               <p>NewFile returns a new File with the given file descriptor and
name. The returned value will be nil if fd is not a valid file
descriptor. On Unix systems, if the file descriptor is in
non-blocking mode, NewFile will attempt to return a pollable File
(one for which the SetDeadline methods work).
After passing it to NewFile, fd may become invalid under the same
conditions described in the comments of the Fd method, and the same
constraints apply.</p>
               
               <pre><code>func NewFile(fd uintptr, name string) *File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewFile" data-name="NewFile">
               <h3>
                  NewFile 
                  <span class="badge">function</span>
                  
                  <a href="#NewFile" class="anchor" title="Link to NewFile">#</a>
               </h3>
               
               <p>NewFile returns a new File with the given file descriptor and
name. The returned value will be nil if fd is not a valid file
descriptor.</p>
               
               <pre><code>func NewFile(fd uintptr, name string) *File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewFile" data-name="NewFile">
               <h3>
                  NewFile 
                  <span class="badge">function</span>
                  
                  <a href="#NewFile" class="anchor" title="Link to NewFile">#</a>
               </h3>
               
               <p>NewFile returns a new File with the given file descriptor and
name. The returned value will be nil if fd is not a valid file
descriptor.</p>
               
               <pre><code>func NewFile(fd uintptr, name string) *File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewSyscallError" data-name="NewSyscallError">
               <h3>
                  NewSyscallError 
                  <span class="badge">function</span>
                  
                  <a href="#NewSyscallError" class="anchor" title="Link to NewSyscallError">#</a>
               </h3>
               
               <p>NewSyscallError returns, as an error, a new [SyscallError]
with the given system call name and error details.
As a convenience, if err is nil, NewSyscallError returns nil.</p>
               
               <pre><code>func NewSyscallError(syscall string, err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge">function</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <p>Open opens the named file for reading. If successful, methods on
the returned file can be used for reading; the associated file
descriptor has mode O_RDONLY.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func Open(name string) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <pre><code>func (rfs *rootFS) Open(name string) (fs.File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <p>Open opens the named file in the root for reading.
See [Open] for more details.</p>
               
               <pre><code>func (r *Root) Open(name string) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <pre><code>func (dir dirFS) Open(name string) (fs.File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OpenFile" data-name="OpenFile">
               <h3>
                  OpenFile 
                  <span class="badge">function</span>
                  
                  <a href="#OpenFile" class="anchor" title="Link to OpenFile">#</a>
               </h3>
               
               <p>OpenFile is the generalized open call; most users will use Open
or Create instead. It opens the named file with specified flag
(O_RDONLY etc.). If the file does not exist, and the O_CREATE flag
is passed, it is created with mode perm (before umask);
the containing directory must exist. If successful,
methods on the returned File can be used for I/O.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func OpenFile(name string, flag int, perm FileMode) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OpenFile" data-name="OpenFile">
               <h3>
                  OpenFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OpenFile" class="anchor" title="Link to OpenFile">#</a>
               </h3>
               
               <p>OpenFile opens the named file in the root.
See [OpenFile] for more details.
If perm contains bits other than the nine least-significant bits (0o777),
OpenFile returns an error.</p>
               
               <pre><code>func (r *Root) OpenFile(name string, flag int, perm FileMode) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OpenInRoot" data-name="OpenInRoot">
               <h3>
                  OpenInRoot 
                  <span class="badge">function</span>
                  
                  <a href="#OpenInRoot" class="anchor" title="Link to OpenInRoot">#</a>
               </h3>
               
               <p>OpenInRoot opens the file name in the directory dir.
It is equivalent to OpenRoot(dir) followed by opening the file in the root.
OpenInRoot returns an error if any component of the name
references a location outside of dir.
See [Root] for details and limitations.</p>
               
               <pre><code>func OpenInRoot(dir string, name string) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OpenRoot" data-name="OpenRoot">
               <h3>
                  OpenRoot 
                  <span class="badge">function</span>
                  
                  <a href="#OpenRoot" class="anchor" title="Link to OpenRoot">#</a>
               </h3>
               
               <p>OpenRoot opens the named directory.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func OpenRoot(name string) (*Root, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OpenRoot" data-name="OpenRoot">
               <h3>
                  OpenRoot 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OpenRoot" class="anchor" title="Link to OpenRoot">#</a>
               </h3>
               
               <p>OpenRoot opens the named directory in the root.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func (r *Root) OpenRoot(name string) (*Root, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pid" data-name="Pid">
               <h3>
                  Pid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pid" class="anchor" title="Link to Pid">#</a>
               </h3>
               
               <p>Pid returns the process id of the exited process.</p>
               
               <pre><code>func (p *ProcessState) Pid() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pid" data-name="Pid">
               <h3>
                  Pid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pid" class="anchor" title="Link to Pid">#</a>
               </h3>
               
               <p>Pid returns the process id of the exited process.</p>
               
               <pre><code>func (p *ProcessState) Pid() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pipe" data-name="Pipe">
               <h3>
                  Pipe 
                  <span class="badge">function</span>
                  
                  <a href="#Pipe" class="anchor" title="Link to Pipe">#</a>
               </h3>
               
               <p>Pipe returns a connected pair of Files; reads from r return bytes
written to w. It returns the files and an error, if any.</p>
               
               <pre><code>func Pipe() (r *File, w *File, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pipe" data-name="Pipe">
               <h3>
                  Pipe 
                  <span class="badge">function</span>
                  
                  <a href="#Pipe" class="anchor" title="Link to Pipe">#</a>
               </h3>
               
               <p>Pipe returns a connected pair of Files; reads from r return bytes written to w.
It returns the files and an error, if any.</p>
               
               <pre><code>func Pipe() (r *File, w *File, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pipe" data-name="Pipe">
               <h3>
                  Pipe 
                  <span class="badge">function</span>
                  
                  <a href="#Pipe" class="anchor" title="Link to Pipe">#</a>
               </h3>
               
               <p>Pipe returns a connected pair of Files; reads from r return bytes written to w.
It returns the files and an error, if any.</p>
               
               <pre><code>func Pipe() (r *File, w *File, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pipe" data-name="Pipe">
               <h3>
                  Pipe 
                  <span class="badge">function</span>
                  
                  <a href="#Pipe" class="anchor" title="Link to Pipe">#</a>
               </h3>
               
               <p>Pipe returns a connected pair of Files; reads from r return bytes written to w.
It returns the files and an error, if any. The Windows handles underlying
the returned files are marked as inheritable by child processes.</p>
               
               <pre><code>func Pipe() (r *File, w *File, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pipe" data-name="Pipe">
               <h3>
                  Pipe 
                  <span class="badge">function</span>
                  
                  <a href="#Pipe" class="anchor" title="Link to Pipe">#</a>
               </h3>
               
               <p>Pipe returns a connected pair of Files; reads from r return bytes written to w.
It returns the files and an error, if any.</p>
               
               <pre><code>func Pipe() (r *File, w *File, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="PollFD" data-name="PollFD">
               <h3>
                  PollFD 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#PollFD" class="anchor" title="Link to PollFD">#</a>
               </h3>
               
               <p>PollFD returns the poll.FD of the file.
Other packages in std that also import internal/poll (such as net)
can use a type assertion to access this extension method so that
they can pass the *poll.FD to functions like poll.Splice.
There is an equivalent function in net.rawConn.
PollFD is not intended for use outside the standard library.</p>
               
               <pre><code>func (f *file) PollFD() *poll.FD</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read reads up to len(b) bytes from the File and stores them in b.
It returns the number of bytes read and any error encountered.
At end of file, Read returns 0, io.EOF.</p>
               
               <pre><code>func (f *File) Read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (c *rawConn) Read(f func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (c *rawConn) Read(f func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadAt" data-name="ReadAt">
               <h3>
                  ReadAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadAt" class="anchor" title="Link to ReadAt">#</a>
               </h3>
               
               <p>ReadAt reads len(b) bytes from the File starting at byte offset off.
It returns the number of bytes read and the error, if any.
ReadAt always returns a non-nil error when n < len(b).
At end of file, that error is io.EOF.</p>
               
               <pre><code>func (f *File) ReadAt(b []byte, off int64) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadDir" data-name="ReadDir">
               <h3>
                  ReadDir 
                  <span class="badge">function</span>
                  
                  <a href="#ReadDir" class="anchor" title="Link to ReadDir">#</a>
               </h3>
               
               <p>ReadDir reads the named directory,
returning all its directory entries sorted by filename.
If an error occurs reading the directory,
ReadDir returns the entries it was able to read before the error,
along with the error.</p>
               
               <pre><code>func ReadDir(name string) ([]DirEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadDir" data-name="ReadDir">
               <h3>
                  ReadDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadDir" class="anchor" title="Link to ReadDir">#</a>
               </h3>
               
               <p>ReadDir reads the contents of the directory associated with the file f
and returns a slice of [DirEntry] values in directory order.
Subsequent calls on the same file will yield later DirEntry records in the directory.
If n > 0, ReadDir returns at most n DirEntry records.
In this case, if ReadDir returns an empty slice, it will return an error explaining why.
At the end of a directory, the error is [io.EOF].
If n <= 0, ReadDir returns all the DirEntry records remaining in the directory.
When it succeeds, it returns a nil error (not io.EOF).</p>
               
               <pre><code>func (f *File) ReadDir(n int) ([]DirEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadDir" data-name="ReadDir">
               <h3>
                  ReadDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadDir" class="anchor" title="Link to ReadDir">#</a>
               </h3>
               
               <p>ReadDir reads the named directory, returning all its directory entries sorted
by filename. Through this method, dirFS implements [io/fs.ReadDirFS].</p>
               
               <pre><code>func (dir dirFS) ReadDir(name string) ([]DirEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadDir" data-name="ReadDir">
               <h3>
                  ReadDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadDir" class="anchor" title="Link to ReadDir">#</a>
               </h3>
               
               <pre><code>func (rfs *rootFS) ReadDir(name string) ([]DirEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFile" data-name="ReadFile">
               <h3>
                  ReadFile 
                  <span class="badge">function</span>
                  
                  <a href="#ReadFile" class="anchor" title="Link to ReadFile">#</a>
               </h3>
               
               <p>ReadFile reads the named file and returns the contents.
A successful call returns err == nil, not err == EOF.
Because ReadFile reads the whole file, it does not treat an EOF from Read
as an error to be reported.</p>
               
               <pre><code>func ReadFile(name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFile" data-name="ReadFile">
               <h3>
                  ReadFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFile" class="anchor" title="Link to ReadFile">#</a>
               </h3>
               
               <p>The ReadFile method calls the [ReadFile] function for the file
with the given name in the directory. The function provides
robust handling for small files and special file systems.
Through this method, dirFS implements [io/fs.ReadFileFS].</p>
               
               <pre><code>func (dir dirFS) ReadFile(name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFile" data-name="ReadFile">
               <h3>
                  ReadFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFile" class="anchor" title="Link to ReadFile">#</a>
               </h3>
               
               <pre><code>func (rfs *rootFS) ReadFile(name string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFrom" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFrom" class="anchor" title="Link to ReadFrom">#</a>
               </h3>
               
               <p>ReadFrom hides another ReadFrom method.
It should never be called.</p>
               
               <pre><code>func (noReadFrom) ReadFrom(io.Reader) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadFrom" data-name="ReadFrom">
               <h3>
                  ReadFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadFrom" class="anchor" title="Link to ReadFrom">#</a>
               </h3>
               
               <p>ReadFrom implements io.ReaderFrom.</p>
               
               <pre><code>func (f *File) ReadFrom(r io.Reader) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Readdir" data-name="Readdir">
               <h3>
                  Readdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Readdir" class="anchor" title="Link to Readdir">#</a>
               </h3>
               
               <p>Readdir reads the contents of the directory associated with file and
returns a slice of up to n [FileInfo] values, as would be returned
by [Lstat], in directory order. Subsequent calls on the same file will yield
further FileInfos.
If n > 0, Readdir returns at most n FileInfo structures. In this case, if
Readdir returns an empty slice, it will return a non-nil error
explaining why. At the end of a directory, the error is [io.EOF].
If n <= 0, Readdir returns all the FileInfo from the directory in
a single slice. In this case, if Readdir succeeds (reads all
the way to the end of the directory), it returns the slice and a
nil error. If it encounters an error before the end of the
directory, Readdir returns the FileInfo read until that point
and a non-nil error.
Most clients are better served by the more efficient ReadDir method.</p>
               
               <pre><code>func (f *File) Readdir(n int) ([]FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Readdirnames" data-name="Readdirnames">
               <h3>
                  Readdirnames 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Readdirnames" class="anchor" title="Link to Readdirnames">#</a>
               </h3>
               
               <p>Readdirnames reads the contents of the directory associated with file
and returns a slice of up to n names of files in the directory,
in directory order. Subsequent calls on the same file will yield
further names.
If n > 0, Readdirnames returns at most n names. In this case, if
Readdirnames returns an empty slice, it will return a non-nil error
explaining why. At the end of a directory, the error is [io.EOF].
If n <= 0, Readdirnames returns all the names from the directory in
a single slice. In this case, if Readdirnames succeeds (reads all
the way to the end of the directory), it returns the slice and a
nil error. If it encounters an error before the end of the
directory, Readdirnames returns the names read until that point and
a non-nil error.</p>
               
               <pre><code>func (f *File) Readdirnames(n int) (names []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Readlink" data-name="Readlink">
               <h3>
                  Readlink 
                  <span class="badge">function</span>
                  
                  <a href="#Readlink" class="anchor" title="Link to Readlink">#</a>
               </h3>
               
               <p>Readlink returns the destination of the named symbolic link.
If there is an error, it will be of type *PathError.
If the link destination is relative, Readlink returns the relative path
without resolving it to an absolute one.</p>
               
               <pre><code>func Readlink(name string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Release" data-name="Release">
               <h3>
                  Release 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Release" class="anchor" title="Link to Release">#</a>
               </h3>
               
               <p>Release releases any resources associated with the [Process] p,
rendering it unusable in the future.
Release only needs to be called if [Process.Wait] is not.</p>
               
               <pre><code>func (p *Process) Release() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Remove" data-name="Remove">
               <h3>
                  Remove 
                  <span class="badge">function</span>
                  
                  <a href="#Remove" class="anchor" title="Link to Remove">#</a>
               </h3>
               
               <p>Remove removes the named file or directory.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func Remove(name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Remove" data-name="Remove">
               <h3>
                  Remove 
                  <span class="badge">function</span>
                  
                  <a href="#Remove" class="anchor" title="Link to Remove">#</a>
               </h3>
               
               <p>Remove removes the named file or (empty) directory.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func Remove(name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Remove" data-name="Remove">
               <h3>
                  Remove 
                  <span class="badge">function</span>
                  
                  <a href="#Remove" class="anchor" title="Link to Remove">#</a>
               </h3>
               
               <p>Remove removes the named file or directory.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func Remove(name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Remove" data-name="Remove">
               <h3>
                  Remove 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Remove" class="anchor" title="Link to Remove">#</a>
               </h3>
               
               <p>Remove removes the named file or (empty) directory in the root.
See [Remove] for more details.</p>
               
               <pre><code>func (r *Root) Remove(name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RemoveAll" data-name="RemoveAll">
               <h3>
                  RemoveAll 
                  <span class="badge">function</span>
                  
                  <a href="#RemoveAll" class="anchor" title="Link to RemoveAll">#</a>
               </h3>
               
               <p>RemoveAll removes path and any children it contains.
It removes everything it can but returns the first error
it encounters. If the path does not exist, RemoveAll
returns nil (no error).
If there is an error, it will be of type [*PathError].</p>
               
               <pre><code>func RemoveAll(path string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Rename" data-name="Rename">
               <h3>
                  Rename 
                  <span class="badge">function</span>
                  
                  <a href="#Rename" class="anchor" title="Link to Rename">#</a>
               </h3>
               
               <p>Rename renames (moves) oldpath to newpath.
If newpath already exists and is not a directory, Rename replaces it.
If newpath already exists and is a directory, Rename returns an error.
OS-specific restrictions may apply when oldpath and newpath are in different directories.
Even within the same directory, on non-Unix platforms Rename is not an atomic operation.
If there is an error, it will be of type *LinkError.</p>
               
               <pre><code>func Rename(oldpath string, newpath string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SameFile" data-name="SameFile">
               <h3>
                  SameFile 
                  <span class="badge">function</span>
                  
                  <a href="#SameFile" class="anchor" title="Link to SameFile">#</a>
               </h3>
               
               <p>SameFile reports whether fi1 and fi2 describe the same file.
For example, on Unix this means that the device and inode fields
of the two underlying structures are identical; on other systems
the decision may be based on the path names.
SameFile only applies to results returned by this package's [Stat].
It returns false in other cases.</p>
               
               <pre><code>func SameFile(fi1 FileInfo, fi2 FileInfo) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Seek" data-name="Seek">
               <h3>
                  Seek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Seek" class="anchor" title="Link to Seek">#</a>
               </h3>
               
               <p>Seek sets the offset for the next Read or Write on file to offset, interpreted
according to whence: 0 means relative to the origin of the file, 1 means
relative to the current offset, and 2 means relative to the end.
It returns the new offset and an error, if any.
The behavior of Seek on a file opened with O_APPEND is not specified.</p>
               
               <pre><code>func (f *File) Seek(offset int64, whence int) (ret int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetDeadline" data-name="SetDeadline">
               <h3>
                  SetDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetDeadline" class="anchor" title="Link to SetDeadline">#</a>
               </h3>
               
               <p>SetDeadline sets the read and write deadlines for a File.
It is equivalent to calling both SetReadDeadline and SetWriteDeadline.
Only some kinds of files support setting a deadline. Calls to SetDeadline
for files that do not support deadlines will return ErrNoDeadline.
On most systems ordinary files do not support deadlines, but pipes do.
A deadline is an absolute time after which I/O operations fail with an
error instead of blocking. The deadline applies to all future and pending
I/O, not just the immediately following call to Read or Write.
After a deadline has been exceeded, the connection can be refreshed
by setting a deadline in the future.
If the deadline is exceeded a call to Read or Write or to other I/O
methods will return an error that wraps ErrDeadlineExceeded.
This can be tested using errors.Is(err, os.ErrDeadlineExceeded).
That error implements the Timeout method, and calling the Timeout
method will return true, but there are other possible errors for which
the Timeout will return true even if the deadline has not been exceeded.
An idle timeout can be implemented by repeatedly extending
the deadline after successful Read or Write calls.
A zero value for t means I/O operations will not time out.</p>
               
               <pre><code>func (f *File) SetDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetReadDeadline" data-name="SetReadDeadline">
               <h3>
                  SetReadDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetReadDeadline" class="anchor" title="Link to SetReadDeadline">#</a>
               </h3>
               
               <p>SetReadDeadline sets the deadline for future Read calls and any
currently-blocked Read call.
A zero value for t means Read will not time out.
Not all files support setting deadlines; see SetDeadline.</p>
               
               <pre><code>func (f *File) SetReadDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetWriteDeadline" data-name="SetWriteDeadline">
               <h3>
                  SetWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetWriteDeadline" class="anchor" title="Link to SetWriteDeadline">#</a>
               </h3>
               
               <p>SetWriteDeadline sets the deadline for any future Write calls and any
currently-blocked Write call.
Even if Write times out, it may return n > 0, indicating that
some of the data was successfully written.
A zero value for t means Write will not time out.
Not all files support setting deadlines; see SetDeadline.</p>
               
               <pre><code>func (f *File) SetWriteDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Setenv" data-name="Setenv">
               <h3>
                  Setenv 
                  <span class="badge">function</span>
                  
                  <a href="#Setenv" class="anchor" title="Link to Setenv">#</a>
               </h3>
               
               <p>Setenv sets the value of the environment variable named by the key.
It returns an error, if any.</p>
               
               <pre><code>func Setenv(key string, value string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Signal" data-name="Signal">
               <h3>
                  Signal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Signal" class="anchor" title="Link to Signal">#</a>
               </h3>
               
               <p>Signal sends a signal to the [Process].
Sending [Interrupt] on Windows is not implemented.</p>
               
               <pre><code>func (p *Process) Signal(sig Signal) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) Size() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) Size() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) Size() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StartProcess" data-name="StartProcess">
               <h3>
                  StartProcess 
                  <span class="badge">function</span>
                  
                  <a href="#StartProcess" class="anchor" title="Link to StartProcess">#</a>
               </h3>
               
               <p>StartProcess starts a new process with the program, arguments and attributes
specified by name, argv and attr. The argv slice will become [os.Args] in the
new process, so it normally starts with the program name.
If the calling goroutine has locked the operating system thread
with [runtime.LockOSThread] and modified any inheritable OS-level
thread state (for example, Linux or Plan 9 name spaces), the new
process will inherit the caller's thread state.
StartProcess is a low-level interface. The [os/exec] package provides
higher-level interfaces.
If there is an error, it will be of type [*PathError].</p>
               
               <pre><code>func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code>func (dir dirFS) Stat(name string) (fs.FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge">function</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <p>Stat returns a [FileInfo] describing the named file.
If there is an error, it will be of type [*PathError].</p>
               
               <pre><code>func Stat(name string) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <p>Stat returns the FileInfo structure describing file.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func (f *File) Stat() (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <p>Stat returns the [FileInfo] structure describing file.
If there is an error, it will be of type [*PathError].</p>
               
               <pre><code>func (file *File) Stat() (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <p>Stat returns a [FileInfo] describing the named file in the root.
See [Stat] for more details.</p>
               
               <pre><code>func (r *Root) Stat(name string) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <p>Stat returns the [FileInfo] structure describing file.
If there is an error, it will be of type [*PathError].</p>
               
               <pre><code>func (f *File) Stat() (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Stat" data-name="Stat">
               <h3>
                  Stat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Stat" class="anchor" title="Link to Stat">#</a>
               </h3>
               
               <pre><code>func (rfs *rootFS) Stat(name string) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (de dirEntry) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (de dirEntry) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (d *unixDirent) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Success" data-name="Success">
               <h3>
                  Success 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Success" class="anchor" title="Link to Success">#</a>
               </h3>
               
               <p>Success reports whether the program exited successfully,
such as with exit status 0 on Unix.</p>
               
               <pre><code>func (p *ProcessState) Success() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Symlink" data-name="Symlink">
               <h3>
                  Symlink 
                  <span class="badge">function</span>
                  
                  <a href="#Symlink" class="anchor" title="Link to Symlink">#</a>
               </h3>
               
               <p>Symlink creates newname as a symbolic link to oldname.
On Windows, a symlink to a non-existent oldname creates a file symlink;
if oldname is later created as a directory the symlink will not work.
If there is an error, it will be of type *LinkError.</p>
               
               <pre><code>func Symlink(oldname string, newname string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Symlink" data-name="Symlink">
               <h3>
                  Symlink 
                  <span class="badge">function</span>
                  
                  <a href="#Symlink" class="anchor" title="Link to Symlink">#</a>
               </h3>
               
               <p>Symlink creates newname as a symbolic link to oldname.
On Windows, a symlink to a non-existent oldname creates a file symlink;
if oldname is later created as a directory the symlink will not work.
If there is an error, it will be of type *LinkError.</p>
               
               <pre><code>func Symlink(oldname string, newname string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Symlink" data-name="Symlink">
               <h3>
                  Symlink 
                  <span class="badge">function</span>
                  
                  <a href="#Symlink" class="anchor" title="Link to Symlink">#</a>
               </h3>
               
               <p>Symlink creates newname as a symbolic link to oldname.
On Windows, a symlink to a non-existent oldname creates a file symlink;
if oldname is later created as a directory the symlink will not work.
If there is an error, it will be of type *LinkError.</p>
               
               <pre><code>func Symlink(oldname string, newname string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sync" data-name="Sync">
               <h3>
                  Sync 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sync" class="anchor" title="Link to Sync">#</a>
               </h3>
               
               <p>Sync commits the current contents of the file to stable storage.
Typically, this means flushing the file system's in-memory copy
of recently written data to disk.</p>
               
               <pre><code>func (f *File) Sync() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sync" data-name="Sync">
               <h3>
                  Sync 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sync" class="anchor" title="Link to Sync">#</a>
               </h3>
               
               <p>Sync commits the current contents of the file to stable storage.
Typically, this means flushing the file system's in-memory copy
of recently written data to disk.</p>
               
               <pre><code>func (f *File) Sync() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sys" data-name="Sys">
               <h3>
                  Sys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sys" class="anchor" title="Link to Sys">#</a>
               </h3>
               
               <p>Sys returns system-dependent exit information about
the process. Convert it to the appropriate underlying
type, such as [syscall.WaitStatus] on Unix, to access its contents.</p>
               
               <pre><code>func (p *ProcessState) Sys() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sys" data-name="Sys">
               <h3>
                  Sys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sys" class="anchor" title="Link to Sys">#</a>
               </h3>
               
               <p>Sys returns syscall.Win32FileAttributeData for file fs.</p>
               
               <pre><code>func (fs *fileStat) Sys() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sys" data-name="Sys">
               <h3>
                  Sys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sys" class="anchor" title="Link to Sys">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) Sys() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sys" data-name="Sys">
               <h3>
                  Sys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sys" class="anchor" title="Link to Sys">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) Sys() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SysUsage" data-name="SysUsage">
               <h3>
                  SysUsage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SysUsage" class="anchor" title="Link to SysUsage">#</a>
               </h3>
               
               <p>SysUsage returns system-dependent resource usage information about
the exited process. Convert it to the appropriate underlying
type, such as [*syscall.Rusage] on Unix, to access its contents.
(On Unix, *syscall.Rusage matches struct rusage as defined in the
getrusage(2) manual page.)</p>
               
               <pre><code>func (p *ProcessState) SysUsage() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SyscallConn" data-name="SyscallConn">
               <h3>
                  SyscallConn 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SyscallConn" class="anchor" title="Link to SyscallConn">#</a>
               </h3>
               
               <p>SyscallConn returns a raw file.
This implements the syscall.Conn interface.</p>
               
               <pre><code>func (f *File) SyscallConn() (syscall.RawConn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SystemTime" data-name="SystemTime">
               <h3>
                  SystemTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SystemTime" class="anchor" title="Link to SystemTime">#</a>
               </h3>
               
               <p>SystemTime returns the system CPU time of the exited process and its children.</p>
               
               <pre><code>func (p *ProcessState) SystemTime() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TempDir" data-name="TempDir">
               <h3>
                  TempDir 
                  <span class="badge">function</span>
                  
                  <a href="#TempDir" class="anchor" title="Link to TempDir">#</a>
               </h3>
               
               <p>TempDir returns the default directory to use for temporary files.
On Unix systems, it returns $TMPDIR if non-empty, else /tmp.
On Windows, it uses GetTempPath, returning the first non-empty
value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.
On Plan 9, it returns /tmp.
The directory is neither guaranteed to exist nor have accessible
permissions.</p>
               
               <pre><code>func TempDir() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Timeout" data-name="Timeout">
               <h3>
                  Timeout 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Timeout" class="anchor" title="Link to Timeout">#</a>
               </h3>
               
               <p>Timeout reports whether this error represents a timeout.</p>
               
               <pre><code>func (e *SyscallError) Timeout() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Truncate" data-name="Truncate">
               <h3>
                  Truncate 
                  <span class="badge">function</span>
                  
                  <a href="#Truncate" class="anchor" title="Link to Truncate">#</a>
               </h3>
               
               <p>Truncate changes the size of the named file.
If the file is a symbolic link, it changes the size of the link's target.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func Truncate(name string, size int64) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Truncate" data-name="Truncate">
               <h3>
                  Truncate 
                  <span class="badge">function</span>
                  
                  <a href="#Truncate" class="anchor" title="Link to Truncate">#</a>
               </h3>
               
               <p>Truncate changes the size of the named file.
If the file is a symbolic link, it changes the size of the link's target.</p>
               
               <pre><code>func Truncate(name string, size int64) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Truncate" data-name="Truncate">
               <h3>
                  Truncate 
                  <span class="badge">function</span>
                  
                  <a href="#Truncate" class="anchor" title="Link to Truncate">#</a>
               </h3>
               
               <p>Truncate changes the size of the named file.
If the file is a symbolic link, it changes the size of the link's target.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func Truncate(name string, size int64) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Truncate" data-name="Truncate">
               <h3>
                  Truncate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Truncate" class="anchor" title="Link to Truncate">#</a>
               </h3>
               
               <p>Truncate changes the size of the file.
It does not change the I/O offset.
If there is an error, it will be of type *PathError.</p>
               
               <pre><code>func (f *File) Truncate(size int64) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Truncate" data-name="Truncate">
               <h3>
                  Truncate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Truncate" class="anchor" title="Link to Truncate">#</a>
               </h3>
               
               <p>Truncate changes the size of the file.
It does not change the I/O offset.
If there is an error, it will be of type [*PathError].</p>
               
               <pre><code>func (f *File) Truncate(size int64) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <pre><code>func (d *unixDirent) Type() FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <pre><code>func (de dirEntry) Type() FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Type" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Type" class="anchor" title="Link to Type">#</a>
               </h3>
               
               <pre><code>func (de dirEntry) Type() FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unsetenv" data-name="Unsetenv">
               <h3>
                  Unsetenv 
                  <span class="badge">function</span>
                  
                  <a href="#Unsetenv" class="anchor" title="Link to Unsetenv">#</a>
               </h3>
               
               <p>Unsetenv unsets a single environment variable.</p>
               
               <pre><code>func Unsetenv(key string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code>func (e *LinkError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code>func (e *SyscallError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UserCacheDir" data-name="UserCacheDir">
               <h3>
                  UserCacheDir 
                  <span class="badge">function</span>
                  
                  <a href="#UserCacheDir" class="anchor" title="Link to UserCacheDir">#</a>
               </h3>
               
               <p>UserCacheDir returns the default root directory to use for user-specific
cached data. Users should create their own application-specific subdirectory
within this one and use that.
On Unix systems, it returns $XDG_CACHE_HOME as specified by
https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
non-empty, else $HOME/.cache.
On Darwin, it returns $HOME/Library/Caches.
On Windows, it returns %LocalAppData%.
On Plan 9, it returns $home/lib/cache.
If the location cannot be determined (for example, $HOME is not defined) or
the path in $XDG_CACHE_HOME is relative, then it will return an error.</p>
               
               <pre><code>func UserCacheDir() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UserConfigDir" data-name="UserConfigDir">
               <h3>
                  UserConfigDir 
                  <span class="badge">function</span>
                  
                  <a href="#UserConfigDir" class="anchor" title="Link to UserConfigDir">#</a>
               </h3>
               
               <p>UserConfigDir returns the default root directory to use for user-specific
configuration data. Users should create their own application-specific
subdirectory within this one and use that.
On Unix systems, it returns $XDG_CONFIG_HOME as specified by
https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
non-empty, else $HOME/.config.
On Darwin, it returns $HOME/Library/Application Support.
On Windows, it returns %AppData%.
On Plan 9, it returns $home/lib.
If the location cannot be determined (for example, $HOME is not defined) or
the path in $XDG_CONFIG_HOME is relative, then it will return an error.</p>
               
               <pre><code>func UserConfigDir() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UserHomeDir" data-name="UserHomeDir">
               <h3>
                  UserHomeDir 
                  <span class="badge">function</span>
                  
                  <a href="#UserHomeDir" class="anchor" title="Link to UserHomeDir">#</a>
               </h3>
               
               <p>UserHomeDir returns the current user's home directory.
On Unix, including macOS, it returns the $HOME environment variable.
On Windows, it returns %USERPROFILE%.
On Plan 9, it returns the $home environment variable.
If the expected variable is not set in the environment, UserHomeDir
returns either a platform-specific default value or a non-nil error.</p>
               
               <pre><code>func UserHomeDir() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UserTime" data-name="UserTime">
               <h3>
                  UserTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UserTime" class="anchor" title="Link to UserTime">#</a>
               </h3>
               
               <p>UserTime returns the user CPU time of the exited process and its children.</p>
               
               <pre><code>func (p *ProcessState) UserTime() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Wait" data-name="Wait">
               <h3>
                  Wait 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Wait" class="anchor" title="Link to Wait">#</a>
               </h3>
               
               <p>Wait waits for the [Process] to exit, and then returns a
ProcessState describing its status and an error, if any.
Wait releases any resources associated with the Process.
On most operating systems, the Process must be a child
of the current process or an error will be returned.</p>
               
               <pre><code>func (p *Process) Wait() (*ProcessState, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (c *rawConn) Write(f func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code>func (c *rawConn) Write(f func(uintptr) bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes len(b) bytes from b to the File.
It returns the number of bytes written and an error, if any.
Write returns a non-nil error when n != len(b).</p>
               
               <pre><code>func (f *File) Write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteAt" data-name="WriteAt">
               <h3>
                  WriteAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteAt" class="anchor" title="Link to WriteAt">#</a>
               </h3>
               
               <p>WriteAt writes len(b) bytes to the File starting at byte offset off.
It returns the number of bytes written and an error, if any.
WriteAt returns a non-nil error when n != len(b).
If file was opened with the O_APPEND flag, WriteAt returns an error.</p>
               
               <pre><code>func (f *File) WriteAt(b []byte, off int64) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteFile" data-name="WriteFile">
               <h3>
                  WriteFile 
                  <span class="badge">function</span>
                  
                  <a href="#WriteFile" class="anchor" title="Link to WriteFile">#</a>
               </h3>
               
               <p>WriteFile writes data to the named file, creating it if necessary.
If the file does not exist, WriteFile creates it with permissions perm (before umask);
otherwise WriteFile truncates it before writing, without changing permissions.
Since WriteFile requires multiple system calls to complete, a failure mid-operation
can leave the file in a partially written state.</p>
               
               <pre><code>func WriteFile(name string, data []byte, perm FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteString" data-name="WriteString">
               <h3>
                  WriteString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteString" class="anchor" title="Link to WriteString">#</a>
               </h3>
               
               <p>WriteString is like Write, but writes the contents of string s rather than
a slice of bytes.</p>
               
               <pre><code>func (f *File) WriteString(s string) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteTo" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteTo" class="anchor" title="Link to WriteTo">#</a>
               </h3>
               
               <p>WriteTo implements io.WriterTo.</p>
               
               <pre><code>func (f *File) WriteTo(w io.Writer) (n int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="WriteTo" data-name="WriteTo">
               <h3>
                  WriteTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#WriteTo" class="anchor" title="Link to WriteTo">#</a>
               </h3>
               
               <p>WriteTo hides another WriteTo method.
It should never be called.</p>
               
               <pre><code>func (noWriteTo) WriteTo(io.Writer) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="addExtendedPrefix" data-name="addExtendedPrefix">
               <h3>
                  addExtendedPrefix 
                  <span class="badge">function</span>
                  
                  <a href="#addExtendedPrefix" class="anchor" title="Link to addExtendedPrefix">#</a>
               </h3>
               
               <p>addExtendedPrefix adds the extended path prefix (\\?\) to path.</p>
               
               <pre><code>func addExtendedPrefix(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendBSBytes" data-name="appendBSBytes">
               <h3>
                  appendBSBytes 
                  <span class="badge">function</span>
                  
                  <a href="#appendBSBytes" class="anchor" title="Link to appendBSBytes">#</a>
               </h3>
               
               <p>appendBSBytes appends n '\\' bytes to b and returns the resulting slice.</p>
               
               <pre><code>func appendBSBytes(b []byte, n int) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atime" data-name="atime">
               <h3>
                  atime 
                  <span class="badge">function</span>
                  
                  <a href="#atime" class="anchor" title="Link to atime">#</a>
               </h3>
               
               <p>For testing.</p>
               
               <pre><code>func atime(fi FileInfo) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atime" data-name="atime">
               <h3>
                  atime 
                  <span class="badge">function</span>
                  
                  <a href="#atime" class="anchor" title="Link to atime">#</a>
               </h3>
               
               <p>For testing.</p>
               
               <pre><code>func atime(fi FileInfo) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atime" data-name="atime">
               <h3>
                  atime 
                  <span class="badge">function</span>
                  
                  <a href="#atime" class="anchor" title="Link to atime">#</a>
               </h3>
               
               <p>For testing.</p>
               
               <pre><code>func atime(fi FileInfo) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atime" data-name="atime">
               <h3>
                  atime 
                  <span class="badge">function</span>
                  
                  <a href="#atime" class="anchor" title="Link to atime">#</a>
               </h3>
               
               <p>For testing.</p>
               
               <pre><code>func atime(fi FileInfo) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atime" data-name="atime">
               <h3>
                  atime 
                  <span class="badge">function</span>
                  
                  <a href="#atime" class="anchor" title="Link to atime">#</a>
               </h3>
               
               <p>For testing.</p>
               
               <pre><code>func atime(fi FileInfo) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atime" data-name="atime">
               <h3>
                  atime 
                  <span class="badge">function</span>
                  
                  <a href="#atime" class="anchor" title="Link to atime">#</a>
               </h3>
               
               <p>For testing.</p>
               
               <pre><code>func atime(fi FileInfo) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atime" data-name="atime">
               <h3>
                  atime 
                  <span class="badge">function</span>
                  
                  <a href="#atime" class="anchor" title="Link to atime">#</a>
               </h3>
               
               <p>For testing.</p>
               
               <pre><code>func atime(fi FileInfo) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atime" data-name="atime">
               <h3>
                  atime 
                  <span class="badge">function</span>
                  
                  <a href="#atime" class="anchor" title="Link to atime">#</a>
               </h3>
               
               <p>For testing.</p>
               
               <pre><code>func atime(fi FileInfo) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atime" data-name="atime">
               <h3>
                  atime 
                  <span class="badge">function</span>
                  
                  <a href="#atime" class="anchor" title="Link to atime">#</a>
               </h3>
               
               <p>For testing.</p>
               
               <pre><code>func atime(fi FileInfo) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atime" data-name="atime">
               <h3>
                  atime 
                  <span class="badge">function</span>
                  
                  <a href="#atime" class="anchor" title="Link to atime">#</a>
               </h3>
               
               <p>For testing.</p>
               
               <pre><code>func atime(fi FileInfo) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atime" data-name="atime">
               <h3>
                  atime 
                  <span class="badge">function</span>
                  
                  <a href="#atime" class="anchor" title="Link to atime">#</a>
               </h3>
               
               <p>For testing.</p>
               
               <pre><code>func atime(fi FileInfo) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="atime" data-name="atime">
               <h3>
                  atime 
                  <span class="badge">function</span>
                  
                  <a href="#atime" class="anchor" title="Link to atime">#</a>
               </h3>
               
               <p>For testing.</p>
               
               <pre><code>func atime(fi FileInfo) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="blockUntilWaitable" data-name="blockUntilWaitable">
               <h3>
                  blockUntilWaitable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#blockUntilWaitable" class="anchor" title="Link to blockUntilWaitable">#</a>
               </h3>
               
               <p>blockUntilWaitable attempts to block until a call to p.Wait will
succeed immediately, and reports whether it has done so.
It does not actually call p.Wait.</p>
               
               <pre><code>func (p *Process) blockUntilWaitable() (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="blockUntilWaitable" data-name="blockUntilWaitable">
               <h3>
                  blockUntilWaitable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#blockUntilWaitable" class="anchor" title="Link to blockUntilWaitable">#</a>
               </h3>
               
               <p>blockUntilWaitable attempts to block until a call to p.Wait will
succeed immediately, and reports whether it has done so.
It does not actually call p.Wait.
This version is used on systems that do not implement waitid,
or where we have not implemented it yet. Note that this is racy:
a call to Process.Signal can in an extremely unlikely case send a
signal to the wrong process, see issue #13987.</p>
               
               <pre><code>func (p *Process) blockUntilWaitable() (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="blockUntilWaitable" data-name="blockUntilWaitable">
               <h3>
                  blockUntilWaitable 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#blockUntilWaitable" class="anchor" title="Link to blockUntilWaitable">#</a>
               </h3>
               
               <p>blockUntilWaitable attempts to block until a call to p.Wait will
succeed immediately, and reports whether it has done so.
It does not actually call p.Wait.</p>
               
               <pre><code>func (p *Process) blockUntilWaitable() (bool, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkClonePidfd" data-name="checkClonePidfd">
               <h3>
                  checkClonePidfd 
                  <span class="badge">function</span>
                  
                  <a href="#checkClonePidfd" class="anchor" title="Link to checkClonePidfd">#</a>
               </h3>
               
               <p>Provided by syscall.
go:linkname checkClonePidfd</p>
               
               <pre><code>func checkClonePidfd() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPathEscapes" data-name="checkPathEscapes">
               <h3>
                  checkPathEscapes 
                  <span class="badge">function</span>
                  
                  <a href="#checkPathEscapes" class="anchor" title="Link to checkPathEscapes">#</a>
               </h3>
               
               <p>checkPathEscapes reports whether name escapes the root.
Due to the lack of openat, checkPathEscapes is subject to TOCTOU races
when symlinks change during the resolution process.</p>
               
               <pre><code>func checkPathEscapes(r *Root, name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPathEscapes" data-name="checkPathEscapes">
               <h3>
                  checkPathEscapes 
                  <span class="badge">function</span>
                  
                  <a href="#checkPathEscapes" class="anchor" title="Link to checkPathEscapes">#</a>
               </h3>
               
               <pre><code>func checkPathEscapes(r *Root, name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPathEscapesInternal" data-name="checkPathEscapesInternal">
               <h3>
                  checkPathEscapesInternal 
                  <span class="badge">function</span>
                  
                  <a href="#checkPathEscapesInternal" class="anchor" title="Link to checkPathEscapesInternal">#</a>
               </h3>
               
               <pre><code>func checkPathEscapesInternal(r *Root, name string, lstat bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPathEscapesLstat" data-name="checkPathEscapesLstat">
               <h3>
                  checkPathEscapesLstat 
                  <span class="badge">function</span>
                  
                  <a href="#checkPathEscapesLstat" class="anchor" title="Link to checkPathEscapesLstat">#</a>
               </h3>
               
               <p>checkPathEscapesLstat reports whether name escapes the root.
It does not resolve symlinks in the final path component.
Due to the lack of openat, checkPathEscapes is subject to TOCTOU races
when symlinks change during the resolution process.</p>
               
               <pre><code>func checkPathEscapesLstat(r *Root, name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPathEscapesLstat" data-name="checkPathEscapesLstat">
               <h3>
                  checkPathEscapesLstat 
                  <span class="badge">function</span>
                  
                  <a href="#checkPathEscapesLstat" class="anchor" title="Link to checkPathEscapesLstat">#</a>
               </h3>
               
               <pre><code>func checkPathEscapesLstat(r *Root, name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPidfd" data-name="checkPidfd">
               <h3>
                  checkPidfd 
                  <span class="badge">function</span>
                  
                  <a href="#checkPidfd" class="anchor" title="Link to checkPidfd">#</a>
               </h3>
               
               <p>checkPidfd checks whether all required pidfd-related syscalls work. This
consists of pidfd_open and pidfd_send_signal syscalls, waitid syscall with
idtype of P_PIDFD, and clone(CLONE_PIDFD).
Reasons for non-working pidfd syscalls include an older kernel and an
execution environment in which the above system calls are restricted by
seccomp or a similar technology.</p>
               
               <pre><code>func checkPidfd() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkSymlink" data-name="checkSymlink">
               <h3>
                  checkSymlink 
                  <span class="badge">function</span>
                  
                  <a href="#checkSymlink" class="anchor" title="Link to checkSymlink">#</a>
               </h3>
               
               <p>checkSymlink resolves the symlink name in parent,
and returns errSymlink with the link contents.
If name is not a symlink, return origError.</p>
               
               <pre><code>func checkSymlink(parent int, name string, origError error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkValid" data-name="checkValid">
               <h3>
                  checkValid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkValid" class="anchor" title="Link to checkValid">#</a>
               </h3>
               
               <p>checkValid checks whether f is valid for use.
If not, it returns an appropriate error, perhaps incorporating the operation name op.</p>
               
               <pre><code>func (f *File) checkValid(op string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkValid" data-name="checkValid">
               <h3>
                  checkValid 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#checkValid" class="anchor" title="Link to checkValid">#</a>
               </h3>
               
               <p>checkValid checks whether f is valid for use, but does not prepare
to actually use it. If f is not ready checkValid returns an appropriate
error, perhaps incorporating the operation name op.</p>
               
               <pre><code>func (f *File) checkValid(op string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chmod" data-name="chmod">
               <h3>
                  chmod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#chmod" class="anchor" title="Link to chmod">#</a>
               </h3>
               
               <pre><code>func (f *File) chmod(mode FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chmod" data-name="chmod">
               <h3>
                  chmod 
                  <span class="badge">function</span>
                  
                  <a href="#chmod" class="anchor" title="Link to chmod">#</a>
               </h3>
               
               <p>See docs in file.go:Chmod.</p>
               
               <pre><code>func chmod(name string, mode FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chmod" data-name="chmod">
               <h3>
                  chmod 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#chmod" class="anchor" title="Link to chmod">#</a>
               </h3>
               
               <p>See docs in file.go:(*File).Chmod.</p>
               
               <pre><code>func (f *File) chmod(mode FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="chmod" data-name="chmod">
               <h3>
                  chmod 
                  <span class="badge">function</span>
                  
                  <a href="#chmod" class="anchor" title="Link to chmod">#</a>
               </h3>
               
               <p>See docs in file.go:Chmod.</p>
               
               <pre><code>func chmod(name string, mode FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <pre><code>func (file *file) close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <pre><code>func (file *file) close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <pre><code>func (d *dirInfo) close()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <pre><code>func (d *dirInfo) close()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <pre><code>func (file *file) close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="close" data-name="close">
               <h3>
                  close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#close" class="anchor" title="Link to close">#</a>
               </h3>
               
               <pre><code>func (d *dirInfo) close()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeHandle" data-name="closeHandle">
               <h3>
                  closeHandle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeHandle" class="anchor" title="Link to closeHandle">#</a>
               </h3>
               
               <pre><code>func (p *Process) closeHandle()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeHandle" data-name="closeHandle">
               <h3>
                  closeHandle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeHandle" class="anchor" title="Link to closeHandle">#</a>
               </h3>
               
               <pre><code>func (p *Process) closeHandle()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closeHandle" data-name="closeHandle">
               <h3>
                  closeHandle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#closeHandle" class="anchor" title="Link to closeHandle">#</a>
               </h3>
               
               <pre><code>func (p *Process) closeHandle()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="closedir" data-name="closedir">
               <h3>
                  closedir 
                  <span class="badge">function</span>
                  
                  <a href="#closedir" class="anchor" title="Link to closedir">#</a>
               </h3>
               
               <p>go:linkname closedir syscall.closedir</p>
               
               <pre><code>func closedir(dir uintptr) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="commandLineToArgv" data-name="commandLineToArgv">
               <h3>
                  commandLineToArgv 
                  <span class="badge">function</span>
                  
                  <a href="#commandLineToArgv" class="anchor" title="Link to commandLineToArgv">#</a>
               </h3>
               
               <p>commandLineToArgv splits a command line into individual argument
strings, following the Windows conventions documented
at http://daviddeley.com/autohotkey/parameters/parameters.htm#WINARGV</p>
               
               <pre><code>func commandLineToArgv(cmd string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="convertESRCH" data-name="convertESRCH">
               <h3>
                  convertESRCH 
                  <span class="badge">function</span>
                  
                  <a href="#convertESRCH" class="anchor" title="Link to convertESRCH">#</a>
               </h3>
               
               <pre><code>func convertESRCH(err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="copyFileRange" data-name="copyFileRange">
               <h3>
                  copyFileRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#copyFileRange" class="anchor" title="Link to copyFileRange">#</a>
               </h3>
               
               <pre><code>func (f *File) copyFileRange(r io.Reader) (written int64, handled bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decref" data-name="decref">
               <h3>
                  decref 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#decref" class="anchor" title="Link to decref">#</a>
               </h3>
               
               <p>decref removes a reference to the file. If this is the last
remaining reference, and the file has been marked to be closed,
then actually close it.</p>
               
               <pre><code>func (file *file) decref() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="decref" data-name="decref">
               <h3>
                  decref 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#decref" class="anchor" title="Link to decref">#</a>
               </h3>
               
               <pre><code>func (r *root) decref()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="destroy" data-name="destroy">
               <h3>
                  destroy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#destroy" class="anchor" title="Link to destroy">#</a>
               </h3>
               
               <p>destroy actually closes the descriptor. This is called when
there are no remaining references, by the decref, readUnlock,
and writeUnlock methods.</p>
               
               <pre><code>func (file *file) destroy() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntIno" data-name="direntIno">
               <h3>
                  direntIno 
                  <span class="badge">function</span>
                  
                  <a href="#direntIno" class="anchor" title="Link to direntIno">#</a>
               </h3>
               
               <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntIno" data-name="direntIno">
               <h3>
                  direntIno 
                  <span class="badge">function</span>
                  
                  <a href="#direntIno" class="anchor" title="Link to direntIno">#</a>
               </h3>
               
               <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntIno" data-name="direntIno">
               <h3>
                  direntIno 
                  <span class="badge">function</span>
                  
                  <a href="#direntIno" class="anchor" title="Link to direntIno">#</a>
               </h3>
               
               <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntIno" data-name="direntIno">
               <h3>
                  direntIno 
                  <span class="badge">function</span>
                  
                  <a href="#direntIno" class="anchor" title="Link to direntIno">#</a>
               </h3>
               
               <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntIno" data-name="direntIno">
               <h3>
                  direntIno 
                  <span class="badge">function</span>
                  
                  <a href="#direntIno" class="anchor" title="Link to direntIno">#</a>
               </h3>
               
               <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntIno" data-name="direntIno">
               <h3>
                  direntIno 
                  <span class="badge">function</span>
                  
                  <a href="#direntIno" class="anchor" title="Link to direntIno">#</a>
               </h3>
               
               <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntIno" data-name="direntIno">
               <h3>
                  direntIno 
                  <span class="badge">function</span>
                  
                  <a href="#direntIno" class="anchor" title="Link to direntIno">#</a>
               </h3>
               
               <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntIno" data-name="direntIno">
               <h3>
                  direntIno 
                  <span class="badge">function</span>
                  
                  <a href="#direntIno" class="anchor" title="Link to direntIno">#</a>
               </h3>
               
               <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntIno" data-name="direntIno">
               <h3>
                  direntIno 
                  <span class="badge">function</span>
                  
                  <a href="#direntIno" class="anchor" title="Link to direntIno">#</a>
               </h3>
               
               <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntNamlen" data-name="direntNamlen">
               <h3>
                  direntNamlen 
                  <span class="badge">function</span>
                  
                  <a href="#direntNamlen" class="anchor" title="Link to direntNamlen">#</a>
               </h3>
               
               <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntNamlen" data-name="direntNamlen">
               <h3>
                  direntNamlen 
                  <span class="badge">function</span>
                  
                  <a href="#direntNamlen" class="anchor" title="Link to direntNamlen">#</a>
               </h3>
               
               <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntNamlen" data-name="direntNamlen">
               <h3>
                  direntNamlen 
                  <span class="badge">function</span>
                  
                  <a href="#direntNamlen" class="anchor" title="Link to direntNamlen">#</a>
               </h3>
               
               <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntNamlen" data-name="direntNamlen">
               <h3>
                  direntNamlen 
                  <span class="badge">function</span>
                  
                  <a href="#direntNamlen" class="anchor" title="Link to direntNamlen">#</a>
               </h3>
               
               <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntNamlen" data-name="direntNamlen">
               <h3>
                  direntNamlen 
                  <span class="badge">function</span>
                  
                  <a href="#direntNamlen" class="anchor" title="Link to direntNamlen">#</a>
               </h3>
               
               <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntNamlen" data-name="direntNamlen">
               <h3>
                  direntNamlen 
                  <span class="badge">function</span>
                  
                  <a href="#direntNamlen" class="anchor" title="Link to direntNamlen">#</a>
               </h3>
               
               <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntNamlen" data-name="direntNamlen">
               <h3>
                  direntNamlen 
                  <span class="badge">function</span>
                  
                  <a href="#direntNamlen" class="anchor" title="Link to direntNamlen">#</a>
               </h3>
               
               <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntNamlen" data-name="direntNamlen">
               <h3>
                  direntNamlen 
                  <span class="badge">function</span>
                  
                  <a href="#direntNamlen" class="anchor" title="Link to direntNamlen">#</a>
               </h3>
               
               <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntNamlen" data-name="direntNamlen">
               <h3>
                  direntNamlen 
                  <span class="badge">function</span>
                  
                  <a href="#direntNamlen" class="anchor" title="Link to direntNamlen">#</a>
               </h3>
               
               <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntReclen" data-name="direntReclen">
               <h3>
                  direntReclen 
                  <span class="badge">function</span>
                  
                  <a href="#direntReclen" class="anchor" title="Link to direntReclen">#</a>
               </h3>
               
               <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntReclen" data-name="direntReclen">
               <h3>
                  direntReclen 
                  <span class="badge">function</span>
                  
                  <a href="#direntReclen" class="anchor" title="Link to direntReclen">#</a>
               </h3>
               
               <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntReclen" data-name="direntReclen">
               <h3>
                  direntReclen 
                  <span class="badge">function</span>
                  
                  <a href="#direntReclen" class="anchor" title="Link to direntReclen">#</a>
               </h3>
               
               <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntReclen" data-name="direntReclen">
               <h3>
                  direntReclen 
                  <span class="badge">function</span>
                  
                  <a href="#direntReclen" class="anchor" title="Link to direntReclen">#</a>
               </h3>
               
               <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntReclen" data-name="direntReclen">
               <h3>
                  direntReclen 
                  <span class="badge">function</span>
                  
                  <a href="#direntReclen" class="anchor" title="Link to direntReclen">#</a>
               </h3>
               
               <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntReclen" data-name="direntReclen">
               <h3>
                  direntReclen 
                  <span class="badge">function</span>
                  
                  <a href="#direntReclen" class="anchor" title="Link to direntReclen">#</a>
               </h3>
               
               <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntReclen" data-name="direntReclen">
               <h3>
                  direntReclen 
                  <span class="badge">function</span>
                  
                  <a href="#direntReclen" class="anchor" title="Link to direntReclen">#</a>
               </h3>
               
               <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntReclen" data-name="direntReclen">
               <h3>
                  direntReclen 
                  <span class="badge">function</span>
                  
                  <a href="#direntReclen" class="anchor" title="Link to direntReclen">#</a>
               </h3>
               
               <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntReclen" data-name="direntReclen">
               <h3>
                  direntReclen 
                  <span class="badge">function</span>
                  
                  <a href="#direntReclen" class="anchor" title="Link to direntReclen">#</a>
               </h3>
               
               <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntType" data-name="direntType">
               <h3>
                  direntType 
                  <span class="badge">function</span>
                  
                  <a href="#direntType" class="anchor" title="Link to direntType">#</a>
               </h3>
               
               <pre><code>func direntType(buf []byte) FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntType" data-name="direntType">
               <h3>
                  direntType 
                  <span class="badge">function</span>
                  
                  <a href="#direntType" class="anchor" title="Link to direntType">#</a>
               </h3>
               
               <pre><code>func direntType(buf []byte) FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntType" data-name="direntType">
               <h3>
                  direntType 
                  <span class="badge">function</span>
                  
                  <a href="#direntType" class="anchor" title="Link to direntType">#</a>
               </h3>
               
               <pre><code>func direntType(buf []byte) FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntType" data-name="direntType">
               <h3>
                  direntType 
                  <span class="badge">function</span>
                  
                  <a href="#direntType" class="anchor" title="Link to direntType">#</a>
               </h3>
               
               <pre><code>func direntType(buf []byte) FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntType" data-name="direntType">
               <h3>
                  direntType 
                  <span class="badge">function</span>
                  
                  <a href="#direntType" class="anchor" title="Link to direntType">#</a>
               </h3>
               
               <pre><code>func direntType(buf []byte) FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntType" data-name="direntType">
               <h3>
                  direntType 
                  <span class="badge">function</span>
                  
                  <a href="#direntType" class="anchor" title="Link to direntType">#</a>
               </h3>
               
               <pre><code>func direntType(buf []byte) FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntType" data-name="direntType">
               <h3>
                  direntType 
                  <span class="badge">function</span>
                  
                  <a href="#direntType" class="anchor" title="Link to direntType">#</a>
               </h3>
               
               <pre><code>func direntType(buf []byte) FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntType" data-name="direntType">
               <h3>
                  direntType 
                  <span class="badge">function</span>
                  
                  <a href="#direntType" class="anchor" title="Link to direntType">#</a>
               </h3>
               
               <pre><code>func direntType(buf []byte) FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="direntType" data-name="direntType">
               <h3>
                  direntType 
                  <span class="badge">function</span>
                  
                  <a href="#direntType" class="anchor" title="Link to direntType">#</a>
               </h3>
               
               <pre><code>func direntType(buf []byte) FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dirname" data-name="dirname">
               <h3>
                  dirname 
                  <span class="badge">function</span>
                  
                  <a href="#dirname" class="anchor" title="Link to dirname">#</a>
               </h3>
               
               <pre><code>func dirname(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dirstat" data-name="dirstat">
               <h3>
                  dirstat 
                  <span class="badge">function</span>
                  
                  <a href="#dirstat" class="anchor" title="Link to dirstat">#</a>
               </h3>
               
               <p>arg is an open *File or a path string.</p>
               
               <pre><code>func dirstat(arg any) (*syscall.Dir, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="doInRoot" data-name="doInRoot">
               <h3>
                  doInRoot 
                  <span class="badge">function</span>
                  
                  <a href="#doInRoot" class="anchor" title="Link to doInRoot">#</a>
               </h3>
               
               <p>doInRoot performs an operation on a path in a Root.
It opens the directory containing the final element of the path,
and calls f with the directory FD and name of the final element.
If the path refers to a symlink which should be followed,
then f must return errSymlink.
doInRoot will follow the symlink and call f again.</p>
               
               <pre><code>func doInRoot(r *Root, name string, f func(parent sysfdType, name string) (T, error)) (ret T, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dtToType" data-name="dtToType">
               <h3>
                  dtToType 
                  <span class="badge">function</span>
                  
                  <a href="#dtToType" class="anchor" title="Link to dtToType">#</a>
               </h3>
               
               <pre><code>func dtToType(typ uint8) FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endsWithDot" data-name="endsWithDot">
               <h3>
                  endsWithDot 
                  <span class="badge">function</span>
                  
                  <a href="#endsWithDot" class="anchor" title="Link to endsWithDot">#</a>
               </h3>
               
               <p>endsWithDot reports whether the final component of path is ".".</p>
               
               <pre><code>func endsWithDot(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ensurePidfd" data-name="ensurePidfd">
               <h3>
                  ensurePidfd 
                  <span class="badge">function</span>
                  
                  <a href="#ensurePidfd" class="anchor" title="Link to ensurePidfd">#</a>
               </h3>
               
               <p>ensurePidfd initializes the PidFD field in sysAttr if it is not already set.
It returns the original or modified SysProcAttr struct and a flag indicating
whether the PidFD should be duplicated before using.</p>
               
               <pre><code>func ensurePidfd(sysAttr *syscall.SysProcAttr) (*syscall.SysProcAttr, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ensurePidfd" data-name="ensurePidfd">
               <h3>
                  ensurePidfd 
                  <span class="badge">function</span>
                  
                  <a href="#ensurePidfd" class="anchor" title="Link to ensurePidfd">#</a>
               </h3>
               
               <pre><code>func ensurePidfd(sysAttr *syscall.SysProcAttr) (*syscall.SysProcAttr, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="epipecheck" data-name="epipecheck">
               <h3>
                  epipecheck 
                  <span class="badge">function</span>
                  
                  <a href="#epipecheck" class="anchor" title="Link to epipecheck">#</a>
               </h3>
               
               <pre><code>func epipecheck(file *File, e error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="epipecheck" data-name="epipecheck">
               <h3>
                  epipecheck 
                  <span class="badge">function</span>
                  
                  <a href="#epipecheck" class="anchor" title="Link to epipecheck">#</a>
               </h3>
               
               <p>epipecheck raises SIGPIPE if we get an EPIPE error on standard
output or standard error. See the SIGPIPE docs in os/signal, and
issue 11845.</p>
               
               <pre><code>func epipecheck(file *File, e error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="epipecheck" data-name="epipecheck">
               <h3>
                  epipecheck 
                  <span class="badge">function</span>
                  
                  <a href="#epipecheck" class="anchor" title="Link to epipecheck">#</a>
               </h3>
               
               <pre><code>func epipecheck(file *File, e error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errDeadlineExceeded" data-name="errDeadlineExceeded">
               <h3>
                  errDeadlineExceeded 
                  <span class="badge">function</span>
                  
                  <a href="#errDeadlineExceeded" class="anchor" title="Link to errDeadlineExceeded">#</a>
               </h3>
               
               <p>errDeadlineExceeded returns the value for os.ErrDeadlineExceeded.
This error comes from the internal/poll package, which is also
used by package net. Doing it this way ensures that the net
package will return os.ErrDeadlineExceeded for an exceeded deadline,
as documented by net.Conn.SetDeadline, without requiring any extra
work in the net package and without requiring the internal/poll
package to import os (which it can't, because that would be circular).</p>
               
               <pre><code>func errDeadlineExceeded() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errNoDeadline" data-name="errNoDeadline">
               <h3>
                  errNoDeadline 
                  <span class="badge">function</span>
                  
                  <a href="#errNoDeadline" class="anchor" title="Link to errNoDeadline">#</a>
               </h3>
               
               <pre><code>func errNoDeadline() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="executable" data-name="executable">
               <h3>
                  executable 
                  <span class="badge">function</span>
                  
                  <a href="#executable" class="anchor" title="Link to executable">#</a>
               </h3>
               
               <pre><code>func executable() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="executable" data-name="executable">
               <h3>
                  executable 
                  <span class="badge">function</span>
                  
                  <a href="#executable" class="anchor" title="Link to executable">#</a>
               </h3>
               
               <pre><code>func executable() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="executable" data-name="executable">
               <h3>
                  executable 
                  <span class="badge">function</span>
                  
                  <a href="#executable" class="anchor" title="Link to executable">#</a>
               </h3>
               
               <pre><code>func executable() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="executable" data-name="executable">
               <h3>
                  executable 
                  <span class="badge">function</span>
                  
                  <a href="#executable" class="anchor" title="Link to executable">#</a>
               </h3>
               
               <pre><code>func executable() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="executable" data-name="executable">
               <h3>
                  executable 
                  <span class="badge">function</span>
                  
                  <a href="#executable" class="anchor" title="Link to executable">#</a>
               </h3>
               
               <pre><code>func executable() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="executable" data-name="executable">
               <h3>
                  executable 
                  <span class="badge">function</span>
                  
                  <a href="#executable" class="anchor" title="Link to executable">#</a>
               </h3>
               
               <pre><code>func executable() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="executable" data-name="executable">
               <h3>
                  executable 
                  <span class="badge">function</span>
                  
                  <a href="#executable" class="anchor" title="Link to executable">#</a>
               </h3>
               
               <pre><code>func executable() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="executable" data-name="executable">
               <h3>
                  executable 
                  <span class="badge">function</span>
                  
                  <a href="#executable" class="anchor" title="Link to executable">#</a>
               </h3>
               
               <pre><code>func executable() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exited" data-name="exited">
               <h3>
                  exited 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exited" class="anchor" title="Link to exited">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) exited() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="exited" data-name="exited">
               <h3>
                  exited 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#exited" class="anchor" title="Link to exited">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) exited() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fileInfoFromStat" data-name="fileInfoFromStat">
               <h3>
                  fileInfoFromStat 
                  <span class="badge">function</span>
                  
                  <a href="#fileInfoFromStat" class="anchor" title="Link to fileInfoFromStat">#</a>
               </h3>
               
               <pre><code>func fileInfoFromStat(d *syscall.Dir) *fileStat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fillFileStatFromSys" data-name="fillFileStatFromSys">
               <h3>
                  fillFileStatFromSys 
                  <span class="badge">function</span>
                  
                  <a href="#fillFileStatFromSys" class="anchor" title="Link to fillFileStatFromSys">#</a>
               </h3>
               
               <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fillFileStatFromSys" data-name="fillFileStatFromSys">
               <h3>
                  fillFileStatFromSys 
                  <span class="badge">function</span>
                  
                  <a href="#fillFileStatFromSys" class="anchor" title="Link to fillFileStatFromSys">#</a>
               </h3>
               
               <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fillFileStatFromSys" data-name="fillFileStatFromSys">
               <h3>
                  fillFileStatFromSys 
                  <span class="badge">function</span>
                  
                  <a href="#fillFileStatFromSys" class="anchor" title="Link to fillFileStatFromSys">#</a>
               </h3>
               
               <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fillFileStatFromSys" data-name="fillFileStatFromSys">
               <h3>
                  fillFileStatFromSys 
                  <span class="badge">function</span>
                  
                  <a href="#fillFileStatFromSys" class="anchor" title="Link to fillFileStatFromSys">#</a>
               </h3>
               
               <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fillFileStatFromSys" data-name="fillFileStatFromSys">
               <h3>
                  fillFileStatFromSys 
                  <span class="badge">function</span>
                  
                  <a href="#fillFileStatFromSys" class="anchor" title="Link to fillFileStatFromSys">#</a>
               </h3>
               
               <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fillFileStatFromSys" data-name="fillFileStatFromSys">
               <h3>
                  fillFileStatFromSys 
                  <span class="badge">function</span>
                  
                  <a href="#fillFileStatFromSys" class="anchor" title="Link to fillFileStatFromSys">#</a>
               </h3>
               
               <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fillFileStatFromSys" data-name="fillFileStatFromSys">
               <h3>
                  fillFileStatFromSys 
                  <span class="badge">function</span>
                  
                  <a href="#fillFileStatFromSys" class="anchor" title="Link to fillFileStatFromSys">#</a>
               </h3>
               
               <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fillFileStatFromSys" data-name="fillFileStatFromSys">
               <h3>
                  fillFileStatFromSys 
                  <span class="badge">function</span>
                  
                  <a href="#fillFileStatFromSys" class="anchor" title="Link to fillFileStatFromSys">#</a>
               </h3>
               
               <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fillFileStatFromSys" data-name="fillFileStatFromSys">
               <h3>
                  fillFileStatFromSys 
                  <span class="badge">function</span>
                  
                  <a href="#fillFileStatFromSys" class="anchor" title="Link to fillFileStatFromSys">#</a>
               </h3>
               
               <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fillFileStatFromSys" data-name="fillFileStatFromSys">
               <h3>
                  fillFileStatFromSys 
                  <span class="badge">function</span>
                  
                  <a href="#fillFileStatFromSys" class="anchor" title="Link to fillFileStatFromSys">#</a>
               </h3>
               
               <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findProcess" data-name="findProcess">
               <h3>
                  findProcess 
                  <span class="badge">function</span>
                  
                  <a href="#findProcess" class="anchor" title="Link to findProcess">#</a>
               </h3>
               
               <pre><code>func findProcess(pid int) (p *Process, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findProcess" data-name="findProcess">
               <h3>
                  findProcess 
                  <span class="badge">function</span>
                  
                  <a href="#findProcess" class="anchor" title="Link to findProcess">#</a>
               </h3>
               
               <pre><code>func findProcess(pid int) (p *Process, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findProcess" data-name="findProcess">
               <h3>
                  findProcess 
                  <span class="badge">function</span>
                  
                  <a href="#findProcess" class="anchor" title="Link to findProcess">#</a>
               </h3>
               
               <pre><code>func findProcess(pid int) (p *Process, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixCount" data-name="fixCount">
               <h3>
                  fixCount 
                  <span class="badge">function</span>
                  
                  <a href="#fixCount" class="anchor" title="Link to fixCount">#</a>
               </h3>
               
               <p>Many functions in package syscall return a count of -1 instead of 0.
Using fixCount(call()) instead of call() corrects the count.</p>
               
               <pre><code>func fixCount(n int, err error) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixLongPath" data-name="fixLongPath">
               <h3>
                  fixLongPath 
                  <span class="badge">function</span>
                  
                  <a href="#fixLongPath" class="anchor" title="Link to fixLongPath">#</a>
               </h3>
               
               <p>fixLongPath is a noop on non-Windows platforms.</p>
               
               <pre><code>func fixLongPath(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixLongPath" data-name="fixLongPath">
               <h3>
                  fixLongPath 
                  <span class="badge">function</span>
                  
                  <a href="#fixLongPath" class="anchor" title="Link to fixLongPath">#</a>
               </h3>
               
               <p>fixLongPath returns the extended-length (\\?\-prefixed) form of
path when needed, in order to avoid the default 260 character file
path limit imposed by Windows. If the path is short enough or already
has the extended-length prefix, fixLongPath returns path unmodified.
If the path is relative and joining it with the current working
directory results in a path that is too long, fixLongPath returns
the absolute path with the extended-length prefix.
See https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation</p>
               
               <pre><code>func fixLongPath(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fixLongPath" data-name="fixLongPath">
               <h3>
                  fixLongPath 
                  <span class="badge">function</span>
                  
                  <a href="#fixLongPath" class="anchor" title="Link to fixLongPath">#</a>
               </h3>
               
               <p>fixLongPath is a noop on non-Windows platforms.</p>
               
               <pre><code>func fixLongPath(path string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ftToDuration" data-name="ftToDuration">
               <h3>
                  ftToDuration 
                  <span class="badge">function</span>
                  
                  <a href="#ftToDuration" class="anchor" title="Link to ftToDuration">#</a>
               </h3>
               
               <pre><code>func ftToDuration(ft *syscall.Filetime) time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="genericReadFrom" data-name="genericReadFrom">
               <h3>
                  genericReadFrom 
                  <span class="badge">function</span>
                  
                  <a href="#genericReadFrom" class="anchor" title="Link to genericReadFrom">#</a>
               </h3>
               
               <pre><code>func genericReadFrom(f *File, r io.Reader) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="genericWriteTo" data-name="genericWriteTo">
               <h3>
                  genericWriteTo 
                  <span class="badge">function</span>
                  
                  <a href="#genericWriteTo" class="anchor" title="Link to genericWriteTo">#</a>
               </h3>
               
               <pre><code>func genericWriteTo(f *File, w io.Writer) (int64, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getModuleFileName" data-name="getModuleFileName">
               <h3>
                  getModuleFileName 
                  <span class="badge">function</span>
                  
                  <a href="#getModuleFileName" class="anchor" title="Link to getModuleFileName">#</a>
               </h3>
               
               <pre><code>func getModuleFileName(handle syscall.Handle) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getPidfd" data-name="getPidfd">
               <h3>
                  getPidfd 
                  <span class="badge">function</span>
                  
                  <a href="#getPidfd" class="anchor" title="Link to getPidfd">#</a>
               </h3>
               
               <p>getPidfd returns the value of sysAttr.PidFD (or its duplicate if needDup is
set) and a flag indicating whether the value can be used.</p>
               
               <pre><code>func getPidfd(sysAttr *syscall.SysProcAttr, needDup bool) (uintptr, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getPidfd" data-name="getPidfd">
               <h3>
                  getPidfd 
                  <span class="badge">function</span>
                  
                  <a href="#getPidfd" class="anchor" title="Link to getPidfd">#</a>
               </h3>
               
               <pre><code>func getPidfd(_ *syscall.SysProcAttr, _ bool) (uintptr, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getPollFDAndNetwork" data-name="getPollFDAndNetwork">
               <h3>
                  getPollFDAndNetwork 
                  <span class="badge">function</span>
                  
                  <a href="#getPollFDAndNetwork" class="anchor" title="Link to getPollFDAndNetwork">#</a>
               </h3>
               
               <p>getPollFDAndNetwork tries to get the poll.FD and network type from the given interface
by expecting the underlying type of i to be the implementation of syscall.Conn
that contains a *net.rawConn.</p>
               
               <pre><code>func getPollFDAndNetwork(i any) (*poll.FD, poll.String)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getShellName" data-name="getShellName">
               <h3>
                  getShellName 
                  <span class="badge">function</span>
                  
                  <a href="#getShellName" class="anchor" title="Link to getShellName">#</a>
               </h3>
               
               <p>getShellName returns the name that begins the string and the number of bytes
consumed to extract it. If the name is enclosed in {}, it's part of a ${}
expansion and two more bytes are needed than the length of the name.</p>
               
               <pre><code>func getShellName(s string) (string, int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handlePersistentRelease" data-name="handlePersistentRelease">
               <h3>
                  handlePersistentRelease 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handlePersistentRelease" class="anchor" title="Link to handlePersistentRelease">#</a>
               </h3>
               
               <p>Drop the Process' persistent reference on the handle, deactivating future
Wait/Signal calls with the passed reason.
Returns the status prior to this call. If this is not statusOK, then the
reference was not dropped or status changed.</p>
               
               <pre><code>func (p *Process) handlePersistentRelease(reason processStatus) processStatus</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handleTransientAcquire" data-name="handleTransientAcquire">
               <h3>
                  handleTransientAcquire 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handleTransientAcquire" class="anchor" title="Link to handleTransientAcquire">#</a>
               </h3>
               
               <pre><code>func (p *Process) handleTransientAcquire() (uintptr, processStatus)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="handleTransientRelease" data-name="handleTransientRelease">
               <h3>
                  handleTransientRelease 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#handleTransientRelease" class="anchor" title="Link to handleTransientRelease">#</a>
               </h3>
               
               <pre><code>func (p *Process) handleTransientRelease()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hostname" data-name="hostname">
               <h3>
                  hostname 
                  <span class="badge">function</span>
                  
                  <a href="#hostname" class="anchor" title="Link to hostname">#</a>
               </h3>
               
               <pre><code>func hostname() (name string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hostname" data-name="hostname">
               <h3>
                  hostname 
                  <span class="badge">function</span>
                  
                  <a href="#hostname" class="anchor" title="Link to hostname">#</a>
               </h3>
               
               <pre><code>func hostname() (name string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hostname" data-name="hostname">
               <h3>
                  hostname 
                  <span class="badge">function</span>
                  
                  <a href="#hostname" class="anchor" title="Link to hostname">#</a>
               </h3>
               
               <pre><code>func hostname() (name string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hostname" data-name="hostname">
               <h3>
                  hostname 
                  <span class="badge">function</span>
                  
                  <a href="#hostname" class="anchor" title="Link to hostname">#</a>
               </h3>
               
               <pre><code>func hostname() (name string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hostname" data-name="hostname">
               <h3>
                  hostname 
                  <span class="badge">function</span>
                  
                  <a href="#hostname" class="anchor" title="Link to hostname">#</a>
               </h3>
               
               <pre><code>func hostname() (name string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hostname" data-name="hostname">
               <h3>
                  hostname 
                  <span class="badge">function</span>
                  
                  <a href="#hostname" class="anchor" title="Link to hostname">#</a>
               </h3>
               
               <pre><code>func hostname() (name string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ignoreSIGSYS" data-name="ignoreSIGSYS">
               <h3>
                  ignoreSIGSYS 
                  <span class="badge">function</span>
                  
                  <a href="#ignoreSIGSYS" class="anchor" title="Link to ignoreSIGSYS">#</a>
               </h3>
               
               <p>Provided by runtime.
go:linkname ignoreSIGSYS</p>
               
               <pre><code>func ignoreSIGSYS()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ignoringEINTR" data-name="ignoringEINTR">
               <h3>
                  ignoringEINTR 
                  <span class="badge">function</span>
                  
                  <a href="#ignoringEINTR" class="anchor" title="Link to ignoringEINTR">#</a>
               </h3>
               
               <p>ignoringEINTR makes a function call and repeats it if it returns an
EINTR error. This appears to be required even though we install all
signal handlers with SA_RESTART: see #22838, #38033, #38836, #40846.
Also #20400 and #36644 are issues in which a signal handler is
installed without setting SA_RESTART. None of these are the common case,
but there are enough of them that it seems that we can't avoid
an EINTR loop.</p>
               
               <pre><code>func ignoringEINTR(fn func() error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ignoringEINTR" data-name="ignoringEINTR">
               <h3>
                  ignoringEINTR 
                  <span class="badge">function</span>
                  
                  <a href="#ignoringEINTR" class="anchor" title="Link to ignoringEINTR">#</a>
               </h3>
               
               <pre><code>func ignoringEINTR(fn func() error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ignoringEINTR2" data-name="ignoringEINTR2">
               <h3>
                  ignoringEINTR2 
                  <span class="badge">function</span>
                  
                  <a href="#ignoringEINTR2" class="anchor" title="Link to ignoringEINTR2">#</a>
               </h3>
               
               <pre><code>func ignoringEINTR2(fn func() (T, error)) (T, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ignoringEINTR2" data-name="ignoringEINTR2">
               <h3>
                  ignoringEINTR2 
                  <span class="badge">function</span>
                  
                  <a href="#ignoringEINTR2" class="anchor" title="Link to ignoringEINTR2">#</a>
               </h3>
               
               <p>ignoringEINTR2 is ignoringEINTR, but returning an additional value.</p>
               
               <pre><code>func ignoringEINTR2(fn func() (T, error)) (T, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="incref" data-name="incref">
               <h3>
                  incref 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#incref" class="anchor" title="Link to incref">#</a>
               </h3>
               
               <p>incref adds a reference to the file. It returns an error if the file
is already closed. This method is on File so that we can incorporate
a nil test.</p>
               
               <pre><code>func (f *File) incref(op string) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="incref" data-name="incref">
               <h3>
                  incref 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#incref" class="anchor" title="Link to incref">#</a>
               </h3>
               
               <pre><code>func (r *root) incref() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func (d *dirInfo) init(h syscall.Handle)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isAlphaNum" data-name="isAlphaNum">
               <h3>
                  isAlphaNum 
                  <span class="badge">function</span>
                  
                  <a href="#isAlphaNum" class="anchor" title="Link to isAlphaNum">#</a>
               </h3>
               
               <p>isAlphaNum reports whether the byte is an ASCII letter, number, or underscore.</p>
               
               <pre><code>func isAlphaNum(c uint8) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isExecutable" data-name="isExecutable">
               <h3>
                  isExecutable 
                  <span class="badge">function</span>
                  
                  <a href="#isExecutable" class="anchor" title="Link to isExecutable">#</a>
               </h3>
               
               <p>isExecutable returns an error if a given file is not an executable.</p>
               
               <pre><code>func isExecutable(path string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNoFollowErr" data-name="isNoFollowErr">
               <h3>
                  isNoFollowErr 
                  <span class="badge">function</span>
                  
                  <a href="#isNoFollowErr" class="anchor" title="Link to isNoFollowErr">#</a>
               </h3>
               
               <p>isNoFollowErr reports whether err may result from O_NOFOLLOW blocking an open operation.</p>
               
               <pre><code>func isNoFollowErr(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isNoFollowErr" data-name="isNoFollowErr">
               <h3>
                  isNoFollowErr 
                  <span class="badge">function</span>
                  
                  <a href="#isNoFollowErr" class="anchor" title="Link to isNoFollowErr">#</a>
               </h3>
               
               <p>isNoFollowErr reports whether err may result from O_NOFOLLOW blocking an open operation.</p>
               
               <pre><code>func isNoFollowErr(err error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isReparseTagNameSurrogate" data-name="isReparseTagNameSurrogate">
               <h3>
                  isReparseTagNameSurrogate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isReparseTagNameSurrogate" class="anchor" title="Link to isReparseTagNameSurrogate">#</a>
               </h3>
               
               <p>isReparseTagNameSurrogate determines whether a tag's associated
reparse point is a surrogate for another named entity (for example, a mounted folder).
See https://learn.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-isreparsetagnamesurrogate
and https://learn.microsoft.com/en-us/windows/win32/fileio/reparse-point-tags.</p>
               
               <pre><code>func (fs *fileStat) isReparseTagNameSurrogate() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isShellSpecialVar" data-name="isShellSpecialVar">
               <h3>
                  isShellSpecialVar 
                  <span class="badge">function</span>
                  
                  <a href="#isShellSpecialVar" class="anchor" title="Link to isShellSpecialVar">#</a>
               </h3>
               
               <p>isShellSpecialVar reports whether the character identifies a special
shell variable such as $*.</p>
               
               <pre><code>func isShellSpecialVar(c uint8) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isUnixOrTCP" data-name="isUnixOrTCP">
               <h3>
                  isUnixOrTCP 
                  <span class="badge">function</span>
                  
                  <a href="#isUnixOrTCP" class="anchor" title="Link to isUnixOrTCP">#</a>
               </h3>
               
               <pre><code>func isUnixOrTCP(network string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isValidRootFSPath" data-name="isValidRootFSPath">
               <h3>
                  isValidRootFSPath 
                  <span class="badge">function</span>
                  
                  <a href="#isValidRootFSPath" class="anchor" title="Link to isValidRootFSPath">#</a>
               </h3>
               
               <p>isValidRootFSPath reprots whether name is a valid filename to pass a Root.FS method.</p>
               
               <pre><code>func isValidRootFSPath(name string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="join" data-name="join">
               <h3>
                  join 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#join" class="anchor" title="Link to join">#</a>
               </h3>
               
               <p>join returns the path for name in dir.</p>
               
               <pre><code>func (dir dirFS) join(name string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="joinPath" data-name="joinPath">
               <h3>
                  joinPath 
                  <span class="badge">function</span>
                  
                  <a href="#joinPath" class="anchor" title="Link to joinPath">#</a>
               </h3>
               
               <pre><code>func joinPath(dir string, name string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="kill" data-name="kill">
               <h3>
                  kill 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#kill" class="anchor" title="Link to kill">#</a>
               </h3>
               
               <pre><code>func (p *Process) kill() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="kill" data-name="kill">
               <h3>
                  kill 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#kill" class="anchor" title="Link to kill">#</a>
               </h3>
               
               <pre><code>func (p *Process) kill() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="loadFileId" data-name="loadFileId">
               <h3>
                  loadFileId 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#loadFileId" class="anchor" title="Link to loadFileId">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) loadFileId() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logOpen" data-name="logOpen">
               <h3>
                  logOpen 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logOpen" class="anchor" title="Link to logOpen">#</a>
               </h3>
               
               <pre><code>func (r *Root) logOpen(name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logStat" data-name="logStat">
               <h3>
                  logStat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#logStat" class="anchor" title="Link to logStat">#</a>
               </h3>
               
               <pre><code>func (r *Root) logStat(name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lstatNolog" data-name="lstatNolog">
               <h3>
                  lstatNolog 
                  <span class="badge">function</span>
                  
                  <a href="#lstatNolog" class="anchor" title="Link to lstatNolog">#</a>
               </h3>
               
               <p>lstatNolog implements Lstat for Plan 9.</p>
               
               <pre><code>func lstatNolog(name string) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lstatNolog" data-name="lstatNolog">
               <h3>
                  lstatNolog 
                  <span class="badge">function</span>
                  
                  <a href="#lstatNolog" class="anchor" title="Link to lstatNolog">#</a>
               </h3>
               
               <p>lstatNolog implements Lstat for Windows.</p>
               
               <pre><code>func lstatNolog(name string) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lstatNolog" data-name="lstatNolog">
               <h3>
                  lstatNolog 
                  <span class="badge">function</span>
                  
                  <a href="#lstatNolog" class="anchor" title="Link to lstatNolog">#</a>
               </h3>
               
               <p>lstatNolog lstats a file with no test logging.</p>
               
               <pre><code>func lstatNolog(name string) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mkdirat" data-name="mkdirat">
               <h3>
                  mkdirat 
                  <span class="badge">function</span>
                  
                  <a href="#mkdirat" class="anchor" title="Link to mkdirat">#</a>
               </h3>
               
               <pre><code>func mkdirat(dirfd syscall.Handle, name string, perm FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mkdirat" data-name="mkdirat">
               <h3>
                  mkdirat 
                  <span class="badge">function</span>
                  
                  <a href="#mkdirat" class="anchor" title="Link to mkdirat">#</a>
               </h3>
               
               <pre><code>func mkdirat(fd int, name string, perm FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="mode" data-name="mode">
               <h3>
                  mode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#mode" class="anchor" title="Link to mode">#</a>
               </h3>
               
               <pre><code>func (fs *fileStat) mode() (m FileMode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="modePreGo1_23" data-name="modePreGo1_23">
               <h3>
                  modePreGo1_23 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#modePreGo1_23" class="anchor" title="Link to modePreGo1_23">#</a>
               </h3>
               
               <p>modePreGo1_23 returns the FileMode for the fileStat, using the pre-Go 1.23
logic for determining the file mode.
The logic is subtle and not well-documented, so it is better to keep it
separate from the new logic.</p>
               
               <pre><code>func (fs *fileStat) modePreGo1_23() (m FileMode)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="net_newUnixFile" data-name="net_newUnixFile">
               <h3>
                  net_newUnixFile 
                  <span class="badge">function</span>
                  
                  <a href="#net_newUnixFile" class="anchor" title="Link to net_newUnixFile">#</a>
               </h3>
               
               <p>net_newUnixFile is a hidden entry point called by net.conn.File.
This is used so that a nonblocking network connection will become
blocking if code calls the Fd method. We don't want that for direct
calls to NewFile: passing a nonblocking descriptor to NewFile should
remain nonblocking if you get it back using Fd. But for net.conn.File
the call to NewFile is hidden from the user. Historically in that case
the Fd method has returned a blocking descriptor, and we want to
retain that behavior because existing code expects it and depends on it.
go:linkname net_newUnixFile net.newUnixFile</p>
               
               <pre><code>func net_newUnixFile(fd int, name string) *File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newConsoleFile" data-name="newConsoleFile">
               <h3>
                  newConsoleFile 
                  <span class="badge">function</span>
                  
                  <a href="#newConsoleFile" class="anchor" title="Link to newConsoleFile">#</a>
               </h3>
               
               <p>newConsoleFile creates new File that will be used as console.</p>
               
               <pre><code>func newConsoleFile(h syscall.Handle, name string) *File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newDoneProcess" data-name="newDoneProcess">
               <h3>
                  newDoneProcess 
                  <span class="badge">function</span>
                  
                  <a href="#newDoneProcess" class="anchor" title="Link to newDoneProcess">#</a>
               </h3>
               
               <pre><code>func newDoneProcess(pid int) *Process</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newFile" data-name="newFile">
               <h3>
                  newFile 
                  <span class="badge">function</span>
                  
                  <a href="#newFile" class="anchor" title="Link to newFile">#</a>
               </h3>
               
               <p>newFile is like NewFile, but if called from OpenFile or Pipe
(as passed in the kind parameter) it tries to add the file to
the runtime poller.</p>
               
               <pre><code>func newFile(fd int, name string, kind newFileKind, nonBlocking bool) *File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newFile" data-name="newFile">
               <h3>
                  newFile 
                  <span class="badge">function</span>
                  
                  <a href="#newFile" class="anchor" title="Link to newFile">#</a>
               </h3>
               
               <p>newFile returns a new File with the given file handle and name.
Unlike NewFile, it does not check that h is syscall.InvalidHandle.</p>
               
               <pre><code>func newFile(h syscall.Handle, name string, kind string) *File</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newFileStatFromFileFullDirInfo" data-name="newFileStatFromFileFullDirInfo">
               <h3>
                  newFileStatFromFileFullDirInfo 
                  <span class="badge">function</span>
                  
                  <a href="#newFileStatFromFileFullDirInfo" class="anchor" title="Link to newFileStatFromFileFullDirInfo">#</a>
               </h3>
               
               <p>newFileStatFromFileFullDirInfo copies all required information
from windows.FILE_FULL_DIR_INFO d into the newly created fileStat.</p>
               
               <pre><code>func newFileStatFromFileFullDirInfo(d *windows.FILE_FULL_DIR_INFO) *fileStat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newFileStatFromFileIDBothDirInfo" data-name="newFileStatFromFileIDBothDirInfo">
               <h3>
                  newFileStatFromFileIDBothDirInfo 
                  <span class="badge">function</span>
                  
                  <a href="#newFileStatFromFileIDBothDirInfo" class="anchor" title="Link to newFileStatFromFileIDBothDirInfo">#</a>
               </h3>
               
               <p>newFileStatFromFileIDBothDirInfo copies all required information
from windows.FILE_ID_BOTH_DIR_INFO d into the newly created fileStat.</p>
               
               <pre><code>func newFileStatFromFileIDBothDirInfo(d *windows.FILE_ID_BOTH_DIR_INFO) *fileStat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newFileStatFromGetFileInformationByHandle" data-name="newFileStatFromGetFileInformationByHandle">
               <h3>
                  newFileStatFromGetFileInformationByHandle 
                  <span class="badge">function</span>
                  
                  <a href="#newFileStatFromGetFileInformationByHandle" class="anchor" title="Link to newFileStatFromGetFileInformationByHandle">#</a>
               </h3>
               
               <p>newFileStatFromGetFileInformationByHandle calls GetFileInformationByHandle
to gather all required information about the file handle h.</p>
               
               <pre><code>func newFileStatFromGetFileInformationByHandle(path string, h syscall.Handle) (fs *fileStat, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newFileStatFromWin32FileAttributeData" data-name="newFileStatFromWin32FileAttributeData">
               <h3>
                  newFileStatFromWin32FileAttributeData 
                  <span class="badge">function</span>
                  
                  <a href="#newFileStatFromWin32FileAttributeData" class="anchor" title="Link to newFileStatFromWin32FileAttributeData">#</a>
               </h3>
               
               <p>newFileStatFromWin32FileAttributeData copies all required information
from syscall.Win32FileAttributeData d into the newly created fileStat.</p>
               
               <pre><code>func newFileStatFromWin32FileAttributeData(d *syscall.Win32FileAttributeData) *fileStat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newFileStatFromWin32finddata" data-name="newFileStatFromWin32finddata">
               <h3>
                  newFileStatFromWin32finddata 
                  <span class="badge">function</span>
                  
                  <a href="#newFileStatFromWin32finddata" class="anchor" title="Link to newFileStatFromWin32finddata">#</a>
               </h3>
               
               <p>newFileStatFromWin32finddata copies all required information
from syscall.Win32finddata d into the newly created fileStat.</p>
               
               <pre><code>func newFileStatFromWin32finddata(d *syscall.Win32finddata) *fileStat</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newHandleProcess" data-name="newHandleProcess">
               <h3>
                  newHandleProcess 
                  <span class="badge">function</span>
                  
                  <a href="#newHandleProcess" class="anchor" title="Link to newHandleProcess">#</a>
               </h3>
               
               <pre><code>func newHandleProcess(pid int, handle uintptr) *Process</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newPIDProcess" data-name="newPIDProcess">
               <h3>
                  newPIDProcess 
                  <span class="badge">function</span>
                  
                  <a href="#newPIDProcess" class="anchor" title="Link to newPIDProcess">#</a>
               </h3>
               
               <pre><code>func newPIDProcess(pid int) *Process</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newRawConn" data-name="newRawConn">
               <h3>
                  newRawConn 
                  <span class="badge">function</span>
                  
                  <a href="#newRawConn" class="anchor" title="Link to newRawConn">#</a>
               </h3>
               
               <pre><code>func newRawConn(file *File) (*rawConn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newRawConn" data-name="newRawConn">
               <h3>
                  newRawConn 
                  <span class="badge">function</span>
                  
                  <a href="#newRawConn" class="anchor" title="Link to newRawConn">#</a>
               </h3>
               
               <pre><code>func newRawConn(file *File) (*rawConn, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newRoot" data-name="newRoot">
               <h3>
                  newRoot 
                  <span class="badge">function</span>
                  
                  <a href="#newRoot" class="anchor" title="Link to newRoot">#</a>
               </h3>
               
               <p>newRoot returns a new Root.
If fd is not a directory, it closes it and returns an error.</p>
               
               <pre><code>func newRoot(name string) (*Root, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newRoot" data-name="newRoot">
               <h3>
                  newRoot 
                  <span class="badge">function</span>
                  
                  <a href="#newRoot" class="anchor" title="Link to newRoot">#</a>
               </h3>
               
               <p>newRoot returns a new Root.
If fd is not a directory, it closes it and returns an error.</p>
               
               <pre><code>func newRoot(fd int, name string) (*Root, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newRoot" data-name="newRoot">
               <h3>
                  newRoot 
                  <span class="badge">function</span>
                  
                  <a href="#newRoot" class="anchor" title="Link to newRoot">#</a>
               </h3>
               
               <p>newRoot returns a new Root.
If fd is not a directory, it closes it and returns an error.</p>
               
               <pre><code>func newRoot(fd syscall.Handle, name string) (*Root, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newUnixDirent" data-name="newUnixDirent">
               <h3>
                  newUnixDirent 
                  <span class="badge">function</span>
                  
                  <a href="#newUnixDirent" class="anchor" title="Link to newUnixDirent">#</a>
               </h3>
               
               <pre><code>func newUnixDirent(parent string, name string, typ FileMode) (DirEntry, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextRandom" data-name="nextRandom">
               <h3>
                  nextRandom 
                  <span class="badge">function</span>
                  
                  <a href="#nextRandom" class="anchor" title="Link to nextRandom">#</a>
               </h3>
               
               <pre><code>func nextRandom() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="normaliseLinkPath" data-name="normaliseLinkPath">
               <h3>
                  normaliseLinkPath 
                  <span class="badge">function</span>
                  
                  <a href="#normaliseLinkPath" class="anchor" title="Link to normaliseLinkPath">#</a>
               </h3>
               
               <p>normaliseLinkPath converts absolute paths returned by
DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, ...)
into paths acceptable by all Windows APIs.
For example, it converts
\??\C:\foo\bar into C:\foo\bar
\??\UNC\foo\bar into \\foo\bar
\??\Volume{abc}\ into \\?\Volume{abc}\</p>
               
               <pre><code>func normaliseLinkPath(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="open" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
                  <a href="#open" class="anchor" title="Link to open">#</a>
               </h3>
               
               <pre><code>func open(filePath string, flag int, perm uint32) (int, poll.SysFile, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="open" data-name="open">
               <h3>
                  open 
                  <span class="badge">function</span>
                  
                  <a href="#open" class="anchor" title="Link to open">#</a>
               </h3>
               
               <pre><code>func open(path string, flag int, perm uint32) (int, poll.SysFile, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openDir" data-name="openDir">
               <h3>
                  openDir 
                  <span class="badge">function</span>
                  
                  <a href="#openDir" class="anchor" title="Link to openDir">#</a>
               </h3>
               
               <p>openDir opens a file which is assumed to be a directory. As such, it skips
the syscalls that make the file descriptor non-blocking as these take time
and will fail on file descriptors for directories.</p>
               
               <pre><code>func openDir(name string) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openDirAt" data-name="openDirAt">
               <h3>
                  openDirAt 
                  <span class="badge">function</span>
                  
                  <a href="#openDirAt" class="anchor" title="Link to openDirAt">#</a>
               </h3>
               
               <p>openDirAt opens a directory name relative to the directory referred to by
the file descriptor dirfd. If name is anything but a directory (this
includes a symlink to one), it should return an error. Other than that this
should act like openFileNolog.
This acts like openFileNolog rather than OpenFile because
we are going to (try to) remove the file.
The contents of this file are not relevant for test caching.</p>
               
               <pre><code>func openDirAt(dirfd int, name string) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openDirNolog" data-name="openDirNolog">
               <h3>
                  openDirNolog 
                  <span class="badge">function</span>
                  
                  <a href="#openDirNolog" class="anchor" title="Link to openDirNolog">#</a>
               </h3>
               
               <pre><code>func openDirNolog(name string) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openDirNolog" data-name="openDirNolog">
               <h3>
                  openDirNolog 
                  <span class="badge">function</span>
                  
                  <a href="#openDirNolog" class="anchor" title="Link to openDirNolog">#</a>
               </h3>
               
               <pre><code>func openDirNolog(name string) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openDirNolog" data-name="openDirNolog">
               <h3>
                  openDirNolog 
                  <span class="badge">function</span>
                  
                  <a href="#openDirNolog" class="anchor" title="Link to openDirNolog">#</a>
               </h3>
               
               <pre><code>func openDirNolog(name string) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openFileNolog" data-name="openFileNolog">
               <h3>
                  openFileNolog 
                  <span class="badge">function</span>
                  
                  <a href="#openFileNolog" class="anchor" title="Link to openFileNolog">#</a>
               </h3>
               
               <p>openFileNolog is the Plan 9 implementation of OpenFile.</p>
               
               <pre><code>func openFileNolog(name string, flag int, perm FileMode) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openFileNolog" data-name="openFileNolog">
               <h3>
                  openFileNolog 
                  <span class="badge">function</span>
                  
                  <a href="#openFileNolog" class="anchor" title="Link to openFileNolog">#</a>
               </h3>
               
               <p>openFileNolog is the Unix implementation of OpenFile.
Changes here should be reflected in openDirAt and openDirNolog, if relevant.</p>
               
               <pre><code>func openFileNolog(name string, flag int, perm FileMode) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openFileNolog" data-name="openFileNolog">
               <h3>
                  openFileNolog 
                  <span class="badge">function</span>
                  
                  <a href="#openFileNolog" class="anchor" title="Link to openFileNolog">#</a>
               </h3>
               
               <p>openFileNolog is the Windows implementation of OpenFile.</p>
               
               <pre><code>func openFileNolog(name string, flag int, perm FileMode) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openRootInRoot" data-name="openRootInRoot">
               <h3>
                  openRootInRoot 
                  <span class="badge">function</span>
                  
                  <a href="#openRootInRoot" class="anchor" title="Link to openRootInRoot">#</a>
               </h3>
               
               <p>openRootInRoot is Root.OpenRoot.</p>
               
               <pre><code>func openRootInRoot(r *Root, name string) (*Root, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openRootInRoot" data-name="openRootInRoot">
               <h3>
                  openRootInRoot 
                  <span class="badge">function</span>
                  
                  <a href="#openRootInRoot" class="anchor" title="Link to openRootInRoot">#</a>
               </h3>
               
               <p>openRootInRoot is Root.OpenRoot.</p>
               
               <pre><code>func openRootInRoot(r *Root, name string) (*Root, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openRootInRoot" data-name="openRootInRoot">
               <h3>
                  openRootInRoot 
                  <span class="badge">function</span>
                  
                  <a href="#openRootInRoot" class="anchor" title="Link to openRootInRoot">#</a>
               </h3>
               
               <p>openRootInRoot is Root.OpenRoot.</p>
               
               <pre><code>func openRootInRoot(r *Root, name string) (*Root, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openRootNolog" data-name="openRootNolog">
               <h3>
                  openRootNolog 
                  <span class="badge">function</span>
                  
                  <a href="#openRootNolog" class="anchor" title="Link to openRootNolog">#</a>
               </h3>
               
               <p>openRootNolog is OpenRoot.</p>
               
               <pre><code>func openRootNolog(name string) (*Root, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openRootNolog" data-name="openRootNolog">
               <h3>
                  openRootNolog 
                  <span class="badge">function</span>
                  
                  <a href="#openRootNolog" class="anchor" title="Link to openRootNolog">#</a>
               </h3>
               
               <p>openRootNolog is OpenRoot.</p>
               
               <pre><code>func openRootNolog(name string) (*Root, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openRootNolog" data-name="openRootNolog">
               <h3>
                  openRootNolog 
                  <span class="badge">function</span>
                  
                  <a href="#openRootNolog" class="anchor" title="Link to openRootNolog">#</a>
               </h3>
               
               <p>openRootNolog is OpenRoot.</p>
               
               <pre><code>func openRootNolog(name string) (*Root, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openSymlink" data-name="openSymlink">
               <h3>
                  openSymlink 
                  <span class="badge">function</span>
                  
                  <a href="#openSymlink" class="anchor" title="Link to openSymlink">#</a>
               </h3>
               
               <p>openSymlink calls CreateFile Windows API with FILE_FLAG_OPEN_REPARSE_POINT
parameter, so that Windows does not follow symlink, if path is a symlink.
openSymlink returns opened file handle.</p>
               
               <pre><code>func openSymlink(path string) (syscall.Handle, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openat" data-name="openat">
               <h3>
                  openat 
                  <span class="badge">function</span>
                  
                  <a href="#openat" class="anchor" title="Link to openat">#</a>
               </h3>
               
               <pre><code>func openat(dirfd syscall.Handle, name string, flag int, perm FileMode) (syscall.Handle, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pidDeactivate" data-name="pidDeactivate">
               <h3>
                  pidDeactivate 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pidDeactivate" class="anchor" title="Link to pidDeactivate">#</a>
               </h3>
               
               <pre><code>func (p *Process) pidDeactivate(reason processStatus)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pidSignal" data-name="pidSignal">
               <h3>
                  pidSignal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pidSignal" class="anchor" title="Link to pidSignal">#</a>
               </h3>
               
               <pre><code>func (p *Process) pidSignal(s syscall.Signal) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pidStatus" data-name="pidStatus">
               <h3>
                  pidStatus 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pidStatus" class="anchor" title="Link to pidStatus">#</a>
               </h3>
               
               <pre><code>func (p *Process) pidStatus() processStatus</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pidWait" data-name="pidWait">
               <h3>
                  pidWait 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pidWait" class="anchor" title="Link to pidWait">#</a>
               </h3>
               
               <pre><code>func (p *Process) pidWait() (*ProcessState, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pidfdFind" data-name="pidfdFind">
               <h3>
                  pidfdFind 
                  <span class="badge">function</span>
                  
                  <a href="#pidfdFind" class="anchor" title="Link to pidfdFind">#</a>
               </h3>
               
               <pre><code>func pidfdFind(_ int) (uintptr, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pidfdFind" data-name="pidfdFind">
               <h3>
                  pidfdFind 
                  <span class="badge">function</span>
                  
                  <a href="#pidfdFind" class="anchor" title="Link to pidfdFind">#</a>
               </h3>
               
               <pre><code>func pidfdFind(pid int) (uintptr, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pidfdSendSignal" data-name="pidfdSendSignal">
               <h3>
                  pidfdSendSignal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pidfdSendSignal" class="anchor" title="Link to pidfdSendSignal">#</a>
               </h3>
               
               <pre><code>func (p *Process) pidfdSendSignal(s syscall.Signal) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pidfdSendSignal" data-name="pidfdSendSignal">
               <h3>
                  pidfdSendSignal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pidfdSendSignal" class="anchor" title="Link to pidfdSendSignal">#</a>
               </h3>
               
               <pre><code>func (_ *Process) pidfdSendSignal(_ syscall.Signal) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pidfdWait" data-name="pidfdWait">
               <h3>
                  pidfdWait 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pidfdWait" class="anchor" title="Link to pidfdWait">#</a>
               </h3>
               
               <pre><code>func (p *Process) pidfdWait() (*ProcessState, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pidfdWait" data-name="pidfdWait">
               <h3>
                  pidfdWait 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pidfdWait" class="anchor" title="Link to pidfdWait">#</a>
               </h3>
               
               <pre><code>func (_ *Process) pidfdWait() (*ProcessState, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pidfdWorks" data-name="pidfdWorks">
               <h3>
                  pidfdWorks 
                  <span class="badge">function</span>
                  
                  <a href="#pidfdWorks" class="anchor" title="Link to pidfdWorks">#</a>
               </h3>
               
               <pre><code>func pidfdWorks() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pread" data-name="pread">
               <h3>
                  pread 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pread" class="anchor" title="Link to pread">#</a>
               </h3>
               
               <p>pread reads len(b) bytes from the File starting at byte offset off.
It returns the number of bytes read and the error, if any.
EOF is signaled by a zero count with err set to nil.</p>
               
               <pre><code>func (f *File) pread(b []byte, off int64) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pread" data-name="pread">
               <h3>
                  pread 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pread" class="anchor" title="Link to pread">#</a>
               </h3>
               
               <p>pread reads len(b) bytes from the File starting at byte offset off.
It returns the number of bytes read and the error, if any.
EOF is signaled by a zero count with err set to nil.</p>
               
               <pre><code>func (f *File) pread(b []byte, off int64) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="prefixAndSuffix" data-name="prefixAndSuffix">
               <h3>
                  prefixAndSuffix 
                  <span class="badge">function</span>
                  
                  <a href="#prefixAndSuffix" class="anchor" title="Link to prefixAndSuffix">#</a>
               </h3>
               
               <p>prefixAndSuffix splits pattern by the last wildcard "*", if applicable,
returning prefix as the part before "*" and suffix as the part after "*".</p>
               
               <pre><code>func prefixAndSuffix(pattern string) (prefix string, suffix string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pwrite" data-name="pwrite">
               <h3>
                  pwrite 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pwrite" class="anchor" title="Link to pwrite">#</a>
               </h3>
               
               <p>pwrite writes len(b) bytes to the File starting at byte offset off.
It returns the number of bytes written and an error, if any.
Since Plan 9 preserves message boundaries, never allow
a zero-byte write.</p>
               
               <pre><code>func (f *File) pwrite(b []byte, off int64) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pwrite" data-name="pwrite">
               <h3>
                  pwrite 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pwrite" class="anchor" title="Link to pwrite">#</a>
               </h3>
               
               <p>pwrite writes len(b) bytes to the File starting at byte offset off.
It returns the number of bytes written and an error, if any.</p>
               
               <pre><code>func (f *File) pwrite(b []byte, off int64) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="read" data-name="read">
               <h3>
                  read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#read" class="anchor" title="Link to read">#</a>
               </h3>
               
               <p>read reads up to len(b) bytes from the File.
It returns the number of bytes read and an error, if any.</p>
               
               <pre><code>func (f *File) read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="read" data-name="read">
               <h3>
                  read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#read" class="anchor" title="Link to read">#</a>
               </h3>
               
               <p>read reads up to len(b) bytes from the File.
It returns the number of bytes read and an error, if any.</p>
               
               <pre><code>func (f *File) read(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFileContents" data-name="readFileContents">
               <h3>
                  readFileContents 
                  <span class="badge">function</span>
                  
                  <a href="#readFileContents" class="anchor" title="Link to readFileContents">#</a>
               </h3>
               
               <pre><code>func readFileContents(f *File) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFrom" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readFrom" class="anchor" title="Link to readFrom">#</a>
               </h3>
               
               <pre><code>func (f *File) readFrom(r io.Reader) (written int64, handled bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFrom" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readFrom" class="anchor" title="Link to readFrom">#</a>
               </h3>
               
               <pre><code>func (f *File) readFrom(r io.Reader) (written int64, handled bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFrom" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readFrom" class="anchor" title="Link to readFrom">#</a>
               </h3>
               
               <pre><code>func (f *File) readFrom(r io.Reader) (n int64, handled bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readFrom" data-name="readFrom">
               <h3>
                  readFrom 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readFrom" class="anchor" title="Link to readFrom">#</a>
               </h3>
               
               <p>readFrom is basically a refactor of net.sendFile, but adapted to work for the target of *File.</p>
               
               <pre><code>func (f *File) readFrom(r io.Reader) (written int64, handled bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readInt" data-name="readInt">
               <h3>
                  readInt 
                  <span class="badge">function</span>
                  
                  <a href="#readInt" class="anchor" title="Link to readInt">#</a>
               </h3>
               
               <p>readInt returns the size-bytes unsigned integer in native byte order at offset off.</p>
               
               <pre><code>func readInt(b []byte, off uintptr, size uintptr) (u uint64, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readIntBE" data-name="readIntBE">
               <h3>
                  readIntBE 
                  <span class="badge">function</span>
                  
                  <a href="#readIntBE" class="anchor" title="Link to readIntBE">#</a>
               </h3>
               
               <pre><code>func readIntBE(b []byte, size uintptr) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readIntLE" data-name="readIntLE">
               <h3>
                  readIntLE 
                  <span class="badge">function</span>
                  
                  <a href="#readIntLE" class="anchor" title="Link to readIntLE">#</a>
               </h3>
               
               <pre><code>func readIntLE(b []byte, size uintptr) uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readLock" data-name="readLock">
               <h3>
                  readLock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readLock" class="anchor" title="Link to readLock">#</a>
               </h3>
               
               <p>readLock adds a reference to the file and locks it for reading.
It returns an error if the file is already closed.</p>
               
               <pre><code>func (file *file) readLock() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readNextArg" data-name="readNextArg">
               <h3>
                  readNextArg 
                  <span class="badge">function</span>
                  
                  <a href="#readNextArg" class="anchor" title="Link to readNextArg">#</a>
               </h3>
               
               <p>readNextArg splits command line string cmd into next
argument and command line remainder.</p>
               
               <pre><code>func readNextArg(cmd string) (arg []byte, rest string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readReparseLink" data-name="readReparseLink">
               <h3>
                  readReparseLink 
                  <span class="badge">function</span>
                  
                  <a href="#readReparseLink" class="anchor" title="Link to readReparseLink">#</a>
               </h3>
               
               <pre><code>func readReparseLink(path string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readReparseLinkAt" data-name="readReparseLinkAt">
               <h3>
                  readReparseLinkAt 
                  <span class="badge">function</span>
                  
                  <a href="#readReparseLinkAt" class="anchor" title="Link to readReparseLinkAt">#</a>
               </h3>
               
               <pre><code>func readReparseLinkAt(dirfd syscall.Handle, name string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readReparseLinkHandle" data-name="readReparseLinkHandle">
               <h3>
                  readReparseLinkHandle 
                  <span class="badge">function</span>
                  
                  <a href="#readReparseLinkHandle" class="anchor" title="Link to readReparseLinkHandle">#</a>
               </h3>
               
               <pre><code>func readReparseLinkHandle(h syscall.Handle) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readUnlock" data-name="readUnlock">
               <h3>
                  readUnlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readUnlock" class="anchor" title="Link to readUnlock">#</a>
               </h3>
               
               <p>readUnlock removes a reference from the file and unlocks it for reading.
It also closes the file if it marked as closed and there is no remaining
reference.</p>
               
               <pre><code>func (file *file) readUnlock()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readdir" data-name="readdir">
               <h3>
                  readdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readdir" class="anchor" title="Link to readdir">#</a>
               </h3>
               
               <pre><code>func (f *File) readdir(n int, mode readdirMode) (names []string, dirents []DirEntry, infos []FileInfo, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readdir" data-name="readdir">
               <h3>
                  readdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readdir" class="anchor" title="Link to readdir">#</a>
               </h3>
               
               <pre><code>func (f *File) readdir(n int, mode readdirMode) (names []string, dirents []DirEntry, infos []FileInfo, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readdir" data-name="readdir">
               <h3>
                  readdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readdir" class="anchor" title="Link to readdir">#</a>
               </h3>
               
               <pre><code>func (file *File) readdir(n int, mode readdirMode) (names []string, dirents []DirEntry, infos []FileInfo, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readdir" data-name="readdir">
               <h3>
                  readdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readdir" class="anchor" title="Link to readdir">#</a>
               </h3>
               
               <pre><code>func (file *File) readdir(n int, mode readdirMode) (names []string, dirents []DirEntry, infos []FileInfo, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readdir_r" data-name="readdir_r">
               <h3>
                  readdir_r 
                  <span class="badge">function</span>
                  
                  <a href="#readdir_r" class="anchor" title="Link to readdir_r">#</a>
               </h3>
               
               <p>go:linkname readdir_r syscall.readdir_r</p>
               
               <pre><code>func readdir_r(dir uintptr, entry *syscall.Dirent, result **syscall.Dirent) (res syscall.Errno)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readlink" data-name="readlink">
               <h3>
                  readlink 
                  <span class="badge">function</span>
                  
                  <a href="#readlink" class="anchor" title="Link to readlink">#</a>
               </h3>
               
               <pre><code>func readlink(name string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readlink" data-name="readlink">
               <h3>
                  readlink 
                  <span class="badge">function</span>
                  
                  <a href="#readlink" class="anchor" title="Link to readlink">#</a>
               </h3>
               
               <pre><code>func readlink(name string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readlink" data-name="readlink">
               <h3>
                  readlink 
                  <span class="badge">function</span>
                  
                  <a href="#readlink" class="anchor" title="Link to readlink">#</a>
               </h3>
               
               <pre><code>func readlink(name string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readlinkat" data-name="readlinkat">
               <h3>
                  readlinkat 
                  <span class="badge">function</span>
                  
                  <a href="#readlinkat" class="anchor" title="Link to readlinkat">#</a>
               </h3>
               
               <pre><code>func readlinkat(fd int, name string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="release" data-name="release">
               <h3>
                  release 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#release" class="anchor" title="Link to release">#</a>
               </h3>
               
               <pre><code>func (p *Process) release() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="release" data-name="release">
               <h3>
                  release 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#release" class="anchor" title="Link to release">#</a>
               </h3>
               
               <pre><code>func (p *Process) release() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="release" data-name="release">
               <h3>
                  release 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#release" class="anchor" title="Link to release">#</a>
               </h3>
               
               <pre><code>func (p *Process) release() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeAll" data-name="removeAll">
               <h3>
                  removeAll 
                  <span class="badge">function</span>
                  
                  <a href="#removeAll" class="anchor" title="Link to removeAll">#</a>
               </h3>
               
               <pre><code>func removeAll(path string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeAll" data-name="removeAll">
               <h3>
                  removeAll 
                  <span class="badge">function</span>
                  
                  <a href="#removeAll" class="anchor" title="Link to removeAll">#</a>
               </h3>
               
               <pre><code>func removeAll(path string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeAllFrom" data-name="removeAllFrom">
               <h3>
                  removeAllFrom 
                  <span class="badge">function</span>
                  
                  <a href="#removeAllFrom" class="anchor" title="Link to removeAllFrom">#</a>
               </h3>
               
               <pre><code>func removeAllFrom(parent *File, base string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeat" data-name="removeat">
               <h3>
                  removeat 
                  <span class="badge">function</span>
                  
                  <a href="#removeat" class="anchor" title="Link to removeat">#</a>
               </h3>
               
               <pre><code>func removeat(dirfd syscall.Handle, name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="removeat" data-name="removeat">
               <h3>
                  removeat 
                  <span class="badge">function</span>
                  
                  <a href="#removeat" class="anchor" title="Link to removeat">#</a>
               </h3>
               
               <pre><code>func removeat(fd int, name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rename" data-name="rename">
               <h3>
                  rename 
                  <span class="badge">function</span>
                  
                  <a href="#rename" class="anchor" title="Link to rename">#</a>
               </h3>
               
               <pre><code>func rename(oldname string, newname string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rename" data-name="rename">
               <h3>
                  rename 
                  <span class="badge">function</span>
                  
                  <a href="#rename" class="anchor" title="Link to rename">#</a>
               </h3>
               
               <pre><code>func rename(oldname string, newname string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rename" data-name="rename">
               <h3>
                  rename 
                  <span class="badge">function</span>
                  
                  <a href="#rename" class="anchor" title="Link to rename">#</a>
               </h3>
               
               <pre><code>func rename(oldname string, newname string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="restoreSIGSYS" data-name="restoreSIGSYS">
               <h3>
                  restoreSIGSYS 
                  <span class="badge">function</span>
                  
                  <a href="#restoreSIGSYS" class="anchor" title="Link to restoreSIGSYS">#</a>
               </h3>
               
               <p>go:linkname restoreSIGSYS</p>
               
               <pre><code>func restoreSIGSYS()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootCleanPath" data-name="rootCleanPath">
               <h3>
                  rootCleanPath 
                  <span class="badge">function</span>
                  
                  <a href="#rootCleanPath" class="anchor" title="Link to rootCleanPath">#</a>
               </h3>
               
               <pre><code>func rootCleanPath(s string, prefix []string, suffix []string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootCleanPath" data-name="rootCleanPath">
               <h3>
                  rootCleanPath 
                  <span class="badge">function</span>
                  
                  <a href="#rootCleanPath" class="anchor" title="Link to rootCleanPath">#</a>
               </h3>
               
               <p>rootCleanPath uses GetFullPathName to perform lexical path cleaning.
On Windows, file names are lexically cleaned at the start of a file operation.
For example, on Windows the path `a\..\b` is exactly equivalent to `b` alone,
even if `a` does not exist or is not a directory.
We use the Windows API function GetFullPathName to perform this cleaning.
We could do this ourselves, but there are a number of subtle behaviors here,
and deferring to the OS maintains consistency.
(For example, `a\.\` cleans to `a\`.)
GetFullPathName operates on absolute paths, and our input path is relative.
We make the path absolute by prepending a fixed prefix of \\?\?\.
We want to detect paths which use .. components to escape the root.
We do this by ensuring the cleaned path still begins with \\?\?\.
We catch the corner case of a path which includes a ..\?\. component
by rejecting any input paths which contain a ?, which is not a valid character
in a Windows filename.</p>
               
               <pre><code>func rootCleanPath(s string, prefix []string, suffix []string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootMkdir" data-name="rootMkdir">
               <h3>
                  rootMkdir 
                  <span class="badge">function</span>
                  
                  <a href="#rootMkdir" class="anchor" title="Link to rootMkdir">#</a>
               </h3>
               
               <pre><code>func rootMkdir(r *Root, name string, perm FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootMkdir" data-name="rootMkdir">
               <h3>
                  rootMkdir 
                  <span class="badge">function</span>
                  
                  <a href="#rootMkdir" class="anchor" title="Link to rootMkdir">#</a>
               </h3>
               
               <pre><code>func rootMkdir(r *Root, name string, perm FileMode) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootOpenDir" data-name="rootOpenDir">
               <h3>
                  rootOpenDir 
                  <span class="badge">function</span>
                  
                  <a href="#rootOpenDir" class="anchor" title="Link to rootOpenDir">#</a>
               </h3>
               
               <pre><code>func rootOpenDir(parent int, name string) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootOpenDir" data-name="rootOpenDir">
               <h3>
                  rootOpenDir 
                  <span class="badge">function</span>
                  
                  <a href="#rootOpenDir" class="anchor" title="Link to rootOpenDir">#</a>
               </h3>
               
               <pre><code>func rootOpenDir(parent syscall.Handle, name string) (syscall.Handle, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootOpenFileNolog" data-name="rootOpenFileNolog">
               <h3>
                  rootOpenFileNolog 
                  <span class="badge">function</span>
                  
                  <a href="#rootOpenFileNolog" class="anchor" title="Link to rootOpenFileNolog">#</a>
               </h3>
               
               <p>rootOpenFileNolog is Root.OpenFile.</p>
               
               <pre><code>func rootOpenFileNolog(root *Root, name string, flag int, perm FileMode) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootOpenFileNolog" data-name="rootOpenFileNolog">
               <h3>
                  rootOpenFileNolog 
                  <span class="badge">function</span>
                  
                  <a href="#rootOpenFileNolog" class="anchor" title="Link to rootOpenFileNolog">#</a>
               </h3>
               
               <p>rootOpenFileNolog is Root.OpenFile.</p>
               
               <pre><code>func rootOpenFileNolog(r *Root, name string, flag int, perm FileMode) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootOpenFileNolog" data-name="rootOpenFileNolog">
               <h3>
                  rootOpenFileNolog 
                  <span class="badge">function</span>
                  
                  <a href="#rootOpenFileNolog" class="anchor" title="Link to rootOpenFileNolog">#</a>
               </h3>
               
               <p>rootOpenFileNolog is Root.OpenFile.</p>
               
               <pre><code>func rootOpenFileNolog(root *Root, name string, flag int, perm FileMode) (*File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootRemove" data-name="rootRemove">
               <h3>
                  rootRemove 
                  <span class="badge">function</span>
                  
                  <a href="#rootRemove" class="anchor" title="Link to rootRemove">#</a>
               </h3>
               
               <pre><code>func rootRemove(r *Root, name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootRemove" data-name="rootRemove">
               <h3>
                  rootRemove 
                  <span class="badge">function</span>
                  
                  <a href="#rootRemove" class="anchor" title="Link to rootRemove">#</a>
               </h3>
               
               <pre><code>func rootRemove(r *Root, name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootStat" data-name="rootStat">
               <h3>
                  rootStat 
                  <span class="badge">function</span>
                  
                  <a href="#rootStat" class="anchor" title="Link to rootStat">#</a>
               </h3>
               
               <pre><code>func rootStat(r *Root, name string, lstat bool) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootStat" data-name="rootStat">
               <h3>
                  rootStat 
                  <span class="badge">function</span>
                  
                  <a href="#rootStat" class="anchor" title="Link to rootStat">#</a>
               </h3>
               
               <pre><code>func rootStat(r *Root, name string, lstat bool) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rootStat" data-name="rootStat">
               <h3>
                  rootStat 
                  <span class="badge">function</span>
                  
                  <a href="#rootStat" class="anchor" title="Link to rootStat">#</a>
               </h3>
               
               <pre><code>func rootStat(r *Root, name string, lstat bool) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_args" data-name="runtime_args">
               <h3>
                  runtime_args 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_args" class="anchor" title="Link to runtime_args">#</a>
               </h3>
               
               <pre><code>func runtime_args() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_beforeExit" data-name="runtime_beforeExit">
               <h3>
                  runtime_beforeExit 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_beforeExit" class="anchor" title="Link to runtime_beforeExit">#</a>
               </h3>
               
               <pre><code>func runtime_beforeExit(exitCode int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runtime_rand" data-name="runtime_rand">
               <h3>
                  runtime_rand 
                  <span class="badge">function</span>
                  
                  <a href="#runtime_rand" class="anchor" title="Link to runtime_rand">#</a>
               </h3>
               
               <p>random number source provided by runtime.
We generate random temporary file names so that there's a good
chance the file doesn't exist yet - keeps the number of tries in
TempFile to a minimum.
go:linkname runtime_rand runtime.rand</p>
               
               <pre><code>func runtime_rand() uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sameFile" data-name="sameFile">
               <h3>
                  sameFile 
                  <span class="badge">function</span>
                  
                  <a href="#sameFile" class="anchor" title="Link to sameFile">#</a>
               </h3>
               
               <pre><code>func sameFile(fs1 *fileStat, fs2 *fileStat) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sameFile" data-name="sameFile">
               <h3>
                  sameFile 
                  <span class="badge">function</span>
                  
                  <a href="#sameFile" class="anchor" title="Link to sameFile">#</a>
               </h3>
               
               <pre><code>func sameFile(fs1 *fileStat, fs2 *fileStat) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sameFile" data-name="sameFile">
               <h3>
                  sameFile 
                  <span class="badge">function</span>
                  
                  <a href="#sameFile" class="anchor" title="Link to sameFile">#</a>
               </h3>
               
               <pre><code>func sameFile(fs1 *fileStat, fs2 *fileStat) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="saveInfoFromPath" data-name="saveInfoFromPath">
               <h3>
                  saveInfoFromPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#saveInfoFromPath" class="anchor" title="Link to saveInfoFromPath">#</a>
               </h3>
               
               <p>saveInfoFromPath saves full path of the file to be used by os.SameFile later,
and set name from path.</p>
               
               <pre><code>func (fs *fileStat) saveInfoFromPath(path string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="seek" data-name="seek">
               <h3>
                  seek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#seek" class="anchor" title="Link to seek">#</a>
               </h3>
               
               <p>seek sets the offset for the next Read or Write on file to offset, interpreted
according to whence: 0 means relative to the origin of the file, 1 means
relative to the current offset, and 2 means relative to the end.
It returns the new offset and an error, if any.</p>
               
               <pre><code>func (f *File) seek(offset int64, whence int) (ret int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="seek" data-name="seek">
               <h3>
                  seek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#seek" class="anchor" title="Link to seek">#</a>
               </h3>
               
               <p>seek sets the offset for the next Read or Write on file to offset, interpreted
according to whence: 0 means relative to the origin of the file, 1 means
relative to the current offset, and 2 means relative to the end.
It returns the new offset and an error, if any.</p>
               
               <pre><code>func (f *File) seek(offset int64, whence int) (ret int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="seek" data-name="seek">
               <h3>
                  seek 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#seek" class="anchor" title="Link to seek">#</a>
               </h3>
               
               <p>seek sets the offset for the next Read or Write on file to offset, interpreted
according to whence: 0 means relative to the origin of the file, 1 means
relative to the current offset, and 2 means relative to the end.
It returns the new offset and an error, if any.</p>
               
               <pre><code>func (f *File) seek(offset int64, whence int) (ret int64, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setDeadline" data-name="setDeadline">
               <h3>
                  setDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setDeadline" class="anchor" title="Link to setDeadline">#</a>
               </h3>
               
               <p>setDeadline sets the read and write deadline.</p>
               
               <pre><code>func (f *File) setDeadline(time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setDeadline" data-name="setDeadline">
               <h3>
                  setDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setDeadline" class="anchor" title="Link to setDeadline">#</a>
               </h3>
               
               <p>setDeadline sets the read and write deadline.</p>
               
               <pre><code>func (f *File) setDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setReadDeadline" data-name="setReadDeadline">
               <h3>
                  setReadDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setReadDeadline" class="anchor" title="Link to setReadDeadline">#</a>
               </h3>
               
               <p>setReadDeadline sets the read deadline.</p>
               
               <pre><code>func (f *File) setReadDeadline(time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setReadDeadline" data-name="setReadDeadline">
               <h3>
                  setReadDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setReadDeadline" class="anchor" title="Link to setReadDeadline">#</a>
               </h3>
               
               <p>setReadDeadline sets the read deadline.</p>
               
               <pre><code>func (f *File) setReadDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setStickyBit" data-name="setStickyBit">
               <h3>
                  setStickyBit 
                  <span class="badge">function</span>
                  
                  <a href="#setStickyBit" class="anchor" title="Link to setStickyBit">#</a>
               </h3>
               
               <p>setStickyBit adds ModeSticky to the permission bits of path, non atomic.</p>
               
               <pre><code>func setStickyBit(name string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setWriteDeadline" data-name="setWriteDeadline">
               <h3>
                  setWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setWriteDeadline" class="anchor" title="Link to setWriteDeadline">#</a>
               </h3>
               
               <p>setWriteDeadline sets the write deadline.</p>
               
               <pre><code>func (f *File) setWriteDeadline(t time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setWriteDeadline" data-name="setWriteDeadline">
               <h3>
                  setWriteDeadline 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setWriteDeadline" class="anchor" title="Link to setWriteDeadline">#</a>
               </h3>
               
               <p>setWriteDeadline sets the write deadline.</p>
               
               <pre><code>func (f *File) setWriteDeadline(time.Time) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="signal" data-name="signal">
               <h3>
                  signal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#signal" class="anchor" title="Link to signal">#</a>
               </h3>
               
               <pre><code>func (p *Process) signal(sig Signal) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="signal" data-name="signal">
               <h3>
                  signal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#signal" class="anchor" title="Link to signal">#</a>
               </h3>
               
               <pre><code>func (p *Process) signal(sig Signal) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="signal" data-name="signal">
               <h3>
                  signal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#signal" class="anchor" title="Link to signal">#</a>
               </h3>
               
               <pre><code>func (p *Process) signal(sig Signal) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sigpipe" data-name="sigpipe">
               <h3>
                  sigpipe 
                  <span class="badge">function</span>
                  
                  <a href="#sigpipe" class="anchor" title="Link to sigpipe">#</a>
               </h3>
               
               <pre><code>func sigpipe()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="spliceToFile" data-name="spliceToFile">
               <h3>
                  spliceToFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#spliceToFile" class="anchor" title="Link to spliceToFile">#</a>
               </h3>
               
               <pre><code>func (f *File) spliceToFile(r io.Reader) (written int64, handled bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitPath" data-name="splitPath">
               <h3>
                  splitPath 
                  <span class="badge">function</span>
                  
                  <a href="#splitPath" class="anchor" title="Link to splitPath">#</a>
               </h3>
               
               <p>splitPath returns the base name and parent directory.</p>
               
               <pre><code>func splitPath(path string) (string, string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitPathInRoot" data-name="splitPathInRoot">
               <h3>
                  splitPathInRoot 
                  <span class="badge">function</span>
                  
                  <a href="#splitPathInRoot" class="anchor" title="Link to splitPathInRoot">#</a>
               </h3>
               
               <p>splitPathInRoot splits a path into components
and joins it with the given prefix and suffix.
The path is relative to a Root, and must not be
absolute, volume-relative, or "".
"." components are removed, except in the last component.
Path separators following the last component are returned in suffixSep.</p>
               
               <pre><code>func splitPathInRoot(s string, prefix []string, suffix []string) (_ []string, suffixSep string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitPathList" data-name="splitPathList">
               <h3>
                  splitPathList 
                  <span class="badge">function</span>
                  
                  <a href="#splitPathList" class="anchor" title="Link to splitPathList">#</a>
               </h3>
               
               <p>splitPathList splits a path list.
This is based on genSplit from strings/strings.go</p>
               
               <pre><code>func splitPathList(pathList string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stTimespecToTime" data-name="stTimespecToTime">
               <h3>
                  stTimespecToTime 
                  <span class="badge">function</span>
                  
                  <a href="#stTimespecToTime" class="anchor" title="Link to stTimespecToTime">#</a>
               </h3>
               
               <pre><code>func stTimespecToTime(ts syscall.StTimespec_t) time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startProcess" data-name="startProcess">
               <h3>
                  startProcess 
                  <span class="badge">function</span>
                  
                  <a href="#startProcess" class="anchor" title="Link to startProcess">#</a>
               </h3>
               
               <pre><code>func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startProcess" data-name="startProcess">
               <h3>
                  startProcess 
                  <span class="badge">function</span>
                  
                  <a href="#startProcess" class="anchor" title="Link to startProcess">#</a>
               </h3>
               
               <pre><code>func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stat" data-name="stat">
               <h3>
                  stat 
                  <span class="badge">function</span>
                  
                  <a href="#stat" class="anchor" title="Link to stat">#</a>
               </h3>
               
               <p>stat implements both Stat and Lstat of a file.</p>
               
               <pre><code>func stat(funcname string, name string, followSurrogates bool) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="statHandle" data-name="statHandle">
               <h3>
                  statHandle 
                  <span class="badge">function</span>
                  
                  <a href="#statHandle" class="anchor" title="Link to statHandle">#</a>
               </h3>
               
               <pre><code>func statHandle(name string, h syscall.Handle) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="statNolog" data-name="statNolog">
               <h3>
                  statNolog 
                  <span class="badge">function</span>
                  
                  <a href="#statNolog" class="anchor" title="Link to statNolog">#</a>
               </h3>
               
               <p>statNolog stats a file with no test logging.</p>
               
               <pre><code>func statNolog(name string) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="statNolog" data-name="statNolog">
               <h3>
                  statNolog 
                  <span class="badge">function</span>
                  
                  <a href="#statNolog" class="anchor" title="Link to statNolog">#</a>
               </h3>
               
               <p>statNolog implements Stat for Plan 9.</p>
               
               <pre><code>func statNolog(name string) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="statNolog" data-name="statNolog">
               <h3>
                  statNolog 
                  <span class="badge">function</span>
                  
                  <a href="#statNolog" class="anchor" title="Link to statNolog">#</a>
               </h3>
               
               <p>statNolog implements Stat for Windows.</p>
               
               <pre><code>func statNolog(name string) (FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="success" data-name="success">
               <h3>
                  success 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#success" class="anchor" title="Link to success">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) success() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="success" data-name="success">
               <h3>
                  success 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#success" class="anchor" title="Link to success">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) success() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sys" data-name="sys">
               <h3>
                  sys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sys" class="anchor" title="Link to sys">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) sys() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sys" data-name="sys">
               <h3>
                  sys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sys" class="anchor" title="Link to sys">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) sys() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sysUsage" data-name="sysUsage">
               <h3>
                  sysUsage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sysUsage" class="anchor" title="Link to sysUsage">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) sysUsage() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sysUsage" data-name="sysUsage">
               <h3>
                  sysUsage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#sysUsage" class="anchor" title="Link to sysUsage">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) sysUsage() any</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syscallMode" data-name="syscallMode">
               <h3>
                  syscallMode 
                  <span class="badge">function</span>
                  
                  <a href="#syscallMode" class="anchor" title="Link to syscallMode">#</a>
               </h3>
               
               <p>syscallMode returns the syscall-specific mode bits from Go's portable mode bits.</p>
               
               <pre><code>func syscallMode(i FileMode) (o uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syscallMode" data-name="syscallMode">
               <h3>
                  syscallMode 
                  <span class="badge">function</span>
                  
                  <a href="#syscallMode" class="anchor" title="Link to syscallMode">#</a>
               </h3>
               
               <p>syscallMode returns the syscall-specific mode bits from Go's portable mode bits.</p>
               
               <pre><code>func syscallMode(i FileMode) (o uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="systemTime" data-name="systemTime">
               <h3>
                  systemTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#systemTime" class="anchor" title="Link to systemTime">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) systemTime() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="systemTime" data-name="systemTime">
               <h3>
                  systemTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#systemTime" class="anchor" title="Link to systemTime">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) systemTime() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="systemTime" data-name="systemTime">
               <h3>
                  systemTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#systemTime" class="anchor" title="Link to systemTime">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) systemTime() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tempDir" data-name="tempDir">
               <h3>
                  tempDir 
                  <span class="badge">function</span>
                  
                  <a href="#tempDir" class="anchor" title="Link to tempDir">#</a>
               </h3>
               
               <pre><code>func tempDir() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tempDir" data-name="tempDir">
               <h3>
                  tempDir 
                  <span class="badge">function</span>
                  
                  <a href="#tempDir" class="anchor" title="Link to tempDir">#</a>
               </h3>
               
               <pre><code>func tempDir() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tempDir" data-name="tempDir">
               <h3>
                  tempDir 
                  <span class="badge">function</span>
                  
                  <a href="#tempDir" class="anchor" title="Link to tempDir">#</a>
               </h3>
               
               <pre><code>func tempDir() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryLimitedReader" data-name="tryLimitedReader">
               <h3>
                  tryLimitedReader 
                  <span class="badge">function</span>
                  
                  <a href="#tryLimitedReader" class="anchor" title="Link to tryLimitedReader">#</a>
               </h3>
               
               <p>tryLimitedReader tries to assert the io.Reader to io.LimitedReader, it returns the io.LimitedReader,
the underlying io.Reader and the remaining amount of bytes if the assertion succeeds,
otherwise it just returns the original io.Reader and the theoretical unlimited remaining amount of bytes.</p>
               
               <pre><code>func tryLimitedReader(r io.Reader) (*io.LimitedReader, io.Reader, int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="underlyingError" data-name="underlyingError">
               <h3>
                  underlyingError 
                  <span class="badge">function</span>
                  
                  <a href="#underlyingError" class="anchor" title="Link to underlyingError">#</a>
               </h3>
               
               <p>underlyingError returns the underlying error for known os error types.</p>
               
               <pre><code>func underlyingError(err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="underlyingErrorIs" data-name="underlyingErrorIs">
               <h3>
                  underlyingErrorIs 
                  <span class="badge">function</span>
                  
                  <a href="#underlyingErrorIs" class="anchor" title="Link to underlyingErrorIs">#</a>
               </h3>
               
               <pre><code>func underlyingErrorIs(err error, target error) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="userTime" data-name="userTime">
               <h3>
                  userTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#userTime" class="anchor" title="Link to userTime">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) userTime() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="userTime" data-name="userTime">
               <h3>
                  userTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#userTime" class="anchor" title="Link to userTime">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) userTime() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="userTime" data-name="userTime">
               <h3>
                  userTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#userTime" class="anchor" title="Link to userTime">#</a>
               </h3>
               
               <pre><code>func (p *ProcessState) userTime() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wait" data-name="wait">
               <h3>
                  wait 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#wait" class="anchor" title="Link to wait">#</a>
               </h3>
               
               <pre><code>func (p *Process) wait() (ps *ProcessState, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wait" data-name="wait">
               <h3>
                  wait 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#wait" class="anchor" title="Link to wait">#</a>
               </h3>
               
               <pre><code>func (p *Process) wait() (ps *ProcessState, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wait" data-name="wait">
               <h3>
                  wait 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#wait" class="anchor" title="Link to wait">#</a>
               </h3>
               
               <pre><code>func (p *Process) wait() (ps *ProcessState, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wait6" data-name="wait6">
               <h3>
                  wait6 
                  <span class="badge">function</span>
                  
                  <a href="#wait6" class="anchor" title="Link to wait6">#</a>
               </h3>
               
               <pre><code>func wait6(idtype int, id int, options int) (status int, errno syscall.Errno)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wait6" data-name="wait6">
               <h3>
                  wait6 
                  <span class="badge">function</span>
                  
                  <a href="#wait6" class="anchor" title="Link to wait6">#</a>
               </h3>
               
               <pre><code>func wait6(idtype int, id int, options int) (status int, errno syscall.Errno)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wait6" data-name="wait6">
               <h3>
                  wait6 
                  <span class="badge">function</span>
                  
                  <a href="#wait6" class="anchor" title="Link to wait6">#</a>
               </h3>
               
               <pre><code>func wait6(idtype int, id int, options int) (status int, errno syscall.Errno)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wait6" data-name="wait6">
               <h3>
                  wait6 
                  <span class="badge">function</span>
                  
                  <a href="#wait6" class="anchor" title="Link to wait6">#</a>
               </h3>
               
               <pre><code>func wait6(idtype int, id int, options int) (status int, errno syscall.Errno)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wait6" data-name="wait6">
               <h3>
                  wait6 
                  <span class="badge">function</span>
                  
                  <a href="#wait6" class="anchor" title="Link to wait6">#</a>
               </h3>
               
               <pre><code>func wait6(idtype int, id int, options int) (status int, errno syscall.Errno)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wrapErr" data-name="wrapErr">
               <h3>
                  wrapErr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#wrapErr" class="anchor" title="Link to wrapErr">#</a>
               </h3>
               
               <p>wrapErr wraps an error that occurred during an operation on an open file.
It passes io.EOF through unchanged, otherwise converts
poll.ErrFileClosing to ErrClosed and wraps the error in a PathError.</p>
               
               <pre><code>func (f *File) wrapErr(op string, err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="wrapSyscallError" data-name="wrapSyscallError">
               <h3>
                  wrapSyscallError 
                  <span class="badge">function</span>
                  
                  <a href="#wrapSyscallError" class="anchor" title="Link to wrapSyscallError">#</a>
               </h3>
               
               <p>wrapSyscallError takes an error and a syscall name. If the error is
a syscall.Errno, it wraps it in an os.SyscallError using the syscall name.</p>
               
               <pre><code>func wrapSyscallError(name string, err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="write" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#write" class="anchor" title="Link to write">#</a>
               </h3>
               
               <p>write writes len(b) bytes to the File.
It returns the number of bytes written and an error, if any.</p>
               
               <pre><code>func (f *File) write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="write" data-name="write">
               <h3>
                  write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#write" class="anchor" title="Link to write">#</a>
               </h3>
               
               <p>write writes len(b) bytes to the File.
It returns the number of bytes written and an error, if any.
Since Plan 9 preserves message boundaries, never allow
a zero-byte write.</p>
               
               <pre><code>func (f *File) write(b []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeLock" data-name="writeLock">
               <h3>
                  writeLock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeLock" class="anchor" title="Link to writeLock">#</a>
               </h3>
               
               <p>writeLock adds a reference to the file and locks it for writing.
It returns an error if the file is already closed.</p>
               
               <pre><code>func (file *file) writeLock() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeProcFile" data-name="writeProcFile">
               <h3>
                  writeProcFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeProcFile" class="anchor" title="Link to writeProcFile">#</a>
               </h3>
               
               <pre><code>func (p *Process) writeProcFile(file string, data string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeTo" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeTo" class="anchor" title="Link to writeTo">#</a>
               </h3>
               
               <pre><code>func (f *File) writeTo(w io.Writer) (written int64, handled bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeTo" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeTo" class="anchor" title="Link to writeTo">#</a>
               </h3>
               
               <pre><code>func (f *File) writeTo(w io.Writer) (written int64, handled bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeTo" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeTo" class="anchor" title="Link to writeTo">#</a>
               </h3>
               
               <pre><code>func (f *File) writeTo(w io.Writer) (written int64, handled bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeTo" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeTo" class="anchor" title="Link to writeTo">#</a>
               </h3>
               
               <pre><code>func (f *File) writeTo(w io.Writer) (written int64, handled bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeUnlock" data-name="writeUnlock">
               <h3>
                  writeUnlock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeUnlock" class="anchor" title="Link to writeUnlock">#</a>
               </h3>
               
               <p>writeUnlock removes a reference from the file and unlocks it for writing.
It also closes the file if it is marked as closed and there is no remaining
reference.</p>
               
               <pre><code>func (file *file) writeUnlock()</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>