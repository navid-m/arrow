<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - os</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="os_exec-docs.html">exec</a>
         <br />
         
         <a href="os_signal-docs.html">signal</a>
         <br />
         
         <a href="os_user-docs.html">user</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>os</code>
         </h1>
         <hr />
         
         <article class="global" data-name="supportsCreateWithStickyBit">
            <h2>supportsCreateWithStickyBit</h2>
            <hr />
            
            <p>According to sticky(8), neither open(2) nor mkdir(2) will create
a file with the sticky bit set.</p>
            
            <pre><code>supportsCreateWithStickyBit</code></pre>
         </article>
         
         <article class="global" data-name="_P_PID">
            <h2>_P_PID</h2>
            <hr />
            
            <pre><code>_P_PID</code></pre>
         </article>
         
         <article class="global" data-name="PollCopyFileRangeP">
            <h2>PollCopyFileRangeP</h2>
            <hr />
            
            <pre><code>PollCopyFileRangeP</code></pre>
         </article>
         
         <article class="global" data-name="PathSeparator">
            <h2>PathSeparator</h2>
            <hr />
            
            <pre><code>PathSeparator</code></pre>
         </article>
         
         <article class="global" data-name="PathListSeparator">
            <h2>PathListSeparator</h2>
            <hr />
            
            <pre><code>PathListSeparator</code></pre>
         </article>
         
         <article class="global" data-name="_CTL_KERN">
            <h2>_CTL_KERN</h2>
            <hr />
            
            <p>From FreeBSD's <sys/sysctl.h></p>
            
            <pre><code>_CTL_KERN</code></pre>
         </article>
         
         <article class="global" data-name="_KERN_PROC">
            <h2>_KERN_PROC</h2>
            <hr />
            
            <p>From FreeBSD's <sys/sysctl.h></p>
            
            <pre><code>_KERN_PROC</code></pre>
         </article>
         
         <article class="global" data-name="_KERN_PROC_PATHNAME">
            <h2>_KERN_PROC_PATHNAME</h2>
            <hr />
            
            <p>From FreeBSD's <sys/sysctl.h></p>
            
            <pre><code>_KERN_PROC_PATHNAME</code></pre>
         </article>
         
         <article class="global" data-name="executableMIB">
            <h2>executableMIB</h2>
            <hr />
            
            <pre><code>executableMIB</code></pre>
         </article>
         
         <article class="global" data-name="AddExtendedPrefix">
            <h2>AddExtendedPrefix</h2>
            <hr />
            
            <pre><code>AddExtendedPrefix</code></pre>
         </article>
         
         <article class="global" data-name="NewConsoleFile">
            <h2>NewConsoleFile</h2>
            <hr />
            
            <pre><code>NewConsoleFile</code></pre>
         </article>
         
         <article class="global" data-name="CommandLineToArgv">
            <h2>CommandLineToArgv</h2>
            <hr />
            
            <pre><code>CommandLineToArgv</code></pre>
         </article>
         
         <article class="global" data-name="AllowReadDirFileID">
            <h2>AllowReadDirFileID</h2>
            <hr />
            
            <pre><code>AllowReadDirFileID</code></pre>
         </article>
         
         <article class="global" data-name="winsymlink">
            <h2>winsymlink</h2>
            <hr />
            
            <pre><code>winsymlink</code></pre>
         </article>
         
         <article class="global" data-name="Interrupt">
            <h2>Interrupt</h2>
            <hr />
            
            <p>The only signal values guaranteed to be present in the os package on all
systems are os.Interrupt (send the process an interrupt) and os.Kill (force
the process to exit). On Windows, sending os.Interrupt to a process with
os.Process.Signal is not implemented; it will return an error instead of
sending a signal.</p>
            
            <pre><code>Interrupt Signal</code></pre>
         </article>
         
         <article class="global" data-name="Kill">
            <h2>Kill</h2>
            <hr />
            
            <p>The only signal values guaranteed to be present in the os package on all
systems are os.Interrupt (send the process an interrupt) and os.Kill (force
the process to exit). On Windows, sending os.Interrupt to a process with
os.Process.Signal is not implemented; it will return an error instead of
sending a signal.</p>
            
            <pre><code>Kill Signal</code></pre>
         </article>
         
         <article class="global" data-name="executablePath">
            <h2>executablePath</h2>
            <hr />
            
            <pre><code>executablePath string</code></pre>
         </article>
         
         <article class="global" data-name="initCwd">
            <h2>initCwd</h2>
            <hr />
            
            <pre><code>initCwd</code></pre>
         </article>
         
         <article class="global" data-name="initCwdErr">
            <h2>initCwdErr</h2>
            <hr />
            
            <pre><code>initCwdErr</code></pre>
         </article>
         
         <article class="global" data-name="errENOSYS">
            <h2>errENOSYS</h2>
            <hr />
            
            <pre><code>errENOSYS</code></pre>
         </article>
         
         <article class="global" data-name="errERANGE">
            <h2>errERANGE</h2>
            <hr />
            
            <pre><code>errERANGE</code></pre>
         </article>
         
         <article class="global" data-name="errENOMEM">
            <h2>errENOMEM</h2>
            <hr />
            
            <pre><code>errENOMEM</code></pre>
         </article>
         
         <article class="global" data-name="PathSeparator">
            <h2>PathSeparator</h2>
            <hr />
            
            <pre><code>PathSeparator</code></pre>
         </article>
         
         <article class="global" data-name="PathListSeparator">
            <h2>PathListSeparator</h2>
            <hr />
            
            <pre><code>PathListSeparator</code></pre>
         </article>
         
         <article class="global" data-name="_S_IFNAM">
            <h2>_S_IFNAM</h2>
            <hr />
            
            <p>These constants aren't in the syscall package, which is frozen.
Values taken from golang.org/x/sys/unix.</p>
            
            <pre><code>_S_IFNAM</code></pre>
         </article>
         
         <article class="global" data-name="_S_IFDOOR">
            <h2>_S_IFDOOR</h2>
            <hr />
            
            <p>These constants aren't in the syscall package, which is frozen.
Values taken from golang.org/x/sys/unix.</p>
            
            <pre><code>_S_IFDOOR</code></pre>
         </article>
         
         <article class="global" data-name="_S_IFPORT">
            <h2>_S_IFPORT</h2>
            <hr />
            
            <p>These constants aren't in the syscall package, which is frozen.
Values taken from golang.org/x/sys/unix.</p>
            
            <pre><code>_S_IFPORT</code></pre>
         </article>
         
         <article class="global" data-name="pollCopyFileRange">
            <h2>pollCopyFileRange</h2>
            <hr />
            
            <pre><code>pollCopyFileRange</code></pre>
         </article>
         
         <article class="global" data-name="pollSplice">
            <h2>pollSplice</h2>
            <hr />
            
            <pre><code>pollSplice</code></pre>
         </article>
         
         <article class="global" data-name="errPatternHasSeparator">
            <h2>errPatternHasSeparator</h2>
            <hr />
            
            <pre><code>errPatternHasSeparator</code></pre>
         </article>
         
         <article class="global" data-name="pollCopyFileRange">
            <h2>pollCopyFileRange</h2>
            <hr />
            
            <pre><code>pollCopyFileRange</code></pre>
         </article>
         
         <article class="global" data-name="_P_PID">
            <h2>_P_PID</h2>
            <hr />
            
            <pre><code>_P_PID</code></pre>
         </article>
         
         <article class="global" data-name="_CTL_KERN">
            <h2>_CTL_KERN</h2>
            <hr />
            
            <p>From NetBSD's <sys/sysctl.h></p>
            
            <pre><code>_CTL_KERN</code></pre>
         </article>
         
         <article class="global" data-name="_KERN_PROC_ARGS">
            <h2>_KERN_PROC_ARGS</h2>
            <hr />
            
            <p>From NetBSD's <sys/sysctl.h></p>
            
            <pre><code>_KERN_PROC_ARGS</code></pre>
         </article>
         
         <article class="global" data-name="_KERN_PROC_PATHNAME">
            <h2>_KERN_PROC_PATHNAME</h2>
            <hr />
            
            <p>From NetBSD's <sys/sysctl.h></p>
            
            <pre><code>_KERN_PROC_PATHNAME</code></pre>
         </article>
         
         <article class="global" data-name="executableMIB">
            <h2>executableMIB</h2>
            <hr />
            
            <pre><code>executableMIB</code></pre>
         </article>
         
         <article class="global" data-name="_CTL_KERN">
            <h2>_CTL_KERN</h2>
            <hr />
            
            <p>From DragonFly's <sys/sysctl.h></p>
            
            <pre><code>_CTL_KERN</code></pre>
         </article>
         
         <article class="global" data-name="_KERN_PROC">
            <h2>_KERN_PROC</h2>
            <hr />
            
            <p>From DragonFly's <sys/sysctl.h></p>
            
            <pre><code>_KERN_PROC</code></pre>
         </article>
         
         <article class="global" data-name="_KERN_PROC_PATHNAME">
            <h2>_KERN_PROC_PATHNAME</h2>
            <hr />
            
            <p>From DragonFly's <sys/sysctl.h></p>
            
            <pre><code>_KERN_PROC_PATHNAME</code></pre>
         </article>
         
         <article class="global" data-name="executableMIB">
            <h2>executableMIB</h2>
            <hr />
            
            <pre><code>executableMIB</code></pre>
         </article>
         
         <article class="global" data-name="supportsCloseOnExec">
            <h2>supportsCloseOnExec</h2>
            <hr />
            
            <p>supportsCloseOnExec reports whether the platform supports the
O_CLOEXEC flag.
On Darwin, the O_CLOEXEC flag was introduced in OS X 10.7 (Darwin 11.0.0).
See https://support.apple.com/kb/HT1633.
On FreeBSD, the O_CLOEXEC flag was introduced in version 8.3.</p>
            
            <pre><code>supportsCloseOnExec</code></pre>
         </article>
         
         <article class="global" data-name="PollCopyFileRangeP">
            <h2>PollCopyFileRangeP</h2>
            <hr />
            
            <pre><code>PollCopyFileRangeP</code></pre>
         </article>
         
         <article class="global" data-name="PollSpliceFile">
            <h2>PollSpliceFile</h2>
            <hr />
            
            <pre><code>PollSpliceFile</code></pre>
         </article>
         
         <article class="global" data-name="GetPollFDAndNetwork">
            <h2>GetPollFDAndNetwork</h2>
            <hr />
            
            <pre><code>GetPollFDAndNetwork</code></pre>
         </article>
         
         <article class="global" data-name="CheckPidfdOnce">
            <h2>CheckPidfdOnce</h2>
            <hr />
            
            <pre><code>CheckPidfdOnce</code></pre>
         </article>
         
         <article class="global" data-name="StatusDone">
            <h2>StatusDone</h2>
            <hr />
            
            <pre><code>StatusDone</code></pre>
         </article>
         
         <article class="global" data-name="_UTIME_OMIT">
            <h2>_UTIME_OMIT</h2>
            <hr />
            
            <pre><code>_UTIME_OMIT</code></pre>
         </article>
         
         <article class="global" data-name="kindNewFile">
            <h2>kindNewFile</h2>
            <hr />
            
            <p>kindNewFile means that the descriptor was passed to us via NewFile.</p>
            
            <pre><code>kindNewFile newFileKind</code></pre>
         </article>
         
         <article class="global" data-name="kindOpenFile">
            <h2>kindOpenFile</h2>
            <hr />
            
            <p>kindOpenFile means that the descriptor was opened using
Open, Create, or OpenFile.</p>
            
            <pre><code>kindOpenFile</code></pre>
         </article>
         
         <article class="global" data-name="kindPipe">
            <h2>kindPipe</h2>
            <hr />
            
            <p>kindPipe means that the descriptor was opened using Pipe.</p>
            
            <pre><code>kindPipe</code></pre>
         </article>
         
         <article class="global" data-name="kindSock">
            <h2>kindSock</h2>
            <hr />
            
            <p>kindSock means that the descriptor is a network file descriptor
that was created from net package and was opened using net_newUnixFile.</p>
            
            <pre><code>kindSock</code></pre>
         </article>
         
         <article class="global" data-name="kindNoPoll">
            <h2>kindNoPoll</h2>
            <hr />
            
            <p>kindNoPoll means that we should not put the descriptor into
non-blocking mode, because we know it is not a pipe or FIFO.
Used by openDirAt and openDirNolog for directories.</p>
            
            <pre><code>kindNoPoll</code></pre>
         </article>
         
         <article class="global" data-name="DevNull">
            <h2>DevNull</h2>
            <hr />
            
            <p>DevNull is the name of the operating system's “null device.”
On Unix-like systems, it is "/dev/null"; on Windows, "NUL".</p>
            
            <pre><code>DevNull</code></pre>
         </article>
         
         <article class="global" data-name="DevNull">
            <h2>DevNull</h2>
            <hr />
            
            <p>DevNull is the name of the operating system's “null device.”
On Unix-like systems, it is "/dev/null"; on Windows, "NUL".</p>
            
            <pre><code>DevNull</code></pre>
         </article>
         
         <article class="global" data-name="chmodMask">
            <h2>chmodMask</h2>
            <hr />
            
            <pre><code>chmodMask</code></pre>
         </article>
         
         <article class="global" data-name="getwdCache">
            <h2>getwdCache</h2>
            <hr />
            
            <pre><code>getwdCache *ast.StructType</code></pre>
         </article>
         
         <article class="global" data-name="errENOSYS">
            <h2>errENOSYS</h2>
            <hr />
            
            <pre><code>errENOSYS</code></pre>
         </article>
         
         <article class="global" data-name="errERANGE">
            <h2>errERANGE</h2>
            <hr />
            
            <pre><code>errERANGE</code></pre>
         </article>
         
         <article class="global" data-name="errENOMEM">
            <h2>errENOMEM</h2>
            <hr />
            
            <pre><code>errENOMEM</code></pre>
         </article>
         
         <article class="global" data-name="Interrupt">
            <h2>Interrupt</h2>
            <hr />
            
            <p>The only signal values guaranteed to be present in the os package
on all systems are Interrupt (send the process an interrupt) and
Kill (force the process to exit). Interrupt is not implemented on
Windows; using it with [os.Process.Signal] will return an error.</p>
            
            <pre><code>Interrupt Signal</code></pre>
         </article>
         
         <article class="global" data-name="Kill">
            <h2>Kill</h2>
            <hr />
            
            <p>The only signal values guaranteed to be present in the os package
on all systems are Interrupt (send the process an interrupt) and
Kill (force the process to exit). Interrupt is not implemented on
Windows; using it with [os.Process.Signal] will return an error.</p>
            
            <pre><code>Kill Signal</code></pre>
         </article>
         
         <article class="global" data-name="Args">
            <h2>Args</h2>
            <hr />
            
            <p>Args hold the command-line arguments, starting with the program name.</p>
            
            <pre><code>Args []string</code></pre>
         </article>
         
         <article class="global" data-name="supportsCreateWithStickyBit">
            <h2>supportsCreateWithStickyBit</h2>
            <hr />
            
            <pre><code>supportsCreateWithStickyBit</code></pre>
         </article>
         
         <article class="global" data-name="readdirName">
            <h2>readdirName</h2>
            <hr />
            
            <pre><code>readdirName readdirMode</code></pre>
         </article>
         
         <article class="global" data-name="readdirDirEntry">
            <h2>readdirDirEntry</h2>
            <hr />
            
            <pre><code>readdirDirEntry</code></pre>
         </article>
         
         <article class="global" data-name="readdirFileInfo">
            <h2>readdirFileInfo</h2>
            <hr />
            
            <pre><code>readdirFileInfo</code></pre>
         </article>
         
         <article class="global" data-name="testingForceReadDirLstat">
            <h2>testingForceReadDirLstat</h2>
            <hr />
            
            <p>testingForceReadDirLstat forces ReadDir to call Lstat, for testing that code path.
This can be difficult to provoke on some Unix systems otherwise.</p>
            
            <pre><code>testingForceReadDirLstat bool</code></pre>
         </article>
         
         <article class="global" data-name="dirBufSize">
            <h2>dirBufSize</h2>
            <hr />
            
            <p>dirBufSize is the size of the dirInfo buffer.
The buffer must be big enough to hold at least a single entry.
The filename alone can be 512 bytes (MAX_PATH*2), and the fixed part of
the FILE_ID_BOTH_DIR_INFO structure is 105 bytes, so dirBufSize
should not be set below 1024 bytes (512+105+safety buffer).
Windows 8.1 and earlier only works with buffer sizes up to 64 kB.</p>
            
            <pre><code>dirBufSize</code></pre>
         </article>
         
         <article class="global" data-name="dirBufPool">
            <h2>dirBufPool</h2>
            <hr />
            
            <pre><code>dirBufPool</code></pre>
         </article>
         
         <article class="global" data-name="allowReadDirFileID">
            <h2>allowReadDirFileID</h2>
            <hr />
            
            <p>allowReadDirFileID indicates whether File.readdir should try to use FILE_ID_BOTH_DIR_INFO
if the underlying file system supports it.
Useful for testing purposes.</p>
            
            <pre><code>allowReadDirFileID</code></pre>
         </article>
         
         <article class="global" data-name="_UTIME_OMIT">
            <h2>_UTIME_OMIT</h2>
            <hr />
            
            <p>This matches the value in syscall/syscall_windows.go.</p>
            
            <pre><code>_UTIME_OMIT</code></pre>
         </article>
         
         <article class="global" data-name="DevNull">
            <h2>DevNull</h2>
            <hr />
            
            <p>DevNull is the name of the operating system's “null device.”
On Unix-like systems, it is "/dev/null"; on Windows, "NUL".</p>
            
            <pre><code>DevNull</code></pre>
         </article>
         
         <article class="global" data-name="useGetTempPath2">
            <h2>useGetTempPath2</h2>
            <hr />
            
            <pre><code>useGetTempPath2</code></pre>
         </article>
         
         <article class="global" data-name="winreadlinkvolume">
            <h2>winreadlinkvolume</h2>
            <hr />
            
            <pre><code>winreadlinkvolume</code></pre>
         </article>
         
         <article class="global" data-name="supportsCloseOnExec">
            <h2>supportsCloseOnExec</h2>
            <hr />
            
            <p>supportsCloseOnExec reports whether the platform supports the
O_CLOEXEC flag.</p>
            
            <pre><code>supportsCloseOnExec</code></pre>
         </article>
         
         <article class="global" data-name="_P_PID">
            <h2>_P_PID</h2>
            <hr />
            
            <pre><code>_P_PID</code></pre>
         </article>
         
         <article class="global" data-name="ErrInvalid">
            <h2>ErrInvalid</h2>
            <hr />
            
            <p>ErrInvalid indicates an invalid argument.
Methods on File will return this error when the receiver is nil.</p>
            
            <pre><code>ErrInvalid</code></pre>
         </article>
         
         <article class="global" data-name="ErrPermission">
            <h2>ErrPermission</h2>
            <hr />
            
            <p>Portable analogs of some common system call errors.

Errors returned from this package may be tested against these errors
with [errors.Is].</p>
            
            <pre><code>ErrPermission</code></pre>
         </article>
         
         <article class="global" data-name="ErrExist">
            <h2>ErrExist</h2>
            <hr />
            
            <p>Portable analogs of some common system call errors.

Errors returned from this package may be tested against these errors
with [errors.Is].</p>
            
            <pre><code>ErrExist</code></pre>
         </article>
         
         <article class="global" data-name="ErrNotExist">
            <h2>ErrNotExist</h2>
            <hr />
            
            <p>Portable analogs of some common system call errors.

Errors returned from this package may be tested against these errors
with [errors.Is].</p>
            
            <pre><code>ErrNotExist</code></pre>
         </article>
         
         <article class="global" data-name="ErrClosed">
            <h2>ErrClosed</h2>
            <hr />
            
            <p>Portable analogs of some common system call errors.

Errors returned from this package may be tested against these errors
with [errors.Is].</p>
            
            <pre><code>ErrClosed</code></pre>
         </article>
         
         <article class="global" data-name="ErrNoDeadline">
            <h2>ErrNoDeadline</h2>
            <hr />
            
            <p>Portable analogs of some common system call errors.

Errors returned from this package may be tested against these errors
with [errors.Is].</p>
            
            <pre><code>ErrNoDeadline</code></pre>
         </article>
         
         <article class="global" data-name="ErrDeadlineExceeded">
            <h2>ErrDeadlineExceeded</h2>
            <hr />
            
            <p>Portable analogs of some common system call errors.

Errors returned from this package may be tested against these errors
with [errors.Is].</p>
            
            <pre><code>ErrDeadlineExceeded</code></pre>
         </article>
         
         <article class="global" data-name="rootMaxSymlinks">
            <h2>rootMaxSymlinks</h2>
            <hr />
            
            <p>Maximum number of symbolic links we will follow when resolving a file in a root.
8 is __POSIX_SYMLOOP_MAX (the minimum allowed value for SYMLOOP_MAX),
and a common limit.</p>
            
            <pre><code>rootMaxSymlinks</code></pre>
         </article>
         
         <article class="global" data-name="Atime">
            <h2>Atime</h2>
            <hr />
            
            <pre><code>Atime</code></pre>
         </article>
         
         <article class="global" data-name="LstatP">
            <h2>LstatP</h2>
            <hr />
            
            <pre><code>LstatP</code></pre>
         </article>
         
         <article class="global" data-name="ErrWriteAtInAppendMode">
            <h2>ErrWriteAtInAppendMode</h2>
            <hr />
            
            <pre><code>ErrWriteAtInAppendMode</code></pre>
         </article>
         
         <article class="global" data-name="TestingForceReadDirLstat">
            <h2>TestingForceReadDirLstat</h2>
            <hr />
            
            <pre><code>TestingForceReadDirLstat</code></pre>
         </article>
         
         <article class="global" data-name="ErrPatternHasSeparator">
            <h2>ErrPatternHasSeparator</h2>
            <hr />
            
            <pre><code>ErrPatternHasSeparator</code></pre>
         </article>
         
         <article class="global" data-name="initWd">
            <h2>initWd</h2>
            <hr />
            
            <p>We query the working directory at init, to use it later to search for the
executable file
errWd will be checked later, if we need to use initWd</p>
            
            <pre><code>initWd</code></pre>
         </article>
         
         <article class="global" data-name="errWd">
            <h2>errWd</h2>
            <hr />
            
            <p>We query the working directory at init, to use it later to search for the
executable file
errWd will be checked later, if we need to use initWd</p>
            
            <pre><code>errWd</code></pre>
         </article>
         
         <article class="global" data-name="bitSize16">
            <h2>bitSize16</h2>
            <hr />
            
            <pre><code>bitSize16</code></pre>
         </article>
         
         <article class="global" data-name="supportsCloseOnExec">
            <h2>supportsCloseOnExec</h2>
            <hr />
            
            <p>supportsCloseOnExec reports whether the platform supports the
O_CLOEXEC flag.</p>
            
            <pre><code>supportsCloseOnExec</code></pre>
         </article>
         
         <article class="global" data-name="blockSize">
            <h2>blockSize</h2>
            <hr />
            
            <p>More than 5760 to work around https://golang.org/issue/24015.</p>
            
            <pre><code>blockSize</code></pre>
         </article>
         
         <article class="global" data-name="dirBufPool">
            <h2>dirBufPool</h2>
            <hr />
            
            <pre><code>dirBufPool</code></pre>
         </article>
         
         <article class="global" data-name="sizeOfDirent">
            <h2>sizeOfDirent</h2>
            <hr />
            
            <p>https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md#-dirent-record</p>
            
            <pre><code>sizeOfDirent</code></pre>
         </article>
         
         <article class="global" data-name="checkPidfdOnce">
            <h2>checkPidfdOnce</h2>
            <hr />
            
            <pre><code>checkPidfdOnce</code></pre>
         </article>
         
         <article class="global" data-name="_P_PID">
            <h2>_P_PID</h2>
            <hr />
            
            <pre><code>_P_PID</code></pre>
         </article>
         
         <article class="global" data-name="ErrProcessDone">
            <h2>ErrProcessDone</h2>
            <hr />
            
            <p>ErrProcessDone indicates a [Process] has finished.</p>
            
            <pre><code>ErrProcessDone</code></pre>
         </article>
         
         <article class="global" data-name="modePID">
            <h2>modePID</h2>
            <hr />
            
            <p>modePID means that Process operations such use the raw PID from the
Pid field. handle is not used.

This may be due to the host not supporting handles, or because
Process was created as a literal, leaving handle unset.

This must be the zero value so Process literals get modePID.</p>
            
            <pre><code>modePID processMode</code></pre>
         </article>
         
         <article class="global" data-name="modeHandle">
            <h2>modeHandle</h2>
            <hr />
            
            <p>modeHandle means that Process operations use handle, which is
initialized with an OS process handle.

Note that Release and Wait will deactivate and eventually close the
handle, so acquire may fail, indicating the reason.</p>
            
            <pre><code>modeHandle</code></pre>
         </article>
         
         <article class="global" data-name="statusOK">
            <h2>statusOK</h2>
            <hr />
            
            <p>PID/handle OK to use.</p>
            
            <pre><code>statusOK processStatus</code></pre>
         </article>
         
         <article class="global" data-name="statusDone">
            <h2>statusDone</h2>
            <hr />
            
            <p>statusDone indicates that the PID/handle should not be used because
the process is done (has been successfully Wait'd on).</p>
            
            <pre><code>statusDone processStatus</code></pre>
         </article>
         
         <article class="global" data-name="statusReleased">
            <h2>statusReleased</h2>
            <hr />
            
            <p>statusReleased indicates that the PID/handle should not be used
because the process is released.</p>
            
            <pre><code>statusReleased processStatus</code></pre>
         </article>
         
         <article class="global" data-name="processStatusMask">
            <h2>processStatusMask</h2>
            <hr />
            
            <pre><code>processStatusMask</code></pre>
         </article>
         
         <article class="global" data-name="pidUnset">
            <h2>pidUnset</h2>
            <hr />
            
            <p>Special values for Process.Pid.</p>
            
            <pre><code>pidUnset</code></pre>
         </article>
         
         <article class="global" data-name="pidReleased">
            <h2>pidReleased</h2>
            <hr />
            
            <pre><code>pidReleased</code></pre>
         </article>
         
         <article class="global" data-name="ModeDir">
            <h2>ModeDir</h2>
            <hr />
            
            <p>The single letters are the abbreviations
used by the String method's formatting.</p>
            
            <pre><code>ModeDir</code></pre>
         </article>
         
         <article class="global" data-name="ModeAppend">
            <h2>ModeAppend</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeAppend</code></pre>
         </article>
         
         <article class="global" data-name="ModeExclusive">
            <h2>ModeExclusive</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeExclusive</code></pre>
         </article>
         
         <article class="global" data-name="ModeTemporary">
            <h2>ModeTemporary</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeTemporary</code></pre>
         </article>
         
         <article class="global" data-name="ModeSymlink">
            <h2>ModeSymlink</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeSymlink</code></pre>
         </article>
         
         <article class="global" data-name="ModeDevice">
            <h2>ModeDevice</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeDevice</code></pre>
         </article>
         
         <article class="global" data-name="ModeNamedPipe">
            <h2>ModeNamedPipe</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeNamedPipe</code></pre>
         </article>
         
         <article class="global" data-name="ModeSocket">
            <h2>ModeSocket</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeSocket</code></pre>
         </article>
         
         <article class="global" data-name="ModeSetuid">
            <h2>ModeSetuid</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeSetuid</code></pre>
         </article>
         
         <article class="global" data-name="ModeSetgid">
            <h2>ModeSetgid</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeSetgid</code></pre>
         </article>
         
         <article class="global" data-name="ModeCharDevice">
            <h2>ModeCharDevice</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeCharDevice</code></pre>
         </article>
         
         <article class="global" data-name="ModeSticky">
            <h2>ModeSticky</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeSticky</code></pre>
         </article>
         
         <article class="global" data-name="ModeIrregular">
            <h2>ModeIrregular</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModeIrregular</code></pre>
         </article>
         
         <article class="global" data-name="ModeType">
            <h2>ModeType</h2>
            <hr />
            
            <p>Mask for the type bits. For regular files, none will be set.</p>
            
            <pre><code>ModeType</code></pre>
         </article>
         
         <article class="global" data-name="ModePerm">
            <h2>ModePerm</h2>
            <hr />
            
            <p>The defined file mode bits are the most significant bits of the [FileMode].
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.</p>
            
            <pre><code>ModePerm</code></pre>
         </article>
         
         <article class="global" data-name="SplitPath">
            <h2>SplitPath</h2>
            <hr />
            
            <pre><code>SplitPath</code></pre>
         </article>
         
         <article class="global" data-name="executablePath">
            <h2>executablePath</h2>
            <hr />
            
            <pre><code>executablePath string</code></pre>
         </article>
         
         <article class="global" data-name="initCwd">
            <h2>initCwd</h2>
            <hr />
            
            <pre><code>initCwd</code></pre>
         </article>
         
         <article class="global" data-name="initCwdErr">
            <h2>initCwdErr</h2>
            <hr />
            
            <pre><code>initCwdErr</code></pre>
         </article>
         
         <article class="global" data-name="PathSeparator">
            <h2>PathSeparator</h2>
            <hr />
            
            <pre><code>PathSeparator</code></pre>
         </article>
         
         <article class="global" data-name="PathListSeparator">
            <h2>PathListSeparator</h2>
            <hr />
            
            <pre><code>PathListSeparator</code></pre>
         </article>
         
         <article class="global" data-name="_P_PID">
            <h2>_P_PID</h2>
            <hr />
            
            <pre><code>_P_PID</code></pre>
         </article>
         
         <article class="global" data-name="Stdin">
            <h2>Stdin</h2>
            <hr />
            
            <p>Stdin, Stdout, and Stderr are open Files pointing to the standard input,
standard output, and standard error file descriptors.

Note that the Go runtime writes to standard error for panics and crashes;
closing Stderr may cause those messages to go elsewhere, perhaps
to a file opened later.</p>
            
            <pre><code>Stdin</code></pre>
         </article>
         
         <article class="global" data-name="Stdout">
            <h2>Stdout</h2>
            <hr />
            
            <p>Stdin, Stdout, and Stderr are open Files pointing to the standard input,
standard output, and standard error file descriptors.

Note that the Go runtime writes to standard error for panics and crashes;
closing Stderr may cause those messages to go elsewhere, perhaps
to a file opened later.</p>
            
            <pre><code>Stdout</code></pre>
         </article>
         
         <article class="global" data-name="Stderr">
            <h2>Stderr</h2>
            <hr />
            
            <p>Stdin, Stdout, and Stderr are open Files pointing to the standard input,
standard output, and standard error file descriptors.

Note that the Go runtime writes to standard error for panics and crashes;
closing Stderr may cause those messages to go elsewhere, perhaps
to a file opened later.</p>
            
            <pre><code>Stderr</code></pre>
         </article>
         
         <article class="global" data-name="O_RDONLY">
            <h2>O_RDONLY</h2>
            <hr />
            
            <p>Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.</p>
            
            <pre><code>O_RDONLY int</code></pre>
         </article>
         
         <article class="global" data-name="O_WRONLY">
            <h2>O_WRONLY</h2>
            <hr />
            
            <p>Flags to OpenFile wrapping those of the underlying system. Not all
flags may be implemented on a given system.</p>
            
            <pre><code>O_WRONLY int</code></pre>
         </article>
         
         <article class="global" data-name="O_RDWR">
            <h2>O_RDWR</h2>
            <hr />
            
            <p>Flags to OpenFile wrapping those of the underlying system. Not all
flags may be implemented on a given system.</p>
            
            <pre><code>O_RDWR int</code></pre>
         </article>
         
         <article class="global" data-name="O_APPEND">
            <h2>O_APPEND</h2>
            <hr />
            
            <p>The remaining values may be or'ed in to control behavior.</p>
            
            <pre><code>O_APPEND int</code></pre>
         </article>
         
         <article class="global" data-name="O_CREATE">
            <h2>O_CREATE</h2>
            <hr />
            
            <p>Flags to OpenFile wrapping those of the underlying system. Not all
flags may be implemented on a given system.</p>
            
            <pre><code>O_CREATE int</code></pre>
         </article>
         
         <article class="global" data-name="O_EXCL">
            <h2>O_EXCL</h2>
            <hr />
            
            <p>Flags to OpenFile wrapping those of the underlying system. Not all
flags may be implemented on a given system.</p>
            
            <pre><code>O_EXCL int</code></pre>
         </article>
         
         <article class="global" data-name="O_SYNC">
            <h2>O_SYNC</h2>
            <hr />
            
            <p>Flags to OpenFile wrapping those of the underlying system. Not all
flags may be implemented on a given system.</p>
            
            <pre><code>O_SYNC int</code></pre>
         </article>
         
         <article class="global" data-name="O_TRUNC">
            <h2>O_TRUNC</h2>
            <hr />
            
            <p>Flags to OpenFile wrapping those of the underlying system. Not all
flags may be implemented on a given system.</p>
            
            <pre><code>O_TRUNC int</code></pre>
         </article>
         
         <article class="global" data-name="SEEK_SET">
            <h2>SEEK_SET</h2>
            <hr />
            
            <p>Seek whence values.

Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.</p>
            
            <pre><code>SEEK_SET int</code></pre>
         </article>
         
         <article class="global" data-name="SEEK_CUR">
            <h2>SEEK_CUR</h2>
            <hr />
            
            <p>Seek whence values.

Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.</p>
            
            <pre><code>SEEK_CUR int</code></pre>
         </article>
         
         <article class="global" data-name="SEEK_END">
            <h2>SEEK_END</h2>
            <hr />
            
            <p>Seek whence values.

Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd.</p>
            
            <pre><code>SEEK_END int</code></pre>
         </article>
         
         <article class="global" data-name="errWriteAtInAppendMode">
            <h2>errWriteAtInAppendMode</h2>
            <hr />
            
            <pre><code>errWriteAtInAppendMode</code></pre>
         </article>
         
         <article class="global" data-name="errPathEscapes">
            <h2>errPathEscapes</h2>
            <hr />
            
            <pre><code>errPathEscapes</code></pre>
         </article>
         
         <article class="global" data-name="lstat">
            <h2>lstat</h2>
            <hr />
            
            <p>lstat is overridden in tests.</p>
            
            <pre><code>lstat</code></pre>
         </article>
         
         <article class="global" data-name="checkWrapErr">
            <h2>checkWrapErr</h2>
            <hr />
            
            <p>checkWrapErr is the test hook to enable checking unexpected wrapped errors of poll.ErrFileClosing.
It is set to true in the export_test.go for tests (including fuzz tests).</p>
            
            <pre><code>checkWrapErr</code></pre>
         </article>
          
         <article class="struct" data-name="dirInfo">
            <h2>type dirInfo struct</h2>
            <hr />
            
            <p>Auxiliary information if the File describes a directory</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">dir uintptr</code></pre>
         </article>
         
         <article class="struct" data-name="fileStat">
            <h2>type fileStat struct</h2>
            <hr />
            
            <p>A fileStat is the implementation of FileInfo returned by Stat and Lstat.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
FileAttributes uint32
CreationTime syscall.Filetime
LastAccessTime syscall.Filetime
LastWriteTime syscall.Filetime
FileSizeHigh uint32
FileSizeLow uint32
ReparseTag uint32
filetype uint32
sync.Mutex
path string
vol uint32
idxhi uint32
idxlo uint32
appendNameToPath bool</code></pre>
         </article>
         
         <article class="struct" data-name="ProcessState">
            <h2>type ProcessState struct</h2>
            <hr />
            
            <p>ProcessState stores information about a process, as reported by Wait.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pid int
status syscall.WaitStatus
rusage *syscall.Rusage</code></pre>
         </article>
         
         <article class="struct" data-name="rawConn">
            <h2>type rawConn struct</h2>
            <hr />
            
            <p>rawConn implements syscall.RawConn.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">file *File</code></pre>
         </article>
         
         <article class="struct" data-name="root">
            <h2>type root struct</h2>
            <hr />
            
            <p>root implementation for platforms with a function to open a file
relative to a directory.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
mu sync.Mutex
fd sysfdType
refs int
closed bool</code></pre>
         </article>
         
         <article class="struct" data-name="file">
            <h2>type file struct</h2>
            <hr />
            
            <p>file is the real representation of *File.
The extra level of indirection ensures that no clients of os
can overwrite this data, which could cause the finalizer
to close the wrong file descriptor.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pfd poll.FD
name string
dirinfo *ast.IndexExpr
nonblock bool
stdoutOrErr bool
appendMode bool</code></pre>
         </article>
         
         <article class="struct" data-name="unixDirent">
            <h2>type unixDirent struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">parent string
name string
typ FileMode
info FileInfo</code></pre>
         </article>
         
         <article class="struct" data-name="fileStat">
            <h2>type fileStat struct</h2>
            <hr />
            
            <p>A fileStat is the implementation of FileInfo returned by Stat and Lstat.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
size int64
mode FileMode
modTime time.Time
sys syscall.Stat_t</code></pre>
         </article>
         
         <article class="struct" data-name="fileStat">
            <h2>type fileStat struct</h2>
            <hr />
            
            <p>A fileStat is the implementation of FileInfo returned by Stat and Lstat.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
size int64
mode FileMode
modTime time.Time
sys any</code></pre>
         </article>
         
         <article class="struct" data-name="file">
            <h2>type file struct</h2>
            <hr />
            
            <p>file is the real representation of *File.
The extra level of indirection ensures that no clients of os
can overwrite this data, which could cause the finalizer
to close the wrong file descriptor.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">fdmu poll.FDMutex
fd int
name string
dirinfo *ast.IndexExpr
appendMode bool</code></pre>
         </article>
         
         <article class="struct" data-name="dirInfo">
            <h2>type dirInfo struct</h2>
            <hr />
            
            <p>Auxiliary information if the File describes a directory</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mu sync.Mutex
buf []byte
nbuf int
bufp int</code></pre>
         </article>
         
         <article class="struct" data-name="rawConn">
            <h2>type rawConn struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="ProcessState">
            <h2>type ProcessState struct</h2>
            <hr />
            
            <p>ProcessState stores information about a process, as reported by Wait.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pid int
status *syscall.Waitmsg</code></pre>
         </article>
         
         <article class="struct" data-name="root">
            <h2>type root struct</h2>
            <hr />
            
            <p>root implementation for platforms with no openat.
Currently plan9 and js.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
closed atomic.Bool</code></pre>
         </article>
         
         <article class="struct" data-name="dirInfo">
            <h2>type dirInfo struct</h2>
            <hr />
            
            <p>Auxiliary information if the File describes a directory</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mu sync.Mutex
buf *[]byte
bufp int
h syscall.Handle
vol uint32
class uint32
path string</code></pre>
         </article>
         
         <article class="struct" data-name="dirEntry">
            <h2>type dirEntry struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">fs *fileStat</code></pre>
         </article>
         
         <article class="struct" data-name="file">
            <h2>type file struct</h2>
            <hr />
            
            <p>file is the real representation of *File.
The extra level of indirection ensures that no clients of os
can overwrite this data, which could cause the finalizer
to close the wrong file descriptor.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pfd poll.FD
name string
dirinfo *ast.IndexExpr
appendMode bool</code></pre>
         </article>
         
         <article class="struct" data-name="SyscallError">
            <h2>type SyscallError struct</h2>
            <hr />
            
            <p>SyscallError records an error from a specific system call.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Syscall string
Err error</code></pre>
         </article>
         
         <article class="struct" data-name="Root">
            <h2>type Root struct</h2>
            <hr />
            
            <p>Root may be used to only access files within a single directory tree.

Methods on Root can only access files and directories beneath a root directory.
If any component of a file name passed to a method of Root references a location
outside the root, the method returns an error.
File names may reference the directory itself (.).

Methods on Root will follow symbolic links, but symbolic links may not
reference a location outside the root.
Symbolic links must not be absolute.

Methods on Root do not prohibit traversal of filesystem boundaries,
Linux bind mounts, /proc special files, or access to Unix device files.

Methods on Root are safe to be used from multiple goroutines simultaneously.

On most platforms, creating a Root opens a file descriptor or handle referencing
the directory. If the directory is moved, methods on Root reference the original
directory in its new location.

Root's behavior differs on some platforms:

  - When GOOS=windows, file names may not reference Windows reserved device names
    such as NUL and COM1.
  - When GOOS=js, Root is vulnerable to TOCTOU (time-of-check-time-of-use)
    attacks in symlink validation, and cannot ensure that operations will not
    escape the root.
  - When GOOS=plan9 or GOOS=js, Root does not track directories across renames.
    On these platforms, a Root references a directory name, not a file descriptor.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">root *root</code></pre>
         </article>
         
         <article class="struct" data-name="dirInfo">
            <h2>type dirInfo struct</h2>
            <hr />
            
            <p>Auxiliary information if the File describes a directory</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mu sync.Mutex
buf *[]byte
nbuf int
bufp int</code></pre>
         </article>
         
         <article class="struct" data-name="Process">
            <h2>type Process struct</h2>
            <hr />
            
            <p>Process stores the information about a process created by [StartProcess].</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Pid int
mode processMode
state atomic.Uint64
sigMu sync.RWMutex
handle uintptr</code></pre>
         </article>
         
         <article class="struct" data-name="ProcAttr">
            <h2>type ProcAttr struct</h2>
            <hr />
            
            <p>ProcAttr holds the attributes that will be applied to a new process
started by StartProcess.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Dir string
Env []string
Files []*File
Sys *syscall.SysProcAttr</code></pre>
         </article>
         
         <article class="struct" data-name="File">
            <h2>type File struct</h2>
            <hr />
            
            <p>File represents an open file descriptor.

The methods of File are safe for concurrent use.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*file</code></pre>
         </article>
         
         <article class="struct" data-name="dirEntry">
            <h2>type dirEntry struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">fs *fileStat</code></pre>
         </article>
         
         <article class="struct" data-name="LinkError">
            <h2>type LinkError struct</h2>
            <hr />
            
            <p>LinkError records an error during a link or symlink or rename
system call and the paths that caused it.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Op string
Old string
New string
Err error</code></pre>
         </article>
         
         <article class="struct" data-name="noReadFrom">
            <h2>type noReadFrom struct</h2>
            <hr />
            
            <p>noReadFrom can be embedded alongside another type to
hide the ReadFrom method of that other type.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="fileWithoutReadFrom">
            <h2>type fileWithoutReadFrom struct</h2>
            <hr />
            
            <p>fileWithoutReadFrom implements all the methods of *File other
than ReadFrom. This is used to permit ReadFrom to call io.Copy
without leading to a recursive call to ReadFrom.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">noReadFrom
*File</code></pre>
         </article>
         
         <article class="struct" data-name="noWriteTo">
            <h2>type noWriteTo struct</h2>
            <hr />
            
            <p>noWriteTo can be embedded alongside another type to
hide the WriteTo method of that other type.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="fileWithoutWriteTo">
            <h2>type fileWithoutWriteTo struct</h2>
            <hr />
            
            <p>fileWithoutWriteTo implements all the methods of *File other
than WriteTo. This is used to permit WriteTo to call io.Copy
without leading to a recursive call to WriteTo.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">noWriteTo
*File</code></pre>
         </article>
          
         <article class="function" data-name="hostname">
            <h2>hostname</h2>
            <hr />
            
            <pre><code>func hostname() (name string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="direntIno">
            <h2>direntIno</h2>
            <hr />
            
            <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntReclen">
            <h2>direntReclen</h2>
            <hr />
            
            <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntNamlen">
            <h2>direntNamlen</h2>
            <hr />
            
            <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntType">
            <h2>direntType</h2>
            <hr />
            
            <pre><code>func direntType(buf []byte) FileMode</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close closes the [File], rendering it unusable for I/O.
On files that support [File.SetDeadline], any pending I/O operations will
be canceled and return immediately with an [ErrClosed] error.
Close will return an error if it has already been called.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="read">
            <h2>read</h2>
            <hr />
            
            <p>read reads up to len(b) bytes from the File.
It returns the number of bytes read and an error, if any.</p>
            
            <pre><code>func read(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="pread">
            <h2>pread</h2>
            <hr />
            
            <p>pread reads len(b) bytes from the File starting at byte offset off.
It returns the number of bytes read and the error, if any.
EOF is signaled by a zero count with err set to nil.</p>
            
            <pre><code>func pread(b []byte, off int64) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <p>write writes len(b) bytes to the File.
It returns the number of bytes written and an error, if any.</p>
            
            <pre><code>func write(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="pwrite">
            <h2>pwrite</h2>
            <hr />
            
            <p>pwrite writes len(b) bytes to the File starting at byte offset off.
It returns the number of bytes written and an error, if any.</p>
            
            <pre><code>func pwrite(b []byte, off int64) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="syscallMode">
            <h2>syscallMode</h2>
            <hr />
            
            <p>syscallMode returns the syscall-specific mode bits from Go's portable mode bits.</p>
            
            <pre><code>func syscallMode(i FileMode) o uint32</code></pre>
         </article>
         
         <article class="function" data-name="chmod">
            <h2>chmod</h2>
            <hr />
            
            <p>See docs in file.go:Chmod.</p>
            
            <pre><code>func chmod(name string, mode FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="chmod">
            <h2>chmod</h2>
            <hr />
            
            <p>See docs in file.go:(*File).Chmod.</p>
            
            <pre><code>func chmod(mode FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="Chown">
            <h2>Chown</h2>
            <hr />
            
            <p>Chown changes the numeric uid and gid of the named file.
If the file is a symbolic link, it changes the uid and gid of the link's target.
A uid or gid of -1 means to not change that value.
If there is an error, it will be of type [*PathError].

On Windows or Plan 9, Chown always returns the [syscall.EWINDOWS] or
EPLAN9 error, wrapped in *PathError.</p>
            
            <pre><code>func Chown(name string, uid int, gid int) error</code></pre>
         </article>
         
         <article class="function" data-name="Lchown">
            <h2>Lchown</h2>
            <hr />
            
            <p>Lchown changes the numeric uid and gid of the named file.
If the file is a symbolic link, it changes the uid and gid of the link itself.
If there is an error, it will be of type [*PathError].

On Windows, it always returns the [syscall.EWINDOWS] error, wrapped
in *PathError.</p>
            
            <pre><code>func Lchown(name string, uid int, gid int) error</code></pre>
         </article>
         
         <article class="function" data-name="Chown">
            <h2>Chown</h2>
            <hr />
            
            <p>Chown changes the numeric uid and gid of the named file.
If there is an error, it will be of type [*PathError].

On Windows, it always returns the [syscall.EWINDOWS] error, wrapped
in *PathError.</p>
            
            <pre><code>func Chown(uid int, gid int) error</code></pre>
         </article>
         
         <article class="function" data-name="Truncate">
            <h2>Truncate</h2>
            <hr />
            
            <p>Truncate changes the size of the file.
It does not change the I/O offset.
If there is an error, it will be of type [*PathError].</p>
            
            <pre><code>func Truncate(size int64) error</code></pre>
         </article>
         
         <article class="function" data-name="Sync">
            <h2>Sync</h2>
            <hr />
            
            <p>Sync commits the current contents of the file to stable storage.
Typically, this means flushing the file system's in-memory copy
of recently written data to disk.</p>
            
            <pre><code>func Sync() error</code></pre>
         </article>
         
         <article class="function" data-name="Chtimes">
            <h2>Chtimes</h2>
            <hr />
            
            <p>Chtimes changes the access and modification times of the named
file, similar to the Unix utime() or utimes() functions.
A zero [time.Time] value will leave the corresponding file time unchanged.

The underlying filesystem may truncate or round the values to a
less precise time unit.
If there is an error, it will be of type [*PathError].</p>
            
            <pre><code>func Chtimes(name string, atime time.Time, mtime time.Time) error</code></pre>
         </article>
         
         <article class="function" data-name="Chdir">
            <h2>Chdir</h2>
            <hr />
            
            <p>Chdir changes the current working directory to the file,
which must be a directory.
If there is an error, it will be of type [*PathError].</p>
            
            <pre><code>func Chdir() error</code></pre>
         </article>
         
         <article class="function" data-name="setDeadline">
            <h2>setDeadline</h2>
            <hr />
            
            <p>setDeadline sets the read and write deadline.</p>
            
            <pre><code>func setDeadline(t time.Time) error</code></pre>
         </article>
         
         <article class="function" data-name="setReadDeadline">
            <h2>setReadDeadline</h2>
            <hr />
            
            <p>setReadDeadline sets the read deadline.</p>
            
            <pre><code>func setReadDeadline(t time.Time) error</code></pre>
         </article>
         
         <article class="function" data-name="setWriteDeadline">
            <h2>setWriteDeadline</h2>
            <hr />
            
            <p>setWriteDeadline sets the write deadline.</p>
            
            <pre><code>func setWriteDeadline(t time.Time) error</code></pre>
         </article>
         
         <article class="function" data-name="checkValid">
            <h2>checkValid</h2>
            <hr />
            
            <p>checkValid checks whether f is valid for use.
If not, it returns an appropriate error, perhaps incorporating the operation name op.</p>
            
            <pre><code>func checkValid(op string) error</code></pre>
         </article>
         
         <article class="function" data-name="ignoringEINTR">
            <h2>ignoringEINTR</h2>
            <hr />
            
            <p>ignoringEINTR makes a function call and repeats it if it returns an
EINTR error. This appears to be required even though we install all
signal handlers with SA_RESTART: see #22838, #38033, #38836, #40846.
Also #20400 and #36644 are issues in which a signal handler is
installed without setting SA_RESTART. None of these are the common case,
but there are enough of them that it seems that we can't avoid
an EINTR loop.</p>
            
            <pre><code>func ignoringEINTR(fn func) error</code></pre>
         </article>
         
         <article class="function" data-name="ignoringEINTR2">
            <h2>ignoringEINTR2</h2>
            <hr />
            
            <p>ignoringEINTR2 is ignoringEINTR, but returning an additional value.</p>
            
            <pre><code>func ignoringEINTR2(fn func) (T, error)</code></pre>
         </article>
         
         <article class="function" data-name="close">
            <h2>close</h2>
            <hr />
            
            <pre><code>func close()</code></pre>
         </article>
         
         <article class="function" data-name="readdir">
            <h2>readdir</h2>
            <hr />
            
            <pre><code>func readdir(n int, mode readdirMode) (names []string, dirents []DirEntry, infos []FileInfo, err error)</code></pre>
         </article>
         
         <article class="function" data-name="dtToType">
            <h2>dtToType</h2>
            <hr />
            
            <pre><code>func dtToType(typ uint8) FileMode</code></pre>
         </article>
         
         <article class="function" data-name="closedir">
            <h2>closedir</h2>
            <hr />
            
            <pre><code>func closedir(dir uintptr) err error</code></pre>
         </article>
         
         <article class="function" data-name="readdir_r">
            <h2>readdir_r</h2>
            <hr />
            
            <pre><code>func readdir_r(dir uintptr, entry *syscall.Dirent, result **syscall.Dirent) res syscall.Errno</code></pre>
         </article>
         
         <article class="function" data-name="fillFileStatFromSys">
            <h2>fillFileStatFromSys</h2>
            <hr />
            
            <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
         </article>
         
         <article class="function" data-name="atime">
            <h2>atime</h2>
            <hr />
            
            <p>For testing.</p>
            
            <pre><code>func atime(fi FileInfo) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="wait6">
            <h2>wait6</h2>
            <hr />
            
            <pre><code>func wait6(idtype int, id int, options int) (status int, errno syscall.Errno)</code></pre>
         </article>
         
         <article class="function" data-name="IsPathSeparator">
            <h2>IsPathSeparator</h2>
            <hr />
            
            <p>IsPathSeparator reports whether c is a directory separator character.</p>
            
            <pre><code>func IsPathSeparator(c uint8) bool</code></pre>
         </article>
         
         <article class="function" data-name="splitPath">
            <h2>splitPath</h2>
            <hr />
            
            <p>splitPath returns the base name and parent directory.</p>
            
            <pre><code>func splitPath(path string) (string, string)</code></pre>
         </article>
         
         <article class="function" data-name="checkPathEscapes">
            <h2>checkPathEscapes</h2>
            <hr />
            
            <p>checkPathEscapes reports whether name escapes the root.

Due to the lack of openat, checkPathEscapes is subject to TOCTOU races
when symlinks change during the resolution process.</p>
            
            <pre><code>func checkPathEscapes(r *Root, name string) error</code></pre>
         </article>
         
         <article class="function" data-name="checkPathEscapesLstat">
            <h2>checkPathEscapesLstat</h2>
            <hr />
            
            <p>checkPathEscapesLstat reports whether name escapes the root.
It does not resolve symlinks in the final path component.

Due to the lack of openat, checkPathEscapes is subject to TOCTOU races
when symlinks change during the resolution process.</p>
            
            <pre><code>func checkPathEscapesLstat(r *Root, name string) error</code></pre>
         </article>
         
         <article class="function" data-name="checkPathEscapesInternal">
            <h2>checkPathEscapesInternal</h2>
            <hr />
            
            <pre><code>func checkPathEscapesInternal(r *Root, name string, lstat bool) error</code></pre>
         </article>
         
         <article class="function" data-name="Hostname">
            <h2>Hostname</h2>
            <hr />
            
            <p>Hostname returns the host name reported by the kernel.</p>
            
            <pre><code>func Hostname() (name string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="newFileStatFromGetFileInformationByHandle">
            <h2>newFileStatFromGetFileInformationByHandle</h2>
            <hr />
            
            <p>newFileStatFromGetFileInformationByHandle calls GetFileInformationByHandle
to gather all required information about the file handle h.</p>
            
            <pre><code>func newFileStatFromGetFileInformationByHandle(path string, h syscall.Handle) (fs *fileStat, err error)</code></pre>
         </article>
         
         <article class="function" data-name="newFileStatFromWin32FileAttributeData">
            <h2>newFileStatFromWin32FileAttributeData</h2>
            <hr />
            
            <p>newFileStatFromWin32FileAttributeData copies all required information
from syscall.Win32FileAttributeData d into the newly created fileStat.</p>
            
            <pre><code>func newFileStatFromWin32FileAttributeData(d *syscall.Win32FileAttributeData) *fileStat</code></pre>
         </article>
         
         <article class="function" data-name="newFileStatFromFileIDBothDirInfo">
            <h2>newFileStatFromFileIDBothDirInfo</h2>
            <hr />
            
            <p>newFileStatFromFileIDBothDirInfo copies all required information
from windows.FILE_ID_BOTH_DIR_INFO d into the newly created fileStat.</p>
            
            <pre><code>func newFileStatFromFileIDBothDirInfo(d *windows.FILE_ID_BOTH_DIR_INFO) *fileStat</code></pre>
         </article>
         
         <article class="function" data-name="newFileStatFromFileFullDirInfo">
            <h2>newFileStatFromFileFullDirInfo</h2>
            <hr />
            
            <p>newFileStatFromFileFullDirInfo copies all required information
from windows.FILE_FULL_DIR_INFO d into the newly created fileStat.</p>
            
            <pre><code>func newFileStatFromFileFullDirInfo(d *windows.FILE_FULL_DIR_INFO) *fileStat</code></pre>
         </article>
         
         <article class="function" data-name="newFileStatFromWin32finddata">
            <h2>newFileStatFromWin32finddata</h2>
            <hr />
            
            <p>newFileStatFromWin32finddata copies all required information
from syscall.Win32finddata d into the newly created fileStat.</p>
            
            <pre><code>func newFileStatFromWin32finddata(d *syscall.Win32finddata) *fileStat</code></pre>
         </article>
         
         <article class="function" data-name="isReparseTagNameSurrogate">
            <h2>isReparseTagNameSurrogate</h2>
            <hr />
            
            <p>isReparseTagNameSurrogate determines whether a tag's associated
reparse point is a surrogate for another named entity (for example, a mounted folder).

See https://learn.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-isreparsetagnamesurrogate
and https://learn.microsoft.com/en-us/windows/win32/fileio/reparse-point-tags.</p>
            
            <pre><code>func isReparseTagNameSurrogate() bool</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <pre><code>func Size() int64</code></pre>
         </article>
         
         <article class="function" data-name="Mode">
            <h2>Mode</h2>
            <hr />
            
            <pre><code>func Mode() FileMode</code></pre>
         </article>
         
         <article class="function" data-name="mode">
            <h2>mode</h2>
            <hr />
            
            <pre><code>func mode() m FileMode</code></pre>
         </article>
         
         <article class="function" data-name="modePreGo1_23">
            <h2>modePreGo1_23</h2>
            <hr />
            
            <p>modePreGo1_23 returns the FileMode for the fileStat, using the pre-Go 1.23
logic for determining the file mode.
The logic is subtle and not well-documented, so it is better to keep it
separate from the new logic.</p>
            
            <pre><code>func modePreGo1_23() m FileMode</code></pre>
         </article>
         
         <article class="function" data-name="ModTime">
            <h2>ModTime</h2>
            <hr />
            
            <pre><code>func ModTime() time.Time</code></pre>
         </article>
         
         <article class="function" data-name="Sys">
            <h2>Sys</h2>
            <hr />
            
            <p>Sys returns syscall.Win32FileAttributeData for file fs.</p>
            
            <pre><code>func Sys() any</code></pre>
         </article>
         
         <article class="function" data-name="loadFileId">
            <h2>loadFileId</h2>
            <hr />
            
            <pre><code>func loadFileId() error</code></pre>
         </article>
         
         <article class="function" data-name="saveInfoFromPath">
            <h2>saveInfoFromPath</h2>
            <hr />
            
            <p>saveInfoFromPath saves full path of the file to be used by os.SameFile later,
and set name from path.</p>
            
            <pre><code>func saveInfoFromPath(path string) error</code></pre>
         </article>
         
         <article class="function" data-name="sameFile">
            <h2>sameFile</h2>
            <hr />
            
            <pre><code>func sameFile(fs1 *fileStat, fs2 *fileStat) bool</code></pre>
         </article>
         
         <article class="function" data-name="atime">
            <h2>atime</h2>
            <hr />
            
            <p>For testing.</p>
            
            <pre><code>func atime(fi FileInfo) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="startProcess">
            <h2>startProcess</h2>
            <hr />
            
            <pre><code>func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error)</code></pre>
         </article>
         
         <article class="function" data-name="kill">
            <h2>kill</h2>
            <hr />
            
            <pre><code>func kill() error</code></pre>
         </article>
         
         <article class="function" data-name="Pid">
            <h2>Pid</h2>
            <hr />
            
            <p>Pid returns the process id of the exited process.</p>
            
            <pre><code>func Pid() int</code></pre>
         </article>
         
         <article class="function" data-name="exited">
            <h2>exited</h2>
            <hr />
            
            <pre><code>func exited() bool</code></pre>
         </article>
         
         <article class="function" data-name="success">
            <h2>success</h2>
            <hr />
            
            <pre><code>func success() bool</code></pre>
         </article>
         
         <article class="function" data-name="sys">
            <h2>sys</h2>
            <hr />
            
            <pre><code>func sys() any</code></pre>
         </article>
         
         <article class="function" data-name="sysUsage">
            <h2>sysUsage</h2>
            <hr />
            
            <pre><code>func sysUsage() any</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="ExitCode">
            <h2>ExitCode</h2>
            <hr />
            
            <p>ExitCode returns the exit code of the exited process, or -1
if the process hasn't exited or was terminated by a signal.</p>
            
            <pre><code>func ExitCode() int</code></pre>
         </article>
         
         <article class="function" data-name="executable">
            <h2>executable</h2>
            <hr />
            
            <pre><code>func executable() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="executable">
            <h2>executable</h2>
            <hr />
            
            <pre><code>func executable() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="direntIno">
            <h2>direntIno</h2>
            <hr />
            
            <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntReclen">
            <h2>direntReclen</h2>
            <hr />
            
            <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntNamlen">
            <h2>direntNamlen</h2>
            <hr />
            
            <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntType">
            <h2>direntType</h2>
            <hr />
            
            <pre><code>func direntType(buf []byte) FileMode</code></pre>
         </article>
         
         <article class="function" data-name="IsPathSeparator">
            <h2>IsPathSeparator</h2>
            <hr />
            
            <p>IsPathSeparator reports whether c is a directory separator character.</p>
            
            <pre><code>func IsPathSeparator(c uint8) bool</code></pre>
         </article>
         
         <article class="function" data-name="dirname">
            <h2>dirname</h2>
            <hr />
            
            <pre><code>func dirname(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="fixLongPath">
            <h2>fixLongPath</h2>
            <hr />
            
            <p>fixLongPath returns the extended-length (\\?\-prefixed) form of
path when needed, in order to avoid the default 260 character file
path limit imposed by Windows. If the path is short enough or already
has the extended-length prefix, fixLongPath returns path unmodified.
If the path is relative and joining it with the current working
directory results in a path that is too long, fixLongPath returns
the absolute path with the extended-length prefix.

See https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation</p>
            
            <pre><code>func fixLongPath(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="addExtendedPrefix">
            <h2>addExtendedPrefix</h2>
            <hr />
            
            <p>addExtendedPrefix adds the extended path prefix (\\?\) to path.</p>
            
            <pre><code>func addExtendedPrefix(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="fillFileStatFromSys">
            <h2>fillFileStatFromSys</h2>
            <hr />
            
            <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
         </article>
         
         <article class="function" data-name="stTimespecToTime">
            <h2>stTimespecToTime</h2>
            <hr />
            
            <pre><code>func stTimespecToTime(ts syscall.StTimespec_t) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="atime">
            <h2>atime</h2>
            <hr />
            
            <p>For testing.</p>
            
            <pre><code>func atime(fi FileInfo) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="fillFileStatFromSys">
            <h2>fillFileStatFromSys</h2>
            <hr />
            
            <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
         </article>
         
         <article class="function" data-name="atime">
            <h2>atime</h2>
            <hr />
            
            <p>For testing.</p>
            
            <pre><code>func atime(fi FileInfo) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="hostname">
            <h2>hostname</h2>
            <hr />
            
            <pre><code>func hostname() (name string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(w io.Writer) (written int64, handled bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readFrom">
            <h2>readFrom</h2>
            <hr />
            
            <pre><code>func readFrom(r io.Reader) (written int64, handled bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="spliceToFile">
            <h2>spliceToFile</h2>
            <hr />
            
            <pre><code>func spliceToFile(r io.Reader) (written int64, handled bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="copyFileRange">
            <h2>copyFileRange</h2>
            <hr />
            
            <pre><code>func copyFileRange(r io.Reader) (written int64, handled bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="getPollFDAndNetwork">
            <h2>getPollFDAndNetwork</h2>
            <hr />
            
            <p>getPollFDAndNetwork tries to get the poll.FD and network type from the given interface
by expecting the underlying type of i to be the implementation of syscall.Conn
that contains a *net.rawConn.</p>
            
            <pre><code>func getPollFDAndNetwork(i any) (*poll.FD, poll.String)</code></pre>
         </article>
         
         <article class="function" data-name="isUnixOrTCP">
            <h2>isUnixOrTCP</h2>
            <hr />
            
            <pre><code>func isUnixOrTCP(network string) bool</code></pre>
         </article>
         
         <article class="function" data-name="open">
            <h2>open</h2>
            <hr />
            
            <pre><code>func open(filePath string, flag int, perm uint32) (int, poll.SysFile, error)</code></pre>
         </article>
         
         <article class="function" data-name="rootCleanPath">
            <h2>rootCleanPath</h2>
            <hr />
            
            <pre><code>func rootCleanPath(s string, prefix []string, suffix []string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="blockUntilWaitable">
            <h2>blockUntilWaitable</h2>
            <hr />
            
            <p>blockUntilWaitable attempts to block until a call to p.Wait will
succeed immediately, and reports whether it has done so.
It does not actually call p.Wait.</p>
            
            <pre><code>func blockUntilWaitable() (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="direntIno">
            <h2>direntIno</h2>
            <hr />
            
            <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntReclen">
            <h2>direntReclen</h2>
            <hr />
            
            <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntNamlen">
            <h2>direntNamlen</h2>
            <hr />
            
            <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntType">
            <h2>direntType</h2>
            <hr />
            
            <pre><code>func direntType(buf []byte) FileMode</code></pre>
         </article>
         
         <article class="function" data-name="runtime_rand">
            <h2>runtime_rand</h2>
            <hr />
            
            <p>random number source provided by runtime.
We generate random temporary file names so that there's a good
chance the file doesn't exist yet - keeps the number of tries in
TempFile to a minimum.</p>
            
            <pre><code>func runtime_rand() uint64</code></pre>
         </article>
         
         <article class="function" data-name="nextRandom">
            <h2>nextRandom</h2>
            <hr />
            
            <pre><code>func nextRandom() string</code></pre>
         </article>
         
         <article class="function" data-name="CreateTemp">
            <h2>CreateTemp</h2>
            <hr />
            
            <p>CreateTemp creates a new temporary file in the directory dir,
opens the file for reading and writing, and returns the resulting file.
The filename is generated by taking pattern and adding a random string to the end.
If pattern includes a "*", the random string replaces the last "*".
The file is created with mode 0o600 (before umask).
If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by [TempDir].
Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file.
The caller can use the file's Name method to find the pathname of the file.
It is the caller's responsibility to remove the file when it is no longer needed.</p>
            
            <pre><code>func CreateTemp(dir string, pattern string) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="prefixAndSuffix">
            <h2>prefixAndSuffix</h2>
            <hr />
            
            <p>prefixAndSuffix splits pattern by the last wildcard "*", if applicable,
returning prefix as the part before "*" and suffix as the part after "*".</p>
            
            <pre><code>func prefixAndSuffix(pattern string) (prefix string, suffix string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="MkdirTemp">
            <h2>MkdirTemp</h2>
            <hr />
            
            <p>MkdirTemp creates a new temporary directory in the directory dir
and returns the pathname of the new directory.
The new directory's name is generated by adding a random string to the end of pattern.
If pattern includes a "*", the random string replaces the last "*" instead.
The directory is created with mode 0o700 (before umask).
If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir.
Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.
It is the caller's responsibility to remove the directory when it is no longer needed.</p>
            
            <pre><code>func MkdirTemp(dir string, pattern string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="joinPath">
            <h2>joinPath</h2>
            <hr />
            
            <pre><code>func joinPath(dir string, name string) string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(w io.Writer) (written int64, handled bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readFrom">
            <h2>readFrom</h2>
            <hr />
            
            <pre><code>func readFrom(r io.Reader) (written int64, handled bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="closeHandle">
            <h2>closeHandle</h2>
            <hr />
            
            <pre><code>func closeHandle()</code></pre>
         </article>
         
         <article class="function" data-name="hostname">
            <h2>hostname</h2>
            <hr />
            
            <pre><code>func hostname() (name string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="wait6">
            <h2>wait6</h2>
            <hr />
            
            <pre><code>func wait6(idtype int, id int, options int) (status int, errno syscall.Errno)</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(w io.Writer) (written int64, handled bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readFrom">
            <h2>readFrom</h2>
            <hr />
            
            <p>readFrom is basically a refactor of net.sendFile, but adapted to work for the target of *File.</p>
            
            <pre><code>func readFrom(r io.Reader) (written int64, handled bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="direntIno">
            <h2>direntIno</h2>
            <hr />
            
            <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntReclen">
            <h2>direntReclen</h2>
            <hr />
            
            <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntNamlen">
            <h2>direntNamlen</h2>
            <hr />
            
            <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntType">
            <h2>direntType</h2>
            <hr />
            
            <pre><code>func direntType(buf []byte) FileMode</code></pre>
         </article>
         
         <article class="function" data-name="executable">
            <h2>executable</h2>
            <hr />
            
            <pre><code>func executable() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="getModuleFileName">
            <h2>getModuleFileName</h2>
            <hr />
            
            <pre><code>func getModuleFileName(handle syscall.Handle) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="executable">
            <h2>executable</h2>
            <hr />
            
            <pre><code>func executable() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Pipe">
            <h2>Pipe</h2>
            <hr />
            
            <p>Pipe returns a connected pair of Files; reads from r return bytes written to w.
It returns the files and an error, if any.</p>
            
            <pre><code>func Pipe() (r *File, w *File, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Control">
            <h2>Control</h2>
            <hr />
            
            <pre><code>func Control(f func) error</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(f func) error</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(f func) error</code></pre>
         </article>
         
         <article class="function" data-name="newRawConn">
            <h2>newRawConn</h2>
            <hr />
            
            <pre><code>func newRawConn(file *File) (*rawConn, error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="incref">
            <h2>incref</h2>
            <hr />
            
            <pre><code>func incref() error</code></pre>
         </article>
         
         <article class="function" data-name="decref">
            <h2>decref</h2>
            <hr />
            
            <pre><code>func decref()</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="rootMkdir">
            <h2>rootMkdir</h2>
            <hr />
            
            <pre><code>func rootMkdir(r *Root, name string, perm FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="rootRemove">
            <h2>rootRemove</h2>
            <hr />
            
            <pre><code>func rootRemove(r *Root, name string) error</code></pre>
         </article>
         
         <article class="function" data-name="doInRoot">
            <h2>doInRoot</h2>
            <hr />
            
            <p>doInRoot performs an operation on a path in a Root.

It opens the directory containing the final element of the path,
and calls f with the directory FD and name of the final element.

If the path refers to a symlink which should be followed,
then f must return errSymlink.
doInRoot will follow the symlink and call f again.</p>
            
            <pre><code>func doInRoot(r *Root, name string, f func) (ret T, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="direntIno">
            <h2>direntIno</h2>
            <hr />
            
            <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntReclen">
            <h2>direntReclen</h2>
            <hr />
            
            <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntNamlen">
            <h2>direntNamlen</h2>
            <hr />
            
            <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntType">
            <h2>direntType</h2>
            <hr />
            
            <pre><code>func direntType(buf []byte) FileMode</code></pre>
         </article>
         
         <article class="function" data-name="removeAll">
            <h2>removeAll</h2>
            <hr />
            
            <pre><code>func removeAll(path string) error</code></pre>
         </article>
         
         <article class="function" data-name="wrapSyscallError">
            <h2>wrapSyscallError</h2>
            <hr />
            
            <p>wrapSyscallError takes an error and a syscall name. If the error is
a syscall.Errno, it wraps it in an os.SyscallError using the syscall name.</p>
            
            <pre><code>func wrapSyscallError(name string, err error) error</code></pre>
         </article>
         
         <article class="function" data-name="tryLimitedReader">
            <h2>tryLimitedReader</h2>
            <hr />
            
            <p>tryLimitedReader tries to assert the io.Reader to io.LimitedReader, it returns the io.LimitedReader,
the underlying io.Reader and the remaining amount of bytes if the assertion succeeds,
otherwise it just returns the original io.Reader and the theoretical unlimited remaining amount of bytes.</p>
            
            <pre><code>func tryLimitedReader(r io.Reader) (*io.LimitedReader, io.Reader, int64)</code></pre>
         </article>
         
         <article class="function" data-name="executable">
            <h2>executable</h2>
            <hr />
            
            <pre><code>func executable() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Status">
            <h2>Status</h2>
            <hr />
            
            <pre><code>func Status() processStatus</code></pre>
         </article>
         
         <article class="function" data-name="fixLongPath">
            <h2>fixLongPath</h2>
            <hr />
            
            <p>fixLongPath is a noop on non-Windows platforms.</p>
            
            <pre><code>func fixLongPath(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="rename">
            <h2>rename</h2>
            <hr />
            
            <pre><code>func rename(oldname string, newname string) error</code></pre>
         </article>
         
         <article class="function" data-name="Fd">
            <h2>Fd</h2>
            <hr />
            
            <p>Fd returns the integer Unix file descriptor referencing the open file.
If f is closed, the file descriptor becomes invalid.
If f is garbage collected, a finalizer may close the file descriptor,
making it invalid; see [runtime.SetFinalizer] for more information on when
a finalizer might be run. On Unix systems this will cause the [File.SetDeadline]
methods to stop working.
Because file descriptors can be reused, the returned file descriptor may
only be closed through the [File.Close] method of f, or by its finalizer during
garbage collection. Otherwise, during garbage collection the finalizer
may close an unrelated file descriptor with the same (reused) number.

As an alternative, see the f.SyscallConn method.</p>
            
            <pre><code>func Fd() uintptr</code></pre>
         </article>
         
         <article class="function" data-name="NewFile">
            <h2>NewFile</h2>
            <hr />
            
            <p>NewFile returns a new File with the given file descriptor and
name. The returned value will be nil if fd is not a valid file
descriptor. On Unix systems, if the file descriptor is in
non-blocking mode, NewFile will attempt to return a pollable File
(one for which the SetDeadline methods work).

After passing it to NewFile, fd may become invalid under the same
conditions described in the comments of the Fd method, and the same
constraints apply.</p>
            
            <pre><code>func NewFile(fd uintptr, name string) *File</code></pre>
         </article>
         
         <article class="function" data-name="net_newUnixFile">
            <h2>net_newUnixFile</h2>
            <hr />
            
            <p>net_newUnixFile is a hidden entry point called by net.conn.File.
This is used so that a nonblocking network connection will become
blocking if code calls the Fd method. We don't want that for direct
calls to NewFile: passing a nonblocking descriptor to NewFile should
remain nonblocking if you get it back using Fd. But for net.conn.File
the call to NewFile is hidden from the user. Historically in that case
the Fd method has returned a blocking descriptor, and we want to
retain that behavior because existing code expects it and depends on it.</p>
            
            <pre><code>func net_newUnixFile(fd int, name string) *File</code></pre>
         </article>
         
         <article class="function" data-name="newFile">
            <h2>newFile</h2>
            <hr />
            
            <p>newFile is like NewFile, but if called from OpenFile or Pipe
(as passed in the kind parameter) it tries to add the file to
the runtime poller.</p>
            
            <pre><code>func newFile(fd int, name string, kind newFileKind, nonBlocking bool) *File</code></pre>
         </article>
         
         <article class="function" data-name="sigpipe">
            <h2>sigpipe</h2>
            <hr />
            
            <pre><code>func sigpipe()</code></pre>
         </article>
         
         <article class="function" data-name="epipecheck">
            <h2>epipecheck</h2>
            <hr />
            
            <p>epipecheck raises SIGPIPE if we get an EPIPE error on standard
output or standard error. See the SIGPIPE docs in os/signal, and
issue 11845.</p>
            
            <pre><code>func epipecheck(file *File, e error)</code></pre>
         </article>
         
         <article class="function" data-name="openFileNolog">
            <h2>openFileNolog</h2>
            <hr />
            
            <p>openFileNolog is the Unix implementation of OpenFile.
Changes here should be reflected in openDirAt and openDirNolog, if relevant.</p>
            
            <pre><code>func openFileNolog(name string, flag int, perm FileMode) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="openDirNolog">
            <h2>openDirNolog</h2>
            <hr />
            
            <pre><code>func openDirNolog(name string) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="close">
            <h2>close</h2>
            <hr />
            
            <pre><code>func close() error</code></pre>
         </article>
         
         <article class="function" data-name="seek">
            <h2>seek</h2>
            <hr />
            
            <p>seek sets the offset for the next Read or Write on file to offset, interpreted
according to whence: 0 means relative to the origin of the file, 1 means
relative to the current offset, and 2 means relative to the end.
It returns the new offset and an error, if any.</p>
            
            <pre><code>func seek(offset int64, whence int) (ret int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Truncate">
            <h2>Truncate</h2>
            <hr />
            
            <p>Truncate changes the size of the named file.
If the file is a symbolic link, it changes the size of the link's target.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Truncate(name string, size int64) error</code></pre>
         </article>
         
         <article class="function" data-name="Remove">
            <h2>Remove</h2>
            <hr />
            
            <p>Remove removes the named file or (empty) directory.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Remove(name string) error</code></pre>
         </article>
         
         <article class="function" data-name="tempDir">
            <h2>tempDir</h2>
            <hr />
            
            <pre><code>func tempDir() string</code></pre>
         </article>
         
         <article class="function" data-name="Link">
            <h2>Link</h2>
            <hr />
            
            <p>Link creates newname as a hard link to the oldname file.
If there is an error, it will be of type *LinkError.</p>
            
            <pre><code>func Link(oldname string, newname string) error</code></pre>
         </article>
         
         <article class="function" data-name="Symlink">
            <h2>Symlink</h2>
            <hr />
            
            <p>Symlink creates newname as a symbolic link to oldname.
On Windows, a symlink to a non-existent oldname creates a file symlink;
if oldname is later created as a directory the symlink will not work.
If there is an error, it will be of type *LinkError.</p>
            
            <pre><code>func Symlink(oldname string, newname string) error</code></pre>
         </article>
         
         <article class="function" data-name="readlink">
            <h2>readlink</h2>
            <hr />
            
            <pre><code>func readlink(name string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="IsDir">
            <h2>IsDir</h2>
            <hr />
            
            <pre><code>func IsDir() bool</code></pre>
         </article>
         
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <pre><code>func Type() FileMode</code></pre>
         </article>
         
         <article class="function" data-name="Info">
            <h2>Info</h2>
            <hr />
            
            <pre><code>func Info() (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="newUnixDirent">
            <h2>newUnixDirent</h2>
            <hr />
            
            <pre><code>func newUnixDirent(parent string, name string, typ FileMode) (DirEntry, error)</code></pre>
         </article>
         
         <article class="function" data-name="hostname">
            <h2>hostname</h2>
            <hr />
            
            <pre><code>func hostname() (name string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <pre><code>func Size() int64</code></pre>
         </article>
         
         <article class="function" data-name="Mode">
            <h2>Mode</h2>
            <hr />
            
            <pre><code>func Mode() FileMode</code></pre>
         </article>
         
         <article class="function" data-name="ModTime">
            <h2>ModTime</h2>
            <hr />
            
            <pre><code>func ModTime() time.Time</code></pre>
         </article>
         
         <article class="function" data-name="Sys">
            <h2>Sys</h2>
            <hr />
            
            <pre><code>func Sys() any</code></pre>
         </article>
         
         <article class="function" data-name="sameFile">
            <h2>sameFile</h2>
            <hr />
            
            <pre><code>func sameFile(fs1 *fileStat, fs2 *fileStat) bool</code></pre>
         </article>
         
         <article class="function" data-name="MkdirAll">
            <h2>MkdirAll</h2>
            <hr />
            
            <p>MkdirAll creates a directory named path,
along with any necessary parents, and returns nil,
or else returns an error.
The permission bits perm (before umask) are used for all
directories that MkdirAll creates.
If path is already a directory, MkdirAll does nothing
and returns nil.</p>
            
            <pre><code>func MkdirAll(path string, perm FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="RemoveAll">
            <h2>RemoveAll</h2>
            <hr />
            
            <p>RemoveAll removes path and any children it contains.
It removes everything it can but returns the first error
it encounters. If the path does not exist, RemoveAll
returns nil (no error).
If there is an error, it will be of type [*PathError].</p>
            
            <pre><code>func RemoveAll(path string) error</code></pre>
         </article>
         
         <article class="function" data-name="endsWithDot">
            <h2>endsWithDot</h2>
            <hr />
            
            <p>endsWithDot reports whether the final component of path is ".".</p>
            
            <pre><code>func endsWithDot(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="blockUntilWaitable">
            <h2>blockUntilWaitable</h2>
            <hr />
            
            <p>blockUntilWaitable attempts to block until a call to p.Wait will
succeed immediately, and reports whether it has done so.
It does not actually call p.Wait.</p>
            
            <pre><code>func blockUntilWaitable() (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <pre><code>func Size() int64</code></pre>
         </article>
         
         <article class="function" data-name="Mode">
            <h2>Mode</h2>
            <hr />
            
            <pre><code>func Mode() FileMode</code></pre>
         </article>
         
         <article class="function" data-name="ModTime">
            <h2>ModTime</h2>
            <hr />
            
            <pre><code>func ModTime() time.Time</code></pre>
         </article>
         
         <article class="function" data-name="Sys">
            <h2>Sys</h2>
            <hr />
            
            <pre><code>func Sys() any</code></pre>
         </article>
         
         <article class="function" data-name="sameFile">
            <h2>sameFile</h2>
            <hr />
            
            <pre><code>func sameFile(fs1 *fileStat, fs2 *fileStat) bool</code></pre>
         </article>
         
         <article class="function" data-name="direntIno">
            <h2>direntIno</h2>
            <hr />
            
            <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntReclen">
            <h2>direntReclen</h2>
            <hr />
            
            <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntNamlen">
            <h2>direntNamlen</h2>
            <hr />
            
            <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntType">
            <h2>direntType</h2>
            <hr />
            
            <pre><code>func direntType(buf []byte) FileMode</code></pre>
         </article>
         
         <article class="function" data-name="direntIno">
            <h2>direntIno</h2>
            <hr />
            
            <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntReclen">
            <h2>direntReclen</h2>
            <hr />
            
            <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntNamlen">
            <h2>direntNamlen</h2>
            <hr />
            
            <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntType">
            <h2>direntType</h2>
            <hr />
            
            <pre><code>func direntType(buf []byte) FileMode</code></pre>
         </article>
         
         <article class="function" data-name="open">
            <h2>open</h2>
            <hr />
            
            <pre><code>func open(path string, flag int, perm uint32) (int, poll.SysFile, error)</code></pre>
         </article>
         
         <article class="function" data-name="fixLongPath">
            <h2>fixLongPath</h2>
            <hr />
            
            <p>fixLongPath is a noop on non-Windows platforms.</p>
            
            <pre><code>func fixLongPath(path string) string</code></pre>
         </article>
         
         <article class="function" data-name="Fd">
            <h2>Fd</h2>
            <hr />
            
            <p>Fd returns the integer Plan 9 file descriptor referencing the open file.
If f is closed, the file descriptor becomes invalid.
If f is garbage collected, a finalizer may close the file descriptor,
making it invalid; see [runtime.SetFinalizer] for more information on when
a finalizer might be run. On Unix systems this will cause the [File.SetDeadline]
methods to stop working.

As an alternative, see the f.SyscallConn method.</p>
            
            <pre><code>func Fd() uintptr</code></pre>
         </article>
         
         <article class="function" data-name="NewFile">
            <h2>NewFile</h2>
            <hr />
            
            <p>NewFile returns a new File with the given file descriptor and
name. The returned value will be nil if fd is not a valid file
descriptor.</p>
            
            <pre><code>func NewFile(fd uintptr, name string) *File</code></pre>
         </article>
         
         <article class="function" data-name="epipecheck">
            <h2>epipecheck</h2>
            <hr />
            
            <pre><code>func epipecheck(file *File, e error)</code></pre>
         </article>
         
         <article class="function" data-name="syscallMode">
            <h2>syscallMode</h2>
            <hr />
            
            <p>syscallMode returns the syscall-specific mode bits from Go's portable mode bits.</p>
            
            <pre><code>func syscallMode(i FileMode) o uint32</code></pre>
         </article>
         
         <article class="function" data-name="openFileNolog">
            <h2>openFileNolog</h2>
            <hr />
            
            <p>openFileNolog is the Plan 9 implementation of OpenFile.</p>
            
            <pre><code>func openFileNolog(name string, flag int, perm FileMode) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="openDirNolog">
            <h2>openDirNolog</h2>
            <hr />
            
            <pre><code>func openDirNolog(name string) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close closes the File, rendering it unusable for I/O.
On files that support SetDeadline, any pending I/O operations will
be canceled and return immediately with an ErrClosed error.
Close will return an error if it has already been called.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="close">
            <h2>close</h2>
            <hr />
            
            <pre><code>func close() error</code></pre>
         </article>
         
         <article class="function" data-name="destroy">
            <h2>destroy</h2>
            <hr />
            
            <p>destroy actually closes the descriptor. This is called when
there are no remaining references, by the decref, readUnlock,
and writeUnlock methods.</p>
            
            <pre><code>func destroy() error</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <p>Stat returns the FileInfo structure describing file.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Stat() (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Truncate">
            <h2>Truncate</h2>
            <hr />
            
            <p>Truncate changes the size of the file.
It does not change the I/O offset.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Truncate(size int64) error</code></pre>
         </article>
         
         <article class="function" data-name="chmod">
            <h2>chmod</h2>
            <hr />
            
            <pre><code>func chmod(mode FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="Sync">
            <h2>Sync</h2>
            <hr />
            
            <p>Sync commits the current contents of the file to stable storage.
Typically, this means flushing the file system's in-memory copy
of recently written data to disk.</p>
            
            <pre><code>func Sync() error</code></pre>
         </article>
         
         <article class="function" data-name="read">
            <h2>read</h2>
            <hr />
            
            <p>read reads up to len(b) bytes from the File.
It returns the number of bytes read and an error, if any.</p>
            
            <pre><code>func read(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="pread">
            <h2>pread</h2>
            <hr />
            
            <p>pread reads len(b) bytes from the File starting at byte offset off.
It returns the number of bytes read and the error, if any.
EOF is signaled by a zero count with err set to nil.</p>
            
            <pre><code>func pread(b []byte, off int64) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <p>write writes len(b) bytes to the File.
It returns the number of bytes written and an error, if any.
Since Plan 9 preserves message boundaries, never allow
a zero-byte write.</p>
            
            <pre><code>func write(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="pwrite">
            <h2>pwrite</h2>
            <hr />
            
            <p>pwrite writes len(b) bytes to the File starting at byte offset off.
It returns the number of bytes written and an error, if any.
Since Plan 9 preserves message boundaries, never allow
a zero-byte write.</p>
            
            <pre><code>func pwrite(b []byte, off int64) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="seek">
            <h2>seek</h2>
            <hr />
            
            <p>seek sets the offset for the next Read or Write on file to offset, interpreted
according to whence: 0 means relative to the origin of the file, 1 means
relative to the current offset, and 2 means relative to the end.
It returns the new offset and an error, if any.</p>
            
            <pre><code>func seek(offset int64, whence int) (ret int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Truncate">
            <h2>Truncate</h2>
            <hr />
            
            <p>Truncate changes the size of the named file.
If the file is a symbolic link, it changes the size of the link's target.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Truncate(name string, size int64) error</code></pre>
         </article>
         
         <article class="function" data-name="Remove">
            <h2>Remove</h2>
            <hr />
            
            <p>Remove removes the named file or directory.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Remove(name string) error</code></pre>
         </article>
         
         <article class="function" data-name="rename">
            <h2>rename</h2>
            <hr />
            
            <pre><code>func rename(oldname string, newname string) error</code></pre>
         </article>
         
         <article class="function" data-name="chmod">
            <h2>chmod</h2>
            <hr />
            
            <p>See docs in file.go:Chmod.</p>
            
            <pre><code>func chmod(name string, mode FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="Chtimes">
            <h2>Chtimes</h2>
            <hr />
            
            <p>Chtimes changes the access and modification times of the named
file, similar to the Unix utime() or utimes() functions.
A zero time.Time value will leave the corresponding file time unchanged.

The underlying filesystem may truncate or round the values to a
less precise time unit.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Chtimes(name string, atime time.Time, mtime time.Time) error</code></pre>
         </article>
         
         <article class="function" data-name="Pipe">
            <h2>Pipe</h2>
            <hr />
            
            <p>Pipe returns a connected pair of Files; reads from r return bytes
written to w. It returns the files and an error, if any.</p>
            
            <pre><code>func Pipe() (r *File, w *File, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Link">
            <h2>Link</h2>
            <hr />
            
            <p>Link creates newname as a hard link to the oldname file.
If there is an error, it will be of type *LinkError.</p>
            
            <pre><code>func Link(oldname string, newname string) error</code></pre>
         </article>
         
         <article class="function" data-name="Symlink">
            <h2>Symlink</h2>
            <hr />
            
            <p>Symlink creates newname as a symbolic link to oldname.
On Windows, a symlink to a non-existent oldname creates a file symlink;
if oldname is later created as a directory the symlink will not work.
If there is an error, it will be of type *LinkError.</p>
            
            <pre><code>func Symlink(oldname string, newname string) error</code></pre>
         </article>
         
         <article class="function" data-name="readlink">
            <h2>readlink</h2>
            <hr />
            
            <pre><code>func readlink(name string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Chown">
            <h2>Chown</h2>
            <hr />
            
            <p>Chown changes the numeric uid and gid of the named file.
If the file is a symbolic link, it changes the uid and gid of the link's target.
A uid or gid of -1 means to not change that value.
If there is an error, it will be of type *PathError.

On Windows or Plan 9, Chown always returns the syscall.EWINDOWS or
EPLAN9 error, wrapped in *PathError.</p>
            
            <pre><code>func Chown(name string, uid int, gid int) error</code></pre>
         </article>
         
         <article class="function" data-name="Lchown">
            <h2>Lchown</h2>
            <hr />
            
            <p>Lchown changes the numeric uid and gid of the named file.
If the file is a symbolic link, it changes the uid and gid of the link itself.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Lchown(name string, uid int, gid int) error</code></pre>
         </article>
         
         <article class="function" data-name="Chown">
            <h2>Chown</h2>
            <hr />
            
            <p>Chown changes the numeric uid and gid of the named file.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Chown(uid int, gid int) error</code></pre>
         </article>
         
         <article class="function" data-name="tempDir">
            <h2>tempDir</h2>
            <hr />
            
            <pre><code>func tempDir() string</code></pre>
         </article>
         
         <article class="function" data-name="Chdir">
            <h2>Chdir</h2>
            <hr />
            
            <p>Chdir changes the current working directory to the file,
which must be a directory.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Chdir() error</code></pre>
         </article>
         
         <article class="function" data-name="setDeadline">
            <h2>setDeadline</h2>
            <hr />
            
            <p>setDeadline sets the read and write deadline.</p>
            
            <pre><code>func setDeadline(time.Time) error</code></pre>
         </article>
         
         <article class="function" data-name="setReadDeadline">
            <h2>setReadDeadline</h2>
            <hr />
            
            <p>setReadDeadline sets the read deadline.</p>
            
            <pre><code>func setReadDeadline(time.Time) error</code></pre>
         </article>
         
         <article class="function" data-name="setWriteDeadline">
            <h2>setWriteDeadline</h2>
            <hr />
            
            <p>setWriteDeadline sets the write deadline.</p>
            
            <pre><code>func setWriteDeadline(time.Time) error</code></pre>
         </article>
         
         <article class="function" data-name="checkValid">
            <h2>checkValid</h2>
            <hr />
            
            <p>checkValid checks whether f is valid for use, but does not prepare
to actually use it. If f is not ready checkValid returns an appropriate
error, perhaps incorporating the operation name op.</p>
            
            <pre><code>func checkValid(op string) error</code></pre>
         </article>
         
         <article class="function" data-name="Control">
            <h2>Control</h2>
            <hr />
            
            <pre><code>func Control(f func) error</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(f func) error</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(f func) error</code></pre>
         </article>
         
         <article class="function" data-name="newRawConn">
            <h2>newRawConn</h2>
            <hr />
            
            <pre><code>func newRawConn(file *File) (*rawConn, error)</code></pre>
         </article>
         
         <article class="function" data-name="ignoringEINTR">
            <h2>ignoringEINTR</h2>
            <hr />
            
            <pre><code>func ignoringEINTR(fn func) error</code></pre>
         </article>
         
         <article class="function" data-name="ignoringEINTR2">
            <h2>ignoringEINTR2</h2>
            <hr />
            
            <pre><code>func ignoringEINTR2(fn func) (T, error)</code></pre>
         </article>
         
         <article class="function" data-name="Getwd">
            <h2>Getwd</h2>
            <hr />
            
            <p>Getwd returns an absolute path name corresponding to the
current directory. If the current directory can be
reached via multiple paths (due to symbolic links),
Getwd may return any one of them.

On Unix platforms, if the environment variable PWD
provides an absolute name, and it is a name of the
current directory, it is returned.</p>
            
            <pre><code>func Getwd() (dir string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="removeAll">
            <h2>removeAll</h2>
            <hr />
            
            <pre><code>func removeAll(path string) error</code></pre>
         </article>
         
         <article class="function" data-name="removeAllFrom">
            <h2>removeAllFrom</h2>
            <hr />
            
            <pre><code>func removeAllFrom(parent *File, base string) error</code></pre>
         </article>
         
         <article class="function" data-name="openDirAt">
            <h2>openDirAt</h2>
            <hr />
            
            <p>openDirAt opens a directory name relative to the directory referred to by
the file descriptor dirfd. If name is anything but a directory (this
includes a symlink to one), it should return an error. Other than that this
should act like openFileNolog.

This acts like openFileNolog rather than OpenFile because
we are going to (try to) remove the file.
The contents of this file are not relevant for test caching.</p>
            
            <pre><code>func openDirAt(dirfd int, name string) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="startProcess">
            <h2>startProcess</h2>
            <hr />
            
            <pre><code>func startProcess(name string, argv []string, attr *ProcAttr) (p *Process, err error)</code></pre>
         </article>
         
         <article class="function" data-name="writeProcFile">
            <h2>writeProcFile</h2>
            <hr />
            
            <pre><code>func writeProcFile(file string, data string) error</code></pre>
         </article>
         
         <article class="function" data-name="signal">
            <h2>signal</h2>
            <hr />
            
            <pre><code>func signal(sig Signal) error</code></pre>
         </article>
         
         <article class="function" data-name="kill">
            <h2>kill</h2>
            <hr />
            
            <pre><code>func kill() error</code></pre>
         </article>
         
         <article class="function" data-name="wait">
            <h2>wait</h2>
            <hr />
            
            <pre><code>func wait() (ps *ProcessState, err error)</code></pre>
         </article>
         
         <article class="function" data-name="release">
            <h2>release</h2>
            <hr />
            
            <pre><code>func release() error</code></pre>
         </article>
         
         <article class="function" data-name="findProcess">
            <h2>findProcess</h2>
            <hr />
            
            <pre><code>func findProcess(pid int) (p *Process, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Pid">
            <h2>Pid</h2>
            <hr />
            
            <p>Pid returns the process id of the exited process.</p>
            
            <pre><code>func Pid() int</code></pre>
         </article>
         
         <article class="function" data-name="exited">
            <h2>exited</h2>
            <hr />
            
            <pre><code>func exited() bool</code></pre>
         </article>
         
         <article class="function" data-name="success">
            <h2>success</h2>
            <hr />
            
            <pre><code>func success() bool</code></pre>
         </article>
         
         <article class="function" data-name="sys">
            <h2>sys</h2>
            <hr />
            
            <pre><code>func sys() any</code></pre>
         </article>
         
         <article class="function" data-name="sysUsage">
            <h2>sysUsage</h2>
            <hr />
            
            <pre><code>func sysUsage() any</code></pre>
         </article>
         
         <article class="function" data-name="userTime">
            <h2>userTime</h2>
            <hr />
            
            <pre><code>func userTime() time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="systemTime">
            <h2>systemTime</h2>
            <hr />
            
            <pre><code>func systemTime() time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="ExitCode">
            <h2>ExitCode</h2>
            <hr />
            
            <p>ExitCode returns the exit code of the exited process, or -1
if the process hasn't exited or was terminated by a signal.</p>
            
            <pre><code>func ExitCode() int</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="runtime_args">
            <h2>runtime_args</h2>
            <hr />
            
            <pre><code>func runtime_args() []string</code></pre>
         </article>
         
         <article class="function" data-name="Getuid">
            <h2>Getuid</h2>
            <hr />
            
            <p>Getuid returns the numeric user id of the caller.

On Windows, it returns -1.</p>
            
            <pre><code>func Getuid() int</code></pre>
         </article>
         
         <article class="function" data-name="Geteuid">
            <h2>Geteuid</h2>
            <hr />
            
            <p>Geteuid returns the numeric effective user id of the caller.

On Windows, it returns -1.</p>
            
            <pre><code>func Geteuid() int</code></pre>
         </article>
         
         <article class="function" data-name="Getgid">
            <h2>Getgid</h2>
            <hr />
            
            <p>Getgid returns the numeric group id of the caller.

On Windows, it returns -1.</p>
            
            <pre><code>func Getgid() int</code></pre>
         </article>
         
         <article class="function" data-name="Getegid">
            <h2>Getegid</h2>
            <hr />
            
            <p>Getegid returns the numeric effective group id of the caller.

On Windows, it returns -1.</p>
            
            <pre><code>func Getegid() int</code></pre>
         </article>
         
         <article class="function" data-name="Getgroups">
            <h2>Getgroups</h2>
            <hr />
            
            <p>Getgroups returns a list of the numeric ids of groups that the caller belongs to.

On Windows, it returns [syscall.EWINDOWS]. See the [os/user] package
for a possible alternative.</p>
            
            <pre><code>func Getgroups() ([]int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Exit">
            <h2>Exit</h2>
            <hr />
            
            <p>Exit causes the current program to exit with the given status code.
Conventionally, code zero indicates success, non-zero an error.
The program terminates immediately; deferred functions are not run.

For portability, the status code should be in the range [0, 125].</p>
            
            <pre><code>func Exit(code int)</code></pre>
         </article>
         
         <article class="function" data-name="runtime_beforeExit">
            <h2>runtime_beforeExit</h2>
            <hr />
            
            <pre><code>func runtime_beforeExit(exitCode int)</code></pre>
         </article>
         
         <article class="function" data-name="openRootNolog">
            <h2>openRootNolog</h2>
            <hr />
            
            <p>openRootNolog is OpenRoot.</p>
            
            <pre><code>func openRootNolog(name string) (*Root, error)</code></pre>
         </article>
         
         <article class="function" data-name="openRootInRoot">
            <h2>openRootInRoot</h2>
            <hr />
            
            <p>openRootInRoot is Root.OpenRoot.</p>
            
            <pre><code>func openRootInRoot(r *Root, name string) (*Root, error)</code></pre>
         </article>
         
         <article class="function" data-name="newRoot">
            <h2>newRoot</h2>
            <hr />
            
            <p>newRoot returns a new Root.
If fd is not a directory, it closes it and returns an error.</p>
            
            <pre><code>func newRoot(name string) (*Root, error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="rootOpenFileNolog">
            <h2>rootOpenFileNolog</h2>
            <hr />
            
            <p>rootOpenFileNolog is Root.OpenFile.</p>
            
            <pre><code>func rootOpenFileNolog(r *Root, name string, flag int, perm FileMode) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="rootStat">
            <h2>rootStat</h2>
            <hr />
            
            <pre><code>func rootStat(r *Root, name string, lstat bool) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="rootMkdir">
            <h2>rootMkdir</h2>
            <hr />
            
            <pre><code>func rootMkdir(r *Root, name string, perm FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="rootRemove">
            <h2>rootRemove</h2>
            <hr />
            
            <pre><code>func rootRemove(r *Root, name string) error</code></pre>
         </article>
         
         <article class="function" data-name="fillFileStatFromSys">
            <h2>fillFileStatFromSys</h2>
            <hr />
            
            <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
         </article>
         
         <article class="function" data-name="atime">
            <h2>atime</h2>
            <hr />
            
            <p>For testing.</p>
            
            <pre><code>func atime(fi FileInfo) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="fillFileStatFromSys">
            <h2>fillFileStatFromSys</h2>
            <hr />
            
            <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
         </article>
         
         <article class="function" data-name="atime">
            <h2>atime</h2>
            <hr />
            
            <p>For testing.</p>
            
            <pre><code>func atime(fi FileInfo) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(w io.Writer) (written int64, handled bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readFrom">
            <h2>readFrom</h2>
            <hr />
            
            <pre><code>func readFrom(r io.Reader) (n int64, handled bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Readdir">
            <h2>Readdir</h2>
            <hr />
            
            <p>Readdir reads the contents of the directory associated with file and
returns a slice of up to n [FileInfo] values, as would be returned
by [Lstat], in directory order. Subsequent calls on the same file will yield
further FileInfos.

If n > 0, Readdir returns at most n FileInfo structures. In this case, if
Readdir returns an empty slice, it will return a non-nil error
explaining why. At the end of a directory, the error is [io.EOF].

If n <= 0, Readdir returns all the FileInfo from the directory in
a single slice. In this case, if Readdir succeeds (reads all
the way to the end of the directory), it returns the slice and a
nil error. If it encounters an error before the end of the
directory, Readdir returns the FileInfo read until that point
and a non-nil error.

Most clients are better served by the more efficient ReadDir method.</p>
            
            <pre><code>func Readdir(n int) ([]FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Readdirnames">
            <h2>Readdirnames</h2>
            <hr />
            
            <p>Readdirnames reads the contents of the directory associated with file
and returns a slice of up to n names of files in the directory,
in directory order. Subsequent calls on the same file will yield
further names.

If n > 0, Readdirnames returns at most n names. In this case, if
Readdirnames returns an empty slice, it will return a non-nil error
explaining why. At the end of a directory, the error is [io.EOF].

If n <= 0, Readdirnames returns all the names from the directory in
a single slice. In this case, if Readdirnames succeeds (reads all
the way to the end of the directory), it returns the slice and a
nil error. If it encounters an error before the end of the
directory, Readdirnames returns the names read until that point and
a non-nil error.</p>
            
            <pre><code>func Readdirnames(n int) (names []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadDir">
            <h2>ReadDir</h2>
            <hr />
            
            <p>ReadDir reads the contents of the directory associated with the file f
and returns a slice of [DirEntry] values in directory order.
Subsequent calls on the same file will yield later DirEntry records in the directory.

If n > 0, ReadDir returns at most n DirEntry records.
In this case, if ReadDir returns an empty slice, it will return an error explaining why.
At the end of a directory, the error is [io.EOF].

If n <= 0, ReadDir returns all the DirEntry records remaining in the directory.
When it succeeds, it returns a nil error (not io.EOF).</p>
            
            <pre><code>func ReadDir(n int) ([]DirEntry, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadDir">
            <h2>ReadDir</h2>
            <hr />
            
            <p>ReadDir reads the named directory,
returning all its directory entries sorted by filename.
If an error occurs reading the directory,
ReadDir returns the entries it was able to read before the error,
along with the error.</p>
            
            <pre><code>func ReadDir(name string) ([]DirEntry, error)</code></pre>
         </article>
         
         <article class="function" data-name="CopyFS">
            <h2>CopyFS</h2>
            <hr />
            
            <p>CopyFS copies the file system fsys into the directory dir,
creating dir if necessary.

Files are created with mode 0o666 plus any execute permissions
from the source, and directories are created with mode 0o777
(before umask).

CopyFS will not overwrite existing files. If a file name in fsys
already exists in the destination, CopyFS will return an error
such that errors.Is(err, fs.ErrExist) will be true.

Symbolic links in fsys are not supported. A *PathError with Err set
to ErrInvalid is returned when copying from a symbolic link.

Symbolic links in dir are followed.

New files added to fsys (including if dir is a subdirectory of fsys)
while CopyFS is running are not guaranteed to be copied.

Copying stops at and returns the first error encountered.</p>
            
            <pre><code>func CopyFS(dir string, fsys fs.FS) error</code></pre>
         </article>
         
         <article class="function" data-name="close">
            <h2>close</h2>
            <hr />
            
            <pre><code>func close()</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init(h syscall.Handle)</code></pre>
         </article>
         
         <article class="function" data-name="readdir">
            <h2>readdir</h2>
            <hr />
            
            <pre><code>func readdir(n int, mode readdirMode) (names []string, dirents []DirEntry, infos []FileInfo, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="IsDir">
            <h2>IsDir</h2>
            <hr />
            
            <pre><code>func IsDir() bool</code></pre>
         </article>
         
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <pre><code>func Type() FileMode</code></pre>
         </article>
         
         <article class="function" data-name="Info">
            <h2>Info</h2>
            <hr />
            
            <pre><code>func Info() (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="closeHandle">
            <h2>closeHandle</h2>
            <hr />
            
            <pre><code>func closeHandle()</code></pre>
         </article>
         
         <article class="function" data-name="Fd">
            <h2>Fd</h2>
            <hr />
            
            <p>Fd returns the Windows handle referencing the open file.
If f is closed, the file descriptor becomes invalid.
If f is garbage collected, a finalizer may close the file descriptor,
making it invalid; see [runtime.SetFinalizer] for more information on when
a finalizer might be run. On Unix systems this will cause the [File.SetDeadline]
methods to stop working.</p>
            
            <pre><code>func Fd() uintptr</code></pre>
         </article>
         
         <article class="function" data-name="newFile">
            <h2>newFile</h2>
            <hr />
            
            <p>newFile returns a new File with the given file handle and name.
Unlike NewFile, it does not check that h is syscall.InvalidHandle.</p>
            
            <pre><code>func newFile(h syscall.Handle, name string, kind string) *File</code></pre>
         </article>
         
         <article class="function" data-name="newConsoleFile">
            <h2>newConsoleFile</h2>
            <hr />
            
            <p>newConsoleFile creates new File that will be used as console.</p>
            
            <pre><code>func newConsoleFile(h syscall.Handle, name string) *File</code></pre>
         </article>
         
         <article class="function" data-name="NewFile">
            <h2>NewFile</h2>
            <hr />
            
            <p>NewFile returns a new File with the given file descriptor and
name. The returned value will be nil if fd is not a valid file
descriptor.</p>
            
            <pre><code>func NewFile(fd uintptr, name string) *File</code></pre>
         </article>
         
         <article class="function" data-name="epipecheck">
            <h2>epipecheck</h2>
            <hr />
            
            <pre><code>func epipecheck(file *File, e error)</code></pre>
         </article>
         
         <article class="function" data-name="openFileNolog">
            <h2>openFileNolog</h2>
            <hr />
            
            <p>openFileNolog is the Windows implementation of OpenFile.</p>
            
            <pre><code>func openFileNolog(name string, flag int, perm FileMode) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="openDirNolog">
            <h2>openDirNolog</h2>
            <hr />
            
            <pre><code>func openDirNolog(name string) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="close">
            <h2>close</h2>
            <hr />
            
            <pre><code>func close() error</code></pre>
         </article>
         
         <article class="function" data-name="seek">
            <h2>seek</h2>
            <hr />
            
            <p>seek sets the offset for the next Read or Write on file to offset, interpreted
according to whence: 0 means relative to the origin of the file, 1 means
relative to the current offset, and 2 means relative to the end.
It returns the new offset and an error, if any.</p>
            
            <pre><code>func seek(offset int64, whence int) (ret int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Truncate">
            <h2>Truncate</h2>
            <hr />
            
            <p>Truncate changes the size of the named file.
If the file is a symbolic link, it changes the size of the link's target.</p>
            
            <pre><code>func Truncate(name string, size int64) error</code></pre>
         </article>
         
         <article class="function" data-name="Remove">
            <h2>Remove</h2>
            <hr />
            
            <p>Remove removes the named file or directory.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Remove(name string) error</code></pre>
         </article>
         
         <article class="function" data-name="rename">
            <h2>rename</h2>
            <hr />
            
            <pre><code>func rename(oldname string, newname string) error</code></pre>
         </article>
         
         <article class="function" data-name="Pipe">
            <h2>Pipe</h2>
            <hr />
            
            <p>Pipe returns a connected pair of Files; reads from r return bytes written to w.
It returns the files and an error, if any. The Windows handles underlying
the returned files are marked as inheritable by child processes.</p>
            
            <pre><code>func Pipe() (r *File, w *File, err error)</code></pre>
         </article>
         
         <article class="function" data-name="tempDir">
            <h2>tempDir</h2>
            <hr />
            
            <pre><code>func tempDir() string</code></pre>
         </article>
         
         <article class="function" data-name="Link">
            <h2>Link</h2>
            <hr />
            
            <p>Link creates newname as a hard link to the oldname file.
If there is an error, it will be of type *LinkError.</p>
            
            <pre><code>func Link(oldname string, newname string) error</code></pre>
         </article>
         
         <article class="function" data-name="Symlink">
            <h2>Symlink</h2>
            <hr />
            
            <p>Symlink creates newname as a symbolic link to oldname.
On Windows, a symlink to a non-existent oldname creates a file symlink;
if oldname is later created as a directory the symlink will not work.
If there is an error, it will be of type *LinkError.</p>
            
            <pre><code>func Symlink(oldname string, newname string) error</code></pre>
         </article>
         
         <article class="function" data-name="openSymlink">
            <h2>openSymlink</h2>
            <hr />
            
            <p>openSymlink calls CreateFile Windows API with FILE_FLAG_OPEN_REPARSE_POINT
parameter, so that Windows does not follow symlink, if path is a symlink.
openSymlink returns opened file handle.</p>
            
            <pre><code>func openSymlink(path string) (syscall.Handle, error)</code></pre>
         </article>
         
         <article class="function" data-name="normaliseLinkPath">
            <h2>normaliseLinkPath</h2>
            <hr />
            
            <p>normaliseLinkPath converts absolute paths returned by
DeviceIoControl(h, FSCTL_GET_REPARSE_POINT, ...)
into paths acceptable by all Windows APIs.
For example, it converts

	\??\C:\foo\bar into C:\foo\bar
	\??\UNC\foo\bar into \\foo\bar
	\??\Volume{abc}\ into \\?\Volume{abc}\</p>
            
            <pre><code>func normaliseLinkPath(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="readReparseLink">
            <h2>readReparseLink</h2>
            <hr />
            
            <pre><code>func readReparseLink(path string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="readReparseLinkHandle">
            <h2>readReparseLinkHandle</h2>
            <hr />
            
            <pre><code>func readReparseLinkHandle(h syscall.Handle) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="readlink">
            <h2>readlink</h2>
            <hr />
            
            <pre><code>func readlink(name string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="hostname">
            <h2>hostname</h2>
            <hr />
            
            <pre><code>func hostname() (name string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="wait6">
            <h2>wait6</h2>
            <hr />
            
            <pre><code>func wait6(idtype int, id int, options int) (status int, errno syscall.Errno)</code></pre>
         </article>
         
         <article class="function" data-name="errNoDeadline">
            <h2>errNoDeadline</h2>
            <hr />
            
            <pre><code>func errNoDeadline() error</code></pre>
         </article>
         
         <article class="function" data-name="errDeadlineExceeded">
            <h2>errDeadlineExceeded</h2>
            <hr />
            
            <p>errDeadlineExceeded returns the value for os.ErrDeadlineExceeded.
This error comes from the internal/poll package, which is also
used by package net. Doing it this way ensures that the net
package will return os.ErrDeadlineExceeded for an exceeded deadline,
as documented by net.Conn.SetDeadline, without requiring any extra
work in the net package and without requiring the internal/poll
package to import os (which it can't, because that would be circular).</p>
            
            <pre><code>func errDeadlineExceeded() error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="Timeout">
            <h2>Timeout</h2>
            <hr />
            
            <p>Timeout reports whether this error represents a timeout.</p>
            
            <pre><code>func Timeout() bool</code></pre>
         </article>
         
         <article class="function" data-name="NewSyscallError">
            <h2>NewSyscallError</h2>
            <hr />
            
            <p>NewSyscallError returns, as an error, a new [SyscallError]
with the given system call name and error details.
As a convenience, if err is nil, NewSyscallError returns nil.</p>
            
            <pre><code>func NewSyscallError(syscall string, err error) error</code></pre>
         </article>
         
         <article class="function" data-name="IsExist">
            <h2>IsExist</h2>
            <hr />
            
            <p>IsExist returns a boolean indicating whether its argument is known to report
that a file or directory already exists. It is satisfied by [ErrExist] as
well as some syscall errors.

This function predates [errors.Is]. It only supports errors returned by
the os package. New code should use errors.Is(err, fs.ErrExist).</p>
            
            <pre><code>func IsExist(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsNotExist">
            <h2>IsNotExist</h2>
            <hr />
            
            <p>IsNotExist returns a boolean indicating whether its argument is known to
report that a file or directory does not exist. It is satisfied by
[ErrNotExist] as well as some syscall errors.

This function predates [errors.Is]. It only supports errors returned by
the os package. New code should use errors.Is(err, fs.ErrNotExist).</p>
            
            <pre><code>func IsNotExist(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsPermission">
            <h2>IsPermission</h2>
            <hr />
            
            <p>IsPermission returns a boolean indicating whether its argument is known to
report that permission is denied. It is satisfied by [ErrPermission] as well
as some syscall errors.

This function predates [errors.Is]. It only supports errors returned by
the os package. New code should use errors.Is(err, fs.ErrPermission).</p>
            
            <pre><code>func IsPermission(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsTimeout">
            <h2>IsTimeout</h2>
            <hr />
            
            <p>IsTimeout returns a boolean indicating whether its argument is known
to report that a timeout occurred.

This function predates [errors.Is], and the notion of whether an
error indicates a timeout can be ambiguous. For example, the Unix
error EWOULDBLOCK sometimes indicates a timeout and sometimes does not.
New code should use errors.Is with a value appropriate to the call
returning the error, such as [os.ErrDeadlineExceeded].</p>
            
            <pre><code>func IsTimeout(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="underlyingErrorIs">
            <h2>underlyingErrorIs</h2>
            <hr />
            
            <pre><code>func underlyingErrorIs(err error, target error) bool</code></pre>
         </article>
         
         <article class="function" data-name="underlyingError">
            <h2>underlyingError</h2>
            <hr />
            
            <p>underlyingError returns the underlying error for known os error types.</p>
            
            <pre><code>func underlyingError(err error) error</code></pre>
         </article>
         
         <article class="function" data-name="incref">
            <h2>incref</h2>
            <hr />
            
            <p>incref adds a reference to the file. It returns an error if the file
is already closed. This method is on File so that we can incorporate
a nil test.</p>
            
            <pre><code>func incref(op string) err error</code></pre>
         </article>
         
         <article class="function" data-name="decref">
            <h2>decref</h2>
            <hr />
            
            <p>decref removes a reference to the file. If this is the last
remaining reference, and the file has been marked to be closed,
then actually close it.</p>
            
            <pre><code>func decref() error</code></pre>
         </article>
         
         <article class="function" data-name="readLock">
            <h2>readLock</h2>
            <hr />
            
            <p>readLock adds a reference to the file and locks it for reading.
It returns an error if the file is already closed.</p>
            
            <pre><code>func readLock() error</code></pre>
         </article>
         
         <article class="function" data-name="readUnlock">
            <h2>readUnlock</h2>
            <hr />
            
            <p>readUnlock removes a reference from the file and unlocks it for reading.
It also closes the file if it marked as closed and there is no remaining
reference.</p>
            
            <pre><code>func readUnlock()</code></pre>
         </article>
         
         <article class="function" data-name="writeLock">
            <h2>writeLock</h2>
            <hr />
            
            <p>writeLock adds a reference to the file and locks it for writing.
It returns an error if the file is already closed.</p>
            
            <pre><code>func writeLock() error</code></pre>
         </article>
         
         <article class="function" data-name="writeUnlock">
            <h2>writeUnlock</h2>
            <hr />
            
            <p>writeUnlock removes a reference from the file and unlocks it for writing.
It also closes the file if it is marked as closed and there is no remaining
reference.</p>
            
            <pre><code>func writeUnlock()</code></pre>
         </article>
         
         <article class="function" data-name="OpenInRoot">
            <h2>OpenInRoot</h2>
            <hr />
            
            <p>OpenInRoot opens the file name in the directory dir.
It is equivalent to OpenRoot(dir) followed by opening the file in the root.

OpenInRoot returns an error if any component of the name
references a location outside of dir.

See [Root] for details and limitations.</p>
            
            <pre><code>func OpenInRoot(dir string, name string) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="OpenRoot">
            <h2>OpenRoot</h2>
            <hr />
            
            <p>OpenRoot opens the named directory.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func OpenRoot(name string) (*Root, error)</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <p>Name returns the name of the directory presented to OpenRoot.

It is safe to call Name after [Close].</p>
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close closes the Root.
After Close is called, methods on Root return errors.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <p>Open opens the named file in the root for reading.
See [Open] for more details.</p>
            
            <pre><code>func Open(name string) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="Create">
            <h2>Create</h2>
            <hr />
            
            <p>Create creates or truncates the named file in the root.
See [Create] for more details.</p>
            
            <pre><code>func Create(name string) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="OpenFile">
            <h2>OpenFile</h2>
            <hr />
            
            <p>OpenFile opens the named file in the root.
See [OpenFile] for more details.

If perm contains bits other than the nine least-significant bits (0o777),
OpenFile returns an error.</p>
            
            <pre><code>func OpenFile(name string, flag int, perm FileMode) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="OpenRoot">
            <h2>OpenRoot</h2>
            <hr />
            
            <p>OpenRoot opens the named directory in the root.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func OpenRoot(name string) (*Root, error)</code></pre>
         </article>
         
         <article class="function" data-name="Mkdir">
            <h2>Mkdir</h2>
            <hr />
            
            <p>Mkdir creates a new directory in the root
with the specified name and permission bits (before umask).
See [Mkdir] for more details.

If perm contains bits other than the nine least-significant bits (0o777),
OpenFile returns an error.</p>
            
            <pre><code>func Mkdir(name string, perm FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="Remove">
            <h2>Remove</h2>
            <hr />
            
            <p>Remove removes the named file or (empty) directory in the root.
See [Remove] for more details.</p>
            
            <pre><code>func Remove(name string) error</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <p>Stat returns a [FileInfo] describing the named file in the root.
See [Stat] for more details.</p>
            
            <pre><code>func Stat(name string) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Lstat">
            <h2>Lstat</h2>
            <hr />
            
            <p>Lstat returns a [FileInfo] describing the named file in the root.
If the file is a symbolic link, the returned FileInfo
describes the symbolic link.
See [Lstat] for more details.</p>
            
            <pre><code>func Lstat(name string) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="logOpen">
            <h2>logOpen</h2>
            <hr />
            
            <pre><code>func logOpen(name string)</code></pre>
         </article>
         
         <article class="function" data-name="logStat">
            <h2>logStat</h2>
            <hr />
            
            <pre><code>func logStat(name string)</code></pre>
         </article>
         
         <article class="function" data-name="splitPathInRoot">
            <h2>splitPathInRoot</h2>
            <hr />
            
            <p>splitPathInRoot splits a path into components
and joins it with the given prefix and suffix.

The path is relative to a Root, and must not be
absolute, volume-relative, or "".

"." components are removed, except in the last component.

Path separators following the last component are returned in suffixSep.</p>
            
            <pre><code>func splitPathInRoot(s string, prefix []string, suffix []string) (_ []string, suffixSep string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="FS">
            <h2>FS</h2>
            <hr />
            
            <p>FS returns a file system (an fs.FS) for the tree of files in the root.

The result implements [io/fs.StatFS], [io/fs.ReadFileFS] and
[io/fs.ReadDirFS].</p>
            
            <pre><code>func FS() fs.FS</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <pre><code>func Open(name string) (fs.File, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadDir">
            <h2>ReadDir</h2>
            <hr />
            
            <pre><code>func ReadDir(name string) ([]DirEntry, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadFile">
            <h2>ReadFile</h2>
            <hr />
            
            <pre><code>func ReadFile(name string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <pre><code>func Stat(name string) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="isValidRootFSPath">
            <h2>isValidRootFSPath</h2>
            <hr />
            
            <p>isValidRootFSPath reprots whether name is a valid filename to pass a Root.FS method.</p>
            
            <pre><code>func isValidRootFSPath(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="Executable">
            <h2>Executable</h2>
            <hr />
            
            <p>Executable returns the path name for the executable that started
the current process. There is no guarantee that the path is still
pointing to the correct executable. If a symlink was used to start
the process, depending on the operating system, the result might
be the symlink or the path it pointed to. If a stable result is
needed, [path/filepath.EvalSymlinks] might help.

Executable returns an absolute path unless an error occurred.

The main use case is finding resources located relative to an
executable.</p>
            
            <pre><code>func Executable() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="executable">
            <h2>executable</h2>
            <hr />
            
            <pre><code>func executable() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="isExecutable">
            <h2>isExecutable</h2>
            <hr />
            
            <p>isExecutable returns an error if a given file is not an executable.</p>
            
            <pre><code>func isExecutable(path string) error</code></pre>
         </article>
         
         <article class="function" data-name="splitPathList">
            <h2>splitPathList</h2>
            <hr />
            
            <p>splitPathList splits a path list.
This is based on genSplit from strings/strings.go</p>
            
            <pre><code>func splitPathList(pathList string) []string</code></pre>
         </article>
         
         <article class="function" data-name="PollFD">
            <h2>PollFD</h2>
            <hr />
            
            <p>PollFD returns the poll.FD of the file.

Other packages in std that also import internal/poll (such as net)
can use a type assertion to access this extension method so that
they can pass the *poll.FD to functions like poll.Splice.

There is an equivalent function in net.rawConn.

PollFD is not intended for use outside the standard library.</p>
            
            <pre><code>func PollFD() *poll.FD</code></pre>
         </article>
         
         <article class="function" data-name="ensurePidfd">
            <h2>ensurePidfd</h2>
            <hr />
            
            <pre><code>func ensurePidfd(sysAttr *syscall.SysProcAttr) (*syscall.SysProcAttr, bool)</code></pre>
         </article>
         
         <article class="function" data-name="getPidfd">
            <h2>getPidfd</h2>
            <hr />
            
            <pre><code>func getPidfd(_ *syscall.SysProcAttr, _ bool) (uintptr, bool)</code></pre>
         </article>
         
         <article class="function" data-name="pidfdFind">
            <h2>pidfdFind</h2>
            <hr />
            
            <pre><code>func pidfdFind(_ int) (uintptr, error)</code></pre>
         </article>
         
         <article class="function" data-name="pidfdWait">
            <h2>pidfdWait</h2>
            <hr />
            
            <pre><code>func pidfdWait() (*ProcessState, error)</code></pre>
         </article>
         
         <article class="function" data-name="pidfdSendSignal">
            <h2>pidfdSendSignal</h2>
            <hr />
            
            <pre><code>func pidfdSendSignal(_ syscall.Signal) error</code></pre>
         </article>
         
         <article class="function" data-name="checkPathEscapes">
            <h2>checkPathEscapes</h2>
            <hr />
            
            <pre><code>func checkPathEscapes(r *Root, name string) error</code></pre>
         </article>
         
         <article class="function" data-name="checkPathEscapesLstat">
            <h2>checkPathEscapesLstat</h2>
            <hr />
            
            <pre><code>func checkPathEscapesLstat(r *Root, name string) error</code></pre>
         </article>
         
         <article class="function" data-name="rootCleanPath">
            <h2>rootCleanPath</h2>
            <hr />
            
            <p>rootCleanPath uses GetFullPathName to perform lexical path cleaning.

On Windows, file names are lexically cleaned at the start of a file operation.
For example, on Windows the path `a\..\b` is exactly equivalent to `b` alone,
even if `a` does not exist or is not a directory.

We use the Windows API function GetFullPathName to perform this cleaning.
We could do this ourselves, but there are a number of subtle behaviors here,
and deferring to the OS maintains consistency.
(For example, `a\.\` cleans to `a\`.)

GetFullPathName operates on absolute paths, and our input path is relative.
We make the path absolute by prepending a fixed prefix of \\?\?\.

We want to detect paths which use .. components to escape the root.
We do this by ensuring the cleaned path still begins with \\?\?\.
We catch the corner case of a path which includes a ..\?\. component
by rejecting any input paths which contain a ?, which is not a valid character
in a Windows filename.</p>
            
            <pre><code>func rootCleanPath(s string, prefix []string, suffix []string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="openRootNolog">
            <h2>openRootNolog</h2>
            <hr />
            
            <p>openRootNolog is OpenRoot.</p>
            
            <pre><code>func openRootNolog(name string) (*Root, error)</code></pre>
         </article>
         
         <article class="function" data-name="newRoot">
            <h2>newRoot</h2>
            <hr />
            
            <p>newRoot returns a new Root.
If fd is not a directory, it closes it and returns an error.</p>
            
            <pre><code>func newRoot(fd syscall.Handle, name string) (*Root, error)</code></pre>
         </article>
         
         <article class="function" data-name="openRootInRoot">
            <h2>openRootInRoot</h2>
            <hr />
            
            <p>openRootInRoot is Root.OpenRoot.</p>
            
            <pre><code>func openRootInRoot(r *Root, name string) (*Root, error)</code></pre>
         </article>
         
         <article class="function" data-name="rootOpenFileNolog">
            <h2>rootOpenFileNolog</h2>
            <hr />
            
            <p>rootOpenFileNolog is Root.OpenFile.</p>
            
            <pre><code>func rootOpenFileNolog(root *Root, name string, flag int, perm FileMode) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="openat">
            <h2>openat</h2>
            <hr />
            
            <pre><code>func openat(dirfd syscall.Handle, name string, flag int, perm FileMode) (syscall.Handle, error)</code></pre>
         </article>
         
         <article class="function" data-name="readReparseLinkAt">
            <h2>readReparseLinkAt</h2>
            <hr />
            
            <pre><code>func readReparseLinkAt(dirfd syscall.Handle, name string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="rootOpenDir">
            <h2>rootOpenDir</h2>
            <hr />
            
            <pre><code>func rootOpenDir(parent syscall.Handle, name string) (syscall.Handle, error)</code></pre>
         </article>
         
         <article class="function" data-name="rootStat">
            <h2>rootStat</h2>
            <hr />
            
            <pre><code>func rootStat(r *Root, name string, lstat bool) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="mkdirat">
            <h2>mkdirat</h2>
            <hr />
            
            <pre><code>func mkdirat(dirfd syscall.Handle, name string, perm FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="removeat">
            <h2>removeat</h2>
            <hr />
            
            <pre><code>func removeat(dirfd syscall.Handle, name string) error</code></pre>
         </article>
         
         <article class="function" data-name="fileInfoFromStat">
            <h2>fileInfoFromStat</h2>
            <hr />
            
            <pre><code>func fileInfoFromStat(d *syscall.Dir) *fileStat</code></pre>
         </article>
         
         <article class="function" data-name="dirstat">
            <h2>dirstat</h2>
            <hr />
            
            <p>arg is an open *File or a path string.</p>
            
            <pre><code>func dirstat(arg any) (*syscall.Dir, error)</code></pre>
         </article>
         
         <article class="function" data-name="statNolog">
            <h2>statNolog</h2>
            <hr />
            
            <p>statNolog implements Stat for Plan 9.</p>
            
            <pre><code>func statNolog(name string) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="lstatNolog">
            <h2>lstatNolog</h2>
            <hr />
            
            <p>lstatNolog implements Lstat for Plan 9.</p>
            
            <pre><code>func lstatNolog(name string) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="atime">
            <h2>atime</h2>
            <hr />
            
            <p>For testing.</p>
            
            <pre><code>func atime(fi FileInfo) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="close">
            <h2>close</h2>
            <hr />
            
            <pre><code>func close()</code></pre>
         </article>
         
         <article class="function" data-name="readdir">
            <h2>readdir</h2>
            <hr />
            
            <pre><code>func readdir(n int, mode readdirMode) (names []string, dirents []DirEntry, infos []FileInfo, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readInt">
            <h2>readInt</h2>
            <hr />
            
            <p>readInt returns the size-bytes unsigned integer in native byte order at offset off.</p>
            
            <pre><code>func readInt(b []byte, off uintptr, size uintptr) (u uint64, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="readIntBE">
            <h2>readIntBE</h2>
            <hr />
            
            <pre><code>func readIntBE(b []byte, size uintptr) uint64</code></pre>
         </article>
         
         <article class="function" data-name="readIntLE">
            <h2>readIntLE</h2>
            <hr />
            
            <pre><code>func readIntLE(b []byte, size uintptr) uint64</code></pre>
         </article>
         
         <article class="function" data-name="direntIno">
            <h2>direntIno</h2>
            <hr />
            
            <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntReclen">
            <h2>direntReclen</h2>
            <hr />
            
            <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntNamlen">
            <h2>direntNamlen</h2>
            <hr />
            
            <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntType">
            <h2>direntType</h2>
            <hr />
            
            <pre><code>func direntType(buf []byte) FileMode</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <p>Stat returns the [FileInfo] structure describing file.
If there is an error, it will be of type [*PathError].</p>
            
            <pre><code>func Stat() (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="statNolog">
            <h2>statNolog</h2>
            <hr />
            
            <p>statNolog stats a file with no test logging.</p>
            
            <pre><code>func statNolog(name string) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="lstatNolog">
            <h2>lstatNolog</h2>
            <hr />
            
            <p>lstatNolog lstats a file with no test logging.</p>
            
            <pre><code>func lstatNolog(name string) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="isNoFollowErr">
            <h2>isNoFollowErr</h2>
            <hr />
            
            <p>isNoFollowErr reports whether err may result from O_NOFOLLOW blocking an open operation.</p>
            
            <pre><code>func isNoFollowErr(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="openRootNolog">
            <h2>openRootNolog</h2>
            <hr />
            
            <p>openRootNolog is OpenRoot.</p>
            
            <pre><code>func openRootNolog(name string) (*Root, error)</code></pre>
         </article>
         
         <article class="function" data-name="newRoot">
            <h2>newRoot</h2>
            <hr />
            
            <p>newRoot returns a new Root.
If fd is not a directory, it closes it and returns an error.</p>
            
            <pre><code>func newRoot(fd int, name string) (*Root, error)</code></pre>
         </article>
         
         <article class="function" data-name="openRootInRoot">
            <h2>openRootInRoot</h2>
            <hr />
            
            <p>openRootInRoot is Root.OpenRoot.</p>
            
            <pre><code>func openRootInRoot(r *Root, name string) (*Root, error)</code></pre>
         </article>
         
         <article class="function" data-name="rootOpenFileNolog">
            <h2>rootOpenFileNolog</h2>
            <hr />
            
            <p>rootOpenFileNolog is Root.OpenFile.</p>
            
            <pre><code>func rootOpenFileNolog(root *Root, name string, flag int, perm FileMode) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="rootOpenDir">
            <h2>rootOpenDir</h2>
            <hr />
            
            <pre><code>func rootOpenDir(parent int, name string) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="rootStat">
            <h2>rootStat</h2>
            <hr />
            
            <pre><code>func rootStat(r *Root, name string, lstat bool) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="mkdirat">
            <h2>mkdirat</h2>
            <hr />
            
            <pre><code>func mkdirat(fd int, name string, perm FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="removeat">
            <h2>removeat</h2>
            <hr />
            
            <pre><code>func removeat(fd int, name string) error</code></pre>
         </article>
         
         <article class="function" data-name="checkSymlink">
            <h2>checkSymlink</h2>
            <hr />
            
            <p>checkSymlink resolves the symlink name in parent,
and returns errSymlink with the link contents.

If name is not a symlink, return origError.</p>
            
            <pre><code>func checkSymlink(parent int, name string, origError error) error</code></pre>
         </article>
         
         <article class="function" data-name="readlinkat">
            <h2>readlinkat</h2>
            <hr />
            
            <pre><code>func readlinkat(fd int, name string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="fillFileStatFromSys">
            <h2>fillFileStatFromSys</h2>
            <hr />
            
            <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
         </article>
         
         <article class="function" data-name="atime">
            <h2>atime</h2>
            <hr />
            
            <p>For testing.</p>
            
            <pre><code>func atime(fi FileInfo) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="fillFileStatFromSys">
            <h2>fillFileStatFromSys</h2>
            <hr />
            
            <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
         </article>
         
         <article class="function" data-name="atime">
            <h2>atime</h2>
            <hr />
            
            <p>For testing.</p>
            
            <pre><code>func atime(fi FileInfo) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="direntIno">
            <h2>direntIno</h2>
            <hr />
            
            <pre><code>func direntIno(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntReclen">
            <h2>direntReclen</h2>
            <hr />
            
            <pre><code>func direntReclen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntNamlen">
            <h2>direntNamlen</h2>
            <hr />
            
            <pre><code>func direntNamlen(buf []byte) (uint64, bool)</code></pre>
         </article>
         
         <article class="function" data-name="direntType">
            <h2>direntType</h2>
            <hr />
            
            <pre><code>func direntType(buf []byte) FileMode</code></pre>
         </article>
         
         <article class="function" data-name="ensurePidfd">
            <h2>ensurePidfd</h2>
            <hr />
            
            <p>ensurePidfd initializes the PidFD field in sysAttr if it is not already set.
It returns the original or modified SysProcAttr struct and a flag indicating
whether the PidFD should be duplicated before using.</p>
            
            <pre><code>func ensurePidfd(sysAttr *syscall.SysProcAttr) (*syscall.SysProcAttr, bool)</code></pre>
         </article>
         
         <article class="function" data-name="getPidfd">
            <h2>getPidfd</h2>
            <hr />
            
            <p>getPidfd returns the value of sysAttr.PidFD (or its duplicate if needDup is
set) and a flag indicating whether the value can be used.</p>
            
            <pre><code>func getPidfd(sysAttr *syscall.SysProcAttr, needDup bool) (uintptr, bool)</code></pre>
         </article>
         
         <article class="function" data-name="pidfdFind">
            <h2>pidfdFind</h2>
            <hr />
            
            <pre><code>func pidfdFind(pid int) (uintptr, error)</code></pre>
         </article>
         
         <article class="function" data-name="pidfdWait">
            <h2>pidfdWait</h2>
            <hr />
            
            <pre><code>func pidfdWait() (*ProcessState, error)</code></pre>
         </article>
         
         <article class="function" data-name="pidfdSendSignal">
            <h2>pidfdSendSignal</h2>
            <hr />
            
            <pre><code>func pidfdSendSignal(s syscall.Signal) error</code></pre>
         </article>
         
         <article class="function" data-name="pidfdWorks">
            <h2>pidfdWorks</h2>
            <hr />
            
            <pre><code>func pidfdWorks() bool</code></pre>
         </article>
         
         <article class="function" data-name="checkPidfd">
            <h2>checkPidfd</h2>
            <hr />
            
            <p>checkPidfd checks whether all required pidfd-related syscalls work. This
consists of pidfd_open and pidfd_send_signal syscalls, waitid syscall with
idtype of P_PIDFD, and clone(CLONE_PIDFD).

Reasons for non-working pidfd syscalls include an older kernel and an
execution environment in which the above system calls are restricted by
seccomp or a similar technology.</p>
            
            <pre><code>func checkPidfd() error</code></pre>
         </article>
         
         <article class="function" data-name="checkClonePidfd">
            <h2>checkClonePidfd</h2>
            <hr />
            
            <p>Provided by syscall.</p>
            
            <pre><code>func checkClonePidfd() error</code></pre>
         </article>
         
         <article class="function" data-name="ignoreSIGSYS">
            <h2>ignoreSIGSYS</h2>
            <hr />
            
            <p>Provided by runtime.</p>
            
            <pre><code>func ignoreSIGSYS()</code></pre>
         </article>
         
         <article class="function" data-name="restoreSIGSYS">
            <h2>restoreSIGSYS</h2>
            <hr />
            
            <pre><code>func restoreSIGSYS()</code></pre>
         </article>
         
         <article class="function" data-name="fillFileStatFromSys">
            <h2>fillFileStatFromSys</h2>
            <hr />
            
            <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
         </article>
         
         <article class="function" data-name="atime">
            <h2>atime</h2>
            <hr />
            
            <p>For testing.</p>
            
            <pre><code>func atime(fi FileInfo) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="wait6">
            <h2>wait6</h2>
            <hr />
            
            <pre><code>func wait6(idtype int, id int, options int) (status int, errno syscall.Errno)</code></pre>
         </article>
         
         <article class="function" data-name="wait">
            <h2>wait</h2>
            <hr />
            
            <pre><code>func wait() (ps *ProcessState, err error)</code></pre>
         </article>
         
         <article class="function" data-name="signal">
            <h2>signal</h2>
            <hr />
            
            <pre><code>func signal(sig Signal) error</code></pre>
         </article>
         
         <article class="function" data-name="release">
            <h2>release</h2>
            <hr />
            
            <pre><code>func release() error</code></pre>
         </article>
         
         <article class="function" data-name="closeHandle">
            <h2>closeHandle</h2>
            <hr />
            
            <pre><code>func closeHandle()</code></pre>
         </article>
         
         <article class="function" data-name="findProcess">
            <h2>findProcess</h2>
            <hr />
            
            <pre><code>func findProcess(pid int) (p *Process, err error)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="appendBSBytes">
            <h2>appendBSBytes</h2>
            <hr />
            
            <p>appendBSBytes appends n '\\' bytes to b and returns the resulting slice.</p>
            
            <pre><code>func appendBSBytes(b []byte, n int) []byte</code></pre>
         </article>
         
         <article class="function" data-name="readNextArg">
            <h2>readNextArg</h2>
            <hr />
            
            <p>readNextArg splits command line string cmd into next
argument and command line remainder.</p>
            
            <pre><code>func readNextArg(cmd string) (arg []byte, rest string)</code></pre>
         </article>
         
         <article class="function" data-name="commandLineToArgv">
            <h2>commandLineToArgv</h2>
            <hr />
            
            <p>commandLineToArgv splits a command line into individual argument
strings, following the Windows conventions documented
at http://daviddeley.com/autohotkey/parameters/parameters.htm#WINARGV</p>
            
            <pre><code>func commandLineToArgv(cmd string) []string</code></pre>
         </article>
         
         <article class="function" data-name="ftToDuration">
            <h2>ftToDuration</h2>
            <hr />
            
            <pre><code>func ftToDuration(ft *syscall.Filetime) time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="userTime">
            <h2>userTime</h2>
            <hr />
            
            <pre><code>func userTime() time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="systemTime">
            <h2>systemTime</h2>
            <hr />
            
            <pre><code>func systemTime() time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <p>Stat returns a [FileInfo] describing the named file.
If there is an error, it will be of type [*PathError].</p>
            
            <pre><code>func Stat(name string) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Lstat">
            <h2>Lstat</h2>
            <hr />
            
            <p>Lstat returns a [FileInfo] describing the named file.
If the file is a symbolic link, the returned FileInfo
describes the symbolic link. Lstat makes no attempt to follow the link.
If there is an error, it will be of type [*PathError].

On Windows, if the file is a reparse point that is a surrogate for another
named entity (such as a symbolic link or mounted folder), the returned
FileInfo describes the reparse point, and makes no attempt to resolve it.</p>
            
            <pre><code>func Lstat(name string) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Expand">
            <h2>Expand</h2>
            <hr />
            
            <p>Expand replaces ${var} or $var in the string based on the mapping function.
For example, [os.ExpandEnv](s) is equivalent to [os.Expand](s, [os.Getenv]).</p>
            
            <pre><code>func Expand(s string, mapping func) string</code></pre>
         </article>
         
         <article class="function" data-name="ExpandEnv">
            <h2>ExpandEnv</h2>
            <hr />
            
            <p>ExpandEnv replaces ${var} or $var in the string according to the values
of the current environment variables. References to undefined
variables are replaced by the empty string.</p>
            
            <pre><code>func ExpandEnv(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="isShellSpecialVar">
            <h2>isShellSpecialVar</h2>
            <hr />
            
            <p>isShellSpecialVar reports whether the character identifies a special
shell variable such as $*.</p>
            
            <pre><code>func isShellSpecialVar(c uint8) bool</code></pre>
         </article>
         
         <article class="function" data-name="isAlphaNum">
            <h2>isAlphaNum</h2>
            <hr />
            
            <p>isAlphaNum reports whether the byte is an ASCII letter, number, or underscore.</p>
            
            <pre><code>func isAlphaNum(c uint8) bool</code></pre>
         </article>
         
         <article class="function" data-name="getShellName">
            <h2>getShellName</h2>
            <hr />
            
            <p>getShellName returns the name that begins the string and the number of bytes
consumed to extract it. If the name is enclosed in {}, it's part of a ${}
expansion and two more bytes are needed than the length of the name.</p>
            
            <pre><code>func getShellName(s string) (string, int)</code></pre>
         </article>
         
         <article class="function" data-name="Getenv">
            <h2>Getenv</h2>
            <hr />
            
            <p>Getenv retrieves the value of the environment variable named by the key.
It returns the value, which will be empty if the variable is not present.
To distinguish between an empty value and an unset value, use [LookupEnv].</p>
            
            <pre><code>func Getenv(key string) string</code></pre>
         </article>
         
         <article class="function" data-name="LookupEnv">
            <h2>LookupEnv</h2>
            <hr />
            
            <p>LookupEnv retrieves the value of the environment variable named
by the key. If the variable is present in the environment the
value (which may be empty) is returned and the boolean is true.
Otherwise the returned value will be empty and the boolean will
be false.</p>
            
            <pre><code>func LookupEnv(key string) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="Setenv">
            <h2>Setenv</h2>
            <hr />
            
            <p>Setenv sets the value of the environment variable named by the key.
It returns an error, if any.</p>
            
            <pre><code>func Setenv(key string, value string) error</code></pre>
         </article>
         
         <article class="function" data-name="Unsetenv">
            <h2>Unsetenv</h2>
            <hr />
            
            <p>Unsetenv unsets a single environment variable.</p>
            
            <pre><code>func Unsetenv(key string) error</code></pre>
         </article>
         
         <article class="function" data-name="Clearenv">
            <h2>Clearenv</h2>
            <hr />
            
            <p>Clearenv deletes all environment variables.</p>
            
            <pre><code>func Clearenv()</code></pre>
         </article>
         
         <article class="function" data-name="Environ">
            <h2>Environ</h2>
            <hr />
            
            <p>Environ returns a copy of strings representing the environment,
in the form "key=value".</p>
            
            <pre><code>func Environ() []string</code></pre>
         </article>
         
         <article class="function" data-name="newPIDProcess">
            <h2>newPIDProcess</h2>
            <hr />
            
            <pre><code>func newPIDProcess(pid int) *Process</code></pre>
         </article>
         
         <article class="function" data-name="newHandleProcess">
            <h2>newHandleProcess</h2>
            <hr />
            
            <pre><code>func newHandleProcess(pid int, handle uintptr) *Process</code></pre>
         </article>
         
         <article class="function" data-name="newDoneProcess">
            <h2>newDoneProcess</h2>
            <hr />
            
            <pre><code>func newDoneProcess(pid int) *Process</code></pre>
         </article>
         
         <article class="function" data-name="handleTransientAcquire">
            <h2>handleTransientAcquire</h2>
            <hr />
            
            <pre><code>func handleTransientAcquire() (uintptr, processStatus)</code></pre>
         </article>
         
         <article class="function" data-name="handleTransientRelease">
            <h2>handleTransientRelease</h2>
            <hr />
            
            <pre><code>func handleTransientRelease()</code></pre>
         </article>
         
         <article class="function" data-name="handlePersistentRelease">
            <h2>handlePersistentRelease</h2>
            <hr />
            
            <p>Drop the Process' persistent reference on the handle, deactivating future
Wait/Signal calls with the passed reason.

Returns the status prior to this call. If this is not statusOK, then the
reference was not dropped or status changed.</p>
            
            <pre><code>func handlePersistentRelease(reason processStatus) processStatus</code></pre>
         </article>
         
         <article class="function" data-name="pidStatus">
            <h2>pidStatus</h2>
            <hr />
            
            <pre><code>func pidStatus() processStatus</code></pre>
         </article>
         
         <article class="function" data-name="pidDeactivate">
            <h2>pidDeactivate</h2>
            <hr />
            
            <pre><code>func pidDeactivate(reason processStatus)</code></pre>
         </article>
         
         <article class="function" data-name="Getpid">
            <h2>Getpid</h2>
            <hr />
            
            <p>Getpid returns the process id of the caller.</p>
            
            <pre><code>func Getpid() int</code></pre>
         </article>
         
         <article class="function" data-name="Getppid">
            <h2>Getppid</h2>
            <hr />
            
            <p>Getppid returns the process id of the caller's parent.</p>
            
            <pre><code>func Getppid() int</code></pre>
         </article>
         
         <article class="function" data-name="FindProcess">
            <h2>FindProcess</h2>
            <hr />
            
            <p>FindProcess looks for a running process by its pid.

The [Process] it returns can be used to obtain information
about the underlying operating system process.

On Unix systems, FindProcess always succeeds and returns a Process
for the given pid, regardless of whether the process exists. To test whether
the process actually exists, see whether p.Signal(syscall.Signal(0)) reports
an error.</p>
            
            <pre><code>func FindProcess(pid int) (*Process, error)</code></pre>
         </article>
         
         <article class="function" data-name="StartProcess">
            <h2>StartProcess</h2>
            <hr />
            
            <p>StartProcess starts a new process with the program, arguments and attributes
specified by name, argv and attr. The argv slice will become [os.Args] in the
new process, so it normally starts with the program name.

If the calling goroutine has locked the operating system thread
with [runtime.LockOSThread] and modified any inheritable OS-level
thread state (for example, Linux or Plan 9 name spaces), the new
process will inherit the caller's thread state.

StartProcess is a low-level interface. The [os/exec] package provides
higher-level interfaces.

If there is an error, it will be of type [*PathError].</p>
            
            <pre><code>func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)</code></pre>
         </article>
         
         <article class="function" data-name="Release">
            <h2>Release</h2>
            <hr />
            
            <p>Release releases any resources associated with the [Process] p,
rendering it unusable in the future.
Release only needs to be called if [Process.Wait] is not.</p>
            
            <pre><code>func Release() error</code></pre>
         </article>
         
         <article class="function" data-name="Kill">
            <h2>Kill</h2>
            <hr />
            
            <p>Kill causes the [Process] to exit immediately. Kill does not wait until
the Process has actually exited. This only kills the Process itself,
not any other processes it may have started.</p>
            
            <pre><code>func Kill() error</code></pre>
         </article>
         
         <article class="function" data-name="Wait">
            <h2>Wait</h2>
            <hr />
            
            <p>Wait waits for the [Process] to exit, and then returns a
ProcessState describing its status and an error, if any.
Wait releases any resources associated with the Process.
On most operating systems, the Process must be a child
of the current process or an error will be returned.</p>
            
            <pre><code>func Wait() (*ProcessState, error)</code></pre>
         </article>
         
         <article class="function" data-name="Signal">
            <h2>Signal</h2>
            <hr />
            
            <p>Signal sends a signal to the [Process].
Sending [Interrupt] on Windows is not implemented.</p>
            
            <pre><code>func Signal(sig Signal) error</code></pre>
         </article>
         
         <article class="function" data-name="UserTime">
            <h2>UserTime</h2>
            <hr />
            
            <p>UserTime returns the user CPU time of the exited process and its children.</p>
            
            <pre><code>func UserTime() time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="SystemTime">
            <h2>SystemTime</h2>
            <hr />
            
            <p>SystemTime returns the system CPU time of the exited process and its children.</p>
            
            <pre><code>func SystemTime() time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="Exited">
            <h2>Exited</h2>
            <hr />
            
            <p>Exited reports whether the program has exited.
On Unix systems this reports true if the program exited due to calling exit,
but false if the program terminated due to a signal.</p>
            
            <pre><code>func Exited() bool</code></pre>
         </article>
         
         <article class="function" data-name="Success">
            <h2>Success</h2>
            <hr />
            
            <p>Success reports whether the program exited successfully,
such as with exit status 0 on Unix.</p>
            
            <pre><code>func Success() bool</code></pre>
         </article>
         
         <article class="function" data-name="Sys">
            <h2>Sys</h2>
            <hr />
            
            <p>Sys returns system-dependent exit information about
the process. Convert it to the appropriate underlying
type, such as [syscall.WaitStatus] on Unix, to access its contents.</p>
            
            <pre><code>func Sys() any</code></pre>
         </article>
         
         <article class="function" data-name="SysUsage">
            <h2>SysUsage</h2>
            <hr />
            
            <p>SysUsage returns system-dependent resource usage information about
the exited process. Convert it to the appropriate underlying
type, such as [*syscall.Rusage] on Unix, to access its contents.
(On Unix, *syscall.Rusage matches struct rusage as defined in the
getrusage(2) manual page.)</p>
            
            <pre><code>func SysUsage() any</code></pre>
         </article>
         
         <article class="function" data-name="wait">
            <h2>wait</h2>
            <hr />
            
            <pre><code>func wait() (ps *ProcessState, err error)</code></pre>
         </article>
         
         <article class="function" data-name="pidWait">
            <h2>pidWait</h2>
            <hr />
            
            <pre><code>func pidWait() (*ProcessState, error)</code></pre>
         </article>
         
         <article class="function" data-name="signal">
            <h2>signal</h2>
            <hr />
            
            <pre><code>func signal(sig Signal) error</code></pre>
         </article>
         
         <article class="function" data-name="pidSignal">
            <h2>pidSignal</h2>
            <hr />
            
            <pre><code>func pidSignal(s syscall.Signal) error</code></pre>
         </article>
         
         <article class="function" data-name="convertESRCH">
            <h2>convertESRCH</h2>
            <hr />
            
            <pre><code>func convertESRCH(err error) error</code></pre>
         </article>
         
         <article class="function" data-name="release">
            <h2>release</h2>
            <hr />
            
            <pre><code>func release() error</code></pre>
         </article>
         
         <article class="function" data-name="findProcess">
            <h2>findProcess</h2>
            <hr />
            
            <pre><code>func findProcess(pid int) (p *Process, err error)</code></pre>
         </article>
         
         <article class="function" data-name="userTime">
            <h2>userTime</h2>
            <hr />
            
            <pre><code>func userTime() time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="systemTime">
            <h2>systemTime</h2>
            <hr />
            
            <pre><code>func systemTime() time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="Pipe">
            <h2>Pipe</h2>
            <hr />
            
            <p>Pipe returns a connected pair of Files; reads from r return bytes written to w.
It returns the files and an error, if any.</p>
            
            <pre><code>func Pipe() (r *File, w *File, err error)</code></pre>
         </article>
         
         <article class="function" data-name="hostname">
            <h2>hostname</h2>
            <hr />
            
            <pre><code>func hostname() (name string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Getpagesize">
            <h2>Getpagesize</h2>
            <hr />
            
            <p>Getpagesize returns the underlying system's memory page size.</p>
            
            <pre><code>func Getpagesize() int</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="IsDir">
            <h2>IsDir</h2>
            <hr />
            
            <pre><code>func IsDir() bool</code></pre>
         </article>
         
         <article class="function" data-name="SameFile">
            <h2>SameFile</h2>
            <hr />
            
            <p>SameFile reports whether fi1 and fi2 describe the same file.
For example, on Unix this means that the device and inode fields
of the two underlying structures are identical; on other systems
the decision may be based on the path names.
SameFile only applies to results returned by this package's [Stat].
It returns false in other cases.</p>
            
            <pre><code>func SameFile(fi1 FileInfo, fi2 FileInfo) bool</code></pre>
         </article>
         
         <article class="function" data-name="blockUntilWaitable">
            <h2>blockUntilWaitable</h2>
            <hr />
            
            <p>blockUntilWaitable attempts to block until a call to p.Wait will
succeed immediately, and reports whether it has done so.
It does not actually call p.Wait.
This version is used on systems that do not implement waitid,
or where we have not implemented it yet. Note that this is racy:
a call to Process.Signal can in an extremely unlikely case send a
signal to the wrong process, see issue #13987.</p>
            
            <pre><code>func blockUntilWaitable() (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="executable">
            <h2>executable</h2>
            <hr />
            
            <pre><code>func executable() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="fillFileStatFromSys">
            <h2>fillFileStatFromSys</h2>
            <hr />
            
            <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
         </article>
         
         <article class="function" data-name="atime">
            <h2>atime</h2>
            <hr />
            
            <p>For testing.</p>
            
            <pre><code>func atime(fi FileInfo) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="executable">
            <h2>executable</h2>
            <hr />
            
            <pre><code>func executable() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <p>Stat returns the [FileInfo] structure describing file.
If there is an error, it will be of type [*PathError].</p>
            
            <pre><code>func Stat() (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="stat">
            <h2>stat</h2>
            <hr />
            
            <p>stat implements both Stat and Lstat of a file.</p>
            
            <pre><code>func stat(funcname string, name string, followSurrogates bool) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="statHandle">
            <h2>statHandle</h2>
            <hr />
            
            <pre><code>func statHandle(name string, h syscall.Handle) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="statNolog">
            <h2>statNolog</h2>
            <hr />
            
            <p>statNolog implements Stat for Windows.</p>
            
            <pre><code>func statNolog(name string) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="lstatNolog">
            <h2>lstatNolog</h2>
            <hr />
            
            <p>lstatNolog implements Lstat for Windows.</p>
            
            <pre><code>func lstatNolog(name string) (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="readdir">
            <h2>readdir</h2>
            <hr />
            
            <pre><code>func readdir(n int, mode readdirMode) (names []string, dirents []DirEntry, infos []FileInfo, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="IsDir">
            <h2>IsDir</h2>
            <hr />
            
            <pre><code>func IsDir() bool</code></pre>
         </article>
         
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <pre><code>func Type() FileMode</code></pre>
         </article>
         
         <article class="function" data-name="Info">
            <h2>Info</h2>
            <hr />
            
            <pre><code>func Info() (FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="isNoFollowErr">
            <h2>isNoFollowErr</h2>
            <hr />
            
            <p>isNoFollowErr reports whether err may result from O_NOFOLLOW blocking an open operation.</p>
            
            <pre><code>func isNoFollowErr(err error) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsPathSeparator">
            <h2>IsPathSeparator</h2>
            <hr />
            
            <p>IsPathSeparator reports whether c is a directory separator character.</p>
            
            <pre><code>func IsPathSeparator(c uint8) bool</code></pre>
         </article>
         
         <article class="function" data-name="Pipe">
            <h2>Pipe</h2>
            <hr />
            
            <p>Pipe returns a connected pair of Files; reads from r return bytes written to w.
It returns the files and an error, if any.</p>
            
            <pre><code>func Pipe() (r *File, w *File, err error)</code></pre>
         </article>
         
         <article class="function" data-name="fillFileStatFromSys">
            <h2>fillFileStatFromSys</h2>
            <hr />
            
            <pre><code>func fillFileStatFromSys(fs *fileStat, name string)</code></pre>
         </article>
         
         <article class="function" data-name="atime">
            <h2>atime</h2>
            <hr />
            
            <p>For testing.</p>
            
            <pre><code>func atime(fi FileInfo) time.Time</code></pre>
         </article>
         
         <article class="function" data-name="wait6">
            <h2>wait6</h2>
            <hr />
            
            <pre><code>func wait6(idtype int, id int, options int) (status int, errno syscall.Errno)</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <p>Name returns the name of the file as presented to Open.

It is safe to call Name after [Close].</p>
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <p>Read reads up to len(b) bytes from the File and stores them in b.
It returns the number of bytes read and any error encountered.
At end of file, Read returns 0, io.EOF.</p>
            
            <pre><code>func Read(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadAt">
            <h2>ReadAt</h2>
            <hr />
            
            <p>ReadAt reads len(b) bytes from the File starting at byte offset off.
It returns the number of bytes read and the error, if any.
ReadAt always returns a non-nil error when n < len(b).
At end of file, that error is io.EOF.</p>
            
            <pre><code>func ReadAt(b []byte, off int64) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadFrom">
            <h2>ReadFrom</h2>
            <hr />
            
            <p>ReadFrom implements io.ReaderFrom.</p>
            
            <pre><code>func ReadFrom(r io.Reader) (n int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadFrom">
            <h2>ReadFrom</h2>
            <hr />
            
            <p>ReadFrom hides another ReadFrom method.
It should never be called.</p>
            
            <pre><code>func ReadFrom(io.Reader) (int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="genericReadFrom">
            <h2>genericReadFrom</h2>
            <hr />
            
            <pre><code>func genericReadFrom(f *File, r io.Reader) (int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write writes len(b) bytes from b to the File.
It returns the number of bytes written and an error, if any.
Write returns a non-nil error when n != len(b).</p>
            
            <pre><code>func Write(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteAt">
            <h2>WriteAt</h2>
            <hr />
            
            <p>WriteAt writes len(b) bytes to the File starting at byte offset off.
It returns the number of bytes written and an error, if any.
WriteAt returns a non-nil error when n != len(b).

If file was opened with the O_APPEND flag, WriteAt returns an error.</p>
            
            <pre><code>func WriteAt(b []byte, off int64) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteTo">
            <h2>WriteTo</h2>
            <hr />
            
            <p>WriteTo implements io.WriterTo.</p>
            
            <pre><code>func WriteTo(w io.Writer) (n int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteTo">
            <h2>WriteTo</h2>
            <hr />
            
            <p>WriteTo hides another WriteTo method.
It should never be called.</p>
            
            <pre><code>func WriteTo(io.Writer) (int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="genericWriteTo">
            <h2>genericWriteTo</h2>
            <hr />
            
            <pre><code>func genericWriteTo(f *File, w io.Writer) (int64, error)</code></pre>
         </article>
         
         <article class="function" data-name="Seek">
            <h2>Seek</h2>
            <hr />
            
            <p>Seek sets the offset for the next Read or Write on file to offset, interpreted
according to whence: 0 means relative to the origin of the file, 1 means
relative to the current offset, and 2 means relative to the end.
It returns the new offset and an error, if any.
The behavior of Seek on a file opened with O_APPEND is not specified.</p>
            
            <pre><code>func Seek(offset int64, whence int) (ret int64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteString">
            <h2>WriteString</h2>
            <hr />
            
            <p>WriteString is like Write, but writes the contents of string s rather than
a slice of bytes.</p>
            
            <pre><code>func WriteString(s string) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Mkdir">
            <h2>Mkdir</h2>
            <hr />
            
            <p>Mkdir creates a new directory with the specified name and permission
bits (before umask).
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Mkdir(name string, perm FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="setStickyBit">
            <h2>setStickyBit</h2>
            <hr />
            
            <p>setStickyBit adds ModeSticky to the permission bits of path, non atomic.</p>
            
            <pre><code>func setStickyBit(name string) error</code></pre>
         </article>
         
         <article class="function" data-name="Chdir">
            <h2>Chdir</h2>
            <hr />
            
            <p>Chdir changes the current working directory to the named directory.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Chdir(dir string) error</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <p>Open opens the named file for reading. If successful, methods on
the returned file can be used for reading; the associated file
descriptor has mode O_RDONLY.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Open(name string) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="Create">
            <h2>Create</h2>
            <hr />
            
            <p>Create creates or truncates the named file. If the file already exists,
it is truncated. If the file does not exist, it is created with mode 0o666
(before umask). If successful, methods on the returned File can
be used for I/O; the associated file descriptor has mode O_RDWR.
The directory containing the file must already exist.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Create(name string) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="OpenFile">
            <h2>OpenFile</h2>
            <hr />
            
            <p>OpenFile is the generalized open call; most users will use Open
or Create instead. It opens the named file with specified flag
(O_RDONLY etc.). If the file does not exist, and the O_CREATE flag
is passed, it is created with mode perm (before umask);
the containing directory must exist. If successful,
methods on the returned File can be used for I/O.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func OpenFile(name string, flag int, perm FileMode) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="openDir">
            <h2>openDir</h2>
            <hr />
            
            <p>openDir opens a file which is assumed to be a directory. As such, it skips
the syscalls that make the file descriptor non-blocking as these take time
and will fail on file descriptors for directories.</p>
            
            <pre><code>func openDir(name string) (*File, error)</code></pre>
         </article>
         
         <article class="function" data-name="Rename">
            <h2>Rename</h2>
            <hr />
            
            <p>Rename renames (moves) oldpath to newpath.
If newpath already exists and is not a directory, Rename replaces it.
If newpath already exists and is a directory, Rename returns an error.
OS-specific restrictions may apply when oldpath and newpath are in different directories.
Even within the same directory, on non-Unix platforms Rename is not an atomic operation.
If there is an error, it will be of type *LinkError.</p>
            
            <pre><code>func Rename(oldpath string, newpath string) error</code></pre>
         </article>
         
         <article class="function" data-name="Readlink">
            <h2>Readlink</h2>
            <hr />
            
            <p>Readlink returns the destination of the named symbolic link.
If there is an error, it will be of type *PathError.

If the link destination is relative, Readlink returns the relative path
without resolving it to an absolute one.</p>
            
            <pre><code>func Readlink(name string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="fixCount">
            <h2>fixCount</h2>
            <hr />
            
            <p>Many functions in package syscall return a count of -1 instead of 0.
Using fixCount(call()) instead of call() corrects the count.</p>
            
            <pre><code>func fixCount(n int, err error) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="wrapErr">
            <h2>wrapErr</h2>
            <hr />
            
            <p>wrapErr wraps an error that occurred during an operation on an open file.
It passes io.EOF through unchanged, otherwise converts
poll.ErrFileClosing to ErrClosed and wraps the error in a PathError.</p>
            
            <pre><code>func wrapErr(op string, err error) error</code></pre>
         </article>
         
         <article class="function" data-name="TempDir">
            <h2>TempDir</h2>
            <hr />
            
            <p>TempDir returns the default directory to use for temporary files.

On Unix systems, it returns $TMPDIR if non-empty, else /tmp.
On Windows, it uses GetTempPath, returning the first non-empty
value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.
On Plan 9, it returns /tmp.

The directory is neither guaranteed to exist nor have accessible
permissions.</p>
            
            <pre><code>func TempDir() string</code></pre>
         </article>
         
         <article class="function" data-name="UserCacheDir">
            <h2>UserCacheDir</h2>
            <hr />
            
            <p>UserCacheDir returns the default root directory to use for user-specific
cached data. Users should create their own application-specific subdirectory
within this one and use that.

On Unix systems, it returns $XDG_CACHE_HOME as specified by
https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
non-empty, else $HOME/.cache.
On Darwin, it returns $HOME/Library/Caches.
On Windows, it returns %LocalAppData%.
On Plan 9, it returns $home/lib/cache.

If the location cannot be determined (for example, $HOME is not defined) or
the path in $XDG_CACHE_HOME is relative, then it will return an error.</p>
            
            <pre><code>func UserCacheDir() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="UserConfigDir">
            <h2>UserConfigDir</h2>
            <hr />
            
            <p>UserConfigDir returns the default root directory to use for user-specific
configuration data. Users should create their own application-specific
subdirectory within this one and use that.

On Unix systems, it returns $XDG_CONFIG_HOME as specified by
https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
non-empty, else $HOME/.config.
On Darwin, it returns $HOME/Library/Application Support.
On Windows, it returns %AppData%.
On Plan 9, it returns $home/lib.

If the location cannot be determined (for example, $HOME is not defined) or
the path in $XDG_CONFIG_HOME is relative, then it will return an error.</p>
            
            <pre><code>func UserConfigDir() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="UserHomeDir">
            <h2>UserHomeDir</h2>
            <hr />
            
            <p>UserHomeDir returns the current user's home directory.

On Unix, including macOS, it returns the $HOME environment variable.
On Windows, it returns %USERPROFILE%.
On Plan 9, it returns the $home environment variable.

If the expected variable is not set in the environment, UserHomeDir
returns either a platform-specific default value or a non-nil error.</p>
            
            <pre><code>func UserHomeDir() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="Chmod">
            <h2>Chmod</h2>
            <hr />
            
            <p>Chmod changes the mode of the named file to mode.
If the file is a symbolic link, it changes the mode of the link's target.
If there is an error, it will be of type *PathError.

A different subset of the mode bits are used, depending on the
operating system.

On Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and
ModeSticky are used.

On Windows, only the 0o200 bit (owner writable) of mode is used; it
controls whether the file's read-only attribute is set or cleared.
The other bits are currently unused. For compatibility with Go 1.12
and earlier, use a non-zero mode. Use mode 0o400 for a read-only
file and 0o600 for a readable+writable file.

On Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,
and ModeTemporary are used.</p>
            
            <pre><code>func Chmod(name string, mode FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="Chmod">
            <h2>Chmod</h2>
            <hr />
            
            <p>Chmod changes the mode of the file to mode.
If there is an error, it will be of type *PathError.</p>
            
            <pre><code>func Chmod(mode FileMode) error</code></pre>
         </article>
         
         <article class="function" data-name="SetDeadline">
            <h2>SetDeadline</h2>
            <hr />
            
            <p>SetDeadline sets the read and write deadlines for a File.
It is equivalent to calling both SetReadDeadline and SetWriteDeadline.

Only some kinds of files support setting a deadline. Calls to SetDeadline
for files that do not support deadlines will return ErrNoDeadline.
On most systems ordinary files do not support deadlines, but pipes do.

A deadline is an absolute time after which I/O operations fail with an
error instead of blocking. The deadline applies to all future and pending
I/O, not just the immediately following call to Read or Write.
After a deadline has been exceeded, the connection can be refreshed
by setting a deadline in the future.

If the deadline is exceeded a call to Read or Write or to other I/O
methods will return an error that wraps ErrDeadlineExceeded.
This can be tested using errors.Is(err, os.ErrDeadlineExceeded).
That error implements the Timeout method, and calling the Timeout
method will return true, but there are other possible errors for which
the Timeout will return true even if the deadline has not been exceeded.

An idle timeout can be implemented by repeatedly extending
the deadline after successful Read or Write calls.

A zero value for t means I/O operations will not time out.</p>
            
            <pre><code>func SetDeadline(t time.Time) error</code></pre>
         </article>
         
         <article class="function" data-name="SetReadDeadline">
            <h2>SetReadDeadline</h2>
            <hr />
            
            <p>SetReadDeadline sets the deadline for future Read calls and any
currently-blocked Read call.
A zero value for t means Read will not time out.
Not all files support setting deadlines; see SetDeadline.</p>
            
            <pre><code>func SetReadDeadline(t time.Time) error</code></pre>
         </article>
         
         <article class="function" data-name="SetWriteDeadline">
            <h2>SetWriteDeadline</h2>
            <hr />
            
            <p>SetWriteDeadline sets the deadline for any future Write calls and any
currently-blocked Write call.
Even if Write times out, it may return n > 0, indicating that
some of the data was successfully written.
A zero value for t means Write will not time out.
Not all files support setting deadlines; see SetDeadline.</p>
            
            <pre><code>func SetWriteDeadline(t time.Time) error</code></pre>
         </article>
         
         <article class="function" data-name="SyscallConn">
            <h2>SyscallConn</h2>
            <hr />
            
            <p>SyscallConn returns a raw file.
This implements the syscall.Conn interface.</p>
            
            <pre><code>func SyscallConn() (syscall.RawConn, error)</code></pre>
         </article>
         
         <article class="function" data-name="DirFS">
            <h2>DirFS</h2>
            <hr />
            
            <p>DirFS returns a file system (an fs.FS) for the tree of files rooted at the directory dir.

Note that DirFS("/prefix") only guarantees that the Open calls it makes to the
operating system will begin with "/prefix": DirFS("/prefix").Open("file") is the
same as os.Open("/prefix/file"). So if /prefix/file is a symbolic link pointing outside
the /prefix tree, then using DirFS does not stop the access any more than using
os.Open does. Additionally, the root of the fs.FS returned for a relative path,
DirFS("prefix"), will be affected by later calls to Chdir. DirFS is therefore not
a general substitute for a chroot-style security mechanism when the directory tree
contains arbitrary content.

Use [Root.FS] to obtain a fs.FS that prevents escapes from the tree via symbolic links.

The directory dir must not be "".

The result implements [io/fs.StatFS], [io/fs.ReadFileFS] and
[io/fs.ReadDirFS].</p>
            
            <pre><code>func DirFS(dir string) fs.FS</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <pre><code>func Open(name string) (fs.File, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadFile">
            <h2>ReadFile</h2>
            <hr />
            
            <p>The ReadFile method calls the [ReadFile] function for the file
with the given name in the directory. The function provides
robust handling for small files and special file systems.
Through this method, dirFS implements [io/fs.ReadFileFS].</p>
            
            <pre><code>func ReadFile(name string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadDir">
            <h2>ReadDir</h2>
            <hr />
            
            <p>ReadDir reads the named directory, returning all its directory entries sorted
by filename. Through this method, dirFS implements [io/fs.ReadDirFS].</p>
            
            <pre><code>func ReadDir(name string) ([]DirEntry, error)</code></pre>
         </article>
         
         <article class="function" data-name="Stat">
            <h2>Stat</h2>
            <hr />
            
            <pre><code>func Stat(name string) (fs.FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="join">
            <h2>join</h2>
            <hr />
            
            <p>join returns the path for name in dir.</p>
            
            <pre><code>func join(name string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="ReadFile">
            <h2>ReadFile</h2>
            <hr />
            
            <p>ReadFile reads the named file and returns the contents.
A successful call returns err == nil, not err == EOF.
Because ReadFile reads the whole file, it does not treat an EOF from Read
as an error to be reported.</p>
            
            <pre><code>func ReadFile(name string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="readFileContents">
            <h2>readFileContents</h2>
            <hr />
            
            <pre><code>func readFileContents(f *File) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="WriteFile">
            <h2>WriteFile</h2>
            <hr />
            
            <p>WriteFile writes data to the named file, creating it if necessary.
If the file does not exist, WriteFile creates it with permissions perm (before umask);
otherwise WriteFile truncates it before writing, without changing permissions.
Since WriteFile requires multiple system calls to complete, a failure mid-operation
can leave the file in a partially written state.</p>
            
            <pre><code>func WriteFile(name string, data []byte, perm FileMode) error</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
