<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - token</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>token</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"cmp"
"fmt"
"slices"
"strconv"
"sync"
"sync/atomic"
"strconv"
"unicode"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="ADD">
               <h3>
                  ADD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Operators and delimiters</p>
               
               <pre><code>const ADD</code></pre>
            </article>
            
            <article class="global" data-name="ADD_ASSIGN">
               <h3>
                  ADD_ASSIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const ADD_ASSIGN</code></pre>
            </article>
            
            <article class="global" data-name="AND">
               <h3>
                  AND 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const AND</code></pre>
            </article>
            
            <article class="global" data-name="AND_ASSIGN">
               <h3>
                  AND_ASSIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const AND_ASSIGN</code></pre>
            </article>
            
            <article class="global" data-name="AND_NOT">
               <h3>
                  AND_NOT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const AND_NOT</code></pre>
            </article>
            
            <article class="global" data-name="AND_NOT_ASSIGN">
               <h3>
                  AND_NOT_ASSIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const AND_NOT_ASSIGN</code></pre>
            </article>
            
            <article class="global" data-name="ARROW">
               <h3>
                  ARROW 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const ARROW</code></pre>
            </article>
            
            <article class="global" data-name="ASSIGN">
               <h3>
                  ASSIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const ASSIGN</code></pre>
            </article>
            
            <article class="global" data-name="BREAK">
               <h3>
                  BREAK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Keywords</p>
               
               <pre><code>const BREAK</code></pre>
            </article>
            
            <article class="global" data-name="CASE">
               <h3>
                  CASE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const CASE</code></pre>
            </article>
            
            <article class="global" data-name="CHAN">
               <h3>
                  CHAN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const CHAN</code></pre>
            </article>
            
            <article class="global" data-name="CHAR">
               <h3>
                  CHAR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const CHAR</code></pre>
            </article>
            
            <article class="global" data-name="COLON">
               <h3>
                  COLON 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const COLON</code></pre>
            </article>
            
            <article class="global" data-name="COMMA">
               <h3>
                  COMMA 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const COMMA</code></pre>
            </article>
            
            <article class="global" data-name="COMMENT">
               <h3>
                  COMMENT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const COMMENT</code></pre>
            </article>
            
            <article class="global" data-name="CONST">
               <h3>
                  CONST 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const CONST</code></pre>
            </article>
            
            <article class="global" data-name="CONTINUE">
               <h3>
                  CONTINUE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const CONTINUE</code></pre>
            </article>
            
            <article class="global" data-name="DEC">
               <h3>
                  DEC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const DEC</code></pre>
            </article>
            
            <article class="global" data-name="DEFAULT">
               <h3>
                  DEFAULT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const DEFAULT</code></pre>
            </article>
            
            <article class="global" data-name="DEFER">
               <h3>
                  DEFER 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const DEFER</code></pre>
            </article>
            
            <article class="global" data-name="DEFINE">
               <h3>
                  DEFINE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const DEFINE</code></pre>
            </article>
            
            <article class="global" data-name="ELLIPSIS">
               <h3>
                  ELLIPSIS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const ELLIPSIS</code></pre>
            </article>
            
            <article class="global" data-name="ELSE">
               <h3>
                  ELSE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const ELSE</code></pre>
            </article>
            
            <article class="global" data-name="EOF">
               <h3>
                  EOF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const EOF</code></pre>
            </article>
            
            <article class="global" data-name="EQL">
               <h3>
                  EQL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const EQL</code></pre>
            </article>
            
            <article class="global" data-name="FALLTHROUGH">
               <h3>
                  FALLTHROUGH 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const FALLTHROUGH</code></pre>
            </article>
            
            <article class="global" data-name="FLOAT">
               <h3>
                  FLOAT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const FLOAT</code></pre>
            </article>
            
            <article class="global" data-name="FOR">
               <h3>
                  FOR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const FOR</code></pre>
            </article>
            
            <article class="global" data-name="FUNC">
               <h3>
                  FUNC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const FUNC</code></pre>
            </article>
            
            <article class="global" data-name="GEQ">
               <h3>
                  GEQ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const GEQ</code></pre>
            </article>
            
            <article class="global" data-name="GO">
               <h3>
                  GO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const GO</code></pre>
            </article>
            
            <article class="global" data-name="GOTO">
               <h3>
                  GOTO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const GOTO</code></pre>
            </article>
            
            <article class="global" data-name="GTR">
               <h3>
                  GTR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const GTR</code></pre>
            </article>
            
            <article class="global" data-name="HighestPrec">
               <h3>
                  HighestPrec 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>A set of constants for precedence-based expression parsing.
Non-operators have lowest precedence, followed by operators
starting with precedence 1 up to unary operators. The highest
precedence serves as "catch-all" precedence for selector,
indexing, and other operator and delimiter tokens.</p>
               
               <pre><code>const HighestPrec = 7</code></pre>
            </article>
            
            <article class="global" data-name="IDENT">
               <h3>
                  IDENT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Identifiers and basic type literals
(these tokens stand for classes of literals)</p>
               
               <pre><code>const IDENT</code></pre>
            </article>
            
            <article class="global" data-name="IF">
               <h3>
                  IF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const IF</code></pre>
            </article>
            
            <article class="global" data-name="ILLEGAL">
               <h3>
                  ILLEGAL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Special tokens</p>
               
               <pre><code>const ILLEGAL Token = iota</code></pre>
            </article>
            
            <article class="global" data-name="IMAG">
               <h3>
                  IMAG 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const IMAG</code></pre>
            </article>
            
            <article class="global" data-name="IMPORT">
               <h3>
                  IMPORT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const IMPORT</code></pre>
            </article>
            
            <article class="global" data-name="INC">
               <h3>
                  INC 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const INC</code></pre>
            </article>
            
            <article class="global" data-name="INT">
               <h3>
                  INT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const INT</code></pre>
            </article>
            
            <article class="global" data-name="INTERFACE">
               <h3>
                  INTERFACE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const INTERFACE</code></pre>
            </article>
            
            <article class="global" data-name="LAND">
               <h3>
                  LAND 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const LAND</code></pre>
            </article>
            
            <article class="global" data-name="LBRACE">
               <h3>
                  LBRACE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const LBRACE</code></pre>
            </article>
            
            <article class="global" data-name="LBRACK">
               <h3>
                  LBRACK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const LBRACK</code></pre>
            </article>
            
            <article class="global" data-name="LEQ">
               <h3>
                  LEQ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const LEQ</code></pre>
            </article>
            
            <article class="global" data-name="LOR">
               <h3>
                  LOR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const LOR</code></pre>
            </article>
            
            <article class="global" data-name="LPAREN">
               <h3>
                  LPAREN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const LPAREN</code></pre>
            </article>
            
            <article class="global" data-name="LSS">
               <h3>
                  LSS 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const LSS</code></pre>
            </article>
            
            <article class="global" data-name="LowestPrec">
               <h3>
                  LowestPrec 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>A set of constants for precedence-based expression parsing.
Non-operators have lowest precedence, followed by operators
starting with precedence 1 up to unary operators. The highest
precedence serves as "catch-all" precedence for selector,
indexing, and other operator and delimiter tokens.</p>
               
               <pre><code>const LowestPrec = 0</code></pre>
            </article>
            
            <article class="global" data-name="MAP">
               <h3>
                  MAP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const MAP</code></pre>
            </article>
            
            <article class="global" data-name="MUL">
               <h3>
                  MUL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const MUL</code></pre>
            </article>
            
            <article class="global" data-name="MUL_ASSIGN">
               <h3>
                  MUL_ASSIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const MUL_ASSIGN</code></pre>
            </article>
            
            <article class="global" data-name="NEQ">
               <h3>
                  NEQ 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const NEQ</code></pre>
            </article>
            
            <article class="global" data-name="NOT">
               <h3>
                  NOT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const NOT</code></pre>
            </article>
            
            <article class="global" data-name="NoPos">
               <h3>
                  NoPos 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The zero value for [Pos] is NoPos; there is no file and line information
associated with it, and NoPos.IsValid() is false. NoPos is always
smaller than any other [Pos] value. The corresponding [Position] value
for NoPos is the zero value for [Position].</p>
               
               <pre><code>const NoPos Pos = 0</code></pre>
            </article>
            
            <article class="global" data-name="OR">
               <h3>
                  OR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const OR</code></pre>
            </article>
            
            <article class="global" data-name="OR_ASSIGN">
               <h3>
                  OR_ASSIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const OR_ASSIGN</code></pre>
            </article>
            
            <article class="global" data-name="PACKAGE">
               <h3>
                  PACKAGE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const PACKAGE</code></pre>
            </article>
            
            <article class="global" data-name="PERIOD">
               <h3>
                  PERIOD 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const PERIOD</code></pre>
            </article>
            
            <article class="global" data-name="QUO">
               <h3>
                  QUO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const QUO</code></pre>
            </article>
            
            <article class="global" data-name="QUO_ASSIGN">
               <h3>
                  QUO_ASSIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const QUO_ASSIGN</code></pre>
            </article>
            
            <article class="global" data-name="RANGE">
               <h3>
                  RANGE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const RANGE</code></pre>
            </article>
            
            <article class="global" data-name="RBRACE">
               <h3>
                  RBRACE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const RBRACE</code></pre>
            </article>
            
            <article class="global" data-name="RBRACK">
               <h3>
                  RBRACK 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const RBRACK</code></pre>
            </article>
            
            <article class="global" data-name="REM">
               <h3>
                  REM 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const REM</code></pre>
            </article>
            
            <article class="global" data-name="REM_ASSIGN">
               <h3>
                  REM_ASSIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const REM_ASSIGN</code></pre>
            </article>
            
            <article class="global" data-name="RETURN">
               <h3>
                  RETURN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const RETURN</code></pre>
            </article>
            
            <article class="global" data-name="RPAREN">
               <h3>
                  RPAREN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const RPAREN</code></pre>
            </article>
            
            <article class="global" data-name="SELECT">
               <h3>
                  SELECT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const SELECT</code></pre>
            </article>
            
            <article class="global" data-name="SEMICOLON">
               <h3>
                  SEMICOLON 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const SEMICOLON</code></pre>
            </article>
            
            <article class="global" data-name="SHL">
               <h3>
                  SHL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const SHL</code></pre>
            </article>
            
            <article class="global" data-name="SHL_ASSIGN">
               <h3>
                  SHL_ASSIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const SHL_ASSIGN</code></pre>
            </article>
            
            <article class="global" data-name="SHR">
               <h3>
                  SHR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const SHR</code></pre>
            </article>
            
            <article class="global" data-name="SHR_ASSIGN">
               <h3>
                  SHR_ASSIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const SHR_ASSIGN</code></pre>
            </article>
            
            <article class="global" data-name="STRING">
               <h3>
                  STRING 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const STRING</code></pre>
            </article>
            
            <article class="global" data-name="STRUCT">
               <h3>
                  STRUCT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const STRUCT</code></pre>
            </article>
            
            <article class="global" data-name="SUB">
               <h3>
                  SUB 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const SUB</code></pre>
            </article>
            
            <article class="global" data-name="SUB_ASSIGN">
               <h3>
                  SUB_ASSIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const SUB_ASSIGN</code></pre>
            </article>
            
            <article class="global" data-name="SWITCH">
               <h3>
                  SWITCH 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const SWITCH</code></pre>
            </article>
            
            <article class="global" data-name="TILDE">
               <h3>
                  TILDE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>additional tokens, handled in an ad-hoc manner</p>
               
               <pre><code>const TILDE</code></pre>
            </article>
            
            <article class="global" data-name="TYPE">
               <h3>
                  TYPE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const TYPE</code></pre>
            </article>
            
            <article class="global" data-name="UnaryPrec">
               <h3>
                  UnaryPrec 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>A set of constants for precedence-based expression parsing.
Non-operators have lowest precedence, followed by operators
starting with precedence 1 up to unary operators. The highest
precedence serves as "catch-all" precedence for selector,
indexing, and other operator and delimiter tokens.</p>
               
               <pre><code>const UnaryPrec = 6</code></pre>
            </article>
            
            <article class="global" data-name="VAR">
               <h3>
                  VAR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const VAR</code></pre>
            </article>
            
            <article class="global" data-name="XOR">
               <h3>
                  XOR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const XOR</code></pre>
            </article>
            
            <article class="global" data-name="XOR_ASSIGN">
               <h3>
                  XOR_ASSIGN 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const XOR_ASSIGN</code></pre>
            </article>
            
            <article class="global" data-name="additional_beg">
               <h3>
                  additional_beg 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const additional_beg</code></pre>
            </article>
            
            <article class="global" data-name="additional_end">
               <h3>
                  additional_end 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const additional_end</code></pre>
            </article>
            
            <article class="global" data-name="debug">
               <h3>
                  debug 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>If debug is set, invalid offset and position values cause a panic
(go.dev/issue/57490).</p>
               
               <pre><code>const debug = false</code></pre>
            </article>
            
            <article class="global" data-name="keyword_beg">
               <h3>
                  keyword_beg 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const keyword_beg</code></pre>
            </article>
            
            <article class="global" data-name="keyword_end">
               <h3>
                  keyword_end 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const keyword_end</code></pre>
            </article>
            
            <article class="global" data-name="keywords">
               <h3>
                  keywords 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var keywords map[string]Token</code></pre>
            </article>
            
            <article class="global" data-name="literal_beg">
               <h3>
                  literal_beg 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const literal_beg</code></pre>
            </article>
            
            <article class="global" data-name="literal_end">
               <h3>
                  literal_end 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const literal_end</code></pre>
            </article>
            
            <article class="global" data-name="operator_beg">
               <h3>
                  operator_beg 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const operator_beg</code></pre>
            </article>
            
            <article class="global" data-name="operator_end">
               <h3>
                  operator_end 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The list of tokens.</p>
               
               <pre><code>const operator_end</code></pre>
            </article>
            
            <article class="global" data-name="tokens">
               <h3>
                  tokens 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var tokens = [...]string{...}</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Pos">
               <h3>
                  Pos
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Pos is a compact encoding of a source position within a file set.
It can be converted into a [Position] for a more convenient, but much
larger, representation.
The Pos value for a given file is a number in the range [base, base+size],
where base and size are specified when a file is added to the file set.
The difference between a Pos value and the corresponding file base
corresponds to the byte offset of that position (represented by the Pos value)
from the beginning of the file. Thus, the file base offset is the Pos value
representing the first byte in the file.
To create the Pos value for a specific source offset (measured in bytes),
first add the respective file to the current file set using [FileSet.AddFile]
and then call [File.Pos](offset) for that file. Given a Pos value p
for a specific file set fset, the corresponding [Position] value is
obtained by calling fset.Position(p).
Pos values can be compared directly with the usual comparison operators:
If two Pos values p and q are in the same file, comparing p and q is
equivalent to comparing the respective source file offsets. If p and q
are in different files, p < q is true if the file implied by p was added
to the respective file set before the file implied by q.</p>
               
               <pre><code>type Pos int</code></pre>
            </article>
            
            <article class="type" data-name="Token">
               <h3>
                  Token
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Token is the set of lexical tokens of the Go programming language.</p>
               
               <pre><code>type Token int</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="File">
               <h3>
                  File
                  <span class="badge">struct</span>
               </h3>
               
               <p>A File is a handle for a file belonging to a [FileSet].
A File has a name, size, and line offset table.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type File struct {
name string
base int
size int
mutex sync.Mutex
lines []int
infos []lineInfo
}</code></pre>
            </article>
            
            <article class="struct" data-name="FileSet">
               <h3>
                  FileSet
                  <span class="badge">struct</span>
               </h3>
               
               <p>A FileSet represents a set of source files.
Methods of file sets are synchronized; multiple goroutines
may invoke them concurrently.
The byte offsets for each file in a file set are mapped into
distinct (integer) intervals, one interval [base, base+size]
per file. [FileSet.Base] represents the first byte in the file, and size
is the corresponding file size. A [Pos] value is a value in such
an interval. By determining the interval a [Pos] value belongs
to, the file, its file base, and thus the byte offset (position)
the [Pos] value is representing can be computed.
When adding a new file, a file base must be provided. That can
be any integer value that is past the end of any interval of any
file already in the file set. For convenience, [FileSet.Base] provides
such a value, which is simply the end of the Pos interval of the most
recently added file, plus one. Unless there is a need to extend an
interval later, using the [FileSet.Base] should be used as argument
for [FileSet.AddFile].
A [File] may be removed from a FileSet when it is no longer needed.
This may reduce memory usage in a long-running application.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FileSet struct {
mutex sync.RWMutex
base int
files []*File
last *ast.IndexExpr
}</code></pre>
            </article>
            
            <article class="struct" data-name="Position">
               <h3>
                  Position
                  <span class="badge">struct</span>
               </h3>
               
               <p>Position describes an arbitrary source position
including the file, line, and column location.
A Position is valid if the line number is > 0.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Position struct {
Filename string
Offset int
Line int
Column int
}</code></pre>
            </article>
            
            <article class="struct" data-name="lineInfo">
               <h3>
                  lineInfo
                  <span class="badge">struct</span>
               </h3>
               
               <p>A lineInfo object describes alternative file, line, and column
number information (such as provided via a //line directive)
for a given file offset.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type lineInfo struct {
Offset int
Filename string
Line int
Column int
}</code></pre>
            </article>
            
            <article class="struct" data-name="serializedFile">
               <h3>
                  serializedFile
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type serializedFile struct {
Name string
Base int
Size int
Lines []int
Infos []lineInfo
}</code></pre>
            </article>
            
            <article class="struct" data-name="serializedFileSet">
               <h3>
                  serializedFileSet
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type serializedFileSet struct {
Base int
Files []serializedFile
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="AddFile">
               <h3>
                  AddFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddFile adds a new file with a given filename, base offset, and file size
to the file set s and returns the file. Multiple files may have the same
name. The base offset must not be smaller than the [FileSet.Base], and
size must not be negative. As a special case, if a negative base is provided,
the current value of the [FileSet.Base] is used instead.
Adding the file will set the file set's [FileSet.Base] value to base + size + 1
as the minimum base value for the next file. The following relationship
exists between a [Pos] value p for a given file offset offs:
int(p) = base + offs
with offs in the range [0, size] and thus p in the range [base, base+size].
For convenience, [File.Pos] may be used to create file-specific position
values from a file offset.</p>
               
               <pre><code>func (s *FileSet) AddFile(filename string, base int, size int) *File</code></pre>
            </article>
            
            <article class="function" data-name="AddLine">
               <h3>
                  AddLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddLine adds the line offset for a new line.
The line offset must be larger than the offset for the previous line
and smaller than the file size; otherwise the line offset is ignored.</p>
               
               <pre><code>func (f *File) AddLine(offset int)</code></pre>
            </article>
            
            <article class="function" data-name="AddLineColumnInfo">
               <h3>
                  AddLineColumnInfo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddLineColumnInfo adds alternative file, line, and column number
information for a given file offset. The offset must be larger
than the offset for the previously added alternative line info
and smaller than the file size; otherwise the information is
ignored.
AddLineColumnInfo is typically used to register alternative position
information for line directives such as //line filename:line:column.</p>
               
               <pre><code>func (f *File) AddLineColumnInfo(offset int, filename string, line int, column int)</code></pre>
            </article>
            
            <article class="function" data-name="AddLineInfo">
               <h3>
                  AddLineInfo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>AddLineInfo is like [File.AddLineColumnInfo] with a column = 1 argument.
It is here for backward-compatibility for code prior to Go 1.11.</p>
               
               <pre><code>func (f *File) AddLineInfo(offset int, filename string, line int)</code></pre>
            </article>
            
            <article class="function" data-name="Base">
               <h3>
                  Base 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Base returns the base offset of file f as registered with AddFile.</p>
               
               <pre><code>func (f *File) Base() int</code></pre>
            </article>
            
            <article class="function" data-name="Base">
               <h3>
                  Base 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Base returns the minimum base offset that must be provided to
[FileSet.AddFile] when adding the next file.</p>
               
               <pre><code>func (s *FileSet) Base() int</code></pre>
            </article>
            
            <article class="function" data-name="File">
               <h3>
                  File 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>File returns the file that contains the position p.
If no such file is found (for instance for p == [NoPos]),
the result is nil.</p>
               
               <pre><code>func (s *FileSet) File(p Pos) (f *File)</code></pre>
            </article>
            
            <article class="function" data-name="IsExported">
               <h3>
                  IsExported 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsExported reports whether name starts with an upper-case letter.</p>
               
               <pre><code>func IsExported(name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsIdentifier">
               <h3>
                  IsIdentifier 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsIdentifier reports whether name is a Go identifier, that is, a non-empty
string made up of letters, digits, and underscores, where the first character
is not a digit. Keywords are not identifiers.</p>
               
               <pre><code>func IsIdentifier(name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsKeyword">
               <h3>
                  IsKeyword 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsKeyword returns true for tokens corresponding to keywords;
it returns false otherwise.</p>
               
               <pre><code>func (tok Token) IsKeyword() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsKeyword">
               <h3>
                  IsKeyword 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsKeyword reports whether name is a Go keyword, such as "func" or "return".</p>
               
               <pre><code>func IsKeyword(name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="IsLiteral">
               <h3>
                  IsLiteral 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsLiteral returns true for tokens corresponding to identifiers
and basic type literals; it returns false otherwise.</p>
               
               <pre><code>func (tok Token) IsLiteral() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsOperator">
               <h3>
                  IsOperator 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsOperator returns true for tokens corresponding to operators and
delimiters; it returns false otherwise.</p>
               
               <pre><code>func (tok Token) IsOperator() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsValid">
               <h3>
                  IsValid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsValid reports whether the position is valid.</p>
               
               <pre><code>func (p Pos) IsValid() bool</code></pre>
            </article>
            
            <article class="function" data-name="IsValid">
               <h3>
                  IsValid 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>IsValid reports whether the position is valid.</p>
               
               <pre><code>func (pos *Position) IsValid() bool</code></pre>
            </article>
            
            <article class="function" data-name="Iterate">
               <h3>
                  Iterate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Iterate calls f for the files in the file set in the order they were added
until f returns false.</p>
               
               <pre><code>func (s *FileSet) Iterate(f func(*File) bool)</code></pre>
            </article>
            
            <article class="function" data-name="Line">
               <h3>
                  Line 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Line returns the line number for the given file position p;
p must be a [Pos] value in that file or [NoPos].</p>
               
               <pre><code>func (f *File) Line(p Pos) int</code></pre>
            </article>
            
            <article class="function" data-name="LineCount">
               <h3>
                  LineCount 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LineCount returns the number of lines in file f.</p>
               
               <pre><code>func (f *File) LineCount() int</code></pre>
            </article>
            
            <article class="function" data-name="LineStart">
               <h3>
                  LineStart 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>LineStart returns the [Pos] value of the start of the specified line.
It ignores any alternative positions set using [File.AddLineColumnInfo].
LineStart panics if the 1-based line number is invalid.</p>
               
               <pre><code>func (f *File) LineStart(line int) Pos</code></pre>
            </article>
            
            <article class="function" data-name="Lines">
               <h3>
                  Lines 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Lines returns the effective line offset table of the form described by [File.SetLines].
Callers must not mutate the result.</p>
               
               <pre><code>func (f *File) Lines() []int</code></pre>
            </article>
            
            <article class="function" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Lookup maps an identifier to its keyword token or [IDENT] (if not a keyword).</p>
               
               <pre><code>func Lookup(ident string) Token</code></pre>
            </article>
            
            <article class="function" data-name="MergeLine">
               <h3>
                  MergeLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MergeLine merges a line with the following line. It is akin to replacing
the newline character at the end of the line with a space (to not change the
remaining offsets). To obtain the line number, consult e.g. [Position.Line].
MergeLine will panic if given an invalid line number.</p>
               
               <pre><code>func (f *File) MergeLine(line int)</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Name returns the file name of file f as registered with AddFile.</p>
               
               <pre><code>func (f *File) Name() string</code></pre>
            </article>
            
            <article class="function" data-name="NewFileSet">
               <h3>
                  NewFileSet 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewFileSet creates a new file set.</p>
               
               <pre><code>func NewFileSet() *FileSet</code></pre>
            </article>
            
            <article class="function" data-name="Offset">
               <h3>
                  Offset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Offset returns the offset for the given file position p.
If p is before the file's start position (or if p is NoPos),
the result is 0; if p is past the file's end position,
the result is the file size (see also go.dev/issue/57490).
The following invariant, though not true for offset values
in general, holds for the result offset:
f.Offset(f.Pos(offset)) == offset</p>
               
               <pre><code>func (f *File) Offset(p Pos) int</code></pre>
            </article>
            
            <article class="function" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pos returns the Pos value for the given file offset.
If offset is negative, the result is the file's start
position; if the offset is too large, the result is
the file's end position (see also go.dev/issue/57490).
The following invariant, though not true for Pos values
in general, holds for the result p:
f.Pos(f.Offset(p)) == p.</p>
               
               <pre><code>func (f *File) Pos(offset int) Pos</code></pre>
            </article>
            
            <article class="function" data-name="Position">
               <h3>
                  Position 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Position returns the Position value for the given file position p.
If p is out of bounds, it is adjusted to match the File.Offset behavior.
Calling f.Position(p) is equivalent to calling f.PositionFor(p, true).</p>
               
               <pre><code>func (f *File) Position(p Pos) (pos Position)</code></pre>
            </article>
            
            <article class="function" data-name="Position">
               <h3>
                  Position 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Position converts a [Pos] p in the fileset into a Position value.
Calling s.Position(p) is equivalent to calling s.PositionFor(p, true).</p>
               
               <pre><code>func (s *FileSet) Position(p Pos) (pos Position)</code></pre>
            </article>
            
            <article class="function" data-name="PositionFor">
               <h3>
                  PositionFor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PositionFor returns the Position value for the given file position p.
If p is out of bounds, it is adjusted to match the File.Offset behavior.
If adjusted is set, the position may be adjusted by position-altering
//line comments; otherwise those comments are ignored.
p must be a Pos value in f or NoPos.</p>
               
               <pre><code>func (f *File) PositionFor(p Pos, adjusted bool) (pos Position)</code></pre>
            </article>
            
            <article class="function" data-name="PositionFor">
               <h3>
                  PositionFor 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PositionFor converts a [Pos] p in the fileset into a [Position] value.
If adjusted is set, the position may be adjusted by position-altering
//line comments; otherwise those comments are ignored.
p must be a [Pos] value in s or [NoPos].</p>
               
               <pre><code>func (s *FileSet) PositionFor(p Pos, adjusted bool) (pos Position)</code></pre>
            </article>
            
            <article class="function" data-name="Precedence">
               <h3>
                  Precedence 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Precedence returns the operator precedence of the binary
operator op. If op is not a binary operator, the result
is LowestPrecedence.</p>
               
               <pre><code>func (op Token) Precedence() int</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Read calls decode to deserialize a file set into s; s must not be nil.</p>
               
               <pre><code>func (s *FileSet) Read(decode func(any) error) error</code></pre>
            </article>
            
            <article class="function" data-name="RemoveFile">
               <h3>
                  RemoveFile 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>RemoveFile removes a file from the [FileSet] so that subsequent
queries for its [Pos] interval yield a negative result.
This reduces the memory usage of a long-lived [FileSet] that
encounters an unbounded stream of files.
Removing a file that does not belong to the set has no effect.</p>
               
               <pre><code>func (s *FileSet) RemoveFile(file *File)</code></pre>
            </article>
            
            <article class="function" data-name="SetLines">
               <h3>
                  SetLines 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetLines sets the line offsets for a file and reports whether it succeeded.
The line offsets are the offsets of the first character of each line;
for instance for the content "ab\nc\n" the line offsets are {0, 3}.
An empty file has an empty line offset table.
Each line offset must be larger than the offset for the previous line
and smaller than the file size; otherwise SetLines fails and returns
false.
Callers must not mutate the provided slice after SetLines returns.</p>
               
               <pre><code>func (f *File) SetLines(lines []int) bool</code></pre>
            </article>
            
            <article class="function" data-name="SetLinesForContent">
               <h3>
                  SetLinesForContent 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetLinesForContent sets the line offsets for the given file content.
It ignores position-altering //line comments.</p>
               
               <pre><code>func (f *File) SetLinesForContent(content []byte)</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Size returns the size of file f as registered with AddFile.</p>
               
               <pre><code>func (f *File) Size() int</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns a string in one of several forms:
file:line:column    valid position with file name
file:line           valid position with file name but no column (column == 0)
line:column         valid position without file name
line                valid position without file name and no column (column == 0)
file                invalid position with file name
-                   invalid position without file name</p>
               
               <pre><code>func (pos Position) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>String returns the string corresponding to the token tok.
For operators, delimiters, and keywords the string is the actual
token character sequence (e.g., for the token [ADD], the string is
"+"). For all other tokens the string corresponds to the token
constant name (e.g. for the token [IDENT], the string is "IDENT").</p>
               
               <pre><code>func (tok Token) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Write calls encode to serialize the file set s.</p>
               
               <pre><code>func (s *FileSet) Write(encode func(any) error) error</code></pre>
            </article>
            
            <article class="function" data-name="file">
               <h3>
                  file 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *FileSet) file(p Pos) *File</code></pre>
            </article>
            
            <article class="function" data-name="fixOffset">
               <h3>
                  fixOffset 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>fixOffset fixes an out-of-bounds offset such that 0 <= offset <= f.size.</p>
               
               <pre><code>func (f *File) fixOffset(offset int) int</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="position">
               <h3>
                  position 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *File) position(p Pos, adjusted bool) (pos Position)</code></pre>
            </article>
            
            <article class="function" data-name="searchFiles">
               <h3>
                  searchFiles 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func searchFiles(a []*File, x int) int</code></pre>
            </article>
            
            <article class="function" data-name="searchInts">
               <h3>
                  searchInts 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func searchInts(a []int, x int) int</code></pre>
            </article>
            
            <article class="function" data-name="searchLineInfos">
               <h3>
                  searchLineInfos 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func searchLineInfos(a []lineInfo, x int) int</code></pre>
            </article>
            
            <article class="function" data-name="unpack">
               <h3>
                  unpack 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unpack returns the filename and line and column number for a file offset.
If adjusted is set, unpack will return the filename and line information
possibly adjusted by //line comments; otherwise those comments are ignored.</p>
               
               <pre><code>func (f *File) unpack(offset int, adjusted bool) (filename string, line int, column int)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
