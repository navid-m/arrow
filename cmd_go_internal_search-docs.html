<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - search</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>search</code>
         </h1>
         <hr />
          
         <article class="struct" data-name="Match">
            <h2>type Match struct</h2>
            <hr />
            
            <p>A Match represents the result of matching a single package pattern.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pattern string
Dirs []string
Pkgs []string
Errs []error</code></pre>
         </article>
         
         <article class="struct" data-name="MatchError">
            <h2>type MatchError struct</h2>
            <hr />
            
            <p>A MatchError indicates an error that occurred while attempting to match a
pattern.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Match *Match
Err error</code></pre>
         </article>
          
         <article class="function" data-name="NewMatch">
            <h2>NewMatch</h2>
            <hr />
            
            <p>NewMatch returns a Match describing the given pattern,
without resolving its packages or errors.</p>
            
            <pre><code>func NewMatch(pattern string) *Match</code></pre>
         </article>
         
         <article class="function" data-name="Pattern">
            <h2>Pattern</h2>
            <hr />
            
            <p>Pattern returns the pattern to be matched.</p>
            
            <pre><code>func Pattern() string</code></pre>
         </article>
         
         <article class="function" data-name="AddError">
            <h2>AddError</h2>
            <hr />
            
            <p>AddError appends a MatchError wrapping err to m.Errs.</p>
            
            <pre><code>func AddError(err error)</code></pre>
         </article>
         
         <article class="function" data-name="IsLiteral">
            <h2>IsLiteral</h2>
            <hr />
            
            <p>IsLiteral reports whether the pattern is free of wildcards and meta-patterns.

A literal pattern must match at most one package.</p>
            
            <pre><code>func IsLiteral() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsLocal">
            <h2>IsLocal</h2>
            <hr />
            
            <p>IsLocal reports whether the pattern must be resolved from a specific root or
directory, such as a filesystem path or a single module.</p>
            
            <pre><code>func IsLocal() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsMeta">
            <h2>IsMeta</h2>
            <hr />
            
            <p>IsMeta reports whether the pattern is a “meta-package” keyword that represents
multiple packages, such as "std", "cmd", "tool", or "all".</p>
            
            <pre><code>func IsMeta() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsMetaPackage">
            <h2>IsMetaPackage</h2>
            <hr />
            
            <p>IsMetaPackage checks if name is a reserved package name that expands to multiple packages.</p>
            
            <pre><code>func IsMetaPackage(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="MatchPackages">
            <h2>MatchPackages</h2>
            <hr />
            
            <p>MatchPackages sets m.Pkgs to a non-nil slice containing all the packages that
can be found under the $GOPATH directories and $GOROOT that match the
pattern. The pattern must be either "all" (all packages), "std" (standard
packages), "cmd" (standard commands), or a path including "...".

If any errors may have caused the set of packages to be incomplete,
MatchPackages appends those errors to m.Errs.</p>
            
            <pre><code>func MatchPackages()</code></pre>
         </article>
         
         <article class="function" data-name="MatchDirs">
            <h2>MatchDirs</h2>
            <hr />
            
            <p>MatchDirs sets m.Dirs to a non-nil slice containing all directories that
potentially match a local pattern. The pattern must begin with an absolute
path, or "./", or "../". On Windows, the pattern may use slash or backslash
separators or a mix of both.

If any errors may have caused the set of directories to be incomplete,
MatchDirs appends those errors to m.Errs.</p>
            
            <pre><code>func MatchDirs(modRoots []string)</code></pre>
         </article>
         
         <article class="function" data-name="WarnUnmatched">
            <h2>WarnUnmatched</h2>
            <hr />
            
            <p>WarnUnmatched warns about patterns that didn't match any packages.</p>
            
            <pre><code>func WarnUnmatched(matches []*Match)</code></pre>
         </article>
         
         <article class="function" data-name="ImportPaths">
            <h2>ImportPaths</h2>
            <hr />
            
            <p>ImportPaths returns the matching paths to use for the given command line.
It calls ImportPathsQuiet and then WarnUnmatched.</p>
            
            <pre><code>func ImportPaths(patterns []string, modRoots []string) []*Match</code></pre>
         </article>
         
         <article class="function" data-name="ImportPathsQuiet">
            <h2>ImportPathsQuiet</h2>
            <hr />
            
            <p>ImportPathsQuiet is like ImportPaths but does not warn about patterns with no matches.</p>
            
            <pre><code>func ImportPathsQuiet(patterns []string, modRoots []string) []*Match</code></pre>
         </article>
         
         <article class="function" data-name="CleanPatterns">
            <h2>CleanPatterns</h2>
            <hr />
            
            <p>CleanPatterns returns the patterns to use for the given command line. It
canonicalizes the patterns but does not evaluate any matches. For patterns
that are not local or absolute paths, it preserves text after '@' to avoid
modifying version queries.</p>
            
            <pre><code>func CleanPatterns(patterns []string) []string</code></pre>
         </article>
         
         <article class="function" data-name="IsStandardImportPath">
            <h2>IsStandardImportPath</h2>
            <hr />
            
            <p>IsStandardImportPath reports whether $GOROOT/src/path should be considered
part of the standard distribution. For historical reasons we allow people to add
their own code to $GOROOT instead of using $GOPATH, but we assume that
code will start with a domain name (dot in the first element).

Note that this function is meant to evaluate whether a directory found in GOROOT
should be treated as part of the standard library. It should not be used to decide
that a directory found in GOPATH should be rejected: directories in GOPATH
need not have dots in the first element, and they just take their chances
with future collisions in the standard library.</p>
            
            <pre><code>func IsStandardImportPath(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsRelativePath">
            <h2>IsRelativePath</h2>
            <hr />
            
            <p>IsRelativePath reports whether pattern should be interpreted as a directory
path relative to the current directory, as opposed to a pattern matching
import paths.</p>
            
            <pre><code>func IsRelativePath(pattern string) bool</code></pre>
         </article>
         
         <article class="function" data-name="InDir">
            <h2>InDir</h2>
            <hr />
            
            <p>InDir checks whether path is in the file tree rooted at dir.
If so, InDir returns an equivalent path relative to dir.
If not, InDir returns an empty string.
InDir makes some effort to succeed even in the presence of symbolic links.</p>
            
            <pre><code>func InDir(path string, dir string) string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
