<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - abt</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>abt</code>
         </h1>
         <hr />
         
         <article class="global" data-name="LEAF_HEIGHT">
            <h2>LEAF_HEIGHT</h2>
            <hr />
            
            <pre><code>LEAF_HEIGHT</code></pre>
         </article>
         
         <article class="global" data-name="ZERO_HEIGHT">
            <h2>ZERO_HEIGHT</h2>
            <hr />
            
            <pre><code>ZERO_HEIGHT</code></pre>
         </article>
         
         <article class="global" data-name="NOT_KEY32">
            <h2>NOT_KEY32</h2>
            <hr />
            
            <pre><code>NOT_KEY32</code></pre>
         </article>
          
         <article class="struct" data-name="T">
            <h2>type T struct</h2>
            <hr />
            
            <p>T is the exported applicative balanced tree data type.
A T can be used as a value; updates to one copy of the value
do not change other copies.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">root *node32
size int</code></pre>
         </article>
         
         <article class="struct" data-name="node32">
            <h2>type node32 struct</h2>
            <hr />
            
            <p>node32 is the internal tree node data type</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">left *node32
right *node32
data *ast.InterfaceType
key int32
height_ int8</code></pre>
         </article>
         
         <article class="struct" data-name="iterator">
            <h2>type iterator struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">parents []*node32</code></pre>
         </article>
         
         <article class="struct" data-name="Iterator">
            <h2>type Iterator struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">it iterator</code></pre>
         </article>
         
         <article class="struct" data-name="sstring">
            <h2>type sstring struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">s string</code></pre>
         </article>
          
         <article class="function" data-name="makeNode">
            <h2>makeNode</h2>
            <hr />
            
            <pre><code>func makeNode(key int32) *node32</code></pre>
         </article>
         
         <article class="function" data-name="IsEmpty">
            <h2>IsEmpty</h2>
            <hr />
            
            <p>IsEmpty returns true iff t is empty.</p>
            
            <pre><code>func IsEmpty() bool</code></pre>
         </article>
         
         <article class="function" data-name="IsSingle">
            <h2>IsSingle</h2>
            <hr />
            
            <p>IsSingle returns true iff t is a singleton (leaf).</p>
            
            <pre><code>func IsSingle() bool</code></pre>
         </article>
         
         <article class="function" data-name="VisitInOrder">
            <h2>VisitInOrder</h2>
            <hr />
            
            <p>VisitInOrder applies f to the key and data pairs in t,
with keys ordered from smallest to largest.</p>
            
            <pre><code>func VisitInOrder(f func)</code></pre>
         </article>
         
         <article class="function" data-name="nilOrData">
            <h2>nilOrData</h2>
            <hr />
            
            <pre><code>func nilOrData() *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="nilOrKeyAndData">
            <h2>nilOrKeyAndData</h2>
            <hr />
            
            <pre><code>func nilOrKeyAndData() (k int32, d *ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="height">
            <h2>height</h2>
            <hr />
            
            <pre><code>func height() int8</code></pre>
         </article>
         
         <article class="function" data-name="Find">
            <h2>Find</h2>
            <hr />
            
            <p>Find returns the data associated with x in the tree, or
nil if x is not in the tree.</p>
            
            <pre><code>func Find(x int32) *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="Insert">
            <h2>Insert</h2>
            <hr />
            
            <p>Insert either adds x to the tree if x was not previously
a key in the tree, or updates the data for x in the tree if
x was already a key in the tree.  The previous data associated
with x is returned, and is nil if x was not previously a
key in the tree.</p>
            
            <pre><code>func Insert(x int32, data *ast.InterfaceType) *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() *T</code></pre>
         </article>
         
         <article class="function" data-name="Delete">
            <h2>Delete</h2>
            <hr />
            
            <pre><code>func Delete(x int32) *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="DeleteMin">
            <h2>DeleteMin</h2>
            <hr />
            
            <pre><code>func DeleteMin() (int32, *ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="DeleteMax">
            <h2>DeleteMax</h2>
            <hr />
            
            <pre><code>func DeleteMax() (int32, *ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <pre><code>func Size() int</code></pre>
         </article>
         
         <article class="function" data-name="Intersection">
            <h2>Intersection</h2>
            <hr />
            
            <p>Intersection returns the intersection of t and u, where the result
data for any common keys is given by f(t's data, u's data) -- f need
not be symmetric.  If f returns nil, then the key and data are not
added to the result.  If f itself is nil, then whatever value was
already present in the smaller set is used.</p>
            
            <pre><code>func Intersection(u *T, f func) *T</code></pre>
         </article>
         
         <article class="function" data-name="Union">
            <h2>Union</h2>
            <hr />
            
            <p>Union returns the union of t and u, where the result data for any common keys
is given by f(t's data, u's data) -- f need not be symmetric.  If f returns nil,
then the key and data are not added to the result.  If f itself is nil, then
whatever value was already present in the larger set is used.</p>
            
            <pre><code>func Union(u *T, f func) *T</code></pre>
         </article>
         
         <article class="function" data-name="Difference">
            <h2>Difference</h2>
            <hr />
            
            <p>Difference returns the difference of t and u, subject to the result
of f applied to data corresponding to equal keys.  If f returns nil
(or if f is nil) then the key+data are excluded, as usual.  If f
returns not-nil, then that key+data pair is inserted. instead.</p>
            
            <pre><code>func Difference(u *T, f func) *T</code></pre>
         </article>
         
         <article class="function" data-name="Iterator">
            <h2>Iterator</h2>
            <hr />
            
            <pre><code>func Iterator() Iterator</code></pre>
         </article>
         
         <article class="function" data-name="Equals">
            <h2>Equals</h2>
            <hr />
            
            <pre><code>func Equals(u *T) bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="equals">
            <h2>equals</h2>
            <hr />
            
            <pre><code>func equals(u *node32) bool</code></pre>
         </article>
         
         <article class="function" data-name="Equiv">
            <h2>Equiv</h2>
            <hr />
            
            <pre><code>func Equiv(u *T, eqv func) bool</code></pre>
         </article>
         
         <article class="function" data-name="equiv">
            <h2>equiv</h2>
            <hr />
            
            <pre><code>func equiv(u *node32, eqv func) bool</code></pre>
         </article>
         
         <article class="function" data-name="Next">
            <h2>Next</h2>
            <hr />
            
            <pre><code>func Next() (int32, *ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Done">
            <h2>Done</h2>
            <hr />
            
            <pre><code>func Done() bool</code></pre>
         </article>
         
         <article class="function" data-name="iterator">
            <h2>iterator</h2>
            <hr />
            
            <pre><code>func iterator() iterator</code></pre>
         </article>
         
         <article class="function" data-name="leftmost">
            <h2>leftmost</h2>
            <hr />
            
            <pre><code>func leftmost(t *node32)</code></pre>
         </article>
         
         <article class="function" data-name="done">
            <h2>done</h2>
            <hr />
            
            <pre><code>func done() bool</code></pre>
         </article>
         
         <article class="function" data-name="next">
            <h2>next</h2>
            <hr />
            
            <pre><code>func next() *node32</code></pre>
         </article>
         
         <article class="function" data-name="Min">
            <h2>Min</h2>
            <hr />
            
            <p>Min returns the minimum element of t.
If t is empty, then (NOT_KEY32, nil) is returned.</p>
            
            <pre><code>func Min() (k int32, d *ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Max">
            <h2>Max</h2>
            <hr />
            
            <p>Max returns the maximum element of t.
If t is empty, then (NOT_KEY32, nil) is returned.</p>
            
            <pre><code>func Max() (k int32, d *ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Glb">
            <h2>Glb</h2>
            <hr />
            
            <p>Glb returns the greatest-lower-bound-exclusive of x and the associated
data.  If x has no glb in the tree, then (NOT_KEY32, nil) is returned.</p>
            
            <pre><code>func Glb(x int32) (k int32, d *ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="GlbEq">
            <h2>GlbEq</h2>
            <hr />
            
            <p>GlbEq returns the greatest-lower-bound-inclusive of x and the associated
data.  If x has no glbEQ in the tree, then (NOT_KEY32, nil) is returned.</p>
            
            <pre><code>func GlbEq(x int32) (k int32, d *ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="Lub">
            <h2>Lub</h2>
            <hr />
            
            <p>Lub returns the least-upper-bound-exclusive of x and the associated
data.  If x has no lub in the tree, then (NOT_KEY32, nil) is returned.</p>
            
            <pre><code>func Lub(x int32) (k int32, d *ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="LubEq">
            <h2>LubEq</h2>
            <hr />
            
            <p>LubEq returns the least-upper-bound-inclusive of x and the associated
data.  If x has no lubEq in the tree, then (NOT_KEY32, nil) is returned.</p>
            
            <pre><code>func LubEq(x int32) (k int32, d *ast.InterfaceType)</code></pre>
         </article>
         
         <article class="function" data-name="isLeaf">
            <h2>isLeaf</h2>
            <hr />
            
            <pre><code>func isLeaf() bool</code></pre>
         </article>
         
         <article class="function" data-name="visitInOrder">
            <h2>visitInOrder</h2>
            <hr />
            
            <pre><code>func visitInOrder(f func)</code></pre>
         </article>
         
         <article class="function" data-name="find">
            <h2>find</h2>
            <hr />
            
            <pre><code>func find(key int32) *node32</code></pre>
         </article>
         
         <article class="function" data-name="min">
            <h2>min</h2>
            <hr />
            
            <pre><code>func min() *node32</code></pre>
         </article>
         
         <article class="function" data-name="max">
            <h2>max</h2>
            <hr />
            
            <pre><code>func max() *node32</code></pre>
         </article>
         
         <article class="function" data-name="glb">
            <h2>glb</h2>
            <hr />
            
            <pre><code>func glb(key int32, allow_eq bool) *node32</code></pre>
         </article>
         
         <article class="function" data-name="lub">
            <h2>lub</h2>
            <hr />
            
            <pre><code>func lub(key int32, allow_eq bool) *node32</code></pre>
         </article>
         
         <article class="function" data-name="aInsert">
            <h2>aInsert</h2>
            <hr />
            
            <pre><code>func aInsert(x int32) (newroot *node32, newnode *node32, oldnode *node32)</code></pre>
         </article>
         
         <article class="function" data-name="aDelete">
            <h2>aDelete</h2>
            <hr />
            
            <pre><code>func aDelete(key int32) (deleted *node32, newSubTree *node32)</code></pre>
         </article>
         
         <article class="function" data-name="aDeleteMin">
            <h2>aDeleteMin</h2>
            <hr />
            
            <pre><code>func aDeleteMin() (deleted *node32, newSubTree *node32)</code></pre>
         </article>
         
         <article class="function" data-name="aDeleteMax">
            <h2>aDeleteMax</h2>
            <hr />
            
            <pre><code>func aDeleteMax() (deleted *node32, newSubTree *node32)</code></pre>
         </article>
         
         <article class="function" data-name="aRebalanceAfterLeftDeletion">
            <h2>aRebalanceAfterLeftDeletion</h2>
            <hr />
            
            <pre><code>func aRebalanceAfterLeftDeletion(oldLeftHeight int8, tleft *node32) *node32</code></pre>
         </article>
         
         <article class="function" data-name="aRebalanceAfterRightDeletion">
            <h2>aRebalanceAfterRightDeletion</h2>
            <hr />
            
            <pre><code>func aRebalanceAfterRightDeletion(oldRightHeight int8, tright *node32) *node32</code></pre>
         </article>
         
         <article class="function" data-name="aRightIsHigh">
            <h2>aRightIsHigh</h2>
            <hr />
            
            <p>aRightIsHigh does rotations necessary to fix a high right child
assume that t and t.right are already fresh copies.</p>
            
            <pre><code>func aRightIsHigh(newnode *node32) *node32</code></pre>
         </article>
         
         <article class="function" data-name="aLeftIsHigh">
            <h2>aLeftIsHigh</h2>
            <hr />
            
            <p>aLeftIsHigh does rotations necessary to fix a high left child
assume that t and t.left are already fresh copies.</p>
            
            <pre><code>func aLeftIsHigh(newnode *node32) *node32</code></pre>
         </article>
         
         <article class="function" data-name="rightToRoot">
            <h2>rightToRoot</h2>
            <hr />
            
            <p>rightToRoot does that rotation, modifying t and t.right in the process.</p>
            
            <pre><code>func rightToRoot() *node32</code></pre>
         </article>
         
         <article class="function" data-name="leftToRoot">
            <h2>leftToRoot</h2>
            <hr />
            
            <p>leftToRoot does that rotation, modifying t and t.left in the process.</p>
            
            <pre><code>func leftToRoot() *node32</code></pre>
         </article>
         
         <article class="function" data-name="copy">
            <h2>copy</h2>
            <hr />
            
            <pre><code>func copy() *node32</code></pre>
         </article>
         
         <article class="function" data-name="makeTree">
            <h2>makeTree</h2>
            <hr />
            
            <pre><code>func makeTree(te *testing.T, x []int32, check bool) (t *T, k int, min int32, max int32)</code></pre>
         </article>
         
         <article class="function" data-name="applicInsert">
            <h2>applicInsert</h2>
            <hr />
            
            <pre><code>func applicInsert(te *testing.T, x []int32)</code></pre>
         </article>
         
         <article class="function" data-name="applicFind">
            <h2>applicFind</h2>
            <hr />
            
            <pre><code>func applicFind(te *testing.T, x []int32)</code></pre>
         </article>
         
         <article class="function" data-name="applicBounds">
            <h2>applicBounds</h2>
            <hr />
            
            <pre><code>func applicBounds(te *testing.T, x []int32)</code></pre>
         </article>
         
         <article class="function" data-name="applicDeleteMin">
            <h2>applicDeleteMin</h2>
            <hr />
            
            <pre><code>func applicDeleteMin(te *testing.T, x []int32)</code></pre>
         </article>
         
         <article class="function" data-name="applicDeleteMax">
            <h2>applicDeleteMax</h2>
            <hr />
            
            <pre><code>func applicDeleteMax(te *testing.T, x []int32)</code></pre>
         </article>
         
         <article class="function" data-name="applicDelete">
            <h2>applicDelete</h2>
            <hr />
            
            <pre><code>func applicDelete(te *testing.T, x []int32)</code></pre>
         </article>
         
         <article class="function" data-name="applicIterator">
            <h2>applicIterator</h2>
            <hr />
            
            <pre><code>func applicIterator(te *testing.T, x []int32)</code></pre>
         </article>
         
         <article class="function" data-name="equiv">
            <h2>equiv</h2>
            <hr />
            
            <pre><code>func equiv(a *ast.InterfaceType, b *ast.InterfaceType) bool</code></pre>
         </article>
         
         <article class="function" data-name="applicEquals">
            <h2>applicEquals</h2>
            <hr />
            
            <pre><code>func applicEquals(te *testing.T, x []int32, y []int32)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree(x []int32) *T</code></pre>
         </article>
         
         <article class="function" data-name="treePlus1">
            <h2>treePlus1</h2>
            <hr />
            
            <pre><code>func treePlus1(x []int32) *T</code></pre>
         </article>
         
         <article class="function" data-name="TestApplicInsert">
            <h2>TestApplicInsert</h2>
            <hr />
            
            <pre><code>func TestApplicInsert(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestApplicFind">
            <h2>TestApplicFind</h2>
            <hr />
            
            <pre><code>func TestApplicFind(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBounds">
            <h2>TestBounds</h2>
            <hr />
            
            <pre><code>func TestBounds(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDeleteMin">
            <h2>TestDeleteMin</h2>
            <hr />
            
            <pre><code>func TestDeleteMin(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDeleteMax">
            <h2>TestDeleteMax</h2>
            <hr />
            
            <pre><code>func TestDeleteMax(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDelete">
            <h2>TestDelete</h2>
            <hr />
            
            <pre><code>func TestDelete(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIterator">
            <h2>TestIterator</h2>
            <hr />
            
            <pre><code>func TestIterator(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestEquals">
            <h2>TestEquals</h2>
            <hr />
            
            <pre><code>func TestEquals(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="first">
            <h2>first</h2>
            <hr />
            
            <pre><code>func first(x *ast.InterfaceType, y *ast.InterfaceType) *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="second">
            <h2>second</h2>
            <hr />
            
            <pre><code>func second(x *ast.InterfaceType, y *ast.InterfaceType) *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="alwaysNil">
            <h2>alwaysNil</h2>
            <hr />
            
            <pre><code>func alwaysNil(x *ast.InterfaceType, y *ast.InterfaceType) *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="smaller">
            <h2>smaller</h2>
            <hr />
            
            <pre><code>func smaller(x *ast.InterfaceType, y *ast.InterfaceType) *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="assert">
            <h2>assert</h2>
            <hr />
            
            <pre><code>func assert(t *testing.T, expected *T, got *T, what string)</code></pre>
         </article>
         
         <article class="function" data-name="TestSetOps">
            <h2>TestSetOps</h2>
            <hr />
            
            <pre><code>func TestSetOps(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="stringer">
            <h2>stringer</h2>
            <hr />
            
            <pre><code>func stringer(s string) *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="wellFormed">
            <h2>wellFormed</h2>
            <hr />
            
            <p>wellFormed ensures that a red-black tree meets
all of its invariants and returns a string identifying
the first problem encountered. If there is no problem
then the returned string is empty. The size is also
returned to allow comparison of calculated tree size
with expected.</p>
            
            <pre><code>func wellFormed() (s string, i int)</code></pre>
         </article>
         
         <article class="function" data-name="wellFormedSubtree">
            <h2>wellFormedSubtree</h2>
            <hr />
            
            <p>wellFormedSubtree ensures that a red-black subtree meets
all of its invariants and returns a string identifying
the first problem encountered. If there is no problem
then the returned string is empty. The size is also
returned to allow comparison of calculated tree size
with expected.</p>
            
            <pre><code>func wellFormedSubtree(parent *node32, keyMin int32, keyMax int32) (s string, i int)</code></pre>
         </article>
         
         <article class="function" data-name="DebugString">
            <h2>DebugString</h2>
            <hr />
            
            <pre><code>func DebugString() string</code></pre>
         </article>
         
         <article class="function" data-name="DebugString">
            <h2>DebugString</h2>
            <hr />
            
            <p>DebugString prints the tree with nested information
to allow an eyeball check on the tree balance.</p>
            
            <pre><code>func DebugString(indent int) string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
