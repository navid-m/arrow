<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - typesinternal</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>typesinternal</code>
         </h1>
         <hr />
         
         <article class="global" data-name="InvalidSyntaxTree">
            <h2>InvalidSyntaxTree</h2>
            <hr />
            
            <p>InvalidSyntaxTree occurs if an invalid syntax tree is provided
to the type checker. It should never happen.</p>
            
            <pre><code>InvalidSyntaxTree ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ ErrorCode</code></pre>
         </article>
         
         <article class="global" data-name="Test">
            <h2>Test</h2>
            <hr />
            
            <p>Test is reserved for errors that only apply while in self-test mode.</p>
            
            <pre><code>Test</code></pre>
         </article>
         
         <article class="global" data-name="BlankPkgName">
            <h2>BlankPkgName</h2>
            <hr />
            
            <p>BlankPkgName occurs when a package name is the blank identifier "_".

Per the spec:
 "The PackageName must not be the blank identifier."</p>
            
            <pre><code>BlankPkgName</code></pre>
         </article>
         
         <article class="global" data-name="MismatchedPkgName">
            <h2>MismatchedPkgName</h2>
            <hr />
            
            <p>MismatchedPkgName occurs when a file's package name doesn't match the
package name already established by other files.</p>
            
            <pre><code>MismatchedPkgName</code></pre>
         </article>
         
         <article class="global" data-name="InvalidPkgUse">
            <h2>InvalidPkgUse</h2>
            <hr />
            
            <p>InvalidPkgUse occurs when a package identifier is used outside of a
selector expression.

Example:
 import "fmt"

 var _ = fmt</p>
            
            <pre><code>InvalidPkgUse</code></pre>
         </article>
         
         <article class="global" data-name="BadImportPath">
            <h2>BadImportPath</h2>
            <hr />
            
            <p>BadImportPath occurs when an import path is not valid.</p>
            
            <pre><code>BadImportPath</code></pre>
         </article>
         
         <article class="global" data-name="BrokenImport">
            <h2>BrokenImport</h2>
            <hr />
            
            <p>BrokenImport occurs when importing a package fails.

Example:
 import "amissingpackage"</p>
            
            <pre><code>BrokenImport</code></pre>
         </article>
         
         <article class="global" data-name="ImportCRenamed">
            <h2>ImportCRenamed</h2>
            <hr />
            
            <p>ImportCRenamed occurs when the special import "C" is renamed. "C" is a
pseudo-package, and must not be renamed.

Example:
 import _ "C"</p>
            
            <pre><code>ImportCRenamed</code></pre>
         </article>
         
         <article class="global" data-name="UnusedImport">
            <h2>UnusedImport</h2>
            <hr />
            
            <p>UnusedImport occurs when an import is unused.

Example:
 import "fmt"

 func main() {}</p>
            
            <pre><code>UnusedImport</code></pre>
         </article>
         
         <article class="global" data-name="InvalidInitCycle">
            <h2>InvalidInitCycle</h2>
            <hr />
            
            <p>InvalidInitCycle occurs when an invalid cycle is detected within the
initialization graph.

Example:
 var x int = f()

 func f() int { return x }</p>
            
            <pre><code>InvalidInitCycle</code></pre>
         </article>
         
         <article class="global" data-name="DuplicateDecl">
            <h2>DuplicateDecl</h2>
            <hr />
            
            <p>DuplicateDecl occurs when an identifier is declared multiple times.

Example:
 var x = 1
 var x = 2</p>
            
            <pre><code>DuplicateDecl</code></pre>
         </article>
         
         <article class="global" data-name="InvalidDeclCycle">
            <h2>InvalidDeclCycle</h2>
            <hr />
            
            <p>InvalidDeclCycle occurs when a declaration cycle is not valid.

Example:
 import "unsafe"

 type T struct {
 	a [n]int
 }

 var n = unsafe.Sizeof(T{})</p>
            
            <pre><code>InvalidDeclCycle</code></pre>
         </article>
         
         <article class="global" data-name="InvalidTypeCycle">
            <h2>InvalidTypeCycle</h2>
            <hr />
            
            <p>InvalidTypeCycle occurs when a cycle in type definitions results in a
type that is not well-defined.

Example:
 import "unsafe"

 type T [unsafe.Sizeof(T{})]int</p>
            
            <pre><code>InvalidTypeCycle</code></pre>
         </article>
         
         <article class="global" data-name="InvalidConstInit">
            <h2>InvalidConstInit</h2>
            <hr />
            
            <p>InvalidConstInit occurs when a const declaration has a non-constant
initializer.

Example:
 var x int
 const _ = x</p>
            
            <pre><code>InvalidConstInit</code></pre>
         </article>
         
         <article class="global" data-name="InvalidConstVal">
            <h2>InvalidConstVal</h2>
            <hr />
            
            <p>InvalidConstVal occurs when a const value cannot be converted to its
target type.

TODO(findleyr): this error code and example are not very clear. Consider
removing it.

Example:
 const _ = 1 << "hello"</p>
            
            <pre><code>InvalidConstVal</code></pre>
         </article>
         
         <article class="global" data-name="InvalidConstType">
            <h2>InvalidConstType</h2>
            <hr />
            
            <p>InvalidConstType occurs when the underlying type in a const declaration
is not a valid constant type.

Example:
 const c *int = 4</p>
            
            <pre><code>InvalidConstType</code></pre>
         </article>
         
         <article class="global" data-name="UntypedNilUse">
            <h2>UntypedNilUse</h2>
            <hr />
            
            <p>UntypedNilUse occurs when the predeclared (untyped) value nil is used to
initialize a variable declared without an explicit type.

Example:
 var x = nil</p>
            
            <pre><code>UntypedNilUse</code></pre>
         </article>
         
         <article class="global" data-name="WrongAssignCount">
            <h2>WrongAssignCount</h2>
            <hr />
            
            <p>WrongAssignCount occurs when the number of values on the right-hand side
of an assignment or initialization expression does not match the number
of variables on the left-hand side.

Example:
 var x = 1, 2</p>
            
            <pre><code>WrongAssignCount</code></pre>
         </article>
         
         <article class="global" data-name="UnassignableOperand">
            <h2>UnassignableOperand</h2>
            <hr />
            
            <p>UnassignableOperand occurs when the left-hand side of an assignment is
not assignable.

Example:
 func f() {
 	const c = 1
 	c = 2
 }</p>
            
            <pre><code>UnassignableOperand</code></pre>
         </article>
         
         <article class="global" data-name="NoNewVar">
            <h2>NoNewVar</h2>
            <hr />
            
            <p>NoNewVar occurs when a short variable declaration (':=') does not declare
new variables.

Example:
 func f() {
 	x := 1
 	x := 2
 }</p>
            
            <pre><code>NoNewVar</code></pre>
         </article>
         
         <article class="global" data-name="MultiValAssignOp">
            <h2>MultiValAssignOp</h2>
            <hr />
            
            <p>MultiValAssignOp occurs when an assignment operation (+=, *=, etc) does
not have single-valued left-hand or right-hand side.

Per the spec:
 "In assignment operations, both the left- and right-hand expression lists
 must contain exactly one single-valued expression"

Example:
 func f() int {
 	x, y := 1, 2
 	x, y += 1
 	return x + y
 }</p>
            
            <pre><code>MultiValAssignOp</code></pre>
         </article>
         
         <article class="global" data-name="InvalidIfaceAssign">
            <h2>InvalidIfaceAssign</h2>
            <hr />
            
            <p>InvalidIfaceAssign occurs when a value of type T is used as an
interface, but T does not implement a method of the expected interface.

Example:
 type I interface {
 	f()
 }

 type T int

 var x I = T(1)</p>
            
            <pre><code>InvalidIfaceAssign</code></pre>
         </article>
         
         <article class="global" data-name="InvalidChanAssign">
            <h2>InvalidChanAssign</h2>
            <hr />
            
            <p>InvalidChanAssign occurs when a chan assignment is invalid.

Per the spec, a value x is assignable to a channel type T if:
 "x is a bidirectional channel value, T is a channel type, x's type V and
 T have identical element types, and at least one of V or T is not a
 defined type."

Example:
 type T1 chan int
 type T2 chan int

 var x T1
 // Invalid assignment because both types are named
 var _ T2 = x</p>
            
            <pre><code>InvalidChanAssign</code></pre>
         </article>
         
         <article class="global" data-name="IncompatibleAssign">
            <h2>IncompatibleAssign</h2>
            <hr />
            
            <p>IncompatibleAssign occurs when the type of the right-hand side expression
in an assignment cannot be assigned to the type of the variable being
assigned.

Example:
 var x []int
 var _ int = x</p>
            
            <pre><code>IncompatibleAssign</code></pre>
         </article>
         
         <article class="global" data-name="UnaddressableFieldAssign">
            <h2>UnaddressableFieldAssign</h2>
            <hr />
            
            <p>UnaddressableFieldAssign occurs when trying to assign to a struct field
in a map value.

Example:
 func f() {
 	m := make(map[string]struct{i int})
 	m["foo"].i = 42
 }</p>
            
            <pre><code>UnaddressableFieldAssign</code></pre>
         </article>
         
         <article class="global" data-name="NotAType">
            <h2>NotAType</h2>
            <hr />
            
            <p>NotAType occurs when the identifier used as the underlying type in a type
declaration or the right-hand side of a type alias does not denote a type.

Example:
 var S = 2

 type T S</p>
            
            <pre><code>NotAType</code></pre>
         </article>
         
         <article class="global" data-name="InvalidArrayLen">
            <h2>InvalidArrayLen</h2>
            <hr />
            
            <p>InvalidArrayLen occurs when an array length is not a constant value.

Example:
 var n = 3
 var _ = [n]int{}</p>
            
            <pre><code>InvalidArrayLen</code></pre>
         </article>
         
         <article class="global" data-name="BlankIfaceMethod">
            <h2>BlankIfaceMethod</h2>
            <hr />
            
            <p>BlankIfaceMethod occurs when a method name is '_'.

Per the spec:
 "The name of each explicitly specified method must be unique and not
 blank."

Example:
 type T interface {
 	_(int)
 }</p>
            
            <pre><code>BlankIfaceMethod</code></pre>
         </article>
         
         <article class="global" data-name="IncomparableMapKey">
            <h2>IncomparableMapKey</h2>
            <hr />
            
            <p>IncomparableMapKey occurs when a map key type does not support the == and
!= operators.

Per the spec:
 "The comparison operators == and != must be fully defined for operands of
 the key type; thus the key type must not be a function, map, or slice."

Example:
 var x map[T]int

 type T []int</p>
            
            <pre><code>IncomparableMapKey</code></pre>
         </article>
         
         <article class="global" data-name="InvalidIfaceEmbed">
            <h2>InvalidIfaceEmbed</h2>
            <hr />
            
            <p>InvalidIfaceEmbed occurs when a non-interface type is embedded in an
interface.

Example:
 type T struct {}

 func (T) m()

 type I interface {
 	T
 }</p>
            
            <pre><code>InvalidIfaceEmbed</code></pre>
         </article>
         
         <article class="global" data-name="InvalidPtrEmbed">
            <h2>InvalidPtrEmbed</h2>
            <hr />
            
            <p>InvalidPtrEmbed occurs when an embedded field is of the pointer form *T,
and T itself is itself a pointer, an unsafe.Pointer, or an interface.

Per the spec:
 "An embedded field must be specified as a type name T or as a pointer to
 a non-interface type name *T, and T itself may not be a pointer type."

Example:
 type T *int

 type S struct {
 	*T
 }</p>
            
            <pre><code>InvalidPtrEmbed</code></pre>
         </article>
         
         <article class="global" data-name="BadRecv">
            <h2>BadRecv</h2>
            <hr />
            
            <p>BadRecv occurs when a method declaration does not have exactly one
receiver parameter.

Example:
 func () _() {}</p>
            
            <pre><code>BadRecv</code></pre>
         </article>
         
         <article class="global" data-name="InvalidRecv">
            <h2>InvalidRecv</h2>
            <hr />
            
            <p>InvalidRecv occurs when a receiver type expression is not of the form T
or *T, or T is a pointer type.

Example:
 type T struct {}

 func (**T) m() {}</p>
            
            <pre><code>InvalidRecv</code></pre>
         </article>
         
         <article class="global" data-name="DuplicateFieldAndMethod">
            <h2>DuplicateFieldAndMethod</h2>
            <hr />
            
            <p>DuplicateFieldAndMethod occurs when an identifier appears as both a field
and method name.

Example:
 type T struct {
 	m int
 }

 func (T) m() {}</p>
            
            <pre><code>DuplicateFieldAndMethod</code></pre>
         </article>
         
         <article class="global" data-name="DuplicateMethod">
            <h2>DuplicateMethod</h2>
            <hr />
            
            <p>DuplicateMethod occurs when two methods on the same receiver type have
the same name.

Example:
 type T struct {}
 func (T) m() {}
 func (T) m(i int) int { return i }</p>
            
            <pre><code>DuplicateMethod</code></pre>
         </article>
         
         <article class="global" data-name="InvalidBlank">
            <h2>InvalidBlank</h2>
            <hr />
            
            <p>InvalidBlank occurs when a blank identifier is used as a value or type.

Per the spec:
 "The blank identifier may appear as an operand only on the left-hand side
 of an assignment."

Example:
 var x = _</p>
            
            <pre><code>InvalidBlank</code></pre>
         </article>
         
         <article class="global" data-name="InvalidIota">
            <h2>InvalidIota</h2>
            <hr />
            
            <p>InvalidIota occurs when the predeclared identifier iota is used outside
of a constant declaration.

Example:
 var x = iota</p>
            
            <pre><code>InvalidIota</code></pre>
         </article>
         
         <article class="global" data-name="MissingInitBody">
            <h2>MissingInitBody</h2>
            <hr />
            
            <p>MissingInitBody occurs when an init function is missing its body.

Example:
 func init()</p>
            
            <pre><code>MissingInitBody</code></pre>
         </article>
         
         <article class="global" data-name="InvalidInitSig">
            <h2>InvalidInitSig</h2>
            <hr />
            
            <p>InvalidInitSig occurs when an init function declares parameters or
results.

Example:
 func init() int { return 1 }</p>
            
            <pre><code>InvalidInitSig</code></pre>
         </article>
         
         <article class="global" data-name="InvalidInitDecl">
            <h2>InvalidInitDecl</h2>
            <hr />
            
            <p>InvalidInitDecl occurs when init is declared as anything other than a
function.

Example:
 var init = 1</p>
            
            <pre><code>InvalidInitDecl</code></pre>
         </article>
         
         <article class="global" data-name="InvalidMainDecl">
            <h2>InvalidMainDecl</h2>
            <hr />
            
            <p>InvalidMainDecl occurs when main is declared as anything other than a
function, in a main package.</p>
            
            <pre><code>InvalidMainDecl</code></pre>
         </article>
         
         <article class="global" data-name="TooManyValues">
            <h2>TooManyValues</h2>
            <hr />
            
            <p>TooManyValues occurs when a function returns too many values for the
expression context in which it is used.

Example:
 func ReturnTwo() (int, int) {
 	return 1, 2
 }

 var x = ReturnTwo()</p>
            
            <pre><code>TooManyValues</code></pre>
         </article>
         
         <article class="global" data-name="NotAnExpr">
            <h2>NotAnExpr</h2>
            <hr />
            
            <p>NotAnExpr occurs when a type expression is used where a value expression
is expected.

Example:
 type T struct {}

 func f() {
 	T
 }</p>
            
            <pre><code>NotAnExpr</code></pre>
         </article>
         
         <article class="global" data-name="TruncatedFloat">
            <h2>TruncatedFloat</h2>
            <hr />
            
            <p>TruncatedFloat occurs when a float constant is truncated to an integer
value.

Example:
 var _ int = 98.6</p>
            
            <pre><code>TruncatedFloat</code></pre>
         </article>
         
         <article class="global" data-name="NumericOverflow">
            <h2>NumericOverflow</h2>
            <hr />
            
            <p>NumericOverflow occurs when a numeric constant overflows its target type.

Example:
 var x int8 = 1000</p>
            
            <pre><code>NumericOverflow</code></pre>
         </article>
         
         <article class="global" data-name="UndefinedOp">
            <h2>UndefinedOp</h2>
            <hr />
            
            <p>UndefinedOp occurs when an operator is not defined for the type(s) used
in an operation.

Example:
 var c = "a" - "b"</p>
            
            <pre><code>UndefinedOp</code></pre>
         </article>
         
         <article class="global" data-name="MismatchedTypes">
            <h2>MismatchedTypes</h2>
            <hr />
            
            <p>MismatchedTypes occurs when operand types are incompatible in a binary
operation.

Example:
 var a = "hello"
 var b = 1
 var c = a - b</p>
            
            <pre><code>MismatchedTypes</code></pre>
         </article>
         
         <article class="global" data-name="DivByZero">
            <h2>DivByZero</h2>
            <hr />
            
            <p>DivByZero occurs when a division operation is provable at compile
time to be a division by zero.

Example:
 const divisor = 0
 var x int = 1/divisor</p>
            
            <pre><code>DivByZero</code></pre>
         </article>
         
         <article class="global" data-name="NonNumericIncDec">
            <h2>NonNumericIncDec</h2>
            <hr />
            
            <p>NonNumericIncDec occurs when an increment or decrement operator is
applied to a non-numeric value.

Example:
 func f() {
 	var c = "c"
 	c++
 }</p>
            
            <pre><code>NonNumericIncDec</code></pre>
         </article>
         
         <article class="global" data-name="UnaddressableOperand">
            <h2>UnaddressableOperand</h2>
            <hr />
            
            <p>UnaddressableOperand occurs when the & operator is applied to an
unaddressable expression.

Example:
 var x = &1</p>
            
            <pre><code>UnaddressableOperand</code></pre>
         </article>
         
         <article class="global" data-name="InvalidIndirection">
            <h2>InvalidIndirection</h2>
            <hr />
            
            <p>InvalidIndirection occurs when a non-pointer value is indirected via the
'*' operator.

Example:
 var x int
 var y = *x</p>
            
            <pre><code>InvalidIndirection</code></pre>
         </article>
         
         <article class="global" data-name="NonIndexableOperand">
            <h2>NonIndexableOperand</h2>
            <hr />
            
            <p>NonIndexableOperand occurs when an index operation is applied to a value
that cannot be indexed.

Example:
 var x = 1
 var y = x[1]</p>
            
            <pre><code>NonIndexableOperand</code></pre>
         </article>
         
         <article class="global" data-name="InvalidIndex">
            <h2>InvalidIndex</h2>
            <hr />
            
            <p>InvalidIndex occurs when an index argument is not of integer type,
negative, or out-of-bounds.

Example:
 var s = [...]int{1,2,3}
 var x = s[5]

Example:
 var s = []int{1,2,3}
 var _ = s[-1]

Example:
 var s = []int{1,2,3}
 var i string
 var _ = s[i]</p>
            
            <pre><code>InvalidIndex</code></pre>
         </article>
         
         <article class="global" data-name="SwappedSliceIndices">
            <h2>SwappedSliceIndices</h2>
            <hr />
            
            <p>SwappedSliceIndices occurs when constant indices in a slice expression
are decreasing in value.

Example:
 var _ = []int{1,2,3}[2:1]</p>
            
            <pre><code>SwappedSliceIndices</code></pre>
         </article>
         
         <article class="global" data-name="NonSliceableOperand">
            <h2>NonSliceableOperand</h2>
            <hr />
            
            <p>NonSliceableOperand occurs when a slice operation is applied to a value
whose type is not sliceable, or is unaddressable.

Example:
 var x = [...]int{1, 2, 3}[:1]

Example:
 var x = 1
 var y = 1[:1]</p>
            
            <pre><code>NonSliceableOperand</code></pre>
         </article>
         
         <article class="global" data-name="InvalidSliceExpr">
            <h2>InvalidSliceExpr</h2>
            <hr />
            
            <p>InvalidSliceExpr occurs when a three-index slice expression (a[x:y:z]) is
applied to a string.

Example:
 var s = "hello"
 var x = s[1:2:3]</p>
            
            <pre><code>InvalidSliceExpr</code></pre>
         </article>
         
         <article class="global" data-name="InvalidShiftCount">
            <h2>InvalidShiftCount</h2>
            <hr />
            
            <p>InvalidShiftCount occurs when the right-hand side of a shift operation is
either non-integer, negative, or too large.

Example:
 var (
 	x string
 	y int = 1 << x
 )</p>
            
            <pre><code>InvalidShiftCount</code></pre>
         </article>
         
         <article class="global" data-name="InvalidShiftOperand">
            <h2>InvalidShiftOperand</h2>
            <hr />
            
            <p>InvalidShiftOperand occurs when the shifted operand is not an integer.

Example:
 var s = "hello"
 var x = s << 2</p>
            
            <pre><code>InvalidShiftOperand</code></pre>
         </article>
         
         <article class="global" data-name="InvalidReceive">
            <h2>InvalidReceive</h2>
            <hr />
            
            <p>InvalidReceive occurs when there is a channel receive from a value that
is either not a channel, or is a send-only channel.

Example:
 func f() {
 	var x = 1
 	<-x
 }</p>
            
            <pre><code>InvalidReceive</code></pre>
         </article>
         
         <article class="global" data-name="InvalidSend">
            <h2>InvalidSend</h2>
            <hr />
            
            <p>InvalidSend occurs when there is a channel send to a value that is not a
channel, or is a receive-only channel.

Example:
 func f() {
 	var x = 1
 	x <- "hello!"
 }</p>
            
            <pre><code>InvalidSend</code></pre>
         </article>
         
         <article class="global" data-name="DuplicateLitKey">
            <h2>DuplicateLitKey</h2>
            <hr />
            
            <p>DuplicateLitKey occurs when an index is duplicated in a slice, array, or
map literal.

Example:
 var _ = []int{0:1, 0:2}

Example:
 var _ = map[string]int{"a": 1, "a": 2}</p>
            
            <pre><code>DuplicateLitKey</code></pre>
         </article>
         
         <article class="global" data-name="MissingLitKey">
            <h2>MissingLitKey</h2>
            <hr />
            
            <p>MissingLitKey occurs when a map literal is missing a key expression.

Example:
 var _ = map[string]int{1}</p>
            
            <pre><code>MissingLitKey</code></pre>
         </article>
         
         <article class="global" data-name="InvalidLitIndex">
            <h2>InvalidLitIndex</h2>
            <hr />
            
            <p>InvalidLitIndex occurs when the key in a key-value element of a slice or
array literal is not an integer constant.

Example:
 var i = 0
 var x = []string{i: "world"}</p>
            
            <pre><code>InvalidLitIndex</code></pre>
         </article>
         
         <article class="global" data-name="OversizeArrayLit">
            <h2>OversizeArrayLit</h2>
            <hr />
            
            <p>OversizeArrayLit occurs when an array literal exceeds its length.

Example:
 var _ = [2]int{1,2,3}</p>
            
            <pre><code>OversizeArrayLit</code></pre>
         </article>
         
         <article class="global" data-name="MixedStructLit">
            <h2>MixedStructLit</h2>
            <hr />
            
            <p>MixedStructLit occurs when a struct literal contains a mix of positional
and named elements.

Example:
 var _ = struct{i, j int}{i: 1, 2}</p>
            
            <pre><code>MixedStructLit</code></pre>
         </article>
         
         <article class="global" data-name="InvalidStructLit">
            <h2>InvalidStructLit</h2>
            <hr />
            
            <p>InvalidStructLit occurs when a positional struct literal has an incorrect
number of values.

Example:
 var _ = struct{i, j int}{1,2,3}</p>
            
            <pre><code>InvalidStructLit</code></pre>
         </article>
         
         <article class="global" data-name="MissingLitField">
            <h2>MissingLitField</h2>
            <hr />
            
            <p>MissingLitField occurs when a struct literal refers to a field that does
not exist on the struct type.

Example:
 var _ = struct{i int}{j: 2}</p>
            
            <pre><code>MissingLitField</code></pre>
         </article>
         
         <article class="global" data-name="DuplicateLitField">
            <h2>DuplicateLitField</h2>
            <hr />
            
            <p>DuplicateLitField occurs when a struct literal contains duplicated
fields.

Example:
 var _ = struct{i int}{i: 1, i: 2}</p>
            
            <pre><code>DuplicateLitField</code></pre>
         </article>
         
         <article class="global" data-name="UnexportedLitField">
            <h2>UnexportedLitField</h2>
            <hr />
            
            <p>UnexportedLitField occurs when a positional struct literal implicitly
assigns an unexported field of an imported type.</p>
            
            <pre><code>UnexportedLitField</code></pre>
         </article>
         
         <article class="global" data-name="InvalidLitField">
            <h2>InvalidLitField</h2>
            <hr />
            
            <p>InvalidLitField occurs when a field name is not a valid identifier.

Example:
 var _ = struct{i int}{1: 1}</p>
            
            <pre><code>InvalidLitField</code></pre>
         </article>
         
         <article class="global" data-name="UntypedLit">
            <h2>UntypedLit</h2>
            <hr />
            
            <p>UntypedLit occurs when a composite literal omits a required type
identifier.

Example:
 type outer struct{
 	inner struct { i int }
 }

 var _ = outer{inner: {1}}</p>
            
            <pre><code>UntypedLit</code></pre>
         </article>
         
         <article class="global" data-name="InvalidLit">
            <h2>InvalidLit</h2>
            <hr />
            
            <p>InvalidLit occurs when a composite literal expression does not match its
type.

Example:
 type P *struct{
 	x int
 }
 var _ = P {}</p>
            
            <pre><code>InvalidLit</code></pre>
         </article>
         
         <article class="global" data-name="AmbiguousSelector">
            <h2>AmbiguousSelector</h2>
            <hr />
            
            <p>AmbiguousSelector occurs when a selector is ambiguous.

Example:
 type E1 struct { i int }
 type E2 struct { i int }
 type T struct { E1; E2 }

 var x T
 var _ = x.i</p>
            
            <pre><code>AmbiguousSelector</code></pre>
         </article>
         
         <article class="global" data-name="UndeclaredImportedName">
            <h2>UndeclaredImportedName</h2>
            <hr />
            
            <p>UndeclaredImportedName occurs when a package-qualified identifier is
undeclared by the imported package.

Example:
 import "go/types"

 var _ = types.NotAnActualIdentifier</p>
            
            <pre><code>UndeclaredImportedName</code></pre>
         </article>
         
         <article class="global" data-name="UnexportedName">
            <h2>UnexportedName</h2>
            <hr />
            
            <p>UnexportedName occurs when a selector refers to an unexported identifier
of an imported package.

Example:
 import "reflect"

 type _ reflect.flag</p>
            
            <pre><code>UnexportedName</code></pre>
         </article>
         
         <article class="global" data-name="UndeclaredName">
            <h2>UndeclaredName</h2>
            <hr />
            
            <p>UndeclaredName occurs when an identifier is not declared in the current
scope.

Example:
 var x T</p>
            
            <pre><code>UndeclaredName</code></pre>
         </article>
         
         <article class="global" data-name="MissingFieldOrMethod">
            <h2>MissingFieldOrMethod</h2>
            <hr />
            
            <p>MissingFieldOrMethod occurs when a selector references a field or method
that does not exist.

Example:
 type T struct {}

 var x = T{}.f</p>
            
            <pre><code>MissingFieldOrMethod</code></pre>
         </article>
         
         <article class="global" data-name="BadDotDotDotSyntax">
            <h2>BadDotDotDotSyntax</h2>
            <hr />
            
            <p>BadDotDotDotSyntax occurs when a "..." occurs in a context where it is
not valid.

Example:
 var _ = map[int][...]int{0: {}}</p>
            
            <pre><code>BadDotDotDotSyntax</code></pre>
         </article>
         
         <article class="global" data-name="NonVariadicDotDotDot">
            <h2>NonVariadicDotDotDot</h2>
            <hr />
            
            <p>NonVariadicDotDotDot occurs when a "..." is used on the final argument to
a non-variadic function.

Example:
 func printArgs(s []string) {
 	for _, a := range s {
 		println(a)
 	}
 }

 func f() {
 	s := []string{"a", "b", "c"}
 	printArgs(s...)
 }</p>
            
            <pre><code>NonVariadicDotDotDot</code></pre>
         </article>
         
         <article class="global" data-name="MisplacedDotDotDot">
            <h2>MisplacedDotDotDot</h2>
            <hr />
            
            <p>MisplacedDotDotDot occurs when a "..." is used somewhere other than the
final argument to a function call.

Example:
 func printArgs(args ...int) {
 	for _, a := range args {
 		println(a)
 	}
 }

 func f() {
 	a := []int{1,2,3}
 	printArgs(0, a...)
 }</p>
            
            <pre><code>MisplacedDotDotDot</code></pre>
         </article>
         
         <article class="global" data-name="InvalidDotDotDotOperand">
            <h2>InvalidDotDotDotOperand</h2>
            <hr />
            
            <p>InvalidDotDotDotOperand occurs when a "..." operator is applied to a
single-valued operand.

Example:
 func printArgs(args ...int) {
 	for _, a := range args {
 		println(a)
 	}
 }

 func f() {
 	a := 1
 	printArgs(a...)
 }

Example:
 func args() (int, int) {
 	return 1, 2
 }

 func printArgs(args ...int) {
 	for _, a := range args {
 		println(a)
 	}
 }

 func g() {
 	printArgs(args()...)
 }</p>
            
            <pre><code>InvalidDotDotDotOperand</code></pre>
         </article>
         
         <article class="global" data-name="InvalidDotDotDot">
            <h2>InvalidDotDotDot</h2>
            <hr />
            
            <p>InvalidDotDotDot occurs when a "..." is used in a non-variadic built-in
function.

Example:
 var s = []int{1, 2, 3}
 var l = len(s...)</p>
            
            <pre><code>InvalidDotDotDot</code></pre>
         </article>
         
         <article class="global" data-name="UncalledBuiltin">
            <h2>UncalledBuiltin</h2>
            <hr />
            
            <p>UncalledBuiltin occurs when a built-in function is used as a
function-valued expression, instead of being called.

Per the spec:
 "The built-in functions do not have standard Go types, so they can only
 appear in call expressions; they cannot be used as function values."

Example:
 var _ = copy</p>
            
            <pre><code>UncalledBuiltin</code></pre>
         </article>
         
         <article class="global" data-name="InvalidAppend">
            <h2>InvalidAppend</h2>
            <hr />
            
            <p>InvalidAppend occurs when append is called with a first argument that is
not a slice.

Example:
 var _ = append(1, 2)</p>
            
            <pre><code>InvalidAppend</code></pre>
         </article>
         
         <article class="global" data-name="InvalidCap">
            <h2>InvalidCap</h2>
            <hr />
            
            <p>InvalidCap occurs when an argument to the cap built-in function is not of
supported type.

See https://golang.org/ref/spec#Length_and_capacity for information on
which underlying types are supported as arguments to cap and len.

Example:
 var s = 2
 var x = cap(s)</p>
            
            <pre><code>InvalidCap</code></pre>
         </article>
         
         <article class="global" data-name="InvalidClose">
            <h2>InvalidClose</h2>
            <hr />
            
            <p>InvalidClose occurs when close(...) is called with an argument that is
not of channel type, or that is a receive-only channel.

Example:
 func f() {
 	var x int
 	close(x)
 }</p>
            
            <pre><code>InvalidClose</code></pre>
         </article>
         
         <article class="global" data-name="InvalidCopy">
            <h2>InvalidCopy</h2>
            <hr />
            
            <p>InvalidCopy occurs when the arguments are not of slice type or do not
have compatible type.

See https://golang.org/ref/spec#Appending_and_copying_slices for more
information on the type requirements for the copy built-in.

Example:
 func f() {
 	var x []int
 	y := []int64{1,2,3}
 	copy(x, y)
 }</p>
            
            <pre><code>InvalidCopy</code></pre>
         </article>
         
         <article class="global" data-name="InvalidComplex">
            <h2>InvalidComplex</h2>
            <hr />
            
            <p>InvalidComplex occurs when the complex built-in function is called with
arguments with incompatible types.

Example:
 var _ = complex(float32(1), float64(2))</p>
            
            <pre><code>InvalidComplex</code></pre>
         </article>
         
         <article class="global" data-name="InvalidDelete">
            <h2>InvalidDelete</h2>
            <hr />
            
            <p>InvalidDelete occurs when the delete built-in function is called with a
first argument that is not a map.

Example:
 func f() {
 	m := "hello"
 	delete(m, "e")
 }</p>
            
            <pre><code>InvalidDelete</code></pre>
         </article>
         
         <article class="global" data-name="InvalidImag">
            <h2>InvalidImag</h2>
            <hr />
            
            <p>InvalidImag occurs when the imag built-in function is called with an
argument that does not have complex type.

Example:
 var _ = imag(int(1))</p>
            
            <pre><code>InvalidImag</code></pre>
         </article>
         
         <article class="global" data-name="InvalidLen">
            <h2>InvalidLen</h2>
            <hr />
            
            <p>InvalidLen occurs when an argument to the len built-in function is not of
supported type.

See https://golang.org/ref/spec#Length_and_capacity for information on
which underlying types are supported as arguments to cap and len.

Example:
 var s = 2
 var x = len(s)</p>
            
            <pre><code>InvalidLen</code></pre>
         </article>
         
         <article class="global" data-name="SwappedMakeArgs">
            <h2>SwappedMakeArgs</h2>
            <hr />
            
            <p>SwappedMakeArgs occurs when make is called with three arguments, and its
length argument is larger than its capacity argument.

Example:
 var x = make([]int, 3, 2)</p>
            
            <pre><code>SwappedMakeArgs</code></pre>
         </article>
         
         <article class="global" data-name="InvalidMake">
            <h2>InvalidMake</h2>
            <hr />
            
            <p>InvalidMake occurs when make is called with an unsupported type argument.

See https://golang.org/ref/spec#Making_slices_maps_and_channels for
information on the types that may be created using make.

Example:
 var x = make(int)</p>
            
            <pre><code>InvalidMake</code></pre>
         </article>
         
         <article class="global" data-name="InvalidReal">
            <h2>InvalidReal</h2>
            <hr />
            
            <p>InvalidReal occurs when the real built-in function is called with an
argument that does not have complex type.

Example:
 var _ = real(int(1))</p>
            
            <pre><code>InvalidReal</code></pre>
         </article>
         
         <article class="global" data-name="InvalidAssert">
            <h2>InvalidAssert</h2>
            <hr />
            
            <p>InvalidAssert occurs when a type assertion is applied to a
value that is not of interface type.

Example:
 var x = 1
 var _ = x.(float64)</p>
            
            <pre><code>InvalidAssert</code></pre>
         </article>
         
         <article class="global" data-name="ImpossibleAssert">
            <h2>ImpossibleAssert</h2>
            <hr />
            
            <p>ImpossibleAssert occurs for a type assertion x.(T) when the value x of
interface cannot have dynamic type T, due to a missing or mismatching
method on T.

Example:
 type T int

 func (t *T) m() int { return int(*t) }

 type I interface { m() int }

 var x I
 var _ = x.(T)</p>
            
            <pre><code>ImpossibleAssert</code></pre>
         </article>
         
         <article class="global" data-name="InvalidConversion">
            <h2>InvalidConversion</h2>
            <hr />
            
            <p>InvalidConversion occurs when the argument type cannot be converted to the
target.

See https://golang.org/ref/spec#Conversions for the rules of
convertibility.

Example:
 var x float64
 var _ = string(x)</p>
            
            <pre><code>InvalidConversion</code></pre>
         </article>
         
         <article class="global" data-name="InvalidUntypedConversion">
            <h2>InvalidUntypedConversion</h2>
            <hr />
            
            <p>InvalidUntypedConversion occurs when an there is no valid implicit
conversion from an untyped value satisfying the type constraints of the
context in which it is used.

Example:
 var _ = 1 + ""</p>
            
            <pre><code>InvalidUntypedConversion</code></pre>
         </article>
         
         <article class="global" data-name="BadOffsetofSyntax">
            <h2>BadOffsetofSyntax</h2>
            <hr />
            
            <p>BadOffsetofSyntax occurs when unsafe.Offsetof is called with an argument
that is not a selector expression.

Example:
 import "unsafe"

 var x int
 var _ = unsafe.Offsetof(x)</p>
            
            <pre><code>BadOffsetofSyntax</code></pre>
         </article>
         
         <article class="global" data-name="InvalidOffsetof">
            <h2>InvalidOffsetof</h2>
            <hr />
            
            <p>InvalidOffsetof occurs when unsafe.Offsetof is called with a method
selector, rather than a field selector, or when the field is embedded via
a pointer.

Per the spec:

 "If f is an embedded field, it must be reachable without pointer
 indirections through fields of the struct. "

Example:
 import "unsafe"

 type T struct { f int }
 type S struct { *T }
 var s S
 var _ = unsafe.Offsetof(s.f)

Example:
 import "unsafe"

 type S struct{}

 func (S) m() {}

 var s S
 var _ = unsafe.Offsetof(s.m)</p>
            
            <pre><code>InvalidOffsetof</code></pre>
         </article>
         
         <article class="global" data-name="UnusedExpr">
            <h2>UnusedExpr</h2>
            <hr />
            
            <p>UnusedExpr occurs when a side-effect free expression is used as a
statement. Such a statement has no effect.

Example:
 func f(i int) {
 	i*i
 }</p>
            
            <pre><code>UnusedExpr</code></pre>
         </article>
         
         <article class="global" data-name="UnusedVar">
            <h2>UnusedVar</h2>
            <hr />
            
            <p>UnusedVar occurs when a variable is declared but unused.

Example:
 func f() {
 	x := 1
 }</p>
            
            <pre><code>UnusedVar</code></pre>
         </article>
         
         <article class="global" data-name="MissingReturn">
            <h2>MissingReturn</h2>
            <hr />
            
            <p>MissingReturn occurs when a function with results is missing a return
statement.

Example:
 func f() int {}</p>
            
            <pre><code>MissingReturn</code></pre>
         </article>
         
         <article class="global" data-name="WrongResultCount">
            <h2>WrongResultCount</h2>
            <hr />
            
            <p>WrongResultCount occurs when a return statement returns an incorrect
number of values.

Example:
 func ReturnOne() int {
 	return 1, 2
 }</p>
            
            <pre><code>WrongResultCount</code></pre>
         </article>
         
         <article class="global" data-name="OutOfScopeResult">
            <h2>OutOfScopeResult</h2>
            <hr />
            
            <p>OutOfScopeResult occurs when the name of a value implicitly returned by
an empty return statement is shadowed in a nested scope.

Example:
 func factor(n int) (i int) {
 	for i := 2; i < n; i++ {
 		if n%i == 0 {
 			return
 		}
 	}
 	return 0
 }</p>
            
            <pre><code>OutOfScopeResult</code></pre>
         </article>
         
         <article class="global" data-name="InvalidCond">
            <h2>InvalidCond</h2>
            <hr />
            
            <p>InvalidCond occurs when an if condition is not a boolean expression.

Example:
 func checkReturn(i int) {
 	if i {
 		panic("non-zero return")
 	}
 }</p>
            
            <pre><code>InvalidCond</code></pre>
         </article>
         
         <article class="global" data-name="InvalidPostDecl">
            <h2>InvalidPostDecl</h2>
            <hr />
            
            <p>InvalidPostDecl occurs when there is a declaration in a for-loop post
statement.

Example:
 func f() {
 	for i := 0; i < 10; j := 0 {}
 }</p>
            
            <pre><code>InvalidPostDecl</code></pre>
         </article>
         
         <article class="global" data-name="InvalidChanRange">
            <h2>InvalidChanRange</h2>
            <hr />
            
            <p>InvalidChanRange occurs when a send-only channel used in a range
expression.

Example:
 func sum(c chan<- int) {
 	s := 0
 	for i := range c {
 		s += i
 	}
 }</p>
            
            <pre><code>InvalidChanRange</code></pre>
         </article>
         
         <article class="global" data-name="InvalidIterVar">
            <h2>InvalidIterVar</h2>
            <hr />
            
            <p>InvalidIterVar occurs when two iteration variables are used while ranging
over a channel.

Example:
 func f(c chan int) {
 	for k, v := range c {
 		println(k, v)
 	}
 }</p>
            
            <pre><code>InvalidIterVar</code></pre>
         </article>
         
         <article class="global" data-name="InvalidRangeExpr">
            <h2>InvalidRangeExpr</h2>
            <hr />
            
            <p>InvalidRangeExpr occurs when the type of a range expression is not array,
slice, string, map, or channel.

Example:
 func f(i int) {
 	for j := range i {
 		println(j)
 	}
 }</p>
            
            <pre><code>InvalidRangeExpr</code></pre>
         </article>
         
         <article class="global" data-name="MisplacedBreak">
            <h2>MisplacedBreak</h2>
            <hr />
            
            <p>MisplacedBreak occurs when a break statement is not within a for, switch,
or select statement of the innermost function definition.

Example:
 func f() {
 	break
 }</p>
            
            <pre><code>MisplacedBreak</code></pre>
         </article>
         
         <article class="global" data-name="MisplacedContinue">
            <h2>MisplacedContinue</h2>
            <hr />
            
            <p>MisplacedContinue occurs when a continue statement is not within a for
loop of the innermost function definition.

Example:
 func sumeven(n int) int {
 	proceed := func() {
 		continue
 	}
 	sum := 0
 	for i := 1; i <= n; i++ {
 		if i % 2 != 0 {
 			proceed()
 		}
 		sum += i
 	}
 	return sum
 }</p>
            
            <pre><code>MisplacedContinue</code></pre>
         </article>
         
         <article class="global" data-name="MisplacedFallthrough">
            <h2>MisplacedFallthrough</h2>
            <hr />
            
            <p>MisplacedFallthrough occurs when a fallthrough statement is not within an
expression switch.

Example:
 func typename(i interface{}) string {
 	switch i.(type) {
 	case int64:
 		fallthrough
 	case int:
 		return "int"
 	}
 	return "unsupported"
 }</p>
            
            <pre><code>MisplacedFallthrough</code></pre>
         </article>
         
         <article class="global" data-name="DuplicateCase">
            <h2>DuplicateCase</h2>
            <hr />
            
            <p>DuplicateCase occurs when a type or expression switch has duplicate
cases.

Example:
 func printInt(i int) {
 	switch i {
 	case 1:
 		println("one")
 	case 1:
 		println("One")
 	}
 }</p>
            
            <pre><code>DuplicateCase</code></pre>
         </article>
         
         <article class="global" data-name="DuplicateDefault">
            <h2>DuplicateDefault</h2>
            <hr />
            
            <p>DuplicateDefault occurs when a type or expression switch has multiple
default clauses.

Example:
 func printInt(i int) {
 	switch i {
 	case 1:
 		println("one")
 	default:
 		println("One")
 	default:
 		println("1")
 	}
 }</p>
            
            <pre><code>DuplicateDefault</code></pre>
         </article>
         
         <article class="global" data-name="BadTypeKeyword">
            <h2>BadTypeKeyword</h2>
            <hr />
            
            <p>BadTypeKeyword occurs when a .(type) expression is used anywhere other
than a type switch.

Example:
 type I interface {
 	m()
 }
 var t I
 var _ = t.(type)</p>
            
            <pre><code>BadTypeKeyword</code></pre>
         </article>
         
         <article class="global" data-name="InvalidTypeSwitch">
            <h2>InvalidTypeSwitch</h2>
            <hr />
            
            <p>InvalidTypeSwitch occurs when .(type) is used on an expression that is
not of interface type.

Example:
 func f(i int) {
 	switch x := i.(type) {}
 }</p>
            
            <pre><code>InvalidTypeSwitch</code></pre>
         </article>
         
         <article class="global" data-name="InvalidExprSwitch">
            <h2>InvalidExprSwitch</h2>
            <hr />
            
            <p>InvalidExprSwitch occurs when a switch expression is not comparable.

Example:
 func _() {
 	var a struct{ _ func() }
 	switch a /* ERROR cannot switch on a */ {
 	}
 }</p>
            
            <pre><code>InvalidExprSwitch</code></pre>
         </article>
         
         <article class="global" data-name="InvalidSelectCase">
            <h2>InvalidSelectCase</h2>
            <hr />
            
            <p>InvalidSelectCase occurs when a select case is not a channel send or
receive.

Example:
 func checkChan(c <-chan int) bool {
 	select {
 	case c:
 		return true
 	default:
 		return false
 	}
 }</p>
            
            <pre><code>InvalidSelectCase</code></pre>
         </article>
         
         <article class="global" data-name="UndeclaredLabel">
            <h2>UndeclaredLabel</h2>
            <hr />
            
            <p>UndeclaredLabel occurs when an undeclared label is jumped to.

Example:
 func f() {
 	goto L
 }</p>
            
            <pre><code>UndeclaredLabel</code></pre>
         </article>
         
         <article class="global" data-name="DuplicateLabel">
            <h2>DuplicateLabel</h2>
            <hr />
            
            <p>DuplicateLabel occurs when a label is declared more than once.

Example:
 func f() int {
 L:
 L:
 	return 1
 }</p>
            
            <pre><code>DuplicateLabel</code></pre>
         </article>
         
         <article class="global" data-name="MisplacedLabel">
            <h2>MisplacedLabel</h2>
            <hr />
            
            <p>MisplacedLabel occurs when a break or continue label is not on a for,
switch, or select statement.

Example:
 func f() {
 L:
 	a := []int{1,2,3}
 	for _, e := range a {
 		if e > 10 {
 			break L
 		}
 		println(a)
 	}
 }</p>
            
            <pre><code>MisplacedLabel</code></pre>
         </article>
         
         <article class="global" data-name="UnusedLabel">
            <h2>UnusedLabel</h2>
            <hr />
            
            <p>UnusedLabel occurs when a label is declared but not used.

Example:
 func f() {
 L:
 }</p>
            
            <pre><code>UnusedLabel</code></pre>
         </article>
         
         <article class="global" data-name="JumpOverDecl">
            <h2>JumpOverDecl</h2>
            <hr />
            
            <p>JumpOverDecl occurs when a label jumps over a variable declaration.

Example:
 func f() int {
 	goto L
 	x := 2
 L:
 	x++
 	return x
 }</p>
            
            <pre><code>JumpOverDecl</code></pre>
         </article>
         
         <article class="global" data-name="JumpIntoBlock">
            <h2>JumpIntoBlock</h2>
            <hr />
            
            <p>JumpIntoBlock occurs when a forward jump goes to a label inside a nested
block.

Example:
 func f(x int) {
 	goto L
 	if x > 0 {
 	L:
 		print("inside block")
 	}
}</p>
            
            <pre><code>JumpIntoBlock</code></pre>
         </article>
         
         <article class="global" data-name="InvalidMethodExpr">
            <h2>InvalidMethodExpr</h2>
            <hr />
            
            <p>InvalidMethodExpr occurs when a pointer method is called but the argument
is not addressable.

Example:
 type T struct {}

 func (*T) m() int { return 1 }

 var _ = T.m(T{})</p>
            
            <pre><code>InvalidMethodExpr</code></pre>
         </article>
         
         <article class="global" data-name="WrongArgCount">
            <h2>WrongArgCount</h2>
            <hr />
            
            <p>WrongArgCount occurs when too few or too many arguments are passed by a
function call.

Example:
 func f(i int) {}
 var x = f()</p>
            
            <pre><code>WrongArgCount</code></pre>
         </article>
         
         <article class="global" data-name="InvalidCall">
            <h2>InvalidCall</h2>
            <hr />
            
            <p>InvalidCall occurs when an expression is called that is not of function
type.

Example:
 var x = "x"
 var y = x()</p>
            
            <pre><code>InvalidCall</code></pre>
         </article>
         
         <article class="global" data-name="UnusedResults">
            <h2>UnusedResults</h2>
            <hr />
            
            <p>UnusedResults occurs when a restricted expression-only built-in function
is suspended via go or defer. Such a suspension discards the results of
these side-effect free built-in functions, and therefore is ineffectual.

Example:
 func f(a []int) int {
 	defer len(a)
 	return i
 }</p>
            
            <pre><code>UnusedResults</code></pre>
         </article>
         
         <article class="global" data-name="InvalidDefer">
            <h2>InvalidDefer</h2>
            <hr />
            
            <p>InvalidDefer occurs when a deferred expression is not a function call,
for example if the expression is a type conversion.

Example:
 func f(i int) int {
 	defer int32(i)
 	return i
 }</p>
            
            <pre><code>InvalidDefer</code></pre>
         </article>
         
         <article class="global" data-name="InvalidGo">
            <h2>InvalidGo</h2>
            <hr />
            
            <p>InvalidGo occurs when a go expression is not a function call, for example
if the expression is a type conversion.

Example:
 func f(i int) int {
 	go int32(i)
 	return i
 }</p>
            
            <pre><code>InvalidGo</code></pre>
         </article>
         
         <article class="global" data-name="BadDecl">
            <h2>BadDecl</h2>
            <hr />
            
            <p>BadDecl occurs when a declaration has invalid syntax.</p>
            
            <pre><code>BadDecl</code></pre>
         </article>
         
         <article class="global" data-name="RepeatedDecl">
            <h2>RepeatedDecl</h2>
            <hr />
            
            <p>RepeatedDecl occurs when an identifier occurs more than once on the left
hand side of a short variable declaration.

Example:
 func _() {
 	x, y, y := 1, 2, 3
 }</p>
            
            <pre><code>RepeatedDecl</code></pre>
         </article>
         
         <article class="global" data-name="InvalidUnsafeAdd">
            <h2>InvalidUnsafeAdd</h2>
            <hr />
            
            <p>InvalidUnsafeAdd occurs when unsafe.Add is called with a
length argument that is not of integer type.

Example:
 import "unsafe"

 var p unsafe.Pointer
 var _ = unsafe.Add(p, float64(1))</p>
            
            <pre><code>InvalidUnsafeAdd</code></pre>
         </article>
         
         <article class="global" data-name="InvalidUnsafeSlice">
            <h2>InvalidUnsafeSlice</h2>
            <hr />
            
            <p>InvalidUnsafeSlice occurs when unsafe.Slice is called with a
pointer argument that is not of pointer type or a length argument
that is not of integer type, negative, or out of bounds.

Example:
 import "unsafe"

 var x int
 var _ = unsafe.Slice(x, 1)

Example:
 import "unsafe"

 var x int
 var _ = unsafe.Slice(&x, float64(1))

Example:
 import "unsafe"

 var x int
 var _ = unsafe.Slice(&x, -1)

Example:
 import "unsafe"

 var x int
 var _ = unsafe.Slice(&x, uint64(1) << 63)</p>
            
            <pre><code>InvalidUnsafeSlice</code></pre>
         </article>
         
         <article class="global" data-name="UnsupportedFeature">
            <h2>UnsupportedFeature</h2>
            <hr />
            
            <p>UnsupportedFeature occurs when a language feature is used that is not
supported at this Go version.</p>
            
            <pre><code>UnsupportedFeature</code></pre>
         </article>
         
         <article class="global" data-name="NotAGenericType">
            <h2>NotAGenericType</h2>
            <hr />
            
            <p>NotAGenericType occurs when a non-generic type is used where a generic
type is expected: in type or function instantiation.

Example:
 type T int

 var _ T[int]</p>
            
            <pre><code>NotAGenericType</code></pre>
         </article>
         
         <article class="global" data-name="WrongTypeArgCount">
            <h2>WrongTypeArgCount</h2>
            <hr />
            
            <p>WrongTypeArgCount occurs when a type or function is instantiated with an
incorrect number of type arguments, including when a generic type or
function is used without instantiation.

Errors involving failed type inference are assigned other error codes.

Example:
 type T[p any] int

 var _ T[int, string]

Example:
 func f[T any]() {}

 var x = f</p>
            
            <pre><code>WrongTypeArgCount</code></pre>
         </article>
         
         <article class="global" data-name="CannotInferTypeArgs">
            <h2>CannotInferTypeArgs</h2>
            <hr />
            
            <p>CannotInferTypeArgs occurs when type or function type argument inference
fails to infer all type arguments.

Example:
 func f[T any]() {}

 func _() {
 	f()
 }

Example:
  type N[P, Q any] struct{}

  var _ N[int]</p>
            
            <pre><code>CannotInferTypeArgs</code></pre>
         </article>
         
         <article class="global" data-name="InvalidTypeArg">
            <h2>InvalidTypeArg</h2>
            <hr />
            
            <p>InvalidTypeArg occurs when a type argument does not satisfy its
corresponding type parameter constraints.

Example:
 type T[P ~int] struct{}

 var _ T[string]</p>
            
            <pre><code>InvalidTypeArg</code></pre>
         </article>
         
         <article class="global" data-name="InvalidInstanceCycle">
            <h2>InvalidInstanceCycle</h2>
            <hr />
            
            <p>InvalidInstanceCycle occurs when an invalid cycle is detected
within the instantiation graph.

Example:
 func f[T any]() { f[*T]() }</p>
            
            <pre><code>InvalidInstanceCycle</code></pre>
         </article>
         
         <article class="global" data-name="InvalidUnion">
            <h2>InvalidUnion</h2>
            <hr />
            
            <p>InvalidUnion occurs when an embedded union or approximation element is
not valid.

Example:
 type _ interface {
  	~int | interface{ m() }
 }</p>
            
            <pre><code>InvalidUnion</code></pre>
         </article>
         
         <article class="global" data-name="MisplacedConstraintIface">
            <h2>MisplacedConstraintIface</h2>
            <hr />
            
            <p>MisplacedConstraintIface occurs when a constraint-type interface is used
outside of constraint position.

Example:
  type I interface { ~int }

  var _ I</p>
            
            <pre><code>MisplacedConstraintIface</code></pre>
         </article>
         
         <article class="global" data-name="InvalidMethodTypeParams">
            <h2>InvalidMethodTypeParams</h2>
            <hr />
            
            <p>InvalidMethodTypeParams occurs when methods have type parameters.

It cannot be encountered with an AST parsed using go/parser.</p>
            
            <pre><code>InvalidMethodTypeParams</code></pre>
         </article>
         
         <article class="global" data-name="MisplacedTypeParam">
            <h2>MisplacedTypeParam</h2>
            <hr />
            
            <p>MisplacedTypeParam occurs when a type parameter is used in a place where
it is not permitted.

Example:
 type T[P any] P

Example:
 type T[P any] struct{ *P }</p>
            
            <pre><code>MisplacedTypeParam</code></pre>
         </article>
         
         <article class="global" data-name="InvalidUnsafeSliceData">
            <h2>InvalidUnsafeSliceData</h2>
            <hr />
            
            <p>InvalidUnsafeSliceData occurs when unsafe.SliceData is called with
an argument that is not of slice type. It also occurs if it is used
in a package compiled for a language version before go1.20.

Example:
 import "unsafe"

 var x int
 var _ = unsafe.SliceData(x)</p>
            
            <pre><code>InvalidUnsafeSliceData</code></pre>
         </article>
         
         <article class="global" data-name="InvalidUnsafeString">
            <h2>InvalidUnsafeString</h2>
            <hr />
            
            <p>InvalidUnsafeString occurs when unsafe.String is called with
a length argument that is not of integer type, negative, or
out of bounds. It also occurs if it is used in a package
compiled for a language version before go1.20.

Example:
 import "unsafe"

 var b [10]byte
 var _ = unsafe.String(&b[0], -1)</p>
            
            <pre><code>InvalidUnsafeString</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <p>InvalidUnsafeStringData occurs if it is used in a package
compiled for a language version before go1.20.</p>
            
            <pre><code>_</code></pre>
         </article>
         
         <article class="global" data-name="_ErrorCode_name_0">
            <h2>_ErrorCode_name_0</h2>
            <hr />
            
            <pre><code>_ErrorCode_name_0</code></pre>
         </article>
         
         <article class="global" data-name="_ErrorCode_name_1">
            <h2>_ErrorCode_name_1</h2>
            <hr />
            
            <pre><code>_ErrorCode_name_1</code></pre>
         </article>
         
         <article class="global" data-name="_ErrorCode_index_1">
            <h2>_ErrorCode_index_1</h2>
            <hr />
            
            <pre><code>_ErrorCode_index_1</code></pre>
         </article>
           
         <article class="function" data-name="ReceiverNamed">
            <h2>ReceiverNamed</h2>
            <hr />
            
            <p>ReceiverNamed returns the named type (if any) associated with the
type of recv, which may be of the form N or *N, or aliases thereof.
It also reports whether a Pointer was present.</p>
            
            <pre><code>func ReceiverNamed(recv *types.Var) (isPtr bool, named *types.Named)</code></pre>
         </article>
         
         <article class="function" data-name="Unpointer">
            <h2>Unpointer</h2>
            <hr />
            
            <p>Unpointer returns T given *T or an alias thereof.
For all other types it is the identity function.
It does not look at underlying types.
The result may be an alias.

Use this function to strip off the optional pointer on a receiver
in a field or method selection, without losing the named type
(which is needed to compute the method set).

See also [typeparams.MustDeref], which removes one level of
indirection from the type, regardless of named types (analogous to
a LOAD instruction).</p>
            
            <pre><code>func Unpointer(t types.Type) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="TooNewStdSymbols">
            <h2>TooNewStdSymbols</h2>
            <hr />
            
            <p>TooNewStdSymbols computes the set of package-level symbols
exported by pkg that are not available at the specified version.
The result maps each symbol to its minimum version.

The pkg is allowed to contain type errors.</p>
            
            <pre><code>func TooNewStdSymbols(pkg *types.Package, version string) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="SetUsesCgo">
            <h2>SetUsesCgo</h2>
            <hr />
            
            <pre><code>func SetUsesCgo(conf *types.Config) bool</code></pre>
         </article>
         
         <article class="function" data-name="ReadGo116ErrorData">
            <h2>ReadGo116ErrorData</h2>
            <hr />
            
            <p>ReadGo116ErrorData extracts additional information from types.Error values
generated by Go version 1.16 and later: the error code, start position, and
end position. If all positions are valid, start <= err.Pos <= end.

If the data could not be read, the final result parameter will be false.</p>
            
            <pre><code>func ReadGo116ErrorData(err types.Error) (code ErrorCode, start token.Pos, end token.Pos, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="NameRelativeTo">
            <h2>NameRelativeTo</h2>
            <hr />
            
            <p>NameRelativeTo returns a types.Qualifier that qualifies members of
all packages other than pkg, using only the package name.
(By contrast, [types.RelativeTo] uses the complete package path,
which is often excessive.)

If pkg is nil, it is equivalent to [*types.Package.Name].</p>
            
            <pre><code>func NameRelativeTo(pkg *types.Package) types.Qualifier</code></pre>
         </article>
         
         <article class="function" data-name="TypeParams">
            <h2>TypeParams</h2>
            <hr />
            
            <p>TypeParams is a light shim around t.TypeParams().
(go/types.Alias).TypeParams requires >= 1.23.</p>
            
            <pre><code>func TypeParams(t NamedOrAlias) *types.TypeParamList</code></pre>
         </article>
         
         <article class="function" data-name="TypeArgs">
            <h2>TypeArgs</h2>
            <hr />
            
            <p>TypeArgs is a light shim around t.TypeArgs().
(go/types.Alias).TypeArgs requires >= 1.23.</p>
            
            <pre><code>func TypeArgs(t NamedOrAlias) *types.TypeList</code></pre>
         </article>
         
         <article class="function" data-name="Origin">
            <h2>Origin</h2>
            <hr />
            
            <p>Origin returns the generic type of the Named or Alias type t if it
is instantiated, otherwise it returns t.</p>
            
            <pre><code>func Origin(t NamedOrAlias) NamedOrAlias</code></pre>
         </article>
         
         <article class="function" data-name="ZeroString">
            <h2>ZeroString</h2>
            <hr />
            
            <p>ZeroString returns the string representation of the "zero" value of the type t.
This string can be used on the right-hand side of an assignment where the
left-hand side has that explicit type.
Exception: This does not apply to tuples. Their string representation is
informational only and cannot be used in an assignment.
When assigning to a wider type (such as 'any'), it's the caller's
responsibility to handle any necessary type conversions.
See [ZeroExpr] for a variant that returns an [ast.Expr].</p>
            
            <pre><code>func ZeroString(t types.Type, qf types.Qualifier) string</code></pre>
         </article>
         
         <article class="function" data-name="ZeroExpr">
            <h2>ZeroExpr</h2>
            <hr />
            
            <p>ZeroExpr returns the ast.Expr representation of the "zero" value of the type t.
ZeroExpr is defined for types that are suitable for variables.
It may panic for other types such as Tuple or Union.
See [ZeroString] for a variant that returns a string.</p>
            
            <pre><code>func ZeroExpr(f *ast.File, pkg *types.Package, typ types.Type) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="IsZeroExpr">
            <h2>IsZeroExpr</h2>
            <hr />
            
            <p>IsZeroExpr uses simple syntactic heuristics to report whether expr
is a obvious zero value, such as 0, "", nil, or false.
It cannot do better without type information.</p>
            
            <pre><code>func IsZeroExpr(expr ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="TypeExpr">
            <h2>TypeExpr</h2>
            <hr />
            
            <p>TypeExpr returns syntax for the specified type. References to named types
from packages other than pkg are qualified by an appropriate package name, as
defined by the import environment of file.
It may panic for types such as Tuple or Union.</p>
            
            <pre><code>func TypeExpr(f *ast.File, pkg *types.Package, typ types.Type) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="ForEachElement">
            <h2>ForEachElement</h2>
            <hr />
            
            <p>ForEachElement calls f for type T and each type reachable from its
type through reflection. It does this by recursively stripping off
type constructors; in addition, for each named type N, the type *N
is added to the result as it may have additional methods.

The caller must provide an initially empty set used to de-duplicate
identical types, potentially across multiple calls to ForEachElement.
(Its final value holds all the elements seen, matching the arguments
passed to f.)

TODO(adonovan): share/harmonize with go/callgraph/rta.</p>
            
            <pre><code>func ForEachElement(rtypes *typeutil.Map, msets *typeutil.MethodSetCache, T types.Type, f func)</code></pre>
         </article>
         
         <article class="function" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>func _()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
