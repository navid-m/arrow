<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>typesinternal - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                 
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>typesinternal</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"go/types"
"golang.org/x/tools/internal/stdlib"
"golang.org/x/tools/internal/versions"
"go/token"
"go/types"
"reflect"
"unsafe"
"golang.org/x/tools/internal/aliases"
"fmt"
"go/ast"
"go/token"
"go/types"
"strconv"
"strings"
"fmt"
"go/types"
"golang.org/x/tools/go/types/typeutil"
"strconv"
"go/types"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="AmbiguousSelector" data-name="AmbiguousSelector">
               <h3>
                  AmbiguousSelector 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#AmbiguousSelector" class="anchor" title="Link to AmbiguousSelector">#</a>
               </h3>
               
                  <p class="doc-comment">AmbiguousSelector occurs when a selector is ambiguous.
Example:
type E1 struct { i int }
type E2 struct { i int }
type T struct { E1; E2 }
var x T
var _ = x.i</p>
               
               <pre><code class="language-go">const AmbiguousSelector</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BadDecl" data-name="BadDecl">
               <h3>
                  BadDecl 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BadDecl" class="anchor" title="Link to BadDecl">#</a>
               </h3>
               
                  <p class="doc-comment">BadDecl occurs when a declaration has invalid syntax.</p>
               
               <pre><code class="language-go">const BadDecl</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BadDotDotDotSyntax" data-name="BadDotDotDotSyntax">
               <h3>
                  BadDotDotDotSyntax 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BadDotDotDotSyntax" class="anchor" title="Link to BadDotDotDotSyntax">#</a>
               </h3>
               
                  <p class="doc-comment">BadDotDotDotSyntax occurs when a "..." occurs in a context where it is
not valid.
Example:
var _ = map[int][...]int{0: {}}</p>
               
               <pre><code class="language-go">const BadDotDotDotSyntax</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BadImportPath" data-name="BadImportPath">
               <h3>
                  BadImportPath 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BadImportPath" class="anchor" title="Link to BadImportPath">#</a>
               </h3>
               
                  <p class="doc-comment">BadImportPath occurs when an import path is not valid.</p>
               
               <pre><code class="language-go">const BadImportPath</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BadOffsetofSyntax" data-name="BadOffsetofSyntax">
               <h3>
                  BadOffsetofSyntax 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BadOffsetofSyntax" class="anchor" title="Link to BadOffsetofSyntax">#</a>
               </h3>
               
                  <p class="doc-comment">BadOffsetofSyntax occurs when unsafe.Offsetof is called with an argument
that is not a selector expression.
Example:
import "unsafe"
var x int
var _ = unsafe.Offsetof(x)</p>
               
               <pre><code class="language-go">const BadOffsetofSyntax</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BadRecv" data-name="BadRecv">
               <h3>
                  BadRecv 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BadRecv" class="anchor" title="Link to BadRecv">#</a>
               </h3>
               
                  <p class="doc-comment">BadRecv occurs when a method declaration does not have exactly one
receiver parameter.
Example:
func () _() {}</p>
               
               <pre><code class="language-go">const BadRecv</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BadTypeKeyword" data-name="BadTypeKeyword">
               <h3>
                  BadTypeKeyword 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BadTypeKeyword" class="anchor" title="Link to BadTypeKeyword">#</a>
               </h3>
               
                  <p class="doc-comment">BadTypeKeyword occurs when a .(type) expression is used anywhere other
than a type switch.
Example:
type I interface {
m()
}
var t I
var _ = t.(type)</p>
               
               <pre><code class="language-go">const BadTypeKeyword</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BlankIfaceMethod" data-name="BlankIfaceMethod">
               <h3>
                  BlankIfaceMethod 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BlankIfaceMethod" class="anchor" title="Link to BlankIfaceMethod">#</a>
               </h3>
               
                  <p class="doc-comment">BlankIfaceMethod occurs when a method name is '_'.
Per the spec:
"The name of each explicitly specified method must be unique and not
blank."
Example:
type T interface {
_(int)
}</p>
               
               <pre><code class="language-go">const BlankIfaceMethod</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BlankPkgName" data-name="BlankPkgName">
               <h3>
                  BlankPkgName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BlankPkgName" class="anchor" title="Link to BlankPkgName">#</a>
               </h3>
               
                  <p class="doc-comment">BlankPkgName occurs when a package name is the blank identifier "_".
Per the spec:
"The PackageName must not be the blank identifier."</p>
               
               <pre><code class="language-go">const BlankPkgName</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BrokenImport" data-name="BrokenImport">
               <h3>
                  BrokenImport 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BrokenImport" class="anchor" title="Link to BrokenImport">#</a>
               </h3>
               
                  <p class="doc-comment">BrokenImport occurs when importing a package fails.
Example:
import "amissingpackage"</p>
               
               <pre><code class="language-go">const BrokenImport</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="CannotInferTypeArgs" data-name="CannotInferTypeArgs">
               <h3>
                  CannotInferTypeArgs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#CannotInferTypeArgs" class="anchor" title="Link to CannotInferTypeArgs">#</a>
               </h3>
               
                  <p class="doc-comment">CannotInferTypeArgs occurs when type or function type argument inference
fails to infer all type arguments.
Example:
func f[T any]() {}
func _() {
f()
}
Example:
type N[P, Q any] struct{}
var _ N[int]</p>
               
               <pre><code class="language-go">const CannotInferTypeArgs</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DivByZero" data-name="DivByZero">
               <h3>
                  DivByZero 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DivByZero" class="anchor" title="Link to DivByZero">#</a>
               </h3>
               
                  <p class="doc-comment">DivByZero occurs when a division operation is provable at compile
time to be a division by zero.
Example:
const divisor = 0
var x int = 1/divisor</p>
               
               <pre><code class="language-go">const DivByZero</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DuplicateCase" data-name="DuplicateCase">
               <h3>
                  DuplicateCase 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DuplicateCase" class="anchor" title="Link to DuplicateCase">#</a>
               </h3>
               
                  <p class="doc-comment">DuplicateCase occurs when a type or expression switch has duplicate
cases.
Example:
func printInt(i int) {
switch i {
case 1:
println("one")
case 1:
println("One")
}
}</p>
               
               <pre><code class="language-go">const DuplicateCase</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DuplicateDecl" data-name="DuplicateDecl">
               <h3>
                  DuplicateDecl 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DuplicateDecl" class="anchor" title="Link to DuplicateDecl">#</a>
               </h3>
               
                  <p class="doc-comment">DuplicateDecl occurs when an identifier is declared multiple times.
Example:
var x = 1
var x = 2</p>
               
               <pre><code class="language-go">const DuplicateDecl</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DuplicateDefault" data-name="DuplicateDefault">
               <h3>
                  DuplicateDefault 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DuplicateDefault" class="anchor" title="Link to DuplicateDefault">#</a>
               </h3>
               
                  <p class="doc-comment">DuplicateDefault occurs when a type or expression switch has multiple
default clauses.
Example:
func printInt(i int) {
switch i {
case 1:
println("one")
default:
println("One")
default:
println("1")
}
}</p>
               
               <pre><code class="language-go">const DuplicateDefault</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DuplicateFieldAndMethod" data-name="DuplicateFieldAndMethod">
               <h3>
                  DuplicateFieldAndMethod 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DuplicateFieldAndMethod" class="anchor" title="Link to DuplicateFieldAndMethod">#</a>
               </h3>
               
                  <p class="doc-comment">DuplicateFieldAndMethod occurs when an identifier appears as both a field
and method name.
Example:
type T struct {
m int
}
func (T) m() {}</p>
               
               <pre><code class="language-go">const DuplicateFieldAndMethod</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DuplicateLabel" data-name="DuplicateLabel">
               <h3>
                  DuplicateLabel 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DuplicateLabel" class="anchor" title="Link to DuplicateLabel">#</a>
               </h3>
               
                  <p class="doc-comment">DuplicateLabel occurs when a label is declared more than once.
Example:
func f() int {
L:
L:
return 1
}</p>
               
               <pre><code class="language-go">const DuplicateLabel</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DuplicateLitField" data-name="DuplicateLitField">
               <h3>
                  DuplicateLitField 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DuplicateLitField" class="anchor" title="Link to DuplicateLitField">#</a>
               </h3>
               
                  <p class="doc-comment">DuplicateLitField occurs when a struct literal contains duplicated
fields.
Example:
var _ = struct{i int}{i: 1, i: 2}</p>
               
               <pre><code class="language-go">const DuplicateLitField</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DuplicateLitKey" data-name="DuplicateLitKey">
               <h3>
                  DuplicateLitKey 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DuplicateLitKey" class="anchor" title="Link to DuplicateLitKey">#</a>
               </h3>
               
                  <p class="doc-comment">DuplicateLitKey occurs when an index is duplicated in a slice, array, or
map literal.
Example:
var _ = []int{0:1, 0:2}
Example:
var _ = map[string]int{"a": 1, "a": 2}</p>
               
               <pre><code class="language-go">const DuplicateLitKey</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DuplicateMethod" data-name="DuplicateMethod">
               <h3>
                  DuplicateMethod 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DuplicateMethod" class="anchor" title="Link to DuplicateMethod">#</a>
               </h3>
               
                  <p class="doc-comment">DuplicateMethod occurs when two methods on the same receiver type have
the same name.
Example:
type T struct {}
func (T) m() {}
func (T) m(i int) int { return i }</p>
               
               <pre><code class="language-go">const DuplicateMethod</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ImportCRenamed" data-name="ImportCRenamed">
               <h3>
                  ImportCRenamed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ImportCRenamed" class="anchor" title="Link to ImportCRenamed">#</a>
               </h3>
               
                  <p class="doc-comment">ImportCRenamed occurs when the special import "C" is renamed. "C" is a
pseudo-package, and must not be renamed.
Example:
import _ "C"</p>
               
               <pre><code class="language-go">const ImportCRenamed</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ImpossibleAssert" data-name="ImpossibleAssert">
               <h3>
                  ImpossibleAssert 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#ImpossibleAssert" class="anchor" title="Link to ImpossibleAssert">#</a>
               </h3>
               
                  <p class="doc-comment">ImpossibleAssert occurs for a type assertion x.(T) when the value x of
interface cannot have dynamic type T, due to a missing or mismatching
method on T.
Example:
type T int
func (t *T) m() int { return int(*t) }
type I interface { m() int }
var x I
var _ = x.(T)</p>
               
               <pre><code class="language-go">const ImpossibleAssert</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IncomparableMapKey" data-name="IncomparableMapKey">
               <h3>
                  IncomparableMapKey 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IncomparableMapKey" class="anchor" title="Link to IncomparableMapKey">#</a>
               </h3>
               
                  <p class="doc-comment">IncomparableMapKey occurs when a map key type does not support the == and
!= operators.
Per the spec:
"The comparison operators == and != must be fully defined for operands of
the key type; thus the key type must not be a function, map, or slice."
Example:
var x map[T]int
type T []int</p>
               
               <pre><code class="language-go">const IncomparableMapKey</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="IncompatibleAssign" data-name="IncompatibleAssign">
               <h3>
                  IncompatibleAssign 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#IncompatibleAssign" class="anchor" title="Link to IncompatibleAssign">#</a>
               </h3>
               
                  <p class="doc-comment">IncompatibleAssign occurs when the type of the right-hand side expression
in an assignment cannot be assigned to the type of the variable being
assigned.
Example:
var x []int
var _ int = x</p>
               
               <pre><code class="language-go">const IncompatibleAssign</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidAppend" data-name="InvalidAppend">
               <h3>
                  InvalidAppend 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidAppend" class="anchor" title="Link to InvalidAppend">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidAppend occurs when append is called with a first argument that is
not a slice.
Example:
var _ = append(1, 2)</p>
               
               <pre><code class="language-go">const InvalidAppend</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidArrayLen" data-name="InvalidArrayLen">
               <h3>
                  InvalidArrayLen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidArrayLen" class="anchor" title="Link to InvalidArrayLen">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidArrayLen occurs when an array length is not a constant value.
Example:
var n = 3
var _ = [n]int{}</p>
               
               <pre><code class="language-go">const InvalidArrayLen</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidAssert" data-name="InvalidAssert">
               <h3>
                  InvalidAssert 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidAssert" class="anchor" title="Link to InvalidAssert">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidAssert occurs when a type assertion is applied to a
value that is not of interface type.
Example:
var x = 1
var _ = x.(float64)</p>
               
               <pre><code class="language-go">const InvalidAssert</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidBlank" data-name="InvalidBlank">
               <h3>
                  InvalidBlank 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidBlank" class="anchor" title="Link to InvalidBlank">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidBlank occurs when a blank identifier is used as a value or type.
Per the spec:
"The blank identifier may appear as an operand only on the left-hand side
of an assignment."
Example:
var x = _</p>
               
               <pre><code class="language-go">const InvalidBlank</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidCall" data-name="InvalidCall">
               <h3>
                  InvalidCall 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidCall" class="anchor" title="Link to InvalidCall">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidCall occurs when an expression is called that is not of function
type.
Example:
var x = "x"
var y = x()</p>
               
               <pre><code class="language-go">const InvalidCall</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidCap" data-name="InvalidCap">
               <h3>
                  InvalidCap 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidCap" class="anchor" title="Link to InvalidCap">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidCap occurs when an argument to the cap built-in function is not of
supported type.
See https://golang.org/ref/spec#Length_and_capacity for information on
which underlying types are supported as arguments to cap and len.
Example:
var s = 2
var x = cap(s)</p>
               
               <pre><code class="language-go">const InvalidCap</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidChanAssign" data-name="InvalidChanAssign">
               <h3>
                  InvalidChanAssign 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidChanAssign" class="anchor" title="Link to InvalidChanAssign">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidChanAssign occurs when a chan assignment is invalid.
Per the spec, a value x is assignable to a channel type T if:
"x is a bidirectional channel value, T is a channel type, x's type V and
T have identical element types, and at least one of V or T is not a
defined type."
Example:
type T1 chan int
type T2 chan int
var x T1
// Invalid assignment because both types are named
var _ T2 = x</p>
               
               <pre><code class="language-go">const InvalidChanAssign</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidChanRange" data-name="InvalidChanRange">
               <h3>
                  InvalidChanRange 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidChanRange" class="anchor" title="Link to InvalidChanRange">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidChanRange occurs when a send-only channel used in a range
expression.
Example:
func sum(c chan<- int) {
s := 0
for i := range c {
s += i
}
}</p>
               
               <pre><code class="language-go">const InvalidChanRange</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidClose" data-name="InvalidClose">
               <h3>
                  InvalidClose 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidClose" class="anchor" title="Link to InvalidClose">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidClose occurs when close(...) is called with an argument that is
not of channel type, or that is a receive-only channel.
Example:
func f() {
var x int
close(x)
}</p>
               
               <pre><code class="language-go">const InvalidClose</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidComplex" data-name="InvalidComplex">
               <h3>
                  InvalidComplex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidComplex" class="anchor" title="Link to InvalidComplex">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidComplex occurs when the complex built-in function is called with
arguments with incompatible types.
Example:
var _ = complex(float32(1), float64(2))</p>
               
               <pre><code class="language-go">const InvalidComplex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidCond" data-name="InvalidCond">
               <h3>
                  InvalidCond 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidCond" class="anchor" title="Link to InvalidCond">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidCond occurs when an if condition is not a boolean expression.
Example:
func checkReturn(i int) {
if i {
panic("non-zero return")
}
}</p>
               
               <pre><code class="language-go">const InvalidCond</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidConstInit" data-name="InvalidConstInit">
               <h3>
                  InvalidConstInit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidConstInit" class="anchor" title="Link to InvalidConstInit">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidConstInit occurs when a const declaration has a non-constant
initializer.
Example:
var x int
const _ = x</p>
               
               <pre><code class="language-go">const InvalidConstInit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidConstType" data-name="InvalidConstType">
               <h3>
                  InvalidConstType 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidConstType" class="anchor" title="Link to InvalidConstType">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidConstType occurs when the underlying type in a const declaration
is not a valid constant type.
Example:
const c *int = 4</p>
               
               <pre><code class="language-go">const InvalidConstType</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidConstVal" data-name="InvalidConstVal">
               <h3>
                  InvalidConstVal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidConstVal" class="anchor" title="Link to InvalidConstVal">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidConstVal occurs when a const value cannot be converted to its
target type.
TODO(findleyr): this error code and example are not very clear. Consider
removing it.
Example:
const _ = 1 << "hello"</p>
               
               <pre><code class="language-go">const InvalidConstVal</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidConversion" data-name="InvalidConversion">
               <h3>
                  InvalidConversion 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidConversion" class="anchor" title="Link to InvalidConversion">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidConversion occurs when the argument type cannot be converted to the
target.
See https://golang.org/ref/spec#Conversions for the rules of
convertibility.
Example:
var x float64
var _ = string(x)</p>
               
               <pre><code class="language-go">const InvalidConversion</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidCopy" data-name="InvalidCopy">
               <h3>
                  InvalidCopy 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidCopy" class="anchor" title="Link to InvalidCopy">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidCopy occurs when the arguments are not of slice type or do not
have compatible type.
See https://golang.org/ref/spec#Appending_and_copying_slices for more
information on the type requirements for the copy built-in.
Example:
func f() {
var x []int
y := []int64{1,2,3}
copy(x, y)
}</p>
               
               <pre><code class="language-go">const InvalidCopy</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidDeclCycle" data-name="InvalidDeclCycle">
               <h3>
                  InvalidDeclCycle 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidDeclCycle" class="anchor" title="Link to InvalidDeclCycle">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidDeclCycle occurs when a declaration cycle is not valid.
Example:
import "unsafe"
type T struct {
a [n]int
}
var n = unsafe.Sizeof(T{})</p>
               
               <pre><code class="language-go">const InvalidDeclCycle</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidDefer" data-name="InvalidDefer">
               <h3>
                  InvalidDefer 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidDefer" class="anchor" title="Link to InvalidDefer">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidDefer occurs when a deferred expression is not a function call,
for example if the expression is a type conversion.
Example:
func f(i int) int {
defer int32(i)
return i
}</p>
               
               <pre><code class="language-go">const InvalidDefer</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidDelete" data-name="InvalidDelete">
               <h3>
                  InvalidDelete 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidDelete" class="anchor" title="Link to InvalidDelete">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidDelete occurs when the delete built-in function is called with a
first argument that is not a map.
Example:
func f() {
m := "hello"
delete(m, "e")
}</p>
               
               <pre><code class="language-go">const InvalidDelete</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidDotDotDot" data-name="InvalidDotDotDot">
               <h3>
                  InvalidDotDotDot 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidDotDotDot" class="anchor" title="Link to InvalidDotDotDot">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidDotDotDot occurs when a "..." is used in a non-variadic built-in
function.
Example:
var s = []int{1, 2, 3}
var l = len(s...)</p>
               
               <pre><code class="language-go">const InvalidDotDotDot</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidDotDotDotOperand" data-name="InvalidDotDotDotOperand">
               <h3>
                  InvalidDotDotDotOperand 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidDotDotDotOperand" class="anchor" title="Link to InvalidDotDotDotOperand">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidDotDotDotOperand occurs when a "..." operator is applied to a
single-valued operand.
Example:
func printArgs(args ...int) {
for _, a := range args {
println(a)
}
}
func f() {
a := 1
printArgs(a...)
}
Example:
func args() (int, int) {
return 1, 2
}
func printArgs(args ...int) {
for _, a := range args {
println(a)
}
}
func g() {
printArgs(args()...)
}</p>
               
               <pre><code class="language-go">const InvalidDotDotDotOperand</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidExprSwitch" data-name="InvalidExprSwitch">
               <h3>
                  InvalidExprSwitch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidExprSwitch" class="anchor" title="Link to InvalidExprSwitch">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidExprSwitch occurs when a switch expression is not comparable.
Example:
func _() {
var a struct{ _ func() }
switch a /* ERROR cannot switch on a */ {
}
}</p>
               
               <pre><code class="language-go">const InvalidExprSwitch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidGo" data-name="InvalidGo">
               <h3>
                  InvalidGo 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidGo" class="anchor" title="Link to InvalidGo">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidGo occurs when a go expression is not a function call, for example
if the expression is a type conversion.
Example:
func f(i int) int {
go int32(i)
return i
}</p>
               
               <pre><code class="language-go">const InvalidGo</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidIfaceAssign" data-name="InvalidIfaceAssign">
               <h3>
                  InvalidIfaceAssign 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidIfaceAssign" class="anchor" title="Link to InvalidIfaceAssign">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidIfaceAssign occurs when a value of type T is used as an
interface, but T does not implement a method of the expected interface.
Example:
type I interface {
f()
}
type T int
var x I = T(1)</p>
               
               <pre><code class="language-go">const InvalidIfaceAssign</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidIfaceEmbed" data-name="InvalidIfaceEmbed">
               <h3>
                  InvalidIfaceEmbed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidIfaceEmbed" class="anchor" title="Link to InvalidIfaceEmbed">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidIfaceEmbed occurs when a non-interface type is embedded in an
interface.
Example:
type T struct {}
func (T) m()
type I interface {
T
}</p>
               
               <pre><code class="language-go">const InvalidIfaceEmbed</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidImag" data-name="InvalidImag">
               <h3>
                  InvalidImag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidImag" class="anchor" title="Link to InvalidImag">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidImag occurs when the imag built-in function is called with an
argument that does not have complex type.
Example:
var _ = imag(int(1))</p>
               
               <pre><code class="language-go">const InvalidImag</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidIndex" data-name="InvalidIndex">
               <h3>
                  InvalidIndex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidIndex" class="anchor" title="Link to InvalidIndex">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidIndex occurs when an index argument is not of integer type,
negative, or out-of-bounds.
Example:
var s = [...]int{1,2,3}
var x = s[5]
Example:
var s = []int{1,2,3}
var _ = s[-1]
Example:
var s = []int{1,2,3}
var i string
var _ = s[i]</p>
               
               <pre><code class="language-go">const InvalidIndex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidIndirection" data-name="InvalidIndirection">
               <h3>
                  InvalidIndirection 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidIndirection" class="anchor" title="Link to InvalidIndirection">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidIndirection occurs when a non-pointer value is indirected via the
'*' operator.
Example:
var x int
var y = *x</p>
               
               <pre><code class="language-go">const InvalidIndirection</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidInitCycle" data-name="InvalidInitCycle">
               <h3>
                  InvalidInitCycle 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidInitCycle" class="anchor" title="Link to InvalidInitCycle">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidInitCycle occurs when an invalid cycle is detected within the
initialization graph.
Example:
var x int = f()
func f() int { return x }</p>
               
               <pre><code class="language-go">const InvalidInitCycle</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidInitDecl" data-name="InvalidInitDecl">
               <h3>
                  InvalidInitDecl 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidInitDecl" class="anchor" title="Link to InvalidInitDecl">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidInitDecl occurs when init is declared as anything other than a
function.
Example:
var init = 1</p>
               
               <pre><code class="language-go">const InvalidInitDecl</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidInitSig" data-name="InvalidInitSig">
               <h3>
                  InvalidInitSig 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidInitSig" class="anchor" title="Link to InvalidInitSig">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidInitSig occurs when an init function declares parameters or
results.
Example:
func init() int { return 1 }</p>
               
               <pre><code class="language-go">const InvalidInitSig</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidInstanceCycle" data-name="InvalidInstanceCycle">
               <h3>
                  InvalidInstanceCycle 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidInstanceCycle" class="anchor" title="Link to InvalidInstanceCycle">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidInstanceCycle occurs when an invalid cycle is detected
within the instantiation graph.
Example:
func f[T any]() { f[*T]() }</p>
               
               <pre><code class="language-go">const InvalidInstanceCycle</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidIota" data-name="InvalidIota">
               <h3>
                  InvalidIota 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidIota" class="anchor" title="Link to InvalidIota">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidIota occurs when the predeclared identifier iota is used outside
of a constant declaration.
Example:
var x = iota</p>
               
               <pre><code class="language-go">const InvalidIota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidIterVar" data-name="InvalidIterVar">
               <h3>
                  InvalidIterVar 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidIterVar" class="anchor" title="Link to InvalidIterVar">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidIterVar occurs when two iteration variables are used while ranging
over a channel.
Example:
func f(c chan int) {
for k, v := range c {
println(k, v)
}
}</p>
               
               <pre><code class="language-go">const InvalidIterVar</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidLen" data-name="InvalidLen">
               <h3>
                  InvalidLen 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidLen" class="anchor" title="Link to InvalidLen">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidLen occurs when an argument to the len built-in function is not of
supported type.
See https://golang.org/ref/spec#Length_and_capacity for information on
which underlying types are supported as arguments to cap and len.
Example:
var s = 2
var x = len(s)</p>
               
               <pre><code class="language-go">const InvalidLen</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidLit" data-name="InvalidLit">
               <h3>
                  InvalidLit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidLit" class="anchor" title="Link to InvalidLit">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidLit occurs when a composite literal expression does not match its
type.
Example:
type P *struct{
x int
}
var _ = P {}</p>
               
               <pre><code class="language-go">const InvalidLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidLitField" data-name="InvalidLitField">
               <h3>
                  InvalidLitField 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidLitField" class="anchor" title="Link to InvalidLitField">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidLitField occurs when a field name is not a valid identifier.
Example:
var _ = struct{i int}{1: 1}</p>
               
               <pre><code class="language-go">const InvalidLitField</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidLitIndex" data-name="InvalidLitIndex">
               <h3>
                  InvalidLitIndex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidLitIndex" class="anchor" title="Link to InvalidLitIndex">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidLitIndex occurs when the key in a key-value element of a slice or
array literal is not an integer constant.
Example:
var i = 0
var x = []string{i: "world"}</p>
               
               <pre><code class="language-go">const InvalidLitIndex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidMainDecl" data-name="InvalidMainDecl">
               <h3>
                  InvalidMainDecl 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidMainDecl" class="anchor" title="Link to InvalidMainDecl">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidMainDecl occurs when main is declared as anything other than a
function, in a main package.</p>
               
               <pre><code class="language-go">const InvalidMainDecl</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidMake" data-name="InvalidMake">
               <h3>
                  InvalidMake 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidMake" class="anchor" title="Link to InvalidMake">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidMake occurs when make is called with an unsupported type argument.
See https://golang.org/ref/spec#Making_slices_maps_and_channels for
information on the types that may be created using make.
Example:
var x = make(int)</p>
               
               <pre><code class="language-go">const InvalidMake</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidMethodExpr" data-name="InvalidMethodExpr">
               <h3>
                  InvalidMethodExpr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidMethodExpr" class="anchor" title="Link to InvalidMethodExpr">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidMethodExpr occurs when a pointer method is called but the argument
is not addressable.
Example:
type T struct {}
func (*T) m() int { return 1 }
var _ = T.m(T{})</p>
               
               <pre><code class="language-go">const InvalidMethodExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidMethodTypeParams" data-name="InvalidMethodTypeParams">
               <h3>
                  InvalidMethodTypeParams 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidMethodTypeParams" class="anchor" title="Link to InvalidMethodTypeParams">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidMethodTypeParams occurs when methods have type parameters.
It cannot be encountered with an AST parsed using go/parser.</p>
               
               <pre><code class="language-go">const InvalidMethodTypeParams</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidOffsetof" data-name="InvalidOffsetof">
               <h3>
                  InvalidOffsetof 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidOffsetof" class="anchor" title="Link to InvalidOffsetof">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidOffsetof occurs when unsafe.Offsetof is called with a method
selector, rather than a field selector, or when the field is embedded via
a pointer.
Per the spec:
"If f is an embedded field, it must be reachable without pointer
indirections through fields of the struct. "
Example:
import "unsafe"
type T struct { f int }
type S struct { *T }
var s S
var _ = unsafe.Offsetof(s.f)
Example:
import "unsafe"
type S struct{}
func (S) m() {}
var s S
var _ = unsafe.Offsetof(s.m)</p>
               
               <pre><code class="language-go">const InvalidOffsetof</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidPkgUse" data-name="InvalidPkgUse">
               <h3>
                  InvalidPkgUse 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidPkgUse" class="anchor" title="Link to InvalidPkgUse">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidPkgUse occurs when a package identifier is used outside of a
selector expression.
Example:
import "fmt"
var _ = fmt</p>
               
               <pre><code class="language-go">const InvalidPkgUse</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidPostDecl" data-name="InvalidPostDecl">
               <h3>
                  InvalidPostDecl 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidPostDecl" class="anchor" title="Link to InvalidPostDecl">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidPostDecl occurs when there is a declaration in a for-loop post
statement.
Example:
func f() {
for i := 0; i < 10; j := 0 {}
}</p>
               
               <pre><code class="language-go">const InvalidPostDecl</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidPtrEmbed" data-name="InvalidPtrEmbed">
               <h3>
                  InvalidPtrEmbed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidPtrEmbed" class="anchor" title="Link to InvalidPtrEmbed">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidPtrEmbed occurs when an embedded field is of the pointer form *T,
and T itself is itself a pointer, an unsafe.Pointer, or an interface.
Per the spec:
"An embedded field must be specified as a type name T or as a pointer to
a non-interface type name *T, and T itself may not be a pointer type."
Example:
type T *int
type S struct {
*T
}</p>
               
               <pre><code class="language-go">const InvalidPtrEmbed</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidRangeExpr" data-name="InvalidRangeExpr">
               <h3>
                  InvalidRangeExpr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidRangeExpr" class="anchor" title="Link to InvalidRangeExpr">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidRangeExpr occurs when the type of a range expression is not array,
slice, string, map, or channel.
Example:
func f(i int) {
for j := range i {
println(j)
}
}</p>
               
               <pre><code class="language-go">const InvalidRangeExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidReal" data-name="InvalidReal">
               <h3>
                  InvalidReal 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidReal" class="anchor" title="Link to InvalidReal">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidReal occurs when the real built-in function is called with an
argument that does not have complex type.
Example:
var _ = real(int(1))</p>
               
               <pre><code class="language-go">const InvalidReal</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidReceive" data-name="InvalidReceive">
               <h3>
                  InvalidReceive 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidReceive" class="anchor" title="Link to InvalidReceive">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidReceive occurs when there is a channel receive from a value that
is either not a channel, or is a send-only channel.
Example:
func f() {
var x = 1
<-x
}</p>
               
               <pre><code class="language-go">const InvalidReceive</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidRecv" data-name="InvalidRecv">
               <h3>
                  InvalidRecv 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidRecv" class="anchor" title="Link to InvalidRecv">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidRecv occurs when a receiver type expression is not of the form T
or *T, or T is a pointer type.
Example:
type T struct {}
func (**T) m() {}</p>
               
               <pre><code class="language-go">const InvalidRecv</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidSelectCase" data-name="InvalidSelectCase">
               <h3>
                  InvalidSelectCase 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidSelectCase" class="anchor" title="Link to InvalidSelectCase">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidSelectCase occurs when a select case is not a channel send or
receive.
Example:
func checkChan(c <-chan int) bool {
select {
case c:
return true
default:
return false
}
}</p>
               
               <pre><code class="language-go">const InvalidSelectCase</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidSend" data-name="InvalidSend">
               <h3>
                  InvalidSend 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidSend" class="anchor" title="Link to InvalidSend">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidSend occurs when there is a channel send to a value that is not a
channel, or is a receive-only channel.
Example:
func f() {
var x = 1
x <- "hello!"
}</p>
               
               <pre><code class="language-go">const InvalidSend</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidShiftCount" data-name="InvalidShiftCount">
               <h3>
                  InvalidShiftCount 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidShiftCount" class="anchor" title="Link to InvalidShiftCount">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidShiftCount occurs when the right-hand side of a shift operation is
either non-integer, negative, or too large.
Example:
var (
x string
y int = 1 << x
)</p>
               
               <pre><code class="language-go">const InvalidShiftCount</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidShiftOperand" data-name="InvalidShiftOperand">
               <h3>
                  InvalidShiftOperand 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidShiftOperand" class="anchor" title="Link to InvalidShiftOperand">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidShiftOperand occurs when the shifted operand is not an integer.
Example:
var s = "hello"
var x = s << 2</p>
               
               <pre><code class="language-go">const InvalidShiftOperand</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidSliceExpr" data-name="InvalidSliceExpr">
               <h3>
                  InvalidSliceExpr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidSliceExpr" class="anchor" title="Link to InvalidSliceExpr">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidSliceExpr occurs when a three-index slice expression (a[x:y:z]) is
applied to a string.
Example:
var s = "hello"
var x = s[1:2:3]</p>
               
               <pre><code class="language-go">const InvalidSliceExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidStructLit" data-name="InvalidStructLit">
               <h3>
                  InvalidStructLit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidStructLit" class="anchor" title="Link to InvalidStructLit">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidStructLit occurs when a positional struct literal has an incorrect
number of values.
Example:
var _ = struct{i, j int}{1,2,3}</p>
               
               <pre><code class="language-go">const InvalidStructLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidSyntaxTree" data-name="InvalidSyntaxTree">
               <h3>
                  InvalidSyntaxTree 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidSyntaxTree" class="anchor" title="Link to InvalidSyntaxTree">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidSyntaxTree occurs if an invalid syntax tree is provided
to the type checker. It should never happen.</p>
               
               <pre><code class="language-go">const InvalidSyntaxTree ErrorCode = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidTypeArg" data-name="InvalidTypeArg">
               <h3>
                  InvalidTypeArg 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidTypeArg" class="anchor" title="Link to InvalidTypeArg">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidTypeArg occurs when a type argument does not satisfy its
corresponding type parameter constraints.
Example:
type T[P ~int] struct{}
var _ T[string]</p>
               
               <pre><code class="language-go">const InvalidTypeArg</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidTypeCycle" data-name="InvalidTypeCycle">
               <h3>
                  InvalidTypeCycle 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidTypeCycle" class="anchor" title="Link to InvalidTypeCycle">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidTypeCycle occurs when a cycle in type definitions results in a
type that is not well-defined.
Example:
import "unsafe"
type T [unsafe.Sizeof(T{})]int</p>
               
               <pre><code class="language-go">const InvalidTypeCycle</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidTypeSwitch" data-name="InvalidTypeSwitch">
               <h3>
                  InvalidTypeSwitch 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidTypeSwitch" class="anchor" title="Link to InvalidTypeSwitch">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidTypeSwitch occurs when .(type) is used on an expression that is
not of interface type.
Example:
func f(i int) {
switch x := i.(type) {}
}</p>
               
               <pre><code class="language-go">const InvalidTypeSwitch</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidUnion" data-name="InvalidUnion">
               <h3>
                  InvalidUnion 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidUnion" class="anchor" title="Link to InvalidUnion">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidUnion occurs when an embedded union or approximation element is
not valid.
Example:
type _ interface {
~int | interface{ m() }
}</p>
               
               <pre><code class="language-go">const InvalidUnion</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidUnsafeAdd" data-name="InvalidUnsafeAdd">
               <h3>
                  InvalidUnsafeAdd 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidUnsafeAdd" class="anchor" title="Link to InvalidUnsafeAdd">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidUnsafeAdd occurs when unsafe.Add is called with a
length argument that is not of integer type.
Example:
import "unsafe"
var p unsafe.Pointer
var _ = unsafe.Add(p, float64(1))</p>
               
               <pre><code class="language-go">const InvalidUnsafeAdd</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidUnsafeSlice" data-name="InvalidUnsafeSlice">
               <h3>
                  InvalidUnsafeSlice 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidUnsafeSlice" class="anchor" title="Link to InvalidUnsafeSlice">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidUnsafeSlice occurs when unsafe.Slice is called with a
pointer argument that is not of pointer type or a length argument
that is not of integer type, negative, or out of bounds.
Example:
import "unsafe"
var x int
var _ = unsafe.Slice(x, 1)
Example:
import "unsafe"
var x int
var _ = unsafe.Slice(&x, float64(1))
Example:
import "unsafe"
var x int
var _ = unsafe.Slice(&x, -1)
Example:
import "unsafe"
var x int
var _ = unsafe.Slice(&x, uint64(1) << 63)</p>
               
               <pre><code class="language-go">const InvalidUnsafeSlice</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidUnsafeSliceData" data-name="InvalidUnsafeSliceData">
               <h3>
                  InvalidUnsafeSliceData 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidUnsafeSliceData" class="anchor" title="Link to InvalidUnsafeSliceData">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidUnsafeSliceData occurs when unsafe.SliceData is called with
an argument that is not of slice type. It also occurs if it is used
in a package compiled for a language version before go1.20.
Example:
import "unsafe"
var x int
var _ = unsafe.SliceData(x)</p>
               
               <pre><code class="language-go">const InvalidUnsafeSliceData</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidUnsafeString" data-name="InvalidUnsafeString">
               <h3>
                  InvalidUnsafeString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidUnsafeString" class="anchor" title="Link to InvalidUnsafeString">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidUnsafeString occurs when unsafe.String is called with
a length argument that is not of integer type, negative, or
out of bounds. It also occurs if it is used in a package
compiled for a language version before go1.20.
Example:
import "unsafe"
var b [10]byte
var _ = unsafe.String(&b[0], -1)</p>
               
               <pre><code class="language-go">const InvalidUnsafeString</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="InvalidUntypedConversion" data-name="InvalidUntypedConversion">
               <h3>
                  InvalidUntypedConversion 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#InvalidUntypedConversion" class="anchor" title="Link to InvalidUntypedConversion">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidUntypedConversion occurs when an there is no valid implicit
conversion from an untyped value satisfying the type constraints of the
context in which it is used.
Example:
var _ = 1 + ""</p>
               
               <pre><code class="language-go">const InvalidUntypedConversion</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="JumpIntoBlock" data-name="JumpIntoBlock">
               <h3>
                  JumpIntoBlock 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#JumpIntoBlock" class="anchor" title="Link to JumpIntoBlock">#</a>
               </h3>
               
                  <p class="doc-comment">JumpIntoBlock occurs when a forward jump goes to a label inside a nested
block.
Example:
func f(x int) {
goto L
if x > 0 {
L:
print("inside block")
}
}</p>
               
               <pre><code class="language-go">const JumpIntoBlock</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="JumpOverDecl" data-name="JumpOverDecl">
               <h3>
                  JumpOverDecl 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#JumpOverDecl" class="anchor" title="Link to JumpOverDecl">#</a>
               </h3>
               
                  <p class="doc-comment">JumpOverDecl occurs when a label jumps over a variable declaration.
Example:
func f() int {
goto L
x := 2
L:
x++
return x
}</p>
               
               <pre><code class="language-go">const JumpOverDecl</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MismatchedPkgName" data-name="MismatchedPkgName">
               <h3>
                  MismatchedPkgName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MismatchedPkgName" class="anchor" title="Link to MismatchedPkgName">#</a>
               </h3>
               
                  <p class="doc-comment">MismatchedPkgName occurs when a file's package name doesn't match the
package name already established by other files.</p>
               
               <pre><code class="language-go">const MismatchedPkgName</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MismatchedTypes" data-name="MismatchedTypes">
               <h3>
                  MismatchedTypes 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MismatchedTypes" class="anchor" title="Link to MismatchedTypes">#</a>
               </h3>
               
                  <p class="doc-comment">MismatchedTypes occurs when operand types are incompatible in a binary
operation.
Example:
var a = "hello"
var b = 1
var c = a - b</p>
               
               <pre><code class="language-go">const MismatchedTypes</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MisplacedBreak" data-name="MisplacedBreak">
               <h3>
                  MisplacedBreak 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MisplacedBreak" class="anchor" title="Link to MisplacedBreak">#</a>
               </h3>
               
                  <p class="doc-comment">MisplacedBreak occurs when a break statement is not within a for, switch,
or select statement of the innermost function definition.
Example:
func f() {
break
}</p>
               
               <pre><code class="language-go">const MisplacedBreak</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MisplacedConstraintIface" data-name="MisplacedConstraintIface">
               <h3>
                  MisplacedConstraintIface 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MisplacedConstraintIface" class="anchor" title="Link to MisplacedConstraintIface">#</a>
               </h3>
               
                  <p class="doc-comment">MisplacedConstraintIface occurs when a constraint-type interface is used
outside of constraint position.
Example:
type I interface { ~int }
var _ I</p>
               
               <pre><code class="language-go">const MisplacedConstraintIface</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MisplacedContinue" data-name="MisplacedContinue">
               <h3>
                  MisplacedContinue 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MisplacedContinue" class="anchor" title="Link to MisplacedContinue">#</a>
               </h3>
               
                  <p class="doc-comment">MisplacedContinue occurs when a continue statement is not within a for
loop of the innermost function definition.
Example:
func sumeven(n int) int {
proceed := func() {
continue
}
sum := 0
for i := 1; i <= n; i++ {
if i % 2 != 0 {
proceed()
}
sum += i
}
return sum
}</p>
               
               <pre><code class="language-go">const MisplacedContinue</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MisplacedDotDotDot" data-name="MisplacedDotDotDot">
               <h3>
                  MisplacedDotDotDot 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MisplacedDotDotDot" class="anchor" title="Link to MisplacedDotDotDot">#</a>
               </h3>
               
                  <p class="doc-comment">MisplacedDotDotDot occurs when a "..." is used somewhere other than the
final argument to a function call.
Example:
func printArgs(args ...int) {
for _, a := range args {
println(a)
}
}
func f() {
a := []int{1,2,3}
printArgs(0, a...)
}</p>
               
               <pre><code class="language-go">const MisplacedDotDotDot</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MisplacedFallthrough" data-name="MisplacedFallthrough">
               <h3>
                  MisplacedFallthrough 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MisplacedFallthrough" class="anchor" title="Link to MisplacedFallthrough">#</a>
               </h3>
               
                  <p class="doc-comment">MisplacedFallthrough occurs when a fallthrough statement is not within an
expression switch.
Example:
func typename(i interface{}) string {
switch i.(type) {
case int64:
fallthrough
case int:
return "int"
}
return "unsupported"
}</p>
               
               <pre><code class="language-go">const MisplacedFallthrough</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MisplacedLabel" data-name="MisplacedLabel">
               <h3>
                  MisplacedLabel 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MisplacedLabel" class="anchor" title="Link to MisplacedLabel">#</a>
               </h3>
               
                  <p class="doc-comment">MisplacedLabel occurs when a break or continue label is not on a for,
switch, or select statement.
Example:
func f() {
L:
a := []int{1,2,3}
for _, e := range a {
if e > 10 {
break L
}
println(a)
}
}</p>
               
               <pre><code class="language-go">const MisplacedLabel</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MisplacedTypeParam" data-name="MisplacedTypeParam">
               <h3>
                  MisplacedTypeParam 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MisplacedTypeParam" class="anchor" title="Link to MisplacedTypeParam">#</a>
               </h3>
               
                  <p class="doc-comment">MisplacedTypeParam occurs when a type parameter is used in a place where
it is not permitted.
Example:
type T[P any] P
Example:
type T[P any] struct{ *P }</p>
               
               <pre><code class="language-go">const MisplacedTypeParam</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MissingFieldOrMethod" data-name="MissingFieldOrMethod">
               <h3>
                  MissingFieldOrMethod 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MissingFieldOrMethod" class="anchor" title="Link to MissingFieldOrMethod">#</a>
               </h3>
               
                  <p class="doc-comment">MissingFieldOrMethod occurs when a selector references a field or method
that does not exist.
Example:
type T struct {}
var x = T{}.f</p>
               
               <pre><code class="language-go">const MissingFieldOrMethod</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MissingInitBody" data-name="MissingInitBody">
               <h3>
                  MissingInitBody 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MissingInitBody" class="anchor" title="Link to MissingInitBody">#</a>
               </h3>
               
                  <p class="doc-comment">MissingInitBody occurs when an init function is missing its body.
Example:
func init()</p>
               
               <pre><code class="language-go">const MissingInitBody</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MissingLitField" data-name="MissingLitField">
               <h3>
                  MissingLitField 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MissingLitField" class="anchor" title="Link to MissingLitField">#</a>
               </h3>
               
                  <p class="doc-comment">MissingLitField occurs when a struct literal refers to a field that does
not exist on the struct type.
Example:
var _ = struct{i int}{j: 2}</p>
               
               <pre><code class="language-go">const MissingLitField</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MissingLitKey" data-name="MissingLitKey">
               <h3>
                  MissingLitKey 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MissingLitKey" class="anchor" title="Link to MissingLitKey">#</a>
               </h3>
               
                  <p class="doc-comment">MissingLitKey occurs when a map literal is missing a key expression.
Example:
var _ = map[string]int{1}</p>
               
               <pre><code class="language-go">const MissingLitKey</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MissingReturn" data-name="MissingReturn">
               <h3>
                  MissingReturn 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MissingReturn" class="anchor" title="Link to MissingReturn">#</a>
               </h3>
               
                  <p class="doc-comment">MissingReturn occurs when a function with results is missing a return
statement.
Example:
func f() int {}</p>
               
               <pre><code class="language-go">const MissingReturn</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MixedStructLit" data-name="MixedStructLit">
               <h3>
                  MixedStructLit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MixedStructLit" class="anchor" title="Link to MixedStructLit">#</a>
               </h3>
               
                  <p class="doc-comment">MixedStructLit occurs when a struct literal contains a mix of positional
and named elements.
Example:
var _ = struct{i, j int}{i: 1, 2}</p>
               
               <pre><code class="language-go">const MixedStructLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MultiValAssignOp" data-name="MultiValAssignOp">
               <h3>
                  MultiValAssignOp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MultiValAssignOp" class="anchor" title="Link to MultiValAssignOp">#</a>
               </h3>
               
                  <p class="doc-comment">MultiValAssignOp occurs when an assignment operation (+=, *=, etc) does
not have single-valued left-hand or right-hand side.
Per the spec:
"In assignment operations, both the left- and right-hand expression lists
must contain exactly one single-valued expression"
Example:
func f() int {
x, y := 1, 2
x, y += 1
return x + y
}</p>
               
               <pre><code class="language-go">const MultiValAssignOp</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NoNewVar" data-name="NoNewVar">
               <h3>
                  NoNewVar 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NoNewVar" class="anchor" title="Link to NoNewVar">#</a>
               </h3>
               
                  <p class="doc-comment">NoNewVar occurs when a short variable declaration (':=') does not declare
new variables.
Example:
func f() {
x := 1
x := 2
}</p>
               
               <pre><code class="language-go">const NoNewVar</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NonIndexableOperand" data-name="NonIndexableOperand">
               <h3>
                  NonIndexableOperand 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NonIndexableOperand" class="anchor" title="Link to NonIndexableOperand">#</a>
               </h3>
               
                  <p class="doc-comment">NonIndexableOperand occurs when an index operation is applied to a value
that cannot be indexed.
Example:
var x = 1
var y = x[1]</p>
               
               <pre><code class="language-go">const NonIndexableOperand</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NonNumericIncDec" data-name="NonNumericIncDec">
               <h3>
                  NonNumericIncDec 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NonNumericIncDec" class="anchor" title="Link to NonNumericIncDec">#</a>
               </h3>
               
                  <p class="doc-comment">NonNumericIncDec occurs when an increment or decrement operator is
applied to a non-numeric value.
Example:
func f() {
var c = "c"
c++
}</p>
               
               <pre><code class="language-go">const NonNumericIncDec</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NonSliceableOperand" data-name="NonSliceableOperand">
               <h3>
                  NonSliceableOperand 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NonSliceableOperand" class="anchor" title="Link to NonSliceableOperand">#</a>
               </h3>
               
                  <p class="doc-comment">NonSliceableOperand occurs when a slice operation is applied to a value
whose type is not sliceable, or is unaddressable.
Example:
var x = [...]int{1, 2, 3}[:1]
Example:
var x = 1
var y = 1[:1]</p>
               
               <pre><code class="language-go">const NonSliceableOperand</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NonVariadicDotDotDot" data-name="NonVariadicDotDotDot">
               <h3>
                  NonVariadicDotDotDot 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NonVariadicDotDotDot" class="anchor" title="Link to NonVariadicDotDotDot">#</a>
               </h3>
               
                  <p class="doc-comment">NonVariadicDotDotDot occurs when a "..." is used on the final argument to
a non-variadic function.
Example:
func printArgs(s []string) {
for _, a := range s {
println(a)
}
}
func f() {
s := []string{"a", "b", "c"}
printArgs(s...)
}</p>
               
               <pre><code class="language-go">const NonVariadicDotDotDot</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NotAGenericType" data-name="NotAGenericType">
               <h3>
                  NotAGenericType 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NotAGenericType" class="anchor" title="Link to NotAGenericType">#</a>
               </h3>
               
                  <p class="doc-comment">NotAGenericType occurs when a non-generic type is used where a generic
type is expected: in type or function instantiation.
Example:
type T int
var _ T[int]</p>
               
               <pre><code class="language-go">const NotAGenericType</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NotAType" data-name="NotAType">
               <h3>
                  NotAType 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NotAType" class="anchor" title="Link to NotAType">#</a>
               </h3>
               
                  <p class="doc-comment">NotAType occurs when the identifier used as the underlying type in a type
declaration or the right-hand side of a type alias does not denote a type.
Example:
var S = 2
type T S</p>
               
               <pre><code class="language-go">const NotAType</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NotAnExpr" data-name="NotAnExpr">
               <h3>
                  NotAnExpr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NotAnExpr" class="anchor" title="Link to NotAnExpr">#</a>
               </h3>
               
                  <p class="doc-comment">NotAnExpr occurs when a type expression is used where a value expression
is expected.
Example:
type T struct {}
func f() {
T
}</p>
               
               <pre><code class="language-go">const NotAnExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NumericOverflow" data-name="NumericOverflow">
               <h3>
                  NumericOverflow 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NumericOverflow" class="anchor" title="Link to NumericOverflow">#</a>
               </h3>
               
                  <p class="doc-comment">NumericOverflow occurs when a numeric constant overflows its target type.
Example:
var x int8 = 1000</p>
               
               <pre><code class="language-go">const NumericOverflow</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OutOfScopeResult" data-name="OutOfScopeResult">
               <h3>
                  OutOfScopeResult 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OutOfScopeResult" class="anchor" title="Link to OutOfScopeResult">#</a>
               </h3>
               
                  <p class="doc-comment">OutOfScopeResult occurs when the name of a value implicitly returned by
an empty return statement is shadowed in a nested scope.
Example:
func factor(n int) (i int) {
for i := 2; i < n; i++ {
if n%i == 0 {
return
}
}
return 0
}</p>
               
               <pre><code class="language-go">const OutOfScopeResult</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="OversizeArrayLit" data-name="OversizeArrayLit">
               <h3>
                  OversizeArrayLit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#OversizeArrayLit" class="anchor" title="Link to OversizeArrayLit">#</a>
               </h3>
               
                  <p class="doc-comment">OversizeArrayLit occurs when an array literal exceeds its length.
Example:
var _ = [2]int{1,2,3}</p>
               
               <pre><code class="language-go">const OversizeArrayLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="RepeatedDecl" data-name="RepeatedDecl">
               <h3>
                  RepeatedDecl 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#RepeatedDecl" class="anchor" title="Link to RepeatedDecl">#</a>
               </h3>
               
                  <p class="doc-comment">RepeatedDecl occurs when an identifier occurs more than once on the left
hand side of a short variable declaration.
Example:
func _() {
x, y, y := 1, 2, 3
}</p>
               
               <pre><code class="language-go">const RepeatedDecl</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SwappedMakeArgs" data-name="SwappedMakeArgs">
               <h3>
                  SwappedMakeArgs 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SwappedMakeArgs" class="anchor" title="Link to SwappedMakeArgs">#</a>
               </h3>
               
                  <p class="doc-comment">SwappedMakeArgs occurs when make is called with three arguments, and its
length argument is larger than its capacity argument.
Example:
var x = make([]int, 3, 2)</p>
               
               <pre><code class="language-go">const SwappedMakeArgs</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="SwappedSliceIndices" data-name="SwappedSliceIndices">
               <h3>
                  SwappedSliceIndices 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#SwappedSliceIndices" class="anchor" title="Link to SwappedSliceIndices">#</a>
               </h3>
               
                  <p class="doc-comment">SwappedSliceIndices occurs when constant indices in a slice expression
are decreasing in value.
Example:
var _ = []int{1,2,3}[2:1]</p>
               
               <pre><code class="language-go">const SwappedSliceIndices</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="Test" data-name="Test">
               <h3>
                  Test 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#Test" class="anchor" title="Link to Test">#</a>
               </h3>
               
                  <p class="doc-comment">Test is reserved for errors that only apply while in self-test mode.</p>
               
               <pre><code class="language-go">const Test</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TooManyValues" data-name="TooManyValues">
               <h3>
                  TooManyValues 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TooManyValues" class="anchor" title="Link to TooManyValues">#</a>
               </h3>
               
                  <p class="doc-comment">TooManyValues occurs when a function returns too many values for the
expression context in which it is used.
Example:
func ReturnTwo() (int, int) {
return 1, 2
}
var x = ReturnTwo()</p>
               
               <pre><code class="language-go">const TooManyValues</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="TruncatedFloat" data-name="TruncatedFloat">
               <h3>
                  TruncatedFloat 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#TruncatedFloat" class="anchor" title="Link to TruncatedFloat">#</a>
               </h3>
               
                  <p class="doc-comment">TruncatedFloat occurs when a float constant is truncated to an integer
value.
Example:
var _ int = 98.6</p>
               
               <pre><code class="language-go">const TruncatedFloat</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnaddressableFieldAssign" data-name="UnaddressableFieldAssign">
               <h3>
                  UnaddressableFieldAssign 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnaddressableFieldAssign" class="anchor" title="Link to UnaddressableFieldAssign">#</a>
               </h3>
               
                  <p class="doc-comment">UnaddressableFieldAssign occurs when trying to assign to a struct field
in a map value.
Example:
func f() {
m := make(map[string]struct{i int})
m["foo"].i = 42
}</p>
               
               <pre><code class="language-go">const UnaddressableFieldAssign</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnaddressableOperand" data-name="UnaddressableOperand">
               <h3>
                  UnaddressableOperand 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnaddressableOperand" class="anchor" title="Link to UnaddressableOperand">#</a>
               </h3>
               
                  <p class="doc-comment">UnaddressableOperand occurs when the & operator is applied to an
unaddressable expression.
Example:
var x = &1</p>
               
               <pre><code class="language-go">const UnaddressableOperand</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnassignableOperand" data-name="UnassignableOperand">
               <h3>
                  UnassignableOperand 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnassignableOperand" class="anchor" title="Link to UnassignableOperand">#</a>
               </h3>
               
                  <p class="doc-comment">UnassignableOperand occurs when the left-hand side of an assignment is
not assignable.
Example:
func f() {
const c = 1
c = 2
}</p>
               
               <pre><code class="language-go">const UnassignableOperand</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UncalledBuiltin" data-name="UncalledBuiltin">
               <h3>
                  UncalledBuiltin 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UncalledBuiltin" class="anchor" title="Link to UncalledBuiltin">#</a>
               </h3>
               
                  <p class="doc-comment">UncalledBuiltin occurs when a built-in function is used as a
function-valued expression, instead of being called.
Per the spec:
"The built-in functions do not have standard Go types, so they can only
appear in call expressions; they cannot be used as function values."
Example:
var _ = copy</p>
               
               <pre><code class="language-go">const UncalledBuiltin</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UndeclaredImportedName" data-name="UndeclaredImportedName">
               <h3>
                  UndeclaredImportedName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UndeclaredImportedName" class="anchor" title="Link to UndeclaredImportedName">#</a>
               </h3>
               
                  <p class="doc-comment">UndeclaredImportedName occurs when a package-qualified identifier is
undeclared by the imported package.
Example:
import "go/types"
var _ = types.NotAnActualIdentifier</p>
               
               <pre><code class="language-go">const UndeclaredImportedName</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UndeclaredLabel" data-name="UndeclaredLabel">
               <h3>
                  UndeclaredLabel 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UndeclaredLabel" class="anchor" title="Link to UndeclaredLabel">#</a>
               </h3>
               
                  <p class="doc-comment">UndeclaredLabel occurs when an undeclared label is jumped to.
Example:
func f() {
goto L
}</p>
               
               <pre><code class="language-go">const UndeclaredLabel</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UndeclaredName" data-name="UndeclaredName">
               <h3>
                  UndeclaredName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UndeclaredName" class="anchor" title="Link to UndeclaredName">#</a>
               </h3>
               
                  <p class="doc-comment">UndeclaredName occurs when an identifier is not declared in the current
scope.
Example:
var x T</p>
               
               <pre><code class="language-go">const UndeclaredName</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UndefinedOp" data-name="UndefinedOp">
               <h3>
                  UndefinedOp 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UndefinedOp" class="anchor" title="Link to UndefinedOp">#</a>
               </h3>
               
                  <p class="doc-comment">UndefinedOp occurs when an operator is not defined for the type(s) used
in an operation.
Example:
var c = "a" - "b"</p>
               
               <pre><code class="language-go">const UndefinedOp</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnexportedLitField" data-name="UnexportedLitField">
               <h3>
                  UnexportedLitField 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnexportedLitField" class="anchor" title="Link to UnexportedLitField">#</a>
               </h3>
               
                  <p class="doc-comment">UnexportedLitField occurs when a positional struct literal implicitly
assigns an unexported field of an imported type.</p>
               
               <pre><code class="language-go">const UnexportedLitField</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnexportedName" data-name="UnexportedName">
               <h3>
                  UnexportedName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnexportedName" class="anchor" title="Link to UnexportedName">#</a>
               </h3>
               
                  <p class="doc-comment">UnexportedName occurs when a selector refers to an unexported identifier
of an imported package.
Example:
import "reflect"
type _ reflect.flag</p>
               
               <pre><code class="language-go">const UnexportedName</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnsupportedFeature" data-name="UnsupportedFeature">
               <h3>
                  UnsupportedFeature 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnsupportedFeature" class="anchor" title="Link to UnsupportedFeature">#</a>
               </h3>
               
                  <p class="doc-comment">UnsupportedFeature occurs when a language feature is used that is not
supported at this Go version.</p>
               
               <pre><code class="language-go">const UnsupportedFeature</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UntypedLit" data-name="UntypedLit">
               <h3>
                  UntypedLit 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UntypedLit" class="anchor" title="Link to UntypedLit">#</a>
               </h3>
               
                  <p class="doc-comment">UntypedLit occurs when a composite literal omits a required type
identifier.
Example:
type outer struct{
inner struct { i int }
}
var _ = outer{inner: {1}}</p>
               
               <pre><code class="language-go">const UntypedLit</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UntypedNilUse" data-name="UntypedNilUse">
               <h3>
                  UntypedNilUse 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UntypedNilUse" class="anchor" title="Link to UntypedNilUse">#</a>
               </h3>
               
                  <p class="doc-comment">UntypedNilUse occurs when the predeclared (untyped) value nil is used to
initialize a variable declared without an explicit type.
Example:
var x = nil</p>
               
               <pre><code class="language-go">const UntypedNilUse</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnusedExpr" data-name="UnusedExpr">
               <h3>
                  UnusedExpr 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnusedExpr" class="anchor" title="Link to UnusedExpr">#</a>
               </h3>
               
                  <p class="doc-comment">UnusedExpr occurs when a side-effect free expression is used as a
statement. Such a statement has no effect.
Example:
func f(i int) {
i*i
}</p>
               
               <pre><code class="language-go">const UnusedExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnusedImport" data-name="UnusedImport">
               <h3>
                  UnusedImport 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnusedImport" class="anchor" title="Link to UnusedImport">#</a>
               </h3>
               
                  <p class="doc-comment">UnusedImport occurs when an import is unused.
Example:
import "fmt"
func main() {}</p>
               
               <pre><code class="language-go">const UnusedImport</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnusedLabel" data-name="UnusedLabel">
               <h3>
                  UnusedLabel 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnusedLabel" class="anchor" title="Link to UnusedLabel">#</a>
               </h3>
               
                  <p class="doc-comment">UnusedLabel occurs when a label is declared but not used.
Example:
func f() {
L:
}</p>
               
               <pre><code class="language-go">const UnusedLabel</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnusedResults" data-name="UnusedResults">
               <h3>
                  UnusedResults 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnusedResults" class="anchor" title="Link to UnusedResults">#</a>
               </h3>
               
                  <p class="doc-comment">UnusedResults occurs when a restricted expression-only built-in function
is suspended via go or defer. Such a suspension discards the results of
these side-effect free built-in functions, and therefore is ineffectual.
Example:
func f(a []int) int {
defer len(a)
return i
}</p>
               
               <pre><code class="language-go">const UnusedResults</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="UnusedVar" data-name="UnusedVar">
               <h3>
                  UnusedVar 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#UnusedVar" class="anchor" title="Link to UnusedVar">#</a>
               </h3>
               
                  <p class="doc-comment">UnusedVar occurs when a variable is declared but unused.
Example:
func f() {
x := 1
}</p>
               
               <pre><code class="language-go">const UnusedVar</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WrongArgCount" data-name="WrongArgCount">
               <h3>
                  WrongArgCount 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#WrongArgCount" class="anchor" title="Link to WrongArgCount">#</a>
               </h3>
               
                  <p class="doc-comment">WrongArgCount occurs when too few or too many arguments are passed by a
function call.
Example:
func f(i int) {}
var x = f()</p>
               
               <pre><code class="language-go">const WrongArgCount</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WrongAssignCount" data-name="WrongAssignCount">
               <h3>
                  WrongAssignCount 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#WrongAssignCount" class="anchor" title="Link to WrongAssignCount">#</a>
               </h3>
               
                  <p class="doc-comment">WrongAssignCount occurs when the number of values on the right-hand side
of an assignment or initialization expression does not match the number
of variables on the left-hand side.
Example:
var x = 1, 2</p>
               
               <pre><code class="language-go">const WrongAssignCount</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WrongResultCount" data-name="WrongResultCount">
               <h3>
                  WrongResultCount 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#WrongResultCount" class="anchor" title="Link to WrongResultCount">#</a>
               </h3>
               
                  <p class="doc-comment">WrongResultCount occurs when a return statement returns an incorrect
number of values.
Example:
func ReturnOne() int {
return 1, 2
}</p>
               
               <pre><code class="language-go">const WrongResultCount</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="WrongTypeArgCount" data-name="WrongTypeArgCount">
               <h3>
                  WrongTypeArgCount 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#WrongTypeArgCount" class="anchor" title="Link to WrongTypeArgCount">#</a>
               </h3>
               
                  <p class="doc-comment">WrongTypeArgCount occurs when a type or function is instantiated with an
incorrect number of type arguments, including when a generic type or
function is used without instantiation.
Errors involving failed type inference are assigned other error codes.
Example:
type T[p any] int
var _ T[int, string]
Example:
func f[T any]() {}
var x = f</p>
               
               <pre><code class="language-go">const WrongTypeArgCount</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">const _ ErrorCode = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
                  <p class="doc-comment">InvalidUnsafeStringData occurs if it is used in a package
compiled for a language version before go1.20.</p>
               
               <pre><code class="language-go">const _</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ErrorCode_index_1" data-name="_ErrorCode_index_1">
               <h3>
                  _ErrorCode_index_1 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_ErrorCode_index_1" class="anchor" title="Link to _ErrorCode_index_1">#</a>
               </h3>
               
               <pre><code class="language-go">var _ErrorCode_index_1 = [...]uint16{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ErrorCode_name_0" data-name="_ErrorCode_name_0">
               <h3>
                  _ErrorCode_name_0 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_ErrorCode_name_0" class="anchor" title="Link to _ErrorCode_name_0">#</a>
               </h3>
               
               <pre><code class="language-go">const _ErrorCode_name_0 = "InvalidSyntaxTree"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_ErrorCode_name_1" data-name="_ErrorCode_name_1">
               <h3>
                  _ErrorCode_name_1 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#_ErrorCode_name_1" class="anchor" title="Link to _ErrorCode_name_1">#</a>
               </h3>
               
               <pre><code class="language-go">const _ErrorCode_name_1 = "TestBlankPkgNameMismatchedPkgNameInvalidPkgUseBadImportPathBrokenImportImportCRenamedUnusedImportInvalidInitCycleDuplicateDeclInvalidDeclCycleInvalidTypeCycleInvalidConstInitInvalidConstValInvalidConstTypeUntypedNilUseWrongAssignCountUnassignableOperandNoNewVarMultiValAssignOpInvalidIfaceAssignInvalidChanAssignIncompatibleAssignUnaddressableFieldAssignNotATypeInvalidArrayLenBlankIfaceMethodIncomparableMapKeyInvalidIfaceEmbedInvalidPtrEmbedBadRecvInvalidRecvDuplicateFieldAndMethodDuplicateMethodInvalidBlankInvalidIotaMissingInitBodyInvalidInitSigInvalidInitDeclInvalidMainDeclTooManyValuesNotAnExprTruncatedFloatNumericOverflowUndefinedOpMismatchedTypesDivByZeroNonNumericIncDecUnaddressableOperandInvalidIndirectionNonIndexableOperandInvalidIndexSwappedSliceIndicesNonSliceableOperandInvalidSliceExprInvalidShiftCountInvalidShiftOperandInvalidReceiveInvalidSendDuplicateLitKeyMissingLitKeyInvalidLitIndexOversizeArrayLitMixedStructLitInvalidStructLitMissingLitFieldDuplicateLitFieldUnexportedLitFieldInvalidLitFieldUntypedLitInvalidLitAmbiguousSelectorUndeclaredImportedNameUnexportedNameUndeclaredNameMissingFieldOrMethodBadDotDotDotSyntaxNonVariadicDotDotDotMisplacedDotDotDotInvalidDotDotDotOperandInvalidDotDotDotUncalledBuiltinInvalidAppendInvalidCapInvalidCloseInvalidCopyInvalidComplexInvalidDeleteInvalidImagInvalidLenSwappedMakeArgsInvalidMakeInvalidRealInvalidAssertImpossibleAssertInvalidConversionInvalidUntypedConversionBadOffsetofSyntaxInvalidOffsetofUnusedExprUnusedVarMissingReturnWrongResultCountOutOfScopeResultInvalidCondInvalidPostDeclInvalidChanRangeInvalidIterVarInvalidRangeExprMisplacedBreakMisplacedContinueMisplacedFallthroughDuplicateCaseDuplicateDefaultBadTypeKeywordInvalidTypeSwitchInvalidExprSwitchInvalidSelectCaseUndeclaredLabelDuplicateLabelMisplacedLabelUnusedLabelJumpOverDeclJumpIntoBlockInvalidMethodExprWrongArgCountInvalidCallUnusedResultsInvalidDeferInvalidGoBadDeclRepeatedDeclInvalidUnsafeAddInvalidUnsafeSliceUnsupportedFeatureNotAGenericTypeWrongTypeArgCountCannotInferTypeArgsInvalidTypeArgInvalidInstanceCycleInvalidUnionMisplacedConstraintIfaceInvalidMethodTypeParamsMisplacedTypeParamInvalidUnsafeSliceDataInvalidUnsafeString"</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="ErrorCode" data-name="ErrorCode">
               <h3>
                  ErrorCode
                  <span class="badge type-badge">type</span>
                  <a href="#ErrorCode" class="anchor" title="Link to ErrorCode">#</a>
               </h3>
               
               <pre><code class="language-go">type ErrorCode int</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="NamedOrAlias" data-name="NamedOrAlias">
               <h3>
                  NamedOrAlias
                  <span class="badge interface-badge">interface</span>
                  <a href="#NamedOrAlias" class="anchor" title="Link to NamedOrAlias">#</a>
               </h3>
               
               <p>A NamedOrAlias is a [types.Type] that is named (as
defined by the spec) and capable of bearing type parameters: it
abstracts aliases ([types.Alias]) and defined types
([types.Named]).
Every type declared by an explicit "type" declaration is a
NamedOrAlias. (Built-in type symbols may additionally
have type [types.Basic], which is not a NamedOrAlias,
though the spec regards them as "named".)
NamedOrAlias cannot expose the Origin method, because
[types.Alias.Origin] and [types.Named.Origin] have different
(covariant) result types; use [Origin] instead.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type NamedOrAlias interface {
types.Type
Obj() *types.TypeName
}</code></pre>
            </article>
            
         </section>
           
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="ForEachElement" data-name="ForEachElement">
               <h3>
                  ForEachElement 
                  <span class="badge">function</span>
                  
                  <a href="#ForEachElement" class="anchor" title="Link to ForEachElement">#</a>
               </h3>
               
               <p>ForEachElement calls f for type T and each type reachable from its
type through reflection. It does this by recursively stripping off
type constructors; in addition, for each named type N, the type *N
is added to the result as it may have additional methods.
The caller must provide an initially empty set used to de-duplicate
identical types, potentially across multiple calls to ForEachElement.
(Its final value holds all the elements seen, matching the arguments
passed to f.)
TODO(adonovan): share/harmonize with go/callgraph/rta.</p>
               
               <pre><code class="language-go">func ForEachElement(rtypes *typeutil.Map, msets *typeutil.MethodSetCache, T types.Type, f func(types.Type))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsZeroExpr" data-name="IsZeroExpr">
               <h3>
                  IsZeroExpr 
                  <span class="badge">function</span>
                  
                  <a href="#IsZeroExpr" class="anchor" title="Link to IsZeroExpr">#</a>
               </h3>
               
               <p>IsZeroExpr uses simple syntactic heuristics to report whether expr
is a obvious zero value, such as 0, "", nil, or false.
It cannot do better without type information.</p>
               
               <pre><code class="language-go">func IsZeroExpr(expr ast.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NameRelativeTo" data-name="NameRelativeTo">
               <h3>
                  NameRelativeTo 
                  <span class="badge">function</span>
                  
                  <a href="#NameRelativeTo" class="anchor" title="Link to NameRelativeTo">#</a>
               </h3>
               
               <p>NameRelativeTo returns a types.Qualifier that qualifies members of
all packages other than pkg, using only the package name.
(By contrast, [types.RelativeTo] uses the complete package path,
which is often excessive.)
If pkg is nil, it is equivalent to [*types.Package.Name].</p>
               
               <pre><code class="language-go">func NameRelativeTo(pkg *types.Package) types.Qualifier</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Origin" data-name="Origin">
               <h3>
                  Origin 
                  <span class="badge">function</span>
                  
                  <a href="#Origin" class="anchor" title="Link to Origin">#</a>
               </h3>
               
               <p>Origin returns the generic type of the Named or Alias type t if it
is instantiated, otherwise it returns t.</p>
               
               <pre><code class="language-go">func Origin(t NamedOrAlias) NamedOrAlias</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadGo116ErrorData" data-name="ReadGo116ErrorData">
               <h3>
                  ReadGo116ErrorData 
                  <span class="badge">function</span>
                  
                  <a href="#ReadGo116ErrorData" class="anchor" title="Link to ReadGo116ErrorData">#</a>
               </h3>
               
               <p>ReadGo116ErrorData extracts additional information from types.Error values
generated by Go version 1.16 and later: the error code, start position, and
end position. If all positions are valid, start <= err.Pos <= end.
If the data could not be read, the final result parameter will be false.</p>
               
               <pre><code class="language-go">func ReadGo116ErrorData(err types.Error) (code ErrorCode, start token.Pos, end token.Pos, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReceiverNamed" data-name="ReceiverNamed">
               <h3>
                  ReceiverNamed 
                  <span class="badge">function</span>
                  
                  <a href="#ReceiverNamed" class="anchor" title="Link to ReceiverNamed">#</a>
               </h3>
               
               <p>ReceiverNamed returns the named type (if any) associated with the
type of recv, which may be of the form N or *N, or aliases thereof.
It also reports whether a Pointer was present.</p>
               
               <pre><code class="language-go">func ReceiverNamed(recv *types.Var) (isPtr bool, named *types.Named)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetUsesCgo" data-name="SetUsesCgo">
               <h3>
                  SetUsesCgo 
                  <span class="badge">function</span>
                  
                  <a href="#SetUsesCgo" class="anchor" title="Link to SetUsesCgo">#</a>
               </h3>
               
               <pre><code class="language-go">func SetUsesCgo(conf *types.Config) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (i ErrorCode) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TooNewStdSymbols" data-name="TooNewStdSymbols">
               <h3>
                  TooNewStdSymbols 
                  <span class="badge">function</span>
                  
                  <a href="#TooNewStdSymbols" class="anchor" title="Link to TooNewStdSymbols">#</a>
               </h3>
               
               <p>TooNewStdSymbols computes the set of package-level symbols
exported by pkg that are not available at the specified version.
The result maps each symbol to its minimum version.
The pkg is allowed to contain type errors.</p>
               
               <pre><code class="language-go">func TooNewStdSymbols(pkg *types.Package, version string) map[types.Object]string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeArgs" data-name="TypeArgs">
               <h3>
                  TypeArgs 
                  <span class="badge">function</span>
                  
                  <a href="#TypeArgs" class="anchor" title="Link to TypeArgs">#</a>
               </h3>
               
               <p>TypeArgs is a light shim around t.TypeArgs().
(go/types.Alias).TypeArgs requires >= 1.23.</p>
               
               <pre><code class="language-go">func TypeArgs(t NamedOrAlias) *types.TypeList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeExpr" data-name="TypeExpr">
               <h3>
                  TypeExpr 
                  <span class="badge">function</span>
                  
                  <a href="#TypeExpr" class="anchor" title="Link to TypeExpr">#</a>
               </h3>
               
               <p>TypeExpr returns syntax for the specified type. References to named types
from packages other than pkg are qualified by an appropriate package name, as
defined by the import environment of file.
It may panic for types such as Tuple or Union.</p>
               
               <pre><code class="language-go">func TypeExpr(f *ast.File, pkg *types.Package, typ types.Type) ast.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="TypeParams" data-name="TypeParams">
               <h3>
                  TypeParams 
                  <span class="badge">function</span>
                  
                  <a href="#TypeParams" class="anchor" title="Link to TypeParams">#</a>
               </h3>
               
               <p>TypeParams is a light shim around t.TypeParams().
(go/types.Alias).TypeParams requires >= 1.23.</p>
               
               <pre><code class="language-go">func TypeParams(t NamedOrAlias) *types.TypeParamList</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unpointer" data-name="Unpointer">
               <h3>
                  Unpointer 
                  <span class="badge">function</span>
                  
                  <a href="#Unpointer" class="anchor" title="Link to Unpointer">#</a>
               </h3>
               
               <p>Unpointer returns T given *T or an alias thereof.
For all other types it is the identity function.
It does not look at underlying types.
The result may be an alias.
Use this function to strip off the optional pointer on a receiver
in a field or method selection, without losing the named type
(which is needed to compute the method set).
See also [typeparams.MustDeref], which removes one level of
indirection from the type, regardless of named types (analogous to
a LOAD instruction).</p>
               
               <pre><code class="language-go">func Unpointer(t types.Type) types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ZeroExpr" data-name="ZeroExpr">
               <h3>
                  ZeroExpr 
                  <span class="badge">function</span>
                  
                  <a href="#ZeroExpr" class="anchor" title="Link to ZeroExpr">#</a>
               </h3>
               
               <p>ZeroExpr returns the ast.Expr representation of the "zero" value of the type t.
ZeroExpr is defined for types that are suitable for variables.
It may panic for other types such as Tuple or Union.
See [ZeroString] for a variant that returns a string.</p>
               
               <pre><code class="language-go">func ZeroExpr(f *ast.File, pkg *types.Package, typ types.Type) ast.Expr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ZeroString" data-name="ZeroString">
               <h3>
                  ZeroString 
                  <span class="badge">function</span>
                  
                  <a href="#ZeroString" class="anchor" title="Link to ZeroString">#</a>
               </h3>
               
               <p>ZeroString returns the string representation of the "zero" value of the type t.
This string can be used on the right-hand side of an assignment where the
left-hand side has that explicit type.
Exception: This does not apply to tuples. Their string representation is
informational only and cannot be used in an assignment.
When assigning to a wider type (such as 'any'), it's the caller's
responsibility to handle any necessary type conversions.
See [ZeroExpr] for a variant that returns an [ast.Expr].</p>
               
               <pre><code class="language-go">func ZeroString(t types.Type, qf types.Qualifier) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge">function</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code class="language-go">func _()</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>