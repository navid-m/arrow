<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - binutils</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>binutils</code>
         </h1>
         <hr />
         
         <article class="global" data-name="defaultAddr2line">
            <h2>defaultAddr2line</h2>
            <hr />
            
            <pre><code>defaultAddr2line</code></pre>
         </article>
         
         <article class="global" data-name="sentinel">
            <h2>sentinel</h2>
            <hr />
            
            <p>addr2line may produce multiple lines of output. We
use this sentinel to identify the end of the output.</p>
            
            <pre><code>sentinel</code></pre>
         </article>
         
         <article class="global" data-name="defaultLLVMSymbolizer">
            <h2>defaultLLVMSymbolizer</h2>
            <hr />
            
            <pre><code>defaultLLVMSymbolizer</code></pre>
         </article>
         
         <article class="global" data-name="defaultNM">
            <h2>defaultNM</h2>
            <hr />
            
            <pre><code>defaultNM</code></pre>
         </article>
         
         <article class="global" data-name="objdumpLLVMVerRE">
            <h2>objdumpLLVMVerRE</h2>
            <hr />
            
            <pre><code>objdumpLLVMVerRE</code></pre>
         </article>
         
         <article class="global" data-name="elfOpen">
            <h2>elfOpen</h2>
            <hr />
            
            <p>Defined for testing</p>
            
            <pre><code>elfOpen</code></pre>
         </article>
         
         <article class="global" data-name="nmOutputRE">
            <h2>nmOutputRE</h2>
            <hr />
            
            <pre><code>nmOutputRE</code></pre>
         </article>
         
         <article class="global" data-name="objdumpAsmOutputRE">
            <h2>objdumpAsmOutputRE</h2>
            <hr />
            
            <pre><code>objdumpAsmOutputRE</code></pre>
         </article>
         
         <article class="global" data-name="objdumpOutputFileLine">
            <h2>objdumpOutputFileLine</h2>
            <hr />
            
            <pre><code>objdumpOutputFileLine</code></pre>
         </article>
         
         <article class="global" data-name="objdumpOutputFunction">
            <h2>objdumpOutputFunction</h2>
            <hr />
            
            <pre><code>objdumpOutputFunction</code></pre>
         </article>
         
         <article class="global" data-name="objdumpOutputFunctionLLVM">
            <h2>objdumpOutputFunctionLLVM</h2>
            <hr />
            
            <pre><code>objdumpOutputFunctionLLVM</code></pre>
         </article>
          
         <article class="struct" data-name="addr2Liner">
            <h2>type addr2Liner struct</h2>
            <hr />
            
            <p>addr2Liner is a connection to an addr2line command for obtaining
address and line number information from a binary.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mu sync.Mutex
rw lineReaderWriter
base uint64
nm *addr2LinerNM</code></pre>
         </article>
         
         <article class="struct" data-name="addr2LinerJob">
            <h2>type addr2LinerJob struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">cmd *exec.Cmd
in io.WriteCloser
out *bufio.Reader</code></pre>
         </article>
         
         <article class="struct" data-name="llvmSymbolizer">
            <h2>type llvmSymbolizer struct</h2>
            <hr />
            
            <p>llvmSymbolizer is a connection to an llvm-symbolizer command for
obtaining address and line number information from a binary.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">sync.Mutex
filename string
rw lineReaderWriter
base uint64
isData bool</code></pre>
         </article>
         
         <article class="struct" data-name="llvmSymbolizerJob">
            <h2>type llvmSymbolizerJob struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">cmd *exec.Cmd
in io.WriteCloser
out *bufio.Reader
symType string</code></pre>
         </article>
         
         <article class="struct" data-name="addr2LinerNM">
            <h2>type addr2LinerNM struct</h2>
            <hr />
            
            <p>addr2LinerNM is a connection to an nm command for obtaining symbol
information from a binary.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">m []symbolInfo</code></pre>
         </article>
         
         <article class="struct" data-name="symbolInfo">
            <h2>type symbolInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">address uint64
size uint64
name string
symType string</code></pre>
         </article>
         
         <article class="struct" data-name="Binutils">
            <h2>type Binutils struct</h2>
            <hr />
            
            <p>A Binutils implements plugin.ObjTool by invoking the GNU binutils.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">mu sync.Mutex
rep *binrep</code></pre>
         </article>
         
         <article class="struct" data-name="binrep">
            <h2>type binrep struct</h2>
            <hr />
            
            <p>binrep is an immutable representation for Binutils.  It is atomically
replaced on every mutation to provide thread-safe access.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">llvmSymbolizer string
llvmSymbolizerFound bool
addr2line string
addr2lineFound bool
nm string
nmFound bool
objdump string
objdumpFound bool
isLLVMObjdump bool
fast bool</code></pre>
         </article>
         
         <article class="struct" data-name="elfMapping">
            <h2>type elfMapping struct</h2>
            <hr />
            
            <p>elfMapping stores the parameters of a runtime mapping that are needed to
identify the ELF segment associated with a mapping.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">start uint64
limit uint64
offset uint64
kernelOffset *uint64</code></pre>
         </article>
         
         <article class="struct" data-name="file">
            <h2>type file struct</h2>
            <hr />
            
            <p>file implements the binutils.ObjFile interface.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">b *binrep
name string
buildID string
baseOnce sync.Once
base uint64
baseErr error
isData bool
m *elfMapping</code></pre>
         </article>
         
         <article class="struct" data-name="fileNM">
            <h2>type fileNM struct</h2>
            <hr />
            
            <p>fileNM implements the binutils.ObjFile interface, using 'nm' to map
addresses to symbols (without file/line number information). It is
faster than fileAddr2Line.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">file
addr2linernm *addr2LinerNM</code></pre>
         </article>
         
         <article class="struct" data-name="fileAddr2Line">
            <h2>type fileAddr2Line struct</h2>
            <hr />
            
            <p>fileAddr2Line implements the binutils.ObjFile interface, using
llvm-symbolizer, if that's available, or addr2line to map addresses to
symbols (with file/line number information). It can be slow for large
binaries with debug information.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">once sync.Once
file
addr2liner *addr2Liner
llvmSymbolizer *llvmSymbolizer
isData bool</code></pre>
         </article>
          
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <pre><code>func write(s string) error</code></pre>
         </article>
         
         <article class="function" data-name="readLine">
            <h2>readLine</h2>
            <hr />
            
            <pre><code>func readLine() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="close">
            <h2>close</h2>
            <hr />
            
            <p>close releases any resources used by the addr2liner object.</p>
            
            <pre><code>func close()</code></pre>
         </article>
         
         <article class="function" data-name="newAddr2Liner">
            <h2>newAddr2Liner</h2>
            <hr />
            
            <p>newAddr2Liner starts the given addr2liner command reporting
information about the given executable file. If file is a shared
library, base should be the address at which it was mapped in the
program under consideration.</p>
            
            <pre><code>func newAddr2Liner(cmd string, file string, base uint64) (*addr2Liner, error)</code></pre>
         </article>
         
         <article class="function" data-name="readFrame">
            <h2>readFrame</h2>
            <hr />
            
            <p>readFrame parses the addr2line output for a single address. It
returns a populated plugin.Frame and whether it has reached the end of the
data.</p>
            
            <pre><code>func readFrame() (plugin.Frame, bool)</code></pre>
         </article>
         
         <article class="function" data-name="rawAddrInfo">
            <h2>rawAddrInfo</h2>
            <hr />
            
            <pre><code>func rawAddrInfo(addr uint64) ([]plugin.Frame, error)</code></pre>
         </article>
         
         <article class="function" data-name="addrInfo">
            <h2>addrInfo</h2>
            <hr />
            
            <p>addrInfo returns the stack frame information for a specific program
address. It returns nil if the address could not be identified.</p>
            
            <pre><code>func addrInfo(addr uint64) ([]plugin.Frame, error)</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <pre><code>func write(s string) error</code></pre>
         </article>
         
         <article class="function" data-name="readLine">
            <h2>readLine</h2>
            <hr />
            
            <pre><code>func readLine() (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="close">
            <h2>close</h2>
            <hr />
            
            <p>close releases any resources used by the llvmSymbolizer object.</p>
            
            <pre><code>func close()</code></pre>
         </article>
         
         <article class="function" data-name="newLLVMSymbolizer">
            <h2>newLLVMSymbolizer</h2>
            <hr />
            
            <p>newLLVMSymbolizer starts the given llvmSymbolizer command reporting
information about the given executable file. If file is a shared
library, base should be the address at which it was mapped in the
program under consideration.</p>
            
            <pre><code>func newLLVMSymbolizer(cmd string, file string, base uint64, isData bool) (*llvmSymbolizer, error)</code></pre>
         </article>
         
         <article class="function" data-name="readDataFrames">
            <h2>readDataFrames</h2>
            <hr />
            
            <p>readDataFrames parses the llvm-symbolizer DATA output for a single address. It
returns a populated plugin.Frame array with a single entry.</p>
            
            <pre><code>func readDataFrames() ([]plugin.Frame, error)</code></pre>
         </article>
         
         <article class="function" data-name="readCodeFrames">
            <h2>readCodeFrames</h2>
            <hr />
            
            <p>readCodeFrames parses the llvm-symbolizer CODE output for a single address. It
returns a populated plugin.Frame array.</p>
            
            <pre><code>func readCodeFrames() ([]plugin.Frame, error)</code></pre>
         </article>
         
         <article class="function" data-name="addrInfo">
            <h2>addrInfo</h2>
            <hr />
            
            <p>addrInfo returns the stack frame information for a specific program
address. It returns nil if the address could not be identified.</p>
            
            <pre><code>func addrInfo(addr uint64) ([]plugin.Frame, error)</code></pre>
         </article>
         
         <article class="function" data-name="isData">
            <h2>isData</h2>
            <hr />
            
            <p>isData returns if the symbol has a known data object symbol type.</p>
            
            <pre><code>func isData() bool</code></pre>
         </article>
         
         <article class="function" data-name="newAddr2LinerNM">
            <h2>newAddr2LinerNM</h2>
            <hr />
            
            <p>newAddr2LinerNM starts the given nm command reporting information about the
given executable file. If file is a shared library, base should be the
address at which it was mapped in the program under consideration.</p>
            
            <pre><code>func newAddr2LinerNM(cmd string, file string, base uint64) (*addr2LinerNM, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseAddr2LinerNM">
            <h2>parseAddr2LinerNM</h2>
            <hr />
            
            <pre><code>func parseAddr2LinerNM(base uint64, nm io.Reader) (*addr2LinerNM, error)</code></pre>
         </article>
         
         <article class="function" data-name="addrInfo">
            <h2>addrInfo</h2>
            <hr />
            
            <p>addrInfo returns the stack frame information for a specific program
address. It returns nil if the address could not be identified.</p>
            
            <pre><code>func addrInfo(addr uint64) ([]plugin.Frame, error)</code></pre>
         </article>
         
         <article class="function" data-name="get">
            <h2>get</h2>
            <hr />
            
            <p>get returns the current representation for bu, initializing it if necessary.</p>
            
            <pre><code>func get() *binrep</code></pre>
         </article>
         
         <article class="function" data-name="update">
            <h2>update</h2>
            <hr />
            
            <p>update modifies the rep for bu via the supplied function.</p>
            
            <pre><code>func update(fn func)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String returns string representation of the binutils state for debug logging.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="SetFastSymbolization">
            <h2>SetFastSymbolization</h2>
            <hr />
            
            <p>SetFastSymbolization sets a toggle that makes binutils use fast
symbolization (using nm), which is much faster than addr2line but
provides only symbol name information (no file/line).</p>
            
            <pre><code>func SetFastSymbolization(fast bool)</code></pre>
         </article>
         
         <article class="function" data-name="SetTools">
            <h2>SetTools</h2>
            <hr />
            
            <p>SetTools processes the contents of the tools option. It
expects a set of entries separated by commas; each entry is a pair
of the form t:path, where cmd will be used to look only for the
tool named t. If t is not specified, the path is searched for all
tools.</p>
            
            <pre><code>func SetTools(config string)</code></pre>
         </article>
         
         <article class="function" data-name="initTools">
            <h2>initTools</h2>
            <hr />
            
            <pre><code>func initTools(b *binrep, config string)</code></pre>
         </article>
         
         <article class="function" data-name="findObjdump">
            <h2>findObjdump</h2>
            <hr />
            
            <p>findObjdump finds and returns path to preferred objdump binary.
Order of preference is: llvm-objdump, objdump.
On MacOS only, also looks for gobjdump with least preference.
Accepts a list of paths and returns:
a string with path to the preferred objdump binary if found,
or an empty string if not found;
a boolean if any acceptable objdump was found;
a boolean indicating if it is an LLVM objdump.</p>
            
            <pre><code>func findObjdump(paths []string) (string, bool, bool)</code></pre>
         </article>
         
         <article class="function" data-name="chooseExe">
            <h2>chooseExe</h2>
            <hr />
            
            <p>chooseExe finds and returns path to preferred binary. names is a list of
names to search on both Linux and OSX. osxNames is a list of names specific
to OSX. names always has a higher priority than osxNames. The order of
the name within each list decides its priority (e.g. the first name has a
higher priority than the second name in the list).

It returns a string with path to the binary and a boolean indicating if any
acceptable binary was found.</p>
            
            <pre><code>func chooseExe(names []string, osxNames []string, paths []string) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="isLLVMObjdump">
            <h2>isLLVMObjdump</h2>
            <hr />
            
            <p>isLLVMObjdump accepts a string with path to an objdump binary,
and returns a boolean indicating if the given binary is an LLVM
objdump binary of an acceptable version.</p>
            
            <pre><code>func isLLVMObjdump(output string) bool</code></pre>
         </article>
         
         <article class="function" data-name="isBuObjdump">
            <h2>isBuObjdump</h2>
            <hr />
            
            <p>isBuObjdump accepts a string with path to an objdump binary,
and returns a boolean indicating if the given binary is a GNU
binutils objdump binary. No version check is performed.</p>
            
            <pre><code>func isBuObjdump(output string) bool</code></pre>
         </article>
         
         <article class="function" data-name="findExe">
            <h2>findExe</h2>
            <hr />
            
            <p>findExe looks for an executable command on a set of paths.
If it cannot find it, returns cmd.</p>
            
            <pre><code>func findExe(cmd string, paths []string) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="Disasm">
            <h2>Disasm</h2>
            <hr />
            
            <p>Disasm returns the assembly instructions for the specified address range
of a binary.</p>
            
            <pre><code>func Disasm(file string, start uint64, end uint64, intelSyntax bool) ([]plugin.Inst, error)</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <p>Open satisfies the plugin.ObjTool interface.</p>
            
            <pre><code>func Open(name string, start uint64, limit uint64, offset uint64, relocationSymbol string) (plugin.ObjFile, error)</code></pre>
         </article>
         
         <article class="function" data-name="openMachOCommon">
            <h2>openMachOCommon</h2>
            <hr />
            
            <pre><code>func openMachOCommon(name string, of *macho.File, start uint64, limit uint64, offset uint64) (plugin.ObjFile, error)</code></pre>
         </article>
         
         <article class="function" data-name="openFatMachO">
            <h2>openFatMachO</h2>
            <hr />
            
            <pre><code>func openFatMachO(name string, start uint64, limit uint64, offset uint64) (plugin.ObjFile, error)</code></pre>
         </article>
         
         <article class="function" data-name="openMachO">
            <h2>openMachO</h2>
            <hr />
            
            <pre><code>func openMachO(name string, start uint64, limit uint64, offset uint64) (plugin.ObjFile, error)</code></pre>
         </article>
         
         <article class="function" data-name="openELF">
            <h2>openELF</h2>
            <hr />
            
            <pre><code>func openELF(name string, start uint64, limit uint64, offset uint64, relocationSymbol string) (plugin.ObjFile, error)</code></pre>
         </article>
         
         <article class="function" data-name="openPE">
            <h2>openPE</h2>
            <hr />
            
            <pre><code>func openPE(name string, start uint64, limit uint64, offset uint64) (plugin.ObjFile, error)</code></pre>
         </article>
         
         <article class="function" data-name="findProgramHeader">
            <h2>findProgramHeader</h2>
            <hr />
            
            <p>findProgramHeader returns the program segment that matches the current
mapping and the given address, or an error if it cannot find a unique program
header.</p>
            
            <pre><code>func findProgramHeader(ef *elf.File, addr uint64) (*elf.ProgHeader, error)</code></pre>
         </article>
         
         <article class="function" data-name="computeBase">
            <h2>computeBase</h2>
            <hr />
            
            <p>computeBase computes the relocation base for the given binary file only if
the elfMapping field is set. It populates the base and isData fields and
returns an error.</p>
            
            <pre><code>func computeBase(addr uint64) error</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="ObjAddr">
            <h2>ObjAddr</h2>
            <hr />
            
            <pre><code>func ObjAddr(addr uint64) (uint64, error)</code></pre>
         </article>
         
         <article class="function" data-name="BuildID">
            <h2>BuildID</h2>
            <hr />
            
            <pre><code>func BuildID() string</code></pre>
         </article>
         
         <article class="function" data-name="SourceLine">
            <h2>SourceLine</h2>
            <hr />
            
            <pre><code>func SourceLine(addr uint64) ([]plugin.Frame, error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="Symbols">
            <h2>Symbols</h2>
            <hr />
            
            <pre><code>func Symbols(r *regexp.Regexp, addr uint64) ([]*plugin.Sym, error)</code></pre>
         </article>
         
         <article class="function" data-name="SourceLine">
            <h2>SourceLine</h2>
            <hr />
            
            <pre><code>func SourceLine(addr uint64) ([]plugin.Frame, error)</code></pre>
         </article>
         
         <article class="function" data-name="SourceLine">
            <h2>SourceLine</h2>
            <hr />
            
            <pre><code>func SourceLine(addr uint64) ([]plugin.Frame, error)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="findSymbols">
            <h2>findSymbols</h2>
            <hr />
            
            <pre><code>func findSymbols(syms []byte, file string, r *regexp.Regexp, address uint64) ([]*plugin.Sym, error)</code></pre>
         </article>
         
         <article class="function" data-name="matchSymbol">
            <h2>matchSymbol</h2>
            <hr />
            
            <p>matchSymbol checks if a symbol is to be selected by checking its
name to the regexp and optionally its address. It returns the name(s)
to be used for the matched symbol, or nil if no match</p>
            
            <pre><code>func matchSymbol(names []string, start uint64, end uint64, r *regexp.Regexp, address uint64) []string</code></pre>
         </article>
         
         <article class="function" data-name="disassemble">
            <h2>disassemble</h2>
            <hr />
            
            <p>disassemble parses the output of the objdump command and returns
the assembly instructions in a slice.</p>
            
            <pre><code>func disassemble(asm []byte) ([]plugin.Inst, error)</code></pre>
         </article>
         
         <article class="function" data-name="nextSymbol">
            <h2>nextSymbol</h2>
            <hr />
            
            <p>nextSymbol parses the nm output to find the next symbol listed.
Skips over any output it cannot recognize.</p>
            
            <pre><code>func nextSymbol(buf *bytes.Buffer) (uint64, string, error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
