<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - internal</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="net_http_internal_ascii-docs.html">ascii</a>
         <br />
         
         <a href="net_http_internal_testcert-docs.html">testcert</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>internal</code>
         </h1>
         <hr />
         
         <article class="global" data-name="maxLineLength">
            <h2>maxLineLength</h2>
            <hr />
            
            <pre><code>maxLineLength</code></pre>
         </article>
         
         <article class="global" data-name="ErrLineTooLong">
            <h2>ErrLineTooLong</h2>
            <hr />
            
            <pre><code>ErrLineTooLong</code></pre>
         </article>
         
         <article class="global" data-name="semi">
            <h2>semi</h2>
            <hr />
            
            <pre><code>semi</code></pre>
         </article>
          
         <article class="struct" data-name="chunkedReader">
            <h2>type chunkedReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">r *bufio.Reader
n uint64
err error
buf []byte
checkEnd bool
excess int64</code></pre>
         </article>
         
         <article class="struct" data-name="chunkedWriter">
            <h2>type chunkedWriter struct</h2>
            <hr />
            
            <p>Writing to chunkedWriter translates to writing in HTTP chunked Transfer
Encoding wire format to the underlying Wire chunkedWriter.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Wire io.Writer</code></pre>
         </article>
         
         <article class="struct" data-name="FlushAfterChunkWriter">
            <h2>type FlushAfterChunkWriter struct</h2>
            <hr />
            
            <p>FlushAfterChunkWriter signals from the caller of [NewChunkedWriter]
that each chunk should be followed by a flush. It is used by the
[net/http.Transport] code to keep the buffering behavior for headers and
trailers, but flush out chunks aggressively in the middle for
request bodies which may be generated slowly. See Issue 6574.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*bufio.Writer</code></pre>
         </article>
         
         <article class="struct" data-name="funcReader">
            <h2>type funcReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">f func
i int
b []byte
err error</code></pre>
         </article>
          
         <article class="function" data-name="NewChunkedReader">
            <h2>NewChunkedReader</h2>
            <hr />
            
            <p>NewChunkedReader returns a new chunkedReader that translates the data read from r
out of HTTP "chunked" format before returning it.
The chunkedReader returns [io.EOF] when the final 0-length chunk is read.

NewChunkedReader is not needed by normal applications. The http package
automatically decodes chunking when reading response bodies.</p>
            
            <pre><code>func NewChunkedReader(r io.Reader) io.Reader</code></pre>
         </article>
         
         <article class="function" data-name="beginChunk">
            <h2>beginChunk</h2>
            <hr />
            
            <pre><code>func beginChunk()</code></pre>
         </article>
         
         <article class="function" data-name="chunkHeaderAvailable">
            <h2>chunkHeaderAvailable</h2>
            <hr />
            
            <pre><code>func chunkHeaderAvailable() bool</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(b []uint8) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readChunkLine">
            <h2>readChunkLine</h2>
            <hr />
            
            <p>Read a line of bytes (up to \n) from b.
Give up if the line exceeds maxLineLength.
The returned bytes are owned by the bufio.Reader
so they are only valid until the next bufio read.</p>
            
            <pre><code>func readChunkLine(b *bufio.Reader) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="trimTrailingWhitespace">
            <h2>trimTrailingWhitespace</h2>
            <hr />
            
            <pre><code>func trimTrailingWhitespace(b []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="isOWS">
            <h2>isOWS</h2>
            <hr />
            
            <pre><code>func isOWS(b byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="removeChunkExtension">
            <h2>removeChunkExtension</h2>
            <hr />
            
            <p>removeChunkExtension removes any chunk-extension from p.
For example,

	"0" => "0"
	"0;token" => "0"
	"0;token=val" => "0"
	`0;token="quoted string"` => "0"</p>
            
            <pre><code>func removeChunkExtension(p []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewChunkedWriter">
            <h2>NewChunkedWriter</h2>
            <hr />
            
            <p>NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP
"chunked" format before writing them to w. Closing the returned chunkedWriter
sends the final 0-length chunk that marks the end of the stream but does
not send the final CRLF that appears after trailers; trailers and the last
CRLF must be written separately.

NewChunkedWriter is not needed by normal applications. The http
package adds chunking automatically if handlers don't set a
Content-Length header. Using newChunkedWriter inside a handler
would result in double chunking or chunking with a Content-Length
length, both of which are wrong.</p>
            
            <pre><code>func NewChunkedWriter(w io.Writer) io.WriteCloser</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <p>Write the contents of data as one chunk to Wire.
NOTE: Note that the corresponding chunk-writing procedure in Conn.Write has
a bug since it does not check for success of [io.WriteString]</p>
            
            <pre><code>func Write(data []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="parseHexUint">
            <h2>parseHexUint</h2>
            <hr />
            
            <pre><code>func parseHexUint(v []byte) (n uint64, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestChunk">
            <h2>TestChunk</h2>
            <hr />
            
            <pre><code>func TestChunk(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestChunkReadMultiple">
            <h2>TestChunkReadMultiple</h2>
            <hr />
            
            <pre><code>func TestChunkReadMultiple(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestChunkReaderAllocs">
            <h2>TestChunkReaderAllocs</h2>
            <hr />
            
            <pre><code>func TestChunkReaderAllocs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseHexUint">
            <h2>TestParseHexUint</h2>
            <hr />
            
            <pre><code>func TestParseHexUint(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestChunkReadingIgnoresExtensions">
            <h2>TestChunkReadingIgnoresExtensions</h2>
            <hr />
            
            <pre><code>func TestChunkReadingIgnoresExtensions(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestChunkReadPartial">
            <h2>TestChunkReadPartial</h2>
            <hr />
            
            <p>Issue 17355: ChunkedReader shouldn't block waiting for more data
if it can return something.</p>
            
            <pre><code>func TestChunkReadPartial(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIncompleteChunk">
            <h2>TestIncompleteChunk</h2>
            <hr />
            
            <p>Issue 48861: ChunkedReader should report incomplete chunks</p>
            
            <pre><code>func TestIncompleteChunk(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestChunkEndReadError">
            <h2>TestChunkEndReadError</h2>
            <hr />
            
            <pre><code>func TestChunkEndReadError(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestChunkReaderTooMuchOverhead">
            <h2>TestChunkReaderTooMuchOverhead</h2>
            <hr />
            
            <pre><code>func TestChunkReaderTooMuchOverhead(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestChunkReaderByteAtATime">
            <h2>TestChunkReaderByteAtATime</h2>
            <hr />
            
            <pre><code>func TestChunkReaderByteAtATime(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestChunkInvalidInputs">
            <h2>TestChunkInvalidInputs</h2>
            <hr />
            
            <pre><code>func TestChunkInvalidInputs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(p []byte) (n int, err error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
