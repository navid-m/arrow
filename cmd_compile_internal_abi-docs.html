<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - abi</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>abi</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"cmd/compile/internal/base"
"cmd/compile/internal/ir"
"cmd/compile/internal/types"
"cmd/internal/obj"
"cmd/internal/src"
"fmt"
"math"
"sync"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="synthIface" data-name="synthIface">
               <h3>
                  synthIface 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#synthIface" class="anchor" title="Link to synthIface">#</a>
               </h3>
               
               <pre><code class="language-go">var synthIface *types.Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="synthOnce" data-name="synthOnce">
               <h3>
                  synthOnce 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#synthOnce" class="anchor" title="Link to synthOnce">#</a>
               </h3>
               
                  <p class="doc-comment">synthOnce ensures that we only create the synth* fake types once.</p>
               
               <pre><code class="language-go">var synthOnce sync.Once</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="synthSlice" data-name="synthSlice">
               <h3>
                  synthSlice 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#synthSlice" class="anchor" title="Link to synthSlice">#</a>
               </h3>
               
                  <p class="doc-comment">synthSlice, synthString, and syncIface are synthesized struct types
meant to capture the underlying implementations of string/slice/interface.</p>
               
               <pre><code class="language-go">var synthSlice *types.Type</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="synthString" data-name="synthString">
               <h3>
                  synthString 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#synthString" class="anchor" title="Link to synthString">#</a>
               </h3>
               
               <pre><code class="language-go">var synthString *types.Type</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="RegIndex" data-name="RegIndex">
               <h3>
                  RegIndex
                  <span class="badge type-badge">type</span>
                  <a href="#RegIndex" class="anchor" title="Link to RegIndex">#</a>
               </h3>
               
               <p>RegIndex stores the index into the set of machine registers used by
the ABI on a specific architecture for parameter passing.  RegIndex
values 0 through N-1 (where N is the number of integer registers
used for param passing according to the ABI rules) describe integer
registers; values N through M (where M is the number of floating
point registers used).  Thus if the ABI says there are 5 integer
registers and 7 floating point registers, then RegIndex value of 4
indicates the 5th integer register, and a RegIndex value of 11
indicates the 7th floating point register.</p>
               
               <pre><code class="language-go">type RegIndex uint8</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="ABIConfig" data-name="ABIConfig">
               <h3>
                  ABIConfig
                  <span class="badge">struct</span>
                  <a href="#ABIConfig" class="anchor" title="Link to ABIConfig">#</a>
               </h3>
               
               <p>ABIConfig captures the number of registers made available
by the ABI rules for parameter passing and result returning.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ABIConfig struct {
offsetForLocals int64
regAmounts RegAmounts
which obj.ABI
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ABIParamAssignment" data-name="ABIParamAssignment">
               <h3>
                  ABIParamAssignment
                  <span class="badge">struct</span>
                  <a href="#ABIParamAssignment" class="anchor" title="Link to ABIParamAssignment">#</a>
               </h3>
               
               <p>ABIParamAssignment holds information about how a specific param or
result will be passed: in registers (in which case 'Registers' is
populated) or on the stack (in which case 'Offset' is set to a
non-negative stack offset). The values in 'Registers' are indices
(as described above), not architected registers.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ABIParamAssignment struct {
Type *types.Type
Name *ir.Name
Registers []RegIndex
offset int32
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ABIParamResultInfo" data-name="ABIParamResultInfo">
               <h3>
                  ABIParamResultInfo
                  <span class="badge">struct</span>
                  <a href="#ABIParamResultInfo" class="anchor" title="Link to ABIParamResultInfo">#</a>
               </h3>
               
               <p>ABIParamResultInfo stores the results of processing a given
function type to compute stack layout and register assignments. For
each input and output parameter we capture whether the param was
register-assigned (and to which register(s)) or the stack offset
for the param if is not going to be passed in registers according
to the rules in the Go internal ABI specification (1.17).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ABIParamResultInfo struct {
inparams []ABIParamAssignment
outparams []ABIParamAssignment
offsetToSpillArea int64
spillAreaSize int64
inRegistersUsed int
outRegistersUsed int
config *ABIConfig
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="RegAmounts" data-name="RegAmounts">
               <h3>
                  RegAmounts
                  <span class="badge">struct</span>
                  <a href="#RegAmounts" class="anchor" title="Link to RegAmounts">#</a>
               </h3>
               
               <p>RegAmounts holds a specified number of integer/float registers.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type RegAmounts struct {
intRegs int
floatRegs int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="assignState" data-name="assignState">
               <h3>
                  assignState
                  <span class="badge">struct</span>
                  <a href="#assignState" class="anchor" title="Link to assignState">#</a>
               </h3>
               
               <p>assignState holds intermediate state during the register assigning process
for a given function signature.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type assignState struct {
rTotal RegAmounts
rUsed RegAmounts
stackOffset int64
spillOffset int64
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="ABIAnalyze" data-name="ABIAnalyze">
               <h3>
                  ABIAnalyze 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ABIAnalyze" class="anchor" title="Link to ABIAnalyze">#</a>
               </h3>
               
               <p>ABIAnalyze returns the same result as ABIAnalyzeFuncType, but also
updates the offsets of all the receiver, input, and output fields.
If setNname is true, it also sets the FrameOffset of the Nname for
the field(s); this is for use when compiling a function and figuring out
spill locations.  Doing this for callers can cause races for register
outputs because their frame location transitions from BOGUS_FUNARG_OFFSET
to zero to an as-if-AUTO offset that has no use for callers.</p>
               
               <pre><code class="language-go">func (config *ABIConfig) ABIAnalyze(t *types.Type, setNname bool) *ABIParamResultInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ABIAnalyzeFuncType" data-name="ABIAnalyzeFuncType">
               <h3>
                  ABIAnalyzeFuncType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ABIAnalyzeFuncType" class="anchor" title="Link to ABIAnalyzeFuncType">#</a>
               </h3>
               
               <p>ABIAnalyzeFuncType takes a function type 'ft' and an ABI rules description
'config' and analyzes the function to determine how its parameters
and results will be passed (in registers or on the stack), returning
an ABIParamResultInfo object that holds the results of the analysis.</p>
               
               <pre><code class="language-go">func (config *ABIConfig) ABIAnalyzeFuncType(ft *types.Type) *ABIParamResultInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ABIAnalyzeTypes" data-name="ABIAnalyzeTypes">
               <h3>
                  ABIAnalyzeTypes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ABIAnalyzeTypes" class="anchor" title="Link to ABIAnalyzeTypes">#</a>
               </h3>
               
               <p>ABIAnalyzeTypes takes slices of parameter and result types, and returns an ABIParamResultInfo,
based on the given configuration.  This is the same result computed by config.ABIAnalyze applied to the
corresponding method/function type, except that all the embedded parameter names are nil.
This is intended for use by ssagen/ssa.go:(*state).rtcall, for runtime functions that lack a parsed function type.</p>
               
               <pre><code class="language-go">func (config *ABIConfig) ABIAnalyzeTypes(params []*types.Type, results []*types.Type) *ABIParamResultInfo</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ArgWidth" data-name="ArgWidth">
               <h3>
                  ArgWidth 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ArgWidth" class="anchor" title="Link to ArgWidth">#</a>
               </h3>
               
               <p>ArgWidth returns the amount of stack needed for all the inputs
and outputs of a function or method, including ABI-defined parameter
slots and ABI-defined spill slots for register-resident parameters.
The name is inherited from (*Type).ArgWidth(), which it replaces.</p>
               
               <pre><code class="language-go">func (a *ABIParamResultInfo) ArgWidth() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ComputePadding" data-name="ComputePadding">
               <h3>
                  ComputePadding 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ComputePadding" class="anchor" title="Link to ComputePadding">#</a>
               </h3>
               
               <p>ComputePadding returns a list of "post element" padding values in
the case where we have a structure being passed in registers. Given
a param assignment corresponding to a struct, it returns a list
containing padding values for each field, e.g. the Kth element in
the list is the amount of padding between field K and the following
field. For things that are not structs (or structs without padding)
it returns a list of zeros. Example:
type small struct {
x uint16
y uint8
z int32
w int32
}
For this struct we would return a list [0, 1, 0, 0], meaning that
we have one byte of padding after the second field, and no bytes of
padding after any of the other fields. Input parameter "storage" is
a slice with enough capacity to accommodate padding elements for
the architected register set in question.</p>
               
               <pre><code class="language-go">func (pa *ABIParamAssignment) ComputePadding(storage []uint64) []uint64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Config" data-name="Config">
               <h3>
                  Config 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Config" class="anchor" title="Link to Config">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *ABIParamResultInfo) Config() *ABIConfig</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Copy" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Copy" class="anchor" title="Link to Copy">#</a>
               </h3>
               
               <p>Copy returns config.
TODO(mdempsky): Remove.</p>
               
               <pre><code class="language-go">func (config *ABIConfig) Copy() *ABIConfig</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FloatIndexFor" data-name="FloatIndexFor">
               <h3>
                  FloatIndexFor 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FloatIndexFor" class="anchor" title="Link to FloatIndexFor">#</a>
               </h3>
               
               <p>FloatIndexFor translates r into an index in the floating point parameter
registers.  If the result is negative, the input index was actually for the
integer parameter registers.</p>
               
               <pre><code class="language-go">func (config *ABIConfig) FloatIndexFor(r RegIndex) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="FrameOffset" data-name="FrameOffset">
               <h3>
                  FrameOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#FrameOffset" class="anchor" title="Link to FrameOffset">#</a>
               </h3>
               
               <p>FrameOffset returns the frame-pointer-relative location that a function
would spill its input or output parameter to, if such a spill slot exists.
If there is none defined (e.g., register-allocated outputs) it panics.
For register-allocated inputs that is their spill offset reserved for morestack;
for stack-allocated inputs and outputs, that is their location on the stack.
(In a future version of the ABI, register-resident inputs may lose their defined
spill area to help reduce stack sizes.)</p>
               
               <pre><code class="language-go">func (a *ABIParamAssignment) FrameOffset(i *ABIParamResultInfo) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InParam" data-name="InParam">
               <h3>
                  InParam 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InParam" class="anchor" title="Link to InParam">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *ABIParamResultInfo) InParam(i int) *ABIParamAssignment</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InParams" data-name="InParams">
               <h3>
                  InParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InParams" class="anchor" title="Link to InParams">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *ABIParamResultInfo) InParams() []ABIParamAssignment</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InRegistersUsed" data-name="InRegistersUsed">
               <h3>
                  InRegistersUsed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InRegistersUsed" class="anchor" title="Link to InRegistersUsed">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *ABIParamResultInfo) InRegistersUsed() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="LocalsOffset" data-name="LocalsOffset">
               <h3>
                  LocalsOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#LocalsOffset" class="anchor" title="Link to LocalsOffset">#</a>
               </h3>
               
               <p>LocalsOffset returns the architecture-dependent offset from SP for args and results.
In theory this is only used for debugging; it ought to already be incorporated into
results from the ABI-related methods</p>
               
               <pre><code class="language-go">func (config *ABIConfig) LocalsOffset() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewABIConfig" data-name="NewABIConfig">
               <h3>
                  NewABIConfig 
                  <span class="badge">function</span>
                  
                  <a href="#NewABIConfig" class="anchor" title="Link to NewABIConfig">#</a>
               </h3>
               
               <p>NewABIConfig returns a new ABI configuration for an architecture with
iRegsCount integer/pointer registers and fRegsCount floating point registers.</p>
               
               <pre><code class="language-go">func NewABIConfig(iRegsCount int, fRegsCount int, offsetForLocals int64, which uint8) *ABIConfig</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NumParamRegs" data-name="NumParamRegs">
               <h3>
                  NumParamRegs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NumParamRegs" class="anchor" title="Link to NumParamRegs">#</a>
               </h3>
               
               <p>NumParamRegs returns the total number of registers used to
represent a parameter of the given type, which must be register
assignable.</p>
               
               <pre><code class="language-go">func (config *ABIConfig) NumParamRegs(typ *types.Type) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Offset" data-name="Offset">
               <h3>
                  Offset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Offset" class="anchor" title="Link to Offset">#</a>
               </h3>
               
               <p>Offset returns the stack offset for addressing the parameter that "a" describes.
This will panic if "a" describes a register-allocated parameter.</p>
               
               <pre><code class="language-go">func (a *ABIParamAssignment) Offset() int32</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OutParam" data-name="OutParam">
               <h3>
                  OutParam 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OutParam" class="anchor" title="Link to OutParam">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *ABIParamResultInfo) OutParam(i int) *ABIParamAssignment</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OutParams" data-name="OutParams">
               <h3>
                  OutParams 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OutParams" class="anchor" title="Link to OutParams">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *ABIParamResultInfo) OutParams() []ABIParamAssignment</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="OutRegistersUsed" data-name="OutRegistersUsed">
               <h3>
                  OutRegistersUsed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#OutRegistersUsed" class="anchor" title="Link to OutRegistersUsed">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *ABIParamResultInfo) OutRegistersUsed() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterTypes" data-name="RegisterTypes">
               <h3>
                  RegisterTypes 
                  <span class="badge">function</span>
                  
                  <a href="#RegisterTypes" class="anchor" title="Link to RegisterTypes">#</a>
               </h3>
               
               <p>RegisterTypes returns a slice of the types of the registers
corresponding to a slice of parameters.  The returned slice
has capacity for one more, likely a memory type.</p>
               
               <pre><code class="language-go">func RegisterTypes(apa []ABIParamAssignment) []*types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="RegisterTypesAndOffsets" data-name="RegisterTypesAndOffsets">
               <h3>
                  RegisterTypesAndOffsets 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#RegisterTypesAndOffsets" class="anchor" title="Link to RegisterTypesAndOffsets">#</a>
               </h3>
               
               <pre><code class="language-go">func (pa *ABIParamAssignment) RegisterTypesAndOffsets() ([]*types.Type, []int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SpillAreaOffset" data-name="SpillAreaOffset">
               <h3>
                  SpillAreaOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SpillAreaOffset" class="anchor" title="Link to SpillAreaOffset">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *ABIParamResultInfo) SpillAreaOffset() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SpillAreaSize" data-name="SpillAreaSize">
               <h3>
                  SpillAreaSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SpillAreaSize" class="anchor" title="Link to SpillAreaSize">#</a>
               </h3>
               
               <pre><code class="language-go">func (a *ABIParamResultInfo) SpillAreaSize() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String method renders an ABIParamResultInfo in human-readable
form, suitable for debugging or unit testing.</p>
               
               <pre><code class="language-go">func (ri *ABIParamResultInfo) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ToString" data-name="ToString">
               <h3>
                  ToString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ToString" class="anchor" title="Link to ToString">#</a>
               </h3>
               
               <p>ToString method renders an ABIParamAssignment in human-readable
form, suitable for debugging or unit testing.</p>
               
               <pre><code class="language-go">func (ri *ABIParamAssignment) ToString(config *ABIConfig, extra bool) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Which" data-name="Which">
               <h3>
                  Which 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Which" class="anchor" title="Link to Which">#</a>
               </h3>
               
               <p>Which returns the ABI number</p>
               
               <pre><code class="language-go">func (config *ABIConfig) Which() obj.ABI</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="align" data-name="align">
               <h3>
                  align 
                  <span class="badge">function</span>
                  
                  <a href="#align" class="anchor" title="Link to align">#</a>
               </h3>
               
               <p>align returns a rounded up to t's alignment.</p>
               
               <pre><code class="language-go">func align(a int64, t *types.Type) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="alignTo" data-name="alignTo">
               <h3>
                  alignTo 
                  <span class="badge">function</span>
                  
                  <a href="#alignTo" class="anchor" title="Link to alignTo">#</a>
               </h3>
               
               <p>alignTo returns a rounded up to t, where t must be 0 or a power of 2.</p>
               
               <pre><code class="language-go">func alignTo(a int64, t int) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="allocateRegs" data-name="allocateRegs">
               <h3>
                  allocateRegs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#allocateRegs" class="anchor" title="Link to allocateRegs">#</a>
               </h3>
               
               <p>allocateRegs returns an ordered list of register indices for a parameter or result
that we've just determined to be register-assignable. The number of registers
needed is assumed to be stored in state.pUsed.</p>
               
               <pre><code class="language-go">func (state *assignState) allocateRegs(regs []RegIndex, t *types.Type) []RegIndex</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendParamOffsets" data-name="appendParamOffsets">
               <h3>
                  appendParamOffsets 
                  <span class="badge">function</span>
                  
                  <a href="#appendParamOffsets" class="anchor" title="Link to appendParamOffsets">#</a>
               </h3>
               
               <p>appendParamOffsets appends the offset(s) of type t, starting from "at",
to input offsets, and returns the longer slice and the next unused offset.
at should already be aligned for t.</p>
               
               <pre><code class="language-go">func appendParamOffsets(offsets []int64, at int64, t *types.Type) ([]int64, int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="appendParamTypes" data-name="appendParamTypes">
               <h3>
                  appendParamTypes 
                  <span class="badge">function</span>
                  
                  <a href="#appendParamTypes" class="anchor" title="Link to appendParamTypes">#</a>
               </h3>
               
               <pre><code class="language-go">func appendParamTypes(rts []*types.Type, t *types.Type) []*types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="assignParam" data-name="assignParam">
               <h3>
                  assignParam 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#assignParam" class="anchor" title="Link to assignParam">#</a>
               </h3>
               
               <p>assignParam processes a given receiver, param, or result
of field f to determine whether it can be register assigned.
The result of the analysis is recorded in the result
ABIParamResultInfo held in 'state'.</p>
               
               <pre><code class="language-go">func (state *assignState) assignParam(typ *types.Type, name *ir.Name, isResult bool) ABIParamAssignment</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextSlot" data-name="nextSlot">
               <h3>
                  nextSlot 
                  <span class="badge">function</span>
                  
                  <a href="#nextSlot" class="anchor" title="Link to nextSlot">#</a>
               </h3>
               
               <p>nextSlot allocates the next available slot for typ.</p>
               
               <pre><code class="language-go">func nextSlot(offsetp *int64, typ *types.Type) int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="regString" data-name="regString">
               <h3>
                  regString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#regString" class="anchor" title="Link to regString">#</a>
               </h3>
               
               <p>regString produces a human-readable version of a RegIndex.</p>
               
               <pre><code class="language-go">func (c *RegAmounts) regString(r RegIndex) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setup" data-name="setup">
               <h3>
                  setup 
                  <span class="badge">function</span>
                  
                  <a href="#setup" class="anchor" title="Link to setup">#</a>
               </h3>
               
               <p>setup performs setup for the register assignment utilities, manufacturing
a small set of synthesized types that we'll need along the way.</p>
               
               <pre><code class="language-go">func setup()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tryAllocRegs" data-name="tryAllocRegs">
               <h3>
                  tryAllocRegs 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tryAllocRegs" class="anchor" title="Link to tryAllocRegs">#</a>
               </h3>
               
               <p>tryAllocRegs attempts to allocate registers to represent a
parameter of the given type. If unsuccessful, it returns nil.</p>
               
               <pre><code class="language-go">func (state *assignState) tryAllocRegs(typ *types.Type) []RegIndex</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="updateOffset" data-name="updateOffset">
               <h3>
                  updateOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#updateOffset" class="anchor" title="Link to updateOffset">#</a>
               </h3>
               
               <pre><code class="language-go">func (config *ABIConfig) updateOffset(result *ABIParamResultInfo, f *types.Field, a ABIParamAssignment, isResult bool, setNname bool)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

   
               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>