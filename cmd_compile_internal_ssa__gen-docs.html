<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - main</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>main</code>
         </h1>
         <hr />
         
         <article class="global" data-name="regNamesS390X">
            <h2>regNamesS390X</h2>
            <hr />
            
            <p>copied from ../../s390x/reg.go</p>
            
            <pre><code>regNamesS390X</code></pre>
         </article>
         
         <article class="global" data-name="dec64Ops">
            <h2>dec64Ops</h2>
            <hr />
            
            <pre><code>dec64Ops</code></pre>
         </article>
         
         <article class="global" data-name="dec64Blocks">
            <h2>dec64Blocks</h2>
            <hr />
            
            <pre><code>dec64Blocks</code></pre>
         </article>
         
         <article class="global" data-name="genericOps">
            <h2>genericOps</h2>
            <hr />
            
            <pre><code>genericOps</code></pre>
         </article>
         
         <article class="global" data-name="genericBlocks">
            <h2>genericBlocks</h2>
            <hr />
            
            <pre><code>genericBlocks</code></pre>
         </article>
         
         <article class="global" data-name="archs">
            <h2>archs</h2>
            <hr />
            
            <pre><code>archs []arch</code></pre>
         </article>
         
         <article class="global" data-name="cpuprofile">
            <h2>cpuprofile</h2>
            <hr />
            
            <pre><code>cpuprofile</code></pre>
         </article>
         
         <article class="global" data-name="memprofile">
            <h2>memprofile</h2>
            <hr />
            
            <pre><code>memprofile</code></pre>
         </article>
         
         <article class="global" data-name="tracefile">
            <h2>tracefile</h2>
            <hr />
            
            <pre><code>tracefile</code></pre>
         </article>
         
         <article class="global" data-name="regNamesAMD64">
            <h2>regNamesAMD64</h2>
            <hr />
            
            <p>copied from ../../amd64/reg.go</p>
            
            <pre><code>regNamesAMD64</code></pre>
         </article>
         
         <article class="global" data-name="regNamesARM64">
            <h2>regNamesARM64</h2>
            <hr />
            
            <p>Note: registers not used in regalloc are not included in this list,
so that regmask stays within int64
Be careful when hand coding regmasks.</p>
            
            <pre><code>regNamesARM64</code></pre>
         </article>
         
         <article class="global" data-name="regNamesMIPS64">
            <h2>regNamesMIPS64</h2>
            <hr />
            
            <p>Note: registers not used in regalloc are not included in this list,
so that regmask stays within int64
Be careful when hand coding regmasks.</p>
            
            <pre><code>regNamesMIPS64</code></pre>
         </article>
         
         <article class="global" data-name="regNamesPPC64">
            <h2>regNamesPPC64</h2>
            <hr />
            
            <pre><code>regNamesPPC64</code></pre>
         </article>
         
         <article class="global" data-name="riscv64REG_G">
            <h2>riscv64REG_G</h2>
            <hr />
            
            <pre><code>riscv64REG_G</code></pre>
         </article>
         
         <article class="global" data-name="riscv64REG_CTXT">
            <h2>riscv64REG_CTXT</h2>
            <hr />
            
            <pre><code>riscv64REG_CTXT</code></pre>
         </article>
         
         <article class="global" data-name="riscv64REG_LR">
            <h2>riscv64REG_LR</h2>
            <hr />
            
            <pre><code>riscv64REG_LR</code></pre>
         </article>
         
         <article class="global" data-name="riscv64REG_SP">
            <h2>riscv64REG_SP</h2>
            <hr />
            
            <pre><code>riscv64REG_SP</code></pre>
         </article>
         
         <article class="global" data-name="riscv64REG_GP">
            <h2>riscv64REG_GP</h2>
            <hr />
            
            <pre><code>riscv64REG_GP</code></pre>
         </article>
         
         <article class="global" data-name="riscv64REG_TP">
            <h2>riscv64REG_TP</h2>
            <hr />
            
            <pre><code>riscv64REG_TP</code></pre>
         </article>
         
         <article class="global" data-name="riscv64REG_TMP">
            <h2>riscv64REG_TMP</h2>
            <hr />
            
            <pre><code>riscv64REG_TMP</code></pre>
         </article>
         
         <article class="global" data-name="riscv64REG_ZERO">
            <h2>riscv64REG_ZERO</h2>
            <hr />
            
            <pre><code>riscv64REG_ZERO</code></pre>
         </article>
         
         <article class="global" data-name="decOps">
            <h2>decOps</h2>
            <hr />
            
            <pre><code>decOps</code></pre>
         </article>
         
         <article class="global" data-name="decBlocks">
            <h2>decBlocks</h2>
            <hr />
            
            <pre><code>decBlocks</code></pre>
         </article>
         
         <article class="global" data-name="genLog">
            <h2>genLog</h2>
            <hr />
            
            <pre><code>genLog</code></pre>
         </article>
         
         <article class="global" data-name="addLine">
            <h2>addLine</h2>
            <hr />
            
            <pre><code>addLine</code></pre>
         </article>
         
         <article class="global" data-name="printConfig">
            <h2>printConfig</h2>
            <hr />
            
            <pre><code>printConfig</code></pre>
         </article>
         
         <article class="global" data-name="emptyFset">
            <h2>emptyFset</h2>
            <hr />
            
            <pre><code>emptyFset</code></pre>
         </article>
         
         <article class="global" data-name="predeclared">
            <h2>predeclared</h2>
            <hr />
            
            <p>predeclared contains globally known tokens that should not be redefined.</p>
            
            <pre><code>predeclared</code></pre>
         </article>
         
         <article class="global" data-name="reservedNames">
            <h2>reservedNames</h2>
            <hr />
            
            <pre><code>reservedNames</code></pre>
         </article>
         
         <article class="global" data-name="findAllOpcode">
            <h2>findAllOpcode</h2>
            <hr />
            
            <p>findAllOpcode is a function to find the opcode portion of s-expressions.</p>
            
            <pre><code>findAllOpcode</code></pre>
         </article>
         
         <article class="global" data-name="regNamesARM">
            <h2>regNamesARM</h2>
            <hr />
            
            <pre><code>regNamesARM</code></pre>
         </article>
         
         <article class="global" data-name="regNamesMIPS">
            <h2>regNamesMIPS</h2>
            <hr />
            
            <p>Note: registers not used in regalloc are not included in this list,
so that regmask stays within int64
Be careful when hand coding regmasks.</p>
            
            <pre><code>regNamesMIPS</code></pre>
         </article>
         
         <article class="global" data-name="regNamesWasm">
            <h2>regNamesWasm</h2>
            <hr />
            
            <pre><code>regNamesWasm</code></pre>
         </article>
         
         <article class="global" data-name="regNames386">
            <h2>regNames386</h2>
            <hr />
            
            <p>copied from ../../x86/reg.go</p>
            
            <pre><code>regNames386</code></pre>
         </article>
         
         <article class="global" data-name="regNamesLOONG64">
            <h2>regNamesLOONG64</h2>
            <hr />
            
            <p>Note: registers not used in regalloc are not included in this list,
so that regmask stays within int64
Be careful when hand coding regmasks.</p>
            
            <pre><code>regNamesLOONG64</code></pre>
         </article>
          
         <article class="struct" data-name="arch">
            <h2>type arch struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
pkg string
genfile string
ops []opData
blocks []blockData
regnames []string
ParamIntRegNames string
ParamFloatRegNames string
gpregmask regMask
fpregmask regMask
fp32regmask regMask
fp64regmask regMask
specialregmask regMask
framepointerreg int8
linkreg int8
generic bool
imports []string</code></pre>
         </article>
         
         <article class="struct" data-name="opData">
            <h2>type opData struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
reg regInfo
asm string
typ string
aux string
rematerializeable bool
argLength int32
commutative bool
resultInArg0 bool
resultNotInArgs bool
clobberFlags bool
needIntTemp bool
call bool
tailCall bool
nilCheck bool
faultOnNilArg0 bool
faultOnNilArg1 bool
hasSideEffects bool
zeroWidth bool
unsafePoint bool
symEffect string
scale uint8</code></pre>
         </article>
         
         <article class="struct" data-name="blockData">
            <h2>type blockData struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
controls int
aux string</code></pre>
         </article>
         
         <article class="struct" data-name="regInfo">
            <h2>type regInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">inputs []regMask
clobbers regMask
outputs []regMask</code></pre>
         </article>
         
         <article class="struct" data-name="intPair">
            <h2>type intPair struct</h2>
            <hr />
            
            <p>for sorting a pair of integers by key</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">key int
val int</code></pre>
         </article>
         
         <article class="struct" data-name="Rule">
            <h2>type Rule struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Rule string
Loc string</code></pre>
         </article>
         
         <article class="struct" data-name="unusedInspector">
            <h2>type unusedInspector struct</h2>
            <hr />
            
            <p>unusedInspector can be used to detect unused variables and imports in an
ast.Node via its node method. The result is available in the "unused" map.

note that unusedInspector is lazy and best-effort; it only supports the node
types and patterns used by the rulegen program.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">scope *scope
unused *ast.MapType
defining *object</code></pre>
         </article>
         
         <article class="struct" data-name="scope">
            <h2>type scope struct</h2>
            <hr />
            
            <p>scope keeps track of a certain scope and its declared names, as well as the
outer (parent) scope.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">outer *scope
objects *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="object">
            <h2>type object struct</h2>
            <hr />
            
            <p>object keeps track of a declared name, such as a variable or import.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
pos token.Pos
numUses int
used []*object</code></pre>
         </article>
         
         <article class="struct" data-name="BodyBase">
            <h2>type BodyBase struct</h2>
            <hr />
            
            <p>BodyBase is shared by all of our statement pseudo-node types which can
contain other statements.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">List []Statement
CanFail bool</code></pre>
         </article>
         
         <article class="struct" data-name="File">
            <h2>type File struct</h2>
            <hr />
            
            <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.

Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">BodyBase
Arch arch
Suffix string</code></pre>
         </article>
         
         <article class="struct" data-name="Func">
            <h2>type Func struct</h2>
            <hr />
            
            <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.

Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">BodyBase
Kind string
Suffix string
ArgLen int32</code></pre>
         </article>
         
         <article class="struct" data-name="Switch">
            <h2>type Switch struct</h2>
            <hr />
            
            <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.

Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">BodyBase
Expr ast.Expr</code></pre>
         </article>
         
         <article class="struct" data-name="Case">
            <h2>type Case struct</h2>
            <hr />
            
            <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.

Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">BodyBase
Expr ast.Expr</code></pre>
         </article>
         
         <article class="struct" data-name="RuleRewrite">
            <h2>type RuleRewrite struct</h2>
            <hr />
            
            <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.

Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">BodyBase
Match string
Cond string
Result string
Check string
Alloc int
Loc string
CommuteDepth int</code></pre>
         </article>
         
         <article class="struct" data-name="Declare">
            <h2>type Declare struct</h2>
            <hr />
            
            <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.

Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name string
Value ast.Expr</code></pre>
         </article>
         
         <article class="struct" data-name="CondBreak">
            <h2>type CondBreak struct</h2>
            <hr />
            
            <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.

Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Cond ast.Expr
InsideCommuteLoop bool</code></pre>
         </article>
         
         <article class="struct" data-name="StartCommuteLoop">
            <h2>type StartCommuteLoop struct</h2>
            <hr />
            
            <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.

Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Depth int
V string</code></pre>
         </article>
         
         <article class="struct" data-name="allocator">
            <h2>type allocator struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
typ string
mak string
capacity string
resize string
clear string
minLog int
maxLog int</code></pre>
         </article>
         
         <article class="struct" data-name="derived">
            <h2>type derived struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
typ string
base string</code></pre>
         </article>
          
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="regMaskComment">
            <h2>regMaskComment</h2>
            <hr />
            
            <pre><code>func regMaskComment(r regMask) string</code></pre>
         </article>
         
         <article class="function" data-name="main">
            <h2>main</h2>
            <hr />
            
            <pre><code>func main()</code></pre>
         </article>
         
         <article class="function" data-name="genOp">
            <h2>genOp</h2>
            <hr />
            
            <pre><code>func genOp()</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <p>Name returns the name of the architecture for use in Op* and Block* enumerations.</p>
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="countRegs">
            <h2>countRegs</h2>
            <hr />
            
            <p>countRegs returns the number of set bits in the register mask.</p>
            
            <pre><code>func countRegs(r regMask) int</code></pre>
         </article>
         
         <article class="function" data-name="Len">
            <h2>Len</h2>
            <hr />
            
            <pre><code>func Len() int</code></pre>
         </article>
         
         <article class="function" data-name="Swap">
            <h2>Swap</h2>
            <hr />
            
            <pre><code>func Swap(i int, j int)</code></pre>
         </article>
         
         <article class="function" data-name="Less">
            <h2>Less</h2>
            <hr />
            
            <pre><code>func Less(i int, j int) bool</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="riscv64RegName">
            <h2>riscv64RegName</h2>
            <hr />
            
            <pre><code>func riscv64RegName(r int) string</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="normalizeSpaces">
            <h2>normalizeSpaces</h2>
            <hr />
            
            <pre><code>func normalizeSpaces(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="parse">
            <h2>parse</h2>
            <hr />
            
            <p>parse returns the matching part of the rule, additional conditions, and the result.</p>
            
            <pre><code>func parse() (match string, cond string, result string)</code></pre>
         </article>
         
         <article class="function" data-name="genRules">
            <h2>genRules</h2>
            <hr />
            
            <pre><code>func genRules(arch arch)</code></pre>
         </article>
         
         <article class="function" data-name="genSplitLoadRules">
            <h2>genSplitLoadRules</h2>
            <hr />
            
            <pre><code>func genSplitLoadRules(arch arch)</code></pre>
         </article>
         
         <article class="function" data-name="genLateLowerRules">
            <h2>genLateLowerRules</h2>
            <hr />
            
            <pre><code>func genLateLowerRules(arch arch)</code></pre>
         </article>
         
         <article class="function" data-name="genRulesSuffix">
            <h2>genRulesSuffix</h2>
            <hr />
            
            <pre><code>func genRulesSuffix(arch arch, suff string)</code></pre>
         </article>
         
         <article class="function" data-name="scoped">
            <h2>scoped</h2>
            <hr />
            
            <p>scoped opens a new scope when called, and returns a function which closes
that same scope. When a scope is closed, unused variables are recorded.</p>
            
            <pre><code>func scoped() func</code></pre>
         </article>
         
         <article class="function" data-name="exprs">
            <h2>exprs</h2>
            <hr />
            
            <pre><code>func exprs(list []ast.Expr)</code></pre>
         </article>
         
         <article class="function" data-name="node">
            <h2>node</h2>
            <hr />
            
            <pre><code>func node(node ast.Node)</code></pre>
         </article>
         
         <article class="function" data-name="Lookup">
            <h2>Lookup</h2>
            <hr />
            
            <pre><code>func Lookup(name string) *object</code></pre>
         </article>
         
         <article class="function" data-name="fprint">
            <h2>fprint</h2>
            <hr />
            
            <pre><code>func fprint(w io.Writer, n Node)</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <pre><code>func add(node Statement)</code></pre>
         </article>
         
         <article class="function" data-name="declared">
            <h2>declared</h2>
            <hr />
            
            <p>declared reports if the body contains a Declare with the given name.</p>
            
            <pre><code>func declared(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="exprf">
            <h2>exprf</h2>
            <hr />
            
            <p>exprf parses a Go expression generated from fmt.Sprintf, panicking if an
error occurs.</p>
            
            <pre><code>func exprf(format string, a ...*ast.InterfaceType) ast.Expr</code></pre>
         </article>
         
         <article class="function" data-name="stmtf">
            <h2>stmtf</h2>
            <hr />
            
            <p>stmtf parses a Go statement generated from fmt.Sprintf. This function is only
meant for simple statements that don't have a custom Statement node declared
in this package, such as ast.ReturnStmt or ast.ExprStmt.</p>
            
            <pre><code>func stmtf(format string, a ...*ast.InterfaceType) Statement</code></pre>
         </article>
         
         <article class="function" data-name="declf">
            <h2>declf</h2>
            <hr />
            
            <p>declf constructs a simple "name := value" declaration,
using exprf for its value.

name must not be one of reservedNames.
This helps prevent unintended shadowing and name clashes.
To declare a reserved name, use declReserved.</p>
            
            <pre><code>func declf(loc string, name string, format string, a ...*ast.InterfaceType) *Declare</code></pre>
         </article>
         
         <article class="function" data-name="declReserved">
            <h2>declReserved</h2>
            <hr />
            
            <p>declReserved is like declf, but the name must be one of reservedNames.
Calls to declReserved should generally be static and top-level.</p>
            
            <pre><code>func declReserved(name string, value string) *Declare</code></pre>
         </article>
         
         <article class="function" data-name="breakf">
            <h2>breakf</h2>
            <hr />
            
            <p>breakf constructs a simple "if cond { break }" statement, using exprf for its
condition.</p>
            
            <pre><code>func breakf(format string, a ...*ast.InterfaceType) *CondBreak</code></pre>
         </article>
         
         <article class="function" data-name="genBlockRewrite">
            <h2>genBlockRewrite</h2>
            <hr />
            
            <pre><code>func genBlockRewrite(rule Rule, arch arch, data blockData) *RuleRewrite</code></pre>
         </article>
         
         <article class="function" data-name="genMatch">
            <h2>genMatch</h2>
            <hr />
            
            <p>genMatch returns the variable whose source position should be used for the
result (or "" if no opinion), and a boolean that reports whether the match can fail.</p>
            
            <pre><code>func genMatch(rr *RuleRewrite, arch arch, match string, pregenTop bool) (pos string, checkOp string)</code></pre>
         </article>
         
         <article class="function" data-name="genMatch0">
            <h2>genMatch0</h2>
            <hr />
            
            <pre><code>func genMatch0(rr *RuleRewrite, arch arch, match string, v string, cnt *ast.MapType, pregenTop bool) (pos string, checkOp string)</code></pre>
         </article>
         
         <article class="function" data-name="genResult">
            <h2>genResult</h2>
            <hr />
            
            <pre><code>func genResult(rr *RuleRewrite, arch arch, result string, pos string)</code></pre>
         </article>
         
         <article class="function" data-name="genResult0">
            <h2>genResult0</h2>
            <hr />
            
            <pre><code>func genResult0(rr *RuleRewrite, arch arch, result string, top bool, move bool, pos string, cse *ast.MapType) string</code></pre>
         </article>
         
         <article class="function" data-name="split">
            <h2>split</h2>
            <hr />
            
            <pre><code>func split(s string) []string</code></pre>
         </article>
         
         <article class="function" data-name="isBlock">
            <h2>isBlock</h2>
            <hr />
            
            <p>isBlock reports whether this op is a block opcode.</p>
            
            <pre><code>func isBlock(name string, arch arch) bool</code></pre>
         </article>
         
         <article class="function" data-name="extract">
            <h2>extract</h2>
            <hr />
            
            <pre><code>func extract(val string) (op string, typ string, auxint string, aux string, args []string)</code></pre>
         </article>
         
         <article class="function" data-name="parseValue">
            <h2>parseValue</h2>
            <hr />
            
            <p>parseValue parses a parenthesized value from a rule.
The value can be from the match or the result side.
It returns the op and unparsed strings for typ, auxint, and aux restrictions and for all args.
oparch is the architecture that op is located in, or "" for generic.</p>
            
            <pre><code>func parseValue(val string, arch arch, loc string) (op opData, oparch string, typ string, auxint string, aux string, args []string)</code></pre>
         </article>
         
         <article class="function" data-name="opHasAuxInt">
            <h2>opHasAuxInt</h2>
            <hr />
            
            <pre><code>func opHasAuxInt(op opData) bool</code></pre>
         </article>
         
         <article class="function" data-name="opHasAux">
            <h2>opHasAux</h2>
            <hr />
            
            <pre><code>func opHasAux(op opData) bool</code></pre>
         </article>
         
         <article class="function" data-name="splitNameExpr">
            <h2>splitNameExpr</h2>
            <hr />
            
            <p>splitNameExpr splits s-expr arg, possibly prefixed by "name:",
into name and the unprefixed expression.
For example, "x:(Foo)" yields "x", "(Foo)",
and "(Foo)" yields "", "(Foo)".</p>
            
            <pre><code>func splitNameExpr(arg string) (name string, expr string)</code></pre>
         </article>
         
         <article class="function" data-name="getBlockInfo">
            <h2>getBlockInfo</h2>
            <hr />
            
            <pre><code>func getBlockInfo(op string, arch arch) (name string, data blockData)</code></pre>
         </article>
         
         <article class="function" data-name="typeName">
            <h2>typeName</h2>
            <hr />
            
            <p>typeName returns the string to use to generate a type.</p>
            
            <pre><code>func typeName(typ string) string</code></pre>
         </article>
         
         <article class="function" data-name="balance">
            <h2>balance</h2>
            <hr />
            
            <p>balance returns the number of unclosed '(' characters in s.
If a ')' appears without a corresponding '(', balance returns -1.</p>
            
            <pre><code>func balance(s string) int</code></pre>
         </article>
         
         <article class="function" data-name="excludeFromExpansion">
            <h2>excludeFromExpansion</h2>
            <hr />
            
            <p>excludeFromExpansion reports whether the substring s[idx[0]:idx[1]] in a rule
should be disregarded as a candidate for | expansion.
It uses simple syntactic checks to see whether the substring
is inside an AuxInt expression or inside the && conditions.</p>
            
            <pre><code>func excludeFromExpansion(s string, idx []int) bool</code></pre>
         </article>
         
         <article class="function" data-name="expandOr">
            <h2>expandOr</h2>
            <hr />
            
            <p>expandOr converts a rule into multiple rules by expanding | ops.</p>
            
            <pre><code>func expandOr(r string) []string</code></pre>
         </article>
         
         <article class="function" data-name="varCount">
            <h2>varCount</h2>
            <hr />
            
            <p>varCount returns a map which counts the number of occurrences of
Value variables in the s-expression rr.Match and the Go expression rr.Cond.</p>
            
            <pre><code>func varCount(rr *RuleRewrite) *ast.MapType</code></pre>
         </article>
         
         <article class="function" data-name="varCount1">
            <h2>varCount1</h2>
            <hr />
            
            <pre><code>func varCount1(loc string, m string, cnt *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="normalizeWhitespace">
            <h2>normalizeWhitespace</h2>
            <hr />
            
            <p>normalizeWhitespace replaces 2+ whitespace sequences with a single space.</p>
            
            <pre><code>func normalizeWhitespace(x string) string</code></pre>
         </article>
         
         <article class="function" data-name="opIsCommutative">
            <h2>opIsCommutative</h2>
            <hr />
            
            <p>opIsCommutative reports whether op s is commutative.</p>
            
            <pre><code>func opIsCommutative(op string, arch arch) bool</code></pre>
         </article>
         
         <article class="function" data-name="normalizeMatch">
            <h2>normalizeMatch</h2>
            <hr />
            
            <pre><code>func normalizeMatch(m string, arch arch) string</code></pre>
         </article>
         
         <article class="function" data-name="parseEllipsisRules">
            <h2>parseEllipsisRules</h2>
            <hr />
            
            <pre><code>func parseEllipsisRules(rules []Rule, arch arch) (newop string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="isEllipsisValue">
            <h2>isEllipsisValue</h2>
            <hr />
            
            <p>isEllipsisValue reports whether s is of the form (OpX ...).</p>
            
            <pre><code>func isEllipsisValue(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="checkEllipsisRuleCandidate">
            <h2>checkEllipsisRuleCandidate</h2>
            <hr />
            
            <pre><code>func checkEllipsisRuleCandidate(rule Rule, arch arch)</code></pre>
         </article>
         
         <article class="function" data-name="opByName">
            <h2>opByName</h2>
            <hr />
            
            <pre><code>func opByName(arch arch, name string) opData</code></pre>
         </article>
         
         <article class="function" data-name="auxType">
            <h2>auxType</h2>
            <hr />
            
            <p>auxType returns the Go type that this operation should store in its aux field.</p>
            
            <pre><code>func auxType() string</code></pre>
         </article>
         
         <article class="function" data-name="auxIntType">
            <h2>auxIntType</h2>
            <hr />
            
            <p>auxIntType returns the Go type that this operation should store in its auxInt field.</p>
            
            <pre><code>func auxIntType() string</code></pre>
         </article>
         
         <article class="function" data-name="auxType">
            <h2>auxType</h2>
            <hr />
            
            <p>auxType returns the Go type that this block should store in its aux field.</p>
            
            <pre><code>func auxType() string</code></pre>
         </article>
         
         <article class="function" data-name="auxIntType">
            <h2>auxIntType</h2>
            <hr />
            
            <p>auxIntType returns the Go type that this block should store in its auxInt field.</p>
            
            <pre><code>func auxIntType() string</code></pre>
         </article>
         
         <article class="function" data-name="title">
            <h2>title</h2>
            <hr />
            
            <pre><code>func title(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="unTitle">
            <h2>unTitle</h2>
            <hr />
            
            <pre><code>func unTitle(s string) string</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="genAllocators">
            <h2>genAllocators</h2>
            <hr />
            
            <pre><code>func genAllocators()</code></pre>
         </article>
         
         <article class="function" data-name="genAllocator">
            <h2>genAllocator</h2>
            <hr />
            
            <pre><code>func genAllocator(w io.Writer, a allocator)</code></pre>
         </article>
         
         <article class="function" data-name="genDerived">
            <h2>genDerived</h2>
            <hr />
            
            <pre><code>func genDerived(w io.Writer, d derived, base allocator)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
