<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - main</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>main</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"fmt"
"bytes"
"flag"
"fmt"
"go/format"
"log"
"math/bits"
"os"
"path"
"regexp"
"runtime"
"runtime/pprof"
"runtime/trace"
"slices"
"sort"
"strings"
"sync"
"bufio"
"bytes"
"flag"
"fmt"
"go/ast"
"go/format"
"go/parser"
"go/printer"
"go/token"
"io"
"log"
"os"
"path"
"regexp"
"sort"
"strconv"
"strings"
"golang.org/x/tools/go/ast/astutil"
"strings"
"strings"
"strings"
"strings"
"strings"
"bytes"
"fmt"
"go/format"
"io"
"log"
"os"
"strings"
"strings"
"strings"
"strings"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="addLine">
               <h3>
                  addLine 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var addLine = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="archs">
               <h3>
                  archs 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var archs []arch</code></pre>
            </article>
            
            <article class="global" data-name="cpuprofile">
               <h3>
                  cpuprofile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var cpuprofile = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="dec64Blocks">
               <h3>
                  dec64Blocks 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dec64Blocks = []blockData{...}</code></pre>
            </article>
            
            <article class="global" data-name="dec64Ops">
               <h3>
                  dec64Ops 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var dec64Ops = []opData{...}</code></pre>
            </article>
            
            <article class="global" data-name="decBlocks">
               <h3>
                  decBlocks 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var decBlocks = []blockData{...}</code></pre>
            </article>
            
            <article class="global" data-name="decOps">
               <h3>
                  decOps 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var decOps = []opData{...}</code></pre>
            </article>
            
            <article class="global" data-name="emptyFset">
               <h3>
                  emptyFset 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var emptyFset = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="findAllOpcode">
               <h3>
                  findAllOpcode 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>findAllOpcode is a function to find the opcode portion of s-expressions.</p>
               
               <pre><code>var findAllOpcode = *ast.CallExpr.FindAllStringIndex</code></pre>
            </article>
            
            <article class="global" data-name="genLog">
               <h3>
                  genLog 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var genLog = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="genericBlocks">
               <h3>
                  genericBlocks 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var genericBlocks = []blockData{...}</code></pre>
            </article>
            
            <article class="global" data-name="genericOps">
               <h3>
                  genericOps 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var genericOps = []opData{...}</code></pre>
            </article>
            
            <article class="global" data-name="memprofile">
               <h3>
                  memprofile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var memprofile = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="predeclared">
               <h3>
                  predeclared 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>predeclared contains globally known tokens that should not be redefined.</p>
               
               <pre><code>var predeclared = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global" data-name="printConfig">
               <h3>
                  printConfig 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var printConfig = printer.Config{...}</code></pre>
            </article>
            
            <article class="global" data-name="regNames386">
               <h3>
                  regNames386 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>copied from ../../x86/reg.go</p>
               
               <pre><code>var regNames386 = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="regNamesAMD64">
               <h3>
                  regNamesAMD64 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>copied from ../../amd64/reg.go</p>
               
               <pre><code>var regNamesAMD64 = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="regNamesARM">
               <h3>
                  regNamesARM 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var regNamesARM = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="regNamesARM64">
               <h3>
                  regNamesARM64 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Note: registers not used in regalloc are not included in this list,
so that regmask stays within int64
Be careful when hand coding regmasks.</p>
               
               <pre><code>var regNamesARM64 = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="regNamesLOONG64">
               <h3>
                  regNamesLOONG64 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Note: registers not used in regalloc are not included in this list,
so that regmask stays within int64
Be careful when hand coding regmasks.</p>
               
               <pre><code>var regNamesLOONG64 = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="regNamesMIPS">
               <h3>
                  regNamesMIPS 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Note: registers not used in regalloc are not included in this list,
so that regmask stays within int64
Be careful when hand coding regmasks.</p>
               
               <pre><code>var regNamesMIPS = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="regNamesMIPS64">
               <h3>
                  regNamesMIPS64 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Note: registers not used in regalloc are not included in this list,
so that regmask stays within int64
Be careful when hand coding regmasks.</p>
               
               <pre><code>var regNamesMIPS64 = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="regNamesPPC64">
               <h3>
                  regNamesPPC64 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var regNamesPPC64 = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="regNamesS390X">
               <h3>
                  regNamesS390X 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>copied from ../../s390x/reg.go</p>
               
               <pre><code>var regNamesS390X = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="regNamesWasm">
               <h3>
                  regNamesWasm 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var regNamesWasm = []string{...}</code></pre>
            </article>
            
            <article class="global" data-name="reservedNames">
               <h3>
                  reservedNames 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var reservedNames = map[string]bool{...}</code></pre>
            </article>
            
            <article class="global" data-name="riscv64REG_CTXT">
               <h3>
                  riscv64REG_CTXT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const riscv64REG_CTXT = 26</code></pre>
            </article>
            
            <article class="global" data-name="riscv64REG_G">
               <h3>
                  riscv64REG_G 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const riscv64REG_G = 27</code></pre>
            </article>
            
            <article class="global" data-name="riscv64REG_GP">
               <h3>
                  riscv64REG_GP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const riscv64REG_GP = 3</code></pre>
            </article>
            
            <article class="global" data-name="riscv64REG_LR">
               <h3>
                  riscv64REG_LR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const riscv64REG_LR = 1</code></pre>
            </article>
            
            <article class="global" data-name="riscv64REG_SP">
               <h3>
                  riscv64REG_SP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const riscv64REG_SP = 2</code></pre>
            </article>
            
            <article class="global" data-name="riscv64REG_TMP">
               <h3>
                  riscv64REG_TMP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const riscv64REG_TMP = 31</code></pre>
            </article>
            
            <article class="global" data-name="riscv64REG_TP">
               <h3>
                  riscv64REG_TP 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const riscv64REG_TP = 4</code></pre>
            </article>
            
            <article class="global" data-name="riscv64REG_ZERO">
               <h3>
                  riscv64REG_ZERO 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const riscv64REG_ZERO = 0</code></pre>
            </article>
            
            <article class="global" data-name="tracefile">
               <h3>
                  tracefile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var tracefile = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="byKey">
               <h3>
                  byKey
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type byKey []intPair</code></pre>
            </article>
            
            <article class="type" data-name="regMask">
               <h3>
                  regMask
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type regMask uint64</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Node">
               <h3>
                  Node
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Node can be a Statement or an ast.Expr.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Node interface {

}</code></pre>
            </article>
            
            <article class="interface" data-name="Statement">
               <h3>
                  Statement
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>Statement can be one of our high-level statement struct types, or an
ast.Stmt under some limited circumstances.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Statement interface {

}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="BodyBase">
               <h3>
                  BodyBase
                  <span class="badge">struct</span>
               </h3>
               
               <p>BodyBase is shared by all of our statement pseudo-node types which can
contain other statements.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type BodyBase struct {
List []Statement
CanFail bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Case">
               <h3>
                  Case
                  <span class="badge">struct</span>
               </h3>
               
               <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.
Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Case struct {
BodyBase
Expr ast.Expr
}</code></pre>
            </article>
            
            <article class="struct" data-name="CondBreak">
               <h3>
                  CondBreak
                  <span class="badge">struct</span>
               </h3>
               
               <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.
Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CondBreak struct {
Cond ast.Expr
InsideCommuteLoop bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="Declare">
               <h3>
                  Declare
                  <span class="badge">struct</span>
               </h3>
               
               <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.
Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Declare struct {
Name string
Value ast.Expr
}</code></pre>
            </article>
            
            <article class="struct" data-name="File">
               <h3>
                  File
                  <span class="badge">struct</span>
               </h3>
               
               <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.
Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type File struct {
BodyBase
Arch arch
Suffix string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Func">
               <h3>
                  Func
                  <span class="badge">struct</span>
               </h3>
               
               <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.
Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Func struct {
BodyBase
Kind string
Suffix string
ArgLen int32
}</code></pre>
            </article>
            
            <article class="struct" data-name="Rule">
               <h3>
                  Rule
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Rule struct {
Rule string
Loc string
}</code></pre>
            </article>
            
            <article class="struct" data-name="RuleRewrite">
               <h3>
                  RuleRewrite
                  <span class="badge">struct</span>
               </h3>
               
               <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.
Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type RuleRewrite struct {
BodyBase
Match string
Cond string
Result string
Check string
Alloc int
Loc string
CommuteDepth int
}</code></pre>
            </article>
            
            <article class="struct" data-name="StartCommuteLoop">
               <h3>
                  StartCommuteLoop
                  <span class="badge">struct</span>
               </h3>
               
               <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.
Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StartCommuteLoop struct {
Depth int
V string
}</code></pre>
            </article>
            
            <article class="struct" data-name="Switch">
               <h3>
                  Switch
                  <span class="badge">struct</span>
               </h3>
               
               <p>These types define some high-level statement struct types, which can be used
as a Statement. This allows us to keep some node structs simpler, and have
higher-level nodes such as an entire rule rewrite.
Note that ast.Expr is always used as-is; we don't declare our own expression
nodes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Switch struct {
BodyBase
Expr ast.Expr
}</code></pre>
            </article>
            
            <article class="struct" data-name="allocator">
               <h3>
                  allocator
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type allocator struct {
name string
typ string
mak string
capacity string
resize string
clear string
minLog int
maxLog int
}</code></pre>
            </article>
            
            <article class="struct" data-name="arch">
               <h3>
                  arch
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type arch struct {
name string
pkg string
genfile string
ops []opData
blocks []blockData
regnames []string
ParamIntRegNames string
ParamFloatRegNames string
gpregmask regMask
fpregmask regMask
fp32regmask regMask
fp64regmask regMask
specialregmask regMask
framepointerreg int8
linkreg int8
generic bool
imports []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="blockData">
               <h3>
                  blockData
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type blockData struct {
name string
controls int
aux string
}</code></pre>
            </article>
            
            <article class="struct" data-name="derived">
               <h3>
                  derived
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type derived struct {
name string
typ string
base string
}</code></pre>
            </article>
            
            <article class="struct" data-name="intPair">
               <h3>
                  intPair
                  <span class="badge">struct</span>
               </h3>
               
               <p>for sorting a pair of integers by key</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type intPair struct {
key int
val int
}</code></pre>
            </article>
            
            <article class="struct" data-name="object">
               <h3>
                  object
                  <span class="badge">struct</span>
               </h3>
               
               <p>object keeps track of a declared name, such as a variable or import.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type object struct {
name string
pos token.Pos
numUses int
used []*object
}</code></pre>
            </article>
            
            <article class="struct" data-name="opData">
               <h3>
                  opData
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type opData struct {
name string
reg regInfo
asm string
typ string
aux string
rematerializeable bool
argLength int32
commutative bool
resultInArg0 bool
resultNotInArgs bool
clobberFlags bool
needIntTemp bool
call bool
tailCall bool
nilCheck bool
faultOnNilArg0 bool
faultOnNilArg1 bool
hasSideEffects bool
zeroWidth bool
unsafePoint bool
symEffect string
scale uint8
}</code></pre>
            </article>
            
            <article class="struct" data-name="regInfo">
               <h3>
                  regInfo
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type regInfo struct {
inputs []regMask
clobbers regMask
outputs []regMask
}</code></pre>
            </article>
            
            <article class="struct" data-name="scope">
               <h3>
                  scope
                  <span class="badge">struct</span>
               </h3>
               
               <p>scope keeps track of a certain scope and its declared names, as well as the
outer (parent) scope.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type scope struct {
outer *scope
objects map[string]*object
}</code></pre>
            </article>
            
            <article class="struct" data-name="unusedInspector">
               <h3>
                  unusedInspector
                  <span class="badge">struct</span>
               </h3>
               
               <p>unusedInspector can be used to detect unused variables and imports in an
ast.Node via its node method. The result is available in the "unused" map.
note that unusedInspector is lazy and best-effort; it only supports the node
types and patterns used by the rulegen program.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type unusedInspector struct {
scope *scope
unused map[token.Pos]bool
defining *object
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Len">
               <h3>
                  Len 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a byKey) Len() int</code></pre>
            </article>
            
            <article class="function" data-name="Less">
               <h3>
                  Less 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a byKey) Less(i int, j int) bool</code></pre>
            </article>
            
            <article class="function" data-name="Lookup">
               <h3>
                  Lookup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *scope) Lookup(name string) *object</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Name returns the name of the architecture for use in Op* and Block* enumerations.</p>
               
               <pre><code>func (a arch) Name() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r Rule) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Swap">
               <h3>
                  Swap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a byKey) Swap(i int, j int)</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *BodyBase) add(node Statement)</code></pre>
            </article>
            
            <article class="function" data-name="auxIntType">
               <h3>
                  auxIntType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>auxIntType returns the Go type that this operation should store in its auxInt field.</p>
               
               <pre><code>func (op opData) auxIntType() string</code></pre>
            </article>
            
            <article class="function" data-name="auxIntType">
               <h3>
                  auxIntType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>auxIntType returns the Go type that this block should store in its auxInt field.</p>
               
               <pre><code>func (b blockData) auxIntType() string</code></pre>
            </article>
            
            <article class="function" data-name="auxType">
               <h3>
                  auxType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>auxType returns the Go type that this block should store in its aux field.</p>
               
               <pre><code>func (b blockData) auxType() string</code></pre>
            </article>
            
            <article class="function" data-name="auxType">
               <h3>
                  auxType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>auxType returns the Go type that this operation should store in its aux field.</p>
               
               <pre><code>func (op opData) auxType() string</code></pre>
            </article>
            
            <article class="function" data-name="balance">
               <h3>
                  balance 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>balance returns the number of unclosed '(' characters in s.
If a ')' appears without a corresponding '(', balance returns -1.</p>
               
               <pre><code>func balance(s string) int</code></pre>
            </article>
            
            <article class="function" data-name="breakf">
               <h3>
                  breakf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>breakf constructs a simple "if cond { break }" statement, using exprf for its
condition.</p>
               
               <pre><code>func breakf(format string, a ...interface{}) *CondBreak</code></pre>
            </article>
            
            <article class="function" data-name="checkEllipsisRuleCandidate">
               <h3>
                  checkEllipsisRuleCandidate 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func checkEllipsisRuleCandidate(rule Rule, arch arch)</code></pre>
            </article>
            
            <article class="function" data-name="countRegs">
               <h3>
                  countRegs 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>countRegs returns the number of set bits in the register mask.</p>
               
               <pre><code>func countRegs(r regMask) int</code></pre>
            </article>
            
            <article class="function" data-name="declReserved">
               <h3>
                  declReserved 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>declReserved is like declf, but the name must be one of reservedNames.
Calls to declReserved should generally be static and top-level.</p>
               
               <pre><code>func declReserved(name string, value string) *Declare</code></pre>
            </article>
            
            <article class="function" data-name="declared">
               <h3>
                  declared 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>declared reports if the body contains a Declare with the given name.</p>
               
               <pre><code>func (w *BodyBase) declared(name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="declf">
               <h3>
                  declf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>declf constructs a simple "name := value" declaration,
using exprf for its value.
name must not be one of reservedNames.
This helps prevent unintended shadowing and name clashes.
To declare a reserved name, use declReserved.</p>
               
               <pre><code>func declf(loc string, name string, format string, a ...interface{}) *Declare</code></pre>
            </article>
            
            <article class="function" data-name="excludeFromExpansion">
               <h3>
                  excludeFromExpansion 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>excludeFromExpansion reports whether the substring s[idx[0]:idx[1]] in a rule
should be disregarded as a candidate for | expansion.
It uses simple syntactic checks to see whether the substring
is inside an AuxInt expression or inside the && conditions.</p>
               
               <pre><code>func excludeFromExpansion(s string, idx []int) bool</code></pre>
            </article>
            
            <article class="function" data-name="expandOr">
               <h3>
                  expandOr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>expandOr converts a rule into multiple rules by expanding | ops.</p>
               
               <pre><code>func expandOr(r string) []string</code></pre>
            </article>
            
            <article class="function" data-name="exprf">
               <h3>
                  exprf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>exprf parses a Go expression generated from fmt.Sprintf, panicking if an
error occurs.</p>
               
               <pre><code>func exprf(format string, a ...interface{}) ast.Expr</code></pre>
            </article>
            
            <article class="function" data-name="exprs">
               <h3>
                  exprs 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (u *unusedInspector) exprs(list []ast.Expr)</code></pre>
            </article>
            
            <article class="function" data-name="extract">
               <h3>
                  extract 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func extract(val string) (op string, typ string, auxint string, aux string, args []string)</code></pre>
            </article>
            
            <article class="function" data-name="fprint">
               <h3>
                  fprint 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func fprint(w io.Writer, n Node)</code></pre>
            </article>
            
            <article class="function" data-name="genAllocator">
               <h3>
                  genAllocator 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genAllocator(w io.Writer, a allocator)</code></pre>
            </article>
            
            <article class="function" data-name="genAllocators">
               <h3>
                  genAllocators 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genAllocators()</code></pre>
            </article>
            
            <article class="function" data-name="genBlockRewrite">
               <h3>
                  genBlockRewrite 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genBlockRewrite(rule Rule, arch arch, data blockData) *RuleRewrite</code></pre>
            </article>
            
            <article class="function" data-name="genDerived">
               <h3>
                  genDerived 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genDerived(w io.Writer, d derived, base allocator)</code></pre>
            </article>
            
            <article class="function" data-name="genLateLowerRules">
               <h3>
                  genLateLowerRules 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genLateLowerRules(arch arch)</code></pre>
            </article>
            
            <article class="function" data-name="genMatch">
               <h3>
                  genMatch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>genMatch returns the variable whose source position should be used for the
result (or "" if no opinion), and a boolean that reports whether the match can fail.</p>
               
               <pre><code>func genMatch(rr *RuleRewrite, arch arch, match string, pregenTop bool) (pos string, checkOp string)</code></pre>
            </article>
            
            <article class="function" data-name="genMatch0">
               <h3>
                  genMatch0 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genMatch0(rr *RuleRewrite, arch arch, match string, v string, cnt map[string]int, pregenTop bool) (pos string, checkOp string)</code></pre>
            </article>
            
            <article class="function" data-name="genOp">
               <h3>
                  genOp 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genOp()</code></pre>
            </article>
            
            <article class="function" data-name="genResult">
               <h3>
                  genResult 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genResult(rr *RuleRewrite, arch arch, result string, pos string)</code></pre>
            </article>
            
            <article class="function" data-name="genResult0">
               <h3>
                  genResult0 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genResult0(rr *RuleRewrite, arch arch, result string, top bool, move bool, pos string, cse map[string]string) string</code></pre>
            </article>
            
            <article class="function" data-name="genRules">
               <h3>
                  genRules 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genRules(arch arch)</code></pre>
            </article>
            
            <article class="function" data-name="genRulesSuffix">
               <h3>
                  genRulesSuffix 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genRulesSuffix(arch arch, suff string)</code></pre>
            </article>
            
            <article class="function" data-name="genSplitLoadRules">
               <h3>
                  genSplitLoadRules 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func genSplitLoadRules(arch arch)</code></pre>
            </article>
            
            <article class="function" data-name="getBlockInfo">
               <h3>
                  getBlockInfo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func getBlockInfo(op string, arch arch) (name string, data blockData)</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func init()</code></pre>
            </article>
            
            <article class="function" data-name="isBlock">
               <h3>
                  isBlock 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isBlock reports whether this op is a block opcode.</p>
               
               <pre><code>func isBlock(name string, arch arch) bool</code></pre>
            </article>
            
            <article class="function" data-name="isEllipsisValue">
               <h3>
                  isEllipsisValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isEllipsisValue reports whether s is of the form (OpX ...).</p>
               
               <pre><code>func isEllipsisValue(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="main">
               <h3>
                  main 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func main()</code></pre>
            </article>
            
            <article class="function" data-name="node">
               <h3>
                  node 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (u *unusedInspector) node(node ast.Node)</code></pre>
            </article>
            
            <article class="function" data-name="normalizeMatch">
               <h3>
                  normalizeMatch 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func normalizeMatch(m string, arch arch) string</code></pre>
            </article>
            
            <article class="function" data-name="normalizeSpaces">
               <h3>
                  normalizeSpaces 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func normalizeSpaces(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="normalizeWhitespace">
               <h3>
                  normalizeWhitespace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>normalizeWhitespace replaces 2+ whitespace sequences with a single space.</p>
               
               <pre><code>func normalizeWhitespace(x string) string</code></pre>
            </article>
            
            <article class="function" data-name="opByName">
               <h3>
                  opByName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func opByName(arch arch, name string) opData</code></pre>
            </article>
            
            <article class="function" data-name="opHasAux">
               <h3>
                  opHasAux 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func opHasAux(op opData) bool</code></pre>
            </article>
            
            <article class="function" data-name="opHasAuxInt">
               <h3>
                  opHasAuxInt 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func opHasAuxInt(op opData) bool</code></pre>
            </article>
            
            <article class="function" data-name="opIsCommutative">
               <h3>
                  opIsCommutative 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>opIsCommutative reports whether op s is commutative.</p>
               
               <pre><code>func opIsCommutative(op string, arch arch) bool</code></pre>
            </article>
            
            <article class="function" data-name="parse">
               <h3>
                  parse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parse returns the matching part of the rule, additional conditions, and the result.</p>
               
               <pre><code>func (r Rule) parse() (match string, cond string, result string)</code></pre>
            </article>
            
            <article class="function" data-name="parseEllipsisRules">
               <h3>
                  parseEllipsisRules 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func parseEllipsisRules(rules []Rule, arch arch) (newop string, ok bool)</code></pre>
            </article>
            
            <article class="function" data-name="parseValue">
               <h3>
                  parseValue 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseValue parses a parenthesized value from a rule.
The value can be from the match or the result side.
It returns the op and unparsed strings for typ, auxint, and aux restrictions and for all args.
oparch is the architecture that op is located in, or "" for generic.</p>
               
               <pre><code>func parseValue(val string, arch arch, loc string) (op opData, oparch string, typ string, auxint string, aux string, args []string)</code></pre>
            </article>
            
            <article class="function" data-name="regMaskComment">
               <h3>
                  regMaskComment 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a arch) regMaskComment(r regMask) string</code></pre>
            </article>
            
            <article class="function" data-name="riscv64RegName">
               <h3>
                  riscv64RegName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func riscv64RegName(r int) string</code></pre>
            </article>
            
            <article class="function" data-name="scoped">
               <h3>
                  scoped 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>scoped opens a new scope when called, and returns a function which closes
that same scope. When a scope is closed, unused variables are recorded.</p>
               
               <pre><code>func (u *unusedInspector) scoped() func()</code></pre>
            </article>
            
            <article class="function" data-name="split">
               <h3>
                  split 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func split(s string) []string</code></pre>
            </article>
            
            <article class="function" data-name="splitNameExpr">
               <h3>
                  splitNameExpr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>splitNameExpr splits s-expr arg, possibly prefixed by "name:",
into name and the unprefixed expression.
For example, "x:(Foo)" yields "x", "(Foo)",
and "(Foo)" yields "", "(Foo)".</p>
               
               <pre><code>func splitNameExpr(arg string) (name string, expr string)</code></pre>
            </article>
            
            <article class="function" data-name="stmtf">
               <h3>
                  stmtf 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>stmtf parses a Go statement generated from fmt.Sprintf. This function is only
meant for simple statements that don't have a custom Statement node declared
in this package, such as ast.ReturnStmt or ast.ExprStmt.</p>
               
               <pre><code>func stmtf(format string, a ...interface{}) Statement</code></pre>
            </article>
            
            <article class="function" data-name="title">
               <h3>
                  title 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func title(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="typeName">
               <h3>
                  typeName 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>typeName returns the string to use to generate a type.</p>
               
               <pre><code>func typeName(typ string) string</code></pre>
            </article>
            
            <article class="function" data-name="unTitle">
               <h3>
                  unTitle 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func unTitle(s string) string</code></pre>
            </article>
            
            <article class="function" data-name="varCount">
               <h3>
                  varCount 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>varCount returns a map which counts the number of occurrences of
Value variables in the s-expression rr.Match and the Go expression rr.Cond.</p>
               
               <pre><code>func varCount(rr *RuleRewrite) map[string]int</code></pre>
            </article>
            
            <article class="function" data-name="varCount1">
               <h3>
                  varCount1 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func varCount1(loc string, m string, cnt map[string]int)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
