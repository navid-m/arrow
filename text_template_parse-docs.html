<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - parse</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>parse</code>
         </h1>
         <hr />
         
         <article class="global" data-name="textFormat">
            <h2>textFormat</h2>
            <hr />
            
            <pre><code>textFormat</code></pre>
         </article>
         
         <article class="global" data-name="NodeText">
            <h2>NodeText</h2>
            <hr />
            
            <pre><code>NodeText NodeType</code></pre>
         </article>
         
         <article class="global" data-name="NodeAction">
            <h2>NodeAction</h2>
            <hr />
            
            <pre><code>NodeAction</code></pre>
         </article>
         
         <article class="global" data-name="NodeBool">
            <h2>NodeBool</h2>
            <hr />
            
            <pre><code>NodeBool</code></pre>
         </article>
         
         <article class="global" data-name="NodeChain">
            <h2>NodeChain</h2>
            <hr />
            
            <pre><code>NodeChain</code></pre>
         </article>
         
         <article class="global" data-name="NodeCommand">
            <h2>NodeCommand</h2>
            <hr />
            
            <pre><code>NodeCommand</code></pre>
         </article>
         
         <article class="global" data-name="NodeDot">
            <h2>NodeDot</h2>
            <hr />
            
            <pre><code>NodeDot</code></pre>
         </article>
         
         <article class="global" data-name="nodeElse">
            <h2>nodeElse</h2>
            <hr />
            
            <pre><code>nodeElse</code></pre>
         </article>
         
         <article class="global" data-name="nodeEnd">
            <h2>nodeEnd</h2>
            <hr />
            
            <pre><code>nodeEnd</code></pre>
         </article>
         
         <article class="global" data-name="NodeField">
            <h2>NodeField</h2>
            <hr />
            
            <pre><code>NodeField</code></pre>
         </article>
         
         <article class="global" data-name="NodeIdentifier">
            <h2>NodeIdentifier</h2>
            <hr />
            
            <pre><code>NodeIdentifier</code></pre>
         </article>
         
         <article class="global" data-name="NodeIf">
            <h2>NodeIf</h2>
            <hr />
            
            <pre><code>NodeIf</code></pre>
         </article>
         
         <article class="global" data-name="NodeList">
            <h2>NodeList</h2>
            <hr />
            
            <pre><code>NodeList</code></pre>
         </article>
         
         <article class="global" data-name="NodeNil">
            <h2>NodeNil</h2>
            <hr />
            
            <pre><code>NodeNil</code></pre>
         </article>
         
         <article class="global" data-name="NodeNumber">
            <h2>NodeNumber</h2>
            <hr />
            
            <pre><code>NodeNumber</code></pre>
         </article>
         
         <article class="global" data-name="NodePipe">
            <h2>NodePipe</h2>
            <hr />
            
            <pre><code>NodePipe</code></pre>
         </article>
         
         <article class="global" data-name="NodeRange">
            <h2>NodeRange</h2>
            <hr />
            
            <pre><code>NodeRange</code></pre>
         </article>
         
         <article class="global" data-name="NodeString">
            <h2>NodeString</h2>
            <hr />
            
            <pre><code>NodeString</code></pre>
         </article>
         
         <article class="global" data-name="NodeTemplate">
            <h2>NodeTemplate</h2>
            <hr />
            
            <pre><code>NodeTemplate</code></pre>
         </article>
         
         <article class="global" data-name="NodeVariable">
            <h2>NodeVariable</h2>
            <hr />
            
            <pre><code>NodeVariable</code></pre>
         </article>
         
         <article class="global" data-name="NodeWith">
            <h2>NodeWith</h2>
            <hr />
            
            <pre><code>NodeWith</code></pre>
         </article>
         
         <article class="global" data-name="NodeComment">
            <h2>NodeComment</h2>
            <hr />
            
            <pre><code>NodeComment</code></pre>
         </article>
         
         <article class="global" data-name="NodeBreak">
            <h2>NodeBreak</h2>
            <hr />
            
            <pre><code>NodeBreak</code></pre>
         </article>
         
         <article class="global" data-name="NodeContinue">
            <h2>NodeContinue</h2>
            <hr />
            
            <pre><code>NodeContinue</code></pre>
         </article>
         
         <article class="global" data-name="ParseComments">
            <h2>ParseComments</h2>
            <hr />
            
            <pre><code>ParseComments Mode</code></pre>
         </article>
         
         <article class="global" data-name="SkipFuncCheck">
            <h2>SkipFuncCheck</h2>
            <hr />
            
            <pre><code>SkipFuncCheck</code></pre>
         </article>
         
         <article class="global" data-name="debug">
            <h2>debug</h2>
            <hr />
            
            <pre><code>debug</code></pre>
         </article>
         
         <article class="global" data-name="numberTests">
            <h2>numberTests</h2>
            <hr />
            
            <pre><code>numberTests</code></pre>
         </article>
         
         <article class="global" data-name="noError">
            <h2>noError</h2>
            <hr />
            
            <pre><code>noError</code></pre>
         </article>
         
         <article class="global" data-name="hasError">
            <h2>hasError</h2>
            <hr />
            
            <pre><code>hasError</code></pre>
         </article>
         
         <article class="global" data-name="parseTests">
            <h2>parseTests</h2>
            <hr />
            
            <pre><code>parseTests</code></pre>
         </article>
         
         <article class="global" data-name="builtins">
            <h2>builtins</h2>
            <hr />
            
            <pre><code>builtins</code></pre>
         </article>
         
         <article class="global" data-name="isEmptyTests">
            <h2>isEmptyTests</h2>
            <hr />
            
            <pre><code>isEmptyTests</code></pre>
         </article>
         
         <article class="global" data-name="errorTests">
            <h2>errorTests</h2>
            <hr />
            
            <p>All failures, and the result is a string that must appear in the error message.</p>
            
            <pre><code>errorTests</code></pre>
         </article>
         
         <article class="global" data-name="sinkv">
            <h2>sinkv</h2>
            <hr />
            
            <pre><code>sinkv string</code></pre>
         </article>
         
         <article class="global" data-name="sinkl">
            <h2>sinkl</h2>
            <hr />
            
            <pre><code>sinkl string</code></pre>
         </article>
         
         <article class="global" data-name="itemError">
            <h2>itemError</h2>
            <hr />
            
            <pre><code>itemError itemType</code></pre>
         </article>
         
         <article class="global" data-name="itemBool">
            <h2>itemBool</h2>
            <hr />
            
            <pre><code>itemBool</code></pre>
         </article>
         
         <article class="global" data-name="itemChar">
            <h2>itemChar</h2>
            <hr />
            
            <pre><code>itemChar</code></pre>
         </article>
         
         <article class="global" data-name="itemCharConstant">
            <h2>itemCharConstant</h2>
            <hr />
            
            <pre><code>itemCharConstant</code></pre>
         </article>
         
         <article class="global" data-name="itemComment">
            <h2>itemComment</h2>
            <hr />
            
            <pre><code>itemComment</code></pre>
         </article>
         
         <article class="global" data-name="itemComplex">
            <h2>itemComplex</h2>
            <hr />
            
            <pre><code>itemComplex</code></pre>
         </article>
         
         <article class="global" data-name="itemAssign">
            <h2>itemAssign</h2>
            <hr />
            
            <pre><code>itemAssign</code></pre>
         </article>
         
         <article class="global" data-name="itemDeclare">
            <h2>itemDeclare</h2>
            <hr />
            
            <pre><code>itemDeclare</code></pre>
         </article>
         
         <article class="global" data-name="itemEOF">
            <h2>itemEOF</h2>
            <hr />
            
            <pre><code>itemEOF</code></pre>
         </article>
         
         <article class="global" data-name="itemField">
            <h2>itemField</h2>
            <hr />
            
            <pre><code>itemField</code></pre>
         </article>
         
         <article class="global" data-name="itemIdentifier">
            <h2>itemIdentifier</h2>
            <hr />
            
            <pre><code>itemIdentifier</code></pre>
         </article>
         
         <article class="global" data-name="itemLeftDelim">
            <h2>itemLeftDelim</h2>
            <hr />
            
            <pre><code>itemLeftDelim</code></pre>
         </article>
         
         <article class="global" data-name="itemLeftParen">
            <h2>itemLeftParen</h2>
            <hr />
            
            <pre><code>itemLeftParen</code></pre>
         </article>
         
         <article class="global" data-name="itemNumber">
            <h2>itemNumber</h2>
            <hr />
            
            <pre><code>itemNumber</code></pre>
         </article>
         
         <article class="global" data-name="itemPipe">
            <h2>itemPipe</h2>
            <hr />
            
            <pre><code>itemPipe</code></pre>
         </article>
         
         <article class="global" data-name="itemRawString">
            <h2>itemRawString</h2>
            <hr />
            
            <pre><code>itemRawString</code></pre>
         </article>
         
         <article class="global" data-name="itemRightDelim">
            <h2>itemRightDelim</h2>
            <hr />
            
            <pre><code>itemRightDelim</code></pre>
         </article>
         
         <article class="global" data-name="itemRightParen">
            <h2>itemRightParen</h2>
            <hr />
            
            <pre><code>itemRightParen</code></pre>
         </article>
         
         <article class="global" data-name="itemSpace">
            <h2>itemSpace</h2>
            <hr />
            
            <pre><code>itemSpace</code></pre>
         </article>
         
         <article class="global" data-name="itemString">
            <h2>itemString</h2>
            <hr />
            
            <pre><code>itemString</code></pre>
         </article>
         
         <article class="global" data-name="itemText">
            <h2>itemText</h2>
            <hr />
            
            <pre><code>itemText</code></pre>
         </article>
         
         <article class="global" data-name="itemVariable">
            <h2>itemVariable</h2>
            <hr />
            
            <pre><code>itemVariable</code></pre>
         </article>
         
         <article class="global" data-name="itemKeyword">
            <h2>itemKeyword</h2>
            <hr />
            
            <p>Keywords appear after all the rest.</p>
            
            <pre><code>itemKeyword</code></pre>
         </article>
         
         <article class="global" data-name="itemBlock">
            <h2>itemBlock</h2>
            <hr />
            
            <pre><code>itemBlock</code></pre>
         </article>
         
         <article class="global" data-name="itemBreak">
            <h2>itemBreak</h2>
            <hr />
            
            <pre><code>itemBreak</code></pre>
         </article>
         
         <article class="global" data-name="itemContinue">
            <h2>itemContinue</h2>
            <hr />
            
            <pre><code>itemContinue</code></pre>
         </article>
         
         <article class="global" data-name="itemDot">
            <h2>itemDot</h2>
            <hr />
            
            <pre><code>itemDot</code></pre>
         </article>
         
         <article class="global" data-name="itemDefine">
            <h2>itemDefine</h2>
            <hr />
            
            <pre><code>itemDefine</code></pre>
         </article>
         
         <article class="global" data-name="itemElse">
            <h2>itemElse</h2>
            <hr />
            
            <pre><code>itemElse</code></pre>
         </article>
         
         <article class="global" data-name="itemEnd">
            <h2>itemEnd</h2>
            <hr />
            
            <pre><code>itemEnd</code></pre>
         </article>
         
         <article class="global" data-name="itemIf">
            <h2>itemIf</h2>
            <hr />
            
            <pre><code>itemIf</code></pre>
         </article>
         
         <article class="global" data-name="itemNil">
            <h2>itemNil</h2>
            <hr />
            
            <pre><code>itemNil</code></pre>
         </article>
         
         <article class="global" data-name="itemRange">
            <h2>itemRange</h2>
            <hr />
            
            <pre><code>itemRange</code></pre>
         </article>
         
         <article class="global" data-name="itemTemplate">
            <h2>itemTemplate</h2>
            <hr />
            
            <pre><code>itemTemplate</code></pre>
         </article>
         
         <article class="global" data-name="itemWith">
            <h2>itemWith</h2>
            <hr />
            
            <pre><code>itemWith</code></pre>
         </article>
         
         <article class="global" data-name="key">
            <h2>key</h2>
            <hr />
            
            <pre><code>key</code></pre>
         </article>
         
         <article class="global" data-name="eof">
            <h2>eof</h2>
            <hr />
            
            <pre><code>eof</code></pre>
         </article>
         
         <article class="global" data-name="spaceChars">
            <h2>spaceChars</h2>
            <hr />
            
            <p>Trimming spaces.
If the action begins "{{- " rather than "{{", then all space/tab/newlines
preceding the action are trimmed; conversely if it ends " -}}" the
leading spaces are trimmed. This is done entirely in the lexer; the
parser never sees it happen. We require an ASCII space (' ', \t, \r, \n)
to be present to avoid ambiguity with things like "{{-3}}". It reads
better with the space present anyway. For simplicity, only ASCII
does the job.</p>
            
            <pre><code>spaceChars</code></pre>
         </article>
         
         <article class="global" data-name="trimMarker">
            <h2>trimMarker</h2>
            <hr />
            
            <p>Trimming spaces.
If the action begins "{{- " rather than "{{", then all space/tab/newlines
preceding the action are trimmed; conversely if it ends " -}}" the
leading spaces are trimmed. This is done entirely in the lexer; the
parser never sees it happen. We require an ASCII space (' ', \t, \r, \n)
to be present to avoid ambiguity with things like "{{-3}}". It reads
better with the space present anyway. For simplicity, only ASCII
does the job.</p>
            
            <pre><code>trimMarker</code></pre>
         </article>
         
         <article class="global" data-name="trimMarkerLen">
            <h2>trimMarkerLen</h2>
            <hr />
            
            <p>Trimming spaces.
If the action begins "{{- " rather than "{{", then all space/tab/newlines
preceding the action are trimmed; conversely if it ends " -}}" the
leading spaces are trimmed. This is done entirely in the lexer; the
parser never sees it happen. We require an ASCII space (' ', \t, \r, \n)
to be present to avoid ambiguity with things like "{{-3}}". It reads
better with the space present anyway. For simplicity, only ASCII
does the job.</p>
            
            <pre><code>trimMarkerLen</code></pre>
         </article>
         
         <article class="global" data-name="leftDelim">
            <h2>leftDelim</h2>
            <hr />
            
            <pre><code>leftDelim</code></pre>
         </article>
         
         <article class="global" data-name="rightDelim">
            <h2>rightDelim</h2>
            <hr />
            
            <pre><code>rightDelim</code></pre>
         </article>
         
         <article class="global" data-name="leftComment">
            <h2>leftComment</h2>
            <hr />
            
            <pre><code>leftComment</code></pre>
         </article>
         
         <article class="global" data-name="rightComment">
            <h2>rightComment</h2>
            <hr />
            
            <pre><code>rightComment</code></pre>
         </article>
         
         <article class="global" data-name="itemName">
            <h2>itemName</h2>
            <hr />
            
            <p>Make the types prettyprint.</p>
            
            <pre><code>itemName</code></pre>
         </article>
         
         <article class="global" data-name="tDot">
            <h2>tDot</h2>
            <hr />
            
            <pre><code>tDot</code></pre>
         </article>
         
         <article class="global" data-name="tBlock">
            <h2>tBlock</h2>
            <hr />
            
            <pre><code>tBlock</code></pre>
         </article>
         
         <article class="global" data-name="tEOF">
            <h2>tEOF</h2>
            <hr />
            
            <pre><code>tEOF</code></pre>
         </article>
         
         <article class="global" data-name="tFor">
            <h2>tFor</h2>
            <hr />
            
            <pre><code>tFor</code></pre>
         </article>
         
         <article class="global" data-name="tLeft">
            <h2>tLeft</h2>
            <hr />
            
            <pre><code>tLeft</code></pre>
         </article>
         
         <article class="global" data-name="tLpar">
            <h2>tLpar</h2>
            <hr />
            
            <pre><code>tLpar</code></pre>
         </article>
         
         <article class="global" data-name="tPipe">
            <h2>tPipe</h2>
            <hr />
            
            <pre><code>tPipe</code></pre>
         </article>
         
         <article class="global" data-name="tQuote">
            <h2>tQuote</h2>
            <hr />
            
            <pre><code>tQuote</code></pre>
         </article>
         
         <article class="global" data-name="tRange">
            <h2>tRange</h2>
            <hr />
            
            <pre><code>tRange</code></pre>
         </article>
         
         <article class="global" data-name="tRight">
            <h2>tRight</h2>
            <hr />
            
            <pre><code>tRight</code></pre>
         </article>
         
         <article class="global" data-name="tRpar">
            <h2>tRpar</h2>
            <hr />
            
            <pre><code>tRpar</code></pre>
         </article>
         
         <article class="global" data-name="tSpace">
            <h2>tSpace</h2>
            <hr />
            
            <pre><code>tSpace</code></pre>
         </article>
         
         <article class="global" data-name="raw">
            <h2>raw</h2>
            <hr />
            
            <pre><code>raw</code></pre>
         </article>
         
         <article class="global" data-name="rawNL">
            <h2>rawNL</h2>
            <hr />
            
            <pre><code>rawNL</code></pre>
         </article>
         
         <article class="global" data-name="tRawQuote">
            <h2>tRawQuote</h2>
            <hr />
            
            <pre><code>tRawQuote</code></pre>
         </article>
         
         <article class="global" data-name="tRawQuoteNL">
            <h2>tRawQuoteNL</h2>
            <hr />
            
            <pre><code>tRawQuoteNL</code></pre>
         </article>
         
         <article class="global" data-name="lexTests">
            <h2>lexTests</h2>
            <hr />
            
            <pre><code>lexTests</code></pre>
         </article>
         
         <article class="global" data-name="lexDelimTests">
            <h2>lexDelimTests</h2>
            <hr />
            
            <p>Some easy cases from above, but with delimiters $$ and @@</p>
            
            <pre><code>lexDelimTests</code></pre>
         </article>
         
         <article class="global" data-name="tLeftDelim">
            <h2>tLeftDelim</h2>
            <hr />
            
            <pre><code>tLeftDelim</code></pre>
         </article>
         
         <article class="global" data-name="tRightDelim">
            <h2>tRightDelim</h2>
            <hr />
            
            <pre><code>tRightDelim</code></pre>
         </article>
         
         <article class="global" data-name="lexPosTests">
            <h2>lexPosTests</h2>
            <hr />
            
            <pre><code>lexPosTests</code></pre>
         </article>
          
         <article class="struct" data-name="ListNode">
            <h2>type ListNode struct</h2>
            <hr />
            
            <p>ListNode holds a sequence of nodes.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Nodes []Node</code></pre>
         </article>
         
         <article class="struct" data-name="TextNode">
            <h2>type TextNode struct</h2>
            <hr />
            
            <p>TextNode holds plain text.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Text []byte</code></pre>
         </article>
         
         <article class="struct" data-name="CommentNode">
            <h2>type CommentNode struct</h2>
            <hr />
            
            <p>CommentNode holds a comment.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Text string</code></pre>
         </article>
         
         <article class="struct" data-name="PipeNode">
            <h2>type PipeNode struct</h2>
            <hr />
            
            <p>PipeNode holds a pipeline with optional declaration</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Line int
IsAssign bool
Decl []*VariableNode
Cmds []*CommandNode</code></pre>
         </article>
         
         <article class="struct" data-name="ActionNode">
            <h2>type ActionNode struct</h2>
            <hr />
            
            <p>ActionNode holds an action (something bounded by delimiters).
Control actions have their own nodes; ActionNode represents simple
ones such as field evaluations and parenthesized pipelines.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Line int
Pipe *PipeNode</code></pre>
         </article>
         
         <article class="struct" data-name="CommandNode">
            <h2>type CommandNode struct</h2>
            <hr />
            
            <p>CommandNode holds a command (a pipeline inside an evaluating action).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Args []Node</code></pre>
         </article>
         
         <article class="struct" data-name="IdentifierNode">
            <h2>type IdentifierNode struct</h2>
            <hr />
            
            <p>IdentifierNode holds an identifier.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Ident string</code></pre>
         </article>
         
         <article class="struct" data-name="VariableNode">
            <h2>type VariableNode struct</h2>
            <hr />
            
            <p>VariableNode holds a list of variable names, possibly with chained field
accesses. The dollar sign is part of the (first) name.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Ident []string</code></pre>
         </article>
         
         <article class="struct" data-name="DotNode">
            <h2>type DotNode struct</h2>
            <hr />
            
            <p>DotNode holds the special identifier '.'.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree</code></pre>
         </article>
         
         <article class="struct" data-name="NilNode">
            <h2>type NilNode struct</h2>
            <hr />
            
            <p>NilNode holds the special identifier 'nil' representing an untyped nil constant.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree</code></pre>
         </article>
         
         <article class="struct" data-name="FieldNode">
            <h2>type FieldNode struct</h2>
            <hr />
            
            <p>FieldNode holds a field (identifier starting with '.').
The names may be chained ('.x.y').
The period is dropped from each ident.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Ident []string</code></pre>
         </article>
         
         <article class="struct" data-name="ChainNode">
            <h2>type ChainNode struct</h2>
            <hr />
            
            <p>ChainNode holds a term followed by a chain of field accesses (identifier starting with '.').
The names may be chained ('.x.y').
The periods are dropped from each ident.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Node Node
Field []string</code></pre>
         </article>
         
         <article class="struct" data-name="BoolNode">
            <h2>type BoolNode struct</h2>
            <hr />
            
            <p>BoolNode holds a boolean constant.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
True bool</code></pre>
         </article>
         
         <article class="struct" data-name="NumberNode">
            <h2>type NumberNode struct</h2>
            <hr />
            
            <p>NumberNode holds a number: signed or unsigned integer, float, or complex.
The value is parsed and stored under all the types that can represent the value.
This simulates in a small amount of code the behavior of Go's ideal constants.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
IsInt bool
IsUint bool
IsFloat bool
IsComplex bool
Int64 int64
Uint64 uint64
Float64 float64
Complex128 complex128
Text string</code></pre>
         </article>
         
         <article class="struct" data-name="StringNode">
            <h2>type StringNode struct</h2>
            <hr />
            
            <p>StringNode holds a string constant. The value has been "unquoted".</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Quoted string
Text string</code></pre>
         </article>
         
         <article class="struct" data-name="endNode">
            <h2>type endNode struct</h2>
            <hr />
            
            <p>endNode represents an {{end}} action.
It does not appear in the final parse tree.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree</code></pre>
         </article>
         
         <article class="struct" data-name="elseNode">
            <h2>type elseNode struct</h2>
            <hr />
            
            <p>elseNode represents an {{else}} action. Does not appear in the final tree.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Line int</code></pre>
         </article>
         
         <article class="struct" data-name="BranchNode">
            <h2>type BranchNode struct</h2>
            <hr />
            
            <p>BranchNode is the common representation of if, range, and with.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Line int
Pipe *PipeNode
List *ListNode
ElseList *ListNode</code></pre>
         </article>
         
         <article class="struct" data-name="IfNode">
            <h2>type IfNode struct</h2>
            <hr />
            
            <p>IfNode represents an {{if}} action and its commands.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">BranchNode</code></pre>
         </article>
         
         <article class="struct" data-name="BreakNode">
            <h2>type BreakNode struct</h2>
            <hr />
            
            <p>BreakNode represents a {{break}} action.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">tr *Tree
NodeType
Pos
Line int</code></pre>
         </article>
         
         <article class="struct" data-name="ContinueNode">
            <h2>type ContinueNode struct</h2>
            <hr />
            
            <p>ContinueNode represents a {{continue}} action.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">tr *Tree
NodeType
Pos
Line int</code></pre>
         </article>
         
         <article class="struct" data-name="RangeNode">
            <h2>type RangeNode struct</h2>
            <hr />
            
            <p>RangeNode represents a {{range}} action and its commands.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">BranchNode</code></pre>
         </article>
         
         <article class="struct" data-name="WithNode">
            <h2>type WithNode struct</h2>
            <hr />
            
            <p>WithNode represents a {{with}} action and its commands.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">BranchNode</code></pre>
         </article>
         
         <article class="struct" data-name="TemplateNode">
            <h2>type TemplateNode struct</h2>
            <hr />
            
            <p>TemplateNode represents a {{template}} action.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">NodeType
Pos
tr *Tree
Line int
Name string
Pipe *PipeNode</code></pre>
         </article>
         
         <article class="struct" data-name="Tree">
            <h2>type Tree struct</h2>
            <hr />
            
            <p>Tree is the representation of a single parsed template.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name string
ParseName string
Root *ListNode
Mode Mode
text string
funcs []*ast.MapType
lex *lexer
token []item
peekCount int
vars []string
treeSet *ast.MapType
actionLine int
rangeDepth int</code></pre>
         </article>
         
         <article class="struct" data-name="numberTest">
            <h2>type numberTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">text string
isInt bool
isUint bool
isFloat bool
isComplex bool
int64
uint64
float64
complex128</code></pre>
         </article>
         
         <article class="struct" data-name="parseTest">
            <h2>type parseTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
input string
ok bool
result string</code></pre>
         </article>
         
         <article class="struct" data-name="isEmptyTest">
            <h2>type isEmptyTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
input string
empty bool</code></pre>
         </article>
         
         <article class="struct" data-name="item">
            <h2>type item struct</h2>
            <hr />
            
            <p>item represents a token or text string returned from the scanner.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">typ itemType
pos Pos
val string
line int</code></pre>
         </article>
         
         <article class="struct" data-name="lexer">
            <h2>type lexer struct</h2>
            <hr />
            
            <p>lexer holds the state of the scanner.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
input string
leftDelim string
rightDelim string
pos Pos
start Pos
atEOF bool
parenDepth int
line int
startLine int
item item
insideAction bool
options lexOptions</code></pre>
         </article>
         
         <article class="struct" data-name="lexOptions">
            <h2>type lexOptions struct</h2>
            <hr />
            
            <p>lexOptions control behavior of the lexer. All default to false.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">emitComment bool
breakOK bool
continueOK bool</code></pre>
         </article>
         
         <article class="struct" data-name="lexTest">
            <h2>type lexTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
input string
items []item</code></pre>
         </article>
          
         <article class="function" data-name="Position">
            <h2>Position</h2>
            <hr />
            
            <pre><code>func Position() Pos</code></pre>
         </article>
         
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <p>Type returns itself and provides an easy default implementation
for embedding in a Node. Embedded in all non-trivial Nodes.</p>
            
            <pre><code>func Type() NodeType</code></pre>
         </article>
         
         <article class="function" data-name="newList">
            <h2>newList</h2>
            <hr />
            
            <pre><code>func newList(pos Pos) *ListNode</code></pre>
         </article>
         
         <article class="function" data-name="append">
            <h2>append</h2>
            <hr />
            
            <pre><code>func append(n Node)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="CopyList">
            <h2>CopyList</h2>
            <hr />
            
            <pre><code>func CopyList() *ListNode</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newText">
            <h2>newText</h2>
            <hr />
            
            <pre><code>func newText(pos Pos, text string) *TextNode</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newComment">
            <h2>newComment</h2>
            <hr />
            
            <pre><code>func newComment(pos Pos, text string) *CommentNode</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newPipeline">
            <h2>newPipeline</h2>
            <hr />
            
            <pre><code>func newPipeline(pos Pos, line int, vars []*VariableNode) *PipeNode</code></pre>
         </article>
         
         <article class="function" data-name="append">
            <h2>append</h2>
            <hr />
            
            <pre><code>func append(command *CommandNode)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="CopyPipe">
            <h2>CopyPipe</h2>
            <hr />
            
            <pre><code>func CopyPipe() *PipeNode</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newAction">
            <h2>newAction</h2>
            <hr />
            
            <pre><code>func newAction(pos Pos, line int, pipe *PipeNode) *ActionNode</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newCommand">
            <h2>newCommand</h2>
            <hr />
            
            <pre><code>func newCommand(pos Pos) *CommandNode</code></pre>
         </article>
         
         <article class="function" data-name="append">
            <h2>append</h2>
            <hr />
            
            <pre><code>func append(arg Node)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="NewIdentifier">
            <h2>NewIdentifier</h2>
            <hr />
            
            <p>NewIdentifier returns a new [IdentifierNode] with the given identifier name.</p>
            
            <pre><code>func NewIdentifier(ident string) *IdentifierNode</code></pre>
         </article>
         
         <article class="function" data-name="SetPos">
            <h2>SetPos</h2>
            <hr />
            
            <p>SetPos sets the position. [NewIdentifier] is a public method so we can't modify its signature.
Chained for convenience.
TODO: fix one day?</p>
            
            <pre><code>func SetPos(pos Pos) *IdentifierNode</code></pre>
         </article>
         
         <article class="function" data-name="SetTree">
            <h2>SetTree</h2>
            <hr />
            
            <p>SetTree sets the parent tree for the node. [NewIdentifier] is a public method so we can't modify its signature.
Chained for convenience.
TODO: fix one day?</p>
            
            <pre><code>func SetTree(t *Tree) *IdentifierNode</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newVariable">
            <h2>newVariable</h2>
            <hr />
            
            <pre><code>func newVariable(pos Pos, ident string) *VariableNode</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newDot">
            <h2>newDot</h2>
            <hr />
            
            <pre><code>func newDot(pos Pos) *DotNode</code></pre>
         </article>
         
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <pre><code>func Type() NodeType</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newNil">
            <h2>newNil</h2>
            <hr />
            
            <pre><code>func newNil(pos Pos) *NilNode</code></pre>
         </article>
         
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <pre><code>func Type() NodeType</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newField">
            <h2>newField</h2>
            <hr />
            
            <pre><code>func newField(pos Pos, ident string) *FieldNode</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newChain">
            <h2>newChain</h2>
            <hr />
            
            <pre><code>func newChain(pos Pos, node Node) *ChainNode</code></pre>
         </article>
         
         <article class="function" data-name="Add">
            <h2>Add</h2>
            <hr />
            
            <p>Add adds the named field (which should start with a period) to the end of the chain.</p>
            
            <pre><code>func Add(field string)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newBool">
            <h2>newBool</h2>
            <hr />
            
            <pre><code>func newBool(pos Pos, true bool) *BoolNode</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newNumber">
            <h2>newNumber</h2>
            <hr />
            
            <pre><code>func newNumber(pos Pos, text string, typ itemType) (*NumberNode, error)</code></pre>
         </article>
         
         <article class="function" data-name="simplifyComplex">
            <h2>simplifyComplex</h2>
            <hr />
            
            <p>simplifyComplex pulls out any other types that are represented by the complex number.
These all require that the imaginary part be zero.</p>
            
            <pre><code>func simplifyComplex()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newString">
            <h2>newString</h2>
            <hr />
            
            <pre><code>func newString(pos Pos, orig string, text string) *StringNode</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newEnd">
            <h2>newEnd</h2>
            <hr />
            
            <pre><code>func newEnd(pos Pos) *endNode</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newElse">
            <h2>newElse</h2>
            <hr />
            
            <pre><code>func newElse(pos Pos, line int) *elseNode</code></pre>
         </article>
         
         <article class="function" data-name="Type">
            <h2>Type</h2>
            <hr />
            
            <pre><code>func Type() NodeType</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newIf">
            <h2>newIf</h2>
            <hr />
            
            <pre><code>func newIf(pos Pos, line int, pipe *PipeNode, list *ListNode, elseList *ListNode) *IfNode</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newBreak">
            <h2>newBreak</h2>
            <hr />
            
            <pre><code>func newBreak(pos Pos, line int) *BreakNode</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="newContinue">
            <h2>newContinue</h2>
            <hr />
            
            <pre><code>func newContinue(pos Pos, line int) *ContinueNode</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="newRange">
            <h2>newRange</h2>
            <hr />
            
            <pre><code>func newRange(pos Pos, line int, pipe *PipeNode, list *ListNode, elseList *ListNode) *RangeNode</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newWith">
            <h2>newWith</h2>
            <hr />
            
            <pre><code>func newWith(pos Pos, line int, pipe *PipeNode, list *ListNode, elseList *ListNode) *WithNode</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="newTemplate">
            <h2>newTemplate</h2>
            <hr />
            
            <pre><code>func newTemplate(pos Pos, line int, name string, pipe *PipeNode) *TemplateNode</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="writeTo">
            <h2>writeTo</h2>
            <hr />
            
            <pre><code>func writeTo(sb *strings.Builder)</code></pre>
         </article>
         
         <article class="function" data-name="tree">
            <h2>tree</h2>
            <hr />
            
            <pre><code>func tree() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <pre><code>func Copy() Node</code></pre>
         </article>
         
         <article class="function" data-name="Copy">
            <h2>Copy</h2>
            <hr />
            
            <p>Copy returns a copy of the [Tree]. Any parsing state is discarded.</p>
            
            <pre><code>func Copy() *Tree</code></pre>
         </article>
         
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <p>Parse returns a map from template name to [Tree], created by parsing the
templates described in the argument string. The top-level template will be
given the specified name. If an error is encountered, parsing stops and an
empty map is returned with the error.</p>
            
            <pre><code>func Parse(name string, text string, leftDelim string, rightDelim string, funcs ...*ast.MapType) (*ast.MapType, error)</code></pre>
         </article>
         
         <article class="function" data-name="next">
            <h2>next</h2>
            <hr />
            
            <p>next returns the next token.</p>
            
            <pre><code>func next() item</code></pre>
         </article>
         
         <article class="function" data-name="backup">
            <h2>backup</h2>
            <hr />
            
            <p>backup backs the input stream up one token.</p>
            
            <pre><code>func backup()</code></pre>
         </article>
         
         <article class="function" data-name="backup2">
            <h2>backup2</h2>
            <hr />
            
            <p>backup2 backs the input stream up two tokens.
The zeroth token is already there.</p>
            
            <pre><code>func backup2(t1 item)</code></pre>
         </article>
         
         <article class="function" data-name="backup3">
            <h2>backup3</h2>
            <hr />
            
            <p>backup3 backs the input stream up three tokens
The zeroth token is already there.</p>
            
            <pre><code>func backup3(t2 item, t1 item)</code></pre>
         </article>
         
         <article class="function" data-name="peek">
            <h2>peek</h2>
            <hr />
            
            <p>peek returns but does not consume the next token.</p>
            
            <pre><code>func peek() item</code></pre>
         </article>
         
         <article class="function" data-name="nextNonSpace">
            <h2>nextNonSpace</h2>
            <hr />
            
            <p>nextNonSpace returns the next non-space token.</p>
            
            <pre><code>func nextNonSpace() token item</code></pre>
         </article>
         
         <article class="function" data-name="peekNonSpace">
            <h2>peekNonSpace</h2>
            <hr />
            
            <p>peekNonSpace returns but does not consume the next non-space token.</p>
            
            <pre><code>func peekNonSpace() item</code></pre>
         </article>
         
         <article class="function" data-name="New">
            <h2>New</h2>
            <hr />
            
            <p>New allocates a new parse tree with the given name.</p>
            
            <pre><code>func New(name string, funcs ...*ast.MapType) *Tree</code></pre>
         </article>
         
         <article class="function" data-name="ErrorContext">
            <h2>ErrorContext</h2>
            <hr />
            
            <p>ErrorContext returns a textual representation of the location of the node in the input text.
The receiver is only used when the node does not have a pointer to the tree inside,
which can occur in old code.</p>
            
            <pre><code>func ErrorContext(n Node) (location string, context string)</code></pre>
         </article>
         
         <article class="function" data-name="errorf">
            <h2>errorf</h2>
            <hr />
            
            <p>errorf formats the error and terminates processing.</p>
            
            <pre><code>func errorf(format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="error">
            <h2>error</h2>
            <hr />
            
            <p>error terminates processing.</p>
            
            <pre><code>func error(err error)</code></pre>
         </article>
         
         <article class="function" data-name="expect">
            <h2>expect</h2>
            <hr />
            
            <p>expect consumes the next token and guarantees it has the required type.</p>
            
            <pre><code>func expect(expected itemType, context string) item</code></pre>
         </article>
         
         <article class="function" data-name="expectOneOf">
            <h2>expectOneOf</h2>
            <hr />
            
            <p>expectOneOf consumes the next token and guarantees it has one of the required types.</p>
            
            <pre><code>func expectOneOf(expected1 itemType, expected2 itemType, context string) item</code></pre>
         </article>
         
         <article class="function" data-name="unexpected">
            <h2>unexpected</h2>
            <hr />
            
            <p>unexpected complains about the token and terminates processing.</p>
            
            <pre><code>func unexpected(token item, context string)</code></pre>
         </article>
         
         <article class="function" data-name="recover">
            <h2>recover</h2>
            <hr />
            
            <p>recover is the handler that turns panics into returns from the top level of Parse.</p>
            
            <pre><code>func recover(errp *error)</code></pre>
         </article>
         
         <article class="function" data-name="startParse">
            <h2>startParse</h2>
            <hr />
            
            <p>startParse initializes the parser, using the lexer.</p>
            
            <pre><code>func startParse(funcs []*ast.MapType, lex *lexer, treeSet *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="stopParse">
            <h2>stopParse</h2>
            <hr />
            
            <p>stopParse terminates parsing.</p>
            
            <pre><code>func stopParse()</code></pre>
         </article>
         
         <article class="function" data-name="Parse">
            <h2>Parse</h2>
            <hr />
            
            <p>Parse parses the template definition string to construct a representation of
the template for execution. If either action delimiter string is empty, the
default ("{{" or "}}") is used. Embedded template definitions are added to
the treeSet map.</p>
            
            <pre><code>func Parse(text string, leftDelim string, rightDelim string, treeSet *ast.MapType, funcs ...*ast.MapType) (tree *Tree, err error)</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <p>add adds tree to t.treeSet.</p>
            
            <pre><code>func add()</code></pre>
         </article>
         
         <article class="function" data-name="IsEmptyTree">
            <h2>IsEmptyTree</h2>
            <hr />
            
            <p>IsEmptyTree reports whether this tree (node) is empty of everything but space or comments.</p>
            
            <pre><code>func IsEmptyTree(n Node) bool</code></pre>
         </article>
         
         <article class="function" data-name="parse">
            <h2>parse</h2>
            <hr />
            
            <p>parse is the top-level parser for a template, essentially the same
as itemList except it also parses {{define}} actions.
It runs to EOF.</p>
            
            <pre><code>func parse()</code></pre>
         </article>
         
         <article class="function" data-name="parseDefinition">
            <h2>parseDefinition</h2>
            <hr />
            
            <p>parseDefinition parses a {{define}} ...  {{end}} template definition and
installs the definition in t.treeSet. The "define" keyword has already
been scanned.</p>
            
            <pre><code>func parseDefinition()</code></pre>
         </article>
         
         <article class="function" data-name="itemList">
            <h2>itemList</h2>
            <hr />
            
            <p>itemList:

	textOrAction*

Terminates at {{end}} or {{else}}, returned separately.</p>
            
            <pre><code>func itemList() (list *ListNode, next Node)</code></pre>
         </article>
         
         <article class="function" data-name="textOrAction">
            <h2>textOrAction</h2>
            <hr />
            
            <p>textOrAction:

	text | comment | action</p>
            
            <pre><code>func textOrAction() Node</code></pre>
         </article>
         
         <article class="function" data-name="clearActionLine">
            <h2>clearActionLine</h2>
            <hr />
            
            <pre><code>func clearActionLine()</code></pre>
         </article>
         
         <article class="function" data-name="action">
            <h2>action</h2>
            <hr />
            
            <p>Action:

	control
	command ("|" command)*

Left delim is past. Now get actions.
First word could be a keyword such as range.</p>
            
            <pre><code>func action() n Node</code></pre>
         </article>
         
         <article class="function" data-name="breakControl">
            <h2>breakControl</h2>
            <hr />
            
            <p>Break:

	{{break}}

Break keyword is past.</p>
            
            <pre><code>func breakControl(pos Pos, line int) Node</code></pre>
         </article>
         
         <article class="function" data-name="continueControl">
            <h2>continueControl</h2>
            <hr />
            
            <p>Continue:

	{{continue}}

Continue keyword is past.</p>
            
            <pre><code>func continueControl(pos Pos, line int) Node</code></pre>
         </article>
         
         <article class="function" data-name="pipeline">
            <h2>pipeline</h2>
            <hr />
            
            <p>Pipeline:

	declarations? command ('|' command)*</p>
            
            <pre><code>func pipeline(context string, end itemType) pipe *PipeNode</code></pre>
         </article>
         
         <article class="function" data-name="checkPipeline">
            <h2>checkPipeline</h2>
            <hr />
            
            <pre><code>func checkPipeline(pipe *PipeNode, context string)</code></pre>
         </article>
         
         <article class="function" data-name="parseControl">
            <h2>parseControl</h2>
            <hr />
            
            <pre><code>func parseControl(context string) (pos Pos, line int, pipe *PipeNode, list *ListNode, elseList *ListNode)</code></pre>
         </article>
         
         <article class="function" data-name="ifControl">
            <h2>ifControl</h2>
            <hr />
            
            <p>If:

	{{if pipeline}} itemList {{end}}
	{{if pipeline}} itemList {{else}} itemList {{end}}

If keyword is past.</p>
            
            <pre><code>func ifControl() Node</code></pre>
         </article>
         
         <article class="function" data-name="rangeControl">
            <h2>rangeControl</h2>
            <hr />
            
            <p>Range:

	{{range pipeline}} itemList {{end}}
	{{range pipeline}} itemList {{else}} itemList {{end}}

Range keyword is past.</p>
            
            <pre><code>func rangeControl() Node</code></pre>
         </article>
         
         <article class="function" data-name="withControl">
            <h2>withControl</h2>
            <hr />
            
            <p>With:

	{{with pipeline}} itemList {{end}}
	{{with pipeline}} itemList {{else}} itemList {{end}}

If keyword is past.</p>
            
            <pre><code>func withControl() Node</code></pre>
         </article>
         
         <article class="function" data-name="endControl">
            <h2>endControl</h2>
            <hr />
            
            <p>End:

	{{end}}

End keyword is past.</p>
            
            <pre><code>func endControl() Node</code></pre>
         </article>
         
         <article class="function" data-name="elseControl">
            <h2>elseControl</h2>
            <hr />
            
            <p>Else:

	{{else}}

Else keyword is past.</p>
            
            <pre><code>func elseControl() Node</code></pre>
         </article>
         
         <article class="function" data-name="blockControl">
            <h2>blockControl</h2>
            <hr />
            
            <p>Block:

	{{block stringValue pipeline}}

Block keyword is past.
The name must be something that can evaluate to a string.
The pipeline is mandatory.</p>
            
            <pre><code>func blockControl() Node</code></pre>
         </article>
         
         <article class="function" data-name="templateControl">
            <h2>templateControl</h2>
            <hr />
            
            <p>Template:

	{{template stringValue pipeline}}

Template keyword is past. The name must be something that can evaluate
to a string.</p>
            
            <pre><code>func templateControl() Node</code></pre>
         </article>
         
         <article class="function" data-name="parseTemplateName">
            <h2>parseTemplateName</h2>
            <hr />
            
            <pre><code>func parseTemplateName(token item, context string) name string</code></pre>
         </article>
         
         <article class="function" data-name="command">
            <h2>command</h2>
            <hr />
            
            <p>command:

	operand (space operand)*

space-separated arguments up to a pipeline character or right delimiter.
we consume the pipe character but leave the right delim to terminate the action.</p>
            
            <pre><code>func command() *CommandNode</code></pre>
         </article>
         
         <article class="function" data-name="operand">
            <h2>operand</h2>
            <hr />
            
            <p>operand:

	term .Field*

An operand is a space-separated component of a command,
a term possibly followed by field accesses.
A nil return means the next item is not an operand.</p>
            
            <pre><code>func operand() Node</code></pre>
         </article>
         
         <article class="function" data-name="term">
            <h2>term</h2>
            <hr />
            
            <p>term:

	literal (number, string, nil, boolean)
	function (identifier)
	.
	.Field
	$
	'(' pipeline ')'

A term is a simple "expression".
A nil return means the next item is not a term.</p>
            
            <pre><code>func term() Node</code></pre>
         </article>
         
         <article class="function" data-name="hasFunction">
            <h2>hasFunction</h2>
            <hr />
            
            <p>hasFunction reports if a function name exists in the Tree's maps.</p>
            
            <pre><code>func hasFunction(name string) bool</code></pre>
         </article>
         
         <article class="function" data-name="popVars">
            <h2>popVars</h2>
            <hr />
            
            <p>popVars trims the variable list to the specified length</p>
            
            <pre><code>func popVars(n int)</code></pre>
         </article>
         
         <article class="function" data-name="useVar">
            <h2>useVar</h2>
            <hr />
            
            <p>useVar returns a node for a variable reference. It errors if the
variable is not defined.</p>
            
            <pre><code>func useVar(pos Pos, name string) Node</code></pre>
         </article>
         
         <article class="function" data-name="TestNumberParse">
            <h2>TestNumberParse</h2>
            <hr />
            
            <pre><code>func TestNumberParse(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="testParse">
            <h2>testParse</h2>
            <hr />
            
            <pre><code>func testParse(doCopy bool, t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParse">
            <h2>TestParse</h2>
            <hr />
            
            <pre><code>func TestParse(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseCopy">
            <h2>TestParseCopy</h2>
            <hr />
            
            <p>Same as TestParse, but we copy the node first</p>
            
            <pre><code>func TestParseCopy(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestParseWithComments">
            <h2>TestParseWithComments</h2>
            <hr />
            
            <pre><code>func TestParseWithComments(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestKeywordsAndFuncs">
            <h2>TestKeywordsAndFuncs</h2>
            <hr />
            
            <pre><code>func TestKeywordsAndFuncs(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestSkipFuncCheck">
            <h2>TestSkipFuncCheck</h2>
            <hr />
            
            <pre><code>func TestSkipFuncCheck(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIsEmpty">
            <h2>TestIsEmpty</h2>
            <hr />
            
            <pre><code>func TestIsEmpty(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestErrorContextWithTreeCopy">
            <h2>TestErrorContextWithTreeCopy</h2>
            <hr />
            
            <pre><code>func TestErrorContextWithTreeCopy(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestErrors">
            <h2>TestErrors</h2>
            <hr />
            
            <pre><code>func TestErrors(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBlock">
            <h2>TestBlock</h2>
            <hr />
            
            <pre><code>func TestBlock(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLineNum">
            <h2>TestLineNum</h2>
            <hr />
            
            <pre><code>func TestLineNum(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkParseLarge">
            <h2>BenchmarkParseLarge</h2>
            <hr />
            
            <pre><code>func BenchmarkParseLarge(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkVariableString">
            <h2>BenchmarkVariableString</h2>
            <hr />
            
            <pre><code>func BenchmarkVariableString(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkListString">
            <h2>BenchmarkListString</h2>
            <hr />
            
            <pre><code>func BenchmarkListString(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="next">
            <h2>next</h2>
            <hr />
            
            <p>next returns the next rune in the input.</p>
            
            <pre><code>func next() rune</code></pre>
         </article>
         
         <article class="function" data-name="peek">
            <h2>peek</h2>
            <hr />
            
            <p>peek returns but does not consume the next rune in the input.</p>
            
            <pre><code>func peek() rune</code></pre>
         </article>
         
         <article class="function" data-name="backup">
            <h2>backup</h2>
            <hr />
            
            <p>backup steps back one rune.</p>
            
            <pre><code>func backup()</code></pre>
         </article>
         
         <article class="function" data-name="thisItem">
            <h2>thisItem</h2>
            <hr />
            
            <p>thisItem returns the item at the current input point with the specified type
and advances the input.</p>
            
            <pre><code>func thisItem(t itemType) item</code></pre>
         </article>
         
         <article class="function" data-name="emit">
            <h2>emit</h2>
            <hr />
            
            <p>emit passes the trailing text as an item back to the parser.</p>
            
            <pre><code>func emit(t itemType) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="emitItem">
            <h2>emitItem</h2>
            <hr />
            
            <p>emitItem passes the specified item to the parser.</p>
            
            <pre><code>func emitItem(i item) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="ignore">
            <h2>ignore</h2>
            <hr />
            
            <p>ignore skips over the pending input before this point.
It tracks newlines in the ignored text, so use it only
for text that is skipped without calling l.next.</p>
            
            <pre><code>func ignore()</code></pre>
         </article>
         
         <article class="function" data-name="accept">
            <h2>accept</h2>
            <hr />
            
            <p>accept consumes the next rune if it's from the valid set.</p>
            
            <pre><code>func accept(valid string) bool</code></pre>
         </article>
         
         <article class="function" data-name="acceptRun">
            <h2>acceptRun</h2>
            <hr />
            
            <p>acceptRun consumes a run of runes from the valid set.</p>
            
            <pre><code>func acceptRun(valid string)</code></pre>
         </article>
         
         <article class="function" data-name="errorf">
            <h2>errorf</h2>
            <hr />
            
            <p>errorf returns an error token and terminates the scan by passing
back a nil pointer that will be the next state, terminating l.nextItem.</p>
            
            <pre><code>func errorf(format string, args ...any) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="nextItem">
            <h2>nextItem</h2>
            <hr />
            
            <p>nextItem returns the next item from the input.
Called by the parser, not in the lexing goroutine.</p>
            
            <pre><code>func nextItem() item</code></pre>
         </article>
         
         <article class="function" data-name="lex">
            <h2>lex</h2>
            <hr />
            
            <p>lex creates a new scanner for the input string.</p>
            
            <pre><code>func lex(name string, input string, left string, right string) *lexer</code></pre>
         </article>
         
         <article class="function" data-name="lexText">
            <h2>lexText</h2>
            <hr />
            
            <p>lexText scans until an opening action delimiter, "{{".</p>
            
            <pre><code>func lexText(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="rightTrimLength">
            <h2>rightTrimLength</h2>
            <hr />
            
            <p>rightTrimLength returns the length of the spaces at the end of the string.</p>
            
            <pre><code>func rightTrimLength(s string) Pos</code></pre>
         </article>
         
         <article class="function" data-name="atRightDelim">
            <h2>atRightDelim</h2>
            <hr />
            
            <p>atRightDelim reports whether the lexer is at a right delimiter, possibly preceded by a trim marker.</p>
            
            <pre><code>func atRightDelim() (delim bool, trimSpaces bool)</code></pre>
         </article>
         
         <article class="function" data-name="leftTrimLength">
            <h2>leftTrimLength</h2>
            <hr />
            
            <p>leftTrimLength returns the length of the spaces at the beginning of the string.</p>
            
            <pre><code>func leftTrimLength(s string) Pos</code></pre>
         </article>
         
         <article class="function" data-name="lexLeftDelim">
            <h2>lexLeftDelim</h2>
            <hr />
            
            <p>lexLeftDelim scans the left delimiter, which is known to be present, possibly with a trim marker.
(The text to be trimmed has already been emitted.)</p>
            
            <pre><code>func lexLeftDelim(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="lexComment">
            <h2>lexComment</h2>
            <hr />
            
            <p>lexComment scans a comment. The left comment marker is known to be present.</p>
            
            <pre><code>func lexComment(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="lexRightDelim">
            <h2>lexRightDelim</h2>
            <hr />
            
            <p>lexRightDelim scans the right delimiter, which is known to be present, possibly with a trim marker.</p>
            
            <pre><code>func lexRightDelim(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="lexInsideAction">
            <h2>lexInsideAction</h2>
            <hr />
            
            <p>lexInsideAction scans the elements inside action delimiters.</p>
            
            <pre><code>func lexInsideAction(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="lexSpace">
            <h2>lexSpace</h2>
            <hr />
            
            <p>lexSpace scans a run of space characters.
We have not consumed the first space, which is known to be present.
Take care if there is a trim-marked right delimiter, which starts with a space.</p>
            
            <pre><code>func lexSpace(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="lexIdentifier">
            <h2>lexIdentifier</h2>
            <hr />
            
            <p>lexIdentifier scans an alphanumeric.</p>
            
            <pre><code>func lexIdentifier(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="lexField">
            <h2>lexField</h2>
            <hr />
            
            <p>lexField scans a field: .Alphanumeric.
The . has been scanned.</p>
            
            <pre><code>func lexField(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="lexVariable">
            <h2>lexVariable</h2>
            <hr />
            
            <p>lexVariable scans a Variable: $Alphanumeric.
The $ has been scanned.</p>
            
            <pre><code>func lexVariable(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="lexFieldOrVariable">
            <h2>lexFieldOrVariable</h2>
            <hr />
            
            <p>lexFieldOrVariable scans a field or variable: [.$]Alphanumeric.
The . or $ has been scanned.</p>
            
            <pre><code>func lexFieldOrVariable(l *lexer, typ itemType) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="atTerminator">
            <h2>atTerminator</h2>
            <hr />
            
            <p>atTerminator reports whether the input is at valid termination character to
appear after an identifier. Breaks .X.Y into two pieces. Also catches cases
like "$x+2" not being acceptable without a space, in case we decide one
day to implement arithmetic.</p>
            
            <pre><code>func atTerminator() bool</code></pre>
         </article>
         
         <article class="function" data-name="lexChar">
            <h2>lexChar</h2>
            <hr />
            
            <p>lexChar scans a character constant. The initial quote is already
scanned. Syntax checking is done by the parser.</p>
            
            <pre><code>func lexChar(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="lexNumber">
            <h2>lexNumber</h2>
            <hr />
            
            <p>lexNumber scans a number: decimal, octal, hex, float, or imaginary. This
isn't a perfect number scanner - for instance it accepts "." and "0x0.2"
and "089" - but when it's wrong the input is invalid and the parser (via
strconv) will notice.</p>
            
            <pre><code>func lexNumber(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="scanNumber">
            <h2>scanNumber</h2>
            <hr />
            
            <pre><code>func scanNumber() bool</code></pre>
         </article>
         
         <article class="function" data-name="lexQuote">
            <h2>lexQuote</h2>
            <hr />
            
            <p>lexQuote scans a quoted string.</p>
            
            <pre><code>func lexQuote(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="lexRawQuote">
            <h2>lexRawQuote</h2>
            <hr />
            
            <p>lexRawQuote scans a raw quoted string.</p>
            
            <pre><code>func lexRawQuote(l *lexer) stateFn</code></pre>
         </article>
         
         <article class="function" data-name="isSpace">
            <h2>isSpace</h2>
            <hr />
            
            <p>isSpace reports whether r is a space character.</p>
            
            <pre><code>func isSpace(r rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="isAlphaNumeric">
            <h2>isAlphaNumeric</h2>
            <hr />
            
            <p>isAlphaNumeric reports whether r is an alphabetic, digit, or underscore.</p>
            
            <pre><code>func isAlphaNumeric(r rune) bool</code></pre>
         </article>
         
         <article class="function" data-name="hasLeftTrimMarker">
            <h2>hasLeftTrimMarker</h2>
            <hr />
            
            <pre><code>func hasLeftTrimMarker(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="hasRightTrimMarker">
            <h2>hasRightTrimMarker</h2>
            <hr />
            
            <pre><code>func hasRightTrimMarker(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="mkItem">
            <h2>mkItem</h2>
            <hr />
            
            <pre><code>func mkItem(typ itemType, text string) item</code></pre>
         </article>
         
         <article class="function" data-name="collect">
            <h2>collect</h2>
            <hr />
            
            <p>collect gathers the emitted items into a slice.</p>
            
            <pre><code>func collect(t *lexTest, left string, right string) items []item</code></pre>
         </article>
         
         <article class="function" data-name="equal">
            <h2>equal</h2>
            <hr />
            
            <pre><code>func equal(i1 []item, i2 []item, checkPos bool) bool</code></pre>
         </article>
         
         <article class="function" data-name="TestLex">
            <h2>TestLex</h2>
            <hr />
            
            <pre><code>func TestLex(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDelims">
            <h2>TestDelims</h2>
            <hr />
            
            <pre><code>func TestDelims(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDelimsAlphaNumeric">
            <h2>TestDelimsAlphaNumeric</h2>
            <hr />
            
            <pre><code>func TestDelimsAlphaNumeric(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestDelimsAndMarkers">
            <h2>TestDelimsAndMarkers</h2>
            <hr />
            
            <pre><code>func TestDelimsAndMarkers(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPos">
            <h2>TestPos</h2>
            <hr />
            
            <p>The other tests don't check position, to make the test cases easier to construct.
This one does.</p>
            
            <pre><code>func TestPos(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="parseLexer">
            <h2>parseLexer</h2>
            <hr />
            
            <p>parseLexer is a local version of parse that lets us pass in the lexer instead of building it.
We expect an error, so the tree set and funcs list are explicitly nil.</p>
            
            <pre><code>func parseLexer(lex *lexer) (tree *Tree, err error)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
