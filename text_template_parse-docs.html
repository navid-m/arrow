<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - parse</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>parse</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"fmt"
"strings"
"unicode"
"unicode/utf8"
"fmt"
"strconv"
"strings"
"bytes"
"fmt"
"runtime"
"strconv"
"strings"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="NodeAction">
               <h3>
                  NodeAction 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeAction</code></pre>
            </article>
            
            <article class="global" data-name="NodeBool">
               <h3>
                  NodeBool 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeBool</code></pre>
            </article>
            
            <article class="global" data-name="NodeBreak">
               <h3>
                  NodeBreak 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeBreak</code></pre>
            </article>
            
            <article class="global" data-name="NodeChain">
               <h3>
                  NodeChain 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeChain</code></pre>
            </article>
            
            <article class="global" data-name="NodeCommand">
               <h3>
                  NodeCommand 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeCommand</code></pre>
            </article>
            
            <article class="global" data-name="NodeComment">
               <h3>
                  NodeComment 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeComment</code></pre>
            </article>
            
            <article class="global" data-name="NodeContinue">
               <h3>
                  NodeContinue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeContinue</code></pre>
            </article>
            
            <article class="global" data-name="NodeDot">
               <h3>
                  NodeDot 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeDot</code></pre>
            </article>
            
            <article class="global" data-name="NodeField">
               <h3>
                  NodeField 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeField</code></pre>
            </article>
            
            <article class="global" data-name="NodeIdentifier">
               <h3>
                  NodeIdentifier 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeIdentifier</code></pre>
            </article>
            
            <article class="global" data-name="NodeIf">
               <h3>
                  NodeIf 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeIf</code></pre>
            </article>
            
            <article class="global" data-name="NodeList">
               <h3>
                  NodeList 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeList</code></pre>
            </article>
            
            <article class="global" data-name="NodeNil">
               <h3>
                  NodeNil 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeNil</code></pre>
            </article>
            
            <article class="global" data-name="NodeNumber">
               <h3>
                  NodeNumber 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeNumber</code></pre>
            </article>
            
            <article class="global" data-name="NodePipe">
               <h3>
                  NodePipe 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodePipe</code></pre>
            </article>
            
            <article class="global" data-name="NodeRange">
               <h3>
                  NodeRange 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeRange</code></pre>
            </article>
            
            <article class="global" data-name="NodeString">
               <h3>
                  NodeString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeString</code></pre>
            </article>
            
            <article class="global" data-name="NodeTemplate">
               <h3>
                  NodeTemplate 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeTemplate</code></pre>
            </article>
            
            <article class="global" data-name="NodeText">
               <h3>
                  NodeText 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeText NodeType = iota</code></pre>
            </article>
            
            <article class="global" data-name="NodeVariable">
               <h3>
                  NodeVariable 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeVariable</code></pre>
            </article>
            
            <article class="global" data-name="NodeWith">
               <h3>
                  NodeWith 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const NodeWith</code></pre>
            </article>
            
            <article class="global" data-name="ParseComments">
               <h3>
                  ParseComments 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const ParseComments Mode = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="SkipFuncCheck">
               <h3>
                  SkipFuncCheck 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const SkipFuncCheck</code></pre>
            </article>
            
            <article class="global" data-name="eof">
               <h3>
                  eof 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const eof = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="itemAssign">
               <h3>
                  itemAssign 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemAssign</code></pre>
            </article>
            
            <article class="global" data-name="itemBlock">
               <h3>
                  itemBlock 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemBlock</code></pre>
            </article>
            
            <article class="global" data-name="itemBool">
               <h3>
                  itemBool 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemBool</code></pre>
            </article>
            
            <article class="global" data-name="itemBreak">
               <h3>
                  itemBreak 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemBreak</code></pre>
            </article>
            
            <article class="global" data-name="itemChar">
               <h3>
                  itemChar 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemChar</code></pre>
            </article>
            
            <article class="global" data-name="itemCharConstant">
               <h3>
                  itemCharConstant 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemCharConstant</code></pre>
            </article>
            
            <article class="global" data-name="itemComment">
               <h3>
                  itemComment 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemComment</code></pre>
            </article>
            
            <article class="global" data-name="itemComplex">
               <h3>
                  itemComplex 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemComplex</code></pre>
            </article>
            
            <article class="global" data-name="itemContinue">
               <h3>
                  itemContinue 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemContinue</code></pre>
            </article>
            
            <article class="global" data-name="itemDeclare">
               <h3>
                  itemDeclare 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemDeclare</code></pre>
            </article>
            
            <article class="global" data-name="itemDefine">
               <h3>
                  itemDefine 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemDefine</code></pre>
            </article>
            
            <article class="global" data-name="itemDot">
               <h3>
                  itemDot 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemDot</code></pre>
            </article>
            
            <article class="global" data-name="itemEOF">
               <h3>
                  itemEOF 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemEOF</code></pre>
            </article>
            
            <article class="global" data-name="itemElse">
               <h3>
                  itemElse 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemElse</code></pre>
            </article>
            
            <article class="global" data-name="itemEnd">
               <h3>
                  itemEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemEnd</code></pre>
            </article>
            
            <article class="global" data-name="itemError">
               <h3>
                  itemError 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemError itemType = iota</code></pre>
            </article>
            
            <article class="global" data-name="itemField">
               <h3>
                  itemField 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemField</code></pre>
            </article>
            
            <article class="global" data-name="itemIdentifier">
               <h3>
                  itemIdentifier 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemIdentifier</code></pre>
            </article>
            
            <article class="global" data-name="itemIf">
               <h3>
                  itemIf 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemIf</code></pre>
            </article>
            
            <article class="global" data-name="itemKeyword">
               <h3>
                  itemKeyword 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Keywords appear after all the rest.</p>
               
               <pre><code>const itemKeyword</code></pre>
            </article>
            
            <article class="global" data-name="itemLeftDelim">
               <h3>
                  itemLeftDelim 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemLeftDelim</code></pre>
            </article>
            
            <article class="global" data-name="itemLeftParen">
               <h3>
                  itemLeftParen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemLeftParen</code></pre>
            </article>
            
            <article class="global" data-name="itemNil">
               <h3>
                  itemNil 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemNil</code></pre>
            </article>
            
            <article class="global" data-name="itemNumber">
               <h3>
                  itemNumber 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemNumber</code></pre>
            </article>
            
            <article class="global" data-name="itemPipe">
               <h3>
                  itemPipe 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemPipe</code></pre>
            </article>
            
            <article class="global" data-name="itemRange">
               <h3>
                  itemRange 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemRange</code></pre>
            </article>
            
            <article class="global" data-name="itemRawString">
               <h3>
                  itemRawString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemRawString</code></pre>
            </article>
            
            <article class="global" data-name="itemRightDelim">
               <h3>
                  itemRightDelim 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemRightDelim</code></pre>
            </article>
            
            <article class="global" data-name="itemRightParen">
               <h3>
                  itemRightParen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemRightParen</code></pre>
            </article>
            
            <article class="global" data-name="itemSpace">
               <h3>
                  itemSpace 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemSpace</code></pre>
            </article>
            
            <article class="global" data-name="itemString">
               <h3>
                  itemString 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemString</code></pre>
            </article>
            
            <article class="global" data-name="itemTemplate">
               <h3>
                  itemTemplate 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemTemplate</code></pre>
            </article>
            
            <article class="global" data-name="itemText">
               <h3>
                  itemText 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemText</code></pre>
            </article>
            
            <article class="global" data-name="itemVariable">
               <h3>
                  itemVariable 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemVariable</code></pre>
            </article>
            
            <article class="global" data-name="itemWith">
               <h3>
                  itemWith 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const itemWith</code></pre>
            </article>
            
            <article class="global" data-name="key">
               <h3>
                  key 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var key = map[string]itemType{...}</code></pre>
            </article>
            
            <article class="global" data-name="leftComment">
               <h3>
                  leftComment 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const leftComment = "/*"</code></pre>
            </article>
            
            <article class="global" data-name="leftDelim">
               <h3>
                  leftDelim 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const leftDelim = "{{"</code></pre>
            </article>
            
            <article class="global" data-name="nodeElse">
               <h3>
                  nodeElse 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nodeElse</code></pre>
            </article>
            
            <article class="global" data-name="nodeEnd">
               <h3>
                  nodeEnd 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const nodeEnd</code></pre>
            </article>
            
            <article class="global" data-name="rightComment">
               <h3>
                  rightComment 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const rightComment = "*/"</code></pre>
            </article>
            
            <article class="global" data-name="rightDelim">
               <h3>
                  rightDelim 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const rightDelim = "}}"</code></pre>
            </article>
            
            <article class="global" data-name="spaceChars">
               <h3>
                  spaceChars 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Trimming spaces.
If the action begins "{{- " rather than "{{", then all space/tab/newlines
preceding the action are trimmed; conversely if it ends " -}}" the
leading spaces are trimmed. This is done entirely in the lexer; the
parser never sees it happen. We require an ASCII space (' ', \t, \r, \n)
to be present to avoid ambiguity with things like "{{-3}}". It reads
better with the space present anyway. For simplicity, only ASCII
does the job.</p>
               
               <pre><code>const spaceChars = " \t\r\n"</code></pre>
            </article>
            
            <article class="global" data-name="textFormat">
               <h3>
                  textFormat 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var textFormat = "%s"</code></pre>
            </article>
            
            <article class="global" data-name="trimMarker">
               <h3>
                  trimMarker 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Trimming spaces.
If the action begins "{{- " rather than "{{", then all space/tab/newlines
preceding the action are trimmed; conversely if it ends " -}}" the
leading spaces are trimmed. This is done entirely in the lexer; the
parser never sees it happen. We require an ASCII space (' ', \t, \r, \n)
to be present to avoid ambiguity with things like "{{-3}}". It reads
better with the space present anyway. For simplicity, only ASCII
does the job.</p>
               
               <pre><code>const trimMarker = '-'</code></pre>
            </article>
            
            <article class="global" data-name="trimMarkerLen">
               <h3>
                  trimMarkerLen 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Trimming spaces.
If the action begins "{{- " rather than "{{", then all space/tab/newlines
preceding the action are trimmed; conversely if it ends " -}}" the
leading spaces are trimmed. This is done entirely in the lexer; the
parser never sees it happen. We require an ASCII space (' ', \t, \r, \n)
to be present to avoid ambiguity with things like "{{-3}}". It reads
better with the space present anyway. For simplicity, only ASCII
does the job.</p>
               
               <pre><code>const trimMarkerLen = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Mode">
               <h3>
                  Mode
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>A mode value is a set of flags (or 0). Modes control parser behavior.</p>
               
               <pre><code>type Mode uint</code></pre>
            </article>
            
            <article class="type" data-name="NodeType">
               <h3>
                  NodeType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>NodeType identifies the type of a parse tree node.</p>
               
               <pre><code>type NodeType int</code></pre>
            </article>
            
            <article class="type" data-name="Pos">
               <h3>
                  Pos
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>Pos represents a byte position in the original input text from which
this template was parsed.</p>
               
               <pre><code>type Pos int</code></pre>
            </article>
            
            <article class="type" data-name="itemType">
               <h3>
                  itemType
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>itemType identifies the type of lex items.</p>
               
               <pre><code>type itemType int</code></pre>
            </article>
            
            <article class="type" data-name="stateFn">
               <h3>
                  stateFn
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>stateFn represents the state of the scanner as a function that returns the next state.</p>
               
               <pre><code>type stateFn func(*lexer) stateFn</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="Node">
               <h3>
                  Node
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A Node is an element in the parse tree. The interface is trivial.
The interface contains an unexported method so that only
types local to this package can satisfy it.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Node interface {
Type() NodeType
String() string
Copy() Node
Position() Pos
tree() *Tree
writeTo(*strings.Builder)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="ActionNode">
               <h3>
                  ActionNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>ActionNode holds an action (something bounded by delimiters).
Control actions have their own nodes; ActionNode represents simple
ones such as field evaluations and parenthesized pipelines.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ActionNode struct {
NodeType
Pos
tr *Tree
Line int
Pipe *PipeNode
}</code></pre>
            </article>
            
            <article class="struct" data-name="BoolNode">
               <h3>
                  BoolNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>BoolNode holds a boolean constant.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type BoolNode struct {
NodeType
Pos
tr *Tree
True bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="BranchNode">
               <h3>
                  BranchNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>BranchNode is the common representation of if, range, and with.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type BranchNode struct {
NodeType
Pos
tr *Tree
Line int
Pipe *PipeNode
List *ListNode
ElseList *ListNode
}</code></pre>
            </article>
            
            <article class="struct" data-name="BreakNode">
               <h3>
                  BreakNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>BreakNode represents a {{break}} action.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type BreakNode struct {
tr *Tree
NodeType
Pos
Line int
}</code></pre>
            </article>
            
            <article class="struct" data-name="ChainNode">
               <h3>
                  ChainNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>ChainNode holds a term followed by a chain of field accesses (identifier starting with '.').
The names may be chained ('.x.y').
The periods are dropped from each ident.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ChainNode struct {
NodeType
Pos
tr *Tree
Node Node
Field []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="CommandNode">
               <h3>
                  CommandNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>CommandNode holds a command (a pipeline inside an evaluating action).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CommandNode struct {
NodeType
Pos
tr *Tree
Args []Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="CommentNode">
               <h3>
                  CommentNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>CommentNode holds a comment.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CommentNode struct {
NodeType
Pos
tr *Tree
Text string
}</code></pre>
            </article>
            
            <article class="struct" data-name="ContinueNode">
               <h3>
                  ContinueNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>ContinueNode represents a {{continue}} action.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ContinueNode struct {
tr *Tree
NodeType
Pos
Line int
}</code></pre>
            </article>
            
            <article class="struct" data-name="DotNode">
               <h3>
                  DotNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>DotNode holds the special identifier '.'.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type DotNode struct {
NodeType
Pos
tr *Tree
}</code></pre>
            </article>
            
            <article class="struct" data-name="FieldNode">
               <h3>
                  FieldNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>FieldNode holds a field (identifier starting with '.').
The names may be chained ('.x.y').
The period is dropped from each ident.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FieldNode struct {
NodeType
Pos
tr *Tree
Ident []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="IdentifierNode">
               <h3>
                  IdentifierNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>IdentifierNode holds an identifier.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type IdentifierNode struct {
NodeType
Pos
tr *Tree
Ident string
}</code></pre>
            </article>
            
            <article class="struct" data-name="IfNode">
               <h3>
                  IfNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>IfNode represents an {{if}} action and its commands.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type IfNode struct {
BranchNode
}</code></pre>
            </article>
            
            <article class="struct" data-name="ListNode">
               <h3>
                  ListNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>ListNode holds a sequence of nodes.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ListNode struct {
NodeType
Pos
tr *Tree
Nodes []Node
}</code></pre>
            </article>
            
            <article class="struct" data-name="NilNode">
               <h3>
                  NilNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>NilNode holds the special identifier 'nil' representing an untyped nil constant.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NilNode struct {
NodeType
Pos
tr *Tree
}</code></pre>
            </article>
            
            <article class="struct" data-name="NumberNode">
               <h3>
                  NumberNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>NumberNode holds a number: signed or unsigned integer, float, or complex.
The value is parsed and stored under all the types that can represent the value.
This simulates in a small amount of code the behavior of Go's ideal constants.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NumberNode struct {
NodeType
Pos
tr *Tree
IsInt bool
IsUint bool
IsFloat bool
IsComplex bool
Int64 int64
Uint64 uint64
Float64 float64
Complex128 complex128
Text string
}</code></pre>
            </article>
            
            <article class="struct" data-name="PipeNode">
               <h3>
                  PipeNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>PipeNode holds a pipeline with optional declaration</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PipeNode struct {
NodeType
Pos
tr *Tree
Line int
IsAssign bool
Decl []*VariableNode
Cmds []*CommandNode
}</code></pre>
            </article>
            
            <article class="struct" data-name="RangeNode">
               <h3>
                  RangeNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>RangeNode represents a {{range}} action and its commands.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type RangeNode struct {
BranchNode
}</code></pre>
            </article>
            
            <article class="struct" data-name="StringNode">
               <h3>
                  StringNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>StringNode holds a string constant. The value has been "unquoted".</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StringNode struct {
NodeType
Pos
tr *Tree
Quoted string
Text string
}</code></pre>
            </article>
            
            <article class="struct" data-name="TemplateNode">
               <h3>
                  TemplateNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>TemplateNode represents a {{template}} action.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TemplateNode struct {
NodeType
Pos
tr *Tree
Line int
Name string
Pipe *PipeNode
}</code></pre>
            </article>
            
            <article class="struct" data-name="TextNode">
               <h3>
                  TextNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>TextNode holds plain text.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type TextNode struct {
NodeType
Pos
tr *Tree
Text []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="Tree">
               <h3>
                  Tree
                  <span class="badge">struct</span>
               </h3>
               
               <p>Tree is the representation of a single parsed template.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Tree struct {
Name string
ParseName string
Root *ListNode
Mode Mode
text string
funcs []map[string]any
lex *lexer
token [3]item
peekCount int
vars []string
treeSet map[string]*Tree
actionLine int
rangeDepth int
}</code></pre>
            </article>
            
            <article class="struct" data-name="VariableNode">
               <h3>
                  VariableNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>VariableNode holds a list of variable names, possibly with chained field
accesses. The dollar sign is part of the (first) name.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type VariableNode struct {
NodeType
Pos
tr *Tree
Ident []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="WithNode">
               <h3>
                  WithNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>WithNode represents a {{with}} action and its commands.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type WithNode struct {
BranchNode
}</code></pre>
            </article>
            
            <article class="struct" data-name="elseNode">
               <h3>
                  elseNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>elseNode represents an {{else}} action. Does not appear in the final tree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type elseNode struct {
NodeType
Pos
tr *Tree
Line int
}</code></pre>
            </article>
            
            <article class="struct" data-name="endNode">
               <h3>
                  endNode
                  <span class="badge">struct</span>
               </h3>
               
               <p>endNode represents an {{end}} action.
It does not appear in the final parse tree.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type endNode struct {
NodeType
Pos
tr *Tree
}</code></pre>
            </article>
            
            <article class="struct" data-name="item">
               <h3>
                  item
                  <span class="badge">struct</span>
               </h3>
               
               <p>item represents a token or text string returned from the scanner.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type item struct {
typ itemType
pos Pos
val string
line int
}</code></pre>
            </article>
            
            <article class="struct" data-name="lexOptions">
               <h3>
                  lexOptions
                  <span class="badge">struct</span>
               </h3>
               
               <p>lexOptions control behavior of the lexer. All default to false.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type lexOptions struct {
emitComment bool
breakOK bool
continueOK bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="lexer">
               <h3>
                  lexer
                  <span class="badge">struct</span>
               </h3>
               
               <p>lexer holds the state of the scanner.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type lexer struct {
name string
input string
leftDelim string
rightDelim string
pos Pos
start Pos
atEOF bool
parenDepth int
line int
startLine int
item item
insideAction bool
options lexOptions
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Add">
               <h3>
                  Add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Add adds the named field (which should start with a period) to the end of the chain.</p>
               
               <pre><code>func (c *ChainNode) Add(field string)</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w *WithNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Copy returns a copy of the [Tree]. Any parsing state is discarded.</p>
               
               <pre><code>func (t *Tree) Copy() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *VariableNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NilNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *FieldNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i *IdentifierNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *BreakNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ChainNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *CommandNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *BoolNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *ActionNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NumberNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *StringNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *PipeNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *endNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *CommentNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *elseNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *TextNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *BranchNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i *IfNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *ListNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *DotNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ContinueNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r *RangeNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="Copy">
               <h3>
                  Copy 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *TemplateNode) Copy() Node</code></pre>
            </article>
            
            <article class="function" data-name="CopyList">
               <h3>
                  CopyList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *ListNode) CopyList() *ListNode</code></pre>
            </article>
            
            <article class="function" data-name="CopyPipe">
               <h3>
                  CopyPipe 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *PipeNode) CopyPipe() *PipeNode</code></pre>
            </article>
            
            <article class="function" data-name="ErrorContext">
               <h3>
                  ErrorContext 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ErrorContext returns a textual representation of the location of the node in the input text.
The receiver is only used when the node does not have a pointer to the tree inside,
which can occur in old code.</p>
               
               <pre><code>func (t *Tree) ErrorContext(n Node) (location string, context string)</code></pre>
            </article>
            
            <article class="function" data-name="IsEmptyTree">
               <h3>
                  IsEmptyTree 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>IsEmptyTree reports whether this tree (node) is empty of everything but space or comments.</p>
               
               <pre><code>func IsEmptyTree(n Node) bool</code></pre>
            </article>
            
            <article class="function" data-name="New">
               <h3>
                  New 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>New allocates a new parse tree with the given name.</p>
               
               <pre><code>func New(name string, funcs ...map[string]any) *Tree</code></pre>
            </article>
            
            <article class="function" data-name="NewIdentifier">
               <h3>
                  NewIdentifier 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewIdentifier returns a new [IdentifierNode] with the given identifier name.</p>
               
               <pre><code>func NewIdentifier(ident string) *IdentifierNode</code></pre>
            </article>
            
            <article class="function" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Parse parses the template definition string to construct a representation of
the template for execution. If either action delimiter string is empty, the
default ("{{" or "}}") is used. Embedded template definitions are added to
the treeSet map.</p>
               
               <pre><code>func (t *Tree) Parse(text string, leftDelim string, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]any) (tree *Tree, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Parse">
               <h3>
                  Parse 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Parse returns a map from template name to [Tree], created by parsing the
templates described in the argument string. The top-level template will be
given the specified name. If an error is encountered, parsing stops and an
empty map is returned with the error.</p>
               
               <pre><code>func Parse(name string, text string, leftDelim string, rightDelim string, funcs ...map[string]any) (map[string]*Tree, error)</code></pre>
            </article>
            
            <article class="function" data-name="Position">
               <h3>
                  Position 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p Pos) Position() Pos</code></pre>
            </article>
            
            <article class="function" data-name="SetPos">
               <h3>
                  SetPos 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetPos sets the position. [NewIdentifier] is a public method so we can't modify its signature.
Chained for convenience.
TODO: fix one day?</p>
               
               <pre><code>func (i *IdentifierNode) SetPos(pos Pos) *IdentifierNode</code></pre>
            </article>
            
            <article class="function" data-name="SetTree">
               <h3>
                  SetTree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>SetTree sets the parent tree for the node. [NewIdentifier] is a public method so we can't modify its signature.
Chained for convenience.
TODO: fix one day?</p>
               
               <pre><code>func (i *IdentifierNode) SetTree(t *Tree) *IdentifierNode</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *BoolNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *endNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *FieldNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ContinueNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *ListNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *StringNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ChainNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *ActionNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *BreakNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *TextNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i *IdentifierNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i item) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *DotNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *BranchNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *CommentNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NumberNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *elseNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NilNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *TemplateNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *VariableNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *PipeNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *CommandNode) String() string</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *elseNode) Type() NodeType</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *DotNode) Type() NodeType</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Type returns itself and provides an easy default implementation
for embedding in a Node. Embedded in all non-trivial Nodes.</p>
               
               <pre><code>func (t NodeType) Type() NodeType</code></pre>
            </article>
            
            <article class="function" data-name="Type">
               <h3>
                  Type 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NilNode) Type() NodeType</code></pre>
            </article>
            
            <article class="function" data-name="accept">
               <h3>
                  accept 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>accept consumes the next rune if it's from the valid set.</p>
               
               <pre><code>func (l *lexer) accept(valid string) bool</code></pre>
            </article>
            
            <article class="function" data-name="acceptRun">
               <h3>
                  acceptRun 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>acceptRun consumes a run of runes from the valid set.</p>
               
               <pre><code>func (l *lexer) acceptRun(valid string)</code></pre>
            </article>
            
            <article class="function" data-name="action">
               <h3>
                  action 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Action:
control
command ("|" command)*
Left delim is past. Now get actions.
First word could be a keyword such as range.</p>
               
               <pre><code>func (t *Tree) action() (n Node)</code></pre>
            </article>
            
            <article class="function" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>add adds tree to t.treeSet.</p>
               
               <pre><code>func (t *Tree) add()</code></pre>
            </article>
            
            <article class="function" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *CommandNode) append(arg Node)</code></pre>
            </article>
            
            <article class="function" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *PipeNode) append(command *CommandNode)</code></pre>
            </article>
            
            <article class="function" data-name="append">
               <h3>
                  append 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *ListNode) append(n Node)</code></pre>
            </article>
            
            <article class="function" data-name="atRightDelim">
               <h3>
                  atRightDelim 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>atRightDelim reports whether the lexer is at a right delimiter, possibly preceded by a trim marker.</p>
               
               <pre><code>func (l *lexer) atRightDelim() (delim bool, trimSpaces bool)</code></pre>
            </article>
            
            <article class="function" data-name="atTerminator">
               <h3>
                  atTerminator 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>atTerminator reports whether the input is at valid termination character to
appear after an identifier. Breaks .X.Y into two pieces. Also catches cases
like "$x+2" not being acceptable without a space, in case we decide one
day to implement arithmetic.</p>
               
               <pre><code>func (l *lexer) atTerminator() bool</code></pre>
            </article>
            
            <article class="function" data-name="backup">
               <h3>
                  backup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>backup steps back one rune.</p>
               
               <pre><code>func (l *lexer) backup()</code></pre>
            </article>
            
            <article class="function" data-name="backup">
               <h3>
                  backup 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>backup backs the input stream up one token.</p>
               
               <pre><code>func (t *Tree) backup()</code></pre>
            </article>
            
            <article class="function" data-name="backup2">
               <h3>
                  backup2 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>backup2 backs the input stream up two tokens.
The zeroth token is already there.</p>
               
               <pre><code>func (t *Tree) backup2(t1 item)</code></pre>
            </article>
            
            <article class="function" data-name="backup3">
               <h3>
                  backup3 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>backup3 backs the input stream up three tokens
The zeroth token is already there.</p>
               
               <pre><code>func (t *Tree) backup3(t2 item, t1 item)</code></pre>
            </article>
            
            <article class="function" data-name="blockControl">
               <h3>
                  blockControl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Block:
{{block stringValue pipeline}}
Block keyword is past.
The name must be something that can evaluate to a string.
The pipeline is mandatory.</p>
               
               <pre><code>func (t *Tree) blockControl() Node</code></pre>
            </article>
            
            <article class="function" data-name="breakControl">
               <h3>
                  breakControl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Break:
{{break}}
Break keyword is past.</p>
               
               <pre><code>func (t *Tree) breakControl(pos Pos, line int) Node</code></pre>
            </article>
            
            <article class="function" data-name="checkPipeline">
               <h3>
                  checkPipeline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) checkPipeline(pipe *PipeNode, context string)</code></pre>
            </article>
            
            <article class="function" data-name="clearActionLine">
               <h3>
                  clearActionLine 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) clearActionLine()</code></pre>
            </article>
            
            <article class="function" data-name="command">
               <h3>
                  command 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>command:
operand (space operand)*
space-separated arguments up to a pipeline character or right delimiter.
we consume the pipe character but leave the right delim to terminate the action.</p>
               
               <pre><code>func (t *Tree) command() *CommandNode</code></pre>
            </article>
            
            <article class="function" data-name="continueControl">
               <h3>
                  continueControl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Continue:
{{continue}}
Continue keyword is past.</p>
               
               <pre><code>func (t *Tree) continueControl(pos Pos, line int) Node</code></pre>
            </article>
            
            <article class="function" data-name="elseControl">
               <h3>
                  elseControl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Else:
{{else}}
Else keyword is past.</p>
               
               <pre><code>func (t *Tree) elseControl() Node</code></pre>
            </article>
            
            <article class="function" data-name="emit">
               <h3>
                  emit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>emit passes the trailing text as an item back to the parser.</p>
               
               <pre><code>func (l *lexer) emit(t itemType) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="emitItem">
               <h3>
                  emitItem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>emitItem passes the specified item to the parser.</p>
               
               <pre><code>func (l *lexer) emitItem(i item) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="endControl">
               <h3>
                  endControl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>End:
{{end}}
End keyword is past.</p>
               
               <pre><code>func (t *Tree) endControl() Node</code></pre>
            </article>
            
            <article class="function" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>error terminates processing.</p>
               
               <pre><code>func (t *Tree) error(err error)</code></pre>
            </article>
            
            <article class="function" data-name="errorf">
               <h3>
                  errorf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>errorf returns an error token and terminates the scan by passing
back a nil pointer that will be the next state, terminating l.nextItem.</p>
               
               <pre><code>func (l *lexer) errorf(format string, args ...any) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="errorf">
               <h3>
                  errorf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>errorf formats the error and terminates processing.</p>
               
               <pre><code>func (t *Tree) errorf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="expect">
               <h3>
                  expect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>expect consumes the next token and guarantees it has the required type.</p>
               
               <pre><code>func (t *Tree) expect(expected itemType, context string) item</code></pre>
            </article>
            
            <article class="function" data-name="expectOneOf">
               <h3>
                  expectOneOf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>expectOneOf consumes the next token and guarantees it has one of the required types.</p>
               
               <pre><code>func (t *Tree) expectOneOf(expected1 itemType, expected2 itemType, context string) item</code></pre>
            </article>
            
            <article class="function" data-name="hasFunction">
               <h3>
                  hasFunction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>hasFunction reports if a function name exists in the Tree's maps.</p>
               
               <pre><code>func (t *Tree) hasFunction(name string) bool</code></pre>
            </article>
            
            <article class="function" data-name="hasLeftTrimMarker">
               <h3>
                  hasLeftTrimMarker 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func hasLeftTrimMarker(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="hasRightTrimMarker">
               <h3>
                  hasRightTrimMarker 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func hasRightTrimMarker(s string) bool</code></pre>
            </article>
            
            <article class="function" data-name="ifControl">
               <h3>
                  ifControl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>If:
{{if pipeline}} itemList {{end}}
{{if pipeline}} itemList {{else}} itemList {{end}}
If keyword is past.</p>
               
               <pre><code>func (t *Tree) ifControl() Node</code></pre>
            </article>
            
            <article class="function" data-name="ignore">
               <h3>
                  ignore 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ignore skips over the pending input before this point.
It tracks newlines in the ignored text, so use it only
for text that is skipped without calling l.next.</p>
               
               <pre><code>func (l *lexer) ignore()</code></pre>
            </article>
            
            <article class="function" data-name="isAlphaNumeric">
               <h3>
                  isAlphaNumeric 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isAlphaNumeric reports whether r is an alphabetic, digit, or underscore.</p>
               
               <pre><code>func isAlphaNumeric(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="isSpace">
               <h3>
                  isSpace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isSpace reports whether r is a space character.</p>
               
               <pre><code>func isSpace(r rune) bool</code></pre>
            </article>
            
            <article class="function" data-name="itemList">
               <h3>
                  itemList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>itemList:
textOrAction*
Terminates at {{end}} or {{else}}, returned separately.</p>
               
               <pre><code>func (t *Tree) itemList() (list *ListNode, next Node)</code></pre>
            </article>
            
            <article class="function" data-name="leftTrimLength">
               <h3>
                  leftTrimLength 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>leftTrimLength returns the length of the spaces at the beginning of the string.</p>
               
               <pre><code>func leftTrimLength(s string) Pos</code></pre>
            </article>
            
            <article class="function" data-name="lex">
               <h3>
                  lex 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lex creates a new scanner for the input string.</p>
               
               <pre><code>func lex(name string, input string, left string, right string) *lexer</code></pre>
            </article>
            
            <article class="function" data-name="lexChar">
               <h3>
                  lexChar 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexChar scans a character constant. The initial quote is already
scanned. Syntax checking is done by the parser.</p>
               
               <pre><code>func lexChar(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexComment">
               <h3>
                  lexComment 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexComment scans a comment. The left comment marker is known to be present.</p>
               
               <pre><code>func lexComment(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexField">
               <h3>
                  lexField 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexField scans a field: .Alphanumeric.
The . has been scanned.</p>
               
               <pre><code>func lexField(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexFieldOrVariable">
               <h3>
                  lexFieldOrVariable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexFieldOrVariable scans a field or variable: [.$]Alphanumeric.
The . or $ has been scanned.</p>
               
               <pre><code>func lexFieldOrVariable(l *lexer, typ itemType) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexIdentifier">
               <h3>
                  lexIdentifier 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexIdentifier scans an alphanumeric.</p>
               
               <pre><code>func lexIdentifier(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexInsideAction">
               <h3>
                  lexInsideAction 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexInsideAction scans the elements inside action delimiters.</p>
               
               <pre><code>func lexInsideAction(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexLeftDelim">
               <h3>
                  lexLeftDelim 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexLeftDelim scans the left delimiter, which is known to be present, possibly with a trim marker.
(The text to be trimmed has already been emitted.)</p>
               
               <pre><code>func lexLeftDelim(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexNumber">
               <h3>
                  lexNumber 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexNumber scans a number: decimal, octal, hex, float, or imaginary. This
isn't a perfect number scanner - for instance it accepts "." and "0x0.2"
and "089" - but when it's wrong the input is invalid and the parser (via
strconv) will notice.</p>
               
               <pre><code>func lexNumber(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexQuote">
               <h3>
                  lexQuote 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexQuote scans a quoted string.</p>
               
               <pre><code>func lexQuote(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexRawQuote">
               <h3>
                  lexRawQuote 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexRawQuote scans a raw quoted string.</p>
               
               <pre><code>func lexRawQuote(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexRightDelim">
               <h3>
                  lexRightDelim 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexRightDelim scans the right delimiter, which is known to be present, possibly with a trim marker.</p>
               
               <pre><code>func lexRightDelim(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexSpace">
               <h3>
                  lexSpace 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexSpace scans a run of space characters.
We have not consumed the first space, which is known to be present.
Take care if there is a trim-marked right delimiter, which starts with a space.</p>
               
               <pre><code>func lexSpace(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexText">
               <h3>
                  lexText 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexText scans until an opening action delimiter, "{{".</p>
               
               <pre><code>func lexText(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="lexVariable">
               <h3>
                  lexVariable 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>lexVariable scans a Variable: $Alphanumeric.
The $ has been scanned.</p>
               
               <pre><code>func lexVariable(l *lexer) stateFn</code></pre>
            </article>
            
            <article class="function" data-name="newAction">
               <h3>
                  newAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newAction(pos Pos, line int, pipe *PipeNode) *ActionNode</code></pre>
            </article>
            
            <article class="function" data-name="newBool">
               <h3>
                  newBool 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newBool(pos Pos, true bool) *BoolNode</code></pre>
            </article>
            
            <article class="function" data-name="newBreak">
               <h3>
                  newBreak 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newBreak(pos Pos, line int) *BreakNode</code></pre>
            </article>
            
            <article class="function" data-name="newChain">
               <h3>
                  newChain 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newChain(pos Pos, node Node) *ChainNode</code></pre>
            </article>
            
            <article class="function" data-name="newCommand">
               <h3>
                  newCommand 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newCommand(pos Pos) *CommandNode</code></pre>
            </article>
            
            <article class="function" data-name="newComment">
               <h3>
                  newComment 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newComment(pos Pos, text string) *CommentNode</code></pre>
            </article>
            
            <article class="function" data-name="newContinue">
               <h3>
                  newContinue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newContinue(pos Pos, line int) *ContinueNode</code></pre>
            </article>
            
            <article class="function" data-name="newDot">
               <h3>
                  newDot 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newDot(pos Pos) *DotNode</code></pre>
            </article>
            
            <article class="function" data-name="newElse">
               <h3>
                  newElse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newElse(pos Pos, line int) *elseNode</code></pre>
            </article>
            
            <article class="function" data-name="newEnd">
               <h3>
                  newEnd 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newEnd(pos Pos) *endNode</code></pre>
            </article>
            
            <article class="function" data-name="newField">
               <h3>
                  newField 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newField(pos Pos, ident string) *FieldNode</code></pre>
            </article>
            
            <article class="function" data-name="newIf">
               <h3>
                  newIf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newIf(pos Pos, line int, pipe *PipeNode, list *ListNode, elseList *ListNode) *IfNode</code></pre>
            </article>
            
            <article class="function" data-name="newList">
               <h3>
                  newList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newList(pos Pos) *ListNode</code></pre>
            </article>
            
            <article class="function" data-name="newNil">
               <h3>
                  newNil 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newNil(pos Pos) *NilNode</code></pre>
            </article>
            
            <article class="function" data-name="newNumber">
               <h3>
                  newNumber 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newNumber(pos Pos, text string, typ itemType) (*NumberNode, error)</code></pre>
            </article>
            
            <article class="function" data-name="newPipeline">
               <h3>
                  newPipeline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newPipeline(pos Pos, line int, vars []*VariableNode) *PipeNode</code></pre>
            </article>
            
            <article class="function" data-name="newRange">
               <h3>
                  newRange 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newRange(pos Pos, line int, pipe *PipeNode, list *ListNode, elseList *ListNode) *RangeNode</code></pre>
            </article>
            
            <article class="function" data-name="newString">
               <h3>
                  newString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newString(pos Pos, orig string, text string) *StringNode</code></pre>
            </article>
            
            <article class="function" data-name="newTemplate">
               <h3>
                  newTemplate 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newTemplate(pos Pos, line int, name string, pipe *PipeNode) *TemplateNode</code></pre>
            </article>
            
            <article class="function" data-name="newText">
               <h3>
                  newText 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newText(pos Pos, text string) *TextNode</code></pre>
            </article>
            
            <article class="function" data-name="newVariable">
               <h3>
                  newVariable 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newVariable(pos Pos, ident string) *VariableNode</code></pre>
            </article>
            
            <article class="function" data-name="newWith">
               <h3>
                  newWith 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) newWith(pos Pos, line int, pipe *PipeNode, list *ListNode, elseList *ListNode) *WithNode</code></pre>
            </article>
            
            <article class="function" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>next returns the next token.</p>
               
               <pre><code>func (t *Tree) next() item</code></pre>
            </article>
            
            <article class="function" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>next returns the next rune in the input.</p>
               
               <pre><code>func (l *lexer) next() rune</code></pre>
            </article>
            
            <article class="function" data-name="nextItem">
               <h3>
                  nextItem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>nextItem returns the next item from the input.
Called by the parser, not in the lexing goroutine.</p>
               
               <pre><code>func (l *lexer) nextItem() item</code></pre>
            </article>
            
            <article class="function" data-name="nextNonSpace">
               <h3>
                  nextNonSpace 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>nextNonSpace returns the next non-space token.</p>
               
               <pre><code>func (t *Tree) nextNonSpace() (token item)</code></pre>
            </article>
            
            <article class="function" data-name="operand">
               <h3>
                  operand 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>operand:
term .Field*
An operand is a space-separated component of a command,
a term possibly followed by field accesses.
A nil return means the next item is not an operand.</p>
               
               <pre><code>func (t *Tree) operand() Node</code></pre>
            </article>
            
            <article class="function" data-name="parse">
               <h3>
                  parse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parse is the top-level parser for a template, essentially the same
as itemList except it also parses {{define}} actions.
It runs to EOF.</p>
               
               <pre><code>func (t *Tree) parse()</code></pre>
            </article>
            
            <article class="function" data-name="parseControl">
               <h3>
                  parseControl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) parseControl(context string) (pos Pos, line int, pipe *PipeNode, list *ListNode, elseList *ListNode)</code></pre>
            </article>
            
            <article class="function" data-name="parseDefinition">
               <h3>
                  parseDefinition 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseDefinition parses a {{define}} ...  {{end}} template definition and
installs the definition in t.treeSet. The "define" keyword has already
been scanned.</p>
               
               <pre><code>func (t *Tree) parseDefinition()</code></pre>
            </article>
            
            <article class="function" data-name="parseTemplateName">
               <h3>
                  parseTemplateName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *Tree) parseTemplateName(token item, context string) (name string)</code></pre>
            </article>
            
            <article class="function" data-name="peek">
               <h3>
                  peek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>peek returns but does not consume the next rune in the input.</p>
               
               <pre><code>func (l *lexer) peek() rune</code></pre>
            </article>
            
            <article class="function" data-name="peek">
               <h3>
                  peek 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>peek returns but does not consume the next token.</p>
               
               <pre><code>func (t *Tree) peek() item</code></pre>
            </article>
            
            <article class="function" data-name="peekNonSpace">
               <h3>
                  peekNonSpace 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>peekNonSpace returns but does not consume the next non-space token.</p>
               
               <pre><code>func (t *Tree) peekNonSpace() item</code></pre>
            </article>
            
            <article class="function" data-name="pipeline">
               <h3>
                  pipeline 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Pipeline:
declarations? command ('|' command)*</p>
               
               <pre><code>func (t *Tree) pipeline(context string, end itemType) (pipe *PipeNode)</code></pre>
            </article>
            
            <article class="function" data-name="popVars">
               <h3>
                  popVars 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>popVars trims the variable list to the specified length</p>
               
               <pre><code>func (t *Tree) popVars(n int)</code></pre>
            </article>
            
            <article class="function" data-name="rangeControl">
               <h3>
                  rangeControl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Range:
{{range pipeline}} itemList {{end}}
{{range pipeline}} itemList {{else}} itemList {{end}}
Range keyword is past.</p>
               
               <pre><code>func (t *Tree) rangeControl() Node</code></pre>
            </article>
            
            <article class="function" data-name="recover">
               <h3>
                  recover 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>recover is the handler that turns panics into returns from the top level of Parse.</p>
               
               <pre><code>func (t *Tree) recover(errp *error)</code></pre>
            </article>
            
            <article class="function" data-name="rightTrimLength">
               <h3>
                  rightTrimLength 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>rightTrimLength returns the length of the spaces at the end of the string.</p>
               
               <pre><code>func rightTrimLength(s string) Pos</code></pre>
            </article>
            
            <article class="function" data-name="scanNumber">
               <h3>
                  scanNumber 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *lexer) scanNumber() bool</code></pre>
            </article>
            
            <article class="function" data-name="simplifyComplex">
               <h3>
                  simplifyComplex 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>simplifyComplex pulls out any other types that are represented by the complex number.
These all require that the imaginary part be zero.</p>
               
               <pre><code>func (n *NumberNode) simplifyComplex()</code></pre>
            </article>
            
            <article class="function" data-name="startParse">
               <h3>
                  startParse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>startParse initializes the parser, using the lexer.</p>
               
               <pre><code>func (t *Tree) startParse(funcs []map[string]any, lex *lexer, treeSet map[string]*Tree)</code></pre>
            </article>
            
            <article class="function" data-name="stopParse">
               <h3>
                  stopParse 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>stopParse terminates parsing.</p>
               
               <pre><code>func (t *Tree) stopParse()</code></pre>
            </article>
            
            <article class="function" data-name="templateControl">
               <h3>
                  templateControl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Template:
{{template stringValue pipeline}}
Template keyword is past. The name must be something that can evaluate
to a string.</p>
               
               <pre><code>func (t *Tree) templateControl() Node</code></pre>
            </article>
            
            <article class="function" data-name="term">
               <h3>
                  term 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>term:
literal (number, string, nil, boolean)
function (identifier)
.
.Field
$
'(' pipeline ')'
A term is a simple "expression".
A nil return means the next item is not a term.</p>
               
               <pre><code>func (t *Tree) term() Node</code></pre>
            </article>
            
            <article class="function" data-name="textOrAction">
               <h3>
                  textOrAction 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>textOrAction:
text | comment | action</p>
               
               <pre><code>func (t *Tree) textOrAction() Node</code></pre>
            </article>
            
            <article class="function" data-name="thisItem">
               <h3>
                  thisItem 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>thisItem returns the item at the current input point with the specified type
and advances the input.</p>
               
               <pre><code>func (l *lexer) thisItem(t itemType) item</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *ActionNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *StringNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NilNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *VariableNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ContinueNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *ListNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *FieldNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i *IdentifierNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *BreakNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ChainNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *CommandNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *TextNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *BranchNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *BoolNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NumberNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *DotNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *elseNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *TemplateNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *CommentNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *PipeNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="tree">
               <h3>
                  tree 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *endNode) tree() *Tree</code></pre>
            </article>
            
            <article class="function" data-name="unexpected">
               <h3>
                  unexpected 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unexpected complains about the token and terminates processing.</p>
               
               <pre><code>func (t *Tree) unexpected(token item, context string)</code></pre>
            </article>
            
            <article class="function" data-name="useVar">
               <h3>
                  useVar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>useVar returns a node for a variable reference. It errors if the
variable is not defined.</p>
               
               <pre><code>func (t *Tree) useVar(pos Pos, name string) Node</code></pre>
            </article>
            
            <article class="function" data-name="withControl">
               <h3>
                  withControl 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>With:
{{with pipeline}} itemList {{end}}
{{with pipeline}} itemList {{else}} itemList {{end}}
If keyword is past.</p>
               
               <pre><code>func (t *Tree) withControl() Node</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *BranchNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ChainNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *CommentNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *endNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NumberNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *CommandNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (s *StringNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *BoolNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *TextNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *elseNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (i *IdentifierNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (a *ActionNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (b *BreakNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (l *ListNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f *FieldNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (v *VariableNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (c *ContinueNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (t *TemplateNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (n *NilNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (d *DotNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
            <article class="function" data-name="writeTo">
               <h3>
                  writeTo 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *PipeNode) writeTo(sb *strings.Builder)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
