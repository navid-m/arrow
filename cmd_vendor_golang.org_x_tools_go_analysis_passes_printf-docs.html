<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>printf - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 14%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>printf</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"fmt"
"go/ast"
"go/types"
"golang.org/x/tools/go/analysis"
"golang.org/x/tools/internal/typeparams"
"bytes"
_ "embed"
"fmt"
"go/ast"
"go/constant"
"go/token"
"go/types"
"reflect"
"regexp"
"sort"
"strconv"
"strings"
"unicode/utf8"
"golang.org/x/tools/go/analysis"
"golang.org/x/tools/go/analysis/passes/inspect"
"golang.org/x/tools/go/analysis/passes/internal/analysisutil"
"golang.org/x/tools/go/ast/inspector"
"golang.org/x/tools/go/types/typeutil"
"golang.org/x/tools/internal/typeparams"
"golang.org/x/tools/internal/versions"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="Analyzer" data-name="Analyzer">
               <h3>
                  Analyzer 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#Analyzer" class="anchor" title="Link to Analyzer">#</a>
               </h3>
               
               <pre><code class="language-go">var Analyzer = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindErrorf" data-name="KindErrorf">
               <h3>
                  KindErrorf 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindErrorf" class="anchor" title="Link to KindErrorf">#</a>
               </h3>
               
               <pre><code class="language-go">const KindErrorf</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindNone" data-name="KindNone">
               <h3>
                  KindNone 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindNone" class="anchor" title="Link to KindNone">#</a>
               </h3>
               
               <pre><code class="language-go">const KindNone Kind = iota</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindPrint" data-name="KindPrint">
               <h3>
                  KindPrint 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindPrint" class="anchor" title="Link to KindPrint">#</a>
               </h3>
               
               <pre><code class="language-go">const KindPrint</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="KindPrintf" data-name="KindPrintf">
               <h3>
                  KindPrintf 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#KindPrintf" class="anchor" title="Link to KindPrintf">#</a>
               </h3>
               
               <pre><code class="language-go">const KindPrintf</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="allFlags" data-name="allFlags">
               <h3>
                  allFlags 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#allFlags" class="anchor" title="Link to allFlags">#</a>
               </h3>
               
                  <p class="doc-comment">Common flag sets for printf verbs.</p>
               
               <pre><code class="language-go">const allFlags = " -+.0#"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="anyType" data-name="anyType">
               <h3>
                  anyType 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#anyType" class="anchor" title="Link to anyType">#</a>
               </h3>
               
               <pre><code class="language-go">const anyType printfArgType = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="argBool" data-name="argBool">
               <h3>
                  argBool 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#argBool" class="anchor" title="Link to argBool">#</a>
               </h3>
               
               <pre><code class="language-go">const argBool printfArgType = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="argComplex" data-name="argComplex">
               <h3>
                  argComplex 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#argComplex" class="anchor" title="Link to argComplex">#</a>
               </h3>
               
               <pre><code class="language-go">const argComplex</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="argError" data-name="argError">
               <h3>
                  argError 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#argError" class="anchor" title="Link to argError">#</a>
               </h3>
               
               <pre><code class="language-go">const argError</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="argFloat" data-name="argFloat">
               <h3>
                  argFloat 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#argFloat" class="anchor" title="Link to argFloat">#</a>
               </h3>
               
               <pre><code class="language-go">const argFloat</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="argInt" data-name="argInt">
               <h3>
                  argInt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#argInt" class="anchor" title="Link to argInt">#</a>
               </h3>
               
               <pre><code class="language-go">const argInt</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="argPointer" data-name="argPointer">
               <h3>
                  argPointer 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#argPointer" class="anchor" title="Link to argPointer">#</a>
               </h3>
               
               <pre><code class="language-go">const argPointer</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="argRune" data-name="argRune">
               <h3>
                  argRune 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#argRune" class="anchor" title="Link to argRune">#</a>
               </h3>
               
               <pre><code class="language-go">const argRune</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="argString" data-name="argString">
               <h3>
                  argString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#argString" class="anchor" title="Link to argString">#</a>
               </h3>
               
               <pre><code class="language-go">const argString</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="doc" data-name="doc">
               <h3>
                  doc 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#doc" class="anchor" title="Link to doc">#</a>
               </h3>
               
                  <p class="doc-comment">go:embed doc.go</p>
               
               <pre><code class="language-go">var doc string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errorType" data-name="errorType">
               <h3>
                  errorType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errorType" class="anchor" title="Link to errorType">#</a>
               </h3>
               
               <pre><code class="language-go">var errorType = *ast.TypeAssertExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagsRE" data-name="flagsRE">
               <h3>
                  flagsRE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagsRE" class="anchor" title="Link to flagsRE">#</a>
               </h3>
               
               <pre><code class="language-go">const flagsRE = `[+\-#]*`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="indexOptRE" data-name="indexOptRE">
               <h3>
                  indexOptRE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#indexOptRE" class="anchor" title="Link to indexOptRE">#</a>
               </h3>
               
               <pre><code class="language-go">const indexOptRE = `(\[[0-9]+\])?`</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="isPrint" data-name="isPrint">
               <h3>
                  isPrint 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#isPrint" class="anchor" title="Link to isPrint">#</a>
               </h3>
               
                  <p class="doc-comment">isPrint records the print functions.
If a key ends in 'f' then it is assumed to be a formatted print.
Keys are either values returned by (*types.Func).FullName,
or case-insensitive identifiers such as "errorf".
The -funcs flag adds to this set.
The set below includes facts for many important standard library
functions, even though the analysis is capable of deducing that, for
example, fmt.Printf forwards to fmt.Fprintf. We avoid relying on the
driver applying analyzers to standard packages because "go vet" does
not do so with gccgo, and nor do some other build systems.</p>
               
               <pre><code class="language-go">var isPrint = stringSet{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noFlag" data-name="noFlag">
               <h3>
                  noFlag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#noFlag" class="anchor" title="Link to noFlag">#</a>
               </h3>
               
                  <p class="doc-comment">Common flag sets for printf verbs.</p>
               
               <pre><code class="language-go">const noFlag = ""</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="numFlag" data-name="numFlag">
               <h3>
                  numFlag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#numFlag" class="anchor" title="Link to numFlag">#</a>
               </h3>
               
                  <p class="doc-comment">Common flag sets for printf verbs.</p>
               
               <pre><code class="language-go">const numFlag = " -+.0"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="numOptRE" data-name="numOptRE">
               <h3>
                  numOptRE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#numOptRE" class="anchor" title="Link to numOptRE">#</a>
               </h3>
               
               <pre><code class="language-go">const numOptRE = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="printFormatRE" data-name="printFormatRE">
               <h3>
                  printFormatRE 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#printFormatRE" class="anchor" title="Link to printFormatRE">#</a>
               </h3>
               
                  <p class="doc-comment">printFormatRE is the regexp we match and report as a possible format string
in the first argument to unformatted prints like fmt.Print.
We exclude the space flag, so that printing a string like "x % y" is not reported as a format.</p>
               
               <pre><code class="language-go">var printFormatRE = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="printVerbs" data-name="printVerbs">
               <h3>
                  printVerbs 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#printVerbs" class="anchor" title="Link to printVerbs">#</a>
               </h3>
               
                  <p class="doc-comment">printVerbs identifies which flags are known to printf for each verb.</p>
               
               <pre><code class="language-go">var printVerbs = []printVerb{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sharpNumFlag" data-name="sharpNumFlag">
               <h3>
                  sharpNumFlag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sharpNumFlag" class="anchor" title="Link to sharpNumFlag">#</a>
               </h3>
               
                  <p class="doc-comment">Common flag sets for printf verbs.</p>
               
               <pre><code class="language-go">const sharpNumFlag = " -+.0#"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="suppressNonconstants" data-name="suppressNonconstants">
               <h3>
                  suppressNonconstants 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#suppressNonconstants" class="anchor" title="Link to suppressNonconstants">#</a>
               </h3>
               
                  <p class="doc-comment">suppressNonconstants suppresses reporting printf calls with
non-constant formatting strings (proposal #60529) when true.
This variable is to allow for staging the transition to newer
versions of x/tools by vendoring.
Remove this after the 1.24 release.</p>
               
               <pre><code class="language-go">var suppressNonconstants bool</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="verbRE" data-name="verbRE">
               <h3>
                  verbRE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#verbRE" class="anchor" title="Link to verbRE">#</a>
               </h3>
               
               <pre><code class="language-go">const verbRE = `[bcdefgopqstvxEFGTUX]`</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Kind" data-name="Kind">
               <h3>
                  Kind
                  <span class="badge type-badge">type</span>
                  <a href="#Kind" class="anchor" title="Link to Kind">#</a>
               </h3>
               
               <p>Kind is a kind of fmt function behavior.</p>
               
               <pre><code class="language-go">type Kind int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="printfArgType" data-name="printfArgType">
               <h3>
                  printfArgType
                  <span class="badge type-badge">type</span>
                  <a href="#printfArgType" class="anchor" title="Link to printfArgType">#</a>
               </h3>
               
               <p>printfArgType encodes the types of expressions a printf verb accepts. It is a bitmask.</p>
               
               <pre><code class="language-go">type printfArgType int</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="stringSet" data-name="stringSet">
               <h3>
                  stringSet
                  <span class="badge type-badge">type</span>
                  <a href="#stringSet" class="anchor" title="Link to stringSet">#</a>
               </h3>
               
               <p>stringSet is a set-of-nonempty-strings-valued flag.
Note: elements without a '.' get lower-cased.</p>
               
               <pre><code class="language-go">type stringSet map[string]bool</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Result" data-name="Result">
               <h3>
                  Result
                  <span class="badge">struct</span>
                  <a href="#Result" class="anchor" title="Link to Result">#</a>
               </h3>
               
               <p>Result is the printf analyzer's result type. Clients may query the result
to learn whether a function behaves like fmt.Print or fmt.Printf.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type Result struct {
funcs map[*types.Func]Kind
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="argMatcher" data-name="argMatcher">
               <h3>
                  argMatcher
                  <span class="badge">struct</span>
                  <a href="#argMatcher" class="anchor" title="Link to argMatcher">#</a>
               </h3>
               
               <p>argMatcher recursively matches types against the printfArgType t.
To short-circuit recursion, it keeps track of types that have already been
matched (or are in the process of being matched) via the seen map. Recursion
arises from the compound types {map,chan,slice} which may be printed with %d
etc. if that is appropriate for their element types, as well as from type
parameters, which are expanded to the constituents of their type set.
The reason field may be set to report the cause of the mismatch.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type argMatcher struct {
t printfArgType
seen map[types.Type]bool
reason string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="formatState" data-name="formatState">
               <h3>
                  formatState
                  <span class="badge">struct</span>
                  <a href="#formatState" class="anchor" title="Link to formatState">#</a>
               </h3>
               
               <p>formatState holds the parsed representation of a printf directive such as "%3.*[4]d".
It is constructed by parsePrintfVerb.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type formatState struct {
verb rune
format string
name string
flags []byte
argNums []int
firstArg int
pass *analysis.Pass
call *ast.CallExpr
argNum int
hasIndex bool
indexPending bool
nbytes int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="isWrapper" data-name="isWrapper">
               <h3>
                  isWrapper
                  <span class="badge">struct</span>
                  <a href="#isWrapper" class="anchor" title="Link to isWrapper">#</a>
               </h3>
               
               <p>isWrapper is a fact indicating that a function is a print or printf wrapper.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type isWrapper struct {
Kind Kind
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="printVerb" data-name="printVerb">
               <h3>
                  printVerb
                  <span class="badge">struct</span>
                  <a href="#printVerb" class="anchor" title="Link to printVerb">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type printVerb struct {
verb rune
flags string
typ printfArgType
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="printfCaller" data-name="printfCaller">
               <h3>
                  printfCaller
                  <span class="badge">struct</span>
                  <a href="#printfCaller" class="anchor" title="Link to printfCaller">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type printfCaller struct {
w *printfWrapper
call *ast.CallExpr
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="printfWrapper" data-name="printfWrapper">
               <h3>
                  printfWrapper
                  <span class="badge">struct</span>
                  <a href="#printfWrapper" class="anchor" title="Link to printfWrapper">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type printfWrapper struct {
obj *types.Func
fdecl *ast.FuncDecl
format *types.Var
args *types.Var
callers []printfCaller
failed bool
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AFact" data-name="AFact">
               <h3>
                  AFact 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AFact" class="anchor" title="Link to AFact">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *isWrapper) AFact()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Kind" data-name="Kind">
               <h3>
                  Kind 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Kind" class="anchor" title="Link to Kind">#</a>
               </h3>
               
               <p>Kind reports whether fn behaves like fmt.Print or fmt.Printf.</p>
               
               <pre><code class="language-go">func (r *Result) Kind(fn *types.Func) Kind</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <pre><code class="language-go">func (ss stringSet) Set(flag string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (ss stringSet) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (kind Kind) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code class="language-go">func (f *isWrapper) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="argCanBeChecked" data-name="argCanBeChecked">
               <h3>
                  argCanBeChecked 
                  <span class="badge">function</span>
                  
                  <a href="#argCanBeChecked" class="anchor" title="Link to argCanBeChecked">#</a>
               </h3>
               
               <p>argCanBeChecked reports whether the specified argument is statically present;
it may be beyond the list of arguments or in a terminal slice... argument, which
means we can't see it.</p>
               
               <pre><code class="language-go">func argCanBeChecked(pass *analysis.Pass, call *ast.CallExpr, formatArg int, state *formatState) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkCalls" data-name="checkCalls">
               <h3>
                  checkCalls 
                  <span class="badge">function</span>
                  
                  <a href="#checkCalls" class="anchor" title="Link to checkCalls">#</a>
               </h3>
               
               <p>checkCalls triggers the print-specific checks for calls that invoke a print
function.</p>
               
               <pre><code class="language-go">func checkCalls(pass *analysis.Pass)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPrint" data-name="checkPrint">
               <h3>
                  checkPrint 
                  <span class="badge">function</span>
                  
                  <a href="#checkPrint" class="anchor" title="Link to checkPrint">#</a>
               </h3>
               
               <p>checkPrint checks a call to an unformatted print routine such as Println.</p>
               
               <pre><code class="language-go">func checkPrint(pass *analysis.Pass, call *ast.CallExpr, fn *types.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPrintf" data-name="checkPrintf">
               <h3>
                  checkPrintf 
                  <span class="badge">function</span>
                  
                  <a href="#checkPrintf" class="anchor" title="Link to checkPrintf">#</a>
               </h3>
               
               <p>checkPrintf checks a call to a formatted print routine such as Printf.</p>
               
               <pre><code class="language-go">func checkPrintf(pass *analysis.Pass, fileVersion string, kind Kind, call *ast.CallExpr, fn *types.Func)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkPrintfFwd" data-name="checkPrintfFwd">
               <h3>
                  checkPrintfFwd 
                  <span class="badge">function</span>
                  
                  <a href="#checkPrintfFwd" class="anchor" title="Link to checkPrintfFwd">#</a>
               </h3>
               
               <p>checkPrintfFwd checks that a printf-forwarding wrapper is forwarding correctly.
It diagnoses writing fmt.Printf(format, args) instead of fmt.Printf(format, args...).</p>
               
               <pre><code class="language-go">func checkPrintfFwd(pass *analysis.Pass, w *printfWrapper, call *ast.CallExpr, kind Kind, res *Result)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="count" data-name="count">
               <h3>
                  count 
                  <span class="badge">function</span>
                  
                  <a href="#count" class="anchor" title="Link to count">#</a>
               </h3>
               
               <p>count(n, what) returns "1 what" or "N whats"
(assuming the plural of what is whats).</p>
               
               <pre><code class="language-go">func count(n int, what string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findPrintfLike" data-name="findPrintfLike">
               <h3>
                  findPrintfLike 
                  <span class="badge">function</span>
                  
                  <a href="#findPrintfLike" class="anchor" title="Link to findPrintfLike">#</a>
               </h3>
               
               <p>findPrintfLike scans the entire package to find printf-like functions.</p>
               
               <pre><code class="language-go">func findPrintfLike(pass *analysis.Pass, res *Result) (any, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="formatStringIndex" data-name="formatStringIndex">
               <h3>
                  formatStringIndex 
                  <span class="badge">function</span>
                  
                  <a href="#formatStringIndex" class="anchor" title="Link to formatStringIndex">#</a>
               </h3>
               
               <p>formatStringIndex returns the index of the format string (the last
non-variadic parameter) within the given printf-like call
expression, or -1 if unknown.</p>
               
               <pre><code class="language-go">func formatStringIndex(pass *analysis.Pass, call *ast.CallExpr) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge">function</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func init()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isConvertibleToString" data-name="isConvertibleToString">
               <h3>
                  isConvertibleToString 
                  <span class="badge">function</span>
                  
                  <a href="#isConvertibleToString" class="anchor" title="Link to isConvertibleToString">#</a>
               </h3>
               
               <pre><code class="language-go">func isConvertibleToString(typ types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isFormatter" data-name="isFormatter">
               <h3>
                  isFormatter 
                  <span class="badge">function</span>
                  
                  <a href="#isFormatter" class="anchor" title="Link to isFormatter">#</a>
               </h3>
               
               <p>isFormatter reports whether t could satisfy fmt.Formatter.
The only interface method to look for is "Format(State, rune)".</p>
               
               <pre><code class="language-go">func isFormatter(typ types.Type) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isFunctionValue" data-name="isFunctionValue">
               <h3>
                  isFunctionValue 
                  <span class="badge">function</span>
                  
                  <a href="#isFunctionValue" class="anchor" title="Link to isFunctionValue">#</a>
               </h3>
               
               <p>isFunctionValue reports whether the expression is a function as opposed to a function call.
It is almost always a mistake to print a function value.</p>
               
               <pre><code class="language-go">func isFunctionValue(pass *analysis.Pass, e ast.Expr) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isStringer" data-name="isStringer">
               <h3>
                  isStringer 
                  <span class="badge">function</span>
                  
                  <a href="#isStringer" class="anchor" title="Link to isStringer">#</a>
               </h3>
               
               <p>isStringer reports whether the method signature matches the String() definition in fmt.Stringer.</p>
               
               <pre><code class="language-go">func isStringer(sig *types.Signature) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge">function</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <pre><code class="language-go">func match(info *types.Info, arg ast.Expr, param *types.Var) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <p>match checks if typ matches m's printf arg type. If topLevel is true, typ is
the actual type of the printf arg, for which special rules apply. As a
special case, top level type parameters pass topLevel=true when checking for
matches among the constituents of their type set, as type arguments will
replace the type parameter at compile time.</p>
               
               <pre><code class="language-go">func (m *argMatcher) match(typ types.Type, topLevel bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchArgType" data-name="matchArgType">
               <h3>
                  matchArgType 
                  <span class="badge">function</span>
                  
                  <a href="#matchArgType" class="anchor" title="Link to matchArgType">#</a>
               </h3>
               
               <p>matchArgType reports an error if printf verb t is not appropriate for
operand arg.
If arg is a type parameter, the verb t must be appropriate for every type in
the type parameter type set.</p>
               
               <pre><code class="language-go">func matchArgType(pass *analysis.Pass, t printfArgType, arg ast.Expr) (reason string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maybePrintfWrapper" data-name="maybePrintfWrapper">
               <h3>
                  maybePrintfWrapper 
                  <span class="badge">function</span>
                  
                  <a href="#maybePrintfWrapper" class="anchor" title="Link to maybePrintfWrapper">#</a>
               </h3>
               
               <p>maybePrintfWrapper decides whether decl (a declared function) may be a wrapper
around a fmt.Printf or fmt.Print function. If so it returns a printfWrapper
function describing the declaration. Later processing will analyze the
graph of potential printf wrappers to pick out the ones that are true wrappers.
A function may be a Printf or Print wrapper if its last argument is ...interface{}.
If the next-to-last argument is a string, then this may be a Printf wrapper.
Otherwise it may be a Print wrapper.</p>
               
               <pre><code class="language-go">func maybePrintfWrapper(info *types.Info, decl ast.Decl) *printfWrapper</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="okPrintfArg" data-name="okPrintfArg">
               <h3>
                  okPrintfArg 
                  <span class="badge">function</span>
                  
                  <a href="#okPrintfArg" class="anchor" title="Link to okPrintfArg">#</a>
               </h3>
               
               <p>okPrintfArg compares the formatState to the arguments actually present,
reporting any discrepancies it can discern. If the final argument is ellipsissed,
there's little it can do for that.</p>
               
               <pre><code class="language-go">func okPrintfArg(pass *analysis.Pass, call *ast.CallExpr, state *formatState) (ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseFlags" data-name="parseFlags">
               <h3>
                  parseFlags 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseFlags" class="anchor" title="Link to parseFlags">#</a>
               </h3>
               
               <p>parseFlags accepts any printf flags.</p>
               
               <pre><code class="language-go">func (s *formatState) parseFlags()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseIndex" data-name="parseIndex">
               <h3>
                  parseIndex 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseIndex" class="anchor" title="Link to parseIndex">#</a>
               </h3>
               
               <p>parseIndex scans an index expression. It returns false if there is a syntax error.</p>
               
               <pre><code class="language-go">func (s *formatState) parseIndex() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseNum" data-name="parseNum">
               <h3>
                  parseNum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseNum" class="anchor" title="Link to parseNum">#</a>
               </h3>
               
               <p>parseNum scans a width or precision (or *). It returns false if there's a bad index expression.</p>
               
               <pre><code class="language-go">func (s *formatState) parseNum() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePrecision" data-name="parsePrecision">
               <h3>
                  parsePrecision 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parsePrecision" class="anchor" title="Link to parsePrecision">#</a>
               </h3>
               
               <p>parsePrecision scans for a precision. It returns false if there's a bad index expression.</p>
               
               <pre><code class="language-go">func (s *formatState) parsePrecision() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePrintfVerb" data-name="parsePrintfVerb">
               <h3>
                  parsePrintfVerb 
                  <span class="badge">function</span>
                  
                  <a href="#parsePrintfVerb" class="anchor" title="Link to parsePrintfVerb">#</a>
               </h3>
               
               <p>parsePrintfVerb looks the formatting directive that begins the format string
and returns a formatState that encodes what the directive wants, without looking
at the actual arguments present in the call. The result is nil if there is an error.</p>
               
               <pre><code class="language-go">func parsePrintfVerb(pass *analysis.Pass, call *ast.CallExpr, name string, format string, firstArg int, argNum int) *formatState</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="printfNameAndKind" data-name="printfNameAndKind">
               <h3>
                  printfNameAndKind 
                  <span class="badge">function</span>
                  
                  <a href="#printfNameAndKind" class="anchor" title="Link to printfNameAndKind">#</a>
               </h3>
               
               <pre><code class="language-go">func printfNameAndKind(pass *analysis.Pass, call *ast.CallExpr) (fn *types.Func, kind Kind)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="recursiveStringer" data-name="recursiveStringer">
               <h3>
                  recursiveStringer 
                  <span class="badge">function</span>
                  
                  <a href="#recursiveStringer" class="anchor" title="Link to recursiveStringer">#</a>
               </h3>
               
               <p>recursiveStringer reports whether the argument e is a potential
recursive call to stringer or is an error, such as t and &t in these examples:
func (t *T) String() string { printf("%s",  t) }
func (t  T) Error() string { printf("%s",  t) }
func (t  T) String() string { printf("%s", &t) }</p>
               
               <pre><code class="language-go">func recursiveStringer(pass *analysis.Pass, e ast.Expr) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="run" data-name="run">
               <h3>
                  run 
                  <span class="badge">function</span>
                  
                  <a href="#run" class="anchor" title="Link to run">#</a>
               </h3>
               
               <pre><code class="language-go">func run(pass *analysis.Pass) (any, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="scanNum" data-name="scanNum">
               <h3>
                  scanNum 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#scanNum" class="anchor" title="Link to scanNum">#</a>
               </h3>
               
               <p>scanNum advances through a decimal number if present.</p>
               
               <pre><code class="language-go">func (s *formatState) scanNum()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stringConstantExpr" data-name="stringConstantExpr">
               <h3>
                  stringConstantExpr 
                  <span class="badge">function</span>
                  
                  <a href="#stringConstantExpr" class="anchor" title="Link to stringConstantExpr">#</a>
               </h3>
               
               <p>stringConstantExpr returns expression's string constant value.
("", false) is returned if expression isn't a string
constant.</p>
               
               <pre><code class="language-go">func stringConstantExpr(pass *analysis.Pass, expr ast.Expr) (string, bool)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function deduplicateImports() {
            const importsSection = document.querySelector('#imports-section code');
            if (!importsSection) return;
            
            const lines = importsSection.textContent.split('\n');
            var uniqueLines = [...new Set(lines.filter(line => line.trim()))];
            uniqueLines.sort();
            importsSection.textContent = uniqueLines.join('\n');
            
            if (window.Prism) {
               Prism.highlightElement(importsSection);
            }
         }

         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();
                  const allMatches = [];
                  const sectionOrder = ['imports', 'globals', 'types', 'interfaces', 'structs', 'functions'];
                  
                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl = el.classList.contains("private");
                        const shouldShowPrivate = getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                           
                           const section = el.closest('section');
                           if (section) {
                              const sectionId = section.id;
                              const sectionIndex = sectionOrder.indexOf(sectionId);
                              const isExactMatch = name.toLowerCase() === query;
                              
                              allMatches.push({
                                 element: el,
                                 name: name,
                                 isExact: isExactMatch,
                                 sectionId: sectionId,
                                 sectionIndex: sectionIndex >= 0 ? sectionIndex : 999
                              });
                           }
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  allMatches.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     if (a.sectionIndex !== b.sectionIndex) return a.sectionIndex - b.sectionIndex;
                     return a.name.localeCompare(b.name);
                  });

                  const sectionMatches = {};
                  allMatches.forEach(match => {
                     if (!sectionMatches[match.sectionId]) {
                        sectionMatches[match.sectionId] = [];
                     }
                     sectionMatches[match.sectionId].push(match);
                  });
                  Object.keys(sectionMatches).forEach(sectionId => {
                     const section = document.getElementById(sectionId);
                     if (!section) return;
                     
                     sectionMatches[sectionId].forEach(match => {
                        section.appendChild(match.element);
                     });
                  });
                  if (query === "") {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     
                     let insertAfter = firstDivider;
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (section) {
                           insertAfter.insertAdjacentElement('afterend', section);
                           insertAfter = section;
                        }
                     });
                  } else {
                     const main = document.querySelector('main');
                     const h1 = main.querySelector('h1');
                     const firstDivider = main.querySelector('.section-divider');
                     const sectionsWithExactMatches = [];
                     const sectionsWithoutExactMatches = [];
                     
                     sectionOrder.forEach(sectionId => {
                        const section = document.getElementById(sectionId);
                        if (!section || !sectionMatches[sectionId]) return;
                        
                        const hasExactMatch = sectionMatches[sectionId].some(match => match.isExact);
                        if (hasExactMatch) {
                           sectionsWithExactMatches.push(section);
                        } else {
                           sectionsWithoutExactMatches.push(section);
                        }
                     });
                     let insertAfter = firstDivider;
                     [...sectionsWithExactMatches, ...sectionsWithoutExactMatches].forEach(section => {
                        insertAfter.insertAdjacentElement('afterend', section);
                        insertAfter = section;
                     });
                  }

                  updateSectionVisibility();
                  const symbolItems = Array.from(document.querySelectorAll('#symbolIndex li'));
                  const matchingSymbols = [];
                  
                  symbolItems.forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                              const isExactMatch = symbolName === query;
                              matchingSymbols.push({
                                 element: li,
                                 name: symbolName,
                                 isExact: isExactMatch
                              });
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
                  matchingSymbols.sort((a, b) => {
                     if (a.isExact && !b.isExact) return -1;
                     if (!a.isExact && b.isExact) return 1;
                     return a.name.localeCompare(b.name);
                  });
                  
                  const symbolIndex = document.getElementById('symbolIndex');
                  matchingSymbols.forEach(symbol => {
                     symbolIndex.appendChild(symbol.element);
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();
            deduplicateImports();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>