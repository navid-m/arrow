<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - printf</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>printf</code>
         </h1>
         <hr />
         
         <article class="global" data-name="doc">
            <h2>doc</h2>
            <hr />
            
            <pre><code>doc string</code></pre>
         </article>
         
         <article class="global" data-name="Analyzer">
            <h2>Analyzer</h2>
            <hr />
            
            <pre><code>Analyzer</code></pre>
         </article>
         
         <article class="global" data-name="KindNone">
            <h2>KindNone</h2>
            <hr />
            
            <pre><code>KindNone Kind</code></pre>
         </article>
         
         <article class="global" data-name="KindPrint">
            <h2>KindPrint</h2>
            <hr />
            
            <pre><code>KindPrint</code></pre>
         </article>
         
         <article class="global" data-name="KindPrintf">
            <h2>KindPrintf</h2>
            <hr />
            
            <pre><code>KindPrintf</code></pre>
         </article>
         
         <article class="global" data-name="KindErrorf">
            <h2>KindErrorf</h2>
            <hr />
            
            <pre><code>KindErrorf</code></pre>
         </article>
         
         <article class="global" data-name="isPrint">
            <h2>isPrint</h2>
            <hr />
            
            <p>isPrint records the print functions.
If a key ends in 'f' then it is assumed to be a formatted print.

Keys are either values returned by (*types.Func).FullName,
or case-insensitive identifiers such as "errorf".

The -funcs flag adds to this set.

The set below includes facts for many important standard library
functions, even though the analysis is capable of deducing that, for
example, fmt.Printf forwards to fmt.Fprintf. We avoid relying on the
driver applying analyzers to standard packages because "go vet" does
not do so with gccgo, and nor do some other build systems.</p>
            
            <pre><code>isPrint</code></pre>
         </article>
         
         <article class="global" data-name="argBool">
            <h2>argBool</h2>
            <hr />
            
            <pre><code>argBool printfArgType</code></pre>
         </article>
         
         <article class="global" data-name="argInt">
            <h2>argInt</h2>
            <hr />
            
            <pre><code>argInt</code></pre>
         </article>
         
         <article class="global" data-name="argRune">
            <h2>argRune</h2>
            <hr />
            
            <pre><code>argRune</code></pre>
         </article>
         
         <article class="global" data-name="argString">
            <h2>argString</h2>
            <hr />
            
            <pre><code>argString</code></pre>
         </article>
         
         <article class="global" data-name="argFloat">
            <h2>argFloat</h2>
            <hr />
            
            <pre><code>argFloat</code></pre>
         </article>
         
         <article class="global" data-name="argComplex">
            <h2>argComplex</h2>
            <hr />
            
            <pre><code>argComplex</code></pre>
         </article>
         
         <article class="global" data-name="argPointer">
            <h2>argPointer</h2>
            <hr />
            
            <pre><code>argPointer</code></pre>
         </article>
         
         <article class="global" data-name="argError">
            <h2>argError</h2>
            <hr />
            
            <pre><code>argError</code></pre>
         </article>
         
         <article class="global" data-name="anyType">
            <h2>anyType</h2>
            <hr />
            
            <pre><code>anyType printfArgType</code></pre>
         </article>
         
         <article class="global" data-name="noFlag">
            <h2>noFlag</h2>
            <hr />
            
            <p>Common flag sets for printf verbs.</p>
            
            <pre><code>noFlag</code></pre>
         </article>
         
         <article class="global" data-name="numFlag">
            <h2>numFlag</h2>
            <hr />
            
            <p>Common flag sets for printf verbs.</p>
            
            <pre><code>numFlag</code></pre>
         </article>
         
         <article class="global" data-name="sharpNumFlag">
            <h2>sharpNumFlag</h2>
            <hr />
            
            <p>Common flag sets for printf verbs.</p>
            
            <pre><code>sharpNumFlag</code></pre>
         </article>
         
         <article class="global" data-name="allFlags">
            <h2>allFlags</h2>
            <hr />
            
            <p>Common flag sets for printf verbs.</p>
            
            <pre><code>allFlags</code></pre>
         </article>
         
         <article class="global" data-name="printVerbs">
            <h2>printVerbs</h2>
            <hr />
            
            <p>printVerbs identifies which flags are known to printf for each verb.</p>
            
            <pre><code>printVerbs</code></pre>
         </article>
         
         <article class="global" data-name="printFormatRE">
            <h2>printFormatRE</h2>
            <hr />
            
            <p>printFormatRE is the regexp we match and report as a possible format string
in the first argument to unformatted prints like fmt.Print.
We exclude the space flag, so that printing a string like "x % y" is not reported as a format.</p>
            
            <pre><code>printFormatRE</code></pre>
         </article>
         
         <article class="global" data-name="flagsRE">
            <h2>flagsRE</h2>
            <hr />
            
            <pre><code>flagsRE</code></pre>
         </article>
         
         <article class="global" data-name="indexOptRE">
            <h2>indexOptRE</h2>
            <hr />
            
            <pre><code>indexOptRE</code></pre>
         </article>
         
         <article class="global" data-name="numOptRE">
            <h2>numOptRE</h2>
            <hr />
            
            <pre><code>numOptRE</code></pre>
         </article>
         
         <article class="global" data-name="verbRE">
            <h2>verbRE</h2>
            <hr />
            
            <pre><code>verbRE</code></pre>
         </article>
         
         <article class="global" data-name="suppressNonconstants">
            <h2>suppressNonconstants</h2>
            <hr />
            
            <p>suppressNonconstants suppresses reporting printf calls with
non-constant formatting strings (proposal #60529) when true.

This variable is to allow for staging the transition to newer
versions of x/tools by vendoring.

Remove this after the 1.24 release.</p>
            
            <pre><code>suppressNonconstants bool</code></pre>
         </article>
         
         <article class="global" data-name="errorType">
            <h2>errorType</h2>
            <hr />
            
            <pre><code>errorType</code></pre>
         </article>
          
         <article class="struct" data-name="Result">
            <h2>type Result struct</h2>
            <hr />
            
            <p>Result is the printf analyzer's result type. Clients may query the result
to learn whether a function behaves like fmt.Print or fmt.Printf.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">funcs *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="isWrapper">
            <h2>type isWrapper struct</h2>
            <hr />
            
            <p>isWrapper is a fact indicating that a function is a print or printf wrapper.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Kind Kind</code></pre>
         </article>
         
         <article class="struct" data-name="printfWrapper">
            <h2>type printfWrapper struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">obj *types.Func
fdecl *ast.FuncDecl
format *types.Var
args *types.Var
callers []printfCaller
failed bool</code></pre>
         </article>
         
         <article class="struct" data-name="printfCaller">
            <h2>type printfCaller struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">w *printfWrapper
call *ast.CallExpr</code></pre>
         </article>
         
         <article class="struct" data-name="formatState">
            <h2>type formatState struct</h2>
            <hr />
            
            <p>formatState holds the parsed representation of a printf directive such as "%3.*[4]d".
It is constructed by parsePrintfVerb.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">verb rune
format string
name string
flags []byte
argNums []int
firstArg int
pass *analysis.Pass
call *ast.CallExpr
argNum int
hasIndex bool
indexPending bool
nbytes int</code></pre>
         </article>
         
         <article class="struct" data-name="printVerb">
            <h2>type printVerb struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">verb rune
flags string
typ printfArgType</code></pre>
         </article>
         
         <article class="struct" data-name="argMatcher">
            <h2>type argMatcher struct</h2>
            <hr />
            
            <p>argMatcher recursively matches types against the printfArgType t.

To short-circuit recursion, it keeps track of types that have already been
matched (or are in the process of being matched) via the seen map. Recursion
arises from the compound types {map,chan,slice} which may be printed with %d
etc. if that is appropriate for their element types, as well as from type
parameters, which are expanded to the constituents of their type set.

The reason field may be set to report the cause of the mismatch.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">t printfArgType
seen *ast.MapType
reason string</code></pre>
         </article>
          
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Kind">
            <h2>Kind</h2>
            <hr />
            
            <p>Kind reports whether fn behaves like fmt.Print or fmt.Printf.</p>
            
            <pre><code>func Kind(fn *types.Func) Kind</code></pre>
         </article>
         
         <article class="function" data-name="AFact">
            <h2>AFact</h2>
            <hr />
            
            <pre><code>func AFact()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="run">
            <h2>run</h2>
            <hr />
            
            <pre><code>func run(pass *analysis.Pass) (any, error)</code></pre>
         </article>
         
         <article class="function" data-name="maybePrintfWrapper">
            <h2>maybePrintfWrapper</h2>
            <hr />
            
            <p>maybePrintfWrapper decides whether decl (a declared function) may be a wrapper
around a fmt.Printf or fmt.Print function. If so it returns a printfWrapper
function describing the declaration. Later processing will analyze the
graph of potential printf wrappers to pick out the ones that are true wrappers.
A function may be a Printf or Print wrapper if its last argument is ...interface{}.
If the next-to-last argument is a string, then this may be a Printf wrapper.
Otherwise it may be a Print wrapper.</p>
            
            <pre><code>func maybePrintfWrapper(info *types.Info, decl ast.Decl) *printfWrapper</code></pre>
         </article>
         
         <article class="function" data-name="findPrintfLike">
            <h2>findPrintfLike</h2>
            <hr />
            
            <p>findPrintfLike scans the entire package to find printf-like functions.</p>
            
            <pre><code>func findPrintfLike(pass *analysis.Pass, res *Result) (any, error)</code></pre>
         </article>
         
         <article class="function" data-name="match">
            <h2>match</h2>
            <hr />
            
            <pre><code>func match(info *types.Info, arg ast.Expr, param *types.Var) bool</code></pre>
         </article>
         
         <article class="function" data-name="checkPrintfFwd">
            <h2>checkPrintfFwd</h2>
            <hr />
            
            <p>checkPrintfFwd checks that a printf-forwarding wrapper is forwarding correctly.
It diagnoses writing fmt.Printf(format, args) instead of fmt.Printf(format, args...).</p>
            
            <pre><code>func checkPrintfFwd(pass *analysis.Pass, w *printfWrapper, call *ast.CallExpr, kind Kind, res *Result)</code></pre>
         </article>
         
         <article class="function" data-name="formatStringIndex">
            <h2>formatStringIndex</h2>
            <hr />
            
            <p>formatStringIndex returns the index of the format string (the last
non-variadic parameter) within the given printf-like call
expression, or -1 if unknown.</p>
            
            <pre><code>func formatStringIndex(pass *analysis.Pass, call *ast.CallExpr) int</code></pre>
         </article>
         
         <article class="function" data-name="stringConstantExpr">
            <h2>stringConstantExpr</h2>
            <hr />
            
            <p>stringConstantExpr returns expression's string constant value.

("", false) is returned if expression isn't a string
constant.</p>
            
            <pre><code>func stringConstantExpr(pass *analysis.Pass, expr ast.Expr) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="checkCalls">
            <h2>checkCalls</h2>
            <hr />
            
            <p>checkCalls triggers the print-specific checks for calls that invoke a print
function.</p>
            
            <pre><code>func checkCalls(pass *analysis.Pass)</code></pre>
         </article>
         
         <article class="function" data-name="printfNameAndKind">
            <h2>printfNameAndKind</h2>
            <hr />
            
            <pre><code>func printfNameAndKind(pass *analysis.Pass, call *ast.CallExpr) (fn *types.Func, kind Kind)</code></pre>
         </article>
         
         <article class="function" data-name="isFormatter">
            <h2>isFormatter</h2>
            <hr />
            
            <p>isFormatter reports whether t could satisfy fmt.Formatter.
The only interface method to look for is "Format(State, rune)".</p>
            
            <pre><code>func isFormatter(typ types.Type) bool</code></pre>
         </article>
         
         <article class="function" data-name="checkPrintf">
            <h2>checkPrintf</h2>
            <hr />
            
            <p>checkPrintf checks a call to a formatted print routine such as Printf.</p>
            
            <pre><code>func checkPrintf(pass *analysis.Pass, fileVersion string, kind Kind, call *ast.CallExpr, fn *types.Func)</code></pre>
         </article>
         
         <article class="function" data-name="parseFlags">
            <h2>parseFlags</h2>
            <hr />
            
            <p>parseFlags accepts any printf flags.</p>
            
            <pre><code>func parseFlags()</code></pre>
         </article>
         
         <article class="function" data-name="scanNum">
            <h2>scanNum</h2>
            <hr />
            
            <p>scanNum advances through a decimal number if present.</p>
            
            <pre><code>func scanNum()</code></pre>
         </article>
         
         <article class="function" data-name="parseIndex">
            <h2>parseIndex</h2>
            <hr />
            
            <p>parseIndex scans an index expression. It returns false if there is a syntax error.</p>
            
            <pre><code>func parseIndex() bool</code></pre>
         </article>
         
         <article class="function" data-name="parseNum">
            <h2>parseNum</h2>
            <hr />
            
            <p>parseNum scans a width or precision (or *). It returns false if there's a bad index expression.</p>
            
            <pre><code>func parseNum() bool</code></pre>
         </article>
         
         <article class="function" data-name="parsePrecision">
            <h2>parsePrecision</h2>
            <hr />
            
            <p>parsePrecision scans for a precision. It returns false if there's a bad index expression.</p>
            
            <pre><code>func parsePrecision() bool</code></pre>
         </article>
         
         <article class="function" data-name="parsePrintfVerb">
            <h2>parsePrintfVerb</h2>
            <hr />
            
            <p>parsePrintfVerb looks the formatting directive that begins the format string
and returns a formatState that encodes what the directive wants, without looking
at the actual arguments present in the call. The result is nil if there is an error.</p>
            
            <pre><code>func parsePrintfVerb(pass *analysis.Pass, call *ast.CallExpr, name string, format string, firstArg int, argNum int) *formatState</code></pre>
         </article>
         
         <article class="function" data-name="okPrintfArg">
            <h2>okPrintfArg</h2>
            <hr />
            
            <p>okPrintfArg compares the formatState to the arguments actually present,
reporting any discrepancies it can discern. If the final argument is ellipsissed,
there's little it can do for that.</p>
            
            <pre><code>func okPrintfArg(pass *analysis.Pass, call *ast.CallExpr, state *formatState) ok bool</code></pre>
         </article>
         
         <article class="function" data-name="recursiveStringer">
            <h2>recursiveStringer</h2>
            <hr />
            
            <p>recursiveStringer reports whether the argument e is a potential
recursive call to stringer or is an error, such as t and &t in these examples:

	func (t *T) String() string { printf("%s",  t) }
	func (t  T) Error() string { printf("%s",  t) }
	func (t  T) String() string { printf("%s", &t) }</p>
            
            <pre><code>func recursiveStringer(pass *analysis.Pass, e ast.Expr) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="isStringer">
            <h2>isStringer</h2>
            <hr />
            
            <p>isStringer reports whether the method signature matches the String() definition in fmt.Stringer.</p>
            
            <pre><code>func isStringer(sig *types.Signature) bool</code></pre>
         </article>
         
         <article class="function" data-name="isFunctionValue">
            <h2>isFunctionValue</h2>
            <hr />
            
            <p>isFunctionValue reports whether the expression is a function as opposed to a function call.
It is almost always a mistake to print a function value.</p>
            
            <pre><code>func isFunctionValue(pass *analysis.Pass, e ast.Expr) bool</code></pre>
         </article>
         
         <article class="function" data-name="argCanBeChecked">
            <h2>argCanBeChecked</h2>
            <hr />
            
            <p>argCanBeChecked reports whether the specified argument is statically present;
it may be beyond the list of arguments or in a terminal slice... argument, which
means we can't see it.</p>
            
            <pre><code>func argCanBeChecked(pass *analysis.Pass, call *ast.CallExpr, formatArg int, state *formatState) bool</code></pre>
         </article>
         
         <article class="function" data-name="checkPrint">
            <h2>checkPrint</h2>
            <hr />
            
            <p>checkPrint checks a call to an unformatted print routine such as Println.</p>
            
            <pre><code>func checkPrint(pass *analysis.Pass, call *ast.CallExpr, fn *types.Func)</code></pre>
         </article>
         
         <article class="function" data-name="count">
            <h2>count</h2>
            <hr />
            
            <p>count(n, what) returns "1 what" or "N whats"
(assuming the plural of what is whats).</p>
            
            <pre><code>func count(n int, what string) string</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(flag string) error</code></pre>
         </article>
         
         <article class="function" data-name="matchArgType">
            <h2>matchArgType</h2>
            <hr />
            
            <p>matchArgType reports an error if printf verb t is not appropriate for
operand arg.

If arg is a type parameter, the verb t must be appropriate for every type in
the type parameter type set.</p>
            
            <pre><code>func matchArgType(pass *analysis.Pass, t printfArgType, arg ast.Expr) (reason string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="match">
            <h2>match</h2>
            <hr />
            
            <p>match checks if typ matches m's printf arg type. If topLevel is true, typ is
the actual type of the printf arg, for which special rules apply. As a
special case, top level type parameters pass topLevel=true when checking for
matches among the constituents of their type set, as type arguments will
replace the type parameter at compile time.</p>
            
            <pre><code>func match(typ types.Type, topLevel bool) bool</code></pre>
         </article>
         
         <article class="function" data-name="isConvertibleToString">
            <h2>isConvertibleToString</h2>
            <hr />
            
            <pre><code>func isConvertibleToString(typ types.Type) bool</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
