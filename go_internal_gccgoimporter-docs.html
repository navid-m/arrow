<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - gccgoimporter</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="go_internal_gccgoimporter_testdata-docs.html">testdata</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>gccgoimporter</code>
         </h1>
         <hr />
         
         <article class="global" data-name="typeParserTests">
            <h2>typeParserTests</h2>
            <hr />
            
            <pre><code>typeParserTests</code></pre>
         </article>
         
         <article class="global" data-name="armag">
            <h2>armag</h2>
            <hr />
            
            <p>Magic strings for different archive file formats.</p>
            
            <pre><code>armag</code></pre>
         </article>
         
         <article class="global" data-name="armagt">
            <h2>armagt</h2>
            <hr />
            
            <p>Magic strings for different archive file formats.</p>
            
            <pre><code>armagt</code></pre>
         </article>
         
         <article class="global" data-name="armagb">
            <h2>armagb</h2>
            <hr />
            
            <p>Magic strings for different archive file formats.</p>
            
            <pre><code>armagb</code></pre>
         </article>
         
         <article class="global" data-name="arNameOff">
            <h2>arNameOff</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arNameOff</code></pre>
         </article>
         
         <article class="global" data-name="arNameSize">
            <h2>arNameSize</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arNameSize</code></pre>
         </article>
         
         <article class="global" data-name="arDateOff">
            <h2>arDateOff</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arDateOff</code></pre>
         </article>
         
         <article class="global" data-name="arDateSize">
            <h2>arDateSize</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arDateSize</code></pre>
         </article>
         
         <article class="global" data-name="arUIDOff">
            <h2>arUIDOff</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arUIDOff</code></pre>
         </article>
         
         <article class="global" data-name="arUIDSize">
            <h2>arUIDSize</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arUIDSize</code></pre>
         </article>
         
         <article class="global" data-name="arGIDOff">
            <h2>arGIDOff</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arGIDOff</code></pre>
         </article>
         
         <article class="global" data-name="arGIDSize">
            <h2>arGIDSize</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arGIDSize</code></pre>
         </article>
         
         <article class="global" data-name="arModeOff">
            <h2>arModeOff</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arModeOff</code></pre>
         </article>
         
         <article class="global" data-name="arModeSize">
            <h2>arModeSize</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arModeSize</code></pre>
         </article>
         
         <article class="global" data-name="arSizeOff">
            <h2>arSizeOff</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arSizeOff</code></pre>
         </article>
         
         <article class="global" data-name="arSizeSize">
            <h2>arSizeSize</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arSizeSize</code></pre>
         </article>
         
         <article class="global" data-name="arFmagOff">
            <h2>arFmagOff</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arFmagOff</code></pre>
         </article>
         
         <article class="global" data-name="arFmagSize">
            <h2>arFmagSize</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arFmagSize</code></pre>
         </article>
         
         <article class="global" data-name="arHdrSize">
            <h2>arHdrSize</h2>
            <hr />
            
            <p>Offsets and sizes for fields in a standard archive header.</p>
            
            <pre><code>arHdrSize</code></pre>
         </article>
         
         <article class="global" data-name="arfmag">
            <h2>arfmag</h2>
            <hr />
            
            <p>The contents of the fmag field of a standard archive header.</p>
            
            <pre><code>arfmag</code></pre>
         </article>
         
         <article class="global" data-name="importablePackages">
            <h2>importablePackages</h2>
            <hr />
            
            <p>importablePackages is a list of packages that we verify that we can
import. This should be all standard library packages in all relevant
versions of gccgo. Note that since gccgo follows a different release
cycle, and since different systems have different versions installed,
we can't use the last-two-versions rule of the gc toolchain.</p>
            
            <pre><code>importablePackages</code></pre>
         </article>
         
         <article class="global" data-name="gccgov1Magic">
            <h2>gccgov1Magic</h2>
            <hr />
            
            <pre><code>gccgov1Magic</code></pre>
         </article>
         
         <article class="global" data-name="gccgov2Magic">
            <h2>gccgov2Magic</h2>
            <hr />
            
            <pre><code>gccgov2Magic</code></pre>
         </article>
         
         <article class="global" data-name="gccgov3Magic">
            <h2>gccgov3Magic</h2>
            <hr />
            
            <pre><code>gccgov3Magic</code></pre>
         </article>
         
         <article class="global" data-name="goimporterMagic">
            <h2>goimporterMagic</h2>
            <hr />
            
            <pre><code>goimporterMagic</code></pre>
         </article>
         
         <article class="global" data-name="archiveMagic">
            <h2>archiveMagic</h2>
            <hr />
            
            <pre><code>archiveMagic</code></pre>
         </article>
         
         <article class="global" data-name="aixbigafMagic">
            <h2>aixbigafMagic</h2>
            <hr />
            
            <pre><code>aixbigafMagic</code></pre>
         </article>
         
         <article class="global" data-name="importerTests">
            <h2>importerTests</h2>
            <hr />
            
            <p>When adding tests to this list, be sure to set the 'gccgoVersion'
field if the testcases uses a "recent" Go addition (ex: aliases).</p>
            
            <pre><code>importerTests</code></pre>
         </article>
         
         <article class="global" data-name="reserved">
            <h2>reserved</h2>
            <hr />
            
            <p>reserved is a singleton type used to fill type map slots that have
been reserved (i.e., for which a type number has been parsed) but
which don't have their actual type yet. When the type map is updated,
the actual type must replace a reserved entry (or we have an internal
error). Used for self-verification only - not required for correctness.</p>
            
            <pre><code>reserved</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinINT8">
            <h2>gccgoBuiltinINT8</h2>
            <hr />
            
            <p>From gofrontend/go/export.h
Note that these values are negative in the gofrontend and have been made positive
in the gccgoimporter.</p>
            
            <pre><code>gccgoBuiltinINT8</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinINT16">
            <h2>gccgoBuiltinINT16</h2>
            <hr />
            
            <pre><code>gccgoBuiltinINT16</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinINT32">
            <h2>gccgoBuiltinINT32</h2>
            <hr />
            
            <pre><code>gccgoBuiltinINT32</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinINT64">
            <h2>gccgoBuiltinINT64</h2>
            <hr />
            
            <pre><code>gccgoBuiltinINT64</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinUINT8">
            <h2>gccgoBuiltinUINT8</h2>
            <hr />
            
            <pre><code>gccgoBuiltinUINT8</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinUINT16">
            <h2>gccgoBuiltinUINT16</h2>
            <hr />
            
            <pre><code>gccgoBuiltinUINT16</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinUINT32">
            <h2>gccgoBuiltinUINT32</h2>
            <hr />
            
            <pre><code>gccgoBuiltinUINT32</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinUINT64">
            <h2>gccgoBuiltinUINT64</h2>
            <hr />
            
            <pre><code>gccgoBuiltinUINT64</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinFLOAT32">
            <h2>gccgoBuiltinFLOAT32</h2>
            <hr />
            
            <pre><code>gccgoBuiltinFLOAT32</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinFLOAT64">
            <h2>gccgoBuiltinFLOAT64</h2>
            <hr />
            
            <pre><code>gccgoBuiltinFLOAT64</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinINT">
            <h2>gccgoBuiltinINT</h2>
            <hr />
            
            <pre><code>gccgoBuiltinINT</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinUINT">
            <h2>gccgoBuiltinUINT</h2>
            <hr />
            
            <pre><code>gccgoBuiltinUINT</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinUINTPTR">
            <h2>gccgoBuiltinUINTPTR</h2>
            <hr />
            
            <pre><code>gccgoBuiltinUINTPTR</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinBOOL">
            <h2>gccgoBuiltinBOOL</h2>
            <hr />
            
            <pre><code>gccgoBuiltinBOOL</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinSTRING">
            <h2>gccgoBuiltinSTRING</h2>
            <hr />
            
            <pre><code>gccgoBuiltinSTRING</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinCOMPLEX64">
            <h2>gccgoBuiltinCOMPLEX64</h2>
            <hr />
            
            <pre><code>gccgoBuiltinCOMPLEX64</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinCOMPLEX128">
            <h2>gccgoBuiltinCOMPLEX128</h2>
            <hr />
            
            <pre><code>gccgoBuiltinCOMPLEX128</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinERROR">
            <h2>gccgoBuiltinERROR</h2>
            <hr />
            
            <pre><code>gccgoBuiltinERROR</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinBYTE">
            <h2>gccgoBuiltinBYTE</h2>
            <hr />
            
            <pre><code>gccgoBuiltinBYTE</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinRUNE">
            <h2>gccgoBuiltinRUNE</h2>
            <hr />
            
            <pre><code>gccgoBuiltinRUNE</code></pre>
         </article>
         
         <article class="global" data-name="gccgoBuiltinANY">
            <h2>gccgoBuiltinANY</h2>
            <hr />
            
            <pre><code>gccgoBuiltinANY</code></pre>
         </article>
          
         <article class="struct" data-name="seekerReadAt">
            <h2>type seekerReadAt struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">seeker io.ReadSeeker</code></pre>
         </article>
         
         <article class="struct" data-name="GccgoInstallation">
            <h2>type GccgoInstallation struct</h2>
            <hr />
            
            <p>Information about a specific installation of gccgo.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">GccVersion string
TargetTriple string
LibPaths []string</code></pre>
         </article>
         
         <article class="struct" data-name="PackageInit">
            <h2>type PackageInit struct</h2>
            <hr />
            
            <p>A PackageInit describes an imported package that needs initialization.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Name string
InitFunc string
Priority int</code></pre>
         </article>
         
         <article class="struct" data-name="InitData">
            <h2>type InitData struct</h2>
            <hr />
            
            <p>The gccgo-specific init data for a package.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Priority int
Inits []PackageInit</code></pre>
         </article>
         
         <article class="struct" data-name="importerTest">
            <h2>type importerTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkgpath string
name string
want string
wantval string
wantinits []string
gccgoVersion int</code></pre>
         </article>
         
         <article class="struct" data-name="parser">
            <h2>type parser struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">scanner *scanner.Scanner
version string
tok rune
lit string
pkgpath string
pkgname string
pkg *types.Package
imports *ast.MapType
typeList []types.Type
typeData []string
fixups []fixupRecord
initdata InitData
aliases *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="fixupRecord">
            <h2>type fixupRecord struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">toUpdate *types.Named
target types.Type</code></pre>
         </article>
         
         <article class="struct" data-name="importError">
            <h2>type importError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pos scanner.Position
err error</code></pre>
         </article>
          
         <article class="function" data-name="TestTypeParser">
            <h2>TestTypeParser</h2>
            <hr />
            
            <pre><code>func TestTypeParser(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="arExportData">
            <h2>arExportData</h2>
            <hr />
            
            <p>arExportData takes an archive file and returns a ReadSeeker for the
export data in that file. This assumes that there is only one
object in the archive containing export data, which is not quite
what gccgo does; gccgo concatenates together all the export data
for all the objects in the file.  In practice that case does not arise.</p>
            
            <pre><code>func arExportData(archive io.ReadSeeker) (io.ReadSeeker, error)</code></pre>
         </article>
         
         <article class="function" data-name="standardArExportData">
            <h2>standardArExportData</h2>
            <hr />
            
            <p>standardArExportData returns export data from a standard archive.</p>
            
            <pre><code>func standardArExportData(archive io.ReadSeeker) (io.ReadSeeker, error)</code></pre>
         </article>
         
         <article class="function" data-name="elfFromAr">
            <h2>elfFromAr</h2>
            <hr />
            
            <p>elfFromAr tries to get export data from an archive member as an ELF file.
If there is no export data, this returns nil, nil.</p>
            
            <pre><code>func elfFromAr(member *io.SectionReader) (io.ReadSeeker, error)</code></pre>
         </article>
         
         <article class="function" data-name="aixBigArExportData">
            <h2>aixBigArExportData</h2>
            <hr />
            
            <p>aixBigArExportData returns export data from an AIX big archive.</p>
            
            <pre><code>func aixBigArExportData(archive io.ReadSeeker) (io.ReadSeeker, error)</code></pre>
         </article>
         
         <article class="function" data-name="readerAtFromSeeker">
            <h2>readerAtFromSeeker</h2>
            <hr />
            
            <p>readerAtFromSeeker turns an io.ReadSeeker into an io.ReaderAt.
This is only safe because there won't be any concurrent seeks
while this code is executing.</p>
            
            <pre><code>func readerAtFromSeeker(rs io.ReadSeeker) io.ReaderAt</code></pre>
         </article>
         
         <article class="function" data-name="ReadAt">
            <h2>ReadAt</h2>
            <hr />
            
            <pre><code>func ReadAt(p []byte, off int64) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="InitFromDriver">
            <h2>InitFromDriver</h2>
            <hr />
            
            <p>Ask the driver at the given path for information for this GccgoInstallation.
The given arguments are passed directly to the call of the driver.</p>
            
            <pre><code>func InitFromDriver(gccgoPath string, args ...string) err error</code></pre>
         </article>
         
         <article class="function" data-name="SearchPaths">
            <h2>SearchPaths</h2>
            <hr />
            
            <p>Return the list of export search paths for this GccgoInstallation.</p>
            
            <pre><code>func SearchPaths() paths []string</code></pre>
         </article>
         
         <article class="function" data-name="GetImporter">
            <h2>GetImporter</h2>
            <hr />
            
            <p>Return an importer that searches incpaths followed by the gcc installation's
built-in search paths and the current directory.</p>
            
            <pre><code>func GetImporter(incpaths []string, initmap *ast.MapType) Importer</code></pre>
         </article>
         
         <article class="function" data-name="TestInstallationImporter">
            <h2>TestInstallationImporter</h2>
            <hr />
            
            <pre><code>func TestInstallationImporter(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="findExportFile">
            <h2>findExportFile</h2>
            <hr />
            
            <p>Locate the file from which to read export data.
This is intended to replicate the logic in gofrontend.</p>
            
            <pre><code>func findExportFile(searchpaths []string, pkgpath string) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="openExportFile">
            <h2>openExportFile</h2>
            <hr />
            
            <p>Opens the export data file at the given path. If this is an ELF file,
searches for and opens the .go_export section. If this is an archive,
reads the export data from the first member, which is assumed to be an ELF file.
This is intended to replicate the logic in gofrontend.</p>
            
            <pre><code>func openExportFile(fpath string) (reader io.ReadSeeker, closer io.Closer, err error)</code></pre>
         </article>
         
         <article class="function" data-name="GetImporter">
            <h2>GetImporter</h2>
            <hr />
            
            <pre><code>func GetImporter(searchpaths []string, initmap *ast.MapType) Importer</code></pre>
         </article>
         
         <article class="function" data-name="readMagic">
            <h2>readMagic</h2>
            <hr />
            
            <p>readMagic reads the four bytes at the start of a ReadSeeker and
returns them as a string.</p>
            
            <pre><code>func readMagic(reader io.ReadSeeker) (string, error)</code></pre>
         </article>
         
         <article class="function" data-name="runImporterTest">
            <h2>runImporterTest</h2>
            <hr />
            
            <pre><code>func runImporterTest(t *testing.T, imp Importer, initmap *ast.MapType, test *importerTest)</code></pre>
         </article>
         
         <article class="function" data-name="TestGoxImporter">
            <h2>TestGoxImporter</h2>
            <hr />
            
            <pre><code>func TestGoxImporter(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="gccgoPath">
            <h2>gccgoPath</h2>
            <hr />
            
            <p>gccgoPath returns a path to gccgo if it is present (either in
path or specified via GCCGO environment variable), or an
empty string if no gccgo is available.</p>
            
            <pre><code>func gccgoPath() string</code></pre>
         </article>
         
         <article class="function" data-name="TestObjImporter">
            <h2>TestObjImporter</h2>
            <hr />
            
            <pre><code>func TestObjImporter(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init(filename string, src io.Reader, imports *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="initScanner">
            <h2>initScanner</h2>
            <hr />
            
            <pre><code>func initScanner(filename string, src io.Reader)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="error">
            <h2>error</h2>
            <hr />
            
            <pre><code>func error(err any)</code></pre>
         </article>
         
         <article class="function" data-name="errorf">
            <h2>errorf</h2>
            <hr />
            
            <pre><code>func errorf(format string, args ...any)</code></pre>
         </article>
         
         <article class="function" data-name="expect">
            <h2>expect</h2>
            <hr />
            
            <pre><code>func expect(tok rune) string</code></pre>
         </article>
         
         <article class="function" data-name="expectEOL">
            <h2>expectEOL</h2>
            <hr />
            
            <pre><code>func expectEOL()</code></pre>
         </article>
         
         <article class="function" data-name="expectKeyword">
            <h2>expectKeyword</h2>
            <hr />
            
            <pre><code>func expectKeyword(keyword string)</code></pre>
         </article>
         
         <article class="function" data-name="parseString">
            <h2>parseString</h2>
            <hr />
            
            <pre><code>func parseString() string</code></pre>
         </article>
         
         <article class="function" data-name="parseUnquotedString">
            <h2>parseUnquotedString</h2>
            <hr />
            
            <p>unquotedString     = { unquotedStringChar } .
unquotedStringChar = <neither a whitespace nor a ';' char> .</p>
            
            <pre><code>func parseUnquotedString() string</code></pre>
         </article>
         
         <article class="function" data-name="next">
            <h2>next</h2>
            <hr />
            
            <pre><code>func next()</code></pre>
         </article>
         
         <article class="function" data-name="parseQualifiedName">
            <h2>parseQualifiedName</h2>
            <hr />
            
            <pre><code>func parseQualifiedName() (path string, name string)</code></pre>
         </article>
         
         <article class="function" data-name="parseUnquotedQualifiedName">
            <h2>parseUnquotedQualifiedName</h2>
            <hr />
            
            <pre><code>func parseUnquotedQualifiedName() (path string, name string)</code></pre>
         </article>
         
         <article class="function" data-name="parseQualifiedNameStr">
            <h2>parseQualifiedNameStr</h2>
            <hr />
            
            <p>qualifiedName = [ ["."] unquotedString "." ] unquotedString .

The above production uses greedy matching.</p>
            
            <pre><code>func parseQualifiedNameStr(unquotedName string) (pkgpath string, name string)</code></pre>
         </article>
         
         <article class="function" data-name="getPkg">
            <h2>getPkg</h2>
            <hr />
            
            <p>getPkg returns the package for a given path. If the package is
not found but we have a package name, create the package and
add it to the p.imports map.</p>
            
            <pre><code>func getPkg(pkgpath string, name string) *types.Package</code></pre>
         </article>
         
         <article class="function" data-name="parseExportedName">
            <h2>parseExportedName</h2>
            <hr />
            
            <p>parseExportedName is like parseQualifiedName, but
the package path is resolved to an imported *types.Package.

ExportedName = string [string] .</p>
            
            <pre><code>func parseExportedName() (pkg *types.Package, name string)</code></pre>
         </article>
         
         <article class="function" data-name="parseName">
            <h2>parseName</h2>
            <hr />
            
            <p>Name = QualifiedName | "?" .</p>
            
            <pre><code>func parseName() string</code></pre>
         </article>
         
         <article class="function" data-name="deref">
            <h2>deref</h2>
            <hr />
            
            <pre><code>func deref(typ types.Type) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="parseField">
            <h2>parseField</h2>
            <hr />
            
            <p>Field = Name Type [string] .</p>
            
            <pre><code>func parseField(pkg *types.Package) (field *types.Var, tag string)</code></pre>
         </article>
         
         <article class="function" data-name="parseParam">
            <h2>parseParam</h2>
            <hr />
            
            <p>Param = Name ["..."] Type .</p>
            
            <pre><code>func parseParam(pkg *types.Package) (param *types.Var, isVariadic bool)</code></pre>
         </article>
         
         <article class="function" data-name="parseVar">
            <h2>parseVar</h2>
            <hr />
            
            <p>Var = Name Type .</p>
            
            <pre><code>func parseVar(pkg *types.Package) *types.Var</code></pre>
         </article>
         
         <article class="function" data-name="parseConversion">
            <h2>parseConversion</h2>
            <hr />
            
            <p>Conversion = "convert" "(" Type "," ConstValue ")" .</p>
            
            <pre><code>func parseConversion(pkg *types.Package) (val constant.Value, typ types.Type)</code></pre>
         </article>
         
         <article class="function" data-name="parseConstValue">
            <h2>parseConstValue</h2>
            <hr />
            
            <p>ConstValue     = string | "false" | "true" | ["-"] (int ["'"] | FloatOrComplex) | Conversion .
FloatOrComplex = float ["i" | ("+"|"-") float "i"] .</p>
            
            <pre><code>func parseConstValue(pkg *types.Package) (val constant.Value, typ types.Type)</code></pre>
         </article>
         
         <article class="function" data-name="parseConst">
            <h2>parseConst</h2>
            <hr />
            
            <p>Const = Name [Type] "=" ConstValue .</p>
            
            <pre><code>func parseConst(pkg *types.Package) *types.Const</code></pre>
         </article>
         
         <article class="function" data-name="reserve">
            <h2>reserve</h2>
            <hr />
            
            <p>reserve reserves the type map entry n for future use.</p>
            
            <pre><code>func reserve(n int)</code></pre>
         </article>
         
         <article class="function" data-name="update">
            <h2>update</h2>
            <hr />
            
            <p>update sets the type map entries for the entries in nlist to t.
An entry in nlist can be a type number in p.typeList,
used to resolve named types, or it can be a *types.Pointer,
used to resolve pointers to named types in case they are referenced
by embedded fields.</p>
            
            <pre><code>func update(t types.Type, nlist []any)</code></pre>
         </article>
         
         <article class="function" data-name="parseNamedType">
            <h2>parseNamedType</h2>
            <hr />
            
            <p>NamedType = TypeName [ "=" ] Type { Method } .
TypeName  = ExportedName .
Method    = "func" "(" Param ")" Name ParamList ResultList [InlineBody] ";" .</p>
            
            <pre><code>func parseNamedType(nlist []any) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="parseInt64">
            <h2>parseInt64</h2>
            <hr />
            
            <pre><code>func parseInt64() int64</code></pre>
         </article>
         
         <article class="function" data-name="parseInt">
            <h2>parseInt</h2>
            <hr />
            
            <pre><code>func parseInt() int</code></pre>
         </article>
         
         <article class="function" data-name="parseArrayOrSliceType">
            <h2>parseArrayOrSliceType</h2>
            <hr />
            
            <p>ArrayOrSliceType = "[" [ int ] "]" Type .</p>
            
            <pre><code>func parseArrayOrSliceType(pkg *types.Package, nlist []any) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="parseMapType">
            <h2>parseMapType</h2>
            <hr />
            
            <p>MapType = "map" "[" Type "]" Type .</p>
            
            <pre><code>func parseMapType(pkg *types.Package, nlist []any) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="parseChanType">
            <h2>parseChanType</h2>
            <hr />
            
            <p>ChanType = "chan" ["<-" | "-<"] Type .</p>
            
            <pre><code>func parseChanType(pkg *types.Package, nlist []any) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="parseStructType">
            <h2>parseStructType</h2>
            <hr />
            
            <p>StructType = "struct" "{" { Field } "}" .</p>
            
            <pre><code>func parseStructType(pkg *types.Package, nlist []any) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="parseParamList">
            <h2>parseParamList</h2>
            <hr />
            
            <p>ParamList = "(" [ { Parameter "," } Parameter ] ")" .</p>
            
            <pre><code>func parseParamList(pkg *types.Package) (*types.Tuple, bool)</code></pre>
         </article>
         
         <article class="function" data-name="parseResultList">
            <h2>parseResultList</h2>
            <hr />
            
            <p>ResultList = Type | ParamList .</p>
            
            <pre><code>func parseResultList(pkg *types.Package) *types.Tuple</code></pre>
         </article>
         
         <article class="function" data-name="parseFunctionType">
            <h2>parseFunctionType</h2>
            <hr />
            
            <p>FunctionType = ParamList ResultList .</p>
            
            <pre><code>func parseFunctionType(pkg *types.Package, nlist []any) *types.Signature</code></pre>
         </article>
         
         <article class="function" data-name="parseFunc">
            <h2>parseFunc</h2>
            <hr />
            
            <p>Func = Name FunctionType [InlineBody] .</p>
            
            <pre><code>func parseFunc(pkg *types.Package) *types.Func</code></pre>
         </article>
         
         <article class="function" data-name="parseInterfaceType">
            <h2>parseInterfaceType</h2>
            <hr />
            
            <p>InterfaceType = "interface" "{" { ("?" Type | Func) ";" } "}" .</p>
            
            <pre><code>func parseInterfaceType(pkg *types.Package, nlist []any) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="parsePointerType">
            <h2>parsePointerType</h2>
            <hr />
            
            <p>PointerType = "*" ("any" | Type) .</p>
            
            <pre><code>func parsePointerType(pkg *types.Package, nlist []any) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="parseTypeSpec">
            <h2>parseTypeSpec</h2>
            <hr />
            
            <p>TypeSpec = NamedType | MapType | ChanType | StructType | InterfaceType | PointerType | ArrayOrSliceType | FunctionType .</p>
            
            <pre><code>func parseTypeSpec(pkg *types.Package, nlist []any) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="lookupBuiltinType">
            <h2>lookupBuiltinType</h2>
            <hr />
            
            <pre><code>func lookupBuiltinType(typ int) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="parseType">
            <h2>parseType</h2>
            <hr />
            
            <p>Type = "<" "type" ( "-" int | int [ TypeSpec ] ) ">" .

parseType updates the type map to t for all type numbers n.</p>
            
            <pre><code>func parseType(pkg *types.Package, n ...any) types.Type</code></pre>
         </article>
         
         <article class="function" data-name="parseTypeAfterAngle">
            <h2>parseTypeAfterAngle</h2>
            <hr />
            
            <p>(*parser).Type after reading the "<".</p>
            
            <pre><code>func parseTypeAfterAngle(pkg *types.Package, n ...any) (t types.Type, n1 int)</code></pre>
         </article>
         
         <article class="function" data-name="parseTypeExtended">
            <h2>parseTypeExtended</h2>
            <hr />
            
            <p>parseTypeExtended is identical to parseType, but if the type in
question is a saved type, returns the index as well as the type
pointer (index returned is zero if we parsed a builtin).</p>
            
            <pre><code>func parseTypeExtended(pkg *types.Package, n ...any) (t types.Type, n1 int)</code></pre>
         </article>
         
         <article class="function" data-name="skipInlineBody">
            <h2>skipInlineBody</h2>
            <hr />
            
            <p>InlineBody = "<inl:NN>" .{NN}
Reports whether a body was skipped.</p>
            
            <pre><code>func skipInlineBody()</code></pre>
         </article>
         
         <article class="function" data-name="parseTypes">
            <h2>parseTypes</h2>
            <hr />
            
            <p>Types = "types" maxp1 exportedp1 (offset length)* .</p>
            
            <pre><code>func parseTypes(pkg *types.Package)</code></pre>
         </article>
         
         <article class="function" data-name="parseSavedType">
            <h2>parseSavedType</h2>
            <hr />
            
            <p>parseSavedType parses one saved type definition.</p>
            
            <pre><code>func parseSavedType(pkg *types.Package, i int, nlist []any)</code></pre>
         </article>
         
         <article class="function" data-name="parsePackageInit">
            <h2>parsePackageInit</h2>
            <hr />
            
            <p>PackageInit = unquotedString unquotedString int .</p>
            
            <pre><code>func parsePackageInit() PackageInit</code></pre>
         </article>
         
         <article class="function" data-name="maybeCreatePackage">
            <h2>maybeCreatePackage</h2>
            <hr />
            
            <p>Create the package if we have parsed both the package path and package name.</p>
            
            <pre><code>func maybeCreatePackage()</code></pre>
         </article>
         
         <article class="function" data-name="parseInitDataDirective">
            <h2>parseInitDataDirective</h2>
            <hr />
            
            <p>InitDataDirective = ( "v1" | "v2" | "v3" ) ";" |

	"priority" int ";" |
	"init" { PackageInit } ";" |
	"checksum" unquotedString ";" .</p>
            
            <pre><code>func parseInitDataDirective()</code></pre>
         </article>
         
         <article class="function" data-name="parseDirective">
            <h2>parseDirective</h2>
            <hr />
            
            <p>Directive = InitDataDirective |

	"package" unquotedString [ unquotedString ] [ unquotedString ] ";" |
	"pkgpath" unquotedString ";" |
	"prefix" unquotedString ";" |
	"import" unquotedString unquotedString string ";" |
	"indirectimport" unquotedString unquotedstring ";" |
	"func" Func ";" |
	"type" Type ";" |
	"var" Var ";" |
	"const" Const ";" .</p>
            
            <pre><code>func parseDirective()</code></pre>
         </article>
         
         <article class="function" data-name="parsePackage">
            <h2>parsePackage</h2>
            <hr />
            
            <p>Package = { Directive } .</p>
            
            <pre><code>func parsePackage() *types.Package</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
