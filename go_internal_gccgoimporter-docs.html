<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - gccgoimporter</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>gccgoimporter</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"debug/elf"
"errors"
"fmt"
"internal/xcoff"
"io"
"strconv"
"strings"
"bufio"
"go/types"
"os"
"os/exec"
"path/filepath"
"strings"
"bytes"
"debug/elf"
"fmt"
"go/types"
"internal/xcoff"
"io"
"os"
"path/filepath"
"strings"
"errors"
"fmt"
"go/constant"
"go/token"
"go/types"
"io"
"strconv"
"strings"
"text/scanner"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="aixbigafMagic">
               <h3>
                  aixbigafMagic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const aixbigafMagic = "<big"</code></pre>
            </article>
            
            <article class="global" data-name="arDateOff">
               <h3>
                  arDateOff 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arDateOff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="arDateSize">
               <h3>
                  arDateSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arDateSize = 12</code></pre>
            </article>
            
            <article class="global" data-name="arFmagOff">
               <h3>
                  arFmagOff 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arFmagOff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="arFmagSize">
               <h3>
                  arFmagSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arFmagSize = 2</code></pre>
            </article>
            
            <article class="global" data-name="arGIDOff">
               <h3>
                  arGIDOff 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arGIDOff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="arGIDSize">
               <h3>
                  arGIDSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arGIDSize = 6</code></pre>
            </article>
            
            <article class="global" data-name="arHdrSize">
               <h3>
                  arHdrSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arHdrSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="arModeOff">
               <h3>
                  arModeOff 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arModeOff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="arModeSize">
               <h3>
                  arModeSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arModeSize = 8</code></pre>
            </article>
            
            <article class="global" data-name="arNameOff">
               <h3>
                  arNameOff 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arNameOff = 0</code></pre>
            </article>
            
            <article class="global" data-name="arNameSize">
               <h3>
                  arNameSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arNameSize = 16</code></pre>
            </article>
            
            <article class="global" data-name="arSizeOff">
               <h3>
                  arSizeOff 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arSizeOff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="arSizeSize">
               <h3>
                  arSizeSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arSizeSize = 10</code></pre>
            </article>
            
            <article class="global" data-name="arUIDOff">
               <h3>
                  arUIDOff 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arUIDOff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="arUIDSize">
               <h3>
                  arUIDSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code>const arUIDSize = 6</code></pre>
            </article>
            
            <article class="global" data-name="archiveMagic">
               <h3>
                  archiveMagic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const archiveMagic = "!<ar"</code></pre>
            </article>
            
            <article class="global" data-name="arfmag">
               <h3>
                  arfmag 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>The contents of the fmag field of a standard archive header.</p>
               
               <pre><code>const arfmag = "`\n"</code></pre>
            </article>
            
            <article class="global" data-name="armag">
               <h3>
                  armag 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Magic strings for different archive file formats.</p>
               
               <pre><code>const armag = "!<arch>\n"</code></pre>
            </article>
            
            <article class="global" data-name="armagb">
               <h3>
                  armagb 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Magic strings for different archive file formats.</p>
               
               <pre><code>const armagb = "<bigaf>\n"</code></pre>
            </article>
            
            <article class="global" data-name="armagt">
               <h3>
                  armagt 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>Magic strings for different archive file formats.</p>
               
               <pre><code>const armagt = "!<thin>\n"</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinANY">
               <h3>
                  gccgoBuiltinANY 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinANY = 22</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinBOOL">
               <h3>
                  gccgoBuiltinBOOL 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinBOOL = 15</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinBYTE">
               <h3>
                  gccgoBuiltinBYTE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinBYTE = 20</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinCOMPLEX128">
               <h3>
                  gccgoBuiltinCOMPLEX128 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinCOMPLEX128 = 18</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinCOMPLEX64">
               <h3>
                  gccgoBuiltinCOMPLEX64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinCOMPLEX64 = 17</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinERROR">
               <h3>
                  gccgoBuiltinERROR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinERROR = 19</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinFLOAT32">
               <h3>
                  gccgoBuiltinFLOAT32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinFLOAT32 = 9</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinFLOAT64">
               <h3>
                  gccgoBuiltinFLOAT64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinFLOAT64 = 10</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinINT">
               <h3>
                  gccgoBuiltinINT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinINT = 11</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinINT16">
               <h3>
                  gccgoBuiltinINT16 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinINT16 = 2</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinINT32">
               <h3>
                  gccgoBuiltinINT32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinINT32 = 3</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinINT64">
               <h3>
                  gccgoBuiltinINT64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinINT64 = 4</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinINT8">
               <h3>
                  gccgoBuiltinINT8 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>From gofrontend/go/export.h
Note that these values are negative in the gofrontend and have been made positive
in the gccgoimporter.</p>
               
               <pre><code>const gccgoBuiltinINT8 = 1</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinRUNE">
               <h3>
                  gccgoBuiltinRUNE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinRUNE = 21</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinSTRING">
               <h3>
                  gccgoBuiltinSTRING 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinSTRING = 16</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinUINT">
               <h3>
                  gccgoBuiltinUINT 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinUINT = 12</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinUINT16">
               <h3>
                  gccgoBuiltinUINT16 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinUINT16 = 6</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinUINT32">
               <h3>
                  gccgoBuiltinUINT32 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinUINT32 = 7</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinUINT64">
               <h3>
                  gccgoBuiltinUINT64 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinUINT64 = 8</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinUINT8">
               <h3>
                  gccgoBuiltinUINT8 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinUINT8 = 5</code></pre>
            </article>
            
            <article class="global" data-name="gccgoBuiltinUINTPTR">
               <h3>
                  gccgoBuiltinUINTPTR 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgoBuiltinUINTPTR = 13</code></pre>
            </article>
            
            <article class="global" data-name="gccgov1Magic">
               <h3>
                  gccgov1Magic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgov1Magic = "v1;\n"</code></pre>
            </article>
            
            <article class="global" data-name="gccgov2Magic">
               <h3>
                  gccgov2Magic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgov2Magic = "v2;\n"</code></pre>
            </article>
            
            <article class="global" data-name="gccgov3Magic">
               <h3>
                  gccgov3Magic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gccgov3Magic = "v3;\n"</code></pre>
            </article>
            
            <article class="global" data-name="goimporterMagic">
               <h3>
                  goimporterMagic 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const goimporterMagic = "\n$$ "</code></pre>
            </article>
            
            <article class="global" data-name="reserved">
               <h3>
                  reserved 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>reserved is a singleton type used to fill type map slots that have
been reserved (i.e., for which a type number has been parsed) but
which don't have their actual type yet. When the type map is updated,
the actual type must replace a reserved entry (or we have an internal
error). Used for self-verification only - not required for correctness.</p>
               
               <pre><code>var reserved = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="Importer">
               <h3>
                  Importer
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>An Importer resolves import paths to Packages. The imports map records
packages already known, indexed by package path.
An importer must determine the canonical package path and check imports
to see if it is already present in the map. If so, the Importer can return
the map entry. Otherwise, the importer must load the package data for the
given path into a new *Package, record it in imports map, and return the
package.</p>
               
               <pre><code>type Importer func(imports map[string]*types.Package, path string, srcDir string, lookup func(string) (io.ReadCloser, error)) (*types.Package, error)</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="GccgoInstallation">
               <h3>
                  GccgoInstallation
                  <span class="badge">struct</span>
               </h3>
               
               <p>Information about a specific installation of gccgo.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type GccgoInstallation struct {
GccVersion string
TargetTriple string
LibPaths []string
}</code></pre>
            </article>
            
            <article class="struct" data-name="InitData">
               <h3>
                  InitData
                  <span class="badge">struct</span>
               </h3>
               
               <p>The gccgo-specific init data for a package.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type InitData struct {
Priority int
Inits []PackageInit
}</code></pre>
            </article>
            
            <article class="struct" data-name="PackageInit">
               <h3>
                  PackageInit
                  <span class="badge">struct</span>
               </h3>
               
               <p>A PackageInit describes an imported package that needs initialization.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type PackageInit struct {
Name string
InitFunc string
Priority int
}</code></pre>
            </article>
            
            <article class="struct" data-name="fixupRecord">
               <h3>
                  fixupRecord
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fixupRecord struct {
toUpdate *types.Named
target types.Type
}</code></pre>
            </article>
            
            <article class="struct" data-name="importError">
               <h3>
                  importError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type importError struct {
pos scanner.Position
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="parser">
               <h3>
                  parser
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type parser struct {
scanner *scanner.Scanner
version string
tok rune
lit string
pkgpath string
pkgname string
pkg *types.Package
imports map[string]*types.Package
typeList []types.Type
typeData []string
fixups []fixupRecord
initdata InitData
aliases map[int]string
}</code></pre>
            </article>
            
            <article class="struct" data-name="seekerReadAt">
               <h3>
                  seekerReadAt
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type seekerReadAt struct {
seeker io.ReadSeeker
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e importError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="GetImporter">
               <h3>
                  GetImporter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func GetImporter(searchpaths []string, initmap map[*types.Package]InitData) Importer</code></pre>
            </article>
            
            <article class="function" data-name="GetImporter">
               <h3>
                  GetImporter 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Return an importer that searches incpaths followed by the gcc installation's
built-in search paths and the current directory.</p>
               
               <pre><code>func (inst *GccgoInstallation) GetImporter(incpaths []string, initmap map[*types.Package]InitData) Importer</code></pre>
            </article>
            
            <article class="function" data-name="InitFromDriver">
               <h3>
                  InitFromDriver 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Ask the driver at the given path for information for this GccgoInstallation.
The given arguments are passed directly to the call of the driver.</p>
               
               <pre><code>func (inst *GccgoInstallation) InitFromDriver(gccgoPath string, args ...string) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="ReadAt">
               <h3>
                  ReadAt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (sra seekerReadAt) ReadAt(p []byte, off int64) (int, error)</code></pre>
            </article>
            
            <article class="function" data-name="SearchPaths">
               <h3>
                  SearchPaths 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Return the list of export search paths for this GccgoInstallation.</p>
               
               <pre><code>func (inst *GccgoInstallation) SearchPaths() (paths []string)</code></pre>
            </article>
            
            <article class="function" data-name="aixBigArExportData">
               <h3>
                  aixBigArExportData 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>aixBigArExportData returns export data from an AIX big archive.</p>
               
               <pre><code>func aixBigArExportData(archive io.ReadSeeker) (io.ReadSeeker, error)</code></pre>
            </article>
            
            <article class="function" data-name="arExportData">
               <h3>
                  arExportData 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>arExportData takes an archive file and returns a ReadSeeker for the
export data in that file. This assumes that there is only one
object in the archive containing export data, which is not quite
what gccgo does; gccgo concatenates together all the export data
for all the objects in the file.  In practice that case does not arise.</p>
               
               <pre><code>func arExportData(archive io.ReadSeeker) (io.ReadSeeker, error)</code></pre>
            </article>
            
            <article class="function" data-name="deref">
               <h3>
                  deref 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func deref(typ types.Type) types.Type</code></pre>
            </article>
            
            <article class="function" data-name="elfFromAr">
               <h3>
                  elfFromAr 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>elfFromAr tries to get export data from an archive member as an ELF file.
If there is no export data, this returns nil, nil.</p>
               
               <pre><code>func elfFromAr(member *io.SectionReader) (io.ReadSeeker, error)</code></pre>
            </article>
            
            <article class="function" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) error(err any)</code></pre>
            </article>
            
            <article class="function" data-name="errorf">
               <h3>
                  errorf 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) errorf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function" data-name="expect">
               <h3>
                  expect 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) expect(tok rune) string</code></pre>
            </article>
            
            <article class="function" data-name="expectEOL">
               <h3>
                  expectEOL 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) expectEOL()</code></pre>
            </article>
            
            <article class="function" data-name="expectKeyword">
               <h3>
                  expectKeyword 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) expectKeyword(keyword string)</code></pre>
            </article>
            
            <article class="function" data-name="findExportFile">
               <h3>
                  findExportFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Locate the file from which to read export data.
This is intended to replicate the logic in gofrontend.</p>
               
               <pre><code>func findExportFile(searchpaths []string, pkgpath string) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="getPkg">
               <h3>
                  getPkg 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>getPkg returns the package for a given path. If the package is
not found but we have a package name, create the package and
add it to the p.imports map.</p>
               
               <pre><code>func (p *parser) getPkg(pkgpath string, name string) *types.Package</code></pre>
            </article>
            
            <article class="function" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) init(filename string, src io.Reader, imports map[string]*types.Package)</code></pre>
            </article>
            
            <article class="function" data-name="initScanner">
               <h3>
                  initScanner 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) initScanner(filename string, src io.Reader)</code></pre>
            </article>
            
            <article class="function" data-name="lookupBuiltinType">
               <h3>
                  lookupBuiltinType 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func lookupBuiltinType(typ int) types.Type</code></pre>
            </article>
            
            <article class="function" data-name="maybeCreatePackage">
               <h3>
                  maybeCreatePackage 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Create the package if we have parsed both the package path and package name.</p>
               
               <pre><code>func (p *parser) maybeCreatePackage()</code></pre>
            </article>
            
            <article class="function" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) next()</code></pre>
            </article>
            
            <article class="function" data-name="openExportFile">
               <h3>
                  openExportFile 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Opens the export data file at the given path. If this is an ELF file,
searches for and opens the .go_export section. If this is an archive,
reads the export data from the first member, which is assumed to be an ELF file.
This is intended to replicate the logic in gofrontend.</p>
               
               <pre><code>func openExportFile(fpath string) (reader io.ReadSeeker, closer io.Closer, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseArrayOrSliceType">
               <h3>
                  parseArrayOrSliceType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ArrayOrSliceType = "[" [ int ] "]" Type .</p>
               
               <pre><code>func (p *parser) parseArrayOrSliceType(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function" data-name="parseChanType">
               <h3>
                  parseChanType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ChanType = "chan" ["<-" | "-<"] Type .</p>
               
               <pre><code>func (p *parser) parseChanType(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function" data-name="parseConst">
               <h3>
                  parseConst 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Const = Name [Type] "=" ConstValue .</p>
               
               <pre><code>func (p *parser) parseConst(pkg *types.Package) *types.Const</code></pre>
            </article>
            
            <article class="function" data-name="parseConstValue">
               <h3>
                  parseConstValue 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ConstValue     = string | "false" | "true" | ["-"] (int ["'"] | FloatOrComplex) | Conversion .
FloatOrComplex = float ["i" | ("+"|"-") float "i"] .</p>
               
               <pre><code>func (p *parser) parseConstValue(pkg *types.Package) (val constant.Value, typ types.Type)</code></pre>
            </article>
            
            <article class="function" data-name="parseConversion">
               <h3>
                  parseConversion 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Conversion = "convert" "(" Type "," ConstValue ")" .</p>
               
               <pre><code>func (p *parser) parseConversion(pkg *types.Package) (val constant.Value, typ types.Type)</code></pre>
            </article>
            
            <article class="function" data-name="parseDirective">
               <h3>
                  parseDirective 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Directive = InitDataDirective |
"package" unquotedString [ unquotedString ] [ unquotedString ] ";" |
"pkgpath" unquotedString ";" |
"prefix" unquotedString ";" |
"import" unquotedString unquotedString string ";" |
"indirectimport" unquotedString unquotedstring ";" |
"func" Func ";" |
"type" Type ";" |
"var" Var ";" |
"const" Const ";" .</p>
               
               <pre><code>func (p *parser) parseDirective()</code></pre>
            </article>
            
            <article class="function" data-name="parseExportedName">
               <h3>
                  parseExportedName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseExportedName is like parseQualifiedName, but
the package path is resolved to an imported *types.Package.
ExportedName = string [string] .</p>
               
               <pre><code>func (p *parser) parseExportedName() (pkg *types.Package, name string)</code></pre>
            </article>
            
            <article class="function" data-name="parseField">
               <h3>
                  parseField 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Field = Name Type [string] .</p>
               
               <pre><code>func (p *parser) parseField(pkg *types.Package) (field *types.Var, tag string)</code></pre>
            </article>
            
            <article class="function" data-name="parseFunc">
               <h3>
                  parseFunc 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Func = Name FunctionType [InlineBody] .</p>
               
               <pre><code>func (p *parser) parseFunc(pkg *types.Package) *types.Func</code></pre>
            </article>
            
            <article class="function" data-name="parseFunctionType">
               <h3>
                  parseFunctionType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>FunctionType = ParamList ResultList .</p>
               
               <pre><code>func (p *parser) parseFunctionType(pkg *types.Package, nlist []any) *types.Signature</code></pre>
            </article>
            
            <article class="function" data-name="parseInitDataDirective">
               <h3>
                  parseInitDataDirective 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>InitDataDirective = ( "v1" | "v2" | "v3" ) ";" |
"priority" int ";" |
"init" { PackageInit } ";" |
"checksum" unquotedString ";" .</p>
               
               <pre><code>func (p *parser) parseInitDataDirective()</code></pre>
            </article>
            
            <article class="function" data-name="parseInt">
               <h3>
                  parseInt 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) parseInt() int</code></pre>
            </article>
            
            <article class="function" data-name="parseInt64">
               <h3>
                  parseInt64 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) parseInt64() int64</code></pre>
            </article>
            
            <article class="function" data-name="parseInterfaceType">
               <h3>
                  parseInterfaceType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>InterfaceType = "interface" "{" { ("?" Type | Func) ";" } "}" .</p>
               
               <pre><code>func (p *parser) parseInterfaceType(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function" data-name="parseMapType">
               <h3>
                  parseMapType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>MapType = "map" "[" Type "]" Type .</p>
               
               <pre><code>func (p *parser) parseMapType(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function" data-name="parseName">
               <h3>
                  parseName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Name = QualifiedName | "?" .</p>
               
               <pre><code>func (p *parser) parseName() string</code></pre>
            </article>
            
            <article class="function" data-name="parseNamedType">
               <h3>
                  parseNamedType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>NamedType = TypeName [ "=" ] Type { Method } .
TypeName  = ExportedName .
Method    = "func" "(" Param ")" Name ParamList ResultList [InlineBody] ";" .</p>
               
               <pre><code>func (p *parser) parseNamedType(nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function" data-name="parsePackage">
               <h3>
                  parsePackage 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Package = { Directive } .</p>
               
               <pre><code>func (p *parser) parsePackage() *types.Package</code></pre>
            </article>
            
            <article class="function" data-name="parsePackageInit">
               <h3>
                  parsePackageInit 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PackageInit = unquotedString unquotedString int .</p>
               
               <pre><code>func (p *parser) parsePackageInit() PackageInit</code></pre>
            </article>
            
            <article class="function" data-name="parseParam">
               <h3>
                  parseParam 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Param = Name ["..."] Type .</p>
               
               <pre><code>func (p *parser) parseParam(pkg *types.Package) (param *types.Var, isVariadic bool)</code></pre>
            </article>
            
            <article class="function" data-name="parseParamList">
               <h3>
                  parseParamList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ParamList = "(" [ { Parameter "," } Parameter ] ")" .</p>
               
               <pre><code>func (p *parser) parseParamList(pkg *types.Package) (*types.Tuple, bool)</code></pre>
            </article>
            
            <article class="function" data-name="parsePointerType">
               <h3>
                  parsePointerType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>PointerType = "*" ("any" | Type) .</p>
               
               <pre><code>func (p *parser) parsePointerType(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function" data-name="parseQualifiedName">
               <h3>
                  parseQualifiedName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) parseQualifiedName() (path string, name string)</code></pre>
            </article>
            
            <article class="function" data-name="parseQualifiedNameStr">
               <h3>
                  parseQualifiedNameStr 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>qualifiedName = [ ["."] unquotedString "." ] unquotedString .
The above production uses greedy matching.</p>
               
               <pre><code>func (p *parser) parseQualifiedNameStr(unquotedName string) (pkgpath string, name string)</code></pre>
            </article>
            
            <article class="function" data-name="parseResultList">
               <h3>
                  parseResultList 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>ResultList = Type | ParamList .</p>
               
               <pre><code>func (p *parser) parseResultList(pkg *types.Package) *types.Tuple</code></pre>
            </article>
            
            <article class="function" data-name="parseSavedType">
               <h3>
                  parseSavedType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseSavedType parses one saved type definition.</p>
               
               <pre><code>func (p *parser) parseSavedType(pkg *types.Package, i int, nlist []any)</code></pre>
            </article>
            
            <article class="function" data-name="parseString">
               <h3>
                  parseString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) parseString() string</code></pre>
            </article>
            
            <article class="function" data-name="parseStructType">
               <h3>
                  parseStructType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>StructType = "struct" "{" { Field } "}" .</p>
               
               <pre><code>func (p *parser) parseStructType(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function" data-name="parseType">
               <h3>
                  parseType 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Type = "<" "type" ( "-" int | int [ TypeSpec ] ) ">" .
parseType updates the type map to t for all type numbers n.</p>
               
               <pre><code>func (p *parser) parseType(pkg *types.Package, n ...any) types.Type</code></pre>
            </article>
            
            <article class="function" data-name="parseTypeAfterAngle">
               <h3>
                  parseTypeAfterAngle 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>(*parser).Type after reading the "<".</p>
               
               <pre><code>func (p *parser) parseTypeAfterAngle(pkg *types.Package, n ...any) (t types.Type, n1 int)</code></pre>
            </article>
            
            <article class="function" data-name="parseTypeExtended">
               <h3>
                  parseTypeExtended 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>parseTypeExtended is identical to parseType, but if the type in
question is a saved type, returns the index as well as the type
pointer (index returned is zero if we parsed a builtin).</p>
               
               <pre><code>func (p *parser) parseTypeExtended(pkg *types.Package, n ...any) (t types.Type, n1 int)</code></pre>
            </article>
            
            <article class="function" data-name="parseTypeSpec">
               <h3>
                  parseTypeSpec 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>TypeSpec = NamedType | MapType | ChanType | StructType | InterfaceType | PointerType | ArrayOrSliceType | FunctionType .</p>
               
               <pre><code>func (p *parser) parseTypeSpec(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function" data-name="parseTypes">
               <h3>
                  parseTypes 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Types = "types" maxp1 exportedp1 (offset length)* .</p>
               
               <pre><code>func (p *parser) parseTypes(pkg *types.Package)</code></pre>
            </article>
            
            <article class="function" data-name="parseUnquotedQualifiedName">
               <h3>
                  parseUnquotedQualifiedName 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (p *parser) parseUnquotedQualifiedName() (path string, name string)</code></pre>
            </article>
            
            <article class="function" data-name="parseUnquotedString">
               <h3>
                  parseUnquotedString 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>unquotedString     = { unquotedStringChar } .
unquotedStringChar = <neither a whitespace nor a ';' char> .</p>
               
               <pre><code>func (p *parser) parseUnquotedString() string</code></pre>
            </article>
            
            <article class="function" data-name="parseVar">
               <h3>
                  parseVar 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Var = Name Type .</p>
               
               <pre><code>func (p *parser) parseVar(pkg *types.Package) *types.Var</code></pre>
            </article>
            
            <article class="function" data-name="readMagic">
               <h3>
                  readMagic 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readMagic reads the four bytes at the start of a ReadSeeker and
returns them as a string.</p>
               
               <pre><code>func readMagic(reader io.ReadSeeker) (string, error)</code></pre>
            </article>
            
            <article class="function" data-name="readerAtFromSeeker">
               <h3>
                  readerAtFromSeeker 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>readerAtFromSeeker turns an io.ReadSeeker into an io.ReaderAt.
This is only safe because there won't be any concurrent seeks
while this code is executing.</p>
               
               <pre><code>func readerAtFromSeeker(rs io.ReadSeeker) io.ReaderAt</code></pre>
            </article>
            
            <article class="function" data-name="reserve">
               <h3>
                  reserve 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>reserve reserves the type map entry n for future use.</p>
               
               <pre><code>func (p *parser) reserve(n int)</code></pre>
            </article>
            
            <article class="function" data-name="skipInlineBody">
               <h3>
                  skipInlineBody 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>InlineBody = "<inl:NN>" .{NN}
Reports whether a body was skipped.</p>
               
               <pre><code>func (p *parser) skipInlineBody()</code></pre>
            </article>
            
            <article class="function" data-name="standardArExportData">
               <h3>
                  standardArExportData 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>standardArExportData returns export data from a standard archive.</p>
               
               <pre><code>func standardArExportData(archive io.ReadSeeker) (io.ReadSeeker, error)</code></pre>
            </article>
            
            <article class="function" data-name="update">
               <h3>
                  update 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>update sets the type map entries for the entries in nlist to t.
An entry in nlist can be a type number in p.typeList,
used to resolve named types, or it can be a *types.Pointer,
used to resolve pointers to named types in case they are referenced
by embedded fields.</p>
               
               <pre><code>func (p *parser) update(t types.Type, nlist []any)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
