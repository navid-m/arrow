<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>gccgoimporter - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>gccgoimporter</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"bytes"
"debug/elf"
"errors"
"fmt"
"internal/xcoff"
"io"
"strconv"
"strings"
"bufio"
"go/types"
"os"
"os/exec"
"path/filepath"
"strings"
"bytes"
"debug/elf"
"fmt"
"go/types"
"internal/xcoff"
"io"
"os"
"path/filepath"
"strings"
"errors"
"fmt"
"go/constant"
"go/token"
"go/types"
"io"
"strconv"
"strings"
"text/scanner"
"unicode/utf8"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="aixbigafMagic" data-name="aixbigafMagic">
               <h3>
                  aixbigafMagic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#aixbigafMagic" class="anchor" title="Link to aixbigafMagic">#</a>
               </h3>
               
               <pre><code class="language-go">const aixbigafMagic = "<big"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arDateOff" data-name="arDateOff">
               <h3>
                  arDateOff 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arDateOff" class="anchor" title="Link to arDateOff">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arDateOff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arDateSize" data-name="arDateSize">
               <h3>
                  arDateSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arDateSize" class="anchor" title="Link to arDateSize">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arDateSize = 12</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arFmagOff" data-name="arFmagOff">
               <h3>
                  arFmagOff 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arFmagOff" class="anchor" title="Link to arFmagOff">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arFmagOff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arFmagSize" data-name="arFmagSize">
               <h3>
                  arFmagSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arFmagSize" class="anchor" title="Link to arFmagSize">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arFmagSize = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arGIDOff" data-name="arGIDOff">
               <h3>
                  arGIDOff 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arGIDOff" class="anchor" title="Link to arGIDOff">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arGIDOff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arGIDSize" data-name="arGIDSize">
               <h3>
                  arGIDSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arGIDSize" class="anchor" title="Link to arGIDSize">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arGIDSize = 6</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arHdrSize" data-name="arHdrSize">
               <h3>
                  arHdrSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arHdrSize" class="anchor" title="Link to arHdrSize">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arHdrSize = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arModeOff" data-name="arModeOff">
               <h3>
                  arModeOff 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arModeOff" class="anchor" title="Link to arModeOff">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arModeOff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arModeSize" data-name="arModeSize">
               <h3>
                  arModeSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arModeSize" class="anchor" title="Link to arModeSize">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arModeSize = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arNameOff" data-name="arNameOff">
               <h3>
                  arNameOff 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arNameOff" class="anchor" title="Link to arNameOff">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arNameOff = 0</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arNameSize" data-name="arNameSize">
               <h3>
                  arNameSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arNameSize" class="anchor" title="Link to arNameSize">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arNameSize = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arSizeOff" data-name="arSizeOff">
               <h3>
                  arSizeOff 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arSizeOff" class="anchor" title="Link to arSizeOff">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arSizeOff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arSizeSize" data-name="arSizeSize">
               <h3>
                  arSizeSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arSizeSize" class="anchor" title="Link to arSizeSize">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arSizeSize = 10</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arUIDOff" data-name="arUIDOff">
               <h3>
                  arUIDOff 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arUIDOff" class="anchor" title="Link to arUIDOff">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arUIDOff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arUIDSize" data-name="arUIDSize">
               <h3>
                  arUIDSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arUIDSize" class="anchor" title="Link to arUIDSize">#</a>
               </h3>
               
                  <p class="doc-comment">Offsets and sizes for fields in a standard archive header.</p>
               
               <pre><code class="language-go">const arUIDSize = 6</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="archiveMagic" data-name="archiveMagic">
               <h3>
                  archiveMagic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#archiveMagic" class="anchor" title="Link to archiveMagic">#</a>
               </h3>
               
               <pre><code class="language-go">const archiveMagic = "!<ar"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="arfmag" data-name="arfmag">
               <h3>
                  arfmag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#arfmag" class="anchor" title="Link to arfmag">#</a>
               </h3>
               
                  <p class="doc-comment">The contents of the fmag field of a standard archive header.</p>
               
               <pre><code class="language-go">const arfmag = "`\n"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="armag" data-name="armag">
               <h3>
                  armag 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#armag" class="anchor" title="Link to armag">#</a>
               </h3>
               
                  <p class="doc-comment">Magic strings for different archive file formats.</p>
               
               <pre><code class="language-go">const armag = "!<arch>\n"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="armagb" data-name="armagb">
               <h3>
                  armagb 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#armagb" class="anchor" title="Link to armagb">#</a>
               </h3>
               
                  <p class="doc-comment">Magic strings for different archive file formats.</p>
               
               <pre><code class="language-go">const armagb = "<bigaf>\n"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="armagt" data-name="armagt">
               <h3>
                  armagt 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#armagt" class="anchor" title="Link to armagt">#</a>
               </h3>
               
                  <p class="doc-comment">Magic strings for different archive file formats.</p>
               
               <pre><code class="language-go">const armagt = "!<thin>\n"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinANY" data-name="gccgoBuiltinANY">
               <h3>
                  gccgoBuiltinANY 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinANY" class="anchor" title="Link to gccgoBuiltinANY">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinANY = 22</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinBOOL" data-name="gccgoBuiltinBOOL">
               <h3>
                  gccgoBuiltinBOOL 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinBOOL" class="anchor" title="Link to gccgoBuiltinBOOL">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinBOOL = 15</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinBYTE" data-name="gccgoBuiltinBYTE">
               <h3>
                  gccgoBuiltinBYTE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinBYTE" class="anchor" title="Link to gccgoBuiltinBYTE">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinBYTE = 20</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinCOMPLEX128" data-name="gccgoBuiltinCOMPLEX128">
               <h3>
                  gccgoBuiltinCOMPLEX128 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinCOMPLEX128" class="anchor" title="Link to gccgoBuiltinCOMPLEX128">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinCOMPLEX128 = 18</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinCOMPLEX64" data-name="gccgoBuiltinCOMPLEX64">
               <h3>
                  gccgoBuiltinCOMPLEX64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinCOMPLEX64" class="anchor" title="Link to gccgoBuiltinCOMPLEX64">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinCOMPLEX64 = 17</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinERROR" data-name="gccgoBuiltinERROR">
               <h3>
                  gccgoBuiltinERROR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinERROR" class="anchor" title="Link to gccgoBuiltinERROR">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinERROR = 19</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinFLOAT32" data-name="gccgoBuiltinFLOAT32">
               <h3>
                  gccgoBuiltinFLOAT32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinFLOAT32" class="anchor" title="Link to gccgoBuiltinFLOAT32">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinFLOAT32 = 9</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinFLOAT64" data-name="gccgoBuiltinFLOAT64">
               <h3>
                  gccgoBuiltinFLOAT64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinFLOAT64" class="anchor" title="Link to gccgoBuiltinFLOAT64">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinFLOAT64 = 10</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinINT" data-name="gccgoBuiltinINT">
               <h3>
                  gccgoBuiltinINT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinINT" class="anchor" title="Link to gccgoBuiltinINT">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinINT = 11</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinINT16" data-name="gccgoBuiltinINT16">
               <h3>
                  gccgoBuiltinINT16 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinINT16" class="anchor" title="Link to gccgoBuiltinINT16">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinINT16 = 2</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinINT32" data-name="gccgoBuiltinINT32">
               <h3>
                  gccgoBuiltinINT32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinINT32" class="anchor" title="Link to gccgoBuiltinINT32">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinINT32 = 3</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinINT64" data-name="gccgoBuiltinINT64">
               <h3>
                  gccgoBuiltinINT64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinINT64" class="anchor" title="Link to gccgoBuiltinINT64">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinINT64 = 4</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinINT8" data-name="gccgoBuiltinINT8">
               <h3>
                  gccgoBuiltinINT8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinINT8" class="anchor" title="Link to gccgoBuiltinINT8">#</a>
               </h3>
               
                  <p class="doc-comment">From gofrontend/go/export.h
Note that these values are negative in the gofrontend and have been made positive
in the gccgoimporter.</p>
               
               <pre><code class="language-go">const gccgoBuiltinINT8 = 1</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinRUNE" data-name="gccgoBuiltinRUNE">
               <h3>
                  gccgoBuiltinRUNE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinRUNE" class="anchor" title="Link to gccgoBuiltinRUNE">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinRUNE = 21</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinSTRING" data-name="gccgoBuiltinSTRING">
               <h3>
                  gccgoBuiltinSTRING 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinSTRING" class="anchor" title="Link to gccgoBuiltinSTRING">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinSTRING = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinUINT" data-name="gccgoBuiltinUINT">
               <h3>
                  gccgoBuiltinUINT 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinUINT" class="anchor" title="Link to gccgoBuiltinUINT">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinUINT = 12</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinUINT16" data-name="gccgoBuiltinUINT16">
               <h3>
                  gccgoBuiltinUINT16 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinUINT16" class="anchor" title="Link to gccgoBuiltinUINT16">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinUINT16 = 6</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinUINT32" data-name="gccgoBuiltinUINT32">
               <h3>
                  gccgoBuiltinUINT32 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinUINT32" class="anchor" title="Link to gccgoBuiltinUINT32">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinUINT32 = 7</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinUINT64" data-name="gccgoBuiltinUINT64">
               <h3>
                  gccgoBuiltinUINT64 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinUINT64" class="anchor" title="Link to gccgoBuiltinUINT64">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinUINT64 = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinUINT8" data-name="gccgoBuiltinUINT8">
               <h3>
                  gccgoBuiltinUINT8 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinUINT8" class="anchor" title="Link to gccgoBuiltinUINT8">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinUINT8 = 5</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgoBuiltinUINTPTR" data-name="gccgoBuiltinUINTPTR">
               <h3>
                  gccgoBuiltinUINTPTR 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgoBuiltinUINTPTR" class="anchor" title="Link to gccgoBuiltinUINTPTR">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgoBuiltinUINTPTR = 13</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgov1Magic" data-name="gccgov1Magic">
               <h3>
                  gccgov1Magic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgov1Magic" class="anchor" title="Link to gccgov1Magic">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgov1Magic = "v1;\n"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgov2Magic" data-name="gccgov2Magic">
               <h3>
                  gccgov2Magic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgov2Magic" class="anchor" title="Link to gccgov2Magic">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgov2Magic = "v2;\n"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gccgov3Magic" data-name="gccgov3Magic">
               <h3>
                  gccgov3Magic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gccgov3Magic" class="anchor" title="Link to gccgov3Magic">#</a>
               </h3>
               
               <pre><code class="language-go">const gccgov3Magic = "v3;\n"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goimporterMagic" data-name="goimporterMagic">
               <h3>
                  goimporterMagic 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#goimporterMagic" class="anchor" title="Link to goimporterMagic">#</a>
               </h3>
               
               <pre><code class="language-go">const goimporterMagic = "\n$$ "</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="reserved" data-name="reserved">
               <h3>
                  reserved 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#reserved" class="anchor" title="Link to reserved">#</a>
               </h3>
               
                  <p class="doc-comment">reserved is a singleton type used to fill type map slots that have
been reserved (i.e., for which a type number has been parsed) but
which don't have their actual type yet. When the type map is updated,
the actual type must replace a reserved entry (or we have an internal
error). Used for self-verification only - not required for correctness.</p>
               
               <pre><code class="language-go">var reserved = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="Importer" data-name="Importer">
               <h3>
                  Importer
                  <span class="badge type-badge">type</span>
                  <a href="#Importer" class="anchor" title="Link to Importer">#</a>
               </h3>
               
               <p>An Importer resolves import paths to Packages. The imports map records
packages already known, indexed by package path.
An importer must determine the canonical package path and check imports
to see if it is already present in the map. If so, the Importer can return
the map entry. Otherwise, the importer must load the package data for the
given path into a new *Package, record it in imports map, and return the
package.</p>
               
               <pre><code class="language-go">type Importer func(imports map[string]*types.Package, path string, srcDir string, lookup func(string) (io.ReadCloser, error)) (*types.Package, error)</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="GccgoInstallation" data-name="GccgoInstallation">
               <h3>
                  GccgoInstallation
                  <span class="badge">struct</span>
                  <a href="#GccgoInstallation" class="anchor" title="Link to GccgoInstallation">#</a>
               </h3>
               
               <p>Information about a specific installation of gccgo.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type GccgoInstallation struct {
GccVersion string
TargetTriple string
LibPaths []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="InitData" data-name="InitData">
               <h3>
                  InitData
                  <span class="badge">struct</span>
                  <a href="#InitData" class="anchor" title="Link to InitData">#</a>
               </h3>
               
               <p>The gccgo-specific init data for a package.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type InitData struct {
Priority int
Inits []PackageInit
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="PackageInit" data-name="PackageInit">
               <h3>
                  PackageInit
                  <span class="badge">struct</span>
                  <a href="#PackageInit" class="anchor" title="Link to PackageInit">#</a>
               </h3>
               
               <p>A PackageInit describes an imported package that needs initialization.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type PackageInit struct {
Name string
InitFunc string
Priority int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fixupRecord" data-name="fixupRecord">
               <h3>
                  fixupRecord
                  <span class="badge">struct</span>
                  <a href="#fixupRecord" class="anchor" title="Link to fixupRecord">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type fixupRecord struct {
toUpdate *types.Named
target types.Type
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="importError" data-name="importError">
               <h3>
                  importError
                  <span class="badge">struct</span>
                  <a href="#importError" class="anchor" title="Link to importError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type importError struct {
pos scanner.Position
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="parser" data-name="parser">
               <h3>
                  parser
                  <span class="badge">struct</span>
                  <a href="#parser" class="anchor" title="Link to parser">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type parser struct {
scanner *scanner.Scanner
version string
tok rune
lit string
pkgpath string
pkgname string
pkg *types.Package
imports map[string]*types.Package
typeList []types.Type
typeData []string
fixups []fixupRecord
initdata InitData
aliases map[int]string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="seekerReadAt" data-name="seekerReadAt">
               <h3>
                  seekerReadAt
                  <span class="badge">struct</span>
                  <a href="#seekerReadAt" class="anchor" title="Link to seekerReadAt">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type seekerReadAt struct {
seeker io.ReadSeeker
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code class="language-go">func (e importError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetImporter" data-name="GetImporter">
               <h3>
                  GetImporter 
                  <span class="badge">function</span>
                  
                  <a href="#GetImporter" class="anchor" title="Link to GetImporter">#</a>
               </h3>
               
               <pre><code class="language-go">func GetImporter(searchpaths []string, initmap map[*types.Package]InitData) Importer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetImporter" data-name="GetImporter">
               <h3>
                  GetImporter 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GetImporter" class="anchor" title="Link to GetImporter">#</a>
               </h3>
               
               <p>Return an importer that searches incpaths followed by the gcc installation's
built-in search paths and the current directory.</p>
               
               <pre><code class="language-go">func (inst *GccgoInstallation) GetImporter(incpaths []string, initmap map[*types.Package]InitData) Importer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="InitFromDriver" data-name="InitFromDriver">
               <h3>
                  InitFromDriver 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#InitFromDriver" class="anchor" title="Link to InitFromDriver">#</a>
               </h3>
               
               <p>Ask the driver at the given path for information for this GccgoInstallation.
The given arguments are passed directly to the call of the driver.</p>
               
               <pre><code class="language-go">func (inst *GccgoInstallation) InitFromDriver(gccgoPath string, args ...string) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ReadAt" data-name="ReadAt">
               <h3>
                  ReadAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ReadAt" class="anchor" title="Link to ReadAt">#</a>
               </h3>
               
               <pre><code class="language-go">func (sra seekerReadAt) ReadAt(p []byte, off int64) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SearchPaths" data-name="SearchPaths">
               <h3>
                  SearchPaths 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SearchPaths" class="anchor" title="Link to SearchPaths">#</a>
               </h3>
               
               <p>Return the list of export search paths for this GccgoInstallation.</p>
               
               <pre><code class="language-go">func (inst *GccgoInstallation) SearchPaths() (paths []string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="aixBigArExportData" data-name="aixBigArExportData">
               <h3>
                  aixBigArExportData 
                  <span class="badge">function</span>
                  
                  <a href="#aixBigArExportData" class="anchor" title="Link to aixBigArExportData">#</a>
               </h3>
               
               <p>aixBigArExportData returns export data from an AIX big archive.</p>
               
               <pre><code class="language-go">func aixBigArExportData(archive io.ReadSeeker) (io.ReadSeeker, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="arExportData" data-name="arExportData">
               <h3>
                  arExportData 
                  <span class="badge">function</span>
                  
                  <a href="#arExportData" class="anchor" title="Link to arExportData">#</a>
               </h3>
               
               <p>arExportData takes an archive file and returns a ReadSeeker for the
export data in that file. This assumes that there is only one
object in the archive containing export data, which is not quite
what gccgo does; gccgo concatenates together all the export data
for all the objects in the file.  In practice that case does not arise.</p>
               
               <pre><code class="language-go">func arExportData(archive io.ReadSeeker) (io.ReadSeeker, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deref" data-name="deref">
               <h3>
                  deref 
                  <span class="badge">function</span>
                  
                  <a href="#deref" class="anchor" title="Link to deref">#</a>
               </h3>
               
               <pre><code class="language-go">func deref(typ types.Type) types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="elfFromAr" data-name="elfFromAr">
               <h3>
                  elfFromAr 
                  <span class="badge">function</span>
                  
                  <a href="#elfFromAr" class="anchor" title="Link to elfFromAr">#</a>
               </h3>
               
               <p>elfFromAr tries to get export data from an archive member as an ELF file.
If there is no export data, this returns nil, nil.</p>
               
               <pre><code class="language-go">func elfFromAr(member *io.SectionReader) (io.ReadSeeker, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="error" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#error" class="anchor" title="Link to error">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) error(err any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="errorf" data-name="errorf">
               <h3>
                  errorf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#errorf" class="anchor" title="Link to errorf">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) errorf(format string, args ...any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expect" data-name="expect">
               <h3>
                  expect 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expect" class="anchor" title="Link to expect">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) expect(tok rune) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expectEOL" data-name="expectEOL">
               <h3>
                  expectEOL 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expectEOL" class="anchor" title="Link to expectEOL">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) expectEOL()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expectKeyword" data-name="expectKeyword">
               <h3>
                  expectKeyword 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#expectKeyword" class="anchor" title="Link to expectKeyword">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) expectKeyword(keyword string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findExportFile" data-name="findExportFile">
               <h3>
                  findExportFile 
                  <span class="badge">function</span>
                  
                  <a href="#findExportFile" class="anchor" title="Link to findExportFile">#</a>
               </h3>
               
               <p>Locate the file from which to read export data.
This is intended to replicate the logic in gofrontend.</p>
               
               <pre><code class="language-go">func findExportFile(searchpaths []string, pkgpath string) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getPkg" data-name="getPkg">
               <h3>
                  getPkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getPkg" class="anchor" title="Link to getPkg">#</a>
               </h3>
               
               <p>getPkg returns the package for a given path. If the package is
not found but we have a package name, create the package and
add it to the p.imports map.</p>
               
               <pre><code class="language-go">func (p *parser) getPkg(pkgpath string, name string) *types.Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) init(filename string, src io.Reader, imports map[string]*types.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="initScanner" data-name="initScanner">
               <h3>
                  initScanner 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#initScanner" class="anchor" title="Link to initScanner">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) initScanner(filename string, src io.Reader)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lookupBuiltinType" data-name="lookupBuiltinType">
               <h3>
                  lookupBuiltinType 
                  <span class="badge">function</span>
                  
                  <a href="#lookupBuiltinType" class="anchor" title="Link to lookupBuiltinType">#</a>
               </h3>
               
               <pre><code class="language-go">func lookupBuiltinType(typ int) types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="maybeCreatePackage" data-name="maybeCreatePackage">
               <h3>
                  maybeCreatePackage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#maybeCreatePackage" class="anchor" title="Link to maybeCreatePackage">#</a>
               </h3>
               
               <p>Create the package if we have parsed both the package path and package name.</p>
               
               <pre><code class="language-go">func (p *parser) maybeCreatePackage()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="next" data-name="next">
               <h3>
                  next 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#next" class="anchor" title="Link to next">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) next()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openExportFile" data-name="openExportFile">
               <h3>
                  openExportFile 
                  <span class="badge">function</span>
                  
                  <a href="#openExportFile" class="anchor" title="Link to openExportFile">#</a>
               </h3>
               
               <p>Opens the export data file at the given path. If this is an ELF file,
searches for and opens the .go_export section. If this is an archive,
reads the export data from the first member, which is assumed to be an ELF file.
This is intended to replicate the logic in gofrontend.</p>
               
               <pre><code class="language-go">func openExportFile(fpath string) (reader io.ReadSeeker, closer io.Closer, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseArrayOrSliceType" data-name="parseArrayOrSliceType">
               <h3>
                  parseArrayOrSliceType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseArrayOrSliceType" class="anchor" title="Link to parseArrayOrSliceType">#</a>
               </h3>
               
               <p>ArrayOrSliceType = "[" [ int ] "]" Type .</p>
               
               <pre><code class="language-go">func (p *parser) parseArrayOrSliceType(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseChanType" data-name="parseChanType">
               <h3>
                  parseChanType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseChanType" class="anchor" title="Link to parseChanType">#</a>
               </h3>
               
               <p>ChanType = "chan" ["<-" | "-<"] Type .</p>
               
               <pre><code class="language-go">func (p *parser) parseChanType(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseConst" data-name="parseConst">
               <h3>
                  parseConst 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseConst" class="anchor" title="Link to parseConst">#</a>
               </h3>
               
               <p>Const = Name [Type] "=" ConstValue .</p>
               
               <pre><code class="language-go">func (p *parser) parseConst(pkg *types.Package) *types.Const</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseConstValue" data-name="parseConstValue">
               <h3>
                  parseConstValue 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseConstValue" class="anchor" title="Link to parseConstValue">#</a>
               </h3>
               
               <p>ConstValue     = string | "false" | "true" | ["-"] (int ["'"] | FloatOrComplex) | Conversion .
FloatOrComplex = float ["i" | ("+"|"-") float "i"] .</p>
               
               <pre><code class="language-go">func (p *parser) parseConstValue(pkg *types.Package) (val constant.Value, typ types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseConversion" data-name="parseConversion">
               <h3>
                  parseConversion 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseConversion" class="anchor" title="Link to parseConversion">#</a>
               </h3>
               
               <p>Conversion = "convert" "(" Type "," ConstValue ")" .</p>
               
               <pre><code class="language-go">func (p *parser) parseConversion(pkg *types.Package) (val constant.Value, typ types.Type)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseDirective" data-name="parseDirective">
               <h3>
                  parseDirective 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseDirective" class="anchor" title="Link to parseDirective">#</a>
               </h3>
               
               <p>Directive = InitDataDirective |
"package" unquotedString [ unquotedString ] [ unquotedString ] ";" |
"pkgpath" unquotedString ";" |
"prefix" unquotedString ";" |
"import" unquotedString unquotedString string ";" |
"indirectimport" unquotedString unquotedstring ";" |
"func" Func ";" |
"type" Type ";" |
"var" Var ";" |
"const" Const ";" .</p>
               
               <pre><code class="language-go">func (p *parser) parseDirective()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseExportedName" data-name="parseExportedName">
               <h3>
                  parseExportedName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseExportedName" class="anchor" title="Link to parseExportedName">#</a>
               </h3>
               
               <p>parseExportedName is like parseQualifiedName, but
the package path is resolved to an imported *types.Package.
ExportedName = string [string] .</p>
               
               <pre><code class="language-go">func (p *parser) parseExportedName() (pkg *types.Package, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseField" data-name="parseField">
               <h3>
                  parseField 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseField" class="anchor" title="Link to parseField">#</a>
               </h3>
               
               <p>Field = Name Type [string] .</p>
               
               <pre><code class="language-go">func (p *parser) parseField(pkg *types.Package) (field *types.Var, tag string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseFunc" data-name="parseFunc">
               <h3>
                  parseFunc 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseFunc" class="anchor" title="Link to parseFunc">#</a>
               </h3>
               
               <p>Func = Name FunctionType [InlineBody] .</p>
               
               <pre><code class="language-go">func (p *parser) parseFunc(pkg *types.Package) *types.Func</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseFunctionType" data-name="parseFunctionType">
               <h3>
                  parseFunctionType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseFunctionType" class="anchor" title="Link to parseFunctionType">#</a>
               </h3>
               
               <p>FunctionType = ParamList ResultList .</p>
               
               <pre><code class="language-go">func (p *parser) parseFunctionType(pkg *types.Package, nlist []any) *types.Signature</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseInitDataDirective" data-name="parseInitDataDirective">
               <h3>
                  parseInitDataDirective 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseInitDataDirective" class="anchor" title="Link to parseInitDataDirective">#</a>
               </h3>
               
               <p>InitDataDirective = ( "v1" | "v2" | "v3" ) ";" |
"priority" int ";" |
"init" { PackageInit } ";" |
"checksum" unquotedString ";" .</p>
               
               <pre><code class="language-go">func (p *parser) parseInitDataDirective()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseInt" data-name="parseInt">
               <h3>
                  parseInt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseInt" class="anchor" title="Link to parseInt">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) parseInt() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseInt64" data-name="parseInt64">
               <h3>
                  parseInt64 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseInt64" class="anchor" title="Link to parseInt64">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) parseInt64() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseInterfaceType" data-name="parseInterfaceType">
               <h3>
                  parseInterfaceType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseInterfaceType" class="anchor" title="Link to parseInterfaceType">#</a>
               </h3>
               
               <p>InterfaceType = "interface" "{" { ("?" Type | Func) ";" } "}" .</p>
               
               <pre><code class="language-go">func (p *parser) parseInterfaceType(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseMapType" data-name="parseMapType">
               <h3>
                  parseMapType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseMapType" class="anchor" title="Link to parseMapType">#</a>
               </h3>
               
               <p>MapType = "map" "[" Type "]" Type .</p>
               
               <pre><code class="language-go">func (p *parser) parseMapType(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseName" data-name="parseName">
               <h3>
                  parseName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseName" class="anchor" title="Link to parseName">#</a>
               </h3>
               
               <p>Name = QualifiedName | "?" .</p>
               
               <pre><code class="language-go">func (p *parser) parseName() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseNamedType" data-name="parseNamedType">
               <h3>
                  parseNamedType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseNamedType" class="anchor" title="Link to parseNamedType">#</a>
               </h3>
               
               <p>NamedType = TypeName [ "=" ] Type { Method } .
TypeName  = ExportedName .
Method    = "func" "(" Param ")" Name ParamList ResultList [InlineBody] ";" .</p>
               
               <pre><code class="language-go">func (p *parser) parseNamedType(nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePackage" data-name="parsePackage">
               <h3>
                  parsePackage 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parsePackage" class="anchor" title="Link to parsePackage">#</a>
               </h3>
               
               <p>Package = { Directive } .</p>
               
               <pre><code class="language-go">func (p *parser) parsePackage() *types.Package</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePackageInit" data-name="parsePackageInit">
               <h3>
                  parsePackageInit 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parsePackageInit" class="anchor" title="Link to parsePackageInit">#</a>
               </h3>
               
               <p>PackageInit = unquotedString unquotedString int .</p>
               
               <pre><code class="language-go">func (p *parser) parsePackageInit() PackageInit</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseParam" data-name="parseParam">
               <h3>
                  parseParam 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseParam" class="anchor" title="Link to parseParam">#</a>
               </h3>
               
               <p>Param = Name ["..."] Type .</p>
               
               <pre><code class="language-go">func (p *parser) parseParam(pkg *types.Package) (param *types.Var, isVariadic bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseParamList" data-name="parseParamList">
               <h3>
                  parseParamList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseParamList" class="anchor" title="Link to parseParamList">#</a>
               </h3>
               
               <p>ParamList = "(" [ { Parameter "," } Parameter ] ")" .</p>
               
               <pre><code class="language-go">func (p *parser) parseParamList(pkg *types.Package) (*types.Tuple, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parsePointerType" data-name="parsePointerType">
               <h3>
                  parsePointerType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parsePointerType" class="anchor" title="Link to parsePointerType">#</a>
               </h3>
               
               <p>PointerType = "*" ("any" | Type) .</p>
               
               <pre><code class="language-go">func (p *parser) parsePointerType(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseQualifiedName" data-name="parseQualifiedName">
               <h3>
                  parseQualifiedName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseQualifiedName" class="anchor" title="Link to parseQualifiedName">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) parseQualifiedName() (path string, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseQualifiedNameStr" data-name="parseQualifiedNameStr">
               <h3>
                  parseQualifiedNameStr 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseQualifiedNameStr" class="anchor" title="Link to parseQualifiedNameStr">#</a>
               </h3>
               
               <p>qualifiedName = [ ["."] unquotedString "." ] unquotedString .
The above production uses greedy matching.</p>
               
               <pre><code class="language-go">func (p *parser) parseQualifiedNameStr(unquotedName string) (pkgpath string, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseResultList" data-name="parseResultList">
               <h3>
                  parseResultList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseResultList" class="anchor" title="Link to parseResultList">#</a>
               </h3>
               
               <p>ResultList = Type | ParamList .</p>
               
               <pre><code class="language-go">func (p *parser) parseResultList(pkg *types.Package) *types.Tuple</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseSavedType" data-name="parseSavedType">
               <h3>
                  parseSavedType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseSavedType" class="anchor" title="Link to parseSavedType">#</a>
               </h3>
               
               <p>parseSavedType parses one saved type definition.</p>
               
               <pre><code class="language-go">func (p *parser) parseSavedType(pkg *types.Package, i int, nlist []any)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseString" data-name="parseString">
               <h3>
                  parseString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseString" class="anchor" title="Link to parseString">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) parseString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseStructType" data-name="parseStructType">
               <h3>
                  parseStructType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseStructType" class="anchor" title="Link to parseStructType">#</a>
               </h3>
               
               <p>StructType = "struct" "{" { Field } "}" .</p>
               
               <pre><code class="language-go">func (p *parser) parseStructType(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseType" data-name="parseType">
               <h3>
                  parseType 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseType" class="anchor" title="Link to parseType">#</a>
               </h3>
               
               <p>Type = "<" "type" ( "-" int | int [ TypeSpec ] ) ">" .
parseType updates the type map to t for all type numbers n.</p>
               
               <pre><code class="language-go">func (p *parser) parseType(pkg *types.Package, n ...any) types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseTypeAfterAngle" data-name="parseTypeAfterAngle">
               <h3>
                  parseTypeAfterAngle 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseTypeAfterAngle" class="anchor" title="Link to parseTypeAfterAngle">#</a>
               </h3>
               
               <p>(*parser).Type after reading the "<".</p>
               
               <pre><code class="language-go">func (p *parser) parseTypeAfterAngle(pkg *types.Package, n ...any) (t types.Type, n1 int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseTypeExtended" data-name="parseTypeExtended">
               <h3>
                  parseTypeExtended 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseTypeExtended" class="anchor" title="Link to parseTypeExtended">#</a>
               </h3>
               
               <p>parseTypeExtended is identical to parseType, but if the type in
question is a saved type, returns the index as well as the type
pointer (index returned is zero if we parsed a builtin).</p>
               
               <pre><code class="language-go">func (p *parser) parseTypeExtended(pkg *types.Package, n ...any) (t types.Type, n1 int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseTypeSpec" data-name="parseTypeSpec">
               <h3>
                  parseTypeSpec 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseTypeSpec" class="anchor" title="Link to parseTypeSpec">#</a>
               </h3>
               
               <p>TypeSpec = NamedType | MapType | ChanType | StructType | InterfaceType | PointerType | ArrayOrSliceType | FunctionType .</p>
               
               <pre><code class="language-go">func (p *parser) parseTypeSpec(pkg *types.Package, nlist []any) types.Type</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseTypes" data-name="parseTypes">
               <h3>
                  parseTypes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseTypes" class="anchor" title="Link to parseTypes">#</a>
               </h3>
               
               <p>Types = "types" maxp1 exportedp1 (offset length)* .</p>
               
               <pre><code class="language-go">func (p *parser) parseTypes(pkg *types.Package)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseUnquotedQualifiedName" data-name="parseUnquotedQualifiedName">
               <h3>
                  parseUnquotedQualifiedName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseUnquotedQualifiedName" class="anchor" title="Link to parseUnquotedQualifiedName">#</a>
               </h3>
               
               <pre><code class="language-go">func (p *parser) parseUnquotedQualifiedName() (path string, name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseUnquotedString" data-name="parseUnquotedString">
               <h3>
                  parseUnquotedString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseUnquotedString" class="anchor" title="Link to parseUnquotedString">#</a>
               </h3>
               
               <p>unquotedString     = { unquotedStringChar } .
unquotedStringChar = <neither a whitespace nor a ';' char> .</p>
               
               <pre><code class="language-go">func (p *parser) parseUnquotedString() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseVar" data-name="parseVar">
               <h3>
                  parseVar 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseVar" class="anchor" title="Link to parseVar">#</a>
               </h3>
               
               <p>Var = Name Type .</p>
               
               <pre><code class="language-go">func (p *parser) parseVar(pkg *types.Package) *types.Var</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readMagic" data-name="readMagic">
               <h3>
                  readMagic 
                  <span class="badge">function</span>
                  
                  <a href="#readMagic" class="anchor" title="Link to readMagic">#</a>
               </h3>
               
               <p>readMagic reads the four bytes at the start of a ReadSeeker and
returns them as a string.</p>
               
               <pre><code class="language-go">func readMagic(reader io.ReadSeeker) (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readerAtFromSeeker" data-name="readerAtFromSeeker">
               <h3>
                  readerAtFromSeeker 
                  <span class="badge">function</span>
                  
                  <a href="#readerAtFromSeeker" class="anchor" title="Link to readerAtFromSeeker">#</a>
               </h3>
               
               <p>readerAtFromSeeker turns an io.ReadSeeker into an io.ReaderAt.
This is only safe because there won't be any concurrent seeks
while this code is executing.</p>
               
               <pre><code class="language-go">func readerAtFromSeeker(rs io.ReadSeeker) io.ReaderAt</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="reserve" data-name="reserve">
               <h3>
                  reserve 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#reserve" class="anchor" title="Link to reserve">#</a>
               </h3>
               
               <p>reserve reserves the type map entry n for future use.</p>
               
               <pre><code class="language-go">func (p *parser) reserve(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skipInlineBody" data-name="skipInlineBody">
               <h3>
                  skipInlineBody 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#skipInlineBody" class="anchor" title="Link to skipInlineBody">#</a>
               </h3>
               
               <p>InlineBody = "<inl:NN>" .{NN}
Reports whether a body was skipped.</p>
               
               <pre><code class="language-go">func (p *parser) skipInlineBody()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="standardArExportData" data-name="standardArExportData">
               <h3>
                  standardArExportData 
                  <span class="badge">function</span>
                  
                  <a href="#standardArExportData" class="anchor" title="Link to standardArExportData">#</a>
               </h3>
               
               <p>standardArExportData returns export data from a standard archive.</p>
               
               <pre><code class="language-go">func standardArExportData(archive io.ReadSeeker) (io.ReadSeeker, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="update" data-name="update">
               <h3>
                  update 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#update" class="anchor" title="Link to update">#</a>
               </h3>
               
               <p>update sets the type map entries for the entries in nlist to t.
An entry in nlist can be a type number in p.typeList,
used to resolve named types, or it can be a *types.Pointer,
used to resolve pointers to named types in case they are referenced
by embedded fields.</p>
               
               <pre><code class="language-go">func (p *parser) update(t types.Type, nlist []any)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>