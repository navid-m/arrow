<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - modindex</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>modindex</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"bytes"
"cmd/go/internal/fsys"
"cmd/go/internal/str"
"errors"
"fmt"
"go/ast"
"go/build"
"go/build/constraint"
"go/token"
"internal/syslist"
"io"
"io/fs"
"path/filepath"
"sort"
"strings"
"unicode"
"unicode/utf8"
"bufio"
"bytes"
"errors"
"fmt"
"go/ast"
"go/build"
"go/parser"
"go/token"
"io"
"strconv"
"strings"
"unicode"
"unicode/utf8"
"bytes"
"encoding/binary"
"errors"
"fmt"
"go/build"
"go/build/constraint"
"go/token"
"internal/godebug"
"internal/goroot"
"path"
"path/filepath"
"runtime"
"runtime/debug"
"sort"
"strings"
"sync"
"time"
"unsafe"
"cmd/go/internal/base"
"cmd/go/internal/cache"
"cmd/go/internal/cfg"
"cmd/go/internal/fsys"
"cmd/go/internal/imports"
"cmd/go/internal/str"
"cmd/internal/par"
"cmd/go/internal/base"
"cmd/go/internal/fsys"
"cmd/go/internal/str"
"encoding/json"
"errors"
"fmt"
"go/build"
"go/doc"
"go/scanner"
"go/token"
"io/fs"
"path/filepath"
"strings"
"cmd/go/internal/base"
"encoding/binary"
"go/token"
"sort"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="ErrNotIndexed" data-name="ErrNotIndexed">
               <h3>
                  ErrNotIndexed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrNotIndexed" class="anchor" title="Link to ErrNotIndexed">#</a>
               </h3>
               
               <pre><code>var ErrNotIndexed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bPlusBuild" data-name="bPlusBuild">
               <h3>
                  bPlusBuild 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bPlusBuild" class="anchor" title="Link to bPlusBuild">#</a>
               </h3>
               
               <pre><code>var bPlusBuild = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bSlashSlash" data-name="bSlashSlash">
               <h3>
                  bSlashSlash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bSlashSlash" class="anchor" title="Link to bSlashSlash">#</a>
               </h3>
               
               <pre><code>var bSlashSlash = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bSlashStar" data-name="bSlashStar">
               <h3>
                  bSlashStar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bSlashStar" class="anchor" title="Link to bSlashStar">#</a>
               </h3>
               
               <pre><code>var bSlashStar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bStarSlash" data-name="bStarSlash">
               <h3>
                  bStarSlash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bStarSlash" class="anchor" title="Link to bStarSlash">#</a>
               </h3>
               
               <pre><code>var bStarSlash = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="binaryOnlyComment" data-name="binaryOnlyComment">
               <h3>
                  binaryOnlyComment 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#binaryOnlyComment" class="anchor" title="Link to binaryOnlyComment">#</a>
               </h3>
               
               <p>Special comment denoting a binary-only package.
See https://golang.org/design/2775-binary-only-packages
for more about the design of binary-only packages.</p>
               
               <pre><code>var binaryOnlyComment = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="bom" data-name="bom">
               <h3>
                  bom 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#bom" class="anchor" title="Link to bom">#</a>
               </h3>
               
               <pre><code>var bom = []byte{...}</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultReleaseTags" data-name="defaultReleaseTags">
               <h3>
                  defaultReleaseTags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultReleaseTags" class="anchor" title="Link to defaultReleaseTags">#</a>
               </h3>
               
               <pre><code>var defaultReleaseTags []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="defaultToolTags" data-name="defaultToolTags">
               <h3>
                  defaultToolTags 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#defaultToolTags" class="anchor" title="Link to defaultToolTags">#</a>
               </h3>
               
               <pre><code>var defaultToolTags []string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="dummyPkg" data-name="dummyPkg">
               <h3>
                  dummyPkg 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#dummyPkg" class="anchor" title="Link to dummyPkg">#</a>
               </h3>
               
               <pre><code>var dummyPkg build.Package</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="enabled" data-name="enabled">
               <h3>
                  enabled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#enabled" class="anchor" title="Link to enabled">#</a>
               </h3>
               
               <p>enabled is used to flag off the behavior of the module index on tip, for debugging.</p>
               
               <pre><code>var enabled = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errCannotFindPackage" data-name="errCannotFindPackage">
               <h3>
                  errCannotFindPackage 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errCannotFindPackage" class="anchor" title="Link to errCannotFindPackage">#</a>
               </h3>
               
               <pre><code>var errCannotFindPackage = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errCorrupt" data-name="errCorrupt">
               <h3>
                  errCorrupt 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errCorrupt" class="anchor" title="Link to errCorrupt">#</a>
               </h3>
               
               <pre><code>var errCorrupt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errDisabled" data-name="errDisabled">
               <h3>
                  errDisabled 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errDisabled" class="anchor" title="Link to errDisabled">#</a>
               </h3>
               
               <pre><code>var errDisabled = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errFIPS140" data-name="errFIPS140">
               <h3>
                  errFIPS140 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errFIPS140" class="anchor" title="Link to errFIPS140">#</a>
               </h3>
               
               <pre><code>var errFIPS140 = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errMultipleGoBuild" data-name="errMultipleGoBuild">
               <h3>
                  errMultipleGoBuild 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errMultipleGoBuild" class="anchor" title="Link to errMultipleGoBuild">#</a>
               </h3>
               
               <pre><code>var errMultipleGoBuild = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNUL" data-name="errNUL">
               <h3>
                  errNUL 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNUL" class="anchor" title="Link to errNUL">#</a>
               </h3>
               
               <pre><code>var errNUL = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNoModules" data-name="errNoModules">
               <h3>
                  errNoModules 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNoModules" class="anchor" title="Link to errNoModules">#</a>
               </h3>
               
               <pre><code>var errNoModules = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNonSource" data-name="errNonSource">
               <h3>
                  errNonSource 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNonSource" class="anchor" title="Link to errNonSource">#</a>
               </h3>
               
               <pre><code>var errNonSource = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNotFromModuleCache" data-name="errNotFromModuleCache">
               <h3>
                  errNotFromModuleCache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNotFromModuleCache" class="anchor" title="Link to errNotFromModuleCache">#</a>
               </h3>
               
               <pre><code>var errNotFromModuleCache = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errSyntax" data-name="errSyntax">
               <h3>
                  errSyntax 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errSyntax" class="anchor" title="Link to errSyntax">#</a>
               </h3>
               
               <pre><code>var errSyntax = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goBuildComment" data-name="goBuildComment">
               <h3>
                  goBuildComment 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goBuildComment" class="anchor" title="Link to goBuildComment">#</a>
               </h3>
               
               <pre><code>var goBuildComment = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="goEmbed" data-name="goEmbed">
               <h3>
                  goEmbed 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#goEmbed" class="anchor" title="Link to goEmbed">#</a>
               </h3>
               
               <pre><code>var goEmbed = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="indexVersion" data-name="indexVersion">
               <h3>
                  indexVersion 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#indexVersion" class="anchor" title="Link to indexVersion">#</a>
               </h3>
               
               <pre><code>const indexVersion = "go index v2"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="installgorootAll" data-name="installgorootAll">
               <h3>
                  installgorootAll 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#installgorootAll" class="anchor" title="Link to installgorootAll">#</a>
               </h3>
               
               <pre><code>var installgorootAll = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="isTest" data-name="isTest">
               <h3>
                  isTest 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#isTest" class="anchor" title="Link to isTest">#</a>
               </h3>
               
               <pre><code>var isTest = false</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="mcache" data-name="mcache">
               <h3>
                  mcache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#mcache" class="anchor" title="Link to mcache">#</a>
               </h3>
               
               <pre><code>var mcache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="modTimeCutoff" data-name="modTimeCutoff">
               <h3>
                  modTimeCutoff 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#modTimeCutoff" class="anchor" title="Link to modTimeCutoff">#</a>
               </h3>
               
               <pre><code>const modTimeCutoff = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="newline" data-name="newline">
               <h3>
                  newline 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#newline" class="anchor" title="Link to newline">#</a>
               </h3>
               
               <pre><code>var newline = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pcache" data-name="pcache">
               <h3>
                  pcache 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#pcache" class="anchor" title="Link to pcache">#</a>
               </h3>
               
               <pre><code>var pcache *ast.IndexListExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="safeString" data-name="safeString">
               <h3>
                  safeString 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#safeString" class="anchor" title="Link to safeString">#</a>
               </h3>
               
               <p>NOTE: $ is not safe for the shell, but it is allowed here because of linker options like -Wl,$ORIGIN.
We never pass these arguments to a shell (just to programs we construct argv for), so this should be okay.
See golang.org/issue/6038.
The @ is for OS X. See golang.org/issue/13720.
The % is for Jenkins. See golang.org/issue/16959.
The ! is because module paths may use them. See golang.org/issue/26716.
The ~ and ^ are for sr.ht. See golang.org/issue/32260.</p>
               
               <pre><code>const safeString = "+-.,/0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz:$@%! ~^"</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="slashSlash" data-name="slashSlash">
               <h3>
                  slashSlash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#slashSlash" class="anchor" title="Link to slashSlash">#</a>
               </h3>
               
               <pre><code>var slashSlash = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="slashStar" data-name="slashStar">
               <h3>
                  slashStar 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#slashStar" class="anchor" title="Link to slashStar">#</a>
               </h3>
               
               <pre><code>var slashStar = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sourceFileBinaryOnly" data-name="sourceFileBinaryOnly">
               <h3>
                  sourceFileBinaryOnly 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sourceFileBinaryOnly" class="anchor" title="Link to sourceFileBinaryOnly">#</a>
               </h3>
               
               <p>Offsets for fields in the sourceFile.</p>
               
               <pre><code>const sourceFileBinaryOnly</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sourceFileCgoDirectives" data-name="sourceFileCgoDirectives">
               <h3>
                  sourceFileCgoDirectives 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sourceFileCgoDirectives" class="anchor" title="Link to sourceFileCgoDirectives">#</a>
               </h3>
               
               <p>Offsets for fields in the sourceFile.</p>
               
               <pre><code>const sourceFileCgoDirectives</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sourceFileError" data-name="sourceFileError">
               <h3>
                  sourceFileError 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sourceFileError" class="anchor" title="Link to sourceFileError">#</a>
               </h3>
               
               <p>Offsets for fields in the sourceFile.</p>
               
               <pre><code>const sourceFileError = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sourceFileGoBuildConstraint" data-name="sourceFileGoBuildConstraint">
               <h3>
                  sourceFileGoBuildConstraint 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sourceFileGoBuildConstraint" class="anchor" title="Link to sourceFileGoBuildConstraint">#</a>
               </h3>
               
               <p>Offsets for fields in the sourceFile.</p>
               
               <pre><code>const sourceFileGoBuildConstraint</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sourceFileIgnoreFile" data-name="sourceFileIgnoreFile">
               <h3>
                  sourceFileIgnoreFile 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sourceFileIgnoreFile" class="anchor" title="Link to sourceFileIgnoreFile">#</a>
               </h3>
               
               <p>Offsets for fields in the sourceFile.</p>
               
               <pre><code>const sourceFileIgnoreFile</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sourceFileName" data-name="sourceFileName">
               <h3>
                  sourceFileName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sourceFileName" class="anchor" title="Link to sourceFileName">#</a>
               </h3>
               
               <p>Offsets for fields in the sourceFile.</p>
               
               <pre><code>const sourceFileName</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sourceFileNumPlusBuildConstraints" data-name="sourceFileNumPlusBuildConstraints">
               <h3>
                  sourceFileNumPlusBuildConstraints 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sourceFileNumPlusBuildConstraints" class="anchor" title="Link to sourceFileNumPlusBuildConstraints">#</a>
               </h3>
               
               <p>Offsets for fields in the sourceFile.</p>
               
               <pre><code>const sourceFileNumPlusBuildConstraints</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sourceFileParseError" data-name="sourceFileParseError">
               <h3>
                  sourceFileParseError 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sourceFileParseError" class="anchor" title="Link to sourceFileParseError">#</a>
               </h3>
               
               <p>Offsets for fields in the sourceFile.</p>
               
               <pre><code>const sourceFileParseError</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sourceFilePkgName" data-name="sourceFilePkgName">
               <h3>
                  sourceFilePkgName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sourceFilePkgName" class="anchor" title="Link to sourceFilePkgName">#</a>
               </h3>
               
               <p>Offsets for fields in the sourceFile.</p>
               
               <pre><code>const sourceFilePkgName</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="sourceFileSynopsis" data-name="sourceFileSynopsis">
               <h3>
                  sourceFileSynopsis 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#sourceFileSynopsis" class="anchor" title="Link to sourceFileSynopsis">#</a>
               </h3>
               
               <p>Offsets for fields in the sourceFile.</p>
               
               <pre><code>const sourceFileSynopsis</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="starSlash" data-name="starSlash">
               <h3>
                  starSlash 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#starSlash" class="anchor" title="Link to starSlash">#</a>
               </h3>
               
               <pre><code>var starSlash = *ast.CallExpr</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Context" data-name="Context">
               <h3>
                  Context
                  <span class="badge">struct</span>
                  <a href="#Context" class="anchor" title="Link to Context">#</a>
               </h3>
               
               <p>A Context specifies the supporting context for a build.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Context struct {
GOARCH string
GOOS string
GOROOT string
GOPATH string
Dir string
CgoEnabled bool
UseAllFiles bool
Compiler string
BuildTags []string
ToolTags []string
ReleaseTags []string
InstallSuffix string
JoinPath func(elem ...string) string
SplitPathList func(list string) []string
IsAbsPath func(path string) bool
IsDir func(path string) bool
HasSubdir func(root string, dir string) (rel string, ok bool)
ReadDir func(dir string) ([]fs.FileInfo, error)
OpenFile func(path string) (io.ReadCloser, error)
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="IndexPackage" data-name="IndexPackage">
               <h3>
                  IndexPackage
                  <span class="badge">struct</span>
                  <a href="#IndexPackage" class="anchor" title="Link to IndexPackage">#</a>
               </h3>
               
               <p>IndexPackage holds the information in the index
needed to load a package in a specific directory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type IndexPackage struct {
error error
dir string
modroot string
sourceFiles []*sourceFile
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Module" data-name="Module">
               <h3>
                  Module
                  <span class="badge">struct</span>
                  <a href="#Module" class="anchor" title="Link to Module">#</a>
               </h3>
               
               <p>Module represents and encoded module index file. It is used to
do the equivalent of build.Import of packages in the module and answer other
questions based on the index file's data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Module struct {
modroot string
d *decoder
n int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="MultiplePackageError" data-name="MultiplePackageError">
               <h3>
                  MultiplePackageError
                  <span class="badge">struct</span>
                  <a href="#MultiplePackageError" class="anchor" title="Link to MultiplePackageError">#</a>
               </h3>
               
               <p>MultiplePackageError describes a directory containing
multiple buildable Go source files for multiple packages.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type MultiplePackageError struct {
Dir string
Packages []string
Files []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="NoGoError" data-name="NoGoError">
               <h3>
                  NoGoError
                  <span class="badge">struct</span>
                  <a href="#NoGoError" class="anchor" title="Link to NoGoError">#</a>
               </h3>
               
               <p>NoGoError is the error used by Import to describe a directory
containing no buildable Go source files. (It may still contain
test files, files hidden by build tags, and so on.)</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type NoGoError struct {
Dir string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="decoder" data-name="decoder">
               <h3>
                  decoder
                  <span class="badge">struct</span>
                  <a href="#decoder" class="anchor" title="Link to decoder">#</a>
               </h3>
               
               <p>A decoder helps decode the index format.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type decoder struct {
data []byte
str []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="embed" data-name="embed">
               <h3>
                  embed
                  <span class="badge">struct</span>
                  <a href="#embed" class="anchor" title="Link to embed">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type embed struct {
pattern string
position token.Position
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="encoder" data-name="encoder">
               <h3>
                  encoder
                  <span class="badge">struct</span>
                  <a href="#encoder" class="anchor" title="Link to encoder">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type encoder struct {
b []byte
stringTable []byte
strings map[string]int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileEmbed" data-name="fileEmbed">
               <h3>
                  fileEmbed
                  <span class="badge">struct</span>
                  <a href="#fileEmbed" class="anchor" title="Link to fileEmbed">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileEmbed struct {
pattern string
pos token.Position
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileImport" data-name="fileImport">
               <h3>
                  fileImport
                  <span class="badge">struct</span>
                  <a href="#fileImport" class="anchor" title="Link to fileImport">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileImport struct {
path string
pos token.Pos
doc *ast.CommentGroup
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="fileInfo" data-name="fileInfo">
               <h3>
                  fileInfo
                  <span class="badge">struct</span>
                  <a href="#fileInfo" class="anchor" title="Link to fileInfo">#</a>
               </h3>
               
               <p>fileInfo records information learned about a file included in a build.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type fileInfo struct {
name string
header []byte
fset *token.FileSet
parsed *ast.File
parseErr error
imports []fileImport
embeds []fileEmbed
directives []build.Directive
binaryOnly bool
goBuildConstraint string
plusBuildConstraints []string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="importReader" data-name="importReader">
               <h3>
                  importReader
                  <span class="badge">struct</span>
                  <a href="#importReader" class="anchor" title="Link to importReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type importReader struct {
b *bufio.Reader
buf []byte
peek byte
err error
eof bool
nerr int
pos token.Position
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="parseError" data-name="parseError">
               <h3>
                  parseError
                  <span class="badge">struct</span>
                  <a href="#parseError" class="anchor" title="Link to parseError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type parseError struct {
ErrorList *scanner.ErrorList
ErrorString string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="rawFile" data-name="rawFile">
               <h3>
                  rawFile
                  <span class="badge">struct</span>
                  <a href="#rawFile" class="anchor" title="Link to rawFile">#</a>
               </h3>
               
               <p>rawFile is the struct representation of the file holding all
information in its fields.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rawFile struct {
error string
parseError string
name string
synopsis string
pkgName string
ignoreFile bool
binaryOnly bool
cgoDirectives string
goBuildConstraint string
plusBuildConstraints []string
imports []rawImport
embeds []embed
directives []build.Directive
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="rawImport" data-name="rawImport">
               <h3>
                  rawImport
                  <span class="badge">struct</span>
                  <a href="#rawImport" class="anchor" title="Link to rawImport">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rawImport struct {
path string
position token.Position
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="rawPackage" data-name="rawPackage">
               <h3>
                  rawPackage
                  <span class="badge">struct</span>
                  <a href="#rawPackage" class="anchor" title="Link to rawPackage">#</a>
               </h3>
               
               <p>rawPackage holds the information from each package that's needed to
fill a build.Package once the context is available.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type rawPackage struct {
error string
dir string
sourceFiles []*rawFile
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="reader" data-name="reader">
               <h3>
                  reader
                  <span class="badge">struct</span>
                  <a href="#reader" class="anchor" title="Link to reader">#</a>
               </h3>
               
               <p>A reader reads sequential fields from a section of the index format.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type reader struct {
d *decoder
pos int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="sourceFile" data-name="sourceFile">
               <h3>
                  sourceFile
                  <span class="badge">struct</span>
                  <a href="#sourceFile" class="anchor" title="Link to sourceFile">#</a>
               </h3>
               
               <p>sourceFile represents the information of a given source file in the module index.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type sourceFile struct {
d *decoder
pos int
onceReadImports sync.Once
savedImports []rawImport
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Bool" data-name="Bool">
               <h3>
                  Bool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bool" class="anchor" title="Link to Bool">#</a>
               </h3>
               
               <pre><code>func (e *encoder) Bool(b bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Bytes" data-name="Bytes">
               <h3>
                  Bytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Bytes" class="anchor" title="Link to Bytes">#</a>
               </h3>
               
               <pre><code>func (e *encoder) Bytes(b []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *NoGoError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *MultiplePackageError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetModule" data-name="GetModule">
               <h3>
                  GetModule 
                  <span class="badge">function</span>
                  
                  <a href="#GetModule" class="anchor" title="Link to GetModule">#</a>
               </h3>
               
               <p>GetModule returns the Module for the given modroot.
It will return ErrNotIndexed if the directory should be read without
using the index, for instance because the index is disabled, or the package
is not in a module.</p>
               
               <pre><code>func GetModule(modroot string) (*Module, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GetPackage" data-name="GetPackage">
               <h3>
                  GetPackage 
                  <span class="badge">function</span>
                  
                  <a href="#GetPackage" class="anchor" title="Link to GetPackage">#</a>
               </h3>
               
               <p>GetPackage returns the IndexPackage for the directory at the given path.
It will return ErrNotIndexed if the directory should be read without
using the index, for instance because the index is disabled, or the package
is not in a module.</p>
               
               <pre><code>func GetPackage(modroot string, pkgdir string) (*IndexPackage, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Import" data-name="Import">
               <h3>
                  Import 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Import" class="anchor" title="Link to Import">#</a>
               </h3>
               
               <p>Import is the equivalent of build.Import given the information in Module.</p>
               
               <pre><code>func (rp *IndexPackage) Import(bctxt build.Context, mode build.ImportMode) (p *build.Package, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Int" data-name="Int">
               <h3>
                  Int 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Int" class="anchor" title="Link to Int">#</a>
               </h3>
               
               <p>Int encodes n. Note that all ints are written to the index as uint32s,
and to avoid problems on 32-bit systems we require fitting into a 32-bit int.</p>
               
               <pre><code>func (e *encoder) Int(n int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IntAt" data-name="IntAt">
               <h3>
                  IntAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IntAt" class="anchor" title="Link to IntAt">#</a>
               </h3>
               
               <pre><code>func (e *encoder) IntAt(n int, at int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsGoDir" data-name="IsGoDir">
               <h3>
                  IsGoDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsGoDir" class="anchor" title="Link to IsGoDir">#</a>
               </h3>
               
               <p>IsGoDir is the equivalent of fsys.IsGoDir using the information in the index.</p>
               
               <pre><code>func (rp *IndexPackage) IsGoDir() (_ bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsStandardPackage" data-name="IsStandardPackage">
               <h3>
                  IsStandardPackage 
                  <span class="badge">function</span>
                  
                  <a href="#IsStandardPackage" class="anchor" title="Link to IsStandardPackage">#</a>
               </h3>
               
               <p>IsStandardPackage reports whether path is a standard package
for the goroot and compiler using the module index if possible,
and otherwise falling back to internal/goroot.IsStandardPackage</p>
               
               <pre><code>func IsStandardPackage(goroot_ string, compiler string, path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Package" data-name="Package">
               <h3>
                  Package 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Package" class="anchor" title="Link to Package">#</a>
               </h3>
               
               <p>Package and returns finds the package with the given path (relative to the module root).
If the package does not exist, Package returns an IndexPackage that will return an
appropriate error from its methods.</p>
               
               <pre><code>func (m *Module) Package(path string) *IndexPackage</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Pos" data-name="Pos">
               <h3>
                  Pos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Pos" class="anchor" title="Link to Pos">#</a>
               </h3>
               
               <pre><code>func (e *encoder) Pos() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Position" data-name="Position">
               <h3>
                  Position 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Position" class="anchor" title="Link to Position">#</a>
               </h3>
               
               <pre><code>func (e *encoder) Position(position token.Position)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ScanDir" data-name="ScanDir">
               <h3>
                  ScanDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ScanDir" class="anchor" title="Link to ScanDir">#</a>
               </h3>
               
               <p>ScanDir implements imports.ScanDir using the information in the index.</p>
               
               <pre><code>func (rp *IndexPackage) ScanDir(tags map[string]bool) (sortedImports []string, sortedTestImports []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (e *encoder) String(s string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Uint32" data-name="Uint32">
               <h3>
                  Uint32 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Uint32" class="anchor" title="Link to Uint32">#</a>
               </h3>
               
               <pre><code>func (e *encoder) Uint32(n uint32)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Walk" data-name="Walk">
               <h3>
                  Walk 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Walk" class="anchor" title="Link to Walk">#</a>
               </h3>
               
               <p>Walk calls f for each package in the index, passing the path to that package relative to the module root.</p>
               
               <pre><code>func (m *Module) Walk(f func(path string))</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asString" data-name="asString">
               <h3>
                  asString 
                  <span class="badge">function</span>
                  
                  <a href="#asString" class="anchor" title="Link to asString">#</a>
               </h3>
               
               <pre><code>func asString(b []byte) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="binaryOnly" data-name="binaryOnly">
               <h3>
                  binaryOnly 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#binaryOnly" class="anchor" title="Link to binaryOnly">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) binaryOnly() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="bool" data-name="bool">
               <h3>
                  bool 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#bool" class="anchor" title="Link to bool">#</a>
               </h3>
               
               <p>bool reads the next bool.</p>
               
               <pre><code>func (r *reader) bool() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="boolAt" data-name="boolAt">
               <h3>
                  boolAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#boolAt" class="anchor" title="Link to boolAt">#</a>
               </h3>
               
               <p>boolAt returns the bool at the given offset in d.data.</p>
               
               <pre><code>func (d *decoder) boolAt(off int) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cgoDirectives" data-name="cgoDirectives">
               <h3>
                  cgoDirectives 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#cgoDirectives" class="anchor" title="Link to cgoDirectives">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) cgoDirectives() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="cleanDecls" data-name="cleanDecls">
               <h3>
                  cleanDecls 
                  <span class="badge">function</span>
                  
                  <a href="#cleanDecls" class="anchor" title="Link to cleanDecls">#</a>
               </h3>
               
               <pre><code>func cleanDecls(m map[string][]token.Position) ([]string, map[string][]token.Position)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="dirHash" data-name="dirHash">
               <h3>
                  dirHash 
                  <span class="badge">function</span>
                  
                  <a href="#dirHash" class="anchor" title="Link to dirHash">#</a>
               </h3>
               
               <p>dirHash returns an ActionID corresponding to the state of the package
located at filesystem path pkgdir.</p>
               
               <pre><code>func dirHash(modroot string, pkgdir string) (cache.ActionID, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="directives" data-name="directives">
               <h3>
                  directives 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#directives" class="anchor" title="Link to directives">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) directives() []build.Directive</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="directivesOffset" data-name="directivesOffset">
               <h3>
                  directivesOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#directivesOffset" class="anchor" title="Link to directivesOffset">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) directivesOffset() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="embeds" data-name="embeds">
               <h3>
                  embeds 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#embeds" class="anchor" title="Link to embeds">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) embeds() []embed</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="embedsOffset" data-name="embedsOffset">
               <h3>
                  embedsOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#embedsOffset" class="anchor" title="Link to embedsOffset">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) embedsOffset() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="encodeFile" data-name="encodeFile">
               <h3>
                  encodeFile 
                  <span class="badge">function</span>
                  
                  <a href="#encodeFile" class="anchor" title="Link to encodeFile">#</a>
               </h3>
               
               <pre><code>func encodeFile(e *encoder, f *rawFile)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="encodeModuleBytes" data-name="encodeModuleBytes">
               <h3>
                  encodeModuleBytes 
                  <span class="badge">function</span>
                  
                  <a href="#encodeModuleBytes" class="anchor" title="Link to encodeModuleBytes">#</a>
               </h3>
               
               <p>encodeModuleBytes produces the encoded representation of the module index.
encodeModuleBytes may modify the packages slice.</p>
               
               <pre><code>func encodeModuleBytes(packages []*rawPackage) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="encodePackage" data-name="encodePackage">
               <h3>
                  encodePackage 
                  <span class="badge">function</span>
                  
                  <a href="#encodePackage" class="anchor" title="Link to encodePackage">#</a>
               </h3>
               
               <pre><code>func encodePackage(e *encoder, p *rawPackage)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="encodePackageBytes" data-name="encodePackageBytes">
               <h3>
                  encodePackageBytes 
                  <span class="badge">function</span>
                  
                  <a href="#encodePackageBytes" class="anchor" title="Link to encodePackageBytes">#</a>
               </h3>
               
               <pre><code>func encodePackageBytes(p *rawPackage) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="error" data-name="error">
               <h3>
                  error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#error" class="anchor" title="Link to error">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="eval" data-name="eval">
               <h3>
                  eval 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#eval" class="anchor" title="Link to eval">#</a>
               </h3>
               
               <pre><code>func (ctxt *Context) eval(x constraint.Expr, allTags map[string]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="expandSrcDir" data-name="expandSrcDir">
               <h3>
                  expandSrcDir 
                  <span class="badge">function</span>
                  
                  <a href="#expandSrcDir" class="anchor" title="Link to expandSrcDir">#</a>
               </h3>
               
               <p>expandSrcDir expands any occurrence of ${SRCDIR}, making sure
the result is safe for the shell.</p>
               
               <pre><code>func expandSrcDir(str string, srcdir string) (string, bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="extractCgoDirectives" data-name="extractCgoDirectives">
               <h3>
                  extractCgoDirectives 
                  <span class="badge">function</span>
                  
                  <a href="#extractCgoDirectives" class="anchor" title="Link to extractCgoDirectives">#</a>
               </h3>
               
               <p>extractCgoDirectives filters only the lines containing #cgo directives from the input,
which is the comment on import "C".</p>
               
               <pre><code>func extractCgoDirectives(doc string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fileListForExt" data-name="fileListForExt">
               <h3>
                  fileListForExt 
                  <span class="badge">function</span>
                  
                  <a href="#fileListForExt" class="anchor" title="Link to fileListForExt">#</a>
               </h3>
               
               <pre><code>func fileListForExt(p *build.Package, ext string) *[]string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findEmbed" data-name="findEmbed">
               <h3>
                  findEmbed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#findEmbed" class="anchor" title="Link to findEmbed">#</a>
               </h3>
               
               <p>findEmbed advances the input reader to the next //go:embed comment.
It reports whether it found a comment.
(Otherwise it found an error or EOF.)</p>
               
               <pre><code>func (r *importReader) findEmbed(first bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="findImportComment" data-name="findImportComment">
               <h3>
                  findImportComment 
                  <span class="badge">function</span>
                  
                  <a href="#findImportComment" class="anchor" title="Link to findImportComment">#</a>
               </h3>
               
               <pre><code>func findImportComment(data []byte) (s string, line int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fromBytes" data-name="fromBytes">
               <h3>
                  fromBytes 
                  <span class="badge">function</span>
                  
                  <a href="#fromBytes" class="anchor" title="Link to fromBytes">#</a>
               </h3>
               
               <p>fromBytes returns a *Module given the encoded representation.</p>
               
               <pre><code>func fromBytes(moddir string, data []byte) (m *Module, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getConstraints" data-name="getConstraints">
               <h3>
                  getConstraints 
                  <span class="badge">function</span>
                  
                  <a href="#getConstraints" class="anchor" title="Link to getConstraints">#</a>
               </h3>
               
               <pre><code>func getConstraints(content []byte) (goBuild string, plusBuild []string, binaryOnly bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getFileInfo" data-name="getFileInfo">
               <h3>
                  getFileInfo 
                  <span class="badge">function</span>
                  
                  <a href="#getFileInfo" class="anchor" title="Link to getFileInfo">#</a>
               </h3>
               
               <p>getFileInfo extracts the information needed from each go file for the module
index.
If Name denotes a Go program, matchFile reads until the end of the
Imports and returns that section of the file in the FileInfo's Header field,
even though it only considers text until the first non-comment
for +build lines.
getFileInfo will return errNonSource if the file is not a source or object
file and shouldn't even be added to IgnoredFiles.</p>
               
               <pre><code>func getFileInfo(dir string, name string, fset *token.FileSet) (*fileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goBuildConstraint" data-name="goBuildConstraint">
               <h3>
                  goBuildConstraint 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#goBuildConstraint" class="anchor" title="Link to goBuildConstraint">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) goBuildConstraint() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="goodOSArchFile" data-name="goodOSArchFile">
               <h3>
                  goodOSArchFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#goodOSArchFile" class="anchor" title="Link to goodOSArchFile">#</a>
               </h3>
               
               <p>goodOSArchFile returns false if the name contains a $GOOS or $GOARCH
suffix which does not match the current system.
The recognized name formats are:
name_$(GOOS).*
name_$(GOARCH).*
name_$(GOOS)_$(GOARCH).*
name_$(GOOS)_test.*
name_$(GOARCH)_test.*
name_$(GOOS)_$(GOARCH)_test.*
Exceptions:
if GOOS=android, then files with GOOS=linux are also matched.
if GOOS=illumos, then files with GOOS=solaris are also matched.
if GOOS=ios, then files with GOOS=darwin are also matched.</p>
               
               <pre><code>func (ctxt *Context) goodOSArchFile(name string, allTags map[string]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gopath" data-name="gopath">
               <h3>
                  gopath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#gopath" class="anchor" title="Link to gopath">#</a>
               </h3>
               
               <p>gopath returns the list of Go path directories.</p>
               
               <pre><code>func (ctxt *Context) gopath() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasSubdir" data-name="hasSubdir">
               <h3>
                  hasSubdir 
                  <span class="badge">function</span>
                  
                  <a href="#hasSubdir" class="anchor" title="Link to hasSubdir">#</a>
               </h3>
               
               <p>hasSubdir reports if dir is within root by performing lexical analysis only.</p>
               
               <pre><code>func hasSubdir(root string, dir string) (rel string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="hasSubdir" data-name="hasSubdir">
               <h3>
                  hasSubdir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#hasSubdir" class="anchor" title="Link to hasSubdir">#</a>
               </h3>
               
               <p>hasSubdir calls ctxt.HasSubdir (if not nil) or else uses
the local file system to answer the question.</p>
               
               <pre><code>func (ctxt *Context) hasSubdir(root string, dir string) (rel string, ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ignoreFile" data-name="ignoreFile">
               <h3>
                  ignoreFile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ignoreFile" class="anchor" title="Link to ignoreFile">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) ignoreFile() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importRaw" data-name="importRaw">
               <h3>
                  importRaw 
                  <span class="badge">function</span>
                  
                  <a href="#importRaw" class="anchor" title="Link to importRaw">#</a>
               </h3>
               
               <p>importRaw fills the rawPackage from the package files in srcDir.
dir is the package's path relative to the modroot.</p>
               
               <pre><code>func importRaw(modroot string, reldir string) *rawPackage</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="imports" data-name="imports">
               <h3>
                  imports 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#imports" class="anchor" title="Link to imports">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) imports() []rawImport</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importsOffset" data-name="importsOffset">
               <h3>
                  importsOffset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#importsOffset" class="anchor" title="Link to importsOffset">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) importsOffset() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexModule" data-name="indexModule">
               <h3>
                  indexModule 
                  <span class="badge">function</span>
                  
                  <a href="#indexModule" class="anchor" title="Link to indexModule">#</a>
               </h3>
               
               <p>indexModule indexes the module at the given directory and returns its
encoded representation. It returns ErrNotIndexed if the module can't
be indexed because it contains symlinks.</p>
               
               <pre><code>func indexModule(modroot string) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="indexPackage" data-name="indexPackage">
               <h3>
                  indexPackage 
                  <span class="badge">function</span>
                  
                  <a href="#indexPackage" class="anchor" title="Link to indexPackage">#</a>
               </h3>
               
               <p>indexPackage indexes the package at the given directory and returns its
encoded representation. It returns ErrNotIndexed if the package can't
be indexed.</p>
               
               <pre><code>func indexPackage(modroot string, pkgdir string) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="int" data-name="int">
               <h3>
                  int 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#int" class="anchor" title="Link to int">#</a>
               </h3>
               
               <p>int reads the next int.</p>
               
               <pre><code>func (r *reader) int() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="intAt" data-name="intAt">
               <h3>
                  intAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#intAt" class="anchor" title="Link to intAt">#</a>
               </h3>
               
               <p>intAt returns the int at the given offset in d.data.</p>
               
               <pre><code>func (d *decoder) intAt(off int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isAbsPath" data-name="isAbsPath">
               <h3>
                  isAbsPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#isAbsPath" class="anchor" title="Link to isAbsPath">#</a>
               </h3>
               
               <p>isAbsPath calls ctxt.IsAbsPath (if not nil) or else filepath.IsAbs.</p>
               
               <pre><code>func (ctxt *Context) isAbsPath(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isDir" data-name="isDir">
               <h3>
                  isDir 
                  <span class="badge">function</span>
                  
                  <a href="#isDir" class="anchor" title="Link to isDir">#</a>
               </h3>
               
               <p>isDir calls ctxt.IsDir (if not nil) or else uses fsys.Stat.</p>
               
               <pre><code>func isDir(path string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isGoBuildComment" data-name="isGoBuildComment">
               <h3>
                  isGoBuildComment 
                  <span class="badge">function</span>
                  
                  <a href="#isGoBuildComment" class="anchor" title="Link to isGoBuildComment">#</a>
               </h3>
               
               <pre><code>func isGoBuildComment(line []byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isIdent" data-name="isIdent">
               <h3>
                  isIdent 
                  <span class="badge">function</span>
                  
                  <a href="#isIdent" class="anchor" title="Link to isIdent">#</a>
               </h3>
               
               <pre><code>func isIdent(c byte) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="joinPath" data-name="joinPath">
               <h3>
                  joinPath 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#joinPath" class="anchor" title="Link to joinPath">#</a>
               </h3>
               
               <p>joinPath calls ctxt.JoinPath (if not nil) or else filepath.Join.</p>
               
               <pre><code>func (ctxt *Context) joinPath(elem ...string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="keys" data-name="keys">
               <h3>
                  keys 
                  <span class="badge">function</span>
                  
                  <a href="#keys" class="anchor" title="Link to keys">#</a>
               </h3>
               
               <pre><code>func keys(m map[string]bool) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makePathsAbsolute" data-name="makePathsAbsolute">
               <h3>
                  makePathsAbsolute 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#makePathsAbsolute" class="anchor" title="Link to makePathsAbsolute">#</a>
               </h3>
               
               <p>makePathsAbsolute looks for compiler options that take paths and
makes them absolute. We do this because through the 1.8 release we
ran the compiler in the package directory, so any relative -I or -L
options would be relative to that directory. In 1.9 we changed to
running the compiler in the build directory, to get consistent
build results (issue #19964). To keep builds working, we change any
relative -I or -L options to be absolute.
Using filepath.IsAbs and filepath.Join here means the results will be
different on different systems, but that's OK: -I and -L options are
inherently system-dependent.</p>
               
               <pre><code>func (ctxt *Context) makePathsAbsolute(args []string, srcDir string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchAuto" data-name="matchAuto">
               <h3>
                  matchAuto 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchAuto" class="anchor" title="Link to matchAuto">#</a>
               </h3>
               
               <p>matchAuto interprets text as either a +build or //go:build expression (whichever works),
reporting whether the expression matches the build context.
matchAuto is only used for testing of tag evaluation
and in #cgo lines, which accept either syntax.</p>
               
               <pre><code>func (ctxt *Context) matchAuto(text string, allTags map[string]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="matchTag" data-name="matchTag">
               <h3>
                  matchTag 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#matchTag" class="anchor" title="Link to matchTag">#</a>
               </h3>
               
               <p>matchTag reports whether the name is one of:
cgo (if cgo is enabled)
$GOOS
$GOARCH
boringcrypto
ctxt.Compiler
linux (if GOOS == android)
solaris (if GOOS == illumos)
tag (if tag is listed in ctxt.BuildTags or ctxt.ReleaseTags)
It records all consulted tags in allTags.</p>
               
               <pre><code>func (ctxt *Context) matchTag(name string, allTags map[string]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="moduleHash" data-name="moduleHash">
               <h3>
                  moduleHash 
                  <span class="badge">function</span>
                  
                  <a href="#moduleHash" class="anchor" title="Link to moduleHash">#</a>
               </h3>
               
               <p>moduleHash returns an ActionID corresponding to the state of the module
located at filesystem path modroot.</p>
               
               <pre><code>func moduleHash(modroot string, ismodcache bool) (cache.ActionID, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="moduleWalkErr" data-name="moduleWalkErr">
               <h3>
                  moduleWalkErr 
                  <span class="badge">function</span>
                  
                  <a href="#moduleWalkErr" class="anchor" title="Link to moduleWalkErr">#</a>
               </h3>
               
               <p>moduleWalkErr returns filepath.SkipDir if the directory isn't relevant
when indexing a module or generating a filehash, ErrNotIndexed,
if the module shouldn't be indexed, and nil otherwise.</p>
               
               <pre><code>func moduleWalkErr(root string, path string, d fs.DirEntry, err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="name" data-name="name">
               <h3>
                  name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#name" class="anchor" title="Link to name">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nameExt" data-name="nameExt">
               <h3>
                  nameExt 
                  <span class="badge">function</span>
                  
                  <a href="#nameExt" class="anchor" title="Link to nameExt">#</a>
               </h3>
               
               <pre><code>func nameExt(name string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newEncoder" data-name="newEncoder">
               <h3>
                  newEncoder 
                  <span class="badge">function</span>
                  
                  <a href="#newEncoder" class="anchor" title="Link to newEncoder">#</a>
               </h3>
               
               <pre><code>func newEncoder() *encoder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newImportReader" data-name="newImportReader">
               <h3>
                  newImportReader 
                  <span class="badge">function</span>
                  
                  <a href="#newImportReader" class="anchor" title="Link to newImportReader">#</a>
               </h3>
               
               <pre><code>func newImportReader(name string, r io.Reader) *importReader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="nextByte" data-name="nextByte">
               <h3>
                  nextByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#nextByte" class="anchor" title="Link to nextByte">#</a>
               </h3>
               
               <p>nextByte is like peekByte but advances beyond the returned byte.</p>
               
               <pre><code>func (r *importReader) nextByte(skipSpace bool) byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openIndexModule" data-name="openIndexModule">
               <h3>
                  openIndexModule 
                  <span class="badge">function</span>
                  
                  <a href="#openIndexModule" class="anchor" title="Link to openIndexModule">#</a>
               </h3>
               
               <p>openIndexModule returns the module index for modPath.
It will return ErrNotIndexed if the module can not be read
using the index because it contains symlinks.</p>
               
               <pre><code>func openIndexModule(modroot string, ismodcache bool) (*Module, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="openIndexPackage" data-name="openIndexPackage">
               <h3>
                  openIndexPackage 
                  <span class="badge">function</span>
                  
                  <a href="#openIndexPackage" class="anchor" title="Link to openIndexPackage">#</a>
               </h3>
               
               <pre><code>func openIndexPackage(modroot string, pkgdir string) (*IndexPackage, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="packageFromBytes" data-name="packageFromBytes">
               <h3>
                  packageFromBytes 
                  <span class="badge">function</span>
                  
                  <a href="#packageFromBytes" class="anchor" title="Link to packageFromBytes">#</a>
               </h3>
               
               <p>packageFromBytes returns a *IndexPackage given the encoded representation.</p>
               
               <pre><code>func packageFromBytes(modroot string, data []byte) (p *IndexPackage, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseError" data-name="parseError">
               <h3>
                  parseError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#parseError" class="anchor" title="Link to parseError">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) parseError() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseErrorFromString" data-name="parseErrorFromString">
               <h3>
                  parseErrorFromString 
                  <span class="badge">function</span>
                  
                  <a href="#parseErrorFromString" class="anchor" title="Link to parseErrorFromString">#</a>
               </h3>
               
               <p>parseErrorFromString converts a string produced by parseErrorToString back
to an error.  An empty string is converted to a nil error, and all
other strings are expected to be JSON-marshaled parseError structs.
The two functions are meant to preserve the structure of an
error of type scanner.ErrorList in a round trip, but may not preserve the
structure of other errors.</p>
               
               <pre><code>func parseErrorFromString(s string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseErrorToString" data-name="parseErrorToString">
               <h3>
                  parseErrorToString 
                  <span class="badge">function</span>
                  
                  <a href="#parseErrorToString" class="anchor" title="Link to parseErrorToString">#</a>
               </h3>
               
               <p>parseErrorToString converts the error from parsing the file into a string
representation. A nil error is converted to an empty string, and all other
errors are converted to a JSON-marshaled parseError struct, with ErrorList
set for errors of type scanner.ErrorList, and ErrorString set to the error's
string representation for all other errors.</p>
               
               <pre><code>func parseErrorToString(err error) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseFileHeader" data-name="parseFileHeader">
               <h3>
                  parseFileHeader 
                  <span class="badge">function</span>
                  
                  <a href="#parseFileHeader" class="anchor" title="Link to parseFileHeader">#</a>
               </h3>
               
               <pre><code>func parseFileHeader(content []byte) (trimmed []byte, goBuild []byte, sawBinaryOnly bool, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseGoEmbed" data-name="parseGoEmbed">
               <h3>
                  parseGoEmbed 
                  <span class="badge">function</span>
                  
                  <a href="#parseGoEmbed" class="anchor" title="Link to parseGoEmbed">#</a>
               </h3>
               
               <p>parseGoEmbed parses the text following "//go:embed" to extract the glob patterns.
It accepts unquoted space-separated patterns as well as double-quoted and back-quoted Go strings.
This is based on a similar function in cmd/compile/internal/gc/noder.go;
this version calculates position information as well.</p>
               
               <pre><code>func parseGoEmbed(args string, pos token.Position) ([]fileEmbed, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseWord" data-name="parseWord">
               <h3>
                  parseWord 
                  <span class="badge">function</span>
                  
                  <a href="#parseWord" class="anchor" title="Link to parseWord">#</a>
               </h3>
               
               <p>parseWord skips any leading spaces or comments in data
and then parses the beginning of data as an identifier or keyword,
returning that word and what remains after the word.</p>
               
               <pre><code>func parseWord(data []byte) (word []byte, rest []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="peekByte" data-name="peekByte">
               <h3>
                  peekByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#peekByte" class="anchor" title="Link to peekByte">#</a>
               </h3>
               
               <p>peekByte returns the next byte from the input reader but does not advance beyond it.
If skipSpace is set, peekByte skips leading spaces and comments.</p>
               
               <pre><code>func (r *importReader) peekByte(skipSpace bool) byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkg" data-name="pkg">
               <h3>
                  pkg 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkg" class="anchor" title="Link to pkg">#</a>
               </h3>
               
               <p>pkg returns the i'th IndexPackage in m.</p>
               
               <pre><code>func (m *Module) pkg(i int) *IndexPackage</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgDir" data-name="pkgDir">
               <h3>
                  pkgDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgDir" class="anchor" title="Link to pkgDir">#</a>
               </h3>
               
               <p>pkgDir returns the dir string of the i'th package in the index.</p>
               
               <pre><code>func (m *Module) pkgDir(i int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgName" data-name="pkgName">
               <h3>
                  pkgName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgName" class="anchor" title="Link to pkgName">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) pkgName() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pkgOff" data-name="pkgOff">
               <h3>
                  pkgOff 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#pkgOff" class="anchor" title="Link to pkgOff">#</a>
               </h3>
               
               <p>pkgOff returns the offset of the data for the i'th package in the index.</p>
               
               <pre><code>func (m *Module) pkgOff(i int) int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="plusBuildConstraints" data-name="plusBuildConstraints">
               <h3>
                  plusBuildConstraints 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#plusBuildConstraints" class="anchor" title="Link to plusBuildConstraints">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) plusBuildConstraints() []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="protect" data-name="protect">
               <h3>
                  protect 
                  <span class="badge">function</span>
                  
                  <a href="#protect" class="anchor" title="Link to protect">#</a>
               </h3>
               
               <p>protect marks the start of a large section of code that accesses the index.
It should be used as:
defer unprotect(protect, &err)
It should not be used for trivial accesses which would be
dwarfed by the overhead of the defer.</p>
               
               <pre><code>func protect() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readAt" data-name="readAt">
               <h3>
                  readAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readAt" class="anchor" title="Link to readAt">#</a>
               </h3>
               
               <p>readAt returns a reader starting at the given position in d.</p>
               
               <pre><code>func (d *decoder) readAt(pos int) *reader</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readByte" data-name="readByte">
               <h3>
                  readByte 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readByte" class="anchor" title="Link to readByte">#</a>
               </h3>
               
               <p>readByte reads the next byte from the input, saves it in buf, and returns it.
If an error occurs, readByte records the error in r.err and returns 0.</p>
               
               <pre><code>func (r *importReader) readByte() byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readByteNoBuf" data-name="readByteNoBuf">
               <h3>
                  readByteNoBuf 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readByteNoBuf" class="anchor" title="Link to readByteNoBuf">#</a>
               </h3>
               
               <p>readByteNoBuf is like readByte but doesn't buffer the byte.
It exhausts r.buf before reading from r.b.</p>
               
               <pre><code>func (r *importReader) readByteNoBuf() byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readComments" data-name="readComments">
               <h3>
                  readComments 
                  <span class="badge">function</span>
                  
                  <a href="#readComments" class="anchor" title="Link to readComments">#</a>
               </h3>
               
               <p>readComments is like io.ReadAll, except that it only reads the leading
block of comments in the file.</p>
               
               <pre><code>func readComments(f io.Reader) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readGoInfo" data-name="readGoInfo">
               <h3>
                  readGoInfo 
                  <span class="badge">function</span>
                  
                  <a href="#readGoInfo" class="anchor" title="Link to readGoInfo">#</a>
               </h3>
               
               <p>readGoInfo expects a Go file as input and reads the file up to and including the import section.
It records what it learned in *info.
If info.fset is non-nil, readGoInfo parses the file and sets info.parsed, info.parseErr,
info.imports and info.embeds.
It only returns an error if there are problems reading the file,
not for syntax errors in the file itself.</p>
               
               <pre><code>func readGoInfo(f io.Reader, info *fileInfo) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readIdent" data-name="readIdent">
               <h3>
                  readIdent 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readIdent" class="anchor" title="Link to readIdent">#</a>
               </h3>
               
               <p>readIdent reads an identifier from the input.
If an identifier is not present, readIdent records a syntax error.</p>
               
               <pre><code>func (r *importReader) readIdent()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readImport" data-name="readImport">
               <h3>
                  readImport 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readImport" class="anchor" title="Link to readImport">#</a>
               </h3>
               
               <p>readImport reads an import clause - optional identifier followed by quoted string -
from the input.</p>
               
               <pre><code>func (r *importReader) readImport()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readKeyword" data-name="readKeyword">
               <h3>
                  readKeyword 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readKeyword" class="anchor" title="Link to readKeyword">#</a>
               </h3>
               
               <p>readKeyword reads the given keyword from the input.
If the keyword is not present, readKeyword records a syntax error.</p>
               
               <pre><code>func (r *importReader) readKeyword(kw string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readString" data-name="readString">
               <h3>
                  readString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readString" class="anchor" title="Link to readString">#</a>
               </h3>
               
               <p>readString reads a quoted string literal from the input.
If an identifier is not present, readString records a syntax error.</p>
               
               <pre><code>func (r *importReader) readString()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="relPath" data-name="relPath">
               <h3>
                  relPath 
                  <span class="badge">function</span>
                  
                  <a href="#relPath" class="anchor" title="Link to relPath">#</a>
               </h3>
               
               <p>relPath returns the path relative to the module's root.</p>
               
               <pre><code>func relPath(path string, modroot string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="safeCgoName" data-name="safeCgoName">
               <h3>
                  safeCgoName 
                  <span class="badge">function</span>
                  
                  <a href="#safeCgoName" class="anchor" title="Link to safeCgoName">#</a>
               </h3>
               
               <pre><code>func safeCgoName(s string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="saveCgo" data-name="saveCgo">
               <h3>
                  saveCgo 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#saveCgo" class="anchor" title="Link to saveCgo">#</a>
               </h3>
               
               <p>saveCgo saves the information from the #cgo lines in the import "C" comment.
These lines set CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS and pkg-config directives
that affect the way cgo's C code is built.</p>
               
               <pre><code>func (ctxt *Context) saveCgo(filename string, di *build.Package, text string) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="shouldBuild" data-name="shouldBuild">
               <h3>
                  shouldBuild 
                  <span class="badge">function</span>
                  
                  <a href="#shouldBuild" class="anchor" title="Link to shouldBuild">#</a>
               </h3>
               
               <p>implements imports.ShouldBuild in terms of an index sourcefile.</p>
               
               <pre><code>func shouldBuild(sf *sourceFile, tags map[string]bool) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="skipSpaceOrComment" data-name="skipSpaceOrComment">
               <h3>
                  skipSpaceOrComment 
                  <span class="badge">function</span>
                  
                  <a href="#skipSpaceOrComment" class="anchor" title="Link to skipSpaceOrComment">#</a>
               </h3>
               
               <p>skipSpaceOrComment returns data with any leading spaces or comments removed.</p>
               
               <pre><code>func skipSpaceOrComment(data []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitPathList" data-name="splitPathList">
               <h3>
                  splitPathList 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#splitPathList" class="anchor" title="Link to splitPathList">#</a>
               </h3>
               
               <p>splitPathList calls ctxt.SplitPathList (if not nil) or else filepath.SplitList.</p>
               
               <pre><code>func (ctxt *Context) splitPathList(s string) []string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitQuoted" data-name="splitQuoted">
               <h3>
                  splitQuoted 
                  <span class="badge">function</span>
                  
                  <a href="#splitQuoted" class="anchor" title="Link to splitQuoted">#</a>
               </h3>
               
               <p>splitQuoted splits the string s around each instance of one or more consecutive
white space characters while taking into account quotes and escaping, and
returns an array of substrings of s or an empty list if s contains only white space.
Single quotes and double quotes are recognized to prevent splitting within the
quoted region, and are removed from the resulting substrings. If a quote in s
isn't closed err will be set and r will have the unclosed argument as the
last element. The backslash is used for escaping.
For example, the following string:
a b:"c d" 'e''f'  "g\""
Would be parsed as:
[]string{"a", "b:c d", "ef", `g"`}</p>
               
               <pre><code>func splitQuoted(s string) (r []string, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="string" data-name="string">
               <h3>
                  string 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#string" class="anchor" title="Link to string">#</a>
               </h3>
               
               <p>string reads the next string.</p>
               
               <pre><code>func (r *reader) string() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stringAt" data-name="stringAt">
               <h3>
                  stringAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stringAt" class="anchor" title="Link to stringAt">#</a>
               </h3>
               
               <p>stringAt returns the string pointed at by the int at the given offset in d.data.</p>
               
               <pre><code>func (d *decoder) stringAt(off int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stringTableAt" data-name="stringTableAt">
               <h3>
                  stringTableAt 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stringTableAt" class="anchor" title="Link to stringTableAt">#</a>
               </h3>
               
               <p>stringTableAt returns the string at the given offset in the string table d.str.</p>
               
               <pre><code>func (d *decoder) stringTableAt(off int) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="synopsis" data-name="synopsis">
               <h3>
                  synopsis 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#synopsis" class="anchor" title="Link to synopsis">#</a>
               </h3>
               
               <pre><code>func (sf *sourceFile) synopsis() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syntaxError" data-name="syntaxError">
               <h3>
                  syntaxError 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#syntaxError" class="anchor" title="Link to syntaxError">#</a>
               </h3>
               
               <p>syntaxError records a syntax error, but only if an I/O error has not already been recorded.</p>
               
               <pre><code>func (r *importReader) syntaxError()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="tokpos" data-name="tokpos">
               <h3>
                  tokpos 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#tokpos" class="anchor" title="Link to tokpos">#</a>
               </h3>
               
               <p>tokpos reads the next token.Position.</p>
               
               <pre><code>func (r *reader) tokpos() token.Position</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unprotect" data-name="unprotect">
               <h3>
                  unprotect 
                  <span class="badge">function</span>
                  
                  <a href="#unprotect" class="anchor" title="Link to unprotect">#</a>
               </h3>
               
               <p>unprotect marks the end of a large section of code that accesses the index.
It should be used as:
defer unprotect(protect, &err)
end looks for panics due to errCorrupt or bad mmap accesses.
When it finds them, it adds explanatory text, consumes the panic, and sets *errp instead.
If errp is nil, end adds the explanatory text but then calls base.Fatalf.</p>
               
               <pre><code>func unprotect(old bool, errp *error)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>