<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - modindex</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>modindex</code>
         </h1>
         <hr />
         
         <article class="global" data-name="thisOS">
            <h2>thisOS</h2>
            <hr />
            
            <pre><code>thisOS</code></pre>
         </article>
         
         <article class="global" data-name="thisArch">
            <h2>thisArch</h2>
            <hr />
            
            <pre><code>thisArch</code></pre>
         </article>
         
         <article class="global" data-name="otherOS">
            <h2>otherOS</h2>
            <hr />
            
            <pre><code>otherOS</code></pre>
         </article>
         
         <article class="global" data-name="otherArch">
            <h2>otherArch</h2>
            <hr />
            
            <pre><code>otherArch</code></pre>
         </article>
         
         <article class="global" data-name="tests">
            <h2>tests</h2>
            <hr />
            
            <pre><code>tests</code></pre>
         </article>
         
         <article class="global" data-name="indexVersion">
            <h2>indexVersion</h2>
            <hr />
            
            <pre><code>indexVersion</code></pre>
         </article>
         
         <article class="global" data-name="defaultToolTags">
            <h2>defaultToolTags</h2>
            <hr />
            
            <pre><code>defaultToolTags []string</code></pre>
         </article>
         
         <article class="global" data-name="defaultReleaseTags">
            <h2>defaultReleaseTags</h2>
            <hr />
            
            <pre><code>defaultReleaseTags []string</code></pre>
         </article>
         
         <article class="global" data-name="errNoModules">
            <h2>errNoModules</h2>
            <hr />
            
            <pre><code>errNoModules</code></pre>
         </article>
         
         <article class="global" data-name="slashSlash">
            <h2>slashSlash</h2>
            <hr />
            
            <pre><code>slashSlash</code></pre>
         </article>
         
         <article class="global" data-name="slashStar">
            <h2>slashStar</h2>
            <hr />
            
            <pre><code>slashStar</code></pre>
         </article>
         
         <article class="global" data-name="starSlash">
            <h2>starSlash</h2>
            <hr />
            
            <pre><code>starSlash</code></pre>
         </article>
         
         <article class="global" data-name="newline">
            <h2>newline</h2>
            <hr />
            
            <pre><code>newline</code></pre>
         </article>
         
         <article class="global" data-name="dummyPkg">
            <h2>dummyPkg</h2>
            <hr />
            
            <pre><code>dummyPkg build.Package</code></pre>
         </article>
         
         <article class="global" data-name="errNonSource">
            <h2>errNonSource</h2>
            <hr />
            
            <pre><code>errNonSource</code></pre>
         </article>
         
         <article class="global" data-name="bSlashSlash">
            <h2>bSlashSlash</h2>
            <hr />
            
            <pre><code>bSlashSlash</code></pre>
         </article>
         
         <article class="global" data-name="bStarSlash">
            <h2>bStarSlash</h2>
            <hr />
            
            <pre><code>bStarSlash</code></pre>
         </article>
         
         <article class="global" data-name="bSlashStar">
            <h2>bSlashStar</h2>
            <hr />
            
            <pre><code>bSlashStar</code></pre>
         </article>
         
         <article class="global" data-name="bPlusBuild">
            <h2>bPlusBuild</h2>
            <hr />
            
            <pre><code>bPlusBuild</code></pre>
         </article>
         
         <article class="global" data-name="goBuildComment">
            <h2>goBuildComment</h2>
            <hr />
            
            <pre><code>goBuildComment</code></pre>
         </article>
         
         <article class="global" data-name="errMultipleGoBuild">
            <h2>errMultipleGoBuild</h2>
            <hr />
            
            <pre><code>errMultipleGoBuild</code></pre>
         </article>
         
         <article class="global" data-name="binaryOnlyComment">
            <h2>binaryOnlyComment</h2>
            <hr />
            
            <p>Special comment denoting a binary-only package.
See https://golang.org/design/2775-binary-only-packages
for more about the design of binary-only packages.</p>
            
            <pre><code>binaryOnlyComment</code></pre>
         </article>
         
         <article class="global" data-name="safeString">
            <h2>safeString</h2>
            <hr />
            
            <p>NOTE: $ is not safe for the shell, but it is allowed here because of linker options like -Wl,$ORIGIN.
We never pass these arguments to a shell (just to programs we construct argv for), so this should be okay.
See golang.org/issue/6038.
The @ is for OS X. See golang.org/issue/13720.
The % is for Jenkins. See golang.org/issue/16959.
The ! is because module paths may use them. See golang.org/issue/26716.
The ~ and ^ are for sr.ht. See golang.org/issue/32260.</p>
            
            <pre><code>safeString</code></pre>
         </article>
         
         <article class="global" data-name="bom">
            <h2>bom</h2>
            <hr />
            
            <pre><code>bom</code></pre>
         </article>
         
         <article class="global" data-name="errSyntax">
            <h2>errSyntax</h2>
            <hr />
            
            <pre><code>errSyntax</code></pre>
         </article>
         
         <article class="global" data-name="errNUL">
            <h2>errNUL</h2>
            <hr />
            
            <pre><code>errNUL</code></pre>
         </article>
         
         <article class="global" data-name="goEmbed">
            <h2>goEmbed</h2>
            <hr />
            
            <pre><code>goEmbed</code></pre>
         </article>
         
         <article class="global" data-name="enabled">
            <h2>enabled</h2>
            <hr />
            
            <p>enabled is used to flag off the behavior of the module index on tip, for debugging.</p>
            
            <pre><code>enabled</code></pre>
         </article>
         
         <article class="global" data-name="modTimeCutoff">
            <h2>modTimeCutoff</h2>
            <hr />
            
            <pre><code>modTimeCutoff</code></pre>
         </article>
         
         <article class="global" data-name="ErrNotIndexed">
            <h2>ErrNotIndexed</h2>
            <hr />
            
            <pre><code>ErrNotIndexed</code></pre>
         </article>
         
         <article class="global" data-name="errDisabled">
            <h2>errDisabled</h2>
            <hr />
            
            <pre><code>errDisabled</code></pre>
         </article>
         
         <article class="global" data-name="errNotFromModuleCache">
            <h2>errNotFromModuleCache</h2>
            <hr />
            
            <pre><code>errNotFromModuleCache</code></pre>
         </article>
         
         <article class="global" data-name="errFIPS140">
            <h2>errFIPS140</h2>
            <hr />
            
            <pre><code>errFIPS140</code></pre>
         </article>
         
         <article class="global" data-name="mcache">
            <h2>mcache</h2>
            <hr />
            
            <pre><code>mcache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="pcache">
            <h2>pcache</h2>
            <hr />
            
            <pre><code>pcache *ast.IndexListExpr</code></pre>
         </article>
         
         <article class="global" data-name="errCorrupt">
            <h2>errCorrupt</h2>
            <hr />
            
            <pre><code>errCorrupt</code></pre>
         </article>
         
         <article class="global" data-name="isTest">
            <h2>isTest</h2>
            <hr />
            
            <pre><code>isTest</code></pre>
         </article>
         
         <article class="global" data-name="installgorootAll">
            <h2>installgorootAll</h2>
            <hr />
            
            <pre><code>installgorootAll</code></pre>
         </article>
         
         <article class="global" data-name="errCannotFindPackage">
            <h2>errCannotFindPackage</h2>
            <hr />
            
            <pre><code>errCannotFindPackage</code></pre>
         </article>
         
         <article class="global" data-name="sourceFileError">
            <h2>sourceFileError</h2>
            <hr />
            
            <p>Offsets for fields in the sourceFile.</p>
            
            <pre><code>sourceFileError</code></pre>
         </article>
         
         <article class="global" data-name="sourceFileParseError">
            <h2>sourceFileParseError</h2>
            <hr />
            
            <p>Offsets for fields in the sourceFile.</p>
            
            <pre><code>sourceFileParseError</code></pre>
         </article>
         
         <article class="global" data-name="sourceFileSynopsis">
            <h2>sourceFileSynopsis</h2>
            <hr />
            
            <p>Offsets for fields in the sourceFile.</p>
            
            <pre><code>sourceFileSynopsis</code></pre>
         </article>
         
         <article class="global" data-name="sourceFileName">
            <h2>sourceFileName</h2>
            <hr />
            
            <p>Offsets for fields in the sourceFile.</p>
            
            <pre><code>sourceFileName</code></pre>
         </article>
         
         <article class="global" data-name="sourceFilePkgName">
            <h2>sourceFilePkgName</h2>
            <hr />
            
            <p>Offsets for fields in the sourceFile.</p>
            
            <pre><code>sourceFilePkgName</code></pre>
         </article>
         
         <article class="global" data-name="sourceFileIgnoreFile">
            <h2>sourceFileIgnoreFile</h2>
            <hr />
            
            <p>Offsets for fields in the sourceFile.</p>
            
            <pre><code>sourceFileIgnoreFile</code></pre>
         </article>
         
         <article class="global" data-name="sourceFileBinaryOnly">
            <h2>sourceFileBinaryOnly</h2>
            <hr />
            
            <p>Offsets for fields in the sourceFile.</p>
            
            <pre><code>sourceFileBinaryOnly</code></pre>
         </article>
         
         <article class="global" data-name="sourceFileCgoDirectives">
            <h2>sourceFileCgoDirectives</h2>
            <hr />
            
            <p>Offsets for fields in the sourceFile.</p>
            
            <pre><code>sourceFileCgoDirectives</code></pre>
         </article>
         
         <article class="global" data-name="sourceFileGoBuildConstraint">
            <h2>sourceFileGoBuildConstraint</h2>
            <hr />
            
            <p>Offsets for fields in the sourceFile.</p>
            
            <pre><code>sourceFileGoBuildConstraint</code></pre>
         </article>
         
         <article class="global" data-name="sourceFileNumPlusBuildConstraints">
            <h2>sourceFileNumPlusBuildConstraints</h2>
            <hr />
            
            <p>Offsets for fields in the sourceFile.</p>
            
            <pre><code>sourceFileNumPlusBuildConstraints</code></pre>
         </article>
          
         <article class="struct" data-name="GoodFileTest">
            <h2>type GoodFileTest struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
result bool</code></pre>
         </article>
         
         <article class="struct" data-name="encoder">
            <h2>type encoder struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">b []byte
stringTable []byte
strings *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="Context">
            <h2>type Context struct</h2>
            <hr />
            
            <p>A Context specifies the supporting context for a build.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">GOARCH string
GOOS string
GOROOT string
GOPATH string
Dir string
CgoEnabled bool
UseAllFiles bool
Compiler string
BuildTags []string
ToolTags []string
ReleaseTags []string
InstallSuffix string
JoinPath func
SplitPathList func
IsAbsPath func
IsDir func
HasSubdir func
ReadDir func
OpenFile func</code></pre>
         </article>
         
         <article class="struct" data-name="NoGoError">
            <h2>type NoGoError struct</h2>
            <hr />
            
            <p>NoGoError is the error used by Import to describe a directory
containing no buildable Go source files. (It may still contain
test files, files hidden by build tags, and so on.)</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Dir string</code></pre>
         </article>
         
         <article class="struct" data-name="MultiplePackageError">
            <h2>type MultiplePackageError struct</h2>
            <hr />
            
            <p>MultiplePackageError describes a directory containing
multiple buildable Go source files for multiple packages.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Dir string
Packages []string
Files []string</code></pre>
         </article>
         
         <article class="struct" data-name="fileInfo">
            <h2>type fileInfo struct</h2>
            <hr />
            
            <p>fileInfo records information learned about a file included in a build.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
header []byte
fset *token.FileSet
parsed *ast.File
parseErr error
imports []fileImport
embeds []fileEmbed
directives []build.Directive
binaryOnly bool
goBuildConstraint string
plusBuildConstraints []string</code></pre>
         </article>
         
         <article class="struct" data-name="fileImport">
            <h2>type fileImport struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
pos token.Pos
doc *ast.CommentGroup</code></pre>
         </article>
         
         <article class="struct" data-name="fileEmbed">
            <h2>type fileEmbed struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pattern string
pos token.Position</code></pre>
         </article>
         
         <article class="struct" data-name="importReader">
            <h2>type importReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">b *bufio.Reader
buf []byte
peek byte
err error
eof bool
nerr int
pos token.Position</code></pre>
         </article>
         
         <article class="struct" data-name="Module">
            <h2>type Module struct</h2>
            <hr />
            
            <p>Module represents and encoded module index file. It is used to
do the equivalent of build.Import of packages in the module and answer other
questions based on the index file's data.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">modroot string
d *decoder
n int</code></pre>
         </article>
         
         <article class="struct" data-name="IndexPackage">
            <h2>type IndexPackage struct</h2>
            <hr />
            
            <p>IndexPackage holds the information in the index
needed to load a package in a specific directory.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">error error
dir string
modroot string
sourceFiles []*sourceFile</code></pre>
         </article>
         
         <article class="struct" data-name="sourceFile">
            <h2>type sourceFile struct</h2>
            <hr />
            
            <p>sourceFile represents the information of a given source file in the module index.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">d *decoder
pos int
onceReadImports sync.Once
savedImports []rawImport</code></pre>
         </article>
         
         <article class="struct" data-name="decoder">
            <h2>type decoder struct</h2>
            <hr />
            
            <p>A decoder helps decode the index format.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">data []byte
str []byte</code></pre>
         </article>
         
         <article class="struct" data-name="reader">
            <h2>type reader struct</h2>
            <hr />
            
            <p>A reader reads sequential fields from a section of the index format.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">d *decoder
pos int</code></pre>
         </article>
         
         <article class="struct" data-name="rawPackage">
            <h2>type rawPackage struct</h2>
            <hr />
            
            <p>rawPackage holds the information from each package that's needed to
fill a build.Package once the context is available.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">error string
dir string
sourceFiles []*rawFile</code></pre>
         </article>
         
         <article class="struct" data-name="parseError">
            <h2>type parseError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">ErrorList *scanner.ErrorList
ErrorString string</code></pre>
         </article>
         
         <article class="struct" data-name="rawFile">
            <h2>type rawFile struct</h2>
            <hr />
            
            <p>rawFile is the struct representation of the file holding all
information in its fields.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">error string
parseError string
name string
synopsis string
pkgName string
ignoreFile bool
binaryOnly bool
cgoDirectives string
goBuildConstraint string
plusBuildConstraints []string
imports []rawImport
embeds []embed
directives []build.Directive</code></pre>
         </article>
         
         <article class="struct" data-name="rawImport">
            <h2>type rawImport struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
position token.Position</code></pre>
         </article>
         
         <article class="struct" data-name="embed">
            <h2>type embed struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pattern string
position token.Position</code></pre>
         </article>
          
         <article class="function" data-name="anotherOS">
            <h2>anotherOS</h2>
            <hr />
            
            <pre><code>func anotherOS() string</code></pre>
         </article>
         
         <article class="function" data-name="anotherArch">
            <h2>anotherArch</h2>
            <hr />
            
            <pre><code>func anotherArch() string</code></pre>
         </article>
         
         <article class="function" data-name="TestGoodOSArch">
            <h2>TestGoodOSArch</h2>
            <hr />
            
            <pre><code>func TestGoodOSArch(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="encodeModuleBytes">
            <h2>encodeModuleBytes</h2>
            <hr />
            
            <p>encodeModuleBytes produces the encoded representation of the module index.
encodeModuleBytes may modify the packages slice.</p>
            
            <pre><code>func encodeModuleBytes(packages []*rawPackage) []byte</code></pre>
         </article>
         
         <article class="function" data-name="encodePackageBytes">
            <h2>encodePackageBytes</h2>
            <hr />
            
            <pre><code>func encodePackageBytes(p *rawPackage) []byte</code></pre>
         </article>
         
         <article class="function" data-name="encodePackage">
            <h2>encodePackage</h2>
            <hr />
            
            <pre><code>func encodePackage(e *encoder, p *rawPackage)</code></pre>
         </article>
         
         <article class="function" data-name="encodeFile">
            <h2>encodeFile</h2>
            <hr />
            
            <pre><code>func encodeFile(e *encoder, f *rawFile)</code></pre>
         </article>
         
         <article class="function" data-name="newEncoder">
            <h2>newEncoder</h2>
            <hr />
            
            <pre><code>func newEncoder() *encoder</code></pre>
         </article>
         
         <article class="function" data-name="Position">
            <h2>Position</h2>
            <hr />
            
            <pre><code>func Position(position token.Position)</code></pre>
         </article>
         
         <article class="function" data-name="Pos">
            <h2>Pos</h2>
            <hr />
            
            <pre><code>func Pos() int</code></pre>
         </article>
         
         <article class="function" data-name="Bytes">
            <h2>Bytes</h2>
            <hr />
            
            <pre><code>func Bytes(b []byte)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String(s string)</code></pre>
         </article>
         
         <article class="function" data-name="Bool">
            <h2>Bool</h2>
            <hr />
            
            <pre><code>func Bool(b bool)</code></pre>
         </article>
         
         <article class="function" data-name="Uint32">
            <h2>Uint32</h2>
            <hr />
            
            <pre><code>func Uint32(n uint32)</code></pre>
         </article>
         
         <article class="function" data-name="Int">
            <h2>Int</h2>
            <hr />
            
            <p>Int encodes n. Note that all ints are written to the index as uint32s,
and to avoid problems on 32-bit systems we require fitting into a 32-bit int.</p>
            
            <pre><code>func Int(n int)</code></pre>
         </article>
         
         <article class="function" data-name="IntAt">
            <h2>IntAt</h2>
            <hr />
            
            <pre><code>func IntAt(n int, at int)</code></pre>
         </article>
         
         <article class="function" data-name="joinPath">
            <h2>joinPath</h2>
            <hr />
            
            <p>joinPath calls ctxt.JoinPath (if not nil) or else filepath.Join.</p>
            
            <pre><code>func joinPath(elem ...string) string</code></pre>
         </article>
         
         <article class="function" data-name="splitPathList">
            <h2>splitPathList</h2>
            <hr />
            
            <p>splitPathList calls ctxt.SplitPathList (if not nil) or else filepath.SplitList.</p>
            
            <pre><code>func splitPathList(s string) []string</code></pre>
         </article>
         
         <article class="function" data-name="isAbsPath">
            <h2>isAbsPath</h2>
            <hr />
            
            <p>isAbsPath calls ctxt.IsAbsPath (if not nil) or else filepath.IsAbs.</p>
            
            <pre><code>func isAbsPath(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="isDir">
            <h2>isDir</h2>
            <hr />
            
            <p>isDir calls ctxt.IsDir (if not nil) or else uses fsys.Stat.</p>
            
            <pre><code>func isDir(path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="hasSubdir">
            <h2>hasSubdir</h2>
            <hr />
            
            <p>hasSubdir calls ctxt.HasSubdir (if not nil) or else uses
the local file system to answer the question.</p>
            
            <pre><code>func hasSubdir(root string, dir string) (rel string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="hasSubdir">
            <h2>hasSubdir</h2>
            <hr />
            
            <p>hasSubdir reports if dir is within root by performing lexical analysis only.</p>
            
            <pre><code>func hasSubdir(root string, dir string) (rel string, ok bool)</code></pre>
         </article>
         
         <article class="function" data-name="gopath">
            <h2>gopath</h2>
            <hr />
            
            <p>gopath returns the list of Go path directories.</p>
            
            <pre><code>func gopath() []string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="nameExt">
            <h2>nameExt</h2>
            <hr />
            
            <pre><code>func nameExt(name string) string</code></pre>
         </article>
         
         <article class="function" data-name="fileListForExt">
            <h2>fileListForExt</h2>
            <hr />
            
            <pre><code>func fileListForExt(p *build.Package, ext string) *[]string</code></pre>
         </article>
         
         <article class="function" data-name="findImportComment">
            <h2>findImportComment</h2>
            <hr />
            
            <pre><code>func findImportComment(data []byte) (s string, line int)</code></pre>
         </article>
         
         <article class="function" data-name="skipSpaceOrComment">
            <h2>skipSpaceOrComment</h2>
            <hr />
            
            <p>skipSpaceOrComment returns data with any leading spaces or comments removed.</p>
            
            <pre><code>func skipSpaceOrComment(data []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="parseWord">
            <h2>parseWord</h2>
            <hr />
            
            <p>parseWord skips any leading spaces or comments in data
and then parses the beginning of data as an identifier or keyword,
returning that word and what remains after the word.</p>
            
            <pre><code>func parseWord(data []byte) (word []byte, rest []byte)</code></pre>
         </article>
         
         <article class="function" data-name="getFileInfo">
            <h2>getFileInfo</h2>
            <hr />
            
            <p>getFileInfo extracts the information needed from each go file for the module
index.

If Name denotes a Go program, matchFile reads until the end of the
Imports and returns that section of the file in the FileInfo's Header field,
even though it only considers text until the first non-comment
for +build lines.

getFileInfo will return errNonSource if the file is not a source or object
file and shouldn't even be added to IgnoredFiles.</p>
            
            <pre><code>func getFileInfo(dir string, name string, fset *token.FileSet) (*fileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="cleanDecls">
            <h2>cleanDecls</h2>
            <hr />
            
            <pre><code>func cleanDecls(m *ast.MapType) ([]string, *ast.MapType)</code></pre>
         </article>
         
         <article class="function" data-name="isGoBuildComment">
            <h2>isGoBuildComment</h2>
            <hr />
            
            <pre><code>func isGoBuildComment(line []byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="getConstraints">
            <h2>getConstraints</h2>
            <hr />
            
            <pre><code>func getConstraints(content []byte) (goBuild string, plusBuild []string, binaryOnly bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseFileHeader">
            <h2>parseFileHeader</h2>
            <hr />
            
            <pre><code>func parseFileHeader(content []byte) (trimmed []byte, goBuild []byte, sawBinaryOnly bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="saveCgo">
            <h2>saveCgo</h2>
            <hr />
            
            <p>saveCgo saves the information from the #cgo lines in the import "C" comment.
These lines set CFLAGS, CPPFLAGS, CXXFLAGS and LDFLAGS and pkg-config directives
that affect the way cgo's C code is built.</p>
            
            <pre><code>func saveCgo(filename string, di *build.Package, text string) error</code></pre>
         </article>
         
         <article class="function" data-name="expandSrcDir">
            <h2>expandSrcDir</h2>
            <hr />
            
            <p>expandSrcDir expands any occurrence of ${SRCDIR}, making sure
the result is safe for the shell.</p>
            
            <pre><code>func expandSrcDir(str string, srcdir string) (string, bool)</code></pre>
         </article>
         
         <article class="function" data-name="makePathsAbsolute">
            <h2>makePathsAbsolute</h2>
            <hr />
            
            <p>makePathsAbsolute looks for compiler options that take paths and
makes them absolute. We do this because through the 1.8 release we
ran the compiler in the package directory, so any relative -I or -L
options would be relative to that directory. In 1.9 we changed to
running the compiler in the build directory, to get consistent
build results (issue #19964). To keep builds working, we change any
relative -I or -L options to be absolute.

Using filepath.IsAbs and filepath.Join here means the results will be
different on different systems, but that's OK: -I and -L options are
inherently system-dependent.</p>
            
            <pre><code>func makePathsAbsolute(args []string, srcDir string)</code></pre>
         </article>
         
         <article class="function" data-name="safeCgoName">
            <h2>safeCgoName</h2>
            <hr />
            
            <pre><code>func safeCgoName(s string) bool</code></pre>
         </article>
         
         <article class="function" data-name="splitQuoted">
            <h2>splitQuoted</h2>
            <hr />
            
            <p>splitQuoted splits the string s around each instance of one or more consecutive
white space characters while taking into account quotes and escaping, and
returns an array of substrings of s or an empty list if s contains only white space.
Single quotes and double quotes are recognized to prevent splitting within the
quoted region, and are removed from the resulting substrings. If a quote in s
isn't closed err will be set and r will have the unclosed argument as the
last element. The backslash is used for escaping.

For example, the following string:

	a b:"c d" 'e''f'  "g\""

Would be parsed as:

	[]string{"a", "b:c d", "ef", `g"`}</p>
            
            <pre><code>func splitQuoted(s string) (r []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="matchAuto">
            <h2>matchAuto</h2>
            <hr />
            
            <p>matchAuto interprets text as either a +build or //go:build expression (whichever works),
reporting whether the expression matches the build context.

matchAuto is only used for testing of tag evaluation
and in #cgo lines, which accept either syntax.</p>
            
            <pre><code>func matchAuto(text string, allTags *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="eval">
            <h2>eval</h2>
            <hr />
            
            <pre><code>func eval(x constraint.Expr, allTags *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="matchTag">
            <h2>matchTag</h2>
            <hr />
            
            <p>matchTag reports whether the name is one of:

	cgo (if cgo is enabled)
	$GOOS
	$GOARCH
	boringcrypto
	ctxt.Compiler
	linux (if GOOS == android)
	solaris (if GOOS == illumos)
	tag (if tag is listed in ctxt.BuildTags or ctxt.ReleaseTags)

It records all consulted tags in allTags.</p>
            
            <pre><code>func matchTag(name string, allTags *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="goodOSArchFile">
            <h2>goodOSArchFile</h2>
            <hr />
            
            <p>goodOSArchFile returns false if the name contains a $GOOS or $GOARCH
suffix which does not match the current system.
The recognized name formats are:

	name_$(GOOS).*
	name_$(GOARCH).*
	name_$(GOOS)_$(GOARCH).*
	name_$(GOOS)_test.*
	name_$(GOARCH)_test.*
	name_$(GOOS)_$(GOARCH)_test.*

Exceptions:
if GOOS=android, then files with GOOS=linux are also matched.
if GOOS=illumos, then files with GOOS=solaris are also matched.
if GOOS=ios, then files with GOOS=darwin are also matched.</p>
            
            <pre><code>func goodOSArchFile(name string, allTags *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="newImportReader">
            <h2>newImportReader</h2>
            <hr />
            
            <pre><code>func newImportReader(name string, r io.Reader) *importReader</code></pre>
         </article>
         
         <article class="function" data-name="isIdent">
            <h2>isIdent</h2>
            <hr />
            
            <pre><code>func isIdent(c byte) bool</code></pre>
         </article>
         
         <article class="function" data-name="syntaxError">
            <h2>syntaxError</h2>
            <hr />
            
            <p>syntaxError records a syntax error, but only if an I/O error has not already been recorded.</p>
            
            <pre><code>func syntaxError()</code></pre>
         </article>
         
         <article class="function" data-name="readByte">
            <h2>readByte</h2>
            <hr />
            
            <p>readByte reads the next byte from the input, saves it in buf, and returns it.
If an error occurs, readByte records the error in r.err and returns 0.</p>
            
            <pre><code>func readByte() byte</code></pre>
         </article>
         
         <article class="function" data-name="readByteNoBuf">
            <h2>readByteNoBuf</h2>
            <hr />
            
            <p>readByteNoBuf is like readByte but doesn't buffer the byte.
It exhausts r.buf before reading from r.b.</p>
            
            <pre><code>func readByteNoBuf() byte</code></pre>
         </article>
         
         <article class="function" data-name="peekByte">
            <h2>peekByte</h2>
            <hr />
            
            <p>peekByte returns the next byte from the input reader but does not advance beyond it.
If skipSpace is set, peekByte skips leading spaces and comments.</p>
            
            <pre><code>func peekByte(skipSpace bool) byte</code></pre>
         </article>
         
         <article class="function" data-name="nextByte">
            <h2>nextByte</h2>
            <hr />
            
            <p>nextByte is like peekByte but advances beyond the returned byte.</p>
            
            <pre><code>func nextByte(skipSpace bool) byte</code></pre>
         </article>
         
         <article class="function" data-name="findEmbed">
            <h2>findEmbed</h2>
            <hr />
            
            <p>findEmbed advances the input reader to the next //go:embed comment.
It reports whether it found a comment.
(Otherwise it found an error or EOF.)</p>
            
            <pre><code>func findEmbed(first bool) bool</code></pre>
         </article>
         
         <article class="function" data-name="readKeyword">
            <h2>readKeyword</h2>
            <hr />
            
            <p>readKeyword reads the given keyword from the input.
If the keyword is not present, readKeyword records a syntax error.</p>
            
            <pre><code>func readKeyword(kw string)</code></pre>
         </article>
         
         <article class="function" data-name="readIdent">
            <h2>readIdent</h2>
            <hr />
            
            <p>readIdent reads an identifier from the input.
If an identifier is not present, readIdent records a syntax error.</p>
            
            <pre><code>func readIdent()</code></pre>
         </article>
         
         <article class="function" data-name="readString">
            <h2>readString</h2>
            <hr />
            
            <p>readString reads a quoted string literal from the input.
If an identifier is not present, readString records a syntax error.</p>
            
            <pre><code>func readString()</code></pre>
         </article>
         
         <article class="function" data-name="readImport">
            <h2>readImport</h2>
            <hr />
            
            <p>readImport reads an import clause - optional identifier followed by quoted string -
from the input.</p>
            
            <pre><code>func readImport()</code></pre>
         </article>
         
         <article class="function" data-name="readComments">
            <h2>readComments</h2>
            <hr />
            
            <p>readComments is like io.ReadAll, except that it only reads the leading
block of comments in the file.</p>
            
            <pre><code>func readComments(f io.Reader) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="readGoInfo">
            <h2>readGoInfo</h2>
            <hr />
            
            <p>readGoInfo expects a Go file as input and reads the file up to and including the import section.
It records what it learned in *info.
If info.fset is non-nil, readGoInfo parses the file and sets info.parsed, info.parseErr,
info.imports and info.embeds.

It only returns an error if there are problems reading the file,
not for syntax errors in the file itself.</p>
            
            <pre><code>func readGoInfo(f io.Reader, info *fileInfo) error</code></pre>
         </article>
         
         <article class="function" data-name="parseGoEmbed">
            <h2>parseGoEmbed</h2>
            <hr />
            
            <p>parseGoEmbed parses the text following "//go:embed" to extract the glob patterns.
It accepts unquoted space-separated patterns as well as double-quoted and back-quoted Go strings.
This is based on a similar function in cmd/compile/internal/gc/noder.go;
this version calculates position information as well.</p>
            
            <pre><code>func parseGoEmbed(args string, pos token.Position) ([]fileEmbed, error)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="TestIndex">
            <h2>TestIndex</h2>
            <hr />
            
            <pre><code>func TestIndex(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestImportRaw_IgnoreNonGo">
            <h2>TestImportRaw_IgnoreNonGo</h2>
            <hr />
            
            <pre><code>func TestImportRaw_IgnoreNonGo(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="moduleHash">
            <h2>moduleHash</h2>
            <hr />
            
            <p>moduleHash returns an ActionID corresponding to the state of the module
located at filesystem path modroot.</p>
            
            <pre><code>func moduleHash(modroot string, ismodcache bool) (cache.ActionID, error)</code></pre>
         </article>
         
         <article class="function" data-name="dirHash">
            <h2>dirHash</h2>
            <hr />
            
            <p>dirHash returns an ActionID corresponding to the state of the package
located at filesystem path pkgdir.</p>
            
            <pre><code>func dirHash(modroot string, pkgdir string) (cache.ActionID, error)</code></pre>
         </article>
         
         <article class="function" data-name="GetPackage">
            <h2>GetPackage</h2>
            <hr />
            
            <p>GetPackage returns the IndexPackage for the directory at the given path.
It will return ErrNotIndexed if the directory should be read without
using the index, for instance because the index is disabled, or the package
is not in a module.</p>
            
            <pre><code>func GetPackage(modroot string, pkgdir string) (*IndexPackage, error)</code></pre>
         </article>
         
         <article class="function" data-name="GetModule">
            <h2>GetModule</h2>
            <hr />
            
            <p>GetModule returns the Module for the given modroot.
It will return ErrNotIndexed if the directory should be read without
using the index, for instance because the index is disabled, or the package
is not in a module.</p>
            
            <pre><code>func GetModule(modroot string) (*Module, error)</code></pre>
         </article>
         
         <article class="function" data-name="openIndexModule">
            <h2>openIndexModule</h2>
            <hr />
            
            <p>openIndexModule returns the module index for modPath.
It will return ErrNotIndexed if the module can not be read
using the index because it contains symlinks.</p>
            
            <pre><code>func openIndexModule(modroot string, ismodcache bool) (*Module, error)</code></pre>
         </article>
         
         <article class="function" data-name="openIndexPackage">
            <h2>openIndexPackage</h2>
            <hr />
            
            <pre><code>func openIndexPackage(modroot string, pkgdir string) (*IndexPackage, error)</code></pre>
         </article>
         
         <article class="function" data-name="protect">
            <h2>protect</h2>
            <hr />
            
            <p>protect marks the start of a large section of code that accesses the index.
It should be used as:

	defer unprotect(protect, &err)

It should not be used for trivial accesses which would be
dwarfed by the overhead of the defer.</p>
            
            <pre><code>func protect() bool</code></pre>
         </article>
         
         <article class="function" data-name="unprotect">
            <h2>unprotect</h2>
            <hr />
            
            <p>unprotect marks the end of a large section of code that accesses the index.
It should be used as:

	defer unprotect(protect, &err)

end looks for panics due to errCorrupt or bad mmap accesses.
When it finds them, it adds explanatory text, consumes the panic, and sets *errp instead.
If errp is nil, end adds the explanatory text but then calls base.Fatalf.</p>
            
            <pre><code>func unprotect(old bool, errp *error)</code></pre>
         </article>
         
         <article class="function" data-name="fromBytes">
            <h2>fromBytes</h2>
            <hr />
            
            <p>fromBytes returns a *Module given the encoded representation.</p>
            
            <pre><code>func fromBytes(moddir string, data []byte) (m *Module, err error)</code></pre>
         </article>
         
         <article class="function" data-name="packageFromBytes">
            <h2>packageFromBytes</h2>
            <hr />
            
            <p>packageFromBytes returns a *IndexPackage given the encoded representation.</p>
            
            <pre><code>func packageFromBytes(modroot string, data []byte) (p *IndexPackage, err error)</code></pre>
         </article>
         
         <article class="function" data-name="pkgDir">
            <h2>pkgDir</h2>
            <hr />
            
            <p>pkgDir returns the dir string of the i'th package in the index.</p>
            
            <pre><code>func pkgDir(i int) string</code></pre>
         </article>
         
         <article class="function" data-name="pkgOff">
            <h2>pkgOff</h2>
            <hr />
            
            <p>pkgOff returns the offset of the data for the i'th package in the index.</p>
            
            <pre><code>func pkgOff(i int) int</code></pre>
         </article>
         
         <article class="function" data-name="Walk">
            <h2>Walk</h2>
            <hr />
            
            <p>Walk calls f for each package in the index, passing the path to that package relative to the module root.</p>
            
            <pre><code>func Walk(f func)</code></pre>
         </article>
         
         <article class="function" data-name="relPath">
            <h2>relPath</h2>
            <hr />
            
            <p>relPath returns the path relative to the module's root.</p>
            
            <pre><code>func relPath(path string, modroot string) string</code></pre>
         </article>
         
         <article class="function" data-name="Import">
            <h2>Import</h2>
            <hr />
            
            <p>Import is the equivalent of build.Import given the information in Module.</p>
            
            <pre><code>func Import(bctxt build.Context, mode build.ImportMode) (p *build.Package, err error)</code></pre>
         </article>
         
         <article class="function" data-name="IsStandardPackage">
            <h2>IsStandardPackage</h2>
            <hr />
            
            <p>IsStandardPackage reports whether path is a standard package
for the goroot and compiler using the module index if possible,
and otherwise falling back to internal/goroot.IsStandardPackage</p>
            
            <pre><code>func IsStandardPackage(goroot_ string, compiler string, path string) bool</code></pre>
         </article>
         
         <article class="function" data-name="IsGoDir">
            <h2>IsGoDir</h2>
            <hr />
            
            <p>IsGoDir is the equivalent of fsys.IsGoDir using the information in the index.</p>
            
            <pre><code>func IsGoDir() (_ bool, err error)</code></pre>
         </article>
         
         <article class="function" data-name="ScanDir">
            <h2>ScanDir</h2>
            <hr />
            
            <p>ScanDir implements imports.ScanDir using the information in the index.</p>
            
            <pre><code>func ScanDir(tags *ast.MapType) (sortedImports []string, sortedTestImports []string, err error)</code></pre>
         </article>
         
         <article class="function" data-name="keys">
            <h2>keys</h2>
            <hr />
            
            <pre><code>func keys(m *ast.MapType) []string</code></pre>
         </article>
         
         <article class="function" data-name="shouldBuild">
            <h2>shouldBuild</h2>
            <hr />
            
            <p>implements imports.ShouldBuild in terms of an index sourcefile.</p>
            
            <pre><code>func shouldBuild(sf *sourceFile, tags *ast.MapType) bool</code></pre>
         </article>
         
         <article class="function" data-name="Package">
            <h2>Package</h2>
            <hr />
            
            <p>Package and returns finds the package with the given path (relative to the module root).
If the package does not exist, Package returns an IndexPackage that will return an
appropriate error from its methods.</p>
            
            <pre><code>func Package(path string) *IndexPackage</code></pre>
         </article>
         
         <article class="function" data-name="pkg">
            <h2>pkg</h2>
            <hr />
            
            <p>pkg returns the i'th IndexPackage in m.</p>
            
            <pre><code>func pkg(i int) *IndexPackage</code></pre>
         </article>
         
         <article class="function" data-name="error">
            <h2>error</h2>
            <hr />
            
            <pre><code>func error() string</code></pre>
         </article>
         
         <article class="function" data-name="parseError">
            <h2>parseError</h2>
            <hr />
            
            <pre><code>func parseError() string</code></pre>
         </article>
         
         <article class="function" data-name="synopsis">
            <h2>synopsis</h2>
            <hr />
            
            <pre><code>func synopsis() string</code></pre>
         </article>
         
         <article class="function" data-name="name">
            <h2>name</h2>
            <hr />
            
            <pre><code>func name() string</code></pre>
         </article>
         
         <article class="function" data-name="pkgName">
            <h2>pkgName</h2>
            <hr />
            
            <pre><code>func pkgName() string</code></pre>
         </article>
         
         <article class="function" data-name="ignoreFile">
            <h2>ignoreFile</h2>
            <hr />
            
            <pre><code>func ignoreFile() bool</code></pre>
         </article>
         
         <article class="function" data-name="binaryOnly">
            <h2>binaryOnly</h2>
            <hr />
            
            <pre><code>func binaryOnly() bool</code></pre>
         </article>
         
         <article class="function" data-name="cgoDirectives">
            <h2>cgoDirectives</h2>
            <hr />
            
            <pre><code>func cgoDirectives() string</code></pre>
         </article>
         
         <article class="function" data-name="goBuildConstraint">
            <h2>goBuildConstraint</h2>
            <hr />
            
            <pre><code>func goBuildConstraint() string</code></pre>
         </article>
         
         <article class="function" data-name="plusBuildConstraints">
            <h2>plusBuildConstraints</h2>
            <hr />
            
            <pre><code>func plusBuildConstraints() []string</code></pre>
         </article>
         
         <article class="function" data-name="importsOffset">
            <h2>importsOffset</h2>
            <hr />
            
            <pre><code>func importsOffset() int</code></pre>
         </article>
         
         <article class="function" data-name="embedsOffset">
            <h2>embedsOffset</h2>
            <hr />
            
            <pre><code>func embedsOffset() int</code></pre>
         </article>
         
         <article class="function" data-name="directivesOffset">
            <h2>directivesOffset</h2>
            <hr />
            
            <pre><code>func directivesOffset() int</code></pre>
         </article>
         
         <article class="function" data-name="imports">
            <h2>imports</h2>
            <hr />
            
            <pre><code>func imports() []rawImport</code></pre>
         </article>
         
         <article class="function" data-name="embeds">
            <h2>embeds</h2>
            <hr />
            
            <pre><code>func embeds() []embed</code></pre>
         </article>
         
         <article class="function" data-name="directives">
            <h2>directives</h2>
            <hr />
            
            <pre><code>func directives() []build.Directive</code></pre>
         </article>
         
         <article class="function" data-name="asString">
            <h2>asString</h2>
            <hr />
            
            <pre><code>func asString(b []byte) string</code></pre>
         </article>
         
         <article class="function" data-name="intAt">
            <h2>intAt</h2>
            <hr />
            
            <p>intAt returns the int at the given offset in d.data.</p>
            
            <pre><code>func intAt(off int) int</code></pre>
         </article>
         
         <article class="function" data-name="boolAt">
            <h2>boolAt</h2>
            <hr />
            
            <p>boolAt returns the bool at the given offset in d.data.</p>
            
            <pre><code>func boolAt(off int) bool</code></pre>
         </article>
         
         <article class="function" data-name="stringAt">
            <h2>stringAt</h2>
            <hr />
            
            <p>stringAt returns the string pointed at by the int at the given offset in d.data.</p>
            
            <pre><code>func stringAt(off int) string</code></pre>
         </article>
         
         <article class="function" data-name="stringTableAt">
            <h2>stringTableAt</h2>
            <hr />
            
            <p>stringTableAt returns the string at the given offset in the string table d.str.</p>
            
            <pre><code>func stringTableAt(off int) string</code></pre>
         </article>
         
         <article class="function" data-name="readAt">
            <h2>readAt</h2>
            <hr />
            
            <p>readAt returns a reader starting at the given position in d.</p>
            
            <pre><code>func readAt(pos int) *reader</code></pre>
         </article>
         
         <article class="function" data-name="int">
            <h2>int</h2>
            <hr />
            
            <p>int reads the next int.</p>
            
            <pre><code>func int() int</code></pre>
         </article>
         
         <article class="function" data-name="string">
            <h2>string</h2>
            <hr />
            
            <p>string reads the next string.</p>
            
            <pre><code>func string() string</code></pre>
         </article>
         
         <article class="function" data-name="bool">
            <h2>bool</h2>
            <hr />
            
            <p>bool reads the next bool.</p>
            
            <pre><code>func bool() bool</code></pre>
         </article>
         
         <article class="function" data-name="tokpos">
            <h2>tokpos</h2>
            <hr />
            
            <p>tokpos reads the next token.Position.</p>
            
            <pre><code>func tokpos() token.Position</code></pre>
         </article>
         
         <article class="function" data-name="moduleWalkErr">
            <h2>moduleWalkErr</h2>
            <hr />
            
            <p>moduleWalkErr returns filepath.SkipDir if the directory isn't relevant
when indexing a module or generating a filehash, ErrNotIndexed,
if the module shouldn't be indexed, and nil otherwise.</p>
            
            <pre><code>func moduleWalkErr(root string, path string, d fs.DirEntry, err error) error</code></pre>
         </article>
         
         <article class="function" data-name="indexModule">
            <h2>indexModule</h2>
            <hr />
            
            <p>indexModule indexes the module at the given directory and returns its
encoded representation. It returns ErrNotIndexed if the module can't
be indexed because it contains symlinks.</p>
            
            <pre><code>func indexModule(modroot string) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="indexPackage">
            <h2>indexPackage</h2>
            <hr />
            
            <p>indexPackage indexes the package at the given directory and returns its
encoded representation. It returns ErrNotIndexed if the package can't
be indexed.</p>
            
            <pre><code>func indexPackage(modroot string, pkgdir string) []byte</code></pre>
         </article>
         
         <article class="function" data-name="parseErrorToString">
            <h2>parseErrorToString</h2>
            <hr />
            
            <p>parseErrorToString converts the error from parsing the file into a string
representation. A nil error is converted to an empty string, and all other
errors are converted to a JSON-marshaled parseError struct, with ErrorList
set for errors of type scanner.ErrorList, and ErrorString set to the error's
string representation for all other errors.</p>
            
            <pre><code>func parseErrorToString(err error) string</code></pre>
         </article>
         
         <article class="function" data-name="parseErrorFromString">
            <h2>parseErrorFromString</h2>
            <hr />
            
            <p>parseErrorFromString converts a string produced by parseErrorToString back
to an error.  An empty string is converted to a nil error, and all
other strings are expected to be JSON-marshaled parseError structs.
The two functions are meant to preserve the structure of an
error of type scanner.ErrorList in a round trip, but may not preserve the
structure of other errors.</p>
            
            <pre><code>func parseErrorFromString(s string) error</code></pre>
         </article>
         
         <article class="function" data-name="importRaw">
            <h2>importRaw</h2>
            <hr />
            
            <p>importRaw fills the rawPackage from the package files in srcDir.
dir is the package's path relative to the modroot.</p>
            
            <pre><code>func importRaw(modroot string, reldir string) *rawPackage</code></pre>
         </article>
         
         <article class="function" data-name="extractCgoDirectives">
            <h2>extractCgoDirectives</h2>
            <hr />
            
            <p>extractCgoDirectives filters only the lines containing #cgo directives from the input,
which is the comment on import "C".</p>
            
            <pre><code>func extractCgoDirectives(doc string) []string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
