<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - gzip</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                  
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>gzip</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"bufio"
"compress/flate"
"encoding/binary"
"errors"
"hash/crc32"
"io"
"time"
"compress/flate"
"errors"
"fmt"
"hash/crc32"
"io"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="BestCompression" data-name="BestCompression">
               <h3>
                  BestCompression 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BestCompression" class="anchor" title="Link to BestCompression">#</a>
               </h3>
               
               <p>These constants are copied from the flate package, so that code that imports
"compress/gzip" does not also have to import "compress/flate".</p>
               
               <pre><code>const BestCompression = flate.BestCompression</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="BestSpeed" data-name="BestSpeed">
               <h3>
                  BestSpeed 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#BestSpeed" class="anchor" title="Link to BestSpeed">#</a>
               </h3>
               
               <p>These constants are copied from the flate package, so that code that imports
"compress/gzip" does not also have to import "compress/flate".</p>
               
               <pre><code>const BestSpeed = flate.BestSpeed</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="DefaultCompression" data-name="DefaultCompression">
               <h3>
                  DefaultCompression 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#DefaultCompression" class="anchor" title="Link to DefaultCompression">#</a>
               </h3>
               
               <p>These constants are copied from the flate package, so that code that imports
"compress/gzip" does not also have to import "compress/flate".</p>
               
               <pre><code>const DefaultCompression = flate.DefaultCompression</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrChecksum" data-name="ErrChecksum">
               <h3>
                  ErrChecksum 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrChecksum" class="anchor" title="Link to ErrChecksum">#</a>
               </h3>
               
               <p>ErrChecksum is returned when reading GZIP data that has an invalid checksum.</p>
               
               <pre><code>var ErrChecksum = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="ErrHeader" data-name="ErrHeader">
               <h3>
                  ErrHeader 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#ErrHeader" class="anchor" title="Link to ErrHeader">#</a>
               </h3>
               
               <p>ErrHeader is returned when reading GZIP data that has an invalid header.</p>
               
               <pre><code>var ErrHeader = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="HuffmanOnly" data-name="HuffmanOnly">
               <h3>
                  HuffmanOnly 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#HuffmanOnly" class="anchor" title="Link to HuffmanOnly">#</a>
               </h3>
               
               <p>These constants are copied from the flate package, so that code that imports
"compress/gzip" does not also have to import "compress/flate".</p>
               
               <pre><code>const HuffmanOnly = flate.HuffmanOnly</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="NoCompression" data-name="NoCompression">
               <h3>
                  NoCompression 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#NoCompression" class="anchor" title="Link to NoCompression">#</a>
               </h3>
               
               <p>These constants are copied from the flate package, so that code that imports
"compress/gzip" does not also have to import "compress/flate".</p>
               
               <pre><code>const NoCompression = flate.NoCompression</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagComment" data-name="flagComment">
               <h3>
                  flagComment 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagComment" class="anchor" title="Link to flagComment">#</a>
               </h3>
               
               <pre><code>const flagComment = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagExtra" data-name="flagExtra">
               <h3>
                  flagExtra 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagExtra" class="anchor" title="Link to flagExtra">#</a>
               </h3>
               
               <pre><code>const flagExtra = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagHdrCrc" data-name="flagHdrCrc">
               <h3>
                  flagHdrCrc 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagHdrCrc" class="anchor" title="Link to flagHdrCrc">#</a>
               </h3>
               
               <pre><code>const flagHdrCrc = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagName" data-name="flagName">
               <h3>
                  flagName 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagName" class="anchor" title="Link to flagName">#</a>
               </h3>
               
               <pre><code>const flagName = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="flagText" data-name="flagText">
               <h3>
                  flagText 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#flagText" class="anchor" title="Link to flagText">#</a>
               </h3>
               
               <pre><code>const flagText = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gzipDeflate" data-name="gzipDeflate">
               <h3>
                  gzipDeflate 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gzipDeflate" class="anchor" title="Link to gzipDeflate">#</a>
               </h3>
               
               <pre><code>const gzipDeflate = 8</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gzipID1" data-name="gzipID1">
               <h3>
                  gzipID1 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gzipID1" class="anchor" title="Link to gzipID1">#</a>
               </h3>
               
               <pre><code>const gzipID1 = 0x1f</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gzipID2" data-name="gzipID2">
               <h3>
                  gzipID2 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gzipID2" class="anchor" title="Link to gzipID2">#</a>
               </h3>
               
               <pre><code>const gzipID2 = 0x8b</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="le" data-name="le">
               <h3>
                  le 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#le" class="anchor" title="Link to le">#</a>
               </h3>
               
               <pre><code>var le = binary.LittleEndian</code></pre>
            </article>
            
         </section>
            
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Header" data-name="Header">
               <h3>
                  Header
                  <span class="badge">struct</span>
                  <a href="#Header" class="anchor" title="Link to Header">#</a>
               </h3>
               
               <p>The gzip file stores a header giving metadata about the compressed file.
That header is exposed as the fields of the [Writer] and [Reader] structs.
Strings must be UTF-8 encoded and may only contain Unicode code points
U+0001 through U+00FF, due to limitations of the GZIP file format.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Header struct {
Comment string
Extra []byte
ModTime time.Time
Name string
OS byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Reader" data-name="Reader">
               <h3>
                  Reader
                  <span class="badge">struct</span>
                  <a href="#Reader" class="anchor" title="Link to Reader">#</a>
               </h3>
               
               <p>A Reader is an [io.Reader] that can be read to retrieve
uncompressed data from a gzip-format compressed file.
In general, a gzip file can be a concatenation of gzip files,
each with its own header. Reads from the Reader
return the concatenation of the uncompressed data of each.
Only the first header is recorded in the Reader fields.
Gzip files store a length and checksum of the uncompressed data.
The Reader will return an [ErrChecksum] when [Reader.Read]
reaches the end of the uncompressed data if it does not
have the expected length or checksum. Clients should treat data
returned by [Reader.Read] as tentative until they receive the [io.EOF]
marking the end of the data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Reader struct {
Header
r flate.Reader
decompressor io.ReadCloser
digest uint32
size uint32
buf [512]byte
err error
multistream bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Writer" data-name="Writer">
               <h3>
                  Writer
                  <span class="badge">struct</span>
                  <a href="#Writer" class="anchor" title="Link to Writer">#</a>
               </h3>
               
               <p>A Writer is an io.WriteCloser.
Writes to a Writer are compressed and written to w.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Writer struct {
Header
w io.Writer
level int
wroteHeader bool
closed bool
buf [10]byte
compressor *flate.Writer
digest uint32
size uint32
err error
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the [Reader]. It does not close the underlying [io.Reader].
In order for the GZIP checksum to be verified, the reader must be
fully consumed until the [io.EOF].</p>
               
               <pre><code>func (z *Reader) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the [Writer] by flushing any unwritten data to the underlying
[io.Writer] and writing the GZIP footer.
It does not close the underlying [io.Writer].</p>
               
               <pre><code>func (z *Writer) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Flush" data-name="Flush">
               <h3>
                  Flush 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Flush" class="anchor" title="Link to Flush">#</a>
               </h3>
               
               <p>Flush flushes any pending compressed data to the underlying writer.
It is useful mainly in compressed network protocols, to ensure that
a remote reader has enough data to reconstruct a packet. Flush does
not return until the data has been written. If the underlying
writer returns an error, Flush returns that error.
In the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.</p>
               
               <pre><code>func (z *Writer) Flush() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Multistream" data-name="Multistream">
               <h3>
                  Multistream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Multistream" class="anchor" title="Link to Multistream">#</a>
               </h3>
               
               <p>Multistream controls whether the reader supports multistream files.
If enabled (the default), the [Reader] expects the input to be a sequence
of individually gzipped data streams, each with its own header and
trailer, ending at EOF. The effect is that the concatenation of a sequence
of gzipped files is treated as equivalent to the gzip of the concatenation
of the sequence. This is standard behavior for gzip readers.
Calling Multistream(false) disables this behavior; disabling the behavior
can be useful when reading file formats that distinguish individual gzip
data streams or mix gzip data streams with other data streams.
In this mode, when the [Reader] reaches the end of the data stream,
[Reader.Read] returns [io.EOF]. The underlying reader must implement [io.ByteReader]
in order to be left positioned just after the gzip stream.
To start the next stream, call z.Reset(r) followed by z.Multistream(false).
If there is no next stream, z.Reset(r) will return [io.EOF].</p>
               
               <pre><code>func (z *Reader) Multistream(ok bool)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewReader" data-name="NewReader">
               <h3>
                  NewReader 
                  <span class="badge">function</span>
                  
                  <a href="#NewReader" class="anchor" title="Link to NewReader">#</a>
               </h3>
               
               <p>NewReader creates a new [Reader] reading the given reader.
If r does not also implement [io.ByteReader],
the decompressor may read more data than necessary from r.
It is the caller's responsibility to call Close on the [Reader] when done.
The [Reader.Header] fields will be valid in the [Reader] returned.</p>
               
               <pre><code>func NewReader(r io.Reader) (*Reader, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewWriter" data-name="NewWriter">
               <h3>
                  NewWriter 
                  <span class="badge">function</span>
                  
                  <a href="#NewWriter" class="anchor" title="Link to NewWriter">#</a>
               </h3>
               
               <p>NewWriter returns a new [Writer].
Writes to the returned writer are compressed and written to w.
It is the caller's responsibility to call Close on the [Writer] when done.
Writes may be buffered and not flushed until Close.
Callers that wish to set the fields in Writer.Header must do so before
the first call to Write, Flush, or Close.</p>
               
               <pre><code>func NewWriter(w io.Writer) *Writer</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewWriterLevel" data-name="NewWriterLevel">
               <h3>
                  NewWriterLevel 
                  <span class="badge">function</span>
                  
                  <a href="#NewWriterLevel" class="anchor" title="Link to NewWriterLevel">#</a>
               </h3>
               
               <p>NewWriterLevel is like [NewWriter] but specifies the compression level instead
of assuming [DefaultCompression].
The compression level can be [DefaultCompression], [NoCompression], [HuffmanOnly]
or any integer value between [BestSpeed] and [BestCompression] inclusive.
The error returned will be nil if the level is valid.</p>
               
               <pre><code>func NewWriterLevel(w io.Writer, level int) (*Writer, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <p>Read implements [io.Reader], reading uncompressed bytes from its underlying [Reader].</p>
               
               <pre><code>func (z *Reader) Read(p []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset discards the [Writer] z's state and makes it equivalent to the
result of its original state from [NewWriter] or [NewWriterLevel], but
writing to w instead. This permits reusing a [Writer] rather than
allocating a new one.</p>
               
               <pre><code>func (z *Writer) Reset(w io.Writer)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Reset" data-name="Reset">
               <h3>
                  Reset 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Reset" class="anchor" title="Link to Reset">#</a>
               </h3>
               
               <p>Reset discards the [Reader] z's state and makes it equivalent to the
result of its original state from [NewReader], but reading from r instead.
This permits reusing a [Reader] rather than allocating a new one.</p>
               
               <pre><code>func (z *Reader) Reset(r io.Reader) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <p>Write writes a compressed form of p to the underlying [io.Writer]. The
compressed bytes are not necessarily flushed until the [Writer] is closed.</p>
               
               <pre><code>func (z *Writer) Write(p []byte) (int, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="init" data-name="init">
               <h3>
                  init 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#init" class="anchor" title="Link to init">#</a>
               </h3>
               
               <pre><code>func (z *Writer) init(w io.Writer, level int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="noEOF" data-name="noEOF">
               <h3>
                  noEOF 
                  <span class="badge">function</span>
                  
                  <a href="#noEOF" class="anchor" title="Link to noEOF">#</a>
               </h3>
               
               <p>noEOF converts io.EOF to io.ErrUnexpectedEOF.</p>
               
               <pre><code>func noEOF(err error) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readHeader" data-name="readHeader">
               <h3>
                  readHeader 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readHeader" class="anchor" title="Link to readHeader">#</a>
               </h3>
               
               <p>readHeader reads the GZIP header according to section 2.3.1.
This method does not set z.err.</p>
               
               <pre><code>func (z *Reader) readHeader() (hdr Header, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="readString" data-name="readString">
               <h3>
                  readString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#readString" class="anchor" title="Link to readString">#</a>
               </h3>
               
               <p>readString reads a NUL-terminated string from z.r.
It treats the bytes read as being encoded as ISO 8859-1 (Latin-1) and
will output a string encoded using UTF-8.
This method always updates z.digest with the data read.</p>
               
               <pre><code>func (z *Reader) readString() (string, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeBytes" data-name="writeBytes">
               <h3>
                  writeBytes 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeBytes" class="anchor" title="Link to writeBytes">#</a>
               </h3>
               
               <p>writeBytes writes a length-prefixed byte slice to z.w.</p>
               
               <pre><code>func (z *Writer) writeBytes(b []byte) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="writeString" data-name="writeString">
               <h3>
                  writeString 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#writeString" class="anchor" title="Link to writeString">#</a>
               </h3>
               
               <p>writeString writes a UTF-8 string s in GZIP's format to z.w.
GZIP (RFC 1952) specifies that strings are NUL-terminated ISO 8859-1 (Latin-1).</p>
               
               <pre><code>func (z *Writer) writeString(s string) (err error)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>