<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - zip</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>zip</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"archive/zip"
"bytes"
"errors"
"fmt"
"go/version"
"io"
"os"
"os/exec"
"path"
"path/filepath"
"strings"
"time"
"unicode"
"unicode/utf8"
"golang.org/x/mod/modfile"
"golang.org/x/mod/module"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="MaxGoMod">
               <h3>
                  MaxGoMod 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>MaxGoMod is the maximum size in bytes of a go.mod file within a
module zip file.</p>
               
               <pre><code>const MaxGoMod = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="MaxLICENSE">
               <h3>
                  MaxLICENSE 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>MaxLICENSE is the maximum size in bytes of a LICENSE file within a
module zip file.</p>
               
               <pre><code>const MaxLICENSE = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="MaxZipFile">
               <h3>
                  MaxZipFile 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <p>MaxZipFile is the maximum size in bytes of a module zip file. The
go command will report an error if either the zip file or its extracted
content is larger than this.</p>
               
               <pre><code>const MaxZipFile = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global" data-name="errGoModCase">
               <h3>
                  errGoModCase 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errGoModCase = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errGoModSize">
               <h3>
                  errGoModSize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errGoModSize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errHgArchivalTxt">
               <h3>
                  errHgArchivalTxt 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errHgArchivalTxt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errLICENSESize">
               <h3>
                  errLICENSESize 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errLICENSESize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errNotRegular">
               <h3>
                  errNotRegular 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errNotRegular = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errPathNotClean">
               <h3>
                  errPathNotClean 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Predefined error messages for invalid files. Not exhaustive.</p>
               
               <pre><code>var errPathNotClean = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errPathNotRelative">
               <h3>
                  errPathNotRelative 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errPathNotRelative = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errSubmoduleDir">
               <h3>
                  errSubmoduleDir 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errSubmoduleDir = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errSubmoduleFile">
               <h3>
                  errSubmoduleFile 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errSubmoduleFile = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errSymlink">
               <h3>
                  errSymlink 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errSymlink = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errVCS">
               <h3>
                  errVCS 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <p>Predefined error messages for omitted files. Not exhaustive.</p>
               
               <pre><code>var errVCS = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="errVendored">
               <h3>
                  errVendored 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errVendored = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="FileErrorList">
               <h3>
                  FileErrorList
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type FileErrorList []FileError</code></pre>
            </article>
            
            <article class="type" data-name="collisionChecker">
               <h3>
                  collisionChecker
                  <span class="badge type-badge">type</span>
               </h3>
               
               <p>collisionChecker finds case-insensitive name collisions and paths that
are listed as both files and directories.
The keys of this map are processed with strToFold. pathInfo has the original
path for each folded path.</p>
               
               <pre><code>type collisionChecker map[string]pathInfo</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="File">
               <h3>
                  File
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>File provides an abstraction for a file in a directory, zip, or anything
else that looks like a file.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type File interface {
Path() string
Lstat() (os.FileInfo, error)
Open() (io.ReadCloser, error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="CheckedFiles">
               <h3>
                  CheckedFiles
                  <span class="badge">struct</span>
               </h3>
               
               <p>CheckedFiles reports whether a set of files satisfy the name and size
constraints required by module zip files. The constraints are listed in the
package documentation.
Functions that produce this report may include slightly different sets of
files. See documentation for CheckFiles, CheckDir, and CheckZip for details.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CheckedFiles struct {
Valid []string
Omitted []FileError
Invalid []FileError
SizeError error
}</code></pre>
            </article>
            
            <article class="struct" data-name="FileError">
               <h3>
                  FileError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FileError struct {
Path string
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="UnrecognizedVCSError">
               <h3>
                  UnrecognizedVCSError
                  <span class="badge">struct</span>
               </h3>
               
               <p>UnrecognizedVCSError indicates that no recognized version control system was
found in the given directory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UnrecognizedVCSError struct {
RepoRoot string
}</code></pre>
            </article>
            
            <article class="struct" data-name="dataFile">
               <h3>
                  dataFile
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dataFile struct {
name string
data []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="dataFileInfo">
               <h3>
                  dataFileInfo
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dataFileInfo struct {
f dataFile
}</code></pre>
            </article>
            
            <article class="struct" data-name="dirFile">
               <h3>
                  dirFile
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dirFile struct {
filePath string
slashPath string
info os.FileInfo
}</code></pre>
            </article>
            
            <article class="struct" data-name="pathInfo">
               <h3>
                  pathInfo
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pathInfo struct {
path string
isDir bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="zipError">
               <h3>
                  zipError
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type zipError struct {
verb string
path string
err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="zipFile">
               <h3>
                  zipFile
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type zipFile struct {
name string
f *zip.File
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="CheckDir">
               <h3>
                  CheckDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckDir reports whether the files in dir satisfy the name and size
constraints listed in the package documentation. The returned [CheckedFiles]
record contains lists of valid, invalid, and omitted files. If a directory is
omitted (for example, a nested module or vendor directory), it will appear in
the omitted list, but its files won't be listed.
CheckDir returns an error if it encounters an I/O error or if the returned
[CheckedFiles] does not describe a valid module zip file (according to
[CheckedFiles.Err]). The returned [CheckedFiles] is still populated when such
an error is returned.
Note that CheckDir will not open any files, so [CreateFromDir] may still fail
when CheckDir is successful due to I/O errors.</p>
               
               <pre><code>func CheckDir(dir string) (CheckedFiles, error)</code></pre>
            </article>
            
            <article class="function" data-name="CheckFiles">
               <h3>
                  CheckFiles 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckFiles reports whether a list of files satisfy the name and size
constraints listed in the package documentation. The returned CheckedFiles
record contains lists of valid, invalid, and omitted files. Every file in
the given list will be included in exactly one of those lists.
CheckFiles returns an error if the returned CheckedFiles does not describe
a valid module zip file (according to CheckedFiles.Err). The returned
CheckedFiles is still populated when an error is returned.
Note that CheckFiles will not open any files, so Create may still fail when
CheckFiles is successful due to I/O errors and reported size differences.</p>
               
               <pre><code>func CheckFiles(files []File) (CheckedFiles, error)</code></pre>
            </article>
            
            <article class="function" data-name="CheckZip">
               <h3>
                  CheckZip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CheckZip reports whether the files contained in a zip file satisfy the name
and size constraints listed in the package documentation.
CheckZip returns an error if the returned [CheckedFiles] does not describe
a valid module zip file (according to [CheckedFiles.Err]). The returned
CheckedFiles is still populated when an error is returned. CheckZip will
also return an error if the module path or version is malformed or if it
encounters an error reading the zip file.
Note that CheckZip does not read individual files, so [Unzip] may still fail
when CheckZip is successful due to I/O errors.</p>
               
               <pre><code>func CheckZip(m module.Version, zipFile string) (CheckedFiles, error)</code></pre>
            </article>
            
            <article class="function" data-name="Create">
               <h3>
                  Create 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Create builds a zip archive for module m from an abstract list of files
and writes it to w.
Create verifies the restrictions described in the package documentation
and should not produce an archive that [Unzip] cannot extract. Create does not
include files in the output archive if they don't belong in the module zip.
In particular, Create will not include files in modules found in
subdirectories, most files in vendor directories, or irregular files (such
as symbolic links) in the output archive.</p>
               
               <pre><code>func Create(w io.Writer, m module.Version, files []File) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="CreateFromDir">
               <h3>
                  CreateFromDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CreateFromDir creates a module zip file for module m from the contents of
a directory, dir. The zip content is written to w.
CreateFromDir verifies the restrictions described in the package
documentation and should not produce an archive that [Unzip] cannot extract.
CreateFromDir does not include files in the output archive if they don't
belong in the module zip. In particular, CreateFromDir will not include
files in modules found in subdirectories, most files in vendor directories,
or irregular files (such as symbolic links) in the output archive.
Additionally, unlike [Create], CreateFromDir will not include directories
named ".bzr", ".git", ".hg", or ".svn".</p>
               
               <pre><code>func CreateFromDir(w io.Writer, m module.Version, dir string) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="CreateFromVCS">
               <h3>
                  CreateFromVCS 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>CreateFromVCS creates a module zip file for module m from the contents of a
VCS repository stored locally. The zip content is written to w.
repoRoot must be an absolute path to the base of the repository, such as
"/Users/some-user/some-repo". If the repository is a Git repository,
this path is expected to point to its worktree: it can't be a bare git
repo.
revision is the revision of the repository to create the zip from. Examples
include HEAD or SHA sums for git repositories.
subdir must be the relative path from the base of the repository, such as
"sub/dir". To create a zip from the base of the repository, pass an empty
string.
If CreateFromVCS returns [UnrecognizedVCSError], consider falling back to
[CreateFromDir].</p>
               
               <pre><code>func CreateFromVCS(w io.Writer, m module.Version, repoRoot string, revision string, subdir string) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Err returns an error if [CheckedFiles] does not describe a valid module zip
file. [CheckedFiles.SizeError] is returned if that field is set.
A [FileErrorList] is returned
if there are one or more invalid files. Other errors may be returned in the
future.</p>
               
               <pre><code>func (cf CheckedFiles) Err() error</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e FileError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *zipError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (el FileErrorList) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *UnrecognizedVCSError) Error() string</code></pre>
            </article>
            
            <article class="function" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) IsDir() bool</code></pre>
            </article>
            
            <article class="function" data-name="Lstat">
               <h3>
                  Lstat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f dataFile) Lstat() (os.FileInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Lstat">
               <h3>
                  Lstat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f dirFile) Lstat() (os.FileInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="Lstat">
               <h3>
                  Lstat 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f zipFile) Lstat() (os.FileInfo, error)</code></pre>
            </article>
            
            <article class="function" data-name="ModTime">
               <h3>
                  ModTime 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) ModTime() time.Time</code></pre>
            </article>
            
            <article class="function" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) Mode() os.FileMode</code></pre>
            </article>
            
            <article class="function" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) Name() string</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f dirFile) Open() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f zipFile) Open() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f dataFile) Open() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function" data-name="Path">
               <h3>
                  Path 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f dirFile) Path() string</code></pre>
            </article>
            
            <article class="function" data-name="Path">
               <h3>
                  Path 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f dataFile) Path() string</code></pre>
            </article>
            
            <article class="function" data-name="Path">
               <h3>
                  Path 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (f zipFile) Path() string</code></pre>
            </article>
            
            <article class="function" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) Size() int64</code></pre>
            </article>
            
            <article class="function" data-name="Sys">
               <h3>
                  Sys 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (fi dataFileInfo) Sys() interface{}</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e FileError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (e *zipError) Unwrap() error</code></pre>
            </article>
            
            <article class="function" data-name="Unzip">
               <h3>
                  Unzip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>Unzip extracts the contents of a module zip file to a directory.
Unzip checks all restrictions listed in the package documentation and returns
an error if the zip archive is not valid. In some cases, files may be written
to dir before an error is returned (for example, if a file's uncompressed
size does not match its declared size).
dir may or may not exist: Unzip will create it and any missing parent
directories if it doesn't exist. If dir exists, it must be empty.</p>
               
               <pre><code>func Unzip(dir string, m module.Version, zipFile string) (err error)</code></pre>
            </article>
            
            <article class="function" data-name="check">
               <h3>
                  check 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (cc collisionChecker) check(p string, isDir bool) error</code></pre>
            </article>
            
            <article class="function" data-name="checkFiles">
               <h3>
                  checkFiles 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkFiles implements CheckFiles and also returns lists of valid files and
their sizes, corresponding to cf.Valid. It omits files in submodules, files
in vendored packages, symlinked files, and various other unwanted files.
The lists returned are used in Create to avoid repeated calls to File.Lstat.</p>
               
               <pre><code>func checkFiles(files []File) (cf CheckedFiles, validFiles []File, validSizes []int64)</code></pre>
            </article>
            
            <article class="function" data-name="checkZip">
               <h3>
                  checkZip 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>checkZip implements checkZip and also returns the *zip.Reader. This is
used in Unzip to avoid redundant I/O.</p>
               
               <pre><code>func checkZip(m module.Version, f *os.File) (*zip.Reader, CheckedFiles, error)</code></pre>
            </article>
            
            <article class="function" data-name="filesInGitRepo">
               <h3>
                  filesInGitRepo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>filesInGitRepo filters out any files that are git ignored in the directory.</p>
               
               <pre><code>func filesInGitRepo(dir string, rev string, subdir string) ([]File, error)</code></pre>
            </article>
            
            <article class="function" data-name="isGitRepo">
               <h3>
                  isGitRepo 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isGitRepo reports whether the given directory is a git repo.</p>
               
               <pre><code>func isGitRepo(dir string) bool</code></pre>
            </article>
            
            <article class="function" data-name="isVendoredPackage">
               <h3>
                  isVendoredPackage 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>isVendoredPackage attempts to report whether the given filename is contained
in a package whose import path contains (but does not end with) the component
"vendor".
The 'vers' parameter specifies the Go version declared in the module's
go.mod file and must be a valid Go version according to the
go/version.IsValid function.
Vendoring behavior has evolved across Go versions, so this function adapts
its logic accordingly.</p>
               
               <pre><code>func isVendoredPackage(name string, vers string) bool</code></pre>
            </article>
            
            <article class="function" data-name="listFilesInDir">
               <h3>
                  listFilesInDir 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>listFilesInDir walks the directory tree rooted at dir and returns a list of
files, as well as a list of directories and files that were skipped (for
example, nested modules and symbolic links).</p>
               
               <pre><code>func listFilesInDir(dir string) (files []File, omitted []FileError, err error)</code></pre>
            </article>
            
            <article class="function" data-name="parseGoVers">
               <h3>
                  parseGoVers 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>parseGoVers extracts the Go version specified in the given go.mod file.
It returns an empty string if the version is not found or if an error
occurs during file parsing.
The version string is in Go toolchain name syntax, prefixed with "go".
Examples: "go1.21", "go1.22rc2", "go1.23.0"</p>
               
               <pre><code>func parseGoVers(file string, data []byte) string</code></pre>
            </article>
            
            <article class="function" data-name="strToFold">
               <h3>
                  strToFold 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>strToFold returns a string with the property that
strings.EqualFold(s, t) iff strToFold(s) == strToFold(t)
This lets us test a large set of strings for fold-equivalent
duplicates without making a quadratic number of calls
to EqualFold. Note that strings.ToUpper and strings.ToLower
do not have the desired property in some corner cases.</p>
               
               <pre><code>func strToFold(s string) string</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
