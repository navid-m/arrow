<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - zip</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>zip</code>
         </h1>
         <hr />
         
         <article class="global" data-name="MaxZipFile">
            <h2>MaxZipFile</h2>
            <hr />
            
            <p>MaxZipFile is the maximum size in bytes of a module zip file. The
go command will report an error if either the zip file or its extracted
content is larger than this.</p>
            
            <pre><code>MaxZipFile</code></pre>
         </article>
         
         <article class="global" data-name="MaxGoMod">
            <h2>MaxGoMod</h2>
            <hr />
            
            <p>MaxGoMod is the maximum size in bytes of a go.mod file within a
module zip file.</p>
            
            <pre><code>MaxGoMod</code></pre>
         </article>
         
         <article class="global" data-name="MaxLICENSE">
            <h2>MaxLICENSE</h2>
            <hr />
            
            <p>MaxLICENSE is the maximum size in bytes of a LICENSE file within a
module zip file.</p>
            
            <pre><code>MaxLICENSE</code></pre>
         </article>
         
         <article class="global" data-name="errPathNotClean">
            <h2>errPathNotClean</h2>
            <hr />
            
            <p>Predefined error messages for invalid files. Not exhaustive.</p>
            
            <pre><code>errPathNotClean</code></pre>
         </article>
         
         <article class="global" data-name="errPathNotRelative">
            <h2>errPathNotRelative</h2>
            <hr />
            
            <pre><code>errPathNotRelative</code></pre>
         </article>
         
         <article class="global" data-name="errGoModCase">
            <h2>errGoModCase</h2>
            <hr />
            
            <pre><code>errGoModCase</code></pre>
         </article>
         
         <article class="global" data-name="errGoModSize">
            <h2>errGoModSize</h2>
            <hr />
            
            <pre><code>errGoModSize</code></pre>
         </article>
         
         <article class="global" data-name="errLICENSESize">
            <h2>errLICENSESize</h2>
            <hr />
            
            <pre><code>errLICENSESize</code></pre>
         </article>
         
         <article class="global" data-name="errVCS">
            <h2>errVCS</h2>
            <hr />
            
            <p>Predefined error messages for omitted files. Not exhaustive.</p>
            
            <pre><code>errVCS</code></pre>
         </article>
         
         <article class="global" data-name="errVendored">
            <h2>errVendored</h2>
            <hr />
            
            <pre><code>errVendored</code></pre>
         </article>
         
         <article class="global" data-name="errSubmoduleFile">
            <h2>errSubmoduleFile</h2>
            <hr />
            
            <pre><code>errSubmoduleFile</code></pre>
         </article>
         
         <article class="global" data-name="errSubmoduleDir">
            <h2>errSubmoduleDir</h2>
            <hr />
            
            <pre><code>errSubmoduleDir</code></pre>
         </article>
         
         <article class="global" data-name="errHgArchivalTxt">
            <h2>errHgArchivalTxt</h2>
            <hr />
            
            <pre><code>errHgArchivalTxt</code></pre>
         </article>
         
         <article class="global" data-name="errSymlink">
            <h2>errSymlink</h2>
            <hr />
            
            <pre><code>errSymlink</code></pre>
         </article>
         
         <article class="global" data-name="errNotRegular">
            <h2>errNotRegular</h2>
            <hr />
            
            <pre><code>errNotRegular</code></pre>
         </article>
          
         <article class="struct" data-name="CheckedFiles">
            <h2>type CheckedFiles struct</h2>
            <hr />
            
            <p>CheckedFiles reports whether a set of files satisfy the name and size
constraints required by module zip files. The constraints are listed in the
package documentation.

Functions that produce this report may include slightly different sets of
files. See documentation for CheckFiles, CheckDir, and CheckZip for details.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Valid []string
Omitted []FileError
Invalid []FileError
SizeError error</code></pre>
         </article>
         
         <article class="struct" data-name="FileError">
            <h2>type FileError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Path string
Err error</code></pre>
         </article>
         
         <article class="struct" data-name="UnrecognizedVCSError">
            <h2>type UnrecognizedVCSError struct</h2>
            <hr />
            
            <p>UnrecognizedVCSError indicates that no recognized version control system was
found in the given directory.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">RepoRoot string</code></pre>
         </article>
         
         <article class="struct" data-name="dirFile">
            <h2>type dirFile struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">filePath string
slashPath string
info os.FileInfo</code></pre>
         </article>
         
         <article class="struct" data-name="zipFile">
            <h2>type zipFile struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
f *zip.File</code></pre>
         </article>
         
         <article class="struct" data-name="dataFile">
            <h2>type dataFile struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
data []byte</code></pre>
         </article>
         
         <article class="struct" data-name="dataFileInfo">
            <h2>type dataFileInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">f dataFile</code></pre>
         </article>
         
         <article class="struct" data-name="pathInfo">
            <h2>type pathInfo struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">path string
isDir bool</code></pre>
         </article>
         
         <article class="struct" data-name="zipError">
            <h2>type zipError struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">verb string
path string
err error</code></pre>
         </article>
          
         <article class="function" data-name="Err">
            <h2>Err</h2>
            <hr />
            
            <p>Err returns an error if [CheckedFiles] does not describe a valid module zip
file. [CheckedFiles.SizeError] is returned if that field is set.
A [FileErrorList] is returned
if there are one or more invalid files. Other errors may be returned in the
future.</p>
            
            <pre><code>func Err() error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="CheckFiles">
            <h2>CheckFiles</h2>
            <hr />
            
            <p>CheckFiles reports whether a list of files satisfy the name and size
constraints listed in the package documentation. The returned CheckedFiles
record contains lists of valid, invalid, and omitted files. Every file in
the given list will be included in exactly one of those lists.

CheckFiles returns an error if the returned CheckedFiles does not describe
a valid module zip file (according to CheckedFiles.Err). The returned
CheckedFiles is still populated when an error is returned.

Note that CheckFiles will not open any files, so Create may still fail when
CheckFiles is successful due to I/O errors and reported size differences.</p>
            
            <pre><code>func CheckFiles(files []File) (CheckedFiles, error)</code></pre>
         </article>
         
         <article class="function" data-name="parseGoVers">
            <h2>parseGoVers</h2>
            <hr />
            
            <p>parseGoVers extracts the Go version specified in the given go.mod file.
It returns an empty string if the version is not found or if an error
occurs during file parsing.

The version string is in Go toolchain name syntax, prefixed with "go".
Examples: "go1.21", "go1.22rc2", "go1.23.0"</p>
            
            <pre><code>func parseGoVers(file string, data []byte) string</code></pre>
         </article>
         
         <article class="function" data-name="checkFiles">
            <h2>checkFiles</h2>
            <hr />
            
            <p>checkFiles implements CheckFiles and also returns lists of valid files and
their sizes, corresponding to cf.Valid. It omits files in submodules, files
in vendored packages, symlinked files, and various other unwanted files.

The lists returned are used in Create to avoid repeated calls to File.Lstat.</p>
            
            <pre><code>func checkFiles(files []File) (cf CheckedFiles, validFiles []File, validSizes []int64)</code></pre>
         </article>
         
         <article class="function" data-name="CheckDir">
            <h2>CheckDir</h2>
            <hr />
            
            <p>CheckDir reports whether the files in dir satisfy the name and size
constraints listed in the package documentation. The returned [CheckedFiles]
record contains lists of valid, invalid, and omitted files. If a directory is
omitted (for example, a nested module or vendor directory), it will appear in
the omitted list, but its files won't be listed.

CheckDir returns an error if it encounters an I/O error or if the returned
[CheckedFiles] does not describe a valid module zip file (according to
[CheckedFiles.Err]). The returned [CheckedFiles] is still populated when such
an error is returned.

Note that CheckDir will not open any files, so [CreateFromDir] may still fail
when CheckDir is successful due to I/O errors.</p>
            
            <pre><code>func CheckDir(dir string) (CheckedFiles, error)</code></pre>
         </article>
         
         <article class="function" data-name="CheckZip">
            <h2>CheckZip</h2>
            <hr />
            
            <p>CheckZip reports whether the files contained in a zip file satisfy the name
and size constraints listed in the package documentation.

CheckZip returns an error if the returned [CheckedFiles] does not describe
a valid module zip file (according to [CheckedFiles.Err]). The returned
CheckedFiles is still populated when an error is returned. CheckZip will
also return an error if the module path or version is malformed or if it
encounters an error reading the zip file.

Note that CheckZip does not read individual files, so [Unzip] may still fail
when CheckZip is successful due to I/O errors.</p>
            
            <pre><code>func CheckZip(m module.Version, zipFile string) (CheckedFiles, error)</code></pre>
         </article>
         
         <article class="function" data-name="checkZip">
            <h2>checkZip</h2>
            <hr />
            
            <p>checkZip implements checkZip and also returns the *zip.Reader. This is
used in Unzip to avoid redundant I/O.</p>
            
            <pre><code>func checkZip(m module.Version, f *os.File) (*zip.Reader, CheckedFiles, error)</code></pre>
         </article>
         
         <article class="function" data-name="Create">
            <h2>Create</h2>
            <hr />
            
            <p>Create builds a zip archive for module m from an abstract list of files
and writes it to w.

Create verifies the restrictions described in the package documentation
and should not produce an archive that [Unzip] cannot extract. Create does not
include files in the output archive if they don't belong in the module zip.
In particular, Create will not include files in modules found in
subdirectories, most files in vendor directories, or irregular files (such
as symbolic links) in the output archive.</p>
            
            <pre><code>func Create(w io.Writer, m module.Version, files []File) err error</code></pre>
         </article>
         
         <article class="function" data-name="CreateFromDir">
            <h2>CreateFromDir</h2>
            <hr />
            
            <p>CreateFromDir creates a module zip file for module m from the contents of
a directory, dir. The zip content is written to w.

CreateFromDir verifies the restrictions described in the package
documentation and should not produce an archive that [Unzip] cannot extract.
CreateFromDir does not include files in the output archive if they don't
belong in the module zip. In particular, CreateFromDir will not include
files in modules found in subdirectories, most files in vendor directories,
or irregular files (such as symbolic links) in the output archive.
Additionally, unlike [Create], CreateFromDir will not include directories
named ".bzr", ".git", ".hg", or ".svn".</p>
            
            <pre><code>func CreateFromDir(w io.Writer, m module.Version, dir string) err error</code></pre>
         </article>
         
         <article class="function" data-name="CreateFromVCS">
            <h2>CreateFromVCS</h2>
            <hr />
            
            <p>CreateFromVCS creates a module zip file for module m from the contents of a
VCS repository stored locally. The zip content is written to w.

repoRoot must be an absolute path to the base of the repository, such as
"/Users/some-user/some-repo". If the repository is a Git repository,
this path is expected to point to its worktree: it can't be a bare git
repo.

revision is the revision of the repository to create the zip from. Examples
include HEAD or SHA sums for git repositories.

subdir must be the relative path from the base of the repository, such as
"sub/dir". To create a zip from the base of the repository, pass an empty
string.

If CreateFromVCS returns [UnrecognizedVCSError], consider falling back to
[CreateFromDir].</p>
            
            <pre><code>func CreateFromVCS(w io.Writer, m module.Version, repoRoot string, revision string, subdir string) err error</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="filesInGitRepo">
            <h2>filesInGitRepo</h2>
            <hr />
            
            <p>filesInGitRepo filters out any files that are git ignored in the directory.</p>
            
            <pre><code>func filesInGitRepo(dir string, rev string, subdir string) ([]File, error)</code></pre>
         </article>
         
         <article class="function" data-name="isGitRepo">
            <h2>isGitRepo</h2>
            <hr />
            
            <p>isGitRepo reports whether the given directory is a git repo.</p>
            
            <pre><code>func isGitRepo(dir string) bool</code></pre>
         </article>
         
         <article class="function" data-name="Path">
            <h2>Path</h2>
            <hr />
            
            <pre><code>func Path() string</code></pre>
         </article>
         
         <article class="function" data-name="Lstat">
            <h2>Lstat</h2>
            <hr />
            
            <pre><code>func Lstat() (os.FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <pre><code>func Open() (io.ReadCloser, error)</code></pre>
         </article>
         
         <article class="function" data-name="Path">
            <h2>Path</h2>
            <hr />
            
            <pre><code>func Path() string</code></pre>
         </article>
         
         <article class="function" data-name="Lstat">
            <h2>Lstat</h2>
            <hr />
            
            <pre><code>func Lstat() (os.FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <pre><code>func Open() (io.ReadCloser, error)</code></pre>
         </article>
         
         <article class="function" data-name="Path">
            <h2>Path</h2>
            <hr />
            
            <pre><code>func Path() string</code></pre>
         </article>
         
         <article class="function" data-name="Lstat">
            <h2>Lstat</h2>
            <hr />
            
            <pre><code>func Lstat() (os.FileInfo, error)</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <pre><code>func Open() (io.ReadCloser, error)</code></pre>
         </article>
         
         <article class="function" data-name="Name">
            <h2>Name</h2>
            <hr />
            
            <pre><code>func Name() string</code></pre>
         </article>
         
         <article class="function" data-name="Size">
            <h2>Size</h2>
            <hr />
            
            <pre><code>func Size() int64</code></pre>
         </article>
         
         <article class="function" data-name="Mode">
            <h2>Mode</h2>
            <hr />
            
            <pre><code>func Mode() os.FileMode</code></pre>
         </article>
         
         <article class="function" data-name="ModTime">
            <h2>ModTime</h2>
            <hr />
            
            <pre><code>func ModTime() time.Time</code></pre>
         </article>
         
         <article class="function" data-name="IsDir">
            <h2>IsDir</h2>
            <hr />
            
            <pre><code>func IsDir() bool</code></pre>
         </article>
         
         <article class="function" data-name="Sys">
            <h2>Sys</h2>
            <hr />
            
            <pre><code>func Sys() *ast.InterfaceType</code></pre>
         </article>
         
         <article class="function" data-name="isVendoredPackage">
            <h2>isVendoredPackage</h2>
            <hr />
            
            <p>isVendoredPackage attempts to report whether the given filename is contained
in a package whose import path contains (but does not end with) the component
"vendor".

The 'vers' parameter specifies the Go version declared in the module's
go.mod file and must be a valid Go version according to the
go/version.IsValid function.
Vendoring behavior has evolved across Go versions, so this function adapts
its logic accordingly.</p>
            
            <pre><code>func isVendoredPackage(name string, vers string) bool</code></pre>
         </article>
         
         <article class="function" data-name="Unzip">
            <h2>Unzip</h2>
            <hr />
            
            <p>Unzip extracts the contents of a module zip file to a directory.

Unzip checks all restrictions listed in the package documentation and returns
an error if the zip archive is not valid. In some cases, files may be written
to dir before an error is returned (for example, if a file's uncompressed
size does not match its declared size).

dir may or may not exist: Unzip will create it and any missing parent
directories if it doesn't exist. If dir exists, it must be empty.</p>
            
            <pre><code>func Unzip(dir string, m module.Version, zipFile string) err error</code></pre>
         </article>
         
         <article class="function" data-name="check">
            <h2>check</h2>
            <hr />
            
            <pre><code>func check(p string, isDir bool) error</code></pre>
         </article>
         
         <article class="function" data-name="listFilesInDir">
            <h2>listFilesInDir</h2>
            <hr />
            
            <p>listFilesInDir walks the directory tree rooted at dir and returns a list of
files, as well as a list of directories and files that were skipped (for
example, nested modules and symbolic links).</p>
            
            <pre><code>func listFilesInDir(dir string) (files []File, omitted []FileError, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Unwrap">
            <h2>Unwrap</h2>
            <hr />
            
            <pre><code>func Unwrap() error</code></pre>
         </article>
         
         <article class="function" data-name="strToFold">
            <h2>strToFold</h2>
            <hr />
            
            <p>strToFold returns a string with the property that

	strings.EqualFold(s, t) iff strToFold(s) == strToFold(t)

This lets us test a large set of strings for fold-equivalent
duplicates without making a quadratic number of calls
to EqualFold. Note that strings.ToUpper and strings.ToLower
do not have the desired property in some corner cases.</p>
            
            <pre><code>func strToFold(s string) string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
