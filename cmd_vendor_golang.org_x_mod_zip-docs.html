<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - zip</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>zip</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"archive/zip"
"bytes"
"errors"
"fmt"
"go/version"
"io"
"os"
"os/exec"
"path"
"path/filepath"
"strings"
"time"
"unicode"
"unicode/utf8"
"golang.org/x/mod/modfile"
"golang.org/x/mod/module"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="MaxGoMod" data-name="MaxGoMod">
               <h3>
                  MaxGoMod 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MaxGoMod" class="anchor" title="Link to MaxGoMod">#</a>
               </h3>
               
               <p>MaxGoMod is the maximum size in bytes of a go.mod file within a
module zip file.</p>
               
               <pre><code>const MaxGoMod = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MaxLICENSE" data-name="MaxLICENSE">
               <h3>
                  MaxLICENSE 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MaxLICENSE" class="anchor" title="Link to MaxLICENSE">#</a>
               </h3>
               
               <p>MaxLICENSE is the maximum size in bytes of a LICENSE file within a
module zip file.</p>
               
               <pre><code>const MaxLICENSE = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="MaxZipFile" data-name="MaxZipFile">
               <h3>
                  MaxZipFile 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#MaxZipFile" class="anchor" title="Link to MaxZipFile">#</a>
               </h3>
               
               <p>MaxZipFile is the maximum size in bytes of a module zip file. The
go command will report an error if either the zip file or its extracted
content is larger than this.</p>
               
               <pre><code>const MaxZipFile = *ast.BinaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errGoModCase" data-name="errGoModCase">
               <h3>
                  errGoModCase 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errGoModCase" class="anchor" title="Link to errGoModCase">#</a>
               </h3>
               
               <pre><code>var errGoModCase = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errGoModSize" data-name="errGoModSize">
               <h3>
                  errGoModSize 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errGoModSize" class="anchor" title="Link to errGoModSize">#</a>
               </h3>
               
               <pre><code>var errGoModSize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errHgArchivalTxt" data-name="errHgArchivalTxt">
               <h3>
                  errHgArchivalTxt 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errHgArchivalTxt" class="anchor" title="Link to errHgArchivalTxt">#</a>
               </h3>
               
               <pre><code>var errHgArchivalTxt = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errLICENSESize" data-name="errLICENSESize">
               <h3>
                  errLICENSESize 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errLICENSESize" class="anchor" title="Link to errLICENSESize">#</a>
               </h3>
               
               <pre><code>var errLICENSESize = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errNotRegular" data-name="errNotRegular">
               <h3>
                  errNotRegular 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errNotRegular" class="anchor" title="Link to errNotRegular">#</a>
               </h3>
               
               <pre><code>var errNotRegular = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errPathNotClean" data-name="errPathNotClean">
               <h3>
                  errPathNotClean 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errPathNotClean" class="anchor" title="Link to errPathNotClean">#</a>
               </h3>
               
               <p>Predefined error messages for invalid files. Not exhaustive.</p>
               
               <pre><code>var errPathNotClean = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errPathNotRelative" data-name="errPathNotRelative">
               <h3>
                  errPathNotRelative 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errPathNotRelative" class="anchor" title="Link to errPathNotRelative">#</a>
               </h3>
               
               <pre><code>var errPathNotRelative = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errSubmoduleDir" data-name="errSubmoduleDir">
               <h3>
                  errSubmoduleDir 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errSubmoduleDir" class="anchor" title="Link to errSubmoduleDir">#</a>
               </h3>
               
               <pre><code>var errSubmoduleDir = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errSubmoduleFile" data-name="errSubmoduleFile">
               <h3>
                  errSubmoduleFile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errSubmoduleFile" class="anchor" title="Link to errSubmoduleFile">#</a>
               </h3>
               
               <pre><code>var errSubmoduleFile = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errSymlink" data-name="errSymlink">
               <h3>
                  errSymlink 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errSymlink" class="anchor" title="Link to errSymlink">#</a>
               </h3>
               
               <pre><code>var errSymlink = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errVCS" data-name="errVCS">
               <h3>
                  errVCS 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errVCS" class="anchor" title="Link to errVCS">#</a>
               </h3>
               
               <p>Predefined error messages for omitted files. Not exhaustive.</p>
               
               <pre><code>var errVCS = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="errVendored" data-name="errVendored">
               <h3>
                  errVendored 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errVendored" class="anchor" title="Link to errVendored">#</a>
               </h3>
               
               <pre><code>var errVendored = *ast.CallExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="FileErrorList" data-name="FileErrorList">
               <h3>
                  FileErrorList
                  <span class="badge type-badge">type</span>
                  <a href="#FileErrorList" class="anchor" title="Link to FileErrorList">#</a>
               </h3>
               
               <pre><code>type FileErrorList []FileError</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="collisionChecker" data-name="collisionChecker">
               <h3>
                  collisionChecker
                  <span class="badge type-badge">type</span>
                  <a href="#collisionChecker" class="anchor" title="Link to collisionChecker">#</a>
               </h3>
               
               <p>collisionChecker finds case-insensitive name collisions and paths that
are listed as both files and directories.
The keys of this map are processed with strToFold. pathInfo has the original
path for each folded path.</p>
               
               <pre><code>type collisionChecker map[string]pathInfo</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="File" data-name="File">
               <h3>
                  File
                  <span class="badge interface-badge">interface</span>
                  <a href="#File" class="anchor" title="Link to File">#</a>
               </h3>
               
               <p>File provides an abstraction for a file in a directory, zip, or anything
else that looks like a file.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type File interface {
Path() string
Lstat() (os.FileInfo, error)
Open() (io.ReadCloser, error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="CheckedFiles" data-name="CheckedFiles">
               <h3>
                  CheckedFiles
                  <span class="badge">struct</span>
                  <a href="#CheckedFiles" class="anchor" title="Link to CheckedFiles">#</a>
               </h3>
               
               <p>CheckedFiles reports whether a set of files satisfy the name and size
constraints required by module zip files. The constraints are listed in the
package documentation.
Functions that produce this report may include slightly different sets of
files. See documentation for CheckFiles, CheckDir, and CheckZip for details.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type CheckedFiles struct {
Valid []string
Omitted []FileError
Invalid []FileError
SizeError error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="FileError" data-name="FileError">
               <h3>
                  FileError
                  <span class="badge">struct</span>
                  <a href="#FileError" class="anchor" title="Link to FileError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type FileError struct {
Path string
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="UnrecognizedVCSError" data-name="UnrecognizedVCSError">
               <h3>
                  UnrecognizedVCSError
                  <span class="badge">struct</span>
                  <a href="#UnrecognizedVCSError" class="anchor" title="Link to UnrecognizedVCSError">#</a>
               </h3>
               
               <p>UnrecognizedVCSError indicates that no recognized version control system was
found in the given directory.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type UnrecognizedVCSError struct {
RepoRoot string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dataFile" data-name="dataFile">
               <h3>
                  dataFile
                  <span class="badge">struct</span>
                  <a href="#dataFile" class="anchor" title="Link to dataFile">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dataFile struct {
name string
data []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dataFileInfo" data-name="dataFileInfo">
               <h3>
                  dataFileInfo
                  <span class="badge">struct</span>
                  <a href="#dataFileInfo" class="anchor" title="Link to dataFileInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dataFileInfo struct {
f dataFile
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="dirFile" data-name="dirFile">
               <h3>
                  dirFile
                  <span class="badge">struct</span>
                  <a href="#dirFile" class="anchor" title="Link to dirFile">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type dirFile struct {
filePath string
slashPath string
info os.FileInfo
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="pathInfo" data-name="pathInfo">
               <h3>
                  pathInfo
                  <span class="badge">struct</span>
                  <a href="#pathInfo" class="anchor" title="Link to pathInfo">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type pathInfo struct {
path string
isDir bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="zipError" data-name="zipError">
               <h3>
                  zipError
                  <span class="badge">struct</span>
                  <a href="#zipError" class="anchor" title="Link to zipError">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type zipError struct {
verb string
path string
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="zipFile" data-name="zipFile">
               <h3>
                  zipFile
                  <span class="badge">struct</span>
                  <a href="#zipFile" class="anchor" title="Link to zipFile">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type zipFile struct {
name string
f *zip.File
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="CheckDir" data-name="CheckDir">
               <h3>
                  CheckDir 
                  <span class="badge">function</span>
                  
                  <a href="#CheckDir" class="anchor" title="Link to CheckDir">#</a>
               </h3>
               
               <p>CheckDir reports whether the files in dir satisfy the name and size
constraints listed in the package documentation. The returned [CheckedFiles]
record contains lists of valid, invalid, and omitted files. If a directory is
omitted (for example, a nested module or vendor directory), it will appear in
the omitted list, but its files won't be listed.
CheckDir returns an error if it encounters an I/O error or if the returned
[CheckedFiles] does not describe a valid module zip file (according to
[CheckedFiles.Err]). The returned [CheckedFiles] is still populated when such
an error is returned.
Note that CheckDir will not open any files, so [CreateFromDir] may still fail
when CheckDir is successful due to I/O errors.</p>
               
               <pre><code>func CheckDir(dir string) (CheckedFiles, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckFiles" data-name="CheckFiles">
               <h3>
                  CheckFiles 
                  <span class="badge">function</span>
                  
                  <a href="#CheckFiles" class="anchor" title="Link to CheckFiles">#</a>
               </h3>
               
               <p>CheckFiles reports whether a list of files satisfy the name and size
constraints listed in the package documentation. The returned CheckedFiles
record contains lists of valid, invalid, and omitted files. Every file in
the given list will be included in exactly one of those lists.
CheckFiles returns an error if the returned CheckedFiles does not describe
a valid module zip file (according to CheckedFiles.Err). The returned
CheckedFiles is still populated when an error is returned.
Note that CheckFiles will not open any files, so Create may still fail when
CheckFiles is successful due to I/O errors and reported size differences.</p>
               
               <pre><code>func CheckFiles(files []File) (CheckedFiles, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CheckZip" data-name="CheckZip">
               <h3>
                  CheckZip 
                  <span class="badge">function</span>
                  
                  <a href="#CheckZip" class="anchor" title="Link to CheckZip">#</a>
               </h3>
               
               <p>CheckZip reports whether the files contained in a zip file satisfy the name
and size constraints listed in the package documentation.
CheckZip returns an error if the returned [CheckedFiles] does not describe
a valid module zip file (according to [CheckedFiles.Err]). The returned
CheckedFiles is still populated when an error is returned. CheckZip will
also return an error if the module path or version is malformed or if it
encounters an error reading the zip file.
Note that CheckZip does not read individual files, so [Unzip] may still fail
when CheckZip is successful due to I/O errors.</p>
               
               <pre><code>func CheckZip(m module.Version, zipFile string) (CheckedFiles, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Create" data-name="Create">
               <h3>
                  Create 
                  <span class="badge">function</span>
                  
                  <a href="#Create" class="anchor" title="Link to Create">#</a>
               </h3>
               
               <p>Create builds a zip archive for module m from an abstract list of files
and writes it to w.
Create verifies the restrictions described in the package documentation
and should not produce an archive that [Unzip] cannot extract. Create does not
include files in the output archive if they don't belong in the module zip.
In particular, Create will not include files in modules found in
subdirectories, most files in vendor directories, or irregular files (such
as symbolic links) in the output archive.</p>
               
               <pre><code>func Create(w io.Writer, m module.Version, files []File) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CreateFromDir" data-name="CreateFromDir">
               <h3>
                  CreateFromDir 
                  <span class="badge">function</span>
                  
                  <a href="#CreateFromDir" class="anchor" title="Link to CreateFromDir">#</a>
               </h3>
               
               <p>CreateFromDir creates a module zip file for module m from the contents of
a directory, dir. The zip content is written to w.
CreateFromDir verifies the restrictions described in the package
documentation and should not produce an archive that [Unzip] cannot extract.
CreateFromDir does not include files in the output archive if they don't
belong in the module zip. In particular, CreateFromDir will not include
files in modules found in subdirectories, most files in vendor directories,
or irregular files (such as symbolic links) in the output archive.
Additionally, unlike [Create], CreateFromDir will not include directories
named ".bzr", ".git", ".hg", or ".svn".</p>
               
               <pre><code>func CreateFromDir(w io.Writer, m module.Version, dir string) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CreateFromVCS" data-name="CreateFromVCS">
               <h3>
                  CreateFromVCS 
                  <span class="badge">function</span>
                  
                  <a href="#CreateFromVCS" class="anchor" title="Link to CreateFromVCS">#</a>
               </h3>
               
               <p>CreateFromVCS creates a module zip file for module m from the contents of a
VCS repository stored locally. The zip content is written to w.
repoRoot must be an absolute path to the base of the repository, such as
"/Users/some-user/some-repo". If the repository is a Git repository,
this path is expected to point to its worktree: it can't be a bare git
repo.
revision is the revision of the repository to create the zip from. Examples
include HEAD or SHA sums for git repositories.
subdir must be the relative path from the base of the repository, such as
"sub/dir". To create a zip from the base of the repository, pass an empty
string.
If CreateFromVCS returns [UnrecognizedVCSError], consider falling back to
[CreateFromDir].</p>
               
               <pre><code>func CreateFromVCS(w io.Writer, m module.Version, repoRoot string, revision string, subdir string) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Err" data-name="Err">
               <h3>
                  Err 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Err" class="anchor" title="Link to Err">#</a>
               </h3>
               
               <p>Err returns an error if [CheckedFiles] does not describe a valid module zip
file. [CheckedFiles.SizeError] is returned if that field is set.
A [FileErrorList] is returned
if there are one or more invalid files. Other errors may be returned in the
future.</p>
               
               <pre><code>func (cf CheckedFiles) Err() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e FileError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *zipError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (el FileErrorList) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Error" data-name="Error">
               <h3>
                  Error 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Error" class="anchor" title="Link to Error">#</a>
               </h3>
               
               <pre><code>func (e *UnrecognizedVCSError) Error() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="IsDir" data-name="IsDir">
               <h3>
                  IsDir 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#IsDir" class="anchor" title="Link to IsDir">#</a>
               </h3>
               
               <pre><code>func (fi dataFileInfo) IsDir() bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lstat" data-name="Lstat">
               <h3>
                  Lstat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lstat" class="anchor" title="Link to Lstat">#</a>
               </h3>
               
               <pre><code>func (f dataFile) Lstat() (os.FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lstat" data-name="Lstat">
               <h3>
                  Lstat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lstat" class="anchor" title="Link to Lstat">#</a>
               </h3>
               
               <pre><code>func (f dirFile) Lstat() (os.FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Lstat" data-name="Lstat">
               <h3>
                  Lstat 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Lstat" class="anchor" title="Link to Lstat">#</a>
               </h3>
               
               <pre><code>func (f zipFile) Lstat() (os.FileInfo, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ModTime" data-name="ModTime">
               <h3>
                  ModTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ModTime" class="anchor" title="Link to ModTime">#</a>
               </h3>
               
               <pre><code>func (fi dataFileInfo) ModTime() time.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Mode" data-name="Mode">
               <h3>
                  Mode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Mode" class="anchor" title="Link to Mode">#</a>
               </h3>
               
               <pre><code>func (fi dataFileInfo) Mode() os.FileMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Name" data-name="Name">
               <h3>
                  Name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Name" class="anchor" title="Link to Name">#</a>
               </h3>
               
               <pre><code>func (fi dataFileInfo) Name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <pre><code>func (f dirFile) Open() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <pre><code>func (f zipFile) Open() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <pre><code>func (f dataFile) Open() (io.ReadCloser, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Path" data-name="Path">
               <h3>
                  Path 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Path" class="anchor" title="Link to Path">#</a>
               </h3>
               
               <pre><code>func (f dirFile) Path() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Path" data-name="Path">
               <h3>
                  Path 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Path" class="anchor" title="Link to Path">#</a>
               </h3>
               
               <pre><code>func (f dataFile) Path() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Path" data-name="Path">
               <h3>
                  Path 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Path" class="anchor" title="Link to Path">#</a>
               </h3>
               
               <pre><code>func (f zipFile) Path() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Size" data-name="Size">
               <h3>
                  Size 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Size" class="anchor" title="Link to Size">#</a>
               </h3>
               
               <pre><code>func (fi dataFileInfo) Size() int64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sys" data-name="Sys">
               <h3>
                  Sys 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sys" class="anchor" title="Link to Sys">#</a>
               </h3>
               
               <pre><code>func (fi dataFileInfo) Sys() interface{}</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code>func (e FileError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unwrap" data-name="Unwrap">
               <h3>
                  Unwrap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Unwrap" class="anchor" title="Link to Unwrap">#</a>
               </h3>
               
               <pre><code>func (e *zipError) Unwrap() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Unzip" data-name="Unzip">
               <h3>
                  Unzip 
                  <span class="badge">function</span>
                  
                  <a href="#Unzip" class="anchor" title="Link to Unzip">#</a>
               </h3>
               
               <p>Unzip extracts the contents of a module zip file to a directory.
Unzip checks all restrictions listed in the package documentation and returns
an error if the zip archive is not valid. In some cases, files may be written
to dir before an error is returned (for example, if a file's uncompressed
size does not match its declared size).
dir may or may not exist: Unzip will create it and any missing parent
directories if it doesn't exist. If dir exists, it must be empty.</p>
               
               <pre><code>func Unzip(dir string, m module.Version, zipFile string) (err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="check" data-name="check">
               <h3>
                  check 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#check" class="anchor" title="Link to check">#</a>
               </h3>
               
               <pre><code>func (cc collisionChecker) check(p string, isDir bool) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkFiles" data-name="checkFiles">
               <h3>
                  checkFiles 
                  <span class="badge">function</span>
                  
                  <a href="#checkFiles" class="anchor" title="Link to checkFiles">#</a>
               </h3>
               
               <p>checkFiles implements CheckFiles and also returns lists of valid files and
their sizes, corresponding to cf.Valid. It omits files in submodules, files
in vendored packages, symlinked files, and various other unwanted files.
The lists returned are used in Create to avoid repeated calls to File.Lstat.</p>
               
               <pre><code>func checkFiles(files []File) (cf CheckedFiles, validFiles []File, validSizes []int64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="checkZip" data-name="checkZip">
               <h3>
                  checkZip 
                  <span class="badge">function</span>
                  
                  <a href="#checkZip" class="anchor" title="Link to checkZip">#</a>
               </h3>
               
               <p>checkZip implements checkZip and also returns the *zip.Reader. This is
used in Unzip to avoid redundant I/O.</p>
               
               <pre><code>func checkZip(m module.Version, f *os.File) (*zip.Reader, CheckedFiles, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="filesInGitRepo" data-name="filesInGitRepo">
               <h3>
                  filesInGitRepo 
                  <span class="badge">function</span>
                  
                  <a href="#filesInGitRepo" class="anchor" title="Link to filesInGitRepo">#</a>
               </h3>
               
               <p>filesInGitRepo filters out any files that are git ignored in the directory.</p>
               
               <pre><code>func filesInGitRepo(dir string, rev string, subdir string) ([]File, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isGitRepo" data-name="isGitRepo">
               <h3>
                  isGitRepo 
                  <span class="badge">function</span>
                  
                  <a href="#isGitRepo" class="anchor" title="Link to isGitRepo">#</a>
               </h3>
               
               <p>isGitRepo reports whether the given directory is a git repo.</p>
               
               <pre><code>func isGitRepo(dir string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="isVendoredPackage" data-name="isVendoredPackage">
               <h3>
                  isVendoredPackage 
                  <span class="badge">function</span>
                  
                  <a href="#isVendoredPackage" class="anchor" title="Link to isVendoredPackage">#</a>
               </h3>
               
               <p>isVendoredPackage attempts to report whether the given filename is contained
in a package whose import path contains (but does not end with) the component
"vendor".
The 'vers' parameter specifies the Go version declared in the module's
go.mod file and must be a valid Go version according to the
go/version.IsValid function.
Vendoring behavior has evolved across Go versions, so this function adapts
its logic accordingly.</p>
               
               <pre><code>func isVendoredPackage(name string, vers string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="listFilesInDir" data-name="listFilesInDir">
               <h3>
                  listFilesInDir 
                  <span class="badge">function</span>
                  
                  <a href="#listFilesInDir" class="anchor" title="Link to listFilesInDir">#</a>
               </h3>
               
               <p>listFilesInDir walks the directory tree rooted at dir and returns a list of
files, as well as a list of directories and files that were skipped (for
example, nested modules and symbolic links).</p>
               
               <pre><code>func listFilesInDir(dir string) (files []File, omitted []FileError, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseGoVers" data-name="parseGoVers">
               <h3>
                  parseGoVers 
                  <span class="badge">function</span>
                  
                  <a href="#parseGoVers" class="anchor" title="Link to parseGoVers">#</a>
               </h3>
               
               <p>parseGoVers extracts the Go version specified in the given go.mod file.
It returns an empty string if the version is not found or if an error
occurs during file parsing.
The version string is in Go toolchain name syntax, prefixed with "go".
Examples: "go1.21", "go1.22rc2", "go1.23.0"</p>
               
               <pre><code>func parseGoVers(file string, data []byte) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="strToFold" data-name="strToFold">
               <h3>
                  strToFold 
                  <span class="badge">function</span>
                  
                  <a href="#strToFold" class="anchor" title="Link to strToFold">#</a>
               </h3>
               
               <p>strToFold returns a string with the property that
strings.EqualFold(s, t) iff strToFold(s) == strToFold(t)
This lets us test a large set of strings for fold-equivalent
duplicates without making a quadratic number of calls
to EqualFold. Note that strings.ToUpper and strings.ToLower
do not have the desired property in some corner cases.</p>
               
               <pre><code>func strToFold(s string) string</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>