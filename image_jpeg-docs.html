<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - jpeg</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>jpeg</code>
         </h1>
         <hr />
         
         <article class="global" data-name="cosines">
            <h2>cosines</h2>
            <hr />
            
            <pre><code>cosines</code></pre>
         </article>
         
         <article class="global" data-name="testBlocks">
            <h2>testBlocks</h2>
            <hr />
            
            <p>testBlocks are the first 10 pre-IDCT blocks from ../testdata/video-001.jpeg.</p>
            
            <pre><code>testBlocks</code></pre>
         </article>
         
         <article class="global" data-name="maxCodeLength">
            <h2>maxCodeLength</h2>
            <hr />
            
            <p>maxCodeLength is the maximum (inclusive) number of bits in a Huffman code.</p>
            
            <pre><code>maxCodeLength</code></pre>
         </article>
         
         <article class="global" data-name="maxNCodes">
            <h2>maxNCodes</h2>
            <hr />
            
            <p>maxNCodes is the maximum (inclusive) number of codes in a Huffman tree.</p>
            
            <pre><code>maxNCodes</code></pre>
         </article>
         
         <article class="global" data-name="lutSize">
            <h2>lutSize</h2>
            <hr />
            
            <p>lutSize is the log-2 size of the Huffman decoder's look-up table.</p>
            
            <pre><code>lutSize</code></pre>
         </article>
         
         <article class="global" data-name="errShortHuffmanData">
            <h2>errShortHuffmanData</h2>
            <hr />
            
            <p>errShortHuffmanData means that an unexpected EOF occurred while decoding
Huffman data.</p>
            
            <pre><code>errShortHuffmanData</code></pre>
         </article>
         
         <article class="global" data-name="errUnsupportedSubsamplingRatio">
            <h2>errUnsupportedSubsamplingRatio</h2>
            <hr />
            
            <pre><code>errUnsupportedSubsamplingRatio</code></pre>
         </article>
         
         <article class="global" data-name="dcTable">
            <h2>dcTable</h2>
            <hr />
            
            <pre><code>dcTable</code></pre>
         </article>
         
         <article class="global" data-name="acTable">
            <h2>acTable</h2>
            <hr />
            
            <pre><code>acTable</code></pre>
         </article>
         
         <article class="global" data-name="maxTc">
            <h2>maxTc</h2>
            <hr />
            
            <pre><code>maxTc</code></pre>
         </article>
         
         <article class="global" data-name="maxTh">
            <h2>maxTh</h2>
            <hr />
            
            <pre><code>maxTh</code></pre>
         </article>
         
         <article class="global" data-name="maxTq">
            <h2>maxTq</h2>
            <hr />
            
            <pre><code>maxTq</code></pre>
         </article>
         
         <article class="global" data-name="maxComponents">
            <h2>maxComponents</h2>
            <hr />
            
            <pre><code>maxComponents</code></pre>
         </article>
         
         <article class="global" data-name="sof0Marker">
            <h2>sof0Marker</h2>
            <hr />
            
            <pre><code>sof0Marker</code></pre>
         </article>
         
         <article class="global" data-name="sof1Marker">
            <h2>sof1Marker</h2>
            <hr />
            
            <pre><code>sof1Marker</code></pre>
         </article>
         
         <article class="global" data-name="sof2Marker">
            <h2>sof2Marker</h2>
            <hr />
            
            <pre><code>sof2Marker</code></pre>
         </article>
         
         <article class="global" data-name="dhtMarker">
            <h2>dhtMarker</h2>
            <hr />
            
            <pre><code>dhtMarker</code></pre>
         </article>
         
         <article class="global" data-name="rst0Marker">
            <h2>rst0Marker</h2>
            <hr />
            
            <pre><code>rst0Marker</code></pre>
         </article>
         
         <article class="global" data-name="rst7Marker">
            <h2>rst7Marker</h2>
            <hr />
            
            <pre><code>rst7Marker</code></pre>
         </article>
         
         <article class="global" data-name="soiMarker">
            <h2>soiMarker</h2>
            <hr />
            
            <pre><code>soiMarker</code></pre>
         </article>
         
         <article class="global" data-name="eoiMarker">
            <h2>eoiMarker</h2>
            <hr />
            
            <pre><code>eoiMarker</code></pre>
         </article>
         
         <article class="global" data-name="sosMarker">
            <h2>sosMarker</h2>
            <hr />
            
            <pre><code>sosMarker</code></pre>
         </article>
         
         <article class="global" data-name="dqtMarker">
            <h2>dqtMarker</h2>
            <hr />
            
            <pre><code>dqtMarker</code></pre>
         </article>
         
         <article class="global" data-name="driMarker">
            <h2>driMarker</h2>
            <hr />
            
            <pre><code>driMarker</code></pre>
         </article>
         
         <article class="global" data-name="comMarker">
            <h2>comMarker</h2>
            <hr />
            
            <pre><code>comMarker</code></pre>
         </article>
         
         <article class="global" data-name="app0Marker">
            <h2>app0Marker</h2>
            <hr />
            
            <p>"APPlication specific" markers aren't part of the JPEG spec per se,
but in practice, their use is described at
https://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/JPEG.html</p>
            
            <pre><code>app0Marker</code></pre>
         </article>
         
         <article class="global" data-name="app14Marker">
            <h2>app14Marker</h2>
            <hr />
            
            <pre><code>app14Marker</code></pre>
         </article>
         
         <article class="global" data-name="app15Marker">
            <h2>app15Marker</h2>
            <hr />
            
            <pre><code>app15Marker</code></pre>
         </article>
         
         <article class="global" data-name="adobeTransformUnknown">
            <h2>adobeTransformUnknown</h2>
            <hr />
            
            <p>See https://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/JPEG.html#Adobe</p>
            
            <pre><code>adobeTransformUnknown</code></pre>
         </article>
         
         <article class="global" data-name="adobeTransformYCbCr">
            <h2>adobeTransformYCbCr</h2>
            <hr />
            
            <p>See https://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/JPEG.html#Adobe</p>
            
            <pre><code>adobeTransformYCbCr</code></pre>
         </article>
         
         <article class="global" data-name="adobeTransformYCbCrK">
            <h2>adobeTransformYCbCrK</h2>
            <hr />
            
            <p>See https://www.sno.phy.queensu.ca/~phil/exiftool/TagNames/JPEG.html#Adobe</p>
            
            <pre><code>adobeTransformYCbCrK</code></pre>
         </article>
         
         <article class="global" data-name="unzig">
            <h2>unzig</h2>
            <hr />
            
            <p>unzig maps from the zig-zag ordering to the natural ordering. For example,
unzig[3] is the column and row of the fourth element in zig-zag order. The
value is 16, which means first column (16%8 == 0) and third row (16/8 == 2).</p>
            
            <pre><code>unzig</code></pre>
         </article>
         
         <article class="global" data-name="errMissingFF00">
            <h2>errMissingFF00</h2>
            <hr />
            
            <p>errMissingFF00 means that readByteStuffedByte encountered an 0xff byte (a
marker byte) that wasn't the expected byte-stuffed sequence 0xff, 0x00.</p>
            
            <pre><code>errMissingFF00</code></pre>
         </article>
         
         <article class="global" data-name="zigzag">
            <h2>zigzag</h2>
            <hr />
            
            <p>zigzag maps from the natural ordering to the zig-zag ordering. For example,
zigzag[0*8 + 3] is the zig-zag sequence number of the element in the fourth
column and first row.</p>
            
            <pre><code>zigzag</code></pre>
         </article>
         
         <article class="global" data-name="unscaledQuantInNaturalOrder">
            <h2>unscaledQuantInNaturalOrder</h2>
            <hr />
            
            <p>unscaledQuantInNaturalOrder are the unscaled quantization tables in
natural (not zig-zag) order, as specified in section K.1.</p>
            
            <pre><code>unscaledQuantInNaturalOrder</code></pre>
         </article>
         
         <article class="global" data-name="testCase">
            <h2>testCase</h2>
            <hr />
            
            <pre><code>testCase</code></pre>
         </article>
         
         <article class="global" data-name="fix_0_298631336">
            <h2>fix_0_298631336</h2>
            <hr />
            
            <p>Trigonometric constants in 13-bit fixed point format.</p>
            
            <pre><code>fix_0_298631336</code></pre>
         </article>
         
         <article class="global" data-name="fix_0_390180644">
            <h2>fix_0_390180644</h2>
            <hr />
            
            <p>Trigonometric constants in 13-bit fixed point format.</p>
            
            <pre><code>fix_0_390180644</code></pre>
         </article>
         
         <article class="global" data-name="fix_0_541196100">
            <h2>fix_0_541196100</h2>
            <hr />
            
            <p>Trigonometric constants in 13-bit fixed point format.</p>
            
            <pre><code>fix_0_541196100</code></pre>
         </article>
         
         <article class="global" data-name="fix_0_765366865">
            <h2>fix_0_765366865</h2>
            <hr />
            
            <p>Trigonometric constants in 13-bit fixed point format.</p>
            
            <pre><code>fix_0_765366865</code></pre>
         </article>
         
         <article class="global" data-name="fix_0_899976223">
            <h2>fix_0_899976223</h2>
            <hr />
            
            <p>Trigonometric constants in 13-bit fixed point format.</p>
            
            <pre><code>fix_0_899976223</code></pre>
         </article>
         
         <article class="global" data-name="fix_1_175875602">
            <h2>fix_1_175875602</h2>
            <hr />
            
            <p>Trigonometric constants in 13-bit fixed point format.</p>
            
            <pre><code>fix_1_175875602</code></pre>
         </article>
         
         <article class="global" data-name="fix_1_501321110">
            <h2>fix_1_501321110</h2>
            <hr />
            
            <p>Trigonometric constants in 13-bit fixed point format.</p>
            
            <pre><code>fix_1_501321110</code></pre>
         </article>
         
         <article class="global" data-name="fix_1_847759065">
            <h2>fix_1_847759065</h2>
            <hr />
            
            <p>Trigonometric constants in 13-bit fixed point format.</p>
            
            <pre><code>fix_1_847759065</code></pre>
         </article>
         
         <article class="global" data-name="fix_1_961570560">
            <h2>fix_1_961570560</h2>
            <hr />
            
            <p>Trigonometric constants in 13-bit fixed point format.</p>
            
            <pre><code>fix_1_961570560</code></pre>
         </article>
         
         <article class="global" data-name="fix_2_053119869">
            <h2>fix_2_053119869</h2>
            <hr />
            
            <p>Trigonometric constants in 13-bit fixed point format.</p>
            
            <pre><code>fix_2_053119869</code></pre>
         </article>
         
         <article class="global" data-name="fix_2_562915447">
            <h2>fix_2_562915447</h2>
            <hr />
            
            <p>Trigonometric constants in 13-bit fixed point format.</p>
            
            <pre><code>fix_2_562915447</code></pre>
         </article>
         
         <article class="global" data-name="fix_3_072711026">
            <h2>fix_3_072711026</h2>
            <hr />
            
            <p>Trigonometric constants in 13-bit fixed point format.</p>
            
            <pre><code>fix_3_072711026</code></pre>
         </article>
         
         <article class="global" data-name="constBits">
            <h2>constBits</h2>
            <hr />
            
            <pre><code>constBits</code></pre>
         </article>
         
         <article class="global" data-name="pass1Bits">
            <h2>pass1Bits</h2>
            <hr />
            
            <pre><code>pass1Bits</code></pre>
         </article>
         
         <article class="global" data-name="centerJSample">
            <h2>centerJSample</h2>
            <hr />
            
            <pre><code>centerJSample</code></pre>
         </article>
         
         <article class="global" data-name="blockSize">
            <h2>blockSize</h2>
            <hr />
            
            <pre><code>blockSize</code></pre>
         </article>
         
         <article class="global" data-name="w1">
            <h2>w1</h2>
            <hr />
            
            <pre><code>w1</code></pre>
         </article>
         
         <article class="global" data-name="w2">
            <h2>w2</h2>
            <hr />
            
            <pre><code>w2</code></pre>
         </article>
         
         <article class="global" data-name="w3">
            <h2>w3</h2>
            <hr />
            
            <pre><code>w3</code></pre>
         </article>
         
         <article class="global" data-name="w5">
            <h2>w5</h2>
            <hr />
            
            <pre><code>w5</code></pre>
         </article>
         
         <article class="global" data-name="w6">
            <h2>w6</h2>
            <hr />
            
            <pre><code>w6</code></pre>
         </article>
         
         <article class="global" data-name="w7">
            <h2>w7</h2>
            <hr />
            
            <pre><code>w7</code></pre>
         </article>
         
         <article class="global" data-name="w1pw7">
            <h2>w1pw7</h2>
            <hr />
            
            <pre><code>w1pw7</code></pre>
         </article>
         
         <article class="global" data-name="w1mw7">
            <h2>w1mw7</h2>
            <hr />
            
            <pre><code>w1mw7</code></pre>
         </article>
         
         <article class="global" data-name="w2pw6">
            <h2>w2pw6</h2>
            <hr />
            
            <pre><code>w2pw6</code></pre>
         </article>
         
         <article class="global" data-name="w2mw6">
            <h2>w2mw6</h2>
            <hr />
            
            <pre><code>w2mw6</code></pre>
         </article>
         
         <article class="global" data-name="w3pw5">
            <h2>w3pw5</h2>
            <hr />
            
            <pre><code>w3pw5</code></pre>
         </article>
         
         <article class="global" data-name="w3mw5">
            <h2>w3mw5</h2>
            <hr />
            
            <pre><code>w3mw5</code></pre>
         </article>
         
         <article class="global" data-name="r2">
            <h2>r2</h2>
            <hr />
            
            <pre><code>r2</code></pre>
         </article>
         
         <article class="global" data-name="bitCount">
            <h2>bitCount</h2>
            <hr />
            
            <p>bitCount counts the number of bits needed to hold an integer.</p>
            
            <pre><code>bitCount</code></pre>
         </article>
         
         <article class="global" data-name="quantIndexLuminance">
            <h2>quantIndexLuminance</h2>
            <hr />
            
            <pre><code>quantIndexLuminance quantIndex</code></pre>
         </article>
         
         <article class="global" data-name="quantIndexChrominance">
            <h2>quantIndexChrominance</h2>
            <hr />
            
            <pre><code>quantIndexChrominance</code></pre>
         </article>
         
         <article class="global" data-name="nQuantIndex">
            <h2>nQuantIndex</h2>
            <hr />
            
            <pre><code>nQuantIndex</code></pre>
         </article>
         
         <article class="global" data-name="unscaledQuant">
            <h2>unscaledQuant</h2>
            <hr />
            
            <p>unscaledQuant are the unscaled quantization tables in zig-zag order. Each
encoder copies and scales the tables according to its quality parameter.
The values are derived from section K.1 of the spec, after converting from
natural to zig-zag order.</p>
            
            <pre><code>unscaledQuant</code></pre>
         </article>
         
         <article class="global" data-name="huffIndexLuminanceDC">
            <h2>huffIndexLuminanceDC</h2>
            <hr />
            
            <pre><code>huffIndexLuminanceDC huffIndex</code></pre>
         </article>
         
         <article class="global" data-name="huffIndexLuminanceAC">
            <h2>huffIndexLuminanceAC</h2>
            <hr />
            
            <pre><code>huffIndexLuminanceAC</code></pre>
         </article>
         
         <article class="global" data-name="huffIndexChrominanceDC">
            <h2>huffIndexChrominanceDC</h2>
            <hr />
            
            <pre><code>huffIndexChrominanceDC</code></pre>
         </article>
         
         <article class="global" data-name="huffIndexChrominanceAC">
            <h2>huffIndexChrominanceAC</h2>
            <hr />
            
            <pre><code>huffIndexChrominanceAC</code></pre>
         </article>
         
         <article class="global" data-name="nHuffIndex">
            <h2>nHuffIndex</h2>
            <hr />
            
            <pre><code>nHuffIndex</code></pre>
         </article>
         
         <article class="global" data-name="theHuffmanSpec">
            <h2>theHuffmanSpec</h2>
            <hr />
            
            <p>theHuffmanSpec is the Huffman encoding specifications.

This encoder uses the same Huffman encoding for all images. It is also the
same Huffman encoding used by section K.3 of the spec.

The DC tables have 12 decoded values, called categories.

The AC tables have 162 decoded values: bytes that pack a 4-bit Run and a
4-bit Size. There are 16 valid Runs and 10 valid Sizes, plus two special R|S
cases: 0|0 (meaning EOB) and F|0 (meaning ZRL).</p>
            
            <pre><code>theHuffmanSpec</code></pre>
         </article>
         
         <article class="global" data-name="theHuffmanLUT">
            <h2>theHuffmanLUT</h2>
            <hr />
            
            <p>theHuffmanLUT are compiled representations of theHuffmanSpec.</p>
            
            <pre><code>theHuffmanLUT []huffmanLUT</code></pre>
         </article>
         
         <article class="global" data-name="sosHeaderY">
            <h2>sosHeaderY</h2>
            <hr />
            
            <p>sosHeaderY is the SOS marker "\xff\xda" followed by 8 bytes:
  - the marker length "\x00\x08",
  - the number of components "\x01",
  - component 1 uses DC table 0 and AC table 0 "\x01\x00",
  - the bytes "\x00\x3f\x00". Section B.2.3 of the spec says that for
    sequential DCTs, those bytes (8-bit Ss, 8-bit Se, 4-bit Ah, 4-bit Al)
    should be 0x00, 0x3f, 0x00<<4 | 0x00.</p>
            
            <pre><code>sosHeaderY</code></pre>
         </article>
         
         <article class="global" data-name="sosHeaderYCbCr">
            <h2>sosHeaderYCbCr</h2>
            <hr />
            
            <p>sosHeaderYCbCr is the SOS marker "\xff\xda" followed by 12 bytes:
  - the marker length "\x00\x0c",
  - the number of components "\x03",
  - component 1 uses DC table 0 and AC table 0 "\x01\x00",
  - component 2 uses DC table 1 and AC table 1 "\x02\x11",
  - component 3 uses DC table 1 and AC table 1 "\x03\x11",
  - the bytes "\x00\x3f\x00". Section B.2.3 of the spec says that for
    sequential DCTs, those bytes (8-bit Ss, 8-bit Se, 4-bit Ah, 4-bit Al)
    should be 0x00, 0x3f, 0x00<<4 | 0x00.</p>
            
            <pre><code>sosHeaderYCbCr</code></pre>
         </article>
         
         <article class="global" data-name="DefaultQuality">
            <h2>DefaultQuality</h2>
            <hr />
            
            <p>DefaultQuality is the default quality encoding parameter.</p>
            
            <pre><code>DefaultQuality</code></pre>
         </article>
          
         <article class="struct" data-name="huffman">
            <h2>type huffman struct</h2>
            <hr />
            
            <p>huffman is a Huffman decoder, specified in section C.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">nCodes int32
lut []uint16
vals []uint8
minCodes []int32
maxCodes []int32
valsIndices []int32</code></pre>
         </article>
         
         <article class="struct" data-name="component">
            <h2>type component struct</h2>
            <hr />
            
            <p>Component specification, specified in section B.2.2.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">h int
v int
c uint8
tq uint8</code></pre>
         </article>
         
         <article class="struct" data-name="bits">
            <h2>type bits struct</h2>
            <hr />
            
            <p>bits holds the unprocessed bits that have been taken from the byte-stream.
The n least significant bits of a form the unread bits, to be read in MSB to
LSB order.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">a uint32
m uint32
n int32</code></pre>
         </article>
         
         <article class="struct" data-name="decoder">
            <h2>type decoder struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">r io.Reader
bits bits
bytes *ast.StructType
width int
height int
img1 *image.Gray
img3 *image.YCbCr
blackPix []byte
blackStride int
ri int
nComp int
baseline bool
progressive bool
jfif bool
adobeTransformValid bool
adobeTransform uint8
eobRun uint16
comp []component
progCoeffs [][]block
huff [][]huffman
quant []block
tmp []byte</code></pre>
         </article>
         
         <article class="struct" data-name="eofReader">
            <h2>type eofReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">data []byte
dataEOF []byte
lenAtEOF int</code></pre>
         </article>
         
         <article class="struct" data-name="huffmanSpec">
            <h2>type huffmanSpec struct</h2>
            <hr />
            
            <p>huffmanSpec specifies a Huffman encoding.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">count []byte
value []byte</code></pre>
         </article>
         
         <article class="struct" data-name="encoder">
            <h2>type encoder struct</h2>
            <hr />
            
            <p>encoder encodes an image to the JPEG format.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">w writer
err error
buf []byte
bits uint32
nBits uint32
quant [][]byte</code></pre>
         </article>
         
         <article class="struct" data-name="Options">
            <h2>type Options struct</h2>
            <hr />
            
            <p>Options are the encoding parameters.
Quality ranges from 1 to 100 inclusive, higher is better.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Quality int</code></pre>
         </article>
          
         <article class="function" data-name="benchmarkDCT">
            <h2>benchmarkDCT</h2>
            <hr />
            
            <pre><code>func benchmarkDCT(b *testing.B, f func)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkFDCT">
            <h2>BenchmarkFDCT</h2>
            <hr />
            
            <pre><code>func BenchmarkFDCT(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkIDCT">
            <h2>BenchmarkIDCT</h2>
            <hr />
            
            <pre><code>func BenchmarkIDCT(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="TestDCT">
            <h2>TestDCT</h2>
            <hr />
            
            <pre><code>func TestDCT(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="differ">
            <h2>differ</h2>
            <hr />
            
            <p>differ reports whether any pair-wise elements in b0 and b1 differ by 2 or
more. That tolerance is because there isn't a single definitive decoding of
a given JPEG image, even before the YCbCr to RGB conversion; implementations
can have different IDCT rounding errors.</p>
            
            <pre><code>func differ(b0 *block, b1 *block) bool</code></pre>
         </article>
         
         <article class="function" data-name="alpha">
            <h2>alpha</h2>
            <hr />
            
            <p>alpha returns 1 if i is 0 and returns √2 otherwise.</p>
            
            <pre><code>func alpha(i int) float64</code></pre>
         </article>
         
         <article class="function" data-name="slowFDCT">
            <h2>slowFDCT</h2>
            <hr />
            
            <p>slowFDCT performs the 8*8 2-dimensional forward discrete cosine transform:

	dst[u,v] = (1/8) * Σ_x Σ_y alpha(u) * alpha(v) * src[x,y] *
		cos((π/2) * (2*x + 1) * u / 8) *
		cos((π/2) * (2*y + 1) * v / 8)

x and y are in pixel space, and u and v are in transform space.

b acts as both dst and src.</p>
            
            <pre><code>func slowFDCT(b *block)</code></pre>
         </article>
         
         <article class="function" data-name="slowIDCT">
            <h2>slowIDCT</h2>
            <hr />
            
            <p>slowIDCT performs the 8*8 2-dimensional inverse discrete cosine transform:

	dst[x,y] = (1/8) * Σ_u Σ_v alpha(u) * alpha(v) * src[u,v] *
		cos((π/2) * (2*x + 1) * u / 8) *
		cos((π/2) * (2*y + 1) * v / 8)

x and y are in pixel space, and u and v are in transform space.

b acts as both dst and src.</p>
            
            <pre><code>func slowIDCT(b *block)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="FuzzDecode">
            <h2>FuzzDecode</h2>
            <hr />
            
            <pre><code>func FuzzDecode(f *testing.F)</code></pre>
         </article>
         
         <article class="function" data-name="ensureNBits">
            <h2>ensureNBits</h2>
            <hr />
            
            <p>ensureNBits reads bytes from the byte buffer to ensure that d.bits.n is at
least n. For best performance (avoiding function calls inside hot loops),
the caller is the one responsible for first checking that d.bits.n < n.</p>
            
            <pre><code>func ensureNBits(n int32) error</code></pre>
         </article>
         
         <article class="function" data-name="receiveExtend">
            <h2>receiveExtend</h2>
            <hr />
            
            <p>receiveExtend is the composition of RECEIVE and EXTEND, specified in section
F.2.2.1.</p>
            
            <pre><code>func receiveExtend(t uint8) (int32, error)</code></pre>
         </article>
         
         <article class="function" data-name="processDHT">
            <h2>processDHT</h2>
            <hr />
            
            <p>processDHT processes a Define Huffman Table marker, and initializes a huffman
struct from its contents. Specified in section B.2.4.2.</p>
            
            <pre><code>func processDHT(n int) error</code></pre>
         </article>
         
         <article class="function" data-name="decodeHuffman">
            <h2>decodeHuffman</h2>
            <hr />
            
            <p>decodeHuffman returns the next Huffman-coded value from the bit-stream,
decoded according to h.</p>
            
            <pre><code>func decodeHuffman(h *huffman) (uint8, error)</code></pre>
         </article>
         
         <article class="function" data-name="decodeBit">
            <h2>decodeBit</h2>
            <hr />
            
            <pre><code>func decodeBit() (bool, error)</code></pre>
         </article>
         
         <article class="function" data-name="decodeBits">
            <h2>decodeBits</h2>
            <hr />
            
            <pre><code>func decodeBits(n int32) (uint32, error)</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="Error">
            <h2>Error</h2>
            <hr />
            
            <pre><code>func Error() string</code></pre>
         </article>
         
         <article class="function" data-name="fill">
            <h2>fill</h2>
            <hr />
            
            <p>fill fills up the d.bytes.buf buffer from the underlying io.Reader. It
should only be called when there are no unread bytes in d.bytes.</p>
            
            <pre><code>func fill() error</code></pre>
         </article>
         
         <article class="function" data-name="unreadByteStuffedByte">
            <h2>unreadByteStuffedByte</h2>
            <hr />
            
            <p>unreadByteStuffedByte undoes the most recent readByteStuffedByte call,
giving a byte of data back from d.bits to d.bytes. The Huffman look-up table
requires at least 8 bits for look-up, which means that Huffman decoding can
sometimes overshoot and read one or two too many bytes. Two-byte overshoot
can happen when expecting to read a 0xff 0x00 byte-stuffed byte.</p>
            
            <pre><code>func unreadByteStuffedByte()</code></pre>
         </article>
         
         <article class="function" data-name="readByte">
            <h2>readByte</h2>
            <hr />
            
            <p>readByte returns the next byte, whether buffered or not buffered. It does
not care about byte stuffing.</p>
            
            <pre><code>func readByte() (x byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readByteStuffedByte">
            <h2>readByteStuffedByte</h2>
            <hr />
            
            <p>readByteStuffedByte is like readByte but is for byte-stuffed Huffman data.</p>
            
            <pre><code>func readByteStuffedByte() (x byte, err error)</code></pre>
         </article>
         
         <article class="function" data-name="readFull">
            <h2>readFull</h2>
            <hr />
            
            <p>readFull reads exactly len(p) bytes into p. It does not care about byte
stuffing.</p>
            
            <pre><code>func readFull(p []byte) error</code></pre>
         </article>
         
         <article class="function" data-name="ignore">
            <h2>ignore</h2>
            <hr />
            
            <p>ignore ignores the next n bytes.</p>
            
            <pre><code>func ignore(n int) error</code></pre>
         </article>
         
         <article class="function" data-name="processSOF">
            <h2>processSOF</h2>
            <hr />
            
            <p>Specified in section B.2.2.</p>
            
            <pre><code>func processSOF(n int) error</code></pre>
         </article>
         
         <article class="function" data-name="processDQT">
            <h2>processDQT</h2>
            <hr />
            
            <p>Specified in section B.2.4.1.</p>
            
            <pre><code>func processDQT(n int) error</code></pre>
         </article>
         
         <article class="function" data-name="processDRI">
            <h2>processDRI</h2>
            <hr />
            
            <p>Specified in section B.2.4.4.</p>
            
            <pre><code>func processDRI(n int) error</code></pre>
         </article>
         
         <article class="function" data-name="processApp0Marker">
            <h2>processApp0Marker</h2>
            <hr />
            
            <pre><code>func processApp0Marker(n int) error</code></pre>
         </article>
         
         <article class="function" data-name="processApp14Marker">
            <h2>processApp14Marker</h2>
            <hr />
            
            <pre><code>func processApp14Marker(n int) error</code></pre>
         </article>
         
         <article class="function" data-name="decode">
            <h2>decode</h2>
            <hr />
            
            <p>decode reads a JPEG image from r and returns it as an image.Image.</p>
            
            <pre><code>func decode(r io.Reader, configOnly bool) (image.Image, error)</code></pre>
         </article>
         
         <article class="function" data-name="applyBlack">
            <h2>applyBlack</h2>
            <hr />
            
            <p>applyBlack combines d.img3 and d.blackPix into a CMYK image. The formula
used depends on whether the JPEG image is stored as CMYK or YCbCrK,
indicated by the APP14 (Adobe) metadata.

Adobe CMYK JPEG images are inverted, where 255 means no ink instead of full
ink, so we apply "v = 255 - v" at various points. Note that a double
inversion is a no-op, so inversions might be implicit in the code below.</p>
            
            <pre><code>func applyBlack() (image.Image, error)</code></pre>
         </article>
         
         <article class="function" data-name="isRGB">
            <h2>isRGB</h2>
            <hr />
            
            <pre><code>func isRGB() bool</code></pre>
         </article>
         
         <article class="function" data-name="convertToRGB">
            <h2>convertToRGB</h2>
            <hr />
            
            <pre><code>func convertToRGB() (image.Image, error)</code></pre>
         </article>
         
         <article class="function" data-name="Decode">
            <h2>Decode</h2>
            <hr />
            
            <p>Decode reads a JPEG image from r and returns it as an [image.Image].</p>
            
            <pre><code>func Decode(r io.Reader) (image.Image, error)</code></pre>
         </article>
         
         <article class="function" data-name="DecodeConfig">
            <h2>DecodeConfig</h2>
            <hr />
            
            <p>DecodeConfig returns the color model and dimensions of a JPEG image without
decoding the entire image.</p>
            
            <pre><code>func DecodeConfig(r io.Reader) (image.Config, error)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="TestZigUnzig">
            <h2>TestZigUnzig</h2>
            <hr />
            
            <pre><code>func TestZigUnzig(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestUnscaledQuant">
            <h2>TestUnscaledQuant</h2>
            <hr />
            
            <pre><code>func TestUnscaledQuant(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="delta">
            <h2>delta</h2>
            <hr />
            
            <pre><code>func delta(u0 uint32, u1 uint32) int64</code></pre>
         </article>
         
         <article class="function" data-name="readPng">
            <h2>readPng</h2>
            <hr />
            
            <pre><code>func readPng(filename string) (image.Image, error)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriter">
            <h2>TestWriter</h2>
            <hr />
            
            <pre><code>func TestWriter(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestWriteGrayscale">
            <h2>TestWriteGrayscale</h2>
            <hr />
            
            <p>TestWriteGrayscale tests that a grayscale images survives a round-trip
through encode/decode cycle.</p>
            
            <pre><code>func TestWriteGrayscale(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="averageDelta">
            <h2>averageDelta</h2>
            <hr />
            
            <p>averageDelta returns the average delta in RGB space. The two images must
have the same bounds.</p>
            
            <pre><code>func averageDelta(m0 image.Image, m1 image.Image) int64</code></pre>
         </article>
         
         <article class="function" data-name="TestEncodeYCbCr">
            <h2>TestEncodeYCbCr</h2>
            <hr />
            
            <pre><code>func TestEncodeYCbCr(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEncodeRGBA">
            <h2>BenchmarkEncodeRGBA</h2>
            <hr />
            
            <pre><code>func BenchmarkEncodeRGBA(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkEncodeYCbCr">
            <h2>BenchmarkEncodeYCbCr</h2>
            <hr />
            
            <pre><code>func BenchmarkEncodeYCbCr(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="fdct">
            <h2>fdct</h2>
            <hr />
            
            <p>fdct performs a forward DCT on an 8x8 block of coefficients, including a
level shift.</p>
            
            <pre><code>func fdct(b *block)</code></pre>
         </article>
         
         <article class="function" data-name="idct">
            <h2>idct</h2>
            <hr />
            
            <p>idct performs a 2-D Inverse Discrete Cosine Transformation.

The input coefficients should already have been multiplied by the
appropriate quantization table. We use fixed-point computation, with the
number of bits for the fractional component varying over the intermediate
stages.

For more on the actual algorithm, see Z. Wang, "Fast algorithms for the
discrete W transform and for the discrete Fourier transform", IEEE Trans. on
ASSP, Vol. ASSP- 32, pp. 803-816, Aug. 1984.</p>
            
            <pre><code>func idct(src *block)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecodeProgressive">
            <h2>TestDecodeProgressive</h2>
            <hr />
            
            <p>TestDecodeProgressive tests that decoding the baseline and progressive
versions of the same image result in exactly the same pixel data, in YCbCr
space for color images, and Y space for grayscale images.</p>
            
            <pre><code>func TestDecodeProgressive(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="decodeFile">
            <h2>decodeFile</h2>
            <hr />
            
            <pre><code>func decodeFile(filename string) (image.Image, error)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(b []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="TestDecodeEOF">
            <h2>TestDecodeEOF</h2>
            <hr />
            
            <pre><code>func TestDecodeEOF(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="check">
            <h2>check</h2>
            <hr />
            
            <p>check checks that the two pix data are equal, within the given bounds.</p>
            
            <pre><code>func check(bounds image.Rectangle, pix0 []byte, pix1 []byte, stride0 int, stride1 int) error</code></pre>
         </article>
         
         <article class="function" data-name="pixString">
            <h2>pixString</h2>
            <hr />
            
            <pre><code>func pixString(pix []byte, stride int, x int, y int) string</code></pre>
         </article>
         
         <article class="function" data-name="TestTruncatedSOSDataDoesntPanic">
            <h2>TestTruncatedSOSDataDoesntPanic</h2>
            <hr />
            
            <pre><code>func TestTruncatedSOSDataDoesntPanic(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestLargeImageWithShortData">
            <h2>TestLargeImageWithShortData</h2>
            <hr />
            
            <pre><code>func TestLargeImageWithShortData(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPaddedRSTMarker">
            <h2>TestPaddedRSTMarker</h2>
            <hr />
            
            <pre><code>func TestPaddedRSTMarker(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestExtraneousData">
            <h2>TestExtraneousData</h2>
            <hr />
            
            <pre><code>func TestExtraneousData(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestIssue56724">
            <h2>TestIssue56724</h2>
            <hr />
            
            <pre><code>func TestIssue56724(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestBadRestartMarker">
            <h2>TestBadRestartMarker</h2>
            <hr />
            
            <pre><code>func TestBadRestartMarker(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="benchmarkDecode">
            <h2>benchmarkDecode</h2>
            <hr />
            
            <pre><code>func benchmarkDecode(b *testing.B, filename string)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecodeBaseline">
            <h2>BenchmarkDecodeBaseline</h2>
            <hr />
            
            <pre><code>func BenchmarkDecodeBaseline(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="BenchmarkDecodeProgressive">
            <h2>BenchmarkDecodeProgressive</h2>
            <hr />
            
            <pre><code>func BenchmarkDecodeProgressive(b *testing.B)</code></pre>
         </article>
         
         <article class="function" data-name="makeImg">
            <h2>makeImg</h2>
            <hr />
            
            <p>makeImg allocates and initializes the destination image.</p>
            
            <pre><code>func makeImg(mxx int, myy int)</code></pre>
         </article>
         
         <article class="function" data-name="processSOS">
            <h2>processSOS</h2>
            <hr />
            
            <p>Specified in section B.2.3.</p>
            
            <pre><code>func processSOS(n int) error</code></pre>
         </article>
         
         <article class="function" data-name="refine">
            <h2>refine</h2>
            <hr />
            
            <p>refine decodes a successive approximation refinement block, as specified in
section G.1.2.</p>
            
            <pre><code>func refine(b *block, h *huffman, zigStart int32, zigEnd int32, delta int32) error</code></pre>
         </article>
         
         <article class="function" data-name="refineNonZeroes">
            <h2>refineNonZeroes</h2>
            <hr />
            
            <p>refineNonZeroes refines non-zero entries of b in zig-zag order. If nz >= 0,
the first nz zero entries are skipped over.</p>
            
            <pre><code>func refineNonZeroes(b *block, zig int32, zigEnd int32, nz int32, delta int32) (int32, error)</code></pre>
         </article>
         
         <article class="function" data-name="reconstructProgressiveImage">
            <h2>reconstructProgressiveImage</h2>
            <hr />
            
            <pre><code>func reconstructProgressiveImage() error</code></pre>
         </article>
         
         <article class="function" data-name="reconstructBlock">
            <h2>reconstructBlock</h2>
            <hr />
            
            <p>reconstructBlock dequantizes, performs the inverse DCT and stores the block
to the image.</p>
            
            <pre><code>func reconstructBlock(b *block, bx int, by int, compIndex int) error</code></pre>
         </article>
         
         <article class="function" data-name="findRST">
            <h2>findRST</h2>
            <hr />
            
            <p>findRST advances past the next RST restart marker that matches expectedRST.
Other than I/O errors, it is also an error if we encounter an {0xFF, M}
two-byte marker sequence where M is not 0x00, 0xFF or the expectedRST.

This is similar to libjpeg's jdmarker.c's next_marker function.
https://github.com/libjpeg-turbo/libjpeg-turbo/blob/2dfe6c0fe9e18671105e94f7cbf044d4a1d157e6/jdmarker.c#L892-L935

Precondition: d.tmp[:2] holds the next two bytes of JPEG-encoded input
(input in the d.readFull sense).</p>
            
            <pre><code>func findRST(expectedRST uint8) error</code></pre>
         </article>
         
         <article class="function" data-name="div">
            <h2>div</h2>
            <hr />
            
            <p>div returns a/b rounded to the nearest integer, instead of rounded to zero.</p>
            
            <pre><code>func div(a int32, b int32) int32</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init(s huffmanSpec)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="flush">
            <h2>flush</h2>
            <hr />
            
            <pre><code>func flush()</code></pre>
         </article>
         
         <article class="function" data-name="write">
            <h2>write</h2>
            <hr />
            
            <pre><code>func write(p []byte)</code></pre>
         </article>
         
         <article class="function" data-name="writeByte">
            <h2>writeByte</h2>
            <hr />
            
            <pre><code>func writeByte(b byte)</code></pre>
         </article>
         
         <article class="function" data-name="emit">
            <h2>emit</h2>
            <hr />
            
            <p>emit emits the least significant nBits bits of bits to the bit-stream.
The precondition is bits < 1<<nBits && nBits <= 16.</p>
            
            <pre><code>func emit(bits uint32, nBits uint32)</code></pre>
         </article>
         
         <article class="function" data-name="emitHuff">
            <h2>emitHuff</h2>
            <hr />
            
            <p>emitHuff emits the given value with the given Huffman encoder.</p>
            
            <pre><code>func emitHuff(h huffIndex, value int32)</code></pre>
         </article>
         
         <article class="function" data-name="emitHuffRLE">
            <h2>emitHuffRLE</h2>
            <hr />
            
            <p>emitHuffRLE emits a run of runLength copies of value encoded with the given
Huffman encoder.</p>
            
            <pre><code>func emitHuffRLE(h huffIndex, runLength int32, value int32)</code></pre>
         </article>
         
         <article class="function" data-name="writeMarkerHeader">
            <h2>writeMarkerHeader</h2>
            <hr />
            
            <p>writeMarkerHeader writes the header for a marker with the given length.</p>
            
            <pre><code>func writeMarkerHeader(marker uint8, markerlen int)</code></pre>
         </article>
         
         <article class="function" data-name="writeDQT">
            <h2>writeDQT</h2>
            <hr />
            
            <p>writeDQT writes the Define Quantization Table marker.</p>
            
            <pre><code>func writeDQT()</code></pre>
         </article>
         
         <article class="function" data-name="writeSOF0">
            <h2>writeSOF0</h2>
            <hr />
            
            <p>writeSOF0 writes the Start Of Frame (Baseline Sequential) marker.</p>
            
            <pre><code>func writeSOF0(size image.Point, nComponent int)</code></pre>
         </article>
         
         <article class="function" data-name="writeDHT">
            <h2>writeDHT</h2>
            <hr />
            
            <p>writeDHT writes the Define Huffman Table marker.</p>
            
            <pre><code>func writeDHT(nComponent int)</code></pre>
         </article>
         
         <article class="function" data-name="writeBlock">
            <h2>writeBlock</h2>
            <hr />
            
            <p>writeBlock writes a block of pixel data using the given quantization table,
returning the post-quantized DC value of the DCT-transformed block. b is in
natural (not zig-zag) order.</p>
            
            <pre><code>func writeBlock(b *block, q quantIndex, prevDC int32) int32</code></pre>
         </article>
         
         <article class="function" data-name="toYCbCr">
            <h2>toYCbCr</h2>
            <hr />
            
            <p>toYCbCr converts the 8x8 region of m whose top-left corner is p to its
YCbCr values.</p>
            
            <pre><code>func toYCbCr(m image.Image, p image.Point, yBlock *block, cbBlock *block, crBlock *block)</code></pre>
         </article>
         
         <article class="function" data-name="grayToY">
            <h2>grayToY</h2>
            <hr />
            
            <p>grayToY stores the 8x8 region of m whose top-left corner is p in yBlock.</p>
            
            <pre><code>func grayToY(m *image.Gray, p image.Point, yBlock *block)</code></pre>
         </article>
         
         <article class="function" data-name="rgbaToYCbCr">
            <h2>rgbaToYCbCr</h2>
            <hr />
            
            <p>rgbaToYCbCr is a specialized version of toYCbCr for image.RGBA images.</p>
            
            <pre><code>func rgbaToYCbCr(m *image.RGBA, p image.Point, yBlock *block, cbBlock *block, crBlock *block)</code></pre>
         </article>
         
         <article class="function" data-name="yCbCrToYCbCr">
            <h2>yCbCrToYCbCr</h2>
            <hr />
            
            <p>yCbCrToYCbCr is a specialized version of toYCbCr for image.YCbCr images.</p>
            
            <pre><code>func yCbCrToYCbCr(m *image.YCbCr, p image.Point, yBlock *block, cbBlock *block, crBlock *block)</code></pre>
         </article>
         
         <article class="function" data-name="scale">
            <h2>scale</h2>
            <hr />
            
            <p>scale scales the 16x16 region represented by the 4 src blocks to the 8x8
dst block.</p>
            
            <pre><code>func scale(dst *block, src *[]block)</code></pre>
         </article>
         
         <article class="function" data-name="writeSOS">
            <h2>writeSOS</h2>
            <hr />
            
            <p>writeSOS writes the StartOfScan marker.</p>
            
            <pre><code>func writeSOS(m image.Image)</code></pre>
         </article>
         
         <article class="function" data-name="Encode">
            <h2>Encode</h2>
            <hr />
            
            <p>Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given
options. Default parameters are used if a nil *[Options] is passed.</p>
            
            <pre><code>func Encode(w io.Writer, m image.Image, o *Options) error</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
