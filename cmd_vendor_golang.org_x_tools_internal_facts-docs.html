<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - facts</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                 
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>facts</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"bytes"
"encoding/gob"
"fmt"
"go/types"
"io"
"log"
"reflect"
"sort"
"sync"
"golang.org/x/tools/go/analysis"
"golang.org/x/tools/go/types/objectpath"
"go/types"
"golang.org/x/tools/internal/aliases"
"golang.org/x/tools/internal/typesinternal"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="debug" data-name="debug">
               <h3>
                  debug 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#debug" class="anchor" title="Link to debug">#</a>
               </h3>
               
               <pre><code>const debug = false</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="GetPackageFunc" data-name="GetPackageFunc">
               <h3>
                  GetPackageFunc
                  <span class="badge type-badge">type</span>
                  <a href="#GetPackageFunc" class="anchor" title="Link to GetPackageFunc">#</a>
               </h3>
               
               <p>A GetPackageFunc function returns the package denoted by a package path.</p>
               
               <pre><code>type GetPackageFunc func(pkgPath string) *types.Package</code></pre>
            </article>
            
         </section>
           
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="Decoder" data-name="Decoder">
               <h3>
                  Decoder
                  <span class="badge">struct</span>
                  <a href="#Decoder" class="anchor" title="Link to Decoder">#</a>
               </h3>
               
               <p>A Decoder decodes the facts from the direct imports of the package
provided to NewEncoder. A single decoder may be used to decode
multiple fact sets (e.g. each for a different set of fact types)
for the same package. Each call to Decode returns an independent
fact set.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Decoder struct {
pkg *types.Package
getPackage GetPackageFunc
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="Set" data-name="Set">
               <h3>
                  Set
                  <span class="badge">struct</span>
                  <a href="#Set" class="anchor" title="Link to Set">#</a>
               </h3>
               
               <p>A Set is a set of analysis.Facts.
Decode creates a Set of facts by reading from the imports of a given
package, and Encode writes out the set. Between these operation,
the Import and Export methods will query and update the set.
All of Set's methods except String are safe to call concurrently.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type Set struct {
pkg *types.Package
mu sync.Mutex
m map[key]analysis.Fact
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="gobFact" data-name="gobFact">
               <h3>
                  gobFact
                  <span class="badge">struct</span>
                  <a href="#gobFact" class="anchor" title="Link to gobFact">#</a>
               </h3>
               
               <p>gobFact is the Gob declaration of a serialized fact.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gobFact struct {
PkgPath string
Object objectpath.Path
Fact analysis.Fact
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="key" data-name="key">
               <h3>
                  key
                  <span class="badge">struct</span>
                  <a href="#key" class="anchor" title="Link to key">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type key struct {
pkg *types.Package
obj types.Object
t reflect.Type
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="AllObjectFacts" data-name="AllObjectFacts">
               <h3>
                  AllObjectFacts 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AllObjectFacts" class="anchor" title="Link to AllObjectFacts">#</a>
               </h3>
               
               <pre><code>func (s *Set) AllObjectFacts(filter map[reflect.Type]bool) []analysis.ObjectFact</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="AllPackageFacts" data-name="AllPackageFacts">
               <h3>
                  AllPackageFacts 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#AllPackageFacts" class="anchor" title="Link to AllPackageFacts">#</a>
               </h3>
               
               <pre><code>func (s *Set) AllPackageFacts(filter map[reflect.Type]bool) []analysis.PackageFact</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Decode" data-name="Decode">
               <h3>
                  Decode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Decode" class="anchor" title="Link to Decode">#</a>
               </h3>
               
               <p>Decode decodes all the facts relevant to the analysis of package
pkgPath. The read function reads serialized fact data from an external
source for one of pkg's direct imports, identified by package path.
The empty file is a valid encoding of an empty fact set.
It is the caller's responsibility to call gob.Register on all
necessary fact types.
Concurrent calls to Decode are safe, so long as the
[GetPackageFunc] (if any) is also concurrency-safe.</p>
               
               <pre><code>func (d *Decoder) Decode(read func(pkgPath string) ([]byte, error)) (*Set, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Encode" data-name="Encode">
               <h3>
                  Encode 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Encode" class="anchor" title="Link to Encode">#</a>
               </h3>
               
               <p>Encode encodes a set of facts to a memory buffer.
It may fail if one of the Facts could not be gob-encoded, but this is
a sign of a bug in an Analyzer.</p>
               
               <pre><code>func (s *Set) Encode() []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExportObjectFact" data-name="ExportObjectFact">
               <h3>
                  ExportObjectFact 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ExportObjectFact" class="anchor" title="Link to ExportObjectFact">#</a>
               </h3>
               
               <p>ExportObjectFact implements analysis.Pass.ExportObjectFact.</p>
               
               <pre><code>func (s *Set) ExportObjectFact(obj types.Object, fact analysis.Fact)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ExportPackageFact" data-name="ExportPackageFact">
               <h3>
                  ExportPackageFact 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ExportPackageFact" class="anchor" title="Link to ExportPackageFact">#</a>
               </h3>
               
               <p>ExportPackageFact implements analysis.Pass.ExportPackageFact.</p>
               
               <pre><code>func (s *Set) ExportPackageFact(fact analysis.Fact)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportObjectFact" data-name="ImportObjectFact">
               <h3>
                  ImportObjectFact 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportObjectFact" class="anchor" title="Link to ImportObjectFact">#</a>
               </h3>
               
               <p>ImportObjectFact implements analysis.Pass.ImportObjectFact.</p>
               
               <pre><code>func (s *Set) ImportObjectFact(obj types.Object, ptr analysis.Fact) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ImportPackageFact" data-name="ImportPackageFact">
               <h3>
                  ImportPackageFact 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ImportPackageFact" class="anchor" title="Link to ImportPackageFact">#</a>
               </h3>
               
               <p>ImportPackageFact implements analysis.Pass.ImportPackageFact.</p>
               
               <pre><code>func (s *Set) ImportPackageFact(pkg *types.Package, ptr analysis.Fact) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewDecoder" data-name="NewDecoder">
               <h3>
                  NewDecoder 
                  <span class="badge">function</span>
                  
                  <a href="#NewDecoder" class="anchor" title="Link to NewDecoder">#</a>
               </h3>
               
               <p>NewDecoder returns a fact decoder for the specified package.
It uses a brute-force recursive approach to enumerate all objects
defined by dependencies of pkg, so that it can learn the set of
package paths that may be mentioned in the fact encoding. This does
not scale well; use [NewDecoderFunc] where possible.</p>
               
               <pre><code>func NewDecoder(pkg *types.Package) *Decoder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewDecoderFunc" data-name="NewDecoderFunc">
               <h3>
                  NewDecoderFunc 
                  <span class="badge">function</span>
                  
                  <a href="#NewDecoderFunc" class="anchor" title="Link to NewDecoderFunc">#</a>
               </h3>
               
               <p>NewDecoderFunc returns a fact decoder for the specified package.
It calls the getPackage function for the package path string of
each dependency (perhaps indirect) that it encounters in the
encoding. If the function returns nil, the fact is discarded.
This function is preferred over [NewDecoder] when the client is
capable of efficient look-up of packages by package path.</p>
               
               <pre><code>func NewDecoderFunc(pkg *types.Package, getPackage GetPackageFunc) *Decoder</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <p>String is provided only for debugging, and must not be called
concurrent with any Import/Export method.</p>
               
               <pre><code>func (s *Set) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="importMap" data-name="importMap">
               <h3>
                  importMap 
                  <span class="badge">function</span>
                  
                  <a href="#importMap" class="anchor" title="Link to importMap">#</a>
               </h3>
               
               <p>importMap computes the import map for a package by traversing the
entire exported API each of its imports.
This is a workaround for the fact that we cannot access the map used
internally by the types.Importer returned by go/importer. The entries
in this map are the packages and objects that may be relevant to the
current analysis unit.
Packages in the map that are only indirectly imported may be
incomplete (!pkg.Complete()).
This function scales very poorly with packages' transitive object
references, which can be more than a million for each package near
the top of a large project. (This was a significant contributor to
#60621.)
TODO(adonovan): opt: compute this information more efficiently
by obtaining it from the internals of the gcexportdata decoder.</p>
               
               <pre><code>func importMap(imports []*types.Package) map[string]*types.Package</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>