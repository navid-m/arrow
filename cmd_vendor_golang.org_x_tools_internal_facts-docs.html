<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - facts</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>facts</code>
         </h1>
         <hr />
         
         <article class="global" data-name="debug">
            <h2>debug</h2>
            <hr />
            
            <pre><code>debug</code></pre>
         </article>
          
         <article class="struct" data-name="Set">
            <h2>type Set struct</h2>
            <hr />
            
            <p>A Set is a set of analysis.Facts.

Decode creates a Set of facts by reading from the imports of a given
package, and Encode writes out the set. Between these operation,
the Import and Export methods will query and update the set.

All of Set's methods except String are safe to call concurrently.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkg *types.Package
mu sync.Mutex
m *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="key">
            <h2>type key struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkg *types.Package
obj types.Object
t reflect.Type</code></pre>
         </article>
         
         <article class="struct" data-name="gobFact">
            <h2>type gobFact struct</h2>
            <hr />
            
            <p>gobFact is the Gob declaration of a serialized fact.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">PkgPath string
Object objectpath.Path
Fact analysis.Fact</code></pre>
         </article>
         
         <article class="struct" data-name="Decoder">
            <h2>type Decoder struct</h2>
            <hr />
            
            <p>A Decoder decodes the facts from the direct imports of the package
provided to NewEncoder. A single decoder may be used to decode
multiple fact sets (e.g. each for a different set of fact types)
for the same package. Each call to Decode returns an independent
fact set.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">pkg *types.Package
getPackage GetPackageFunc</code></pre>
         </article>
          
         <article class="function" data-name="ImportObjectFact">
            <h2>ImportObjectFact</h2>
            <hr />
            
            <p>ImportObjectFact implements analysis.Pass.ImportObjectFact.</p>
            
            <pre><code>func ImportObjectFact(obj types.Object, ptr analysis.Fact) bool</code></pre>
         </article>
         
         <article class="function" data-name="ExportObjectFact">
            <h2>ExportObjectFact</h2>
            <hr />
            
            <p>ExportObjectFact implements analysis.Pass.ExportObjectFact.</p>
            
            <pre><code>func ExportObjectFact(obj types.Object, fact analysis.Fact)</code></pre>
         </article>
         
         <article class="function" data-name="AllObjectFacts">
            <h2>AllObjectFacts</h2>
            <hr />
            
            <pre><code>func AllObjectFacts(filter *ast.MapType) []analysis.ObjectFact</code></pre>
         </article>
         
         <article class="function" data-name="ImportPackageFact">
            <h2>ImportPackageFact</h2>
            <hr />
            
            <p>ImportPackageFact implements analysis.Pass.ImportPackageFact.</p>
            
            <pre><code>func ImportPackageFact(pkg *types.Package, ptr analysis.Fact) bool</code></pre>
         </article>
         
         <article class="function" data-name="ExportPackageFact">
            <h2>ExportPackageFact</h2>
            <hr />
            
            <p>ExportPackageFact implements analysis.Pass.ExportPackageFact.</p>
            
            <pre><code>func ExportPackageFact(fact analysis.Fact)</code></pre>
         </article>
         
         <article class="function" data-name="AllPackageFacts">
            <h2>AllPackageFacts</h2>
            <hr />
            
            <pre><code>func AllPackageFacts(filter *ast.MapType) []analysis.PackageFact</code></pre>
         </article>
         
         <article class="function" data-name="NewDecoder">
            <h2>NewDecoder</h2>
            <hr />
            
            <p>NewDecoder returns a fact decoder for the specified package.

It uses a brute-force recursive approach to enumerate all objects
defined by dependencies of pkg, so that it can learn the set of
package paths that may be mentioned in the fact encoding. This does
not scale well; use [NewDecoderFunc] where possible.</p>
            
            <pre><code>func NewDecoder(pkg *types.Package) *Decoder</code></pre>
         </article>
         
         <article class="function" data-name="NewDecoderFunc">
            <h2>NewDecoderFunc</h2>
            <hr />
            
            <p>NewDecoderFunc returns a fact decoder for the specified package.

It calls the getPackage function for the package path string of
each dependency (perhaps indirect) that it encounters in the
encoding. If the function returns nil, the fact is discarded.

This function is preferred over [NewDecoder] when the client is
capable of efficient look-up of packages by package path.</p>
            
            <pre><code>func NewDecoderFunc(pkg *types.Package, getPackage GetPackageFunc) *Decoder</code></pre>
         </article>
         
         <article class="function" data-name="Decode">
            <h2>Decode</h2>
            <hr />
            
            <p>Decode decodes all the facts relevant to the analysis of package
pkgPath. The read function reads serialized fact data from an external
source for one of pkg's direct imports, identified by package path.
The empty file is a valid encoding of an empty fact set.

It is the caller's responsibility to call gob.Register on all
necessary fact types.

Concurrent calls to Decode are safe, so long as the
[GetPackageFunc] (if any) is also concurrency-safe.</p>
            
            <pre><code>func Decode(read func) (*Set, error)</code></pre>
         </article>
         
         <article class="function" data-name="Encode">
            <h2>Encode</h2>
            <hr />
            
            <p>Encode encodes a set of facts to a memory buffer.

It may fail if one of the Facts could not be gob-encoded, but this is
a sign of a bug in an Analyzer.</p>
            
            <pre><code>func Encode() []byte</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <p>String is provided only for debugging, and must not be called
concurrent with any Import/Export method.</p>
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="importMap">
            <h2>importMap</h2>
            <hr />
            
            <p>importMap computes the import map for a package by traversing the
entire exported API each of its imports.

This is a workaround for the fact that we cannot access the map used
internally by the types.Importer returned by go/importer. The entries
in this map are the packages and objects that may be relevant to the
current analysis unit.

Packages in the map that are only indirectly imported may be
incomplete (!pkg.Complete()).

This function scales very poorly with packages' transitive object
references, which can be more than a million for each package near
the top of a large project. (This was a significant contributor to
#60621.)
TODO(adonovan): opt: compute this information more efficiently
by obtaining it from the internals of the gcexportdata decoder.</p>
            
            <pre><code>func importMap(imports []*types.Package) *ast.MapType</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
