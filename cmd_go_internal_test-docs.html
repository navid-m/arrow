<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - test</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>test</code>
         </h1>
         <hr />
         
         <article class="global" data-name="passFlagToTest">
            <h2>passFlagToTest</h2>
            <hr />
            
            <p>passFlagToTest contains the flags that should be forwarded to
the test binary with the prefix "test.".</p>
            
            <pre><code>passFlagToTest</code></pre>
         </article>
         
         <article class="global" data-name="passAnalyzersToVet">
            <h2>passAnalyzersToVet</h2>
            <hr />
            
            <pre><code>passAnalyzersToVet</code></pre>
         </article>
         
         <article class="global" data-name="testUsage">
            <h2>testUsage</h2>
            <hr />
            
            <pre><code>testUsage</code></pre>
         </article>
         
         <article class="global" data-name="CmdTest">
            <h2>CmdTest</h2>
            <hr />
            
            <pre><code>CmdTest</code></pre>
         </article>
         
         <article class="global" data-name="HelpTestflag">
            <h2>HelpTestflag</h2>
            <hr />
            
            <pre><code>HelpTestflag</code></pre>
         </article>
         
         <article class="global" data-name="HelpTestfunc">
            <h2>HelpTestfunc</h2>
            <hr />
            
            <pre><code>HelpTestfunc</code></pre>
         </article>
         
         <article class="global" data-name="testBench">
            <h2>testBench</h2>
            <hr />
            
            <pre><code>testBench string</code></pre>
         </article>
         
         <article class="global" data-name="testC">
            <h2>testC</h2>
            <hr />
            
            <pre><code>testC bool</code></pre>
         </article>
         
         <article class="global" data-name="testCoverPkgs">
            <h2>testCoverPkgs</h2>
            <hr />
            
            <pre><code>testCoverPkgs []*load.Package</code></pre>
         </article>
         
         <article class="global" data-name="testCoverProfile">
            <h2>testCoverProfile</h2>
            <hr />
            
            <pre><code>testCoverProfile string</code></pre>
         </article>
         
         <article class="global" data-name="testFailFast">
            <h2>testFailFast</h2>
            <hr />
            
            <pre><code>testFailFast bool</code></pre>
         </article>
         
         <article class="global" data-name="testFuzz">
            <h2>testFuzz</h2>
            <hr />
            
            <pre><code>testFuzz string</code></pre>
         </article>
         
         <article class="global" data-name="testJSON">
            <h2>testJSON</h2>
            <hr />
            
            <pre><code>testJSON bool</code></pre>
         </article>
         
         <article class="global" data-name="testList">
            <h2>testList</h2>
            <hr />
            
            <pre><code>testList string</code></pre>
         </article>
         
         <article class="global" data-name="testO">
            <h2>testO</h2>
            <hr />
            
            <pre><code>testO string</code></pre>
         </article>
         
         <article class="global" data-name="testOutputDir">
            <h2>testOutputDir</h2>
            <hr />
            
            <pre><code>testOutputDir outputdirFlag</code></pre>
         </article>
         
         <article class="global" data-name="testShuffle">
            <h2>testShuffle</h2>
            <hr />
            
            <pre><code>testShuffle shuffleFlag</code></pre>
         </article>
         
         <article class="global" data-name="testTimeout">
            <h2>testTimeout</h2>
            <hr />
            
            <pre><code>testTimeout time.Duration</code></pre>
         </article>
         
         <article class="global" data-name="testV">
            <h2>testV</h2>
            <hr />
            
            <pre><code>testV testVFlag</code></pre>
         </article>
         
         <article class="global" data-name="testVet">
            <h2>testVet</h2>
            <hr />
            
            <pre><code>testVet</code></pre>
         </article>
         
         <article class="global" data-name="testArgs">
            <h2>testArgs</h2>
            <hr />
            
            <pre><code>testArgs []string</code></pre>
         </article>
         
         <article class="global" data-name="pkgArgs">
            <h2>pkgArgs</h2>
            <hr />
            
            <pre><code>pkgArgs []string</code></pre>
         </article>
         
         <article class="global" data-name="pkgs">
            <h2>pkgs</h2>
            <hr />
            
            <pre><code>pkgs []*load.Package</code></pre>
         </article>
         
         <article class="global" data-name="testHelp">
            <h2>testHelp</h2>
            <hr />
            
            <pre><code>testHelp bool</code></pre>
         </article>
         
         <article class="global" data-name="testKillTimeout">
            <h2>testKillTimeout</h2>
            <hr />
            
            <pre><code>testKillTimeout</code></pre>
         </article>
         
         <article class="global" data-name="testWaitDelay">
            <h2>testWaitDelay</h2>
            <hr />
            
            <pre><code>testWaitDelay time.Duration</code></pre>
         </article>
         
         <article class="global" data-name="testCacheExpire">
            <h2>testCacheExpire</h2>
            <hr />
            
            <pre><code>testCacheExpire time.Time</code></pre>
         </article>
         
         <article class="global" data-name="testShouldFailFast">
            <h2>testShouldFailFast</h2>
            <hr />
            
            <pre><code>testShouldFailFast atomic.Bool</code></pre>
         </article>
         
         <article class="global" data-name="testBlockProfile">
            <h2>testBlockProfile</h2>
            <hr />
            
            <pre><code>testBlockProfile string</code></pre>
         </article>
         
         <article class="global" data-name="testCPUProfile">
            <h2>testCPUProfile</h2>
            <hr />
            
            <pre><code>testCPUProfile string</code></pre>
         </article>
         
         <article class="global" data-name="testMemProfile">
            <h2>testMemProfile</h2>
            <hr />
            
            <pre><code>testMemProfile string</code></pre>
         </article>
         
         <article class="global" data-name="testMutexProfile">
            <h2>testMutexProfile</h2>
            <hr />
            
            <pre><code>testMutexProfile string</code></pre>
         </article>
         
         <article class="global" data-name="testTrace">
            <h2>testTrace</h2>
            <hr />
            
            <pre><code>testTrace string</code></pre>
         </article>
         
         <article class="global" data-name="testODir">
            <h2>testODir</h2>
            <hr />
            
            <pre><code>testODir</code></pre>
         </article>
         
         <article class="global" data-name="defaultVetFlags">
            <h2>defaultVetFlags</h2>
            <hr />
            
            <pre><code>defaultVetFlags</code></pre>
         </article>
         
         <article class="global" data-name="windowsBadWords">
            <h2>windowsBadWords</h2>
            <hr />
            
            <pre><code>windowsBadWords</code></pre>
         </article>
         
         <article class="global" data-name="noTestsToRun">
            <h2>noTestsToRun</h2>
            <hr />
            
            <pre><code>noTestsToRun</code></pre>
         </article>
         
         <article class="global" data-name="noFuzzTestsToFuzz">
            <h2>noFuzzTestsToFuzz</h2>
            <hr />
            
            <pre><code>noFuzzTestsToFuzz</code></pre>
         </article>
         
         <article class="global" data-name="tooManyFuzzTestsToFuzz">
            <h2>tooManyFuzzTestsToFuzz</h2>
            <hr />
            
            <pre><code>tooManyFuzzTestsToFuzz</code></pre>
         </article>
         
         <article class="global" data-name="stdoutMu">
            <h2>stdoutMu</h2>
            <hr />
            
            <p>stdoutMu and lockedStdout provide a locked standard output
that guarantees never to interlace writes from multiple
goroutines, so that we can have multiple JSON streams writing
to a lockedStdout simultaneously and know that events will
still be intelligible.</p>
            
            <pre><code>stdoutMu sync.Mutex</code></pre>
         </article>
         
         <article class="global" data-name="errBadTestInputs">
            <h2>errBadTestInputs</h2>
            <hr />
            
            <pre><code>errBadTestInputs</code></pre>
         </article>
         
         <article class="global" data-name="testlogMagic">
            <h2>testlogMagic</h2>
            <hr />
            
            <pre><code>testlogMagic</code></pre>
         </article>
         
         <article class="global" data-name="modTimeCutoff">
            <h2>modTimeCutoff</h2>
            <hr />
            
            <pre><code>modTimeCutoff</code></pre>
         </article>
         
         <article class="global" data-name="errFileTooNew">
            <h2>errFileTooNew</h2>
            <hr />
            
            <pre><code>errFileTooNew</code></pre>
         </article>
         
         <article class="global" data-name="gotestjsonbuildtext">
            <h2>gotestjsonbuildtext</h2>
            <hr />
            
            <pre><code>gotestjsonbuildtext</code></pre>
         </article>
         
         <article class="global" data-name="coverMerge">
            <h2>coverMerge</h2>
            <hr />
            
            <pre><code>coverMerge *ast.StructType</code></pre>
         </article>
          
         <article class="struct" data-name="testVFlag">
            <h2>type testVFlag struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">on bool
json bool</code></pre>
         </article>
         
         <article class="struct" data-name="runTestActor">
            <h2>type runTestActor struct</h2>
            <hr />
            
            <p>runTestActor is the actor for running a test.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">c runCache
writeCoverMetaAct *work.Action
prev *ast.ChanType
next *ast.ChanType</code></pre>
         </article>
         
         <article class="struct" data-name="runCache">
            <h2>type runCache struct</h2>
            <hr />
            
            <p>runCache is the cache for running a single test.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">disableCache bool
buf *bytes.Buffer
id1 cache.ActionID
id2 cache.ActionID</code></pre>
         </article>
         
         <article class="struct" data-name="lockedStdout">
            <h2>type lockedStdout struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="outputdirFlag">
            <h2>type outputdirFlag struct</h2>
            <hr />
            
            <p>outputdirFlag implements the -outputdir flag.
It interprets an empty value as the working directory of the 'go' command.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">abs string</code></pre>
         </article>
         
         <article class="struct" data-name="vetFlag">
            <h2>type vetFlag struct</h2>
            <hr />
            
            <p>vetFlag implements the special parsing logic for the -vet flag:
a comma-separated list, with distinguished values "all" and
"off", plus a boolean tracking whether it was set explicitly.

"all" is encoded as vetFlag{true, false, nil}, since it will
pass no flags to the vet binary, and by default, it runs all
analyzers.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">explicit bool
off bool
flags []string</code></pre>
         </article>
         
         <article class="struct" data-name="shuffleFlag">
            <h2>type shuffleFlag struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">on bool
seed *int64</code></pre>
         </article>
          
         <article class="function" data-name="TestMain">
            <h2>TestMain</h2>
            <hr />
            
            <pre><code>func TestMain(m *testing.M)</code></pre>
         </article>
         
         <article class="function" data-name="TestPassFlagToTest">
            <h2>TestPassFlagToTest</h2>
            <hr />
            
            <pre><code>func TestPassFlagToTest(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="TestPassAnalyzersToVet">
            <h2>TestPassAnalyzersToVet</h2>
            <hr />
            
            <pre><code>func TestPassAnalyzersToVet(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <p>Break init loop.</p>
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="IsBoolFlag">
            <h2>IsBoolFlag</h2>
            <hr />
            
            <pre><code>func IsBoolFlag() bool</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(arg string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="testProfile">
            <h2>testProfile</h2>
            <hr />
            
            <p>testProfile returns the name of an arbitrary single-package profiling flag
that is set, if any.</p>
            
            <pre><code>func testProfile() string</code></pre>
         </article>
         
         <article class="function" data-name="testNeedBinary">
            <h2>testNeedBinary</h2>
            <hr />
            
            <p>testNeedBinary reports whether the test needs to keep the binary around.</p>
            
            <pre><code>func testNeedBinary() bool</code></pre>
         </article>
         
         <article class="function" data-name="testShowPass">
            <h2>testShowPass</h2>
            <hr />
            
            <p>testShowPass reports whether the output for a passing test should be shown.</p>
            
            <pre><code>func testShowPass() bool</code></pre>
         </article>
         
         <article class="function" data-name="runTest">
            <h2>runTest</h2>
            <hr />
            
            <pre><code>func runTest(ctx context.Context, cmd *base.Command, args []string)</code></pre>
         </article>
         
         <article class="function" data-name="builderTest">
            <h2>builderTest</h2>
            <hr />
            
            <pre><code>func builderTest(b *work.Builder, ctx context.Context, pkgOpts load.PackageOpts, p *load.Package, imported bool, writeCoverMetaAct *work.Action) (buildAction *work.Action, runAction *work.Action, printAction *work.Action, perr *load.Package, err error)</code></pre>
         </article>
         
         <article class="function" data-name="addTestVet">
            <h2>addTestVet</h2>
            <hr />
            
            <pre><code>func addTestVet(b *work.Builder, p *load.Package, runAction *work.Action, installAction *work.Action)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(b []byte) (int, error)</code></pre>
         </article>
         
         <article class="function" data-name="Act">
            <h2>Act</h2>
            <hr />
            
            <pre><code>func Act(b *work.Builder, ctx context.Context, a *work.Action) error</code></pre>
         </article>
         
         <article class="function" data-name="tryCache">
            <h2>tryCache</h2>
            <hr />
            
            <p>tryCache is called just before the link attempt,
to see if the test result is cached and therefore the link is unneeded.
It reports whether the result can be satisfied from cache.</p>
            
            <pre><code>func tryCache(b *work.Builder, a *work.Action) bool</code></pre>
         </article>
         
         <article class="function" data-name="tryCacheWithID">
            <h2>tryCacheWithID</h2>
            <hr />
            
            <pre><code>func tryCacheWithID(b *work.Builder, a *work.Action, id string) bool</code></pre>
         </article>
         
         <article class="function" data-name="computeTestInputsID">
            <h2>computeTestInputsID</h2>
            <hr />
            
            <p>computeTestInputsID computes the "test inputs ID"
(see comment in tryCacheWithID above) for the
test log.</p>
            
            <pre><code>func computeTestInputsID(a *work.Action, testlog []byte) (cache.ActionID, error)</code></pre>
         </article>
         
         <article class="function" data-name="hashGetenv">
            <h2>hashGetenv</h2>
            <hr />
            
            <pre><code>func hashGetenv(name string) cache.ActionID</code></pre>
         </article>
         
         <article class="function" data-name="hashOpen">
            <h2>hashOpen</h2>
            <hr />
            
            <pre><code>func hashOpen(name string) (cache.ActionID, error)</code></pre>
         </article>
         
         <article class="function" data-name="hashStat">
            <h2>hashStat</h2>
            <hr />
            
            <pre><code>func hashStat(name string) cache.ActionID</code></pre>
         </article>
         
         <article class="function" data-name="hashWriteStat">
            <h2>hashWriteStat</h2>
            <hr />
            
            <pre><code>func hashWriteStat(h io.Writer, info fs.FileInfo)</code></pre>
         </article>
         
         <article class="function" data-name="testAndInputKey">
            <h2>testAndInputKey</h2>
            <hr />
            
            <p>testAndInputKey returns the actual cache key for the pair (testID, testInputsID).</p>
            
            <pre><code>func testAndInputKey(testID cache.ActionID, testInputsID cache.ActionID) cache.ActionID</code></pre>
         </article>
         
         <article class="function" data-name="saveOutput">
            <h2>saveOutput</h2>
            <hr />
            
            <pre><code>func saveOutput(a *work.Action)</code></pre>
         </article>
         
         <article class="function" data-name="coveragePercentage">
            <h2>coveragePercentage</h2>
            <hr />
            
            <p>coveragePercentage returns the coverage results (if enabled) for the
test. It uncovers the data by scanning the output from the test run.</p>
            
            <pre><code>func coveragePercentage(out []byte) string</code></pre>
         </article>
         
         <article class="function" data-name="builderCleanTest">
            <h2>builderCleanTest</h2>
            <hr />
            
            <p>builderCleanTest is the action for cleaning up after a test.</p>
            
            <pre><code>func builderCleanTest(b *work.Builder, ctx context.Context, a *work.Action) error</code></pre>
         </article>
         
         <article class="function" data-name="builderPrintTest">
            <h2>builderPrintTest</h2>
            <hr />
            
            <p>builderPrintTest is the action for printing a test result.</p>
            
            <pre><code>func builderPrintTest(b *work.Builder, ctx context.Context, a *work.Action) error</code></pre>
         </article>
         
         <article class="function" data-name="printExitStatus">
            <h2>printExitStatus</h2>
            <hr />
            
            <p>printExitStatus is the action for printing the final exit status.
If we are running multiple test targets, print a final "FAIL"
in case a failure in an early package has already scrolled
off of the user's terminal.
(See https://golang.org/issue/30507#issuecomment-470593235.)

In JSON mode, we need to maintain valid JSON output and
we assume that the test output is being parsed by a tool
anyway, so the failure will not be missed and would be
awkward to try to wedge into the JSON stream.

In fuzz mode, we only allow a single package for now
(see CL 350156 and https://golang.org/issue/46312),
so there is no possibility of scrolling off and no need
to print the final status.</p>
            
            <pre><code>func printExitStatus(b *work.Builder, ctx context.Context, a *work.Action) error</code></pre>
         </article>
         
         <article class="function" data-name="testBinaryName">
            <h2>testBinaryName</h2>
            <hr />
            
            <p>testBinaryName can be used to create name for test binary executable.
Use last element of import path, not package name.
They differ when package name is "main".
But if the import path is "command-line-arguments",
like it is during 'go run', use the package name.</p>
            
            <pre><code>func testBinaryName(p *load.Package) string</code></pre>
         </article>
         
         <article class="function" data-name="init">
            <h2>init</h2>
            <hr />
            
            <pre><code>func init()</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(value string) err error</code></pre>
         </article>
         
         <article class="function" data-name="getAbs">
            <h2>getAbs</h2>
            <hr />
            
            <pre><code>func getAbs() string</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(value string) error</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
         <article class="function" data-name="Set">
            <h2>Set</h2>
            <hr />
            
            <pre><code>func Set(value string) error</code></pre>
         </article>
         
         <article class="function" data-name="testFlags">
            <h2>testFlags</h2>
            <hr />
            
            <p>testFlags processes the command line, grabbing -x and -c, rewriting known flags
to have "test" before them, and reading the command line for the test binary.
Unfortunately for us, we need to do our own flag processing because go test
grabs some flags but otherwise its command line is just a holding place for
pkg.test's arguments.
We allow known flags both before and after the package name list,
to allow both

	go test fmt -custom-flag-for-fmt-test
	go test -x math</p>
            
            <pre><code>func testFlags(args []string) (packageNames []string, passToTest []string)</code></pre>
         </article>
         
         <article class="function" data-name="exitWithUsage">
            <h2>exitWithUsage</h2>
            <hr />
            
            <pre><code>func exitWithUsage()</code></pre>
         </article>
         
         <article class="function" data-name="initCoverProfile">
            <h2>initCoverProfile</h2>
            <hr />
            
            <p>initCoverProfile initializes the test coverage profile.
It must be run before any calls to mergeCoverProfile or closeCoverProfile.
Using this function clears the profile in case it existed from a previous run,
or in case it doesn't exist and the test is going to fail to create it (or not run).</p>
            
            <pre><code>func initCoverProfile()</code></pre>
         </article>
         
         <article class="function" data-name="mergeCoverProfile">
            <h2>mergeCoverProfile</h2>
            <hr />
            
            <p>mergeCoverProfile merges file into the profile stored in testCoverProfile.
It prints any errors it encounters to ew.</p>
            
            <pre><code>func mergeCoverProfile(ew io.Writer, file string)</code></pre>
         </article>
         
         <article class="function" data-name="closeCoverProfile">
            <h2>closeCoverProfile</h2>
            <hr />
            
            <pre><code>func closeCoverProfile()</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
