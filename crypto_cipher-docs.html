<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - cipher</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>
         
      </aside>

      <main>
         <h1>cipher</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports" data-name="imports">
               <pre><code>"bytes"
"crypto/internal/fips140/aes"
"crypto/internal/fips140/alias"
"crypto/internal/fips140only"
"crypto/subtle"
"crypto/internal/fips140/alias"
"crypto/internal/fips140only"
"crypto/subtle"
"bytes"
"crypto/internal/fips140/aes"
"crypto/internal/fips140/alias"
"crypto/internal/fips140only"
"crypto/subtle"
"crypto/internal/fips140/aes"
"crypto/internal/fips140/aes/gcm"
"crypto/internal/fips140/alias"
"crypto/internal/fips140only"
"crypto/subtle"
"errors"
"internal/byteorder"
"io"
"crypto/internal/fips140/alias"
"crypto/internal/fips140only"
"crypto/subtle"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global" data-name="errOpen">
               <h3>
                  errOpen 
                  <span class="badge var-badge">var</span>
                  
               </h3>
               
               <pre><code>var errOpen = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global" data-name="gcmBlockSize">
               <h3>
                  gcmBlockSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gcmBlockSize = 16</code></pre>
            </article>
            
            <article class="global" data-name="gcmMinimumTagSize">
               <h3>
                  gcmMinimumTagSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gcmMinimumTagSize = 12</code></pre>
            </article>
            
            <article class="global" data-name="gcmStandardNonceSize">
               <h3>
                  gcmStandardNonceSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gcmStandardNonceSize = 12</code></pre>
            </article>
            
            <article class="global" data-name="gcmTagSize">
               <h3>
                  gcmTagSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const gcmTagSize = 16</code></pre>
            </article>
            
            <article class="global" data-name="streamBufferSize">
               <h3>
                  streamBufferSize 
                  <span class="badge const-badge">const</span>
                  
               </h3>
               
               <pre><code>const streamBufferSize = 512</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type" data-name="cbcDecrypter">
               <h3>
                  cbcDecrypter
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type cbcDecrypter cbc</code></pre>
            </article>
            
            <article class="type" data-name="cbcEncrypter">
               <h3>
                  cbcEncrypter
                  <span class="badge type-badge">type</span>
               </h3>
               
               <pre><code>type cbcEncrypter cbc</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface" data-name="AEAD">
               <h3>
                  AEAD
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>AEAD is a cipher mode providing authenticated encryption with associated
data. For a description of the methodology, see
https://en.wikipedia.org/wiki/Authenticated_encryption.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type AEAD interface {
NonceSize() int
Overhead() int
Seal(dst []byte, nonce []byte, plaintext []byte, additionalData []byte) []byte
Open(dst []byte, nonce []byte, ciphertext []byte, additionalData []byte) ([]byte, error)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Block">
               <h3>
                  Block
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A Block represents an implementation of block cipher
using a given key. It provides the capability to encrypt
or decrypt individual blocks. The mode implementations
extend that capability to streams of blocks.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Block interface {
BlockSize() int
Encrypt(dst []byte, src []byte)
Decrypt(dst []byte, src []byte)
}</code></pre>
            </article>
            
            <article class="interface" data-name="BlockMode">
               <h3>
                  BlockMode
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A BlockMode represents a block cipher running in a block-based mode (CBC,
ECB etc).</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type BlockMode interface {
BlockSize() int
CryptBlocks(dst []byte, src []byte)
}</code></pre>
            </article>
            
            <article class="interface" data-name="Stream">
               <h3>
                  Stream
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>A Stream represents a stream cipher.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type Stream interface {
XORKeyStream(dst []byte, src []byte)
}</code></pre>
            </article>
            
            <article class="interface" data-name="cbcDecAble">
               <h3>
                  cbcDecAble
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>cbcDecAble is an interface implemented by ciphers that have a specific
optimized implementation of CBC decryption. crypto/aes doesn't use this
anymore, and we'd like to eventually remove it.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type cbcDecAble interface {
NewCBCDecrypter(iv []byte) BlockMode
}</code></pre>
            </article>
            
            <article class="interface" data-name="cbcEncAble">
               <h3>
                  cbcEncAble
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>cbcEncAble is an interface implemented by ciphers that have a specific
optimized implementation of CBC encryption. crypto/aes doesn't use this
anymore, and we'd like to eventually remove it.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type cbcEncAble interface {
NewCBCEncrypter(iv []byte) BlockMode
}</code></pre>
            </article>
            
            <article class="interface" data-name="ctrAble">
               <h3>
                  ctrAble
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>ctrAble is an interface implemented by ciphers that have a specific optimized
implementation of CTR. crypto/aes doesn't use this anymore, and we'd like to
eventually remove it.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type ctrAble interface {
NewCTR(iv []byte) Stream
}</code></pre>
            </article>
            
            <article class="interface" data-name="gcmAble">
               <h3>
                  gcmAble
                  <span class="badge interface-badge">interface</span>
               </h3>
               
               <p>gcmAble is an interface implemented by ciphers that have a specific optimized
implementation of GCM. crypto/aes doesn't use this anymore, and we'd like to
eventually remove it.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type gcmAble interface {
NewGCM(nonceSize int, tagSize int) (AEAD, error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct" data-name="StreamReader">
               <h3>
                  StreamReader
                  <span class="badge">struct</span>
               </h3>
               
               <p>StreamReader wraps a [Stream] into an [io.Reader]. It calls XORKeyStream
to process each slice of data which passes through.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StreamReader struct {
S Stream
R io.Reader
}</code></pre>
            </article>
            
            <article class="struct" data-name="StreamWriter">
               <h3>
                  StreamWriter
                  <span class="badge">struct</span>
               </h3>
               
               <p>StreamWriter wraps a [Stream] into an io.Writer. It calls XORKeyStream
to process each slice of data which passes through. If any [StreamWriter.Write]
call returns short then the StreamWriter is out of sync and must be discarded.
A StreamWriter has no internal buffering; [StreamWriter.Close] does not need
to be called to flush write data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type StreamWriter struct {
S Stream
W io.Writer
Err error
}</code></pre>
            </article>
            
            <article class="struct" data-name="aesCtrWrapper">
               <h3>
                  aesCtrWrapper
                  <span class="badge">struct</span>
               </h3>
               
               <p>aesCtrWrapper hides extra methods from aes.CTR.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type aesCtrWrapper struct {
c *aes.CTR
}</code></pre>
            </article>
            
            <article class="struct" data-name="cbc">
               <h3>
                  cbc
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cbc struct {
b Block
blockSize int
iv []byte
tmp []byte
}</code></pre>
            </article>
            
            <article class="struct" data-name="cfb">
               <h3>
                  cfb
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type cfb struct {
b Block
next []byte
out []byte
outUsed int
decrypt bool
}</code></pre>
            </article>
            
            <article class="struct" data-name="ctr">
               <h3>
                  ctr
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ctr struct {
b Block
ctr []byte
out []byte
outUsed int
}</code></pre>
            </article>
            
            <article class="struct" data-name="gcmFallback">
               <h3>
                  gcmFallback
                  <span class="badge">struct</span>
               </h3>
               
               <p>gcmFallback is only used for non-AES ciphers, which regrettably we
theoretically support. It's a copy of the generic implementation from
crypto/internal/fips140/aes/gcm/gcm_generic.go, refer to that file for more details.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gcmFallback struct {
cipher Block
nonceSize int
tagSize int
}</code></pre>
            </article>
            
            <article class="struct" data-name="gcmWithRandomNonce">
               <h3>
                  gcmWithRandomNonce
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gcmWithRandomNonce struct {
*gcm.GCM
}</code></pre>
            </article>
            
            <article class="struct" data-name="ofb">
               <h3>
                  ofb
                  <span class="badge">struct</span>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type ofb struct {
b Block
cipher []byte
out []byte
outUsed int
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function" data-name="BlockSize">
               <h3>
                  BlockSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *cbcEncrypter) BlockSize() int</code></pre>
            </article>
            
            <article class="function" data-name="BlockSize">
               <h3>
                  BlockSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *cbcDecrypter) BlockSize() int</code></pre>
            </article>
            
            <article class="function" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <p>Close closes the underlying Writer and returns its Close return value, if the Writer
is also an io.Closer. Otherwise it returns nil.</p>
               
               <pre><code>func (w StreamWriter) Close() error</code></pre>
            </article>
            
            <article class="function" data-name="CryptBlocks">
               <h3>
                  CryptBlocks 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *cbcDecrypter) CryptBlocks(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function" data-name="CryptBlocks">
               <h3>
                  CryptBlocks 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *cbcEncrypter) CryptBlocks(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function" data-name="NewCBCDecrypter">
               <h3>
                  NewCBCDecrypter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining
mode, using the given Block. The length of iv must be the same as the
Block's block size and must match the iv used to encrypt the data.</p>
               
               <pre><code>func NewCBCDecrypter(b Block, iv []byte) BlockMode</code></pre>
            </article>
            
            <article class="function" data-name="NewCBCEncrypter">
               <h3>
                  NewCBCEncrypter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining
mode, using the given Block. The length of iv must be the same as the
Block's block size.</p>
               
               <pre><code>func NewCBCEncrypter(b Block, iv []byte) BlockMode</code></pre>
            </article>
            
            <article class="function" data-name="NewCFBDecrypter">
               <h3>
                  NewCFBDecrypter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewCFBDecrypter returns a [Stream] which decrypts with cipher feedback mode,
using the given [Block]. The iv must be the same length as the [Block]'s block
size.
Deprecated: CFB mode is not authenticated, which generally enables active
attacks to manipulate and recover the plaintext. It is recommended that
applications use [AEAD] modes instead. The standard library implementation of
CFB is also unoptimized and not validated as part of the FIPS 140-3 module.
If an unauthenticated [Stream] mode is required, use [NewCTR] instead.</p>
               
               <pre><code>func NewCFBDecrypter(block Block, iv []byte) Stream</code></pre>
            </article>
            
            <article class="function" data-name="NewCFBEncrypter">
               <h3>
                  NewCFBEncrypter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewCFBEncrypter returns a [Stream] which encrypts with cipher feedback mode,
using the given [Block]. The iv must be the same length as the [Block]'s block
size.
Deprecated: CFB mode is not authenticated, which generally enables active
attacks to manipulate and recover the plaintext. It is recommended that
applications use [AEAD] modes instead. The standard library implementation of
CFB is also unoptimized and not validated as part of the FIPS 140-3 module.
If an unauthenticated [Stream] mode is required, use [NewCTR] instead.</p>
               
               <pre><code>func NewCFBEncrypter(block Block, iv []byte) Stream</code></pre>
            </article>
            
            <article class="function" data-name="NewCTR">
               <h3>
                  NewCTR 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewCTR returns a [Stream] which encrypts/decrypts using the given [Block] in
counter mode. The length of iv must be the same as the [Block]'s block size.</p>
               
               <pre><code>func NewCTR(block Block, iv []byte) Stream</code></pre>
            </article>
            
            <article class="function" data-name="NewGCM">
               <h3>
                  NewGCM 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode
with the standard nonce length.
In general, the GHASH operation performed by this implementation of GCM is not constant-time.
An exception is when the underlying [Block] was created by aes.NewCipher
on systems with hardware support for AES. See the [crypto/aes] package documentation for details.</p>
               
               <pre><code>func NewGCM(cipher Block) (AEAD, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewGCMWithNonceSize">
               <h3>
                  NewGCMWithNonceSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois
Counter Mode, which accepts nonces of the given length. The length must not
be zero.
Only use this function if you require compatibility with an existing
cryptosystem that uses non-standard nonce lengths. All other users should use
[NewGCM], which is faster and more resistant to misuse.</p>
               
               <pre><code>func NewGCMWithNonceSize(cipher Block, size int) (AEAD, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewGCMWithRandomNonce">
               <h3>
                  NewGCMWithRandomNonce 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewGCMWithRandomNonce returns the given cipher wrapped in Galois Counter
Mode, with randomly-generated nonces. The cipher must have been created by
[aes.NewCipher].
It generates a random 96-bit nonce, which is prepended to the ciphertext by Seal,
and is extracted from the ciphertext by Open. The NonceSize of the AEAD is zero,
while the Overhead is 28 bytes (the combination of nonce size and tag size).
A given key MUST NOT be used to encrypt more than 2^32 messages, to limit the
risk of a random nonce collision to negligible levels.</p>
               
               <pre><code>func NewGCMWithRandomNonce(cipher Block) (AEAD, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewGCMWithTagSize">
               <h3>
                  NewGCMWithTagSize 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois
Counter Mode, which generates tags with the given length.
Tag sizes between 12 and 16 bytes are allowed.
Only use this function if you require compatibility with an existing
cryptosystem that uses non-standard tag lengths. All other users should use
[NewGCM], which is more resistant to misuse.</p>
               
               <pre><code>func NewGCMWithTagSize(cipher Block, tagSize int) (AEAD, error)</code></pre>
            </article>
            
            <article class="function" data-name="NewOFB">
               <h3>
                  NewOFB 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>NewOFB returns a [Stream] that encrypts or decrypts using the block cipher b
in output feedback mode. The initialization vector iv's length must be equal
to b's block size.
Deprecated: OFB mode is not authenticated, which generally enables active
attacks to manipulate and recover the plaintext. It is recommended that
applications use [AEAD] modes instead. The standard library implementation of
OFB is also unoptimized and not validated as part of the FIPS 140-3 module.
If an unauthenticated [Stream] mode is required, use [NewCTR] instead.</p>
               
               <pre><code>func NewOFB(b Block, iv []byte) Stream</code></pre>
            </article>
            
            <article class="function" data-name="NonceSize">
               <h3>
                  NonceSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *gcmFallback) NonceSize() int</code></pre>
            </article>
            
            <article class="function" data-name="NonceSize">
               <h3>
                  NonceSize 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g gcmWithRandomNonce) NonceSize() int</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *gcmFallback) Open(dst []byte, nonce []byte, ciphertext []byte, additionalData []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g gcmWithRandomNonce) Open(dst []byte, nonce []byte, ciphertext []byte, additionalData []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function" data-name="Overhead">
               <h3>
                  Overhead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *gcmFallback) Overhead() int</code></pre>
            </article>
            
            <article class="function" data-name="Overhead">
               <h3>
                  Overhead 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g gcmWithRandomNonce) Overhead() int</code></pre>
            </article>
            
            <article class="function" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (r StreamReader) Read(dst []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="Seal">
               <h3>
                  Seal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g gcmWithRandomNonce) Seal(dst []byte, nonce []byte, plaintext []byte, additionalData []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="Seal">
               <h3>
                  Seal 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (g *gcmFallback) Seal(dst []byte, nonce []byte, plaintext []byte, additionalData []byte) []byte</code></pre>
            </article>
            
            <article class="function" data-name="SetIV">
               <h3>
                  SetIV 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *cbcEncrypter) SetIV(iv []byte)</code></pre>
            </article>
            
            <article class="function" data-name="SetIV">
               <h3>
                  SetIV 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *cbcDecrypter) SetIV(iv []byte)</code></pre>
            </article>
            
            <article class="function" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (w StreamWriter) Write(src []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function" data-name="XORKeyStream">
               <h3>
                  XORKeyStream 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *ofb) XORKeyStream(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function" data-name="XORKeyStream">
               <h3>
                  XORKeyStream 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *cfb) XORKeyStream(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function" data-name="XORKeyStream">
               <h3>
                  XORKeyStream 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *ctr) XORKeyStream(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function" data-name="XORKeyStream">
               <h3>
                  XORKeyStream 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x aesCtrWrapper) XORKeyStream(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function" data-name="deriveCounter">
               <h3>
                  deriveCounter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func deriveCounter(H *[gcmBlockSize]byte, counter *[gcmBlockSize]byte, nonce []byte)</code></pre>
            </article>
            
            <article class="function" data-name="gcmAuth">
               <h3>
                  gcmAuth 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func gcmAuth(out []byte, H *[gcmBlockSize]byte, tagMask *[gcmBlockSize]byte, ciphertext []byte, additionalData []byte)</code></pre>
            </article>
            
            <article class="function" data-name="gcmCounterCryptGeneric">
               <h3>
                  gcmCounterCryptGeneric 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func gcmCounterCryptGeneric(b Block, out []byte, src []byte, counter *[gcmBlockSize]byte)</code></pre>
            </article>
            
            <article class="function" data-name="gcmInc32">
               <h3>
                  gcmInc32 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func gcmInc32(counterBlock *[gcmBlockSize]byte)</code></pre>
            </article>
            
            <article class="function" data-name="newCBC">
               <h3>
                  newCBC 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newCBC(b Block, iv []byte) *cbc</code></pre>
            </article>
            
            <article class="function" data-name="newCBCGenericDecrypter">
               <h3>
                  newCBCGenericDecrypter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newCBCGenericDecrypter returns a BlockMode which encrypts in cipher block chaining
mode, using the given Block. The length of iv must be the same as the
Block's block size. This always returns the generic non-asm decrypter for use in
fuzz testing.</p>
               
               <pre><code>func newCBCGenericDecrypter(b Block, iv []byte) BlockMode</code></pre>
            </article>
            
            <article class="function" data-name="newCBCGenericEncrypter">
               <h3>
                  newCBCGenericEncrypter 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>newCBCGenericEncrypter returns a BlockMode which encrypts in cipher block chaining
mode, using the given Block. The length of iv must be the same as the
Block's block size. This always returns the generic non-asm encrypter for use
in fuzz testing.</p>
               
               <pre><code>func newCBCGenericEncrypter(b Block, iv []byte) BlockMode</code></pre>
            </article>
            
            <article class="function" data-name="newCFB">
               <h3>
                  newCFB 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newCFB(block Block, iv []byte, decrypt bool) Stream</code></pre>
            </article>
            
            <article class="function" data-name="newGCM">
               <h3>
                  newGCM 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newGCM(cipher Block, nonceSize int, tagSize int) (AEAD, error)</code></pre>
            </article>
            
            <article class="function" data-name="newGCMFallback">
               <h3>
                  newGCMFallback 
                  <span class="badge">function</span>
                  
               </h3>
               
               <pre><code>func newGCMFallback(cipher Block, nonceSize int, tagSize int) (AEAD, error)</code></pre>
            </article>
            
            <article class="function" data-name="refill">
               <h3>
                  refill 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *ctr) refill()</code></pre>
            </article>
            
            <article class="function" data-name="refill">
               <h3>
                  refill 
                  <span class="badge method-badge">method</span>
                  
               </h3>
               
               <pre><code>func (x *ofb) refill()</code></pre>
            </article>
            
            <article class="function" data-name="sliceForAppend">
               <h3>
                  sliceForAppend 
                  <span class="badge">function</span>
                  
               </h3>
               
               <p>sliceForAppend takes a slice and a requested number of bytes. It returns a
slice with the contents of the given slice followed by that many bytes and a
second slice that aliases into it and contains only the extra bytes. If the
original slice has sufficient capacity then no allocation is performed.</p>
               
               <pre><code>func sliceForAppend(in []byte, n int) (head []byte, tail []byte)</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            // Handle private methods in interfaces
            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     // Reuse fields toggle for interface methods
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        // Only show if not hidden by privacy filters
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });
               });
            }

            // Helper function to check if private elements should be shown
            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  e.preventDefault();
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });
         });
      </script>
   </body>
</html>
