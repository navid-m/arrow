<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - cipher</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
         
         <span style="color: rgba(177, 175, 175, 0.5)">
            No subpackages
         </span>
         
      </aside>
      <main>
         <h1>
            Package
            <code>cipher</code>
         </h1>
         <hr />
         
         <article class="global" data-name="streamBufferSize">
            <h2>streamBufferSize</h2>
            <hr />
            
            <pre><code>streamBufferSize</code></pre>
         </article>
         
         <article class="global" data-name="gcmBlockSize">
            <h2>gcmBlockSize</h2>
            <hr />
            
            <pre><code>gcmBlockSize</code></pre>
         </article>
         
         <article class="global" data-name="gcmStandardNonceSize">
            <h2>gcmStandardNonceSize</h2>
            <hr />
            
            <pre><code>gcmStandardNonceSize</code></pre>
         </article>
         
         <article class="global" data-name="gcmTagSize">
            <h2>gcmTagSize</h2>
            <hr />
            
            <pre><code>gcmTagSize</code></pre>
         </article>
         
         <article class="global" data-name="gcmMinimumTagSize">
            <h2>gcmMinimumTagSize</h2>
            <hr />
            
            <pre><code>gcmMinimumTagSize</code></pre>
         </article>
         
         <article class="global" data-name="errOpen">
            <h2>errOpen</h2>
            <hr />
            
            <pre><code>errOpen</code></pre>
         </article>
          
         <article class="struct" data-name="cfb">
            <h2>type cfb struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">b Block
next []byte
out []byte
outUsed int
decrypt bool</code></pre>
         </article>
         
         <article class="struct" data-name="ctr">
            <h2>type ctr struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">b Block
ctr []byte
out []byte
outUsed int</code></pre>
         </article>
         
         <article class="struct" data-name="aesCtrWrapper">
            <h2>type aesCtrWrapper struct</h2>
            <hr />
            
            <p>aesCtrWrapper hides extra methods from aes.CTR.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">c *aes.CTR</code></pre>
         </article>
         
         <article class="struct" data-name="gcmWithRandomNonce">
            <h2>type gcmWithRandomNonce struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">*gcm.GCM</code></pre>
         </article>
         
         <article class="struct" data-name="gcmFallback">
            <h2>type gcmFallback struct</h2>
            <hr />
            
            <p>gcmFallback is only used for non-AES ciphers, which regrettably we
theoretically support. It's a copy of the generic implementation from
crypto/internal/fips140/aes/gcm/gcm_generic.go, refer to that file for more details.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">cipher Block
nonceSize int
tagSize int</code></pre>
         </article>
         
         <article class="struct" data-name="StreamReader">
            <h2>type StreamReader struct</h2>
            <hr />
            
            <p>StreamReader wraps a [Stream] into an [io.Reader]. It calls XORKeyStream
to process each slice of data which passes through.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">S Stream
R io.Reader</code></pre>
         </article>
         
         <article class="struct" data-name="StreamWriter">
            <h2>type StreamWriter struct</h2>
            <hr />
            
            <p>StreamWriter wraps a [Stream] into an io.Writer. It calls XORKeyStream
to process each slice of data which passes through. If any [StreamWriter.Write]
call returns short then the StreamWriter is out of sync and must be discarded.
A StreamWriter has no internal buffering; [StreamWriter.Close] does not need
to be called to flush write data.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">S Stream
W io.Writer
Err error</code></pre>
         </article>
         
         <article class="struct" data-name="ofb">
            <h2>type ofb struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">b Block
cipher []byte
out []byte
outUsed int</code></pre>
         </article>
         
         <article class="struct" data-name="cbc">
            <h2>type cbc struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">b Block
blockSize int
iv []byte
tmp []byte</code></pre>
         </article>
          
         <article class="function" data-name="XORKeyStream">
            <h2>XORKeyStream</h2>
            <hr />
            
            <pre><code>func XORKeyStream(dst []byte, src []byte)</code></pre>
         </article>
         
         <article class="function" data-name="NewCFBEncrypter">
            <h2>NewCFBEncrypter</h2>
            <hr />
            
            <p>NewCFBEncrypter returns a [Stream] which encrypts with cipher feedback mode,
using the given [Block]. The iv must be the same length as the [Block]'s block
size.

Deprecated: CFB mode is not authenticated, which generally enables active
attacks to manipulate and recover the plaintext. It is recommended that
applications use [AEAD] modes instead. The standard library implementation of
CFB is also unoptimized and not validated as part of the FIPS 140-3 module.
If an unauthenticated [Stream] mode is required, use [NewCTR] instead.</p>
            
            <pre><code>func NewCFBEncrypter(block Block, iv []byte) Stream</code></pre>
         </article>
         
         <article class="function" data-name="NewCFBDecrypter">
            <h2>NewCFBDecrypter</h2>
            <hr />
            
            <p>NewCFBDecrypter returns a [Stream] which decrypts with cipher feedback mode,
using the given [Block]. The iv must be the same length as the [Block]'s block
size.

Deprecated: CFB mode is not authenticated, which generally enables active
attacks to manipulate and recover the plaintext. It is recommended that
applications use [AEAD] modes instead. The standard library implementation of
CFB is also unoptimized and not validated as part of the FIPS 140-3 module.
If an unauthenticated [Stream] mode is required, use [NewCTR] instead.</p>
            
            <pre><code>func NewCFBDecrypter(block Block, iv []byte) Stream</code></pre>
         </article>
         
         <article class="function" data-name="newCFB">
            <h2>newCFB</h2>
            <hr />
            
            <pre><code>func newCFB(block Block, iv []byte, decrypt bool) Stream</code></pre>
         </article>
         
         <article class="function" data-name="NewCTR">
            <h2>NewCTR</h2>
            <hr />
            
            <p>NewCTR returns a [Stream] which encrypts/decrypts using the given [Block] in
counter mode. The length of iv must be the same as the [Block]'s block size.</p>
            
            <pre><code>func NewCTR(block Block, iv []byte) Stream</code></pre>
         </article>
         
         <article class="function" data-name="XORKeyStream">
            <h2>XORKeyStream</h2>
            <hr />
            
            <pre><code>func XORKeyStream(dst []byte, src []byte)</code></pre>
         </article>
         
         <article class="function" data-name="refill">
            <h2>refill</h2>
            <hr />
            
            <pre><code>func refill()</code></pre>
         </article>
         
         <article class="function" data-name="XORKeyStream">
            <h2>XORKeyStream</h2>
            <hr />
            
            <pre><code>func XORKeyStream(dst []byte, src []byte)</code></pre>
         </article>
         
         <article class="function" data-name="NewGCM">
            <h2>NewGCM</h2>
            <hr />
            
            <p>NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode
with the standard nonce length.

In general, the GHASH operation performed by this implementation of GCM is not constant-time.
An exception is when the underlying [Block] was created by aes.NewCipher
on systems with hardware support for AES. See the [crypto/aes] package documentation for details.</p>
            
            <pre><code>func NewGCM(cipher Block) (AEAD, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewGCMWithNonceSize">
            <h2>NewGCMWithNonceSize</h2>
            <hr />
            
            <p>NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois
Counter Mode, which accepts nonces of the given length. The length must not
be zero.

Only use this function if you require compatibility with an existing
cryptosystem that uses non-standard nonce lengths. All other users should use
[NewGCM], which is faster and more resistant to misuse.</p>
            
            <pre><code>func NewGCMWithNonceSize(cipher Block, size int) (AEAD, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewGCMWithTagSize">
            <h2>NewGCMWithTagSize</h2>
            <hr />
            
            <p>NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois
Counter Mode, which generates tags with the given length.

Tag sizes between 12 and 16 bytes are allowed.

Only use this function if you require compatibility with an existing
cryptosystem that uses non-standard tag lengths. All other users should use
[NewGCM], which is more resistant to misuse.</p>
            
            <pre><code>func NewGCMWithTagSize(cipher Block, tagSize int) (AEAD, error)</code></pre>
         </article>
         
         <article class="function" data-name="newGCM">
            <h2>newGCM</h2>
            <hr />
            
            <pre><code>func newGCM(cipher Block, nonceSize int, tagSize int) (AEAD, error)</code></pre>
         </article>
         
         <article class="function" data-name="NewGCMWithRandomNonce">
            <h2>NewGCMWithRandomNonce</h2>
            <hr />
            
            <p>NewGCMWithRandomNonce returns the given cipher wrapped in Galois Counter
Mode, with randomly-generated nonces. The cipher must have been created by
[aes.NewCipher].

It generates a random 96-bit nonce, which is prepended to the ciphertext by Seal,
and is extracted from the ciphertext by Open. The NonceSize of the AEAD is zero,
while the Overhead is 28 bytes (the combination of nonce size and tag size).

A given key MUST NOT be used to encrypt more than 2^32 messages, to limit the
risk of a random nonce collision to negligible levels.</p>
            
            <pre><code>func NewGCMWithRandomNonce(cipher Block) (AEAD, error)</code></pre>
         </article>
         
         <article class="function" data-name="NonceSize">
            <h2>NonceSize</h2>
            <hr />
            
            <pre><code>func NonceSize() int</code></pre>
         </article>
         
         <article class="function" data-name="Overhead">
            <h2>Overhead</h2>
            <hr />
            
            <pre><code>func Overhead() int</code></pre>
         </article>
         
         <article class="function" data-name="Seal">
            <h2>Seal</h2>
            <hr />
            
            <pre><code>func Seal(dst []byte, nonce []byte, plaintext []byte, additionalData []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <pre><code>func Open(dst []byte, nonce []byte, ciphertext []byte, additionalData []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="newGCMFallback">
            <h2>newGCMFallback</h2>
            <hr />
            
            <pre><code>func newGCMFallback(cipher Block, nonceSize int, tagSize int) (AEAD, error)</code></pre>
         </article>
         
         <article class="function" data-name="NonceSize">
            <h2>NonceSize</h2>
            <hr />
            
            <pre><code>func NonceSize() int</code></pre>
         </article>
         
         <article class="function" data-name="Overhead">
            <h2>Overhead</h2>
            <hr />
            
            <pre><code>func Overhead() int</code></pre>
         </article>
         
         <article class="function" data-name="Seal">
            <h2>Seal</h2>
            <hr />
            
            <pre><code>func Seal(dst []byte, nonce []byte, plaintext []byte, additionalData []byte) []byte</code></pre>
         </article>
         
         <article class="function" data-name="Open">
            <h2>Open</h2>
            <hr />
            
            <pre><code>func Open(dst []byte, nonce []byte, ciphertext []byte, additionalData []byte) ([]byte, error)</code></pre>
         </article>
         
         <article class="function" data-name="deriveCounter">
            <h2>deriveCounter</h2>
            <hr />
            
            <pre><code>func deriveCounter(H *[]byte, counter *[]byte, nonce []byte)</code></pre>
         </article>
         
         <article class="function" data-name="gcmCounterCryptGeneric">
            <h2>gcmCounterCryptGeneric</h2>
            <hr />
            
            <pre><code>func gcmCounterCryptGeneric(b Block, out []byte, src []byte, counter *[]byte)</code></pre>
         </article>
         
         <article class="function" data-name="gcmInc32">
            <h2>gcmInc32</h2>
            <hr />
            
            <pre><code>func gcmInc32(counterBlock *[]byte)</code></pre>
         </article>
         
         <article class="function" data-name="gcmAuth">
            <h2>gcmAuth</h2>
            <hr />
            
            <pre><code>func gcmAuth(out []byte, H *[]byte, tagMask *[]byte, ciphertext []byte, additionalData []byte)</code></pre>
         </article>
         
         <article class="function" data-name="sliceForAppend">
            <h2>sliceForAppend</h2>
            <hr />
            
            <p>sliceForAppend takes a slice and a requested number of bytes. It returns a
slice with the contents of the given slice followed by that many bytes and a
second slice that aliases into it and contains only the extra bytes. If the
original slice has sufficient capacity then no allocation is performed.</p>
            
            <pre><code>func sliceForAppend(in []byte, n int) (head []byte, tail []byte)</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(dst []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Write">
            <h2>Write</h2>
            <hr />
            
            <pre><code>func Write(src []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="Close">
            <h2>Close</h2>
            <hr />
            
            <p>Close closes the underlying Writer and returns its Close return value, if the Writer
is also an io.Closer. Otherwise it returns nil.</p>
            
            <pre><code>func Close() error</code></pre>
         </article>
         
         <article class="function" data-name="NewOFB">
            <h2>NewOFB</h2>
            <hr />
            
            <p>NewOFB returns a [Stream] that encrypts or decrypts using the block cipher b
in output feedback mode. The initialization vector iv's length must be equal
to b's block size.

Deprecated: OFB mode is not authenticated, which generally enables active
attacks to manipulate and recover the plaintext. It is recommended that
applications use [AEAD] modes instead. The standard library implementation of
OFB is also unoptimized and not validated as part of the FIPS 140-3 module.
If an unauthenticated [Stream] mode is required, use [NewCTR] instead.</p>
            
            <pre><code>func NewOFB(b Block, iv []byte) Stream</code></pre>
         </article>
         
         <article class="function" data-name="refill">
            <h2>refill</h2>
            <hr />
            
            <pre><code>func refill()</code></pre>
         </article>
         
         <article class="function" data-name="XORKeyStream">
            <h2>XORKeyStream</h2>
            <hr />
            
            <pre><code>func XORKeyStream(dst []byte, src []byte)</code></pre>
         </article>
         
         <article class="function" data-name="newCBC">
            <h2>newCBC</h2>
            <hr />
            
            <pre><code>func newCBC(b Block, iv []byte) *cbc</code></pre>
         </article>
         
         <article class="function" data-name="NewCBCEncrypter">
            <h2>NewCBCEncrypter</h2>
            <hr />
            
            <p>NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining
mode, using the given Block. The length of iv must be the same as the
Block's block size.</p>
            
            <pre><code>func NewCBCEncrypter(b Block, iv []byte) BlockMode</code></pre>
         </article>
         
         <article class="function" data-name="newCBCGenericEncrypter">
            <h2>newCBCGenericEncrypter</h2>
            <hr />
            
            <p>newCBCGenericEncrypter returns a BlockMode which encrypts in cipher block chaining
mode, using the given Block. The length of iv must be the same as the
Block's block size. This always returns the generic non-asm encrypter for use
in fuzz testing.</p>
            
            <pre><code>func newCBCGenericEncrypter(b Block, iv []byte) BlockMode</code></pre>
         </article>
         
         <article class="function" data-name="BlockSize">
            <h2>BlockSize</h2>
            <hr />
            
            <pre><code>func BlockSize() int</code></pre>
         </article>
         
         <article class="function" data-name="CryptBlocks">
            <h2>CryptBlocks</h2>
            <hr />
            
            <pre><code>func CryptBlocks(dst []byte, src []byte)</code></pre>
         </article>
         
         <article class="function" data-name="SetIV">
            <h2>SetIV</h2>
            <hr />
            
            <pre><code>func SetIV(iv []byte)</code></pre>
         </article>
         
         <article class="function" data-name="NewCBCDecrypter">
            <h2>NewCBCDecrypter</h2>
            <hr />
            
            <p>NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining
mode, using the given Block. The length of iv must be the same as the
Block's block size and must match the iv used to encrypt the data.</p>
            
            <pre><code>func NewCBCDecrypter(b Block, iv []byte) BlockMode</code></pre>
         </article>
         
         <article class="function" data-name="newCBCGenericDecrypter">
            <h2>newCBCGenericDecrypter</h2>
            <hr />
            
            <p>newCBCGenericDecrypter returns a BlockMode which encrypts in cipher block chaining
mode, using the given Block. The length of iv must be the same as the
Block's block size. This always returns the generic non-asm decrypter for use in
fuzz testing.</p>
            
            <pre><code>func newCBCGenericDecrypter(b Block, iv []byte) BlockMode</code></pre>
         </article>
         
         <article class="function" data-name="BlockSize">
            <h2>BlockSize</h2>
            <hr />
            
            <pre><code>func BlockSize() int</code></pre>
         </article>
         
         <article class="function" data-name="CryptBlocks">
            <h2>CryptBlocks</h2>
            <hr />
            
            <pre><code>func CryptBlocks(dst []byte, src []byte)</code></pre>
         </article>
         
         <article class="function" data-name="SetIV">
            <h2>SetIV</h2>
            <hr />
            
            <pre><code>func SetIV(iv []byte)</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
