<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>cipher - Documentation</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <link
         href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         p {
            word-wrap: break-word;
            line-height: 1.6;
            font-size: 14px;
            margin-bottom: 1rem;
            color: #ccc;
         }

         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre, code {
            white-space: pre;
         }  

         pre[class*="language-"] {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3) !important;
            border-radius: 8px !important;
            margin: 1rem 0 !important;
            padding: 1rem 1.2rem !important;
            font-size: 0.9rem !important;
            overflow-x: auto !important;
         }

         code[class*="language-"] {
            color: #e6e6e6 !important;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace !important;
            white-space: pre-wrap !important;
         }

         pre:not([class*="language-"]) {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         pre:not([class*="language-"]) code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         .token.comment,
         .token.prolog,
         .token.doctype,
         .token.cdata {
            color: #7c7c7c !important;
         }

         .token.punctuation {
            color: #c9c9c9 !important;
         }

         .token.property,
         .token.tag,
         .token.boolean,
         .token.number,
         .token.constant,
         .token.symbol,
         .token.deleted {
            color: #f2777a !important;
         }

         .token.selector,
         .token.attr-name,
         .token.string,
         .token.char,
         .token.builtin,
         .token.inserted {
            color: #639fc2 !important;
         }

         .token.operator,
         .token.entity,
         .token.url,
         .language-css .token.string,
         .style .token.string {
            color: #66cccc !important;
         }

         .token.atrule,
         .token.attr-value,
         .token.keyword {
            color: #d34343 !important;
         }

         .token.function,
         .token.class-name {
            color: #f99157 !important;
         }

         .token.regex,
         .token.important,
         .token.variable {
            color: #ffcc66 !important;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>cipher</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code class="language-go">"crypto/internal/fips140/alias"
"crypto/internal/fips140only"
"crypto/subtle"
"bytes"
"crypto/internal/fips140/aes"
"crypto/internal/fips140/alias"
"crypto/internal/fips140only"
"crypto/subtle"
"crypto/internal/fips140/aes"
"crypto/internal/fips140/aes/gcm"
"crypto/internal/fips140/alias"
"crypto/internal/fips140only"
"crypto/subtle"
"errors"
"internal/byteorder"
"io"
"crypto/internal/fips140/alias"
"crypto/internal/fips140only"
"crypto/subtle"
"bytes"
"crypto/internal/fips140/aes"
"crypto/internal/fips140/alias"
"crypto/internal/fips140only"
"crypto/subtle"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="errOpen" data-name="errOpen">
               <h3>
                  errOpen 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#errOpen" class="anchor" title="Link to errOpen">#</a>
               </h3>
               
               <pre><code class="language-go">var errOpen = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gcmBlockSize" data-name="gcmBlockSize">
               <h3>
                  gcmBlockSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gcmBlockSize" class="anchor" title="Link to gcmBlockSize">#</a>
               </h3>
               
               <pre><code class="language-go">const gcmBlockSize = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gcmMinimumTagSize" data-name="gcmMinimumTagSize">
               <h3>
                  gcmMinimumTagSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gcmMinimumTagSize" class="anchor" title="Link to gcmMinimumTagSize">#</a>
               </h3>
               
               <pre><code class="language-go">const gcmMinimumTagSize = 12</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gcmStandardNonceSize" data-name="gcmStandardNonceSize">
               <h3>
                  gcmStandardNonceSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gcmStandardNonceSize" class="anchor" title="Link to gcmStandardNonceSize">#</a>
               </h3>
               
               <pre><code class="language-go">const gcmStandardNonceSize = 12</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="gcmTagSize" data-name="gcmTagSize">
               <h3>
                  gcmTagSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#gcmTagSize" class="anchor" title="Link to gcmTagSize">#</a>
               </h3>
               
               <pre><code class="language-go">const gcmTagSize = 16</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="streamBufferSize" data-name="streamBufferSize">
               <h3>
                  streamBufferSize 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#streamBufferSize" class="anchor" title="Link to streamBufferSize">#</a>
               </h3>
               
               <pre><code class="language-go">const streamBufferSize = 512</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="cbcDecrypter" data-name="cbcDecrypter">
               <h3>
                  cbcDecrypter
                  <span class="badge type-badge">type</span>
                  <a href="#cbcDecrypter" class="anchor" title="Link to cbcDecrypter">#</a>
               </h3>
               
               <pre><code class="language-go">type cbcDecrypter cbc</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="cbcEncrypter" data-name="cbcEncrypter">
               <h3>
                  cbcEncrypter
                  <span class="badge type-badge">type</span>
                  <a href="#cbcEncrypter" class="anchor" title="Link to cbcEncrypter">#</a>
               </h3>
               
               <pre><code class="language-go">type cbcEncrypter cbc</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="AEAD" data-name="AEAD">
               <h3>
                  AEAD
                  <span class="badge interface-badge">interface</span>
                  <a href="#AEAD" class="anchor" title="Link to AEAD">#</a>
               </h3>
               
               <p>AEAD is a cipher mode providing authenticated encryption with associated
data. For a description of the methodology, see
https://en.wikipedia.org/wiki/Authenticated_encryption.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type AEAD interface {
NonceSize() int
Overhead() int
Seal(dst []byte, nonce []byte, plaintext []byte, additionalData []byte) []byte
Open(dst []byte, nonce []byte, ciphertext []byte, additionalData []byte) ([]byte, error)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Block" data-name="Block">
               <h3>
                  Block
                  <span class="badge interface-badge">interface</span>
                  <a href="#Block" class="anchor" title="Link to Block">#</a>
               </h3>
               
               <p>A Block represents an implementation of block cipher
using a given key. It provides the capability to encrypt
or decrypt individual blocks. The mode implementations
extend that capability to streams of blocks.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Block interface {
BlockSize() int
Encrypt(dst []byte, src []byte)
Decrypt(dst []byte, src []byte)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="BlockMode" data-name="BlockMode">
               <h3>
                  BlockMode
                  <span class="badge interface-badge">interface</span>
                  <a href="#BlockMode" class="anchor" title="Link to BlockMode">#</a>
               </h3>
               
               <p>A BlockMode represents a block cipher running in a block-based mode (CBC,
ECB etc).</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type BlockMode interface {
BlockSize() int
CryptBlocks(dst []byte, src []byte)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="Stream" data-name="Stream">
               <h3>
                  Stream
                  <span class="badge interface-badge">interface</span>
                  <a href="#Stream" class="anchor" title="Link to Stream">#</a>
               </h3>
               
               <p>A Stream represents a stream cipher.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type Stream interface {
XORKeyStream(dst []byte, src []byte)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="cbcDecAble" data-name="cbcDecAble">
               <h3>
                  cbcDecAble
                  <span class="badge interface-badge">interface</span>
                  <a href="#cbcDecAble" class="anchor" title="Link to cbcDecAble">#</a>
               </h3>
               
               <p>cbcDecAble is an interface implemented by ciphers that have a specific
optimized implementation of CBC decryption. crypto/aes doesn't use this
anymore, and we'd like to eventually remove it.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type cbcDecAble interface {
NewCBCDecrypter(iv []byte) BlockMode
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="cbcEncAble" data-name="cbcEncAble">
               <h3>
                  cbcEncAble
                  <span class="badge interface-badge">interface</span>
                  <a href="#cbcEncAble" class="anchor" title="Link to cbcEncAble">#</a>
               </h3>
               
               <p>cbcEncAble is an interface implemented by ciphers that have a specific
optimized implementation of CBC encryption. crypto/aes doesn't use this
anymore, and we'd like to eventually remove it.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type cbcEncAble interface {
NewCBCEncrypter(iv []byte) BlockMode
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="ctrAble" data-name="ctrAble">
               <h3>
                  ctrAble
                  <span class="badge interface-badge">interface</span>
                  <a href="#ctrAble" class="anchor" title="Link to ctrAble">#</a>
               </h3>
               
               <p>ctrAble is an interface implemented by ciphers that have a specific optimized
implementation of CTR. crypto/aes doesn't use this anymore, and we'd like to
eventually remove it.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type ctrAble interface {
NewCTR(iv []byte) Stream
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="gcmAble" data-name="gcmAble">
               <h3>
                  gcmAble
                  <span class="badge interface-badge">interface</span>
                  <a href="#gcmAble" class="anchor" title="Link to gcmAble">#</a>
               </h3>
               
               <p>gcmAble is an interface implemented by ciphers that have a specific optimized
implementation of GCM. crypto/aes doesn't use this anymore, and we'd like to
eventually remove it.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code language-go">type gcmAble interface {
NewGCM(nonceSize int, tagSize int) (AEAD, error)
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="StreamReader" data-name="StreamReader">
               <h3>
                  StreamReader
                  <span class="badge">struct</span>
                  <a href="#StreamReader" class="anchor" title="Link to StreamReader">#</a>
               </h3>
               
               <p>StreamReader wraps a [Stream] into an [io.Reader]. It calls XORKeyStream
to process each slice of data which passes through.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type StreamReader struct {
S Stream
R io.Reader
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="StreamWriter" data-name="StreamWriter">
               <h3>
                  StreamWriter
                  <span class="badge">struct</span>
                  <a href="#StreamWriter" class="anchor" title="Link to StreamWriter">#</a>
               </h3>
               
               <p>StreamWriter wraps a [Stream] into an io.Writer. It calls XORKeyStream
to process each slice of data which passes through. If any [StreamWriter.Write]
call returns short then the StreamWriter is out of sync and must be discarded.
A StreamWriter has no internal buffering; [StreamWriter.Close] does not need
to be called to flush write data.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type StreamWriter struct {
S Stream
W io.Writer
Err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="aesCtrWrapper" data-name="aesCtrWrapper">
               <h3>
                  aesCtrWrapper
                  <span class="badge">struct</span>
                  <a href="#aesCtrWrapper" class="anchor" title="Link to aesCtrWrapper">#</a>
               </h3>
               
               <p>aesCtrWrapper hides extra methods from aes.CTR.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type aesCtrWrapper struct {
c *aes.CTR
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cbc" data-name="cbc">
               <h3>
                  cbc
                  <span class="badge">struct</span>
                  <a href="#cbc" class="anchor" title="Link to cbc">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cbc struct {
b Block
blockSize int
iv []byte
tmp []byte
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="cfb" data-name="cfb">
               <h3>
                  cfb
                  <span class="badge">struct</span>
                  <a href="#cfb" class="anchor" title="Link to cfb">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type cfb struct {
b Block
next []byte
out []byte
outUsed int
decrypt bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ctr" data-name="ctr">
               <h3>
                  ctr
                  <span class="badge">struct</span>
                  <a href="#ctr" class="anchor" title="Link to ctr">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ctr struct {
b Block
ctr []byte
out []byte
outUsed int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="gcmFallback" data-name="gcmFallback">
               <h3>
                  gcmFallback
                  <span class="badge">struct</span>
                  <a href="#gcmFallback" class="anchor" title="Link to gcmFallback">#</a>
               </h3>
               
               <p>gcmFallback is only used for non-AES ciphers, which regrettably we
theoretically support. It's a copy of the generic implementation from
crypto/internal/fips140/aes/gcm/gcm_generic.go, refer to that file for more details.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type gcmFallback struct {
cipher Block
nonceSize int
tagSize int
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="gcmWithRandomNonce" data-name="gcmWithRandomNonce">
               <h3>
                  gcmWithRandomNonce
                  <span class="badge">struct</span>
                  <a href="#gcmWithRandomNonce" class="anchor" title="Link to gcmWithRandomNonce">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type gcmWithRandomNonce struct {
*gcm.GCM
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="ofb" data-name="ofb">
               <h3>
                  ofb
                  <span class="badge">struct</span>
                  <a href="#ofb" class="anchor" title="Link to ofb">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code language-go">type ofb struct {
b Block
cipher []byte
out []byte
outUsed int
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="BlockSize" data-name="BlockSize">
               <h3>
                  BlockSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BlockSize" class="anchor" title="Link to BlockSize">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *cbcDecrypter) BlockSize() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="BlockSize" data-name="BlockSize">
               <h3>
                  BlockSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#BlockSize" class="anchor" title="Link to BlockSize">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *cbcEncrypter) BlockSize() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Close" data-name="Close">
               <h3>
                  Close 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Close" class="anchor" title="Link to Close">#</a>
               </h3>
               
               <p>Close closes the underlying Writer and returns its Close return value, if the Writer
is also an io.Closer. Otherwise it returns nil.</p>
               
               <pre><code class="language-go">func (w StreamWriter) Close() error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CryptBlocks" data-name="CryptBlocks">
               <h3>
                  CryptBlocks 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CryptBlocks" class="anchor" title="Link to CryptBlocks">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *cbcEncrypter) CryptBlocks(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="CryptBlocks" data-name="CryptBlocks">
               <h3>
                  CryptBlocks 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#CryptBlocks" class="anchor" title="Link to CryptBlocks">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *cbcDecrypter) CryptBlocks(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewCBCDecrypter" data-name="NewCBCDecrypter">
               <h3>
                  NewCBCDecrypter 
                  <span class="badge">function</span>
                  
                  <a href="#NewCBCDecrypter" class="anchor" title="Link to NewCBCDecrypter">#</a>
               </h3>
               
               <p>NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining
mode, using the given Block. The length of iv must be the same as the
Block's block size and must match the iv used to encrypt the data.</p>
               
               <pre><code class="language-go">func NewCBCDecrypter(b Block, iv []byte) BlockMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewCBCEncrypter" data-name="NewCBCEncrypter">
               <h3>
                  NewCBCEncrypter 
                  <span class="badge">function</span>
                  
                  <a href="#NewCBCEncrypter" class="anchor" title="Link to NewCBCEncrypter">#</a>
               </h3>
               
               <p>NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining
mode, using the given Block. The length of iv must be the same as the
Block's block size.</p>
               
               <pre><code class="language-go">func NewCBCEncrypter(b Block, iv []byte) BlockMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewCFBDecrypter" data-name="NewCFBDecrypter">
               <h3>
                  NewCFBDecrypter 
                  <span class="badge">function</span>
                  
                  <a href="#NewCFBDecrypter" class="anchor" title="Link to NewCFBDecrypter">#</a>
               </h3>
               
               <p>NewCFBDecrypter returns a [Stream] which decrypts with cipher feedback mode,
using the given [Block]. The iv must be the same length as the [Block]'s block
size.
Deprecated: CFB mode is not authenticated, which generally enables active
attacks to manipulate and recover the plaintext. It is recommended that
applications use [AEAD] modes instead. The standard library implementation of
CFB is also unoptimized and not validated as part of the FIPS 140-3 module.
If an unauthenticated [Stream] mode is required, use [NewCTR] instead.</p>
               
               <pre><code class="language-go">func NewCFBDecrypter(block Block, iv []byte) Stream</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewCFBEncrypter" data-name="NewCFBEncrypter">
               <h3>
                  NewCFBEncrypter 
                  <span class="badge">function</span>
                  
                  <a href="#NewCFBEncrypter" class="anchor" title="Link to NewCFBEncrypter">#</a>
               </h3>
               
               <p>NewCFBEncrypter returns a [Stream] which encrypts with cipher feedback mode,
using the given [Block]. The iv must be the same length as the [Block]'s block
size.
Deprecated: CFB mode is not authenticated, which generally enables active
attacks to manipulate and recover the plaintext. It is recommended that
applications use [AEAD] modes instead. The standard library implementation of
CFB is also unoptimized and not validated as part of the FIPS 140-3 module.
If an unauthenticated [Stream] mode is required, use [NewCTR] instead.</p>
               
               <pre><code class="language-go">func NewCFBEncrypter(block Block, iv []byte) Stream</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewCTR" data-name="NewCTR">
               <h3>
                  NewCTR 
                  <span class="badge">function</span>
                  
                  <a href="#NewCTR" class="anchor" title="Link to NewCTR">#</a>
               </h3>
               
               <p>NewCTR returns a [Stream] which encrypts/decrypts using the given [Block] in
counter mode. The length of iv must be the same as the [Block]'s block size.</p>
               
               <pre><code class="language-go">func NewCTR(block Block, iv []byte) Stream</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewGCM" data-name="NewGCM">
               <h3>
                  NewGCM 
                  <span class="badge">function</span>
                  
                  <a href="#NewGCM" class="anchor" title="Link to NewGCM">#</a>
               </h3>
               
               <p>NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode
with the standard nonce length.
In general, the GHASH operation performed by this implementation of GCM is not constant-time.
An exception is when the underlying [Block] was created by aes.NewCipher
on systems with hardware support for AES. See the [crypto/aes] package documentation for details.</p>
               
               <pre><code class="language-go">func NewGCM(cipher Block) (AEAD, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewGCMWithNonceSize" data-name="NewGCMWithNonceSize">
               <h3>
                  NewGCMWithNonceSize 
                  <span class="badge">function</span>
                  
                  <a href="#NewGCMWithNonceSize" class="anchor" title="Link to NewGCMWithNonceSize">#</a>
               </h3>
               
               <p>NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois
Counter Mode, which accepts nonces of the given length. The length must not
be zero.
Only use this function if you require compatibility with an existing
cryptosystem that uses non-standard nonce lengths. All other users should use
[NewGCM], which is faster and more resistant to misuse.</p>
               
               <pre><code class="language-go">func NewGCMWithNonceSize(cipher Block, size int) (AEAD, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewGCMWithRandomNonce" data-name="NewGCMWithRandomNonce">
               <h3>
                  NewGCMWithRandomNonce 
                  <span class="badge">function</span>
                  
                  <a href="#NewGCMWithRandomNonce" class="anchor" title="Link to NewGCMWithRandomNonce">#</a>
               </h3>
               
               <p>NewGCMWithRandomNonce returns the given cipher wrapped in Galois Counter
Mode, with randomly-generated nonces. The cipher must have been created by
[aes.NewCipher].
It generates a random 96-bit nonce, which is prepended to the ciphertext by Seal,
and is extracted from the ciphertext by Open. The NonceSize of the AEAD is zero,
while the Overhead is 28 bytes (the combination of nonce size and tag size).
A given key MUST NOT be used to encrypt more than 2^32 messages, to limit the
risk of a random nonce collision to negligible levels.</p>
               
               <pre><code class="language-go">func NewGCMWithRandomNonce(cipher Block) (AEAD, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewGCMWithTagSize" data-name="NewGCMWithTagSize">
               <h3>
                  NewGCMWithTagSize 
                  <span class="badge">function</span>
                  
                  <a href="#NewGCMWithTagSize" class="anchor" title="Link to NewGCMWithTagSize">#</a>
               </h3>
               
               <p>NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois
Counter Mode, which generates tags with the given length.
Tag sizes between 12 and 16 bytes are allowed.
Only use this function if you require compatibility with an existing
cryptosystem that uses non-standard tag lengths. All other users should use
[NewGCM], which is more resistant to misuse.</p>
               
               <pre><code class="language-go">func NewGCMWithTagSize(cipher Block, tagSize int) (AEAD, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NewOFB" data-name="NewOFB">
               <h3>
                  NewOFB 
                  <span class="badge">function</span>
                  
                  <a href="#NewOFB" class="anchor" title="Link to NewOFB">#</a>
               </h3>
               
               <p>NewOFB returns a [Stream] that encrypts or decrypts using the block cipher b
in output feedback mode. The initialization vector iv's length must be equal
to b's block size.
Deprecated: OFB mode is not authenticated, which generally enables active
attacks to manipulate and recover the plaintext. It is recommended that
applications use [AEAD] modes instead. The standard library implementation of
OFB is also unoptimized and not validated as part of the FIPS 140-3 module.
If an unauthenticated [Stream] mode is required, use [NewCTR] instead.</p>
               
               <pre><code class="language-go">func NewOFB(b Block, iv []byte) Stream</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NonceSize" data-name="NonceSize">
               <h3>
                  NonceSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NonceSize" class="anchor" title="Link to NonceSize">#</a>
               </h3>
               
               <pre><code class="language-go">func (g gcmWithRandomNonce) NonceSize() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="NonceSize" data-name="NonceSize">
               <h3>
                  NonceSize 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#NonceSize" class="anchor" title="Link to NonceSize">#</a>
               </h3>
               
               <pre><code class="language-go">func (g *gcmFallback) NonceSize() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <pre><code class="language-go">func (g gcmWithRandomNonce) Open(dst []byte, nonce []byte, ciphertext []byte, additionalData []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Open" data-name="Open">
               <h3>
                  Open 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Open" class="anchor" title="Link to Open">#</a>
               </h3>
               
               <pre><code class="language-go">func (g *gcmFallback) Open(dst []byte, nonce []byte, ciphertext []byte, additionalData []byte) ([]byte, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Overhead" data-name="Overhead">
               <h3>
                  Overhead 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Overhead" class="anchor" title="Link to Overhead">#</a>
               </h3>
               
               <pre><code class="language-go">func (g *gcmFallback) Overhead() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Overhead" data-name="Overhead">
               <h3>
                  Overhead 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Overhead" class="anchor" title="Link to Overhead">#</a>
               </h3>
               
               <pre><code class="language-go">func (g gcmWithRandomNonce) Overhead() int</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code class="language-go">func (r StreamReader) Read(dst []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Seal" data-name="Seal">
               <h3>
                  Seal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Seal" class="anchor" title="Link to Seal">#</a>
               </h3>
               
               <pre><code class="language-go">func (g *gcmFallback) Seal(dst []byte, nonce []byte, plaintext []byte, additionalData []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Seal" data-name="Seal">
               <h3>
                  Seal 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Seal" class="anchor" title="Link to Seal">#</a>
               </h3>
               
               <pre><code class="language-go">func (g gcmWithRandomNonce) Seal(dst []byte, nonce []byte, plaintext []byte, additionalData []byte) []byte</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetIV" data-name="SetIV">
               <h3>
                  SetIV 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetIV" class="anchor" title="Link to SetIV">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *cbcDecrypter) SetIV(iv []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="SetIV" data-name="SetIV">
               <h3>
                  SetIV 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#SetIV" class="anchor" title="Link to SetIV">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *cbcEncrypter) SetIV(iv []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Write" data-name="Write">
               <h3>
                  Write 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Write" class="anchor" title="Link to Write">#</a>
               </h3>
               
               <pre><code class="language-go">func (w StreamWriter) Write(src []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="XORKeyStream" data-name="XORKeyStream">
               <h3>
                  XORKeyStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#XORKeyStream" class="anchor" title="Link to XORKeyStream">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *ctr) XORKeyStream(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="XORKeyStream" data-name="XORKeyStream">
               <h3>
                  XORKeyStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#XORKeyStream" class="anchor" title="Link to XORKeyStream">#</a>
               </h3>
               
               <pre><code class="language-go">func (x aesCtrWrapper) XORKeyStream(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="XORKeyStream" data-name="XORKeyStream">
               <h3>
                  XORKeyStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#XORKeyStream" class="anchor" title="Link to XORKeyStream">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *ofb) XORKeyStream(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="XORKeyStream" data-name="XORKeyStream">
               <h3>
                  XORKeyStream 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#XORKeyStream" class="anchor" title="Link to XORKeyStream">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *cfb) XORKeyStream(dst []byte, src []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="deriveCounter" data-name="deriveCounter">
               <h3>
                  deriveCounter 
                  <span class="badge">function</span>
                  
                  <a href="#deriveCounter" class="anchor" title="Link to deriveCounter">#</a>
               </h3>
               
               <pre><code class="language-go">func deriveCounter(H *[gcmBlockSize]byte, counter *[gcmBlockSize]byte, nonce []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gcmAuth" data-name="gcmAuth">
               <h3>
                  gcmAuth 
                  <span class="badge">function</span>
                  
                  <a href="#gcmAuth" class="anchor" title="Link to gcmAuth">#</a>
               </h3>
               
               <pre><code class="language-go">func gcmAuth(out []byte, H *[gcmBlockSize]byte, tagMask *[gcmBlockSize]byte, ciphertext []byte, additionalData []byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gcmCounterCryptGeneric" data-name="gcmCounterCryptGeneric">
               <h3>
                  gcmCounterCryptGeneric 
                  <span class="badge">function</span>
                  
                  <a href="#gcmCounterCryptGeneric" class="anchor" title="Link to gcmCounterCryptGeneric">#</a>
               </h3>
               
               <pre><code class="language-go">func gcmCounterCryptGeneric(b Block, out []byte, src []byte, counter *[gcmBlockSize]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="gcmInc32" data-name="gcmInc32">
               <h3>
                  gcmInc32 
                  <span class="badge">function</span>
                  
                  <a href="#gcmInc32" class="anchor" title="Link to gcmInc32">#</a>
               </h3>
               
               <pre><code class="language-go">func gcmInc32(counterBlock *[gcmBlockSize]byte)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newCBC" data-name="newCBC">
               <h3>
                  newCBC 
                  <span class="badge">function</span>
                  
                  <a href="#newCBC" class="anchor" title="Link to newCBC">#</a>
               </h3>
               
               <pre><code class="language-go">func newCBC(b Block, iv []byte) *cbc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newCBCGenericDecrypter" data-name="newCBCGenericDecrypter">
               <h3>
                  newCBCGenericDecrypter 
                  <span class="badge">function</span>
                  
                  <a href="#newCBCGenericDecrypter" class="anchor" title="Link to newCBCGenericDecrypter">#</a>
               </h3>
               
               <p>newCBCGenericDecrypter returns a BlockMode which encrypts in cipher block chaining
mode, using the given Block. The length of iv must be the same as the
Block's block size. This always returns the generic non-asm decrypter for use in
fuzz testing.</p>
               
               <pre><code class="language-go">func newCBCGenericDecrypter(b Block, iv []byte) BlockMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newCBCGenericEncrypter" data-name="newCBCGenericEncrypter">
               <h3>
                  newCBCGenericEncrypter 
                  <span class="badge">function</span>
                  
                  <a href="#newCBCGenericEncrypter" class="anchor" title="Link to newCBCGenericEncrypter">#</a>
               </h3>
               
               <p>newCBCGenericEncrypter returns a BlockMode which encrypts in cipher block chaining
mode, using the given Block. The length of iv must be the same as the
Block's block size. This always returns the generic non-asm encrypter for use
in fuzz testing.</p>
               
               <pre><code class="language-go">func newCBCGenericEncrypter(b Block, iv []byte) BlockMode</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newCFB" data-name="newCFB">
               <h3>
                  newCFB 
                  <span class="badge">function</span>
                  
                  <a href="#newCFB" class="anchor" title="Link to newCFB">#</a>
               </h3>
               
               <pre><code class="language-go">func newCFB(block Block, iv []byte, decrypt bool) Stream</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newGCM" data-name="newGCM">
               <h3>
                  newGCM 
                  <span class="badge">function</span>
                  
                  <a href="#newGCM" class="anchor" title="Link to newGCM">#</a>
               </h3>
               
               <pre><code class="language-go">func newGCM(cipher Block, nonceSize int, tagSize int) (AEAD, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newGCMFallback" data-name="newGCMFallback">
               <h3>
                  newGCMFallback 
                  <span class="badge">function</span>
                  
                  <a href="#newGCMFallback" class="anchor" title="Link to newGCMFallback">#</a>
               </h3>
               
               <pre><code class="language-go">func newGCMFallback(cipher Block, nonceSize int, tagSize int) (AEAD, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="refill" data-name="refill">
               <h3>
                  refill 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#refill" class="anchor" title="Link to refill">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *ofb) refill()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="refill" data-name="refill">
               <h3>
                  refill 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#refill" class="anchor" title="Link to refill">#</a>
               </h3>
               
               <pre><code class="language-go">func (x *ctr) refill()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="sliceForAppend" data-name="sliceForAppend">
               <h3>
                  sliceForAppend 
                  <span class="badge">function</span>
                  
                  <a href="#sliceForAppend" class="anchor" title="Link to sliceForAppend">#</a>
               </h3>
               
               <p>sliceForAppend takes a slice and a requested number of bytes. It returns a
slice with the contents of the given slice followed by that many bytes and a
second slice that aliases into it and contains only the extra bytes. If the
original slice has sufficient capacity then no allocation is performed.</p>
               
               <pre><code class="language-go">func sliceForAppend(in []byte, n int) (head []byte, tail []byte)</code></pre>
            </article>
            
         </section>
         
         <hr />
         <p style="color:grey; font-size:smaller">Generated with <a href="https://github.com/navid-m/arrow" target="_blank" style="color:rgb(187, 186, 186)">Arrow</a></p>
      </main>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

      <script>
         function updateSectionVisibility() {
            document.querySelectorAll("section").forEach(section => {
               const visibleArticles = section.querySelectorAll("article:not(.hidden)");
               const header = section.querySelector("h2");
               if (header) {
                  if (visibleArticles.length === 0) {
                     section.classList.add("hidden");
                  } else {
                     section.classList.remove("hidden");
                  }
               }
            });
         }

         document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('p').forEach(el => {
               const raw = el.textContent;
               const parts = raw.split(/(?<=\w)(?<!(?:\.\w))\.(?=\s|$)/);
               const sentences = parts.map((frag, i) => {
               return (i < parts.length - 1 ? frag + '.' : frag).trim();
               }).filter(s => s.length > 0);
               let html = '';
               sentences.forEach((sent, idx) => {
                  html += sent;
                  html += ((idx + 1) % 2 === 0) ? '<br/>' : ' ';
               });
               if (sentences.length > 1) {
                  el.innerHTML = html.trim();
               }
            });
         });

         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            if (window.Prism) {
               Prism.highlightAll();
            }

            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                     updateSectionVisibility();
                  });
               }
            };

            hideInitial("article.imports", toggles.imports); updateSectionVisibility();
            hideInitial("article.function", toggles.functions); updateSectionVisibility();
            hideInitial("article.struct", toggles.structs); updateSectionVisibility();
            hideInitial("article.global", toggles.globals); updateSectionVisibility();
            hideInitial("article.type", toggles.types); updateSectionVisibility();
            hideInitial("article.interface", toggles.interfaces); updateSectionVisibility();

            document.querySelectorAll("article.struct").forEach((article) => {
               const codeBlock = article.querySelector("code.fields-code");
               if (!codeBlock) return;

               const raw = codeBlock.textContent.trim();
               const match = raw.match(/^type\s+\w+\s+struct\s*{(.*)}$/s);
               if (!match) return;

               const fieldsRaw = match[1].trim();
               const fields = fieldsRaw.split("\n").map(line => line.trim()).filter(Boolean);
               const formatted = fields.map(line => `\t${line}`).join("\n");
               const structName = article.dataset.name;
               const finalCode = `type ${structName} struct {\n${formatted}\n}`;

               codeBlock.textContent = finalCode;

               if (window.Prism) Prism.highlightElement(codeBlock);

               if (toggles.fields) {
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               }
            });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && !trimmed.endsWith("{") && trimmed != "}") {
                           return `<span class="method-line">${line}</span>`;
                        } else {
                           return ``;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span><br />`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (window.Prism) {
                     Prism.highlightElement(codeBlock);
                  }

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                     updateSectionVisibility();
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>