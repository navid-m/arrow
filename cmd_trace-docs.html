<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - main</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 14px;
            scroll-behavior: smooth;
         }

         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
            line-height: 1.6;
         }

         .sidebar {
            width: 12%;
            background: rgba(59, 56, 56, 0.15);
            padding: 1.5rem;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.4);
            overflow-y: auto;
            position: sticky;
            top: 0;
            height: 100vh;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
         }

         .sidebar::-webkit-scrollbar {
            width: 6px;
         }

         .sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
         }

         .sidebar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
         }

         main {
            flex: 1;
            padding: 2rem;
            margin: 0;
            max-width: calc(100% - 280px);
            background: linear-gradient(
               135deg,
               rgba(59, 56, 56, 0.05) 0%,
               rgba(0, 0, 0, 0.1) 100%
            );
         }

         .nav-links {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
         }

         .nav-links a {
            color: #ddd;
            text-decoration: none;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s ease;
         }

         .nav-links a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            background: linear-gradient(135deg, #fff 0%, #ddd 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
         }

         h2 {
            font-size: 1.4rem;
            margin: 1rem 0 0.5rem;
            color: #f0f0f0;
         }

         h3 {
            font-size: 1.2rem;
            margin: 0.8rem 0 0.3rem;
            color: #e0e0e0;
            position: relative;
         }

         .sidebar h2,
         .sidebar h3 {
            font-size: 1rem;
            margin: 0.5rem 0 0.3rem;
            color: #ccc;
         }

         /* Anchor link styling */
         .anchor {
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-weight: normal;
            margin-left: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
            font-size: 0.8em;
         }

         h3:hover .anchor,
         .anchor:focus {
            opacity: 1;
         }

         .anchor:hover {
            color: rgba(255, 255, 255, 0.6);
         }

         /* Scroll target offset for fixed elements */
         .symbol-anchor {
            scroll-margin-top: 2rem;
         }

         pre {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e6e6e6;
            padding: 1rem 1.2rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-size: 0.9rem;
            overflow-x: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
         }

         code {
            color: #f5f5f5;
            font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
            white-space: pre-wrap;
         }

         p {
            font-size: 15px;
            margin: 1rem 0;
            color: #ddd;
         }

         article {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: rgba(59, 56, 56, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
         }

         article:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
            transform: translateY(-2px);
         }

         article:target {
            border-color: rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 0 2px rgba(100, 200, 255, 0.2);
         }

         .hidden {
            display: none !important;
         }

         .filter-section {
            margin-bottom: 1.5rem;
         }

         .filter-section h3 {
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
         }

         .filter-toggle label {
            display: flex;
            align-items: center;
            margin-bottom: 0.6rem;
            font-size: 0.85rem;
            color: #bbb;
            cursor: pointer;
            padding: 0.3rem;
            border-radius: 4px;
            transition: background 0.2s ease;
         }

         .filter-toggle label:hover {
            background: rgba(255, 255, 255, 0.05);
         }

         .filter-toggle input {
            margin-right: 0.6rem;
         }

         .field-line,
         .method-line {
            display: block;
         }

         #searchInput {
            width: 100%;
            margin-bottom: 1.5rem;
            border-radius: 8px !important;
            height: 2.8rem;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0 1rem;
         }

         #searchInput::placeholder {
            color: rgba(255, 255, 255, 0.5);
         }

         #searchInput:focus {
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
         }

         .section-divider {
            height: 1px;
            background: linear-gradient(
               90deg,
               transparent 0%,
               rgba(255, 255, 255, 0.3) 50%,
               transparent 100%
            );
            margin: 1.5rem 0;
         }

         .subpackage-list {
            list-style: none;
            padding: 0;
         }

         .subpackage-list li {
            margin-bottom: 0.4rem;
         }

         .subpackage-list a {
            display: block;
            padding: 0.5rem 0.8rem;
            color: #ccc;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.85rem;
         }

         .subpackage-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            transform: translateX(4px);
         }

         .empty-state {
            color: rgba(177, 175, 175, 0.6);
            font-style: italic;
            font-size: 0.8rem;
         }

         .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.1);
            color: #ddd;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 500;
            margin-left: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .method-badge {
            background: rgba(100, 200, 255, 0.2);
            color: #87ceeb;
         }

         .const-badge {
            background: rgba(255, 200, 100, 0.2);
            color: #ffd700;
         }

         .var-badge {
            background: rgba(200, 255, 100, 0.2);
            color: #90ee90;
         }

         .type-badge {
            background: rgba(255, 100, 200, 0.2);
            color: #699eff;
         }

         .interface-badge {
            background: rgba(150, 100, 255, 0.2);
            color: #dda0dd;
         }

         .toc {
            position: sticky;
            top: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
         }

         .toc h4 {
            margin: 0 0 0.8rem;
            font-size: 0.9rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
         }

         .toc ul {
            list-style: none;
            padding: 0;
            margin: 0;
         }

         .toc li {
            margin-bottom: 0.3rem;
         }

         .toc a {
            color: #bbb;
            text-decoration: none;
            font-size: 0.8rem;
            transition: color 0.2s ease;
         }

         .toc a:hover {
            color: #fff;
         }

         .symbol-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
         }

         .symbol-list::-webkit-scrollbar {
            width: 4px;
         }

         .symbol-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
         }

         .symbol-list ul {
            list-style: none;
            padding: 0.5rem;
            margin: 0;
         }

         .symbol-list li {
            margin-bottom: 0.2rem;
         }

         .symbol-list a {
            display: block;
            padding: 0.3rem 0.5rem;
            color: #bbb;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.2s ease;
            font-size: 0.75rem;
         }

         .symbol-list a:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
         }

         @media (max-width: 768px) {
            body {
               flex-direction: column;
            }

            .sidebar {
               width: 90%;
               height: auto;
               position: relative;
            }

            main {
               max-width: 100%;
               padding: 1rem;
            }
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <div class="nav-links">
            <a href="index.html" title="Home">⌂</a>
            <span>|</span>
            <a href="#" onclick="history.back()" title="Back">←</a>
         </div>

         <div class="filter-section">
            <h3>Search</h3>
            <input
               type="search"
               id="searchInput"
               placeholder="Search symbols..."
            />
         </div>

         <div class="filter-section">
            <h3>Filters</h3>
            <div class="filter-toggle">
               <label>
                  <input type="checkbox" id="showImports" />
                  Show imports
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFunctions" />
                  Show private functions
               </label>
               <label>
                  <input type="checkbox" id="showPrivateStructs" />
                  Show private structs
               </label>
               <label>
                  <input type="checkbox" id="showPrivateFields" />
                  Show private fields
               </label>
               <label>
                  <input type="checkbox" id="showPrivateGlobals" />
                  Show private globals
               </label>
               <label>
                  <input type="checkbox" id="showPrivateTypes" />
                  Show private types
               </label>
               <label>
                  <input type="checkbox" id="showPrivateInterfaces" />
                  Show private interfaces
               </label>
            </div>
         </div>

         <div class="section-divider"></div>

         <div class="filter-section">
            <h3>Subpackages</h3>
            
            <div class="empty-state">No subpackages</div>
            
         </div>

         
         <div class="section-divider"></div>

         <div class="toc">
            <h4>Quick Navigation</h4>
            <ul>
               
               <li><a href="#globals">Constants & Variables</a></li>
                
               <li><a href="#types">Type Aliases</a></li>
                
               <li><a href="#interfaces">Interfaces</a></li>
                
               <li><a href="#structs">Structs</a></li>
                
               <li><a href="#functions">Functions</a></li>
               
            </ul>
         </div>

         <div class="filter-section">
            <h3>All Symbols</h3>
            <div class="symbol-list">
               <ul id="symbolIndex">
               </ul>
            </div>
         </div>
         
      </aside>

      <main>
         <h1>main</h1>
         <div class="section-divider"></div>

         
         <section id="imports">
            <h2>Imports</h2>
            <article class="imports symbol-anchor" id="imports-section" data-name="imports">
               <h3>
                  Imports
                  <a href="#imports-section" class="anchor" title="Link to imports">#</a>
               </h3>
               <pre><code>"fmt"
"internal/trace"
"internal/trace/traceviewer"
"internal/trace/traceviewer/format"
"cmp"
"log"
"math"
"net/http"
"slices"
"strconv"
"time"
"internal/trace"
"internal/trace/traceviewer"
"fmt"
"internal/trace"
"internal/trace/traceviewer"
"internal/trace/traceviewer/format"
"cmp"
"fmt"
"html/template"
"internal/trace"
"internal/trace/traceviewer"
"net/http"
"net/url"
"slices"
"sort"
"strconv"
"strings"
"time"
"bytes"
"cmp"
"fmt"
"html/template"
"internal/trace"
"internal/trace/traceviewer"
"log"
"net/http"
"slices"
"strings"
"time"
"fmt"
"internal/trace"
"internal/trace/traceviewer"
"time"
"fmt"
"internal/trace"
"internal/trace/traceviewer"
"strings"
"internal/trace"
"cmp"
"fmt"
"html/template"
"internal/trace"
"internal/trace/traceviewer"
"log"
"net/http"
"slices"
"sort"
"strings"
"time"
"fmt"
"internal/trace"
"internal/trace/traceviewer"
"internal/trace/traceviewer/format"
"strings"
"cmd/internal/browser"
"cmd/internal/telemetry/counter"
"cmp"
"flag"
"fmt"
"internal/trace"
"internal/trace/event"
"internal/trace/raw"
"internal/trace/traceviewer"
"io"
"log"
"net"
"net/http"
_ "net/http/pprof"
"os"
"slices"
"sync/atomic"
"text/tabwriter"
"time"
"cmp"
"fmt"
"internal/trace"
"internal/trace/traceviewer"
"net/http"
"slices"
"strings"
"time"
</code></pre>
            </article>
         </section>
          
         <section id="globals">
            <h2>Constants & Variables</h2>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ generator = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ generator = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="_" data-name="_">
               <h3>
                  _ 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#_" class="anchor" title="Link to _">#</a>
               </h3>
               
               <pre><code>var _ generator = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="debugFlag" data-name="debugFlag">
               <h3>
                  debugFlag 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#debugFlag" class="anchor" title="Link to debugFlag">#</a>
               </h3>
               
               <pre><code>var debugFlag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="httpFlag" data-name="httpFlag">
               <h3>
                  httpFlag 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#httpFlag" class="anchor" title="Link to httpFlag">#</a>
               </h3>
               
               <pre><code>var httpFlag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="noResource" data-name="noResource">
               <h3>
                  noResource 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#noResource" class="anchor" title="Link to noResource">#</a>
               </h3>
               
               <p>noResource indicates the lack of a resource.</p>
               
               <pre><code>const noResource = *ast.UnaryExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pprofFlag" data-name="pprofFlag">
               <h3>
                  pprofFlag 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#pprofFlag" class="anchor" title="Link to pprofFlag">#</a>
               </h3>
               
               <pre><code>var pprofFlag = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="pprofMaxStack" data-name="pprofMaxStack">
               <h3>
                  pprofMaxStack 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#pprofMaxStack" class="anchor" title="Link to pprofMaxStack">#</a>
               </h3>
               
               <p>pprofMaxStack is the extent of the deduplication we're willing to do.
Because slices aren't comparable and we want to leverage maps for deduplication,
we have to choose a fixed constant upper bound on the amount of frames we want
to support. In practice this is fine because there's a maximum depth to these
stacks anyway.</p>
               
               <pre><code>const pprofMaxStack = 128</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="programBinary" data-name="programBinary">
               <h3>
                  programBinary 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#programBinary" class="anchor" title="Link to programBinary">#</a>
               </h3>
               
               <p>The binary file name, left here for serveSVGProfile.</p>
               
               <pre><code>var programBinary string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="templGoroutine" data-name="templGoroutine">
               <h3>
                  templGoroutine 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#templGoroutine" class="anchor" title="Link to templGoroutine">#</a>
               </h3>
               
               <pre><code>var templGoroutine = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="templGoroutines" data-name="templGoroutines">
               <h3>
                  templGoroutines 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#templGoroutines" class="anchor" title="Link to templGoroutines">#</a>
               </h3>
               
               <pre><code>var templGoroutines = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="templUserRegionType" data-name="templUserRegionType">
               <h3>
                  templUserRegionType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#templUserRegionType" class="anchor" title="Link to templUserRegionType">#</a>
               </h3>
               
               <pre><code>var templUserRegionType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="templUserRegionTypes" data-name="templUserRegionTypes">
               <h3>
                  templUserRegionTypes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#templUserRegionTypes" class="anchor" title="Link to templUserRegionTypes">#</a>
               </h3>
               
               <pre><code>var templUserRegionTypes = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="templUserTaskType" data-name="templUserTaskType">
               <h3>
                  templUserTaskType 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#templUserTaskType" class="anchor" title="Link to templUserTaskType">#</a>
               </h3>
               
               <pre><code>var templUserTaskType = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="templUserTaskTypes" data-name="templUserTaskTypes">
               <h3>
                  templUserTaskTypes 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#templUserTaskTypes" class="anchor" title="Link to templUserTaskTypes">#</a>
               </h3>
               
               <pre><code>var templUserTaskTypes = *ast.CallExpr</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="traceFile" data-name="traceFile">
               <h3>
                  traceFile 
                  <span class="badge var-badge">var</span>
                  
                  <a href="#traceFile" class="anchor" title="Link to traceFile">#</a>
               </h3>
               
               <pre><code>var traceFile string</code></pre>
            </article>
            
            <article class="global symbol-anchor" id="usageMessage" data-name="usageMessage">
               <h3>
                  usageMessage 
                  <span class="badge const-badge">const</span>
                  
                  <a href="#usageMessage" class="anchor" title="Link to usageMessage">#</a>
               </h3>
               
               <pre><code>const usageMessage = *ast.BinaryExpr</code></pre>
            </article>
            
         </section>
          
         <section id="types">
            <h2>Type Aliases</h2>
            
            <article class="type symbol-anchor" id="byteCount" data-name="byteCount">
               <h3>
                  byteCount
                  <span class="badge type-badge">type</span>
                  <a href="#byteCount" class="anchor" title="Link to byteCount">#</a>
               </h3>
               
               <pre><code>type byteCount int64</code></pre>
            </article>
            
            <article class="type symbol-anchor" id="computePprofFunc" data-name="computePprofFunc">
               <h3>
                  computePprofFunc
                  <span class="badge type-badge">type</span>
                  <a href="#computePprofFunc" class="anchor" title="Link to computePprofFunc">#</a>
               </h3>
               
               <pre><code>type computePprofFunc func(gToIntervals map[trace.GoID][]interval, events []trace.Event) ([]traceviewer.ProfileRecord, error)</code></pre>
            </article>
            
         </section>
          
         <section id="interfaces">
            <h2>Interfaces</h2>
            
            <article class="interface symbol-anchor" id="generator" data-name="generator">
               <h3>
                  generator
                  <span class="badge interface-badge">interface</span>
                  <a href="#generator" class="anchor" title="Link to generator">#</a>
               </h3>
               
               <p>generator is an interface for generating a JSON trace for the trace viewer
from a trace. Each method in this interface is a handler for a kind of event
that is interesting to render in the UI via the JSON trace.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type generator interface {
Sync()
StackSample(ctx *traceContext, ev *trace.Event)
GlobalRange(ctx *traceContext, ev *trace.Event)
GlobalMetric(ctx *traceContext, ev *trace.Event)
GoroutineLabel(ctx *traceContext, ev *trace.Event)
GoroutineRange(ctx *traceContext, ev *trace.Event)
GoroutineTransition(ctx *traceContext, ev *trace.Event)
ProcRange(ctx *traceContext, ev *trace.Event)
ProcTransition(ctx *traceContext, ev *trace.Event)
Log(ctx *traceContext, ev *trace.Event)
Finish(ctx *traceContext)
}</code></pre>
            </article>
            
            <article class="interface symbol-anchor" id="resource" data-name="resource">
               <h3>
                  resource
                  <span class="badge interface-badge">interface</span>
                  <a href="#resource" class="anchor" title="Link to resource">#</a>
               </h3>
               
               <p>resource is a generic constraint interface for resource IDs.</p>
               
               <pre
                  class="methods-block"
               ><code class="methods-code">type resource interface {
*ast.BinaryExpr
}</code></pre>
            </article>
            
         </section>
          
         <section id="structs">
            <h2>Structs</h2>
            
            <article class="struct symbol-anchor" id="activeRange" data-name="activeRange">
               <h3>
                  activeRange
                  <span class="badge">struct</span>
                  <a href="#activeRange" class="anchor" title="Link to activeRange">#</a>
               </h3>
               
               <p>activeRange represents an active EventRange* range.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type activeRange struct {
time trace.Time
stack trace.Stack
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="completedRange" data-name="completedRange">
               <h3>
                  completedRange
                  <span class="badge">struct</span>
                  <a href="#completedRange" class="anchor" title="Link to completedRange">#</a>
               </h3>
               
               <p>completedRange represents a completed EventRange* range.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type completedRange struct {
name string
startTime trace.Time
endTime trace.Time
startStack trace.Stack
endStack trace.Stack
arg any
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="countingReader" data-name="countingReader">
               <h3>
                  countingReader
                  <span class="badge">struct</span>
                  <a href="#countingReader" class="anchor" title="Link to countingReader">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type countingReader struct {
r io.Reader
bytesRead atomic.Int64
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="gState" data-name="gState">
               <h3>
                  gState
                  <span class="badge">struct</span>
                  <a href="#gState" class="anchor" title="Link to gState">#</a>
               </h3>
               
               <p>gState represents the trace viewer state of a goroutine in a trace.
The type parameter on this type is the resource which is used to construct
a timeline of events. e.g. R=ProcID for a proc-oriented view, R=GoID for
a goroutine-oriented view, etc.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type gState struct {
baseName string
named bool
label string
isSystemG bool
executing R
lastStopStack trace.Stack
activeRanges map[string]activeRange
completedRanges []completedRange
startRunningTime trace.Time
syscall struct{...}
startBlockReason string
startCause struct{...}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="genOpts" data-name="genOpts">
               <h3>
                  genOpts
                  <span class="badge">struct</span>
                  <a href="#genOpts" class="anchor" title="Link to genOpts">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type genOpts struct {
mode traceviewer.Mode
startTime time.Duration
endTime time.Duration
focusGoroutine trace.GoID
goroutines map[trace.GoID]struct{...}
tasks []*trace.UserTaskSummary
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="globalMetricGenerator" data-name="globalMetricGenerator">
               <h3>
                  globalMetricGenerator
                  <span class="badge">struct</span>
                  <a href="#globalMetricGenerator" class="anchor" title="Link to globalMetricGenerator">#</a>
               </h3>
               
               <p>globalMetricGenerator implements a generic handler for Metric events.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type globalMetricGenerator struct {

}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="globalRangeGenerator" data-name="globalRangeGenerator">
               <h3>
                  globalRangeGenerator
                  <span class="badge">struct</span>
                  <a href="#globalRangeGenerator" class="anchor" title="Link to globalRangeGenerator">#</a>
               </h3>
               
               <p>globalRangeGenerator implements a generic handler for EventRange* events that pertain
to trace.ResourceNone (the global scope).</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type globalRangeGenerator struct {
ranges map[string]activeRange
seenSync bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="goroutineGenerator" data-name="goroutineGenerator">
               <h3>
                  goroutineGenerator
                  <span class="badge">struct</span>
                  <a href="#goroutineGenerator" class="anchor" title="Link to goroutineGenerator">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type goroutineGenerator struct {
globalRangeGenerator
globalMetricGenerator
*ast.IndexExpr
*ast.IndexExpr
gStates map[trace.GoID]**ast.IndexExpr
focus trace.GoID
filter map[trace.GoID]struct{...}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="interval" data-name="interval">
               <h3>
                  interval
                  <span class="badge">struct</span>
                  <a href="#interval" class="anchor" title="Link to interval">#</a>
               </h3>
               
               <p>interval represents a time interval in the trace.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type interval struct {
start trace.Time
end trace.Time
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="logEventGenerator" data-name="logEventGenerator">
               <h3>
                  logEventGenerator
                  <span class="badge">struct</span>
                  <a href="#logEventGenerator" class="anchor" title="Link to logEventGenerator">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type logEventGenerator struct {
getResource func(*trace.Event) R
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="parsedTrace" data-name="parsedTrace">
               <h3>
                  parsedTrace
                  <span class="badge">struct</span>
                  <a href="#parsedTrace" class="anchor" title="Link to parsedTrace">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type parsedTrace struct {
events []trace.Event
summary *trace.Summary
size int64
valid int64
err error
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="procGenerator" data-name="procGenerator">
               <h3>
                  procGenerator
                  <span class="badge">struct</span>
                  <a href="#procGenerator" class="anchor" title="Link to procGenerator">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type procGenerator struct {
globalRangeGenerator
globalMetricGenerator
procRangeGenerator
*ast.IndexExpr
*ast.IndexExpr
gStates map[trace.GoID]**ast.IndexExpr
inSyscall map[trace.ProcID]**ast.IndexExpr
maxProc trace.ProcID
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="procRangeGenerator" data-name="procRangeGenerator">
               <h3>
                  procRangeGenerator
                  <span class="badge">struct</span>
                  <a href="#procRangeGenerator" class="anchor" title="Link to procRangeGenerator">#</a>
               </h3>
               
               <p>procRangeGenerator implements a generic handler for EventRange* events whose Scope.Kind is
ResourceProc.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type procRangeGenerator struct {
ranges map[trace.Range]activeRange
seenSync bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="regionFilter" data-name="regionFilter">
               <h3>
                  regionFilter
                  <span class="badge">struct</span>
                  <a href="#regionFilter" class="anchor" title="Link to regionFilter">#</a>
               </h3>
               
               <p>regionFilter represents a region filter specified by a user of cmd/trace.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type regionFilter struct {
name string
params url.Values
cond []func(*parsedTrace, *trace.UserRegionSummary) bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="regionFingerprint" data-name="regionFingerprint">
               <h3>
                  regionFingerprint
                  <span class="badge">struct</span>
                  <a href="#regionFingerprint" class="anchor" title="Link to regionFingerprint">#</a>
               </h3>
               
               <p>regionFingerprint is a way to categorize regions that goes just one step beyond the region's Type
by including the top stack frame.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type regionFingerprint struct {
Frame trace.StackFrame
Type string
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="regionStats" data-name="regionStats">
               <h3>
                  regionStats
                  <span class="badge">struct</span>
                  <a href="#regionStats" class="anchor" title="Link to regionStats">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type regionStats struct {
regionFingerprint
Histogram traceviewer.TimeHistogram
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="stackMap" data-name="stackMap">
               <h3>
                  stackMap
                  <span class="badge">struct</span>
                  <a href="#stackMap" class="anchor" title="Link to stackMap">#</a>
               </h3>
               
               <p>stackMap is a map of trace.Stack to some value V.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stackMap struct {
stacks map[trace.Stack]*traceviewer.ProfileRecord
pcs map[[pprofMaxStack]uint64]trace.Stack
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="stackSampleGenerator" data-name="stackSampleGenerator">
               <h3>
                  stackSampleGenerator
                  <span class="badge">struct</span>
                  <a href="#stackSampleGenerator" class="anchor" title="Link to stackSampleGenerator">#</a>
               </h3>
               
               <p>stackSampleGenerator implements a generic handler for stack sample events.
The provided resource is the resource the stack sample should count against.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type stackSampleGenerator struct {
getResource func(*trace.Event) R
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="taskFilter" data-name="taskFilter">
               <h3>
                  taskFilter
                  <span class="badge">struct</span>
                  <a href="#taskFilter" class="anchor" title="Link to taskFilter">#</a>
               </h3>
               
               <p>taskFilter represents a task filter specified by a user of cmd/trace.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type taskFilter struct {
name string
cond []func(*parsedTrace, *trace.UserTaskSummary) bool
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="taskStats" data-name="taskStats">
               <h3>
                  taskStats
                  <span class="badge">struct</span>
                  <a href="#taskStats" class="anchor" title="Link to taskStats">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type taskStats struct {
Type string
Count int
Histogram traceviewer.TimeHistogram
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="threadGenerator" data-name="threadGenerator">
               <h3>
                  threadGenerator
                  <span class="badge">struct</span>
                  <a href="#threadGenerator" class="anchor" title="Link to threadGenerator">#</a>
               </h3>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type threadGenerator struct {
globalRangeGenerator
globalMetricGenerator
*ast.IndexExpr
*ast.IndexExpr
gStates map[trace.GoID]**ast.IndexExpr
threads map[trace.ThreadID]struct{...}
}</code></pre>
            </article>
            
            <article class="struct symbol-anchor" id="traceContext" data-name="traceContext">
               <h3>
                  traceContext
                  <span class="badge">struct</span>
                  <a href="#traceContext" class="anchor" title="Link to traceContext">#</a>
               </h3>
               
               <p>traceContext is a wrapper around a traceviewer.Emitter with some additional
information that's useful to most parts of trace viewer JSON emission.</p>
               
               <pre
                  class="fields-block"
               ><code class="fields-code">type traceContext struct {
*traceviewer.Emitter
startTime trace.Time
endTime trace.Time
}</code></pre>
            </article>
            
         </section>
          
         <section id="functions">
            <h2>Functions</h2>
            
            <article class="function symbol-anchor" id="Finish" data-name="Finish">
               <h3>
                  Finish 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Finish" class="anchor" title="Link to Finish">#</a>
               </h3>
               
               <p>Finish flushes any outstanding ranges at the end of the trace.</p>
               
               <pre><code>func (g *procRangeGenerator) Finish(ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Finish" data-name="Finish">
               <h3>
                  Finish 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Finish" class="anchor" title="Link to Finish">#</a>
               </h3>
               
               <pre><code>func (g *procGenerator) Finish(ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Finish" data-name="Finish">
               <h3>
                  Finish 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Finish" class="anchor" title="Link to Finish">#</a>
               </h3>
               
               <pre><code>func (g *goroutineGenerator) Finish(ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Finish" data-name="Finish">
               <h3>
                  Finish 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Finish" class="anchor" title="Link to Finish">#</a>
               </h3>
               
               <p>Finish flushes any outstanding ranges at the end of the trace.</p>
               
               <pre><code>func (g *globalRangeGenerator) Finish(ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Finish" data-name="Finish">
               <h3>
                  Finish 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Finish" class="anchor" title="Link to Finish">#</a>
               </h3>
               
               <pre><code>func (g *threadGenerator) Finish(ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GlobalMetric" data-name="GlobalMetric">
               <h3>
                  GlobalMetric 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GlobalMetric" class="anchor" title="Link to GlobalMetric">#</a>
               </h3>
               
               <p>GlobalMetric implements an event handler for EventMetric events. ev must be one such event.</p>
               
               <pre><code>func (g *globalMetricGenerator) GlobalMetric(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GlobalRange" data-name="GlobalRange">
               <h3>
                  GlobalRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GlobalRange" class="anchor" title="Link to GlobalRange">#</a>
               </h3>
               
               <p>GlobalRange implements a handler for EventRange* events whose Scope.Kind is ResourceNone.
It expects ev to be one such event.</p>
               
               <pre><code>func (g *globalRangeGenerator) GlobalRange(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoroutineHandler" data-name="GoroutineHandler">
               <h3>
                  GoroutineHandler 
                  <span class="badge">function</span>
                  
                  <a href="#GoroutineHandler" class="anchor" title="Link to GoroutineHandler">#</a>
               </h3>
               
               <p>GoroutineHandler creates a handler that serves information about
goroutines in a particular group.</p>
               
               <pre><code>func GoroutineHandler(summaries map[trace.GoID]*trace.GoroutineSummary) http.HandlerFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoroutineLabel" data-name="GoroutineLabel">
               <h3>
                  GoroutineLabel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoroutineLabel" class="anchor" title="Link to GoroutineLabel">#</a>
               </h3>
               
               <pre><code>func (g *goroutineGenerator) GoroutineLabel(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoroutineLabel" data-name="GoroutineLabel">
               <h3>
                  GoroutineLabel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoroutineLabel" class="anchor" title="Link to GoroutineLabel">#</a>
               </h3>
               
               <pre><code>func (g *procGenerator) GoroutineLabel(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoroutineLabel" data-name="GoroutineLabel">
               <h3>
                  GoroutineLabel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoroutineLabel" class="anchor" title="Link to GoroutineLabel">#</a>
               </h3>
               
               <pre><code>func (g *threadGenerator) GoroutineLabel(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoroutineRange" data-name="GoroutineRange">
               <h3>
                  GoroutineRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoroutineRange" class="anchor" title="Link to GoroutineRange">#</a>
               </h3>
               
               <pre><code>func (g *goroutineGenerator) GoroutineRange(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoroutineRange" data-name="GoroutineRange">
               <h3>
                  GoroutineRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoroutineRange" class="anchor" title="Link to GoroutineRange">#</a>
               </h3>
               
               <pre><code>func (g *threadGenerator) GoroutineRange(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoroutineRange" data-name="GoroutineRange">
               <h3>
                  GoroutineRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoroutineRange" class="anchor" title="Link to GoroutineRange">#</a>
               </h3>
               
               <pre><code>func (g *procGenerator) GoroutineRange(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoroutineTransition" data-name="GoroutineTransition">
               <h3>
                  GoroutineTransition 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoroutineTransition" class="anchor" title="Link to GoroutineTransition">#</a>
               </h3>
               
               <pre><code>func (g *procGenerator) GoroutineTransition(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoroutineTransition" data-name="GoroutineTransition">
               <h3>
                  GoroutineTransition 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoroutineTransition" class="anchor" title="Link to GoroutineTransition">#</a>
               </h3>
               
               <pre><code>func (g *goroutineGenerator) GoroutineTransition(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoroutineTransition" data-name="GoroutineTransition">
               <h3>
                  GoroutineTransition 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#GoroutineTransition" class="anchor" title="Link to GoroutineTransition">#</a>
               </h3>
               
               <pre><code>func (g *threadGenerator) GoroutineTransition(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="GoroutinesHandlerFunc" data-name="GoroutinesHandlerFunc">
               <h3>
                  GoroutinesHandlerFunc 
                  <span class="badge">function</span>
                  
                  <a href="#GoroutinesHandlerFunc" class="anchor" title="Link to GoroutinesHandlerFunc">#</a>
               </h3>
               
               <p>GoroutinesHandlerFunc returns a HandlerFunc that serves list of goroutine groups.</p>
               
               <pre><code>func GoroutinesHandlerFunc(summaries map[trace.GoID]*trace.GoroutineSummary) http.HandlerFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="JSONTraceHandler" data-name="JSONTraceHandler">
               <h3>
                  JSONTraceHandler 
                  <span class="badge">function</span>
                  
                  <a href="#JSONTraceHandler" class="anchor" title="Link to JSONTraceHandler">#</a>
               </h3>
               
               <pre><code>func JSONTraceHandler(parsed *parsedTrace) http.Handler</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Log" data-name="Log">
               <h3>
                  Log 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Log" class="anchor" title="Link to Log">#</a>
               </h3>
               
               <p>Log implements a log event handler. It expects ev to be one such event.</p>
               
               <pre><code>func (g **ast.IndexExpr) Log(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProcRange" data-name="ProcRange">
               <h3>
                  ProcRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ProcRange" class="anchor" title="Link to ProcRange">#</a>
               </h3>
               
               <pre><code>func (g *goroutineGenerator) ProcRange(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProcRange" data-name="ProcRange">
               <h3>
                  ProcRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ProcRange" class="anchor" title="Link to ProcRange">#</a>
               </h3>
               
               <p>ProcRange implements a handler for EventRange* events whose Scope.Kind is ResourceProc.
It expects ev to be one such event.</p>
               
               <pre><code>func (g *procRangeGenerator) ProcRange(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProcRange" data-name="ProcRange">
               <h3>
                  ProcRange 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ProcRange" class="anchor" title="Link to ProcRange">#</a>
               </h3>
               
               <pre><code>func (g *threadGenerator) ProcRange(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProcTransition" data-name="ProcTransition">
               <h3>
                  ProcTransition 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ProcTransition" class="anchor" title="Link to ProcTransition">#</a>
               </h3>
               
               <pre><code>func (g *threadGenerator) ProcTransition(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProcTransition" data-name="ProcTransition">
               <h3>
                  ProcTransition 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ProcTransition" class="anchor" title="Link to ProcTransition">#</a>
               </h3>
               
               <pre><code>func (g *goroutineGenerator) ProcTransition(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="ProcTransition" data-name="ProcTransition">
               <h3>
                  ProcTransition 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#ProcTransition" class="anchor" title="Link to ProcTransition">#</a>
               </h3>
               
               <pre><code>func (g *procGenerator) ProcTransition(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Read" data-name="Read">
               <h3>
                  Read 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Read" class="anchor" title="Link to Read">#</a>
               </h3>
               
               <pre><code>func (c *countingReader) Read(buf []byte) (n int, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="StackSample" data-name="StackSample">
               <h3>
                  StackSample 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#StackSample" class="anchor" title="Link to StackSample">#</a>
               </h3>
               
               <p>StackSample implements a stack sample event handler. It expects ev to be one such event.</p>
               
               <pre><code>func (g **ast.IndexExpr) StackSample(ctx *traceContext, ev *trace.Event)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="String" data-name="String">
               <h3>
                  String 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#String" class="anchor" title="Link to String">#</a>
               </h3>
               
               <pre><code>func (b byteCount) String() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sync" data-name="Sync">
               <h3>
                  Sync 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sync" class="anchor" title="Link to Sync">#</a>
               </h3>
               
               <pre><code>func (g *procGenerator) Sync()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sync" data-name="Sync">
               <h3>
                  Sync 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sync" class="anchor" title="Link to Sync">#</a>
               </h3>
               
               <p>Sync notifies the generator of an EventSync event.</p>
               
               <pre><code>func (g *procRangeGenerator) Sync()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sync" data-name="Sync">
               <h3>
                  Sync 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sync" class="anchor" title="Link to Sync">#</a>
               </h3>
               
               <p>Sync notifies the generator of an EventSync event.</p>
               
               <pre><code>func (g *globalRangeGenerator) Sync()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sync" data-name="Sync">
               <h3>
                  Sync 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sync" class="anchor" title="Link to Sync">#</a>
               </h3>
               
               <pre><code>func (g *threadGenerator) Sync()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="Sync" data-name="Sync">
               <h3>
                  Sync 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#Sync" class="anchor" title="Link to Sync">#</a>
               </h3>
               
               <pre><code>func (g *goroutineGenerator) Sync()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UserRegionHandlerFunc" data-name="UserRegionHandlerFunc">
               <h3>
                  UserRegionHandlerFunc 
                  <span class="badge">function</span>
                  
                  <a href="#UserRegionHandlerFunc" class="anchor" title="Link to UserRegionHandlerFunc">#</a>
               </h3>
               
               <p>UserRegionHandlerFunc returns a HandlerFunc that presents the details of the selected regions.</p>
               
               <pre><code>func UserRegionHandlerFunc(t *parsedTrace) http.HandlerFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UserRegionURL" data-name="UserRegionURL">
               <h3>
                  UserRegionURL 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UserRegionURL" class="anchor" title="Link to UserRegionURL">#</a>
               </h3>
               
               <pre><code>func (s *regionStats) UserRegionURL() (func(min time.Duration, max time.Duration) string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UserRegionsHandlerFunc" data-name="UserRegionsHandlerFunc">
               <h3>
                  UserRegionsHandlerFunc 
                  <span class="badge">function</span>
                  
                  <a href="#UserRegionsHandlerFunc" class="anchor" title="Link to UserRegionsHandlerFunc">#</a>
               </h3>
               
               <p>UserRegionsHandlerFunc returns a HandlerFunc that reports all regions found in the trace.</p>
               
               <pre><code>func UserRegionsHandlerFunc(t *parsedTrace) http.HandlerFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UserTaskHandlerFunc" data-name="UserTaskHandlerFunc">
               <h3>
                  UserTaskHandlerFunc 
                  <span class="badge">function</span>
                  
                  <a href="#UserTaskHandlerFunc" class="anchor" title="Link to UserTaskHandlerFunc">#</a>
               </h3>
               
               <p>UserTaskHandlerFunc returns a HandlerFunc that presents the details of the selected tasks.</p>
               
               <pre><code>func UserTaskHandlerFunc(t *parsedTrace) http.HandlerFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UserTaskURL" data-name="UserTaskURL">
               <h3>
                  UserTaskURL 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#UserTaskURL" class="anchor" title="Link to UserTaskURL">#</a>
               </h3>
               
               <pre><code>func (s *taskStats) UserTaskURL(complete bool) (func(min time.Duration, max time.Duration) string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="UserTasksHandlerFunc" data-name="UserTasksHandlerFunc">
               <h3>
                  UserTasksHandlerFunc 
                  <span class="badge">function</span>
                  
                  <a href="#UserTasksHandlerFunc" class="anchor" title="Link to UserTasksHandlerFunc">#</a>
               </h3>
               
               <p>UserTasksHandlerFunc returns a HandlerFunc that reports all tasks found in the trace.</p>
               
               <pre><code>func UserTasksHandlerFunc(t *parsedTrace) http.HandlerFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code>func (s *taskStats) add(task *trace.UserTaskSummary)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="add" data-name="add">
               <h3>
                  add 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#add" class="anchor" title="Link to add">#</a>
               </h3>
               
               <pre><code>func (s *regionStats) add(t *parsedTrace, region *trace.UserRegionSummary)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="asMillisecond" data-name="asMillisecond">
               <h3>
                  asMillisecond 
                  <span class="badge">function</span>
                  
                  <a href="#asMillisecond" class="anchor" title="Link to asMillisecond">#</a>
               </h3>
               
               <pre><code>func asMillisecond(d time.Duration) float64</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="augmentName" data-name="augmentName">
               <h3>
                  augmentName 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#augmentName" class="anchor" title="Link to augmentName">#</a>
               </h3>
               
               <p>augmentName attempts to use stk to augment the name of the goroutine
with stack information. This stack must be related to the goroutine
in some way, but it doesn't really matter which stack.</p>
               
               <pre><code>func (gs **ast.IndexExpr) augmentName(stk trace.Stack)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="block" data-name="block">
               <h3>
                  block 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#block" class="anchor" title="Link to block">#</a>
               </h3>
               
               <p>block indicates that the goroutine has stopped executing on a proc -- specifically,
it blocked for some reason.</p>
               
               <pre><code>func (gs **ast.IndexExpr) block(ts trace.Time, stack trace.Stack, reason string, ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="blockedSyscallEnd" data-name="blockedSyscallEnd">
               <h3>
                  blockedSyscallEnd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#blockedSyscallEnd" class="anchor" title="Link to blockedSyscallEnd">#</a>
               </h3>
               
               <p>blockedSyscallEnd indicates the point at which the blocked syscall ended. This is distinct
and orthogonal to syscallEnd; both must be called if the syscall blocked. This sets up an instant
to emit a flow event from, indicating explicitly that this goroutine was unblocked by the system.</p>
               
               <pre><code>func (gs **ast.IndexExpr) blockedSyscallEnd(ts trace.Time, stack trace.Stack, ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computePprofBlock" data-name="computePprofBlock">
               <h3>
                  computePprofBlock 
                  <span class="badge">function</span>
                  
                  <a href="#computePprofBlock" class="anchor" title="Link to computePprofBlock">#</a>
               </h3>
               
               <p>computePprofBlock returns a computePprofFunc that generates blocking pprof-like profile
(time spent blocked on synchronization primitives).</p>
               
               <pre><code>func computePprofBlock() computePprofFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computePprofIO" data-name="computePprofIO">
               <h3>
                  computePprofIO 
                  <span class="badge">function</span>
                  
                  <a href="#computePprofIO" class="anchor" title="Link to computePprofIO">#</a>
               </h3>
               
               <p>computePprofIO returns a computePprofFunc that generates IO pprof-like profile (time spent in
IO wait, currently only network blocking event).</p>
               
               <pre><code>func computePprofIO() computePprofFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computePprofSched" data-name="computePprofSched">
               <h3>
                  computePprofSched 
                  <span class="badge">function</span>
                  
                  <a href="#computePprofSched" class="anchor" title="Link to computePprofSched">#</a>
               </h3>
               
               <p>computePprofSched returns a computePprofFunc that generates a scheduler latency pprof-like profile
(time between a goroutine become runnable and actually scheduled for execution).</p>
               
               <pre><code>func computePprofSched() computePprofFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="computePprofSyscall" data-name="computePprofSyscall">
               <h3>
                  computePprofSyscall 
                  <span class="badge">function</span>
                  
                  <a href="#computePprofSyscall" class="anchor" title="Link to computePprofSyscall">#</a>
               </h3>
               
               <p>computePprofSyscall returns a computePprofFunc that generates a syscall pprof-like
profile (time spent in syscalls).</p>
               
               <pre><code>func computePprofSyscall() computePprofFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="created" data-name="created">
               <h3>
                  created 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#created" class="anchor" title="Link to created">#</a>
               </h3>
               
               <p>created indicates that this goroutine was just created by the provided creator.</p>
               
               <pre><code>func (gs **ast.IndexExpr) created(ts trace.Time, creator R, stack trace.Stack)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="debugEventsFootprint" data-name="debugEventsFootprint">
               <h3>
                  debugEventsFootprint 
                  <span class="badge">function</span>
                  
                  <a href="#debugEventsFootprint" class="anchor" title="Link to debugEventsFootprint">#</a>
               </h3>
               
               <pre><code>func debugEventsFootprint(trc io.Reader) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="debugProcessedEvents" data-name="debugProcessedEvents">
               <h3>
                  debugProcessedEvents 
                  <span class="badge">function</span>
                  
                  <a href="#debugProcessedEvents" class="anchor" title="Link to debugProcessedEvents">#</a>
               </h3>
               
               <pre><code>func debugProcessedEvents(trc io.Reader) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="debugRawEvents" data-name="debugRawEvents">
               <h3>
                  debugRawEvents 
                  <span class="badge">function</span>
                  
                  <a href="#debugRawEvents" class="anchor" title="Link to debugRawEvents">#</a>
               </h3>
               
               <pre><code>func debugRawEvents(trc io.Reader) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="defaultGenOpts" data-name="defaultGenOpts">
               <h3>
                  defaultGenOpts 
                  <span class="badge">function</span>
                  
                  <a href="#defaultGenOpts" class="anchor" title="Link to defaultGenOpts">#</a>
               </h3>
               
               <pre><code>func defaultGenOpts() *genOpts</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="describeEvent" data-name="describeEvent">
               <h3>
                  describeEvent 
                  <span class="badge">function</span>
                  
                  <a href="#describeEvent" class="anchor" title="Link to describeEvent">#</a>
               </h3>
               
               <pre><code>func describeEvent(ev *trace.Event) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="duration" data-name="duration">
               <h3>
                  duration 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#duration" class="anchor" title="Link to duration">#</a>
               </h3>
               
               <pre><code>func (i interval) duration() time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="elapsed" data-name="elapsed">
               <h3>
                  elapsed 
                  <span class="badge">function</span>
                  
                  <a href="#elapsed" class="anchor" title="Link to elapsed">#</a>
               </h3>
               
               <pre><code>func elapsed(d time.Duration) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="elapsed" data-name="elapsed">
               <h3>
                  elapsed 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#elapsed" class="anchor" title="Link to elapsed">#</a>
               </h3>
               
               <p>elapsed returns the elapsed time between the trace time and the start time
of the trace.</p>
               
               <pre><code>func (ctx *traceContext) elapsed(now trace.Time) time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitRegion" data-name="emitRegion">
               <h3>
                  emitRegion 
                  <span class="badge">function</span>
                  
                  <a href="#emitRegion" class="anchor" title="Link to emitRegion">#</a>
               </h3>
               
               <p>emitRegion emits goroutine-based slice events to the UI. The caller
must be emitting for a goroutine-oriented trace.
TODO(mknyszek): Make regions part of the regular generator loop and
treat them like ranges so that we can emit regions in traces oriented
by proc or thread.</p>
               
               <pre><code>func emitRegion(ctx *traceContext, region *trace.UserRegionSummary)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="emitTask" data-name="emitTask">
               <h3>
                  emitTask 
                  <span class="badge">function</span>
                  
                  <a href="#emitTask" class="anchor" title="Link to emitTask">#</a>
               </h3>
               
               <p>emitTask emits information about a task into the trace viewer's event stream.
sortIndex sets the order in which this task will appear related to other tasks,
lowest first.</p>
               
               <pre><code>func emitTask(ctx *traceContext, task *trace.UserTaskSummary, sortIndex int)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="endTime" data-name="endTime">
               <h3>
                  endTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#endTime" class="anchor" title="Link to endTime">#</a>
               </h3>
               
               <pre><code>func (t *parsedTrace) endTime() trace.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="fingerprintRegion" data-name="fingerprintRegion">
               <h3>
                  fingerprintRegion 
                  <span class="badge">function</span>
                  
                  <a href="#fingerprintRegion" class="anchor" title="Link to fingerprintRegion">#</a>
               </h3>
               
               <pre><code>func fingerprintRegion(r *trace.UserRegionSummary) regionFingerprint</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="finish" data-name="finish">
               <h3>
                  finish 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#finish" class="anchor" title="Link to finish">#</a>
               </h3>
               
               <p>finalize writes out any in-progress slices as if the goroutine stopped.
This must only be used once the trace has been fully processed and no
further events will be processed. This method may leave the gState in
an inconsistent state.</p>
               
               <pre><code>func (gs **ast.IndexExpr) finish(ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="generateTrace" data-name="generateTrace">
               <h3>
                  generateTrace 
                  <span class="badge">function</span>
                  
                  <a href="#generateTrace" class="anchor" title="Link to generateTrace">#</a>
               </h3>
               
               <pre><code>func generateTrace(parsed *parsedTrace, opts *genOpts, c traceviewer.TraceConsumer) error</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="getOrAdd" data-name="getOrAdd">
               <h3>
                  getOrAdd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#getOrAdd" class="anchor" title="Link to getOrAdd">#</a>
               </h3>
               
               <pre><code>func (m *stackMap) getOrAdd(stack trace.Stack) *traceviewer.ProfileRecord</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="lastFunc" data-name="lastFunc">
               <h3>
                  lastFunc 
                  <span class="badge">function</span>
                  
                  <a href="#lastFunc" class="anchor" title="Link to lastFunc">#</a>
               </h3>
               
               <pre><code>func lastFunc(s trace.Stack) (fn string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="logAndDie" data-name="logAndDie">
               <h3>
                  logAndDie 
                  <span class="badge">function</span>
                  
                  <a href="#logAndDie" class="anchor" title="Link to logAndDie">#</a>
               </h3>
               
               <pre><code>func logAndDie(err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="main" data-name="main">
               <h3>
                  main 
                  <span class="badge">function</span>
                  
                  <a href="#main" class="anchor" title="Link to main">#</a>
               </h3>
               
               <pre><code>func main()</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="makeComputePprofFunc" data-name="makeComputePprofFunc">
               <h3>
                  makeComputePprofFunc 
                  <span class="badge">function</span>
                  
                  <a href="#makeComputePprofFunc" class="anchor" title="Link to makeComputePprofFunc">#</a>
               </h3>
               
               <p>makeComputePprofFunc returns a computePprofFunc that generates a profile of time goroutines spend
in a particular state for the specified reasons.</p>
               
               <pre><code>func makeComputePprofFunc(state trace.GoState, trackReason func(string) bool) computePprofFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <p>match returns true if a task, described by its ID and summary, matches
the filter.</p>
               
               <pre><code>func (f *taskFilter) match(t *parsedTrace, task *trace.UserTaskSummary) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="match" data-name="match">
               <h3>
                  match 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#match" class="anchor" title="Link to match">#</a>
               </h3>
               
               <p>match returns true if a region, described by its ID and summary, matches
the filter.</p>
               
               <pre><code>func (f *regionFilter) match(t *parsedTrace, s *trace.UserRegionSummary) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="name" data-name="name">
               <h3>
                  name 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#name" class="anchor" title="Link to name">#</a>
               </h3>
               
               <p>name returns a name for the goroutine.</p>
               
               <pre><code>func (gs **ast.IndexExpr) name() string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newGState" data-name="newGState">
               <h3>
                  newGState 
                  <span class="badge">function</span>
                  
                  <a href="#newGState" class="anchor" title="Link to newGState">#</a>
               </h3>
               
               <p>newGState constructs a new goroutine state for the goroutine
identified by the provided ID.</p>
               
               <pre><code>func newGState(goID trace.GoID) **ast.IndexExpr</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newGoroutineGenerator" data-name="newGoroutineGenerator">
               <h3>
                  newGoroutineGenerator 
                  <span class="badge">function</span>
                  
                  <a href="#newGoroutineGenerator" class="anchor" title="Link to newGoroutineGenerator">#</a>
               </h3>
               
               <pre><code>func newGoroutineGenerator(ctx *traceContext, focus trace.GoID, filter map[trace.GoID]struct{...}) *goroutineGenerator</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newProcGenerator" data-name="newProcGenerator">
               <h3>
                  newProcGenerator 
                  <span class="badge">function</span>
                  
                  <a href="#newProcGenerator" class="anchor" title="Link to newProcGenerator">#</a>
               </h3>
               
               <pre><code>func newProcGenerator() *procGenerator</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newRegionFilter" data-name="newRegionFilter">
               <h3>
                  newRegionFilter 
                  <span class="badge">function</span>
                  
                  <a href="#newRegionFilter" class="anchor" title="Link to newRegionFilter">#</a>
               </h3>
               
               <p>newRegionFilter creates a new region filter from URL query variables.</p>
               
               <pre><code>func newRegionFilter(r *http.Request) (*regionFilter, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newStackMap" data-name="newStackMap">
               <h3>
                  newStackMap 
                  <span class="badge">function</span>
                  
                  <a href="#newStackMap" class="anchor" title="Link to newStackMap">#</a>
               </h3>
               
               <pre><code>func newStackMap() *stackMap</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newTaskFilter" data-name="newTaskFilter">
               <h3>
                  newTaskFilter 
                  <span class="badge">function</span>
                  
                  <a href="#newTaskFilter" class="anchor" title="Link to newTaskFilter">#</a>
               </h3>
               
               <p>newTaskFilter creates a new task filter from URL query variables.</p>
               
               <pre><code>func newTaskFilter(r *http.Request) (*taskFilter, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="newThreadGenerator" data-name="newThreadGenerator">
               <h3>
                  newThreadGenerator 
                  <span class="badge">function</span>
                  
                  <a href="#newThreadGenerator" class="anchor" title="Link to newThreadGenerator">#</a>
               </h3>
               
               <pre><code>func newThreadGenerator() *threadGenerator</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="overlap" data-name="overlap">
               <h3>
                  overlap 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#overlap" class="anchor" title="Link to overlap">#</a>
               </h3>
               
               <pre><code>func (i1 interval) overlap(i2 interval) time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseTrace" data-name="parseTrace">
               <h3>
                  parseTrace 
                  <span class="badge">function</span>
                  
                  <a href="#parseTrace" class="anchor" title="Link to parseTrace">#</a>
               </h3>
               
               <pre><code>func parseTrace(rr io.Reader, size int64) (*parsedTrace, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="parseTraceInteractive" data-name="parseTraceInteractive">
               <h3>
                  parseTraceInteractive 
                  <span class="badge">function</span>
                  
                  <a href="#parseTraceInteractive" class="anchor" title="Link to parseTraceInteractive">#</a>
               </h3>
               
               <pre><code>func parseTraceInteractive(tr io.Reader, size int64) (parsed *parsedTrace, err error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pcsForStack" data-name="pcsForStack">
               <h3>
                  pcsForStack 
                  <span class="badge">function</span>
                  
                  <a href="#pcsForStack" class="anchor" title="Link to pcsForStack">#</a>
               </h3>
               
               <p>pcsForStack extracts the first pprofMaxStack PCs from stack into pcs.</p>
               
               <pre><code>func pcsForStack(stack trace.Stack, pcs *[pprofMaxStack]uint64)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pprofByGoroutine" data-name="pprofByGoroutine">
               <h3>
                  pprofByGoroutine 
                  <span class="badge">function</span>
                  
                  <a href="#pprofByGoroutine" class="anchor" title="Link to pprofByGoroutine">#</a>
               </h3>
               
               <pre><code>func pprofByGoroutine(compute computePprofFunc, t *parsedTrace) traceviewer.ProfileFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pprofByRegion" data-name="pprofByRegion">
               <h3>
                  pprofByRegion 
                  <span class="badge">function</span>
                  
                  <a href="#pprofByRegion" class="anchor" title="Link to pprofByRegion">#</a>
               </h3>
               
               <pre><code>func pprofByRegion(compute computePprofFunc, t *parsedTrace) traceviewer.ProfileFunc</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pprofMatchingGoroutines" data-name="pprofMatchingGoroutines">
               <h3>
                  pprofMatchingGoroutines 
                  <span class="badge">function</span>
                  
                  <a href="#pprofMatchingGoroutines" class="anchor" title="Link to pprofMatchingGoroutines">#</a>
               </h3>
               
               <p>pprofMatchingGoroutines returns the ids of goroutines of the matching name and its interval.
If the id string is empty, returns nil without an error.</p>
               
               <pre><code>func pprofMatchingGoroutines(name string, t *parsedTrace) (map[trace.GoID][]interval, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pprofMatchingRegions" data-name="pprofMatchingRegions">
               <h3>
                  pprofMatchingRegions 
                  <span class="badge">function</span>
                  
                  <a href="#pprofMatchingRegions" class="anchor" title="Link to pprofMatchingRegions">#</a>
               </h3>
               
               <p>pprofMatchingRegions returns the time intervals of matching regions
grouped by the goroutine id. If the filter is nil, returns nil without an error.</p>
               
               <pre><code>func pprofMatchingRegions(filter *regionFilter, t *parsedTrace) (map[trace.GoID][]interval, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="pprofOverlappingDuration" data-name="pprofOverlappingDuration">
               <h3>
                  pprofOverlappingDuration 
                  <span class="badge">function</span>
                  
                  <a href="#pprofOverlappingDuration" class="anchor" title="Link to pprofOverlappingDuration">#</a>
               </h3>
               
               <p>pprofOverlappingDuration returns the overlapping duration between
the time intervals in gToIntervals and the specified event.
If gToIntervals is nil, this simply returns the event's duration.</p>
               
               <pre><code>func pprofOverlappingDuration(gToIntervals map[trace.GoID][]interval, id trace.GoID, sample interval) time.Duration</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="primaryGoroutine" data-name="primaryGoroutine">
               <h3>
                  primaryGoroutine 
                  <span class="badge">function</span>
                  
                  <a href="#primaryGoroutine" class="anchor" title="Link to primaryGoroutine">#</a>
               </h3>
               
               <pre><code>func primaryGoroutine(ev *trace.Event) trace.GoID</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="profile" data-name="profile">
               <h3>
                  profile 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#profile" class="anchor" title="Link to profile">#</a>
               </h3>
               
               <pre><code>func (m *stackMap) profile() []traceviewer.ProfileRecord</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rangeActive" data-name="rangeActive">
               <h3>
                  rangeActive 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rangeActive" class="anchor" title="Link to rangeActive">#</a>
               </h3>
               
               <p>rangeActive indicates that a special range of time has been in progress.</p>
               
               <pre><code>func (gs **ast.IndexExpr) rangeActive(name string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rangeBegin" data-name="rangeBegin">
               <h3>
                  rangeBegin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rangeBegin" class="anchor" title="Link to rangeBegin">#</a>
               </h3>
               
               <p>rangeBegin indicates the start of a special range of time.</p>
               
               <pre><code>func (gs **ast.IndexExpr) rangeBegin(ts trace.Time, name string, stack trace.Stack)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="rangeEnd" data-name="rangeEnd">
               <h3>
                  rangeEnd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#rangeEnd" class="anchor" title="Link to rangeEnd">#</a>
               </h3>
               
               <p>rangeEnd indicates the end of a special range of time.</p>
               
               <pre><code>func (gs **ast.IndexExpr) rangeEnd(ts trace.Time, name string, stack trace.Stack, ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="regionInterval" data-name="regionInterval">
               <h3>
                  regionInterval 
                  <span class="badge">function</span>
                  
                  <a href="#regionInterval" class="anchor" title="Link to regionInterval">#</a>
               </h3>
               
               <pre><code>func regionInterval(t *parsedTrace, s *trace.UserRegionSummary) interval</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="regionTopStackFrame" data-name="regionTopStackFrame">
               <h3>
                  regionTopStackFrame 
                  <span class="badge">function</span>
                  
                  <a href="#regionTopStackFrame" class="anchor" title="Link to regionTopStackFrame">#</a>
               </h3>
               
               <pre><code>func regionTopStackFrame(r *trace.UserRegionSummary) trace.StackFrame</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="runGenerator" data-name="runGenerator">
               <h3>
                  runGenerator 
                  <span class="badge">function</span>
                  
                  <a href="#runGenerator" class="anchor" title="Link to runGenerator">#</a>
               </h3>
               
               <p>runGenerator produces a trace into ctx by running the generator over the parsed trace.</p>
               
               <pre><code>func runGenerator(ctx *traceContext, g generator, parsed *parsedTrace, opts *genOpts)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setLabel" data-name="setLabel">
               <h3>
                  setLabel 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setLabel" class="anchor" title="Link to setLabel">#</a>
               </h3>
               
               <p>setLabel adds an additional label to the goroutine's name.</p>
               
               <pre><code>func (gs **ast.IndexExpr) setLabel(label string)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setStartCause" data-name="setStartCause">
               <h3>
                  setStartCause 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setStartCause" class="anchor" title="Link to setStartCause">#</a>
               </h3>
               
               <p>setStartCause sets the reason a goroutine will be allowed to start soon.
For example, via unblocking or exiting a blocked syscall.</p>
               
               <pre><code>func (gs **ast.IndexExpr) setStartCause(ts trace.Time, name string, resource uint64, stack trace.Stack)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="setTask" data-name="setTask">
               <h3>
                  setTask 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#setTask" class="anchor" title="Link to setTask">#</a>
               </h3>
               
               <p>setTask sets a task to focus on.</p>
               
               <pre><code>func (opts *genOpts) setTask(parsed *parsedTrace, task *trace.UserTaskSummary)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="splitTrace" data-name="splitTrace">
               <h3>
                  splitTrace 
                  <span class="badge">function</span>
                  
                  <a href="#splitTrace" class="anchor" title="Link to splitTrace">#</a>
               </h3>
               
               <p>splitTrace splits the trace into a number of ranges, each resulting in approx 100 MiB of
json output (the trace viewer can hardly handle more).</p>
               
               <pre><code>func splitTrace(parsed *parsedTrace) ([]traceviewer.Range, error)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="start" data-name="start">
               <h3>
                  start 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#start" class="anchor" title="Link to start">#</a>
               </h3>
               
               <p>start indicates that a goroutine has started running on a proc.</p>
               
               <pre><code>func (gs **ast.IndexExpr) start(ts trace.Time, resource R, ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="startTime" data-name="startTime">
               <h3>
                  startTime 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#startTime" class="anchor" title="Link to startTime">#</a>
               </h3>
               
               <pre><code>func (t *parsedTrace) startTime() trace.Time</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stat2Color" data-name="stat2Color">
               <h3>
                  stat2Color 
                  <span class="badge">function</span>
                  
                  <a href="#stat2Color" class="anchor" title="Link to stat2Color">#</a>
               </h3>
               
               <pre><code>func stat2Color(statName string) string</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="stop" data-name="stop">
               <h3>
                  stop 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#stop" class="anchor" title="Link to stop">#</a>
               </h3>
               
               <p>stop indicates that the goroutine has stopped executing on a proc.</p>
               
               <pre><code>func (gs **ast.IndexExpr) stop(ts trace.Time, stack trace.Stack, ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syscallBegin" data-name="syscallBegin">
               <h3>
                  syscallBegin 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#syscallBegin" class="anchor" title="Link to syscallBegin">#</a>
               </h3>
               
               <p>syscallBegin indicates that the goroutine entered a syscall on a proc.</p>
               
               <pre><code>func (gs **ast.IndexExpr) syscallBegin(ts trace.Time, resource R, stack trace.Stack)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="syscallEnd" data-name="syscallEnd">
               <h3>
                  syscallEnd 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#syscallEnd" class="anchor" title="Link to syscallEnd">#</a>
               </h3>
               
               <p>syscallEnd ends the syscall slice, wherever the syscall is at. This is orthogonal
to blockedSyscallEnd -- both must be called when a syscall ends and that syscall
blocked. They're kept separate because syscallEnd indicates the point at which the
goroutine is no longer executing on the resource (e.g. a proc) whereas blockedSyscallEnd
is the point at which the goroutine actually exited the syscall regardless of which
resource that happened on.</p>
               
               <pre><code>func (gs **ast.IndexExpr) syscallEnd(ts trace.Time, blocked bool, ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="taskInterval" data-name="taskInterval">
               <h3>
                  taskInterval 
                  <span class="badge">function</span>
                  
                  <a href="#taskInterval" class="anchor" title="Link to taskInterval">#</a>
               </h3>
               
               <pre><code>func taskInterval(t *parsedTrace, s *trace.UserTaskSummary) interval</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="taskMatches" data-name="taskMatches">
               <h3>
                  taskMatches 
                  <span class="badge">function</span>
                  
                  <a href="#taskMatches" class="anchor" title="Link to taskMatches">#</a>
               </h3>
               
               <pre><code>func taskMatches(t *trace.UserTaskSummary, text string) bool</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="unblock" data-name="unblock">
               <h3>
                  unblock 
                  <span class="badge method-badge">method</span>
                  
                  <a href="#unblock" class="anchor" title="Link to unblock">#</a>
               </h3>
               
               <p>unblock indicates that the goroutine gs represents has been unblocked.</p>
               
               <pre><code>func (gs **ast.IndexExpr) unblock(ts trace.Time, stack trace.Stack, resource R, ctx *traceContext)</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="viewerFrames" data-name="viewerFrames">
               <h3>
                  viewerFrames 
                  <span class="badge">function</span>
                  
                  <a href="#viewerFrames" class="anchor" title="Link to viewerFrames">#</a>
               </h3>
               
               <p>viewerFrames returns the frames of the stack of ev. The given frame slice is
used to store the frames to reduce allocations.</p>
               
               <pre><code>func viewerFrames(stk trace.Stack) []*trace.Frame</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="viewerGState" data-name="viewerGState">
               <h3>
                  viewerGState 
                  <span class="badge">function</span>
                  
                  <a href="#viewerGState" class="anchor" title="Link to viewerGState">#</a>
               </h3>
               
               <pre><code>func viewerGState(state trace.GoState, inMarkAssist bool) traceviewer.GState</code></pre>
            </article>
            
            <article class="function symbol-anchor" id="viewerTime" data-name="viewerTime">
               <h3>
                  viewerTime 
                  <span class="badge">function</span>
                  
                  <a href="#viewerTime" class="anchor" title="Link to viewerTime">#</a>
               </h3>
               
               <pre><code>func viewerTime(t time.Duration) float64</code></pre>
            </article>
            
         </section>
         
      </main>

      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }

         function buildSymbolIndex() {
            const symbolIndex = document.getElementById('symbolIndex');
            if (!symbolIndex) return;

            const symbols = [];
            
            document.querySelectorAll('article[data-name]').forEach(article => {
               const name = article.dataset.name;
               const type = article.className.split(' ')[0]; 
               const isPrivateSymbol = isPrivate(name);
               
               if (name && name !== 'imports') {
                  symbols.push({
                     name,
                     type,
                     element: article,
                     isPrivate: isPrivateSymbol
                  });
               }
            });

            symbols.sort((a, b) => a.name.localeCompare(b.name));
            symbolIndex.innerHTML = '';
            symbols.forEach(symbol => {
               const li = document.createElement('li');
               const a = document.createElement('a');
               a.href = `#${symbol.name}`;
               a.textContent = symbol.name;
               a.title = `${symbol.type}: ${symbol.name}`;
               
               if (symbol.isPrivate) {
                  li.classList.add('private', 'hidden');
               }
               
               li.appendChild(a);
               symbolIndex.appendChild(li);
            });
         }

         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               imports: document.getElementById("showImports"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
               types: document.getElementById("showPrivateTypes"),
               interfaces: document.getElementById(
                  "showPrivateInterfaces"
               ),
            };

            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });

               if (toggle) {
                  toggle.addEventListener("change", () => {
                     const show = toggle.checked;
                     document
                        .querySelectorAll(`${selector}.private`)
                        .forEach((el) => {
                           el.classList.toggle("hidden", !show);
                        });
                     
                     const symbolIndexItems = document.querySelectorAll('#symbolIndex li.private');
                     symbolIndexItems.forEach(li => {
                        const link = li.querySelector('a');
                        if (link) {
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           if (targetEl && targetEl.matches(selector)) {
                              li.classList.toggle("hidden", !show);
                           }
                        }
                     });
                  });
               }
            };

            hideInitial("article.imports", toggles.imports);
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            hideInitial("article.type", toggles.types);
            hideInitial("article.interface", toggles.interfaces);

            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch && trimmed != "}") {
                           return `<span class="field-line">${line}</span>`;
                        }
                        if (nameMatch == null) return;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="field-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".field-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            document
               .querySelectorAll("article.interface")
               .forEach((article) => {
                  const codeBlock = article.querySelector(
                     "code.methods-code"
                  );
                  if (!codeBlock) return;

                  const lines = codeBlock.innerHTML.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch) {
                           return `<span class="method-line">${line}</span>`;
                        }

                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class="method-line${
                           isPriv ? " hidden private" : ""
                        }" data-name="${name}">${line}</span>`;
                     })
                     .join("");

                  codeBlock.innerHTML = newContent;

                  if (toggles.fields) {
                     toggles.fields.addEventListener("change", () => {
                        const show = toggles.fields.checked;
                        article
                           .querySelectorAll(".method-line.private")
                           .forEach((el) =>
                              el.classList.toggle("hidden", !show)
                           );
                     });
                  }
               });

            const searchInput = document.getElementById("searchInput");
            if (searchInput) {
               searchInput.addEventListener("input", () => {
                  const query = searchInput.value.trim().toLowerCase();

                  document.querySelectorAll("article").forEach((el) => {
                     const name = el.dataset.name;
                     if (!name) return;

                     const matches =
                        query === "" ||
                        name.toLowerCase().includes(query) ||
                        (el.textContent &&
                           el.textContent.toLowerCase().includes(query));

                     if (matches) {
                        const isPrivateEl =
                           el.classList.contains("private");
                        const shouldShowPrivate =
                           getPrivateToggleState(el);

                        if (!isPrivateEl || shouldShowPrivate) {
                           el.classList.remove("hidden");
                        }
                     } else {
                        el.classList.add("hidden");
                     }
                  });

                  document.querySelectorAll('#symbolIndex li').forEach(li => {
                     const link = li.querySelector('a');
                     if (link) {
                        const symbolName = link.textContent.toLowerCase();
                        const matches = query === "" || symbolName.includes(query);
                        
                        if (matches) {
                           const isPrivateSymbol = li.classList.contains('private');
                           const targetId = link.getAttribute('href').substring(1);
                           const targetEl = document.getElementById(targetId);
                           const shouldShowPrivate = targetEl ? getPrivateToggleState(targetEl) : false;
                           
                           if (!isPrivateSymbol || shouldShowPrivate) {
                              li.style.display = '';
                           }
                        } else {
                           li.style.display = 'none';
                        }
                     }
                  });
               });
            }

            function getPrivateToggleState(element) {
               if (element.classList.contains("function")) {
                  return toggles.functions?.checked || false;
               } else if (element.classList.contains("struct")) {
                  return toggles.structs?.checked || false;
               } else if (element.classList.contains("global")) {
                  return toggles.globals?.checked || false;
               } else if (element.classList.contains("type")) {
                  return toggles.types?.checked || false;
               } else if (element.classList.contains("interface")) {
                  return toggles.interfaces?.checked || false;
               } else if (element.classList.contains("imports")) {
                  return toggles.imports?.checked || false;
               }
               return false;
            }

            buildSymbolIndex();

            document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
               anchor.addEventListener("click", function (e) {
                  const target = document.querySelector(
                     this.getAttribute("href")
                  );
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               });
            });

            window.addEventListener('hashchange', () => {
               const hash = window.location.hash;
               if (hash) {
                  const target = document.querySelector(hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }
            });

            if (window.location.hash) {
               setTimeout(() => {
                  const target = document.querySelector(window.location.hash);
                  if (target) {
                     target.scrollIntoView({
                        behavior: "smooth",
                        block: "start",
                     });
                  }
               }, 100);
            }
         });
      </script>
   </body>
</html>