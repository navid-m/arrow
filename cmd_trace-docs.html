<!DOCTYPE html>
<html lang="en" data-theme="dark">
   <head>
      <meta charset="UTF-8" />
      <meta
         name="viewport"
         content="width=device-width, initial-scale=1.0"
      />
      <title>Docs - main</title>
      <link
         href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css"
         rel="stylesheet"
      />
      <style>
         html {
            font-size: 13px;
         }
         body {
            display: flex;
            min-height: 100vh;
            margin: 0;
         }
         .sidebar {
            width: 200px;
            background: rgba(59, 56, 56, 0.1);
            padding: 1.2rem;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            margin-right: 7px;
         }
         main {
            flex: 0.9;
            padding: 1rem;
            margin: 0;
            max-width: calc(100% - 220px);
         }
         h1 {
            font-size: 1.4rem;
            margin-bottom: 1rem;
         }
         h2 {
            font-size: 1.2rem;
            margin: 0.3rem 0 0.2rem;
         }
         pre {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            margin: 0 0 1rem;
            font-size: 0.85rem;
            overflow-x: auto;
         }
         code {
            color: #f0dbdb;
            white-space: pre-wrap;
         }
         p {
            font-size: 15px;
            padding-top: 10px;
         }
         article {
            margin-bottom: 0.5rem;
            padding: 0.4rem 0.9rem;
            background: rgba(59, 56, 56, 0.5);
            border-radius: 10px;
            max-width: 99%;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
         }
         .hidden {
            display: none;
         }
         .filter-toggle label {
            display: block;
            margin-bottom: 0.5rem;
         }
         .field-line {
            display: block;
         }
      </style>
   </head>
   <body>
      <aside class="sidebar">
         <a href="index.html">⌂</a>
         |
         <a href="#" onclick="history.back()">←</a>
         <hr style="opacity: 0" />
         <h2>Filters</h2>
         <hr />
         <input
            type="search"
            id="searchInput"
            placeholder="Search symbols..."
            style="
               width: 100%;
               margin-bottom: 1rem;
               margin-top: 0.8rem;
               border-radius: 10px !important;
               height: 50px;
               height: 2.5rem;
            "
         />
         <div class="filter-toggle">
            <label>
               <input type="checkbox" id="showPrivateFunctions" />
               Show private functions
            </label>
            <label>
               <input type="checkbox" id="showPrivateStructs" />
               Show private structs
            </label>
            <label>
               <input type="checkbox" id="showPrivateFields" />
               Show private struct fields
            </label>
            <label>
               <input type="checkbox" id="showPrivateGlobals" />
               Show private globals
            </label>
         </div>
         <hr style="opacity: 0" />
         <h2 style="padding-top: 5px">Subpackages</h2>
         <hr />
          
         <a href="cmd_trace_testdata-docs.html">testdata</a>
         <br />
          
      </aside>
      <main>
         <h1>
            Package
            <code>main</code>
         </h1>
         <hr />
         
         <article class="global" data-name="pprofMaxStack">
            <h2>pprofMaxStack</h2>
            <hr />
            
            <p>pprofMaxStack is the extent of the deduplication we're willing to do.

Because slices aren't comparable and we want to leverage maps for deduplication,
we have to choose a fixed constant upper bound on the amount of frames we want
to support. In practice this is fine because there's a maximum depth to these
stacks anyway.</p>
            
            <pre><code>pprofMaxStack</code></pre>
         </article>
         
         <article class="global" data-name="templUserRegionTypes">
            <h2>templUserRegionTypes</h2>
            <hr />
            
            <pre><code>templUserRegionTypes</code></pre>
         </article>
         
         <article class="global" data-name="templUserRegionType">
            <h2>templUserRegionType</h2>
            <hr />
            
            <pre><code>templUserRegionType</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ generator</code></pre>
         </article>
         
         <article class="global" data-name="templGoroutines">
            <h2>templGoroutines</h2>
            <hr />
            
            <pre><code>templGoroutines</code></pre>
         </article>
         
         <article class="global" data-name="templGoroutine">
            <h2>templGoroutine</h2>
            <hr />
            
            <pre><code>templGoroutine</code></pre>
         </article>
         
         <article class="global" data-name="noResource">
            <h2>noResource</h2>
            <hr />
            
            <p>noResource indicates the lack of a resource.</p>
            
            <pre><code>noResource</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ generator</code></pre>
         </article>
         
         <article class="global" data-name="templUserTaskTypes">
            <h2>templUserTaskTypes</h2>
            <hr />
            
            <pre><code>templUserTaskTypes</code></pre>
         </article>
         
         <article class="global" data-name="templUserTaskType">
            <h2>templUserTaskType</h2>
            <hr />
            
            <pre><code>templUserTaskType</code></pre>
         </article>
         
         <article class="global" data-name="_">
            <h2>_</h2>
            <hr />
            
            <pre><code>_ generator</code></pre>
         </article>
         
         <article class="global" data-name="usageMessage">
            <h2>usageMessage</h2>
            <hr />
            
            <pre><code>usageMessage</code></pre>
         </article>
         
         <article class="global" data-name="httpFlag">
            <h2>httpFlag</h2>
            <hr />
            
            <pre><code>httpFlag</code></pre>
         </article>
         
         <article class="global" data-name="pprofFlag">
            <h2>pprofFlag</h2>
            <hr />
            
            <pre><code>pprofFlag</code></pre>
         </article>
         
         <article class="global" data-name="debugFlag">
            <h2>debugFlag</h2>
            <hr />
            
            <pre><code>debugFlag</code></pre>
         </article>
         
         <article class="global" data-name="programBinary">
            <h2>programBinary</h2>
            <hr />
            
            <p>The binary file name, left here for serveSVGProfile.</p>
            
            <pre><code>programBinary string</code></pre>
         </article>
         
         <article class="global" data-name="traceFile">
            <h2>traceFile</h2>
            <hr />
            
            <pre><code>traceFile string</code></pre>
         </article>
          
         <article class="struct" data-name="interval">
            <h2>type interval struct</h2>
            <hr />
            
            <p>interval represents a time interval in the trace.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">start trace.Time
end trace.Time</code></pre>
         </article>
         
         <article class="struct" data-name="stackMap">
            <h2>type stackMap struct</h2>
            <hr />
            
            <p>stackMap is a map of trace.Stack to some value V.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">stacks *ast.MapType
pcs *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="regionFingerprint">
            <h2>type regionFingerprint struct</h2>
            <hr />
            
            <p>regionFingerprint is a way to categorize regions that goes just one step beyond the region's Type
by including the top stack frame.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">Frame trace.StackFrame
Type string</code></pre>
         </article>
         
         <article class="struct" data-name="regionStats">
            <h2>type regionStats struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">regionFingerprint
Histogram traceviewer.TimeHistogram</code></pre>
         </article>
         
         <article class="struct" data-name="regionFilter">
            <h2>type regionFilter struct</h2>
            <hr />
            
            <p>regionFilter represents a region filter specified by a user of cmd/trace.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
params url.Values
cond []func</code></pre>
         </article>
         
         <article class="struct" data-name="threadGenerator">
            <h2>type threadGenerator struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">globalRangeGenerator
globalMetricGenerator
*ast.IndexExpr
*ast.IndexExpr
gStates *ast.MapType
threads *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="stackSampleGenerator">
            <h2>type stackSampleGenerator struct</h2>
            <hr />
            
            <p>stackSampleGenerator implements a generic handler for stack sample events.
The provided resource is the resource the stack sample should count against.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">getResource func</code></pre>
         </article>
         
         <article class="struct" data-name="globalRangeGenerator">
            <h2>type globalRangeGenerator struct</h2>
            <hr />
            
            <p>globalRangeGenerator implements a generic handler for EventRange* events that pertain
to trace.ResourceNone (the global scope).</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ranges *ast.MapType
seenSync bool</code></pre>
         </article>
         
         <article class="struct" data-name="globalMetricGenerator">
            <h2>type globalMetricGenerator struct</h2>
            <hr />
            
            <p>globalMetricGenerator implements a generic handler for Metric events.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code"></code></pre>
         </article>
         
         <article class="struct" data-name="procRangeGenerator">
            <h2>type procRangeGenerator struct</h2>
            <hr />
            
            <p>procRangeGenerator implements a generic handler for EventRange* events whose Scope.Kind is
ResourceProc.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">ranges *ast.MapType
seenSync bool</code></pre>
         </article>
         
         <article class="struct" data-name="activeRange">
            <h2>type activeRange struct</h2>
            <hr />
            
            <p>activeRange represents an active EventRange* range.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">time trace.Time
stack trace.Stack</code></pre>
         </article>
         
         <article class="struct" data-name="completedRange">
            <h2>type completedRange struct</h2>
            <hr />
            
            <p>completedRange represents a completed EventRange* range.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
startTime trace.Time
endTime trace.Time
startStack trace.Stack
endStack trace.Stack
arg any</code></pre>
         </article>
         
         <article class="struct" data-name="logEventGenerator">
            <h2>type logEventGenerator struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">getResource func</code></pre>
         </article>
         
         <article class="struct" data-name="gState">
            <h2>type gState struct</h2>
            <hr />
            
            <p>gState represents the trace viewer state of a goroutine in a trace.

The type parameter on this type is the resource which is used to construct
a timeline of events. e.g. R=ProcID for a proc-oriented view, R=GoID for
a goroutine-oriented view, etc.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">baseName string
named bool
label string
isSystemG bool
executing R
lastStopStack trace.Stack
activeRanges *ast.MapType
completedRanges []completedRange
startRunningTime trace.Time
syscall *ast.StructType
startBlockReason string
startCause *ast.StructType</code></pre>
         </article>
         
         <article class="struct" data-name="traceContext">
            <h2>type traceContext struct</h2>
            <hr />
            
            <p>traceContext is a wrapper around a traceviewer.Emitter with some additional
information that's useful to most parts of trace viewer JSON emission.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">*traceviewer.Emitter
startTime trace.Time
endTime trace.Time</code></pre>
         </article>
         
         <article class="struct" data-name="genOpts">
            <h2>type genOpts struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">mode traceviewer.Mode
startTime time.Duration
endTime time.Duration
focusGoroutine trace.GoID
goroutines *ast.MapType
tasks []*trace.UserTaskSummary</code></pre>
         </article>
         
         <article class="struct" data-name="procGenerator">
            <h2>type procGenerator struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">globalRangeGenerator
globalMetricGenerator
procRangeGenerator
*ast.IndexExpr
*ast.IndexExpr
gStates *ast.MapType
inSyscall *ast.MapType
maxProc trace.ProcID</code></pre>
         </article>
         
         <article class="struct" data-name="taskStats">
            <h2>type taskStats struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">Type string
Count int
Histogram traceviewer.TimeHistogram</code></pre>
         </article>
         
         <article class="struct" data-name="taskFilter">
            <h2>type taskFilter struct</h2>
            <hr />
            
            <p>taskFilter represents a task filter specified by a user of cmd/trace.</p>
            
            <pre
               class="fields-block"
            ><code class="fields-code">name string
cond []func</code></pre>
         </article>
         
         <article class="struct" data-name="goroutineGenerator">
            <h2>type goroutineGenerator struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">globalRangeGenerator
globalMetricGenerator
*ast.IndexExpr
*ast.IndexExpr
gStates *ast.MapType
focus trace.GoID
filter *ast.MapType</code></pre>
         </article>
         
         <article class="struct" data-name="parsedTrace">
            <h2>type parsedTrace struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">events []trace.Event
summary *trace.Summary
size int64
valid int64
err error</code></pre>
         </article>
         
         <article class="struct" data-name="countingReader">
            <h2>type countingReader struct</h2>
            <hr />
            
            <pre
               class="fields-block"
            ><code class="fields-code">r io.Reader
bytesRead atomic.Int64</code></pre>
         </article>
          
         <article class="function" data-name="pprofByGoroutine">
            <h2>pprofByGoroutine</h2>
            <hr />
            
            <pre><code>func pprofByGoroutine(compute computePprofFunc, t *parsedTrace) traceviewer.ProfileFunc</code></pre>
         </article>
         
         <article class="function" data-name="pprofByRegion">
            <h2>pprofByRegion</h2>
            <hr />
            
            <pre><code>func pprofByRegion(compute computePprofFunc, t *parsedTrace) traceviewer.ProfileFunc</code></pre>
         </article>
         
         <article class="function" data-name="pprofMatchingGoroutines">
            <h2>pprofMatchingGoroutines</h2>
            <hr />
            
            <p>pprofMatchingGoroutines returns the ids of goroutines of the matching name and its interval.
If the id string is empty, returns nil without an error.</p>
            
            <pre><code>func pprofMatchingGoroutines(name string, t *parsedTrace) (*ast.MapType, error)</code></pre>
         </article>
         
         <article class="function" data-name="pprofMatchingRegions">
            <h2>pprofMatchingRegions</h2>
            <hr />
            
            <p>pprofMatchingRegions returns the time intervals of matching regions
grouped by the goroutine id. If the filter is nil, returns nil without an error.</p>
            
            <pre><code>func pprofMatchingRegions(filter *regionFilter, t *parsedTrace) (*ast.MapType, error)</code></pre>
         </article>
         
         <article class="function" data-name="computePprofIO">
            <h2>computePprofIO</h2>
            <hr />
            
            <p>computePprofIO returns a computePprofFunc that generates IO pprof-like profile (time spent in
IO wait, currently only network blocking event).</p>
            
            <pre><code>func computePprofIO() computePprofFunc</code></pre>
         </article>
         
         <article class="function" data-name="computePprofBlock">
            <h2>computePprofBlock</h2>
            <hr />
            
            <p>computePprofBlock returns a computePprofFunc that generates blocking pprof-like profile
(time spent blocked on synchronization primitives).</p>
            
            <pre><code>func computePprofBlock() computePprofFunc</code></pre>
         </article>
         
         <article class="function" data-name="computePprofSyscall">
            <h2>computePprofSyscall</h2>
            <hr />
            
            <p>computePprofSyscall returns a computePprofFunc that generates a syscall pprof-like
profile (time spent in syscalls).</p>
            
            <pre><code>func computePprofSyscall() computePprofFunc</code></pre>
         </article>
         
         <article class="function" data-name="computePprofSched">
            <h2>computePprofSched</h2>
            <hr />
            
            <p>computePprofSched returns a computePprofFunc that generates a scheduler latency pprof-like profile
(time between a goroutine become runnable and actually scheduled for execution).</p>
            
            <pre><code>func computePprofSched() computePprofFunc</code></pre>
         </article>
         
         <article class="function" data-name="makeComputePprofFunc">
            <h2>makeComputePprofFunc</h2>
            <hr />
            
            <p>makeComputePprofFunc returns a computePprofFunc that generates a profile of time goroutines spend
in a particular state for the specified reasons.</p>
            
            <pre><code>func makeComputePprofFunc(state trace.GoState, trackReason func) computePprofFunc</code></pre>
         </article>
         
         <article class="function" data-name="pprofOverlappingDuration">
            <h2>pprofOverlappingDuration</h2>
            <hr />
            
            <p>pprofOverlappingDuration returns the overlapping duration between
the time intervals in gToIntervals and the specified event.
If gToIntervals is nil, this simply returns the event's duration.</p>
            
            <pre><code>func pprofOverlappingDuration(gToIntervals *ast.MapType, id trace.GoID, sample interval) time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="duration">
            <h2>duration</h2>
            <hr />
            
            <pre><code>func duration() time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="overlap">
            <h2>overlap</h2>
            <hr />
            
            <pre><code>func overlap(i2 interval) time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="newStackMap">
            <h2>newStackMap</h2>
            <hr />
            
            <pre><code>func newStackMap() *stackMap</code></pre>
         </article>
         
         <article class="function" data-name="getOrAdd">
            <h2>getOrAdd</h2>
            <hr />
            
            <pre><code>func getOrAdd(stack trace.Stack) *traceviewer.ProfileRecord</code></pre>
         </article>
         
         <article class="function" data-name="profile">
            <h2>profile</h2>
            <hr />
            
            <pre><code>func profile() []traceviewer.ProfileRecord</code></pre>
         </article>
         
         <article class="function" data-name="pcsForStack">
            <h2>pcsForStack</h2>
            <hr />
            
            <p>pcsForStack extracts the first pprofMaxStack PCs from stack into pcs.</p>
            
            <pre><code>func pcsForStack(stack trace.Stack, pcs *[]uint64)</code></pre>
         </article>
         
         <article class="function" data-name="UserRegionsHandlerFunc">
            <h2>UserRegionsHandlerFunc</h2>
            <hr />
            
            <p>UserRegionsHandlerFunc returns a HandlerFunc that reports all regions found in the trace.</p>
            
            <pre><code>func UserRegionsHandlerFunc(t *parsedTrace) http.HandlerFunc</code></pre>
         </article>
         
         <article class="function" data-name="fingerprintRegion">
            <h2>fingerprintRegion</h2>
            <hr />
            
            <pre><code>func fingerprintRegion(r *trace.UserRegionSummary) regionFingerprint</code></pre>
         </article>
         
         <article class="function" data-name="regionTopStackFrame">
            <h2>regionTopStackFrame</h2>
            <hr />
            
            <pre><code>func regionTopStackFrame(r *trace.UserRegionSummary) trace.StackFrame</code></pre>
         </article>
         
         <article class="function" data-name="UserRegionURL">
            <h2>UserRegionURL</h2>
            <hr />
            
            <pre><code>func UserRegionURL() func</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <pre><code>func add(t *parsedTrace, region *trace.UserRegionSummary)</code></pre>
         </article>
         
         <article class="function" data-name="UserRegionHandlerFunc">
            <h2>UserRegionHandlerFunc</h2>
            <hr />
            
            <p>UserRegionHandlerFunc returns a HandlerFunc that presents the details of the selected regions.</p>
            
            <pre><code>func UserRegionHandlerFunc(t *parsedTrace) http.HandlerFunc</code></pre>
         </article>
         
         <article class="function" data-name="match">
            <h2>match</h2>
            <hr />
            
            <p>match returns true if a region, described by its ID and summary, matches
the filter.</p>
            
            <pre><code>func match(t *parsedTrace, s *trace.UserRegionSummary) bool</code></pre>
         </article>
         
         <article class="function" data-name="newRegionFilter">
            <h2>newRegionFilter</h2>
            <hr />
            
            <p>newRegionFilter creates a new region filter from URL query variables.</p>
            
            <pre><code>func newRegionFilter(r *http.Request) (*regionFilter, error)</code></pre>
         </article>
         
         <article class="function" data-name="regionInterval">
            <h2>regionInterval</h2>
            <hr />
            
            <pre><code>func regionInterval(t *parsedTrace, s *trace.UserRegionSummary) interval</code></pre>
         </article>
         
         <article class="function" data-name="newThreadGenerator">
            <h2>newThreadGenerator</h2>
            <hr />
            
            <pre><code>func newThreadGenerator() *threadGenerator</code></pre>
         </article>
         
         <article class="function" data-name="Sync">
            <h2>Sync</h2>
            <hr />
            
            <pre><code>func Sync()</code></pre>
         </article>
         
         <article class="function" data-name="GoroutineLabel">
            <h2>GoroutineLabel</h2>
            <hr />
            
            <pre><code>func GoroutineLabel(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="GoroutineRange">
            <h2>GoroutineRange</h2>
            <hr />
            
            <pre><code>func GoroutineRange(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="GoroutineTransition">
            <h2>GoroutineTransition</h2>
            <hr />
            
            <pre><code>func GoroutineTransition(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="ProcTransition">
            <h2>ProcTransition</h2>
            <hr />
            
            <pre><code>func ProcTransition(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="ProcRange">
            <h2>ProcRange</h2>
            <hr />
            
            <pre><code>func ProcRange(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="Finish">
            <h2>Finish</h2>
            <hr />
            
            <pre><code>func Finish(ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="runGenerator">
            <h2>runGenerator</h2>
            <hr />
            
            <p>runGenerator produces a trace into ctx by running the generator over the parsed trace.</p>
            
            <pre><code>func runGenerator(ctx *traceContext, g generator, parsed *parsedTrace, opts *genOpts)</code></pre>
         </article>
         
         <article class="function" data-name="emitTask">
            <h2>emitTask</h2>
            <hr />
            
            <p>emitTask emits information about a task into the trace viewer's event stream.

sortIndex sets the order in which this task will appear related to other tasks,
lowest first.</p>
            
            <pre><code>func emitTask(ctx *traceContext, task *trace.UserTaskSummary, sortIndex int)</code></pre>
         </article>
         
         <article class="function" data-name="emitRegion">
            <h2>emitRegion</h2>
            <hr />
            
            <p>emitRegion emits goroutine-based slice events to the UI. The caller
must be emitting for a goroutine-oriented trace.

TODO(mknyszek): Make regions part of the regular generator loop and
treat them like ranges so that we can emit regions in traces oriented
by proc or thread.</p>
            
            <pre><code>func emitRegion(ctx *traceContext, region *trace.UserRegionSummary)</code></pre>
         </article>
         
         <article class="function" data-name="StackSample">
            <h2>StackSample</h2>
            <hr />
            
            <p>StackSample implements a stack sample event handler. It expects ev to be one such event.</p>
            
            <pre><code>func StackSample(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="Sync">
            <h2>Sync</h2>
            <hr />
            
            <p>Sync notifies the generator of an EventSync event.</p>
            
            <pre><code>func Sync()</code></pre>
         </article>
         
         <article class="function" data-name="GlobalRange">
            <h2>GlobalRange</h2>
            <hr />
            
            <p>GlobalRange implements a handler for EventRange* events whose Scope.Kind is ResourceNone.
It expects ev to be one such event.</p>
            
            <pre><code>func GlobalRange(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="Finish">
            <h2>Finish</h2>
            <hr />
            
            <p>Finish flushes any outstanding ranges at the end of the trace.</p>
            
            <pre><code>func Finish(ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="GlobalMetric">
            <h2>GlobalMetric</h2>
            <hr />
            
            <p>GlobalMetric implements an event handler for EventMetric events. ev must be one such event.</p>
            
            <pre><code>func GlobalMetric(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="Sync">
            <h2>Sync</h2>
            <hr />
            
            <p>Sync notifies the generator of an EventSync event.</p>
            
            <pre><code>func Sync()</code></pre>
         </article>
         
         <article class="function" data-name="ProcRange">
            <h2>ProcRange</h2>
            <hr />
            
            <p>ProcRange implements a handler for EventRange* events whose Scope.Kind is ResourceProc.
It expects ev to be one such event.</p>
            
            <pre><code>func ProcRange(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="Finish">
            <h2>Finish</h2>
            <hr />
            
            <p>Finish flushes any outstanding ranges at the end of the trace.</p>
            
            <pre><code>func Finish(ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="Log">
            <h2>Log</h2>
            <hr />
            
            <p>Log implements a log event handler. It expects ev to be one such event.</p>
            
            <pre><code>func Log(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="GoroutinesHandlerFunc">
            <h2>GoroutinesHandlerFunc</h2>
            <hr />
            
            <p>GoroutinesHandlerFunc returns a HandlerFunc that serves list of goroutine groups.</p>
            
            <pre><code>func GoroutinesHandlerFunc(summaries *ast.MapType) http.HandlerFunc</code></pre>
         </article>
         
         <article class="function" data-name="GoroutineHandler">
            <h2>GoroutineHandler</h2>
            <hr />
            
            <p>GoroutineHandler creates a handler that serves information about
goroutines in a particular group.</p>
            
            <pre><code>func GoroutineHandler(summaries *ast.MapType) http.HandlerFunc</code></pre>
         </article>
         
         <article class="function" data-name="stat2Color">
            <h2>stat2Color</h2>
            <hr />
            
            <pre><code>func stat2Color(statName string) string</code></pre>
         </article>
         
         <article class="function" data-name="newGState">
            <h2>newGState</h2>
            <hr />
            
            <p>newGState constructs a new goroutine state for the goroutine
identified by the provided ID.</p>
            
            <pre><code>func newGState(goID trace.GoID) **ast.IndexExpr</code></pre>
         </article>
         
         <article class="function" data-name="augmentName">
            <h2>augmentName</h2>
            <hr />
            
            <p>augmentName attempts to use stk to augment the name of the goroutine
with stack information. This stack must be related to the goroutine
in some way, but it doesn't really matter which stack.</p>
            
            <pre><code>func augmentName(stk trace.Stack)</code></pre>
         </article>
         
         <article class="function" data-name="setLabel">
            <h2>setLabel</h2>
            <hr />
            
            <p>setLabel adds an additional label to the goroutine's name.</p>
            
            <pre><code>func setLabel(label string)</code></pre>
         </article>
         
         <article class="function" data-name="name">
            <h2>name</h2>
            <hr />
            
            <p>name returns a name for the goroutine.</p>
            
            <pre><code>func name() string</code></pre>
         </article>
         
         <article class="function" data-name="setStartCause">
            <h2>setStartCause</h2>
            <hr />
            
            <p>setStartCause sets the reason a goroutine will be allowed to start soon.
For example, via unblocking or exiting a blocked syscall.</p>
            
            <pre><code>func setStartCause(ts trace.Time, name string, resource uint64, stack trace.Stack)</code></pre>
         </article>
         
         <article class="function" data-name="created">
            <h2>created</h2>
            <hr />
            
            <p>created indicates that this goroutine was just created by the provided creator.</p>
            
            <pre><code>func created(ts trace.Time, creator R, stack trace.Stack)</code></pre>
         </article>
         
         <article class="function" data-name="start">
            <h2>start</h2>
            <hr />
            
            <p>start indicates that a goroutine has started running on a proc.</p>
            
            <pre><code>func start(ts trace.Time, resource R, ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="syscallBegin">
            <h2>syscallBegin</h2>
            <hr />
            
            <p>syscallBegin indicates that the goroutine entered a syscall on a proc.</p>
            
            <pre><code>func syscallBegin(ts trace.Time, resource R, stack trace.Stack)</code></pre>
         </article>
         
         <article class="function" data-name="syscallEnd">
            <h2>syscallEnd</h2>
            <hr />
            
            <p>syscallEnd ends the syscall slice, wherever the syscall is at. This is orthogonal
to blockedSyscallEnd -- both must be called when a syscall ends and that syscall
blocked. They're kept separate because syscallEnd indicates the point at which the
goroutine is no longer executing on the resource (e.g. a proc) whereas blockedSyscallEnd
is the point at which the goroutine actually exited the syscall regardless of which
resource that happened on.</p>
            
            <pre><code>func syscallEnd(ts trace.Time, blocked bool, ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="blockedSyscallEnd">
            <h2>blockedSyscallEnd</h2>
            <hr />
            
            <p>blockedSyscallEnd indicates the point at which the blocked syscall ended. This is distinct
and orthogonal to syscallEnd; both must be called if the syscall blocked. This sets up an instant
to emit a flow event from, indicating explicitly that this goroutine was unblocked by the system.</p>
            
            <pre><code>func blockedSyscallEnd(ts trace.Time, stack trace.Stack, ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="unblock">
            <h2>unblock</h2>
            <hr />
            
            <p>unblock indicates that the goroutine gs represents has been unblocked.</p>
            
            <pre><code>func unblock(ts trace.Time, stack trace.Stack, resource R, ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="block">
            <h2>block</h2>
            <hr />
            
            <p>block indicates that the goroutine has stopped executing on a proc -- specifically,
it blocked for some reason.</p>
            
            <pre><code>func block(ts trace.Time, stack trace.Stack, reason string, ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="stop">
            <h2>stop</h2>
            <hr />
            
            <p>stop indicates that the goroutine has stopped executing on a proc.</p>
            
            <pre><code>func stop(ts trace.Time, stack trace.Stack, ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="finish">
            <h2>finish</h2>
            <hr />
            
            <p>finalize writes out any in-progress slices as if the goroutine stopped.
This must only be used once the trace has been fully processed and no
further events will be processed. This method may leave the gState in
an inconsistent state.</p>
            
            <pre><code>func finish(ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="rangeBegin">
            <h2>rangeBegin</h2>
            <hr />
            
            <p>rangeBegin indicates the start of a special range of time.</p>
            
            <pre><code>func rangeBegin(ts trace.Time, name string, stack trace.Stack)</code></pre>
         </article>
         
         <article class="function" data-name="rangeActive">
            <h2>rangeActive</h2>
            <hr />
            
            <p>rangeActive indicates that a special range of time has been in progress.</p>
            
            <pre><code>func rangeActive(name string)</code></pre>
         </article>
         
         <article class="function" data-name="rangeEnd">
            <h2>rangeEnd</h2>
            <hr />
            
            <p>rangeEnd indicates the end of a special range of time.</p>
            
            <pre><code>func rangeEnd(ts trace.Time, name string, stack trace.Stack, ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="lastFunc">
            <h2>lastFunc</h2>
            <hr />
            
            <pre><code>func lastFunc(s trace.Stack) fn string</code></pre>
         </article>
         
         <article class="function" data-name="JSONTraceHandler">
            <h2>JSONTraceHandler</h2>
            <hr />
            
            <pre><code>func JSONTraceHandler(parsed *parsedTrace) http.Handler</code></pre>
         </article>
         
         <article class="function" data-name="elapsed">
            <h2>elapsed</h2>
            <hr />
            
            <p>elapsed returns the elapsed time between the trace time and the start time
of the trace.</p>
            
            <pre><code>func elapsed(now trace.Time) time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="setTask">
            <h2>setTask</h2>
            <hr />
            
            <p>setTask sets a task to focus on.</p>
            
            <pre><code>func setTask(parsed *parsedTrace, task *trace.UserTaskSummary)</code></pre>
         </article>
         
         <article class="function" data-name="defaultGenOpts">
            <h2>defaultGenOpts</h2>
            <hr />
            
            <pre><code>func defaultGenOpts() *genOpts</code></pre>
         </article>
         
         <article class="function" data-name="generateTrace">
            <h2>generateTrace</h2>
            <hr />
            
            <pre><code>func generateTrace(parsed *parsedTrace, opts *genOpts, c traceviewer.TraceConsumer) error</code></pre>
         </article>
         
         <article class="function" data-name="newProcGenerator">
            <h2>newProcGenerator</h2>
            <hr />
            
            <pre><code>func newProcGenerator() *procGenerator</code></pre>
         </article>
         
         <article class="function" data-name="Sync">
            <h2>Sync</h2>
            <hr />
            
            <pre><code>func Sync()</code></pre>
         </article>
         
         <article class="function" data-name="GoroutineLabel">
            <h2>GoroutineLabel</h2>
            <hr />
            
            <pre><code>func GoroutineLabel(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="GoroutineRange">
            <h2>GoroutineRange</h2>
            <hr />
            
            <pre><code>func GoroutineRange(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="GoroutineTransition">
            <h2>GoroutineTransition</h2>
            <hr />
            
            <pre><code>func GoroutineTransition(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="ProcTransition">
            <h2>ProcTransition</h2>
            <hr />
            
            <pre><code>func ProcTransition(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="Finish">
            <h2>Finish</h2>
            <hr />
            
            <pre><code>func Finish(ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="UserTasksHandlerFunc">
            <h2>UserTasksHandlerFunc</h2>
            <hr />
            
            <p>UserTasksHandlerFunc returns a HandlerFunc that reports all tasks found in the trace.</p>
            
            <pre><code>func UserTasksHandlerFunc(t *parsedTrace) http.HandlerFunc</code></pre>
         </article>
         
         <article class="function" data-name="UserTaskURL">
            <h2>UserTaskURL</h2>
            <hr />
            
            <pre><code>func UserTaskURL(complete bool) func</code></pre>
         </article>
         
         <article class="function" data-name="add">
            <h2>add</h2>
            <hr />
            
            <pre><code>func add(task *trace.UserTaskSummary)</code></pre>
         </article>
         
         <article class="function" data-name="UserTaskHandlerFunc">
            <h2>UserTaskHandlerFunc</h2>
            <hr />
            
            <p>UserTaskHandlerFunc returns a HandlerFunc that presents the details of the selected tasks.</p>
            
            <pre><code>func UserTaskHandlerFunc(t *parsedTrace) http.HandlerFunc</code></pre>
         </article>
         
         <article class="function" data-name="match">
            <h2>match</h2>
            <hr />
            
            <p>match returns true if a task, described by its ID and summary, matches
the filter.</p>
            
            <pre><code>func match(t *parsedTrace, task *trace.UserTaskSummary) bool</code></pre>
         </article>
         
         <article class="function" data-name="newTaskFilter">
            <h2>newTaskFilter</h2>
            <hr />
            
            <p>newTaskFilter creates a new task filter from URL query variables.</p>
            
            <pre><code>func newTaskFilter(r *http.Request) (*taskFilter, error)</code></pre>
         </article>
         
         <article class="function" data-name="taskInterval">
            <h2>taskInterval</h2>
            <hr />
            
            <pre><code>func taskInterval(t *parsedTrace, s *trace.UserTaskSummary) interval</code></pre>
         </article>
         
         <article class="function" data-name="taskMatches">
            <h2>taskMatches</h2>
            <hr />
            
            <pre><code>func taskMatches(t *trace.UserTaskSummary, text string) bool</code></pre>
         </article>
         
         <article class="function" data-name="describeEvent">
            <h2>describeEvent</h2>
            <hr />
            
            <pre><code>func describeEvent(ev *trace.Event) string</code></pre>
         </article>
         
         <article class="function" data-name="primaryGoroutine">
            <h2>primaryGoroutine</h2>
            <hr />
            
            <pre><code>func primaryGoroutine(ev *trace.Event) trace.GoID</code></pre>
         </article>
         
         <article class="function" data-name="elapsed">
            <h2>elapsed</h2>
            <hr />
            
            <pre><code>func elapsed(d time.Duration) string</code></pre>
         </article>
         
         <article class="function" data-name="asMillisecond">
            <h2>asMillisecond</h2>
            <hr />
            
            <pre><code>func asMillisecond(d time.Duration) float64</code></pre>
         </article>
         
         <article class="function" data-name="viewerFrames">
            <h2>viewerFrames</h2>
            <hr />
            
            <p>viewerFrames returns the frames of the stack of ev. The given frame slice is
used to store the frames to reduce allocations.</p>
            
            <pre><code>func viewerFrames(stk trace.Stack) []*trace.Frame</code></pre>
         </article>
         
         <article class="function" data-name="viewerGState">
            <h2>viewerGState</h2>
            <hr />
            
            <pre><code>func viewerGState(state trace.GoState, inMarkAssist bool) traceviewer.GState</code></pre>
         </article>
         
         <article class="function" data-name="viewerTime">
            <h2>viewerTime</h2>
            <hr />
            
            <pre><code>func viewerTime(t time.Duration) float64</code></pre>
         </article>
         
         <article class="function" data-name="newGoroutineGenerator">
            <h2>newGoroutineGenerator</h2>
            <hr />
            
            <pre><code>func newGoroutineGenerator(ctx *traceContext, focus trace.GoID, filter *ast.MapType) *goroutineGenerator</code></pre>
         </article>
         
         <article class="function" data-name="Sync">
            <h2>Sync</h2>
            <hr />
            
            <pre><code>func Sync()</code></pre>
         </article>
         
         <article class="function" data-name="GoroutineLabel">
            <h2>GoroutineLabel</h2>
            <hr />
            
            <pre><code>func GoroutineLabel(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="GoroutineRange">
            <h2>GoroutineRange</h2>
            <hr />
            
            <pre><code>func GoroutineRange(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="GoroutineTransition">
            <h2>GoroutineTransition</h2>
            <hr />
            
            <pre><code>func GoroutineTransition(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="ProcRange">
            <h2>ProcRange</h2>
            <hr />
            
            <pre><code>func ProcRange(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="ProcTransition">
            <h2>ProcTransition</h2>
            <hr />
            
            <pre><code>func ProcTransition(ctx *traceContext, ev *trace.Event)</code></pre>
         </article>
         
         <article class="function" data-name="Finish">
            <h2>Finish</h2>
            <hr />
            
            <pre><code>func Finish(ctx *traceContext)</code></pre>
         </article>
         
         <article class="function" data-name="TestJSONTraceHandler">
            <h2>TestJSONTraceHandler</h2>
            <hr />
            
            <pre><code>func TestJSONTraceHandler(t *testing.T)</code></pre>
         </article>
         
         <article class="function" data-name="checkSyscalls">
            <h2>checkSyscalls</h2>
            <hr />
            
            <pre><code>func checkSyscalls(t *testing.T, data format.Data)</code></pre>
         </article>
         
         <article class="function" data-name="filterEventName">
            <h2>filterEventName</h2>
            <hr />
            
            <pre><code>func filterEventName(name string) eventFilterFn</code></pre>
         </article>
         
         <article class="function" data-name="filterGoRoutineName">
            <h2>filterGoRoutineName</h2>
            <hr />
            
            <p>filterGoRoutineName returns an event filter that returns true if the event's
goroutine name is equal to name.</p>
            
            <pre><code>func filterGoRoutineName(name string) eventFilterFn</code></pre>
         </article>
         
         <article class="function" data-name="parseGoroutineName">
            <h2>parseGoroutineName</h2>
            <hr />
            
            <p>parseGoroutineName returns the goroutine name from the event's name field.
E.g. if e.Name is "G42 main.cpu10", this returns "main.cpu10".</p>
            
            <pre><code>func parseGoroutineName(e *format.Event) string</code></pre>
         </article>
         
         <article class="function" data-name="filterBlocked">
            <h2>filterBlocked</h2>
            <hr />
            
            <p>filterBlocked returns an event filter that returns true if the event's
"blocked" argument is equal to blocked.</p>
            
            <pre><code>func filterBlocked(blocked string) eventFilterFn</code></pre>
         </article>
         
         <article class="function" data-name="filterStackRootFunc">
            <h2>filterStackRootFunc</h2>
            <hr />
            
            <p>filterStackRootFunc returns an event filter that returns true if the function
at the root of the stack trace is named name.</p>
            
            <pre><code>func filterStackRootFunc(name string) eventFilterFn</code></pre>
         </article>
         
         <article class="function" data-name="filterViewerTrace">
            <h2>filterViewerTrace</h2>
            <hr />
            
            <p>filterViewerTrace returns a copy of data with only the events that pass all
of the given filters.</p>
            
            <pre><code>func filterViewerTrace(data format.Data, fns ...eventFilterFn) filtered format.Data</code></pre>
         </article>
         
         <article class="function" data-name="stackFrames">
            <h2>stackFrames</h2>
            <hr />
            
            <pre><code>func stackFrames(data *format.Data, stackID int) frames []string</code></pre>
         </article>
         
         <article class="function" data-name="checkProcStartStop">
            <h2>checkProcStartStop</h2>
            <hr />
            
            <pre><code>func checkProcStartStop(t *testing.T, data format.Data)</code></pre>
         </article>
         
         <article class="function" data-name="checkNetworkUnblock">
            <h2>checkNetworkUnblock</h2>
            <hr />
            
            <pre><code>func checkNetworkUnblock(t *testing.T, data format.Data)</code></pre>
         </article>
         
         <article class="function" data-name="checkExecutionTimes">
            <h2>checkExecutionTimes</h2>
            <hr />
            
            <pre><code>func checkExecutionTimes(t *testing.T, data format.Data)</code></pre>
         </article>
         
         <article class="function" data-name="checkMetaNamesEmitted">
            <h2>checkMetaNamesEmitted</h2>
            <hr />
            
            <pre><code>func checkMetaNamesEmitted(t *testing.T, data format.Data, category string, want []string)</code></pre>
         </article>
         
         <article class="function" data-name="metaEventNameArgs">
            <h2>metaEventNameArgs</h2>
            <hr />
            
            <pre><code>func metaEventNameArgs(category string, data format.Data) names []string</code></pre>
         </article>
         
         <article class="function" data-name="checkPlausibleHeapMetrics">
            <h2>checkPlausibleHeapMetrics</h2>
            <hr />
            
            <pre><code>func checkPlausibleHeapMetrics(t *testing.T, data format.Data)</code></pre>
         </article>
         
         <article class="function" data-name="heapMetrics">
            <h2>heapMetrics</h2>
            <hr />
            
            <pre><code>func heapMetrics(data format.Data) metrics []format.HeapCountersArg</code></pre>
         </article>
         
         <article class="function" data-name="recordJSONTraceHandlerResponse">
            <h2>recordJSONTraceHandlerResponse</h2>
            <hr />
            
            <pre><code>func recordJSONTraceHandlerResponse(t *testing.T, parsed *parsedTrace) format.Data</code></pre>
         </article>
         
         <article class="function" data-name="sumExecutionTime">
            <h2>sumExecutionTime</h2>
            <hr />
            
            <pre><code>func sumExecutionTime(data format.Data) sum time.Duration</code></pre>
         </article>
         
         <article class="function" data-name="getTestTrace">
            <h2>getTestTrace</h2>
            <hr />
            
            <pre><code>func getTestTrace(t *testing.T, testPath string) *parsedTrace</code></pre>
         </article>
         
         <article class="function" data-name="main">
            <h2>main</h2>
            <hr />
            
            <pre><code>func main()</code></pre>
         </article>
         
         <article class="function" data-name="logAndDie">
            <h2>logAndDie</h2>
            <hr />
            
            <pre><code>func logAndDie(err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseTraceInteractive">
            <h2>parseTraceInteractive</h2>
            <hr />
            
            <pre><code>func parseTraceInteractive(tr io.Reader, size int64) (parsed *parsedTrace, err error)</code></pre>
         </article>
         
         <article class="function" data-name="parseTrace">
            <h2>parseTrace</h2>
            <hr />
            
            <pre><code>func parseTrace(rr io.Reader, size int64) (*parsedTrace, error)</code></pre>
         </article>
         
         <article class="function" data-name="startTime">
            <h2>startTime</h2>
            <hr />
            
            <pre><code>func startTime() trace.Time</code></pre>
         </article>
         
         <article class="function" data-name="endTime">
            <h2>endTime</h2>
            <hr />
            
            <pre><code>func endTime() trace.Time</code></pre>
         </article>
         
         <article class="function" data-name="splitTrace">
            <h2>splitTrace</h2>
            <hr />
            
            <p>splitTrace splits the trace into a number of ranges, each resulting in approx 100 MiB of
json output (the trace viewer can hardly handle more).</p>
            
            <pre><code>func splitTrace(parsed *parsedTrace) ([]traceviewer.Range, error)</code></pre>
         </article>
         
         <article class="function" data-name="debugProcessedEvents">
            <h2>debugProcessedEvents</h2>
            <hr />
            
            <pre><code>func debugProcessedEvents(trc io.Reader) error</code></pre>
         </article>
         
         <article class="function" data-name="debugRawEvents">
            <h2>debugRawEvents</h2>
            <hr />
            
            <pre><code>func debugRawEvents(trc io.Reader) error</code></pre>
         </article>
         
         <article class="function" data-name="debugEventsFootprint">
            <h2>debugEventsFootprint</h2>
            <hr />
            
            <pre><code>func debugEventsFootprint(trc io.Reader) error</code></pre>
         </article>
         
         <article class="function" data-name="Read">
            <h2>Read</h2>
            <hr />
            
            <pre><code>func Read(buf []byte) (n int, err error)</code></pre>
         </article>
         
         <article class="function" data-name="String">
            <h2>String</h2>
            <hr />
            
            <pre><code>func String() string</code></pre>
         </article>
         
      </main>
      <script>
         function isPrivate(name) {
            return /^[a-z]/.test(name);
         }
         document.addEventListener("DOMContentLoaded", () => {
            const toggles = {
               functions: document.getElementById("showPrivateFunctions"),
               structs: document.getElementById("showPrivateStructs"),
               fields: document.getElementById("showPrivateFields"),
               globals: document.getElementById("showPrivateGlobals"),
            };
            const hideInitial = (selector, toggle) => {
               document.querySelectorAll(selector).forEach((el) => {
                  const name = el.dataset.name;
                  if (isPrivate(name)) {
                     el.classList.add("private", "hidden");
                  }
               });
               toggle.addEventListener("change", () => {
                  const show = toggle.checked;
                  document
                     .querySelectorAll(`${selector}.private`)
                     .forEach((el) => {
                        el.classList.toggle("hidden", !show);
                     });
               });
            };
            hideInitial("article.function", toggles.functions);
            hideInitial("article.struct", toggles.structs);
            hideInitial("article.global", toggles.globals);
            document
               .querySelectorAll("article.struct")
               .forEach((article) => {
                  const codeBlock =
                     article.querySelector("code.fields-code");
                  if (!codeBlock) return;
                  const lines = codeBlock.innerText.split("\n");
                  const newContent = lines
                     .map((line) => {
                        const trimmed = line.trim();
                        const nameMatch = trimmed.match(
                           /^([A-Za-z_][A-Za-z0-9_]*)/
                        );
                        if (!nameMatch)
                           return `<span class=\"field-line\">${line}</span>`;
                        const name = nameMatch[1];
                        const isPriv = isPrivate(name);
                        return `<span class=\"field-line${
                           isPriv ? " hidden private" : ""
                        }\" data-name=\"${name}\">${line}</span>`;
                     })
                     .join("");
                  codeBlock.innerHTML = newContent;
                  toggles.fields.addEventListener("change", () => {
                     const show = toggles.fields.checked;
                     article
                        .querySelectorAll(".field-line.private")
                        .forEach((el) =>
                           el.classList.toggle("hidden", !show)
                        );
                  });
               });
            const searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", () => {
               const query = searchInput.value.trim().toLowerCase();
               document.querySelectorAll("article").forEach((el) => {
                  const name = el.dataset.name.toLowerCase();
                  if (query === "" || name.includes(query)) {
                     el.classList.remove("hidden");
                  } else {
                     el.classList.add("hidden");
                  }
               });
            });
         });
      </script>
   </body>
</html>
